ir_function_signature *
fabs64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000B);
   body.emit(assign(r000B, bit_and(swizzle_y(r000B), body.constant(2147483647u)), 0x02));

   body.emit(ret(r000B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
is_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000C);
   ir_expression *const r000D = lshift(swizzle_y(r000C), body.constant(int(1)));
   ir_expression *const r000E = lequal(body.constant(4292870144u), r000D);
   ir_expression *const r000F = nequal(swizzle_x(r000C), body.constant(0u));
   ir_expression *const r0010 = bit_and(swizzle_y(r000C), body.constant(1048575u));
   ir_expression *const r0011 = nequal(r0010, body.constant(0u));
   ir_expression *const r0012 = logic_or(r000F, r0011);
   ir_expression *const r0013 = logic_and(r000E, r0012);
   body.emit(ret(r0013));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fneg64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0014 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0014);
   ir_variable *const r0015 = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r0017 = lshift(swizzle_y(r0014), body.constant(int(1)));
   ir_expression *const r0018 = lequal(body.constant(4292870144u), r0017);
   ir_expression *const r0019 = nequal(swizzle_x(r0014), body.constant(0u));
   ir_expression *const r001A = bit_and(swizzle_y(r0014), body.constant(1048575u));
   ir_expression *const r001B = nequal(r001A, body.constant(0u));
   ir_expression *const r001C = logic_or(r0019, r001B);
   ir_expression *const r001D = logic_and(r0018, r001C);
   ir_if *f0016 = new(mem_ctx) ir_if(operand(r001D).val);
   exec_list *const f0016_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0016->then_instructions;

      body.emit(assign(r0015, r0014, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0016->else_instructions;

      body.emit(assign(r0014, bit_xor(swizzle_y(r0014), body.constant(2147483648u)), 0x02));

      body.emit(assign(r0015, r0014, 0x03));


   body.instructions = f0016_parent_instructions;
   body.emit(f0016);

   /* END IF */

   body.emit(ret(r0015));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64FracLo(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r001E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r001E);
   ir_swizzle *const r001F = swizzle_x(r001E);
   body.emit(ret(r001F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64FracHi(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0020 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0020);
   ir_expression *const r0021 = bit_and(swizzle_y(r0020), body.constant(1048575u));
   body.emit(ret(r0021));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0022 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0022);
   ir_expression *const r0023 = rshift(swizzle_y(r0022), body.constant(int(20)));
   ir_expression *const r0024 = bit_and(r0023, body.constant(2047u));
   ir_expression *const r0025 = expr(ir_unop_u2i, r0024);
   body.emit(ret(r0025));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
feq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0026 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0026);
   ir_variable *const r0027 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0027);
   ir_variable *const r0028 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0029 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0029);
   ir_variable *const r002A = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r002A);
   ir_expression *const r002B = rshift(swizzle_y(r0026), body.constant(int(20)));
   ir_expression *const r002C = bit_and(r002B, body.constant(2047u));
   ir_expression *const r002D = expr(ir_unop_u2i, r002C);
   ir_expression *const r002E = equal(r002D, body.constant(int(2047)));
   ir_expression *const r002F = bit_and(swizzle_y(r0026), body.constant(1048575u));
   ir_expression *const r0030 = bit_or(r002F, swizzle_x(r0026));
   ir_expression *const r0031 = nequal(r0030, body.constant(0u));
   body.emit(assign(r002A, logic_and(r002E, r0031), 0x01));

   ir_expression *const r0032 = rshift(swizzle_y(r0027), body.constant(int(20)));
   ir_expression *const r0033 = bit_and(r0032, body.constant(2047u));
   ir_expression *const r0034 = expr(ir_unop_u2i, r0033);
   ir_expression *const r0035 = equal(r0034, body.constant(int(2047)));
   ir_expression *const r0036 = bit_and(swizzle_y(r0027), body.constant(1048575u));
   ir_expression *const r0037 = bit_or(r0036, swizzle_x(r0027));
   ir_expression *const r0038 = nequal(r0037, body.constant(0u));
   body.emit(assign(r0029, logic_and(r0035, r0038), 0x01));

   /* IF CONDITION */
   ir_expression *const r003A = logic_or(r002A, r0029);
   ir_if *f0039 = new(mem_ctx) ir_if(operand(r003A).val);
   exec_list *const f0039_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0039->then_instructions;

      body.emit(assign(r0028, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0039->else_instructions;

      ir_expression *const r003B = equal(swizzle_x(r0026), swizzle_x(r0027));
      ir_expression *const r003C = equal(swizzle_y(r0026), swizzle_y(r0027));
      ir_expression *const r003D = equal(swizzle_x(r0026), body.constant(0u));
      ir_expression *const r003E = bit_or(swizzle_y(r0026), swizzle_y(r0027));
      ir_expression *const r003F = lshift(r003E, body.constant(int(1)));
      ir_expression *const r0040 = equal(r003F, body.constant(0u));
      ir_expression *const r0041 = logic_and(r003D, r0040);
      ir_expression *const r0042 = logic_or(r003C, r0041);
      body.emit(assign(r0028, logic_and(r003B, r0042), 0x01));


   body.instructions = f0039_parent_instructions;
   body.emit(f0039);

   /* END IF */

   body.emit(ret(r0028));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0043 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0043);
   ir_expression *const r0044 = rshift(swizzle_y(r0043), body.constant(int(31)));
   body.emit(ret(r0044));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
le64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0045 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0045);
   ir_variable *const r0046 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0046);
   ir_variable *const r0047 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r0047);
   ir_variable *const r0048 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r0048);
   ir_expression *const r0049 = less(r0045, r0047);
   ir_expression *const r004A = equal(r0045, r0047);
   ir_expression *const r004B = lequal(r0046, r0048);
   ir_expression *const r004C = logic_and(r004A, r004B);
   ir_expression *const r004D = logic_or(r0049, r004C);
   body.emit(ret(r004D));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fle64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r004E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r004E);
   ir_variable *const r004F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r004F);
   ir_variable *const r0050 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0051 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0051);
   ir_variable *const r0052 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0052);
   ir_expression *const r0053 = rshift(swizzle_y(r004E), body.constant(int(20)));
   ir_expression *const r0054 = bit_and(r0053, body.constant(2047u));
   ir_expression *const r0055 = expr(ir_unop_u2i, r0054);
   ir_expression *const r0056 = equal(r0055, body.constant(int(2047)));
   ir_expression *const r0057 = bit_and(swizzle_y(r004E), body.constant(1048575u));
   ir_expression *const r0058 = bit_or(r0057, swizzle_x(r004E));
   ir_expression *const r0059 = nequal(r0058, body.constant(0u));
   body.emit(assign(r0052, logic_and(r0056, r0059), 0x01));

   ir_expression *const r005A = rshift(swizzle_y(r004F), body.constant(int(20)));
   ir_expression *const r005B = bit_and(r005A, body.constant(2047u));
   ir_expression *const r005C = expr(ir_unop_u2i, r005B);
   ir_expression *const r005D = equal(r005C, body.constant(int(2047)));
   ir_expression *const r005E = bit_and(swizzle_y(r004F), body.constant(1048575u));
   ir_expression *const r005F = bit_or(r005E, swizzle_x(r004F));
   ir_expression *const r0060 = nequal(r005F, body.constant(0u));
   body.emit(assign(r0051, logic_and(r005D, r0060), 0x01));

   /* IF CONDITION */
   ir_expression *const r0062 = logic_or(r0052, r0051);
   ir_if *f0061 = new(mem_ctx) ir_if(operand(r0062).val);
   exec_list *const f0061_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0061->then_instructions;

      body.emit(assign(r0050, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0061->else_instructions;

      ir_variable *const r0063 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0063, rshift(swizzle_y(r004E), body.constant(int(31))), 0x01));

      ir_variable *const r0064 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0064, rshift(swizzle_y(r004F), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0066 = nequal(r0063, r0064);
      ir_if *f0065 = new(mem_ctx) ir_if(operand(r0066).val);
      exec_list *const f0065_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0065->then_instructions;

         ir_expression *const r0067 = nequal(r0063, body.constant(0u));
         ir_expression *const r0068 = bit_or(swizzle_y(r004E), swizzle_y(r004F));
         ir_expression *const r0069 = lshift(r0068, body.constant(int(1)));
         ir_expression *const r006A = bit_or(r0069, swizzle_x(r004E));
         ir_expression *const r006B = bit_or(r006A, swizzle_x(r004F));
         ir_expression *const r006C = equal(r006B, body.constant(0u));
         body.emit(assign(r0050, logic_or(r0067, r006C), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0065->else_instructions;

         ir_variable *const r006D = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r006F = nequal(r0063, body.constant(0u));
         ir_if *f006E = new(mem_ctx) ir_if(operand(r006F).val);
         exec_list *const f006E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f006E->then_instructions;

            ir_expression *const r0070 = less(swizzle_y(r004F), swizzle_y(r004E));
            ir_expression *const r0071 = equal(swizzle_y(r004F), swizzle_y(r004E));
            ir_expression *const r0072 = lequal(swizzle_x(r004F), swizzle_x(r004E));
            ir_expression *const r0073 = logic_and(r0071, r0072);
            body.emit(assign(r006D, logic_or(r0070, r0073), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f006E->else_instructions;

            ir_expression *const r0074 = less(swizzle_y(r004E), swizzle_y(r004F));
            ir_expression *const r0075 = equal(swizzle_y(r004E), swizzle_y(r004F));
            ir_expression *const r0076 = lequal(swizzle_x(r004E), swizzle_x(r004F));
            ir_expression *const r0077 = logic_and(r0075, r0076);
            body.emit(assign(r006D, logic_or(r0074, r0077), 0x01));


         body.instructions = f006E_parent_instructions;
         body.emit(f006E);

         /* END IF */

         body.emit(assign(r0050, r006D, 0x01));


      body.instructions = f0065_parent_instructions;
      body.emit(f0065);

      /* END IF */


   body.instructions = f0061_parent_instructions;
   body.emit(f0061);

   /* END IF */

   body.emit(ret(r0050));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
lt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0078 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0078);
   ir_variable *const r0079 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0079);
   ir_variable *const r007A = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r007A);
   ir_variable *const r007B = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r007B);
   ir_expression *const r007C = less(r0078, r007A);
   ir_expression *const r007D = equal(r0078, r007A);
   ir_expression *const r007E = less(r0079, r007B);
   ir_expression *const r007F = logic_and(r007D, r007E);
   ir_expression *const r0080 = logic_or(r007C, r007F);
   body.emit(ret(r0080));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
flt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0081 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0081);
   ir_variable *const r0082 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0082);
   ir_variable *const r0083 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0084 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0084);
   ir_variable *const r0085 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0085);
   ir_expression *const r0086 = rshift(swizzle_y(r0081), body.constant(int(20)));
   ir_expression *const r0087 = bit_and(r0086, body.constant(2047u));
   ir_expression *const r0088 = expr(ir_unop_u2i, r0087);
   ir_expression *const r0089 = equal(r0088, body.constant(int(2047)));
   ir_expression *const r008A = bit_and(swizzle_y(r0081), body.constant(1048575u));
   ir_expression *const r008B = bit_or(r008A, swizzle_x(r0081));
   ir_expression *const r008C = nequal(r008B, body.constant(0u));
   body.emit(assign(r0085, logic_and(r0089, r008C), 0x01));

   ir_expression *const r008D = rshift(swizzle_y(r0082), body.constant(int(20)));
   ir_expression *const r008E = bit_and(r008D, body.constant(2047u));
   ir_expression *const r008F = expr(ir_unop_u2i, r008E);
   ir_expression *const r0090 = equal(r008F, body.constant(int(2047)));
   ir_expression *const r0091 = bit_and(swizzle_y(r0082), body.constant(1048575u));
   ir_expression *const r0092 = bit_or(r0091, swizzle_x(r0082));
   ir_expression *const r0093 = nequal(r0092, body.constant(0u));
   body.emit(assign(r0084, logic_and(r0090, r0093), 0x01));

   /* IF CONDITION */
   ir_expression *const r0095 = logic_or(r0085, r0084);
   ir_if *f0094 = new(mem_ctx) ir_if(operand(r0095).val);
   exec_list *const f0094_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0094->then_instructions;

      body.emit(assign(r0083, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0094->else_instructions;

      ir_variable *const r0096 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0096, rshift(swizzle_y(r0081), body.constant(int(31))), 0x01));

      ir_variable *const r0097 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0097, rshift(swizzle_y(r0082), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0099 = nequal(r0096, r0097);
      ir_if *f0098 = new(mem_ctx) ir_if(operand(r0099).val);
      exec_list *const f0098_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0098->then_instructions;

         ir_expression *const r009A = nequal(r0096, body.constant(0u));
         ir_expression *const r009B = bit_or(swizzle_y(r0081), swizzle_y(r0082));
         ir_expression *const r009C = lshift(r009B, body.constant(int(1)));
         ir_expression *const r009D = bit_or(r009C, swizzle_x(r0081));
         ir_expression *const r009E = bit_or(r009D, swizzle_x(r0082));
         ir_expression *const r009F = nequal(r009E, body.constant(0u));
         body.emit(assign(r0083, logic_and(r009A, r009F), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0098->else_instructions;

         ir_variable *const r00A0 = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r00A2 = nequal(r0096, body.constant(0u));
         ir_if *f00A1 = new(mem_ctx) ir_if(operand(r00A2).val);
         exec_list *const f00A1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f00A1->then_instructions;

            ir_expression *const r00A3 = less(swizzle_y(r0082), swizzle_y(r0081));
            ir_expression *const r00A4 = equal(swizzle_y(r0082), swizzle_y(r0081));
            ir_expression *const r00A5 = less(swizzle_x(r0082), swizzle_x(r0081));
            ir_expression *const r00A6 = logic_and(r00A4, r00A5);
            body.emit(assign(r00A0, logic_or(r00A3, r00A6), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f00A1->else_instructions;

            ir_expression *const r00A7 = less(swizzle_y(r0081), swizzle_y(r0082));
            ir_expression *const r00A8 = equal(swizzle_y(r0081), swizzle_y(r0082));
            ir_expression *const r00A9 = less(swizzle_x(r0081), swizzle_x(r0082));
            ir_expression *const r00AA = logic_and(r00A8, r00A9);
            body.emit(assign(r00A0, logic_or(r00A7, r00AA), 0x01));


         body.instructions = f00A1_parent_instructions;
         body.emit(f00A1);

         /* END IF */

         body.emit(assign(r0083, r00A0, 0x01));


      body.instructions = f0098_parent_instructions;
      body.emit(f0098);

      /* END IF */


   body.instructions = f0094_parent_instructions;
   body.emit(f0094);

   /* END IF */

   body.emit(ret(r0083));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00AB);
   ir_variable *const r00AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00AC);
   ir_variable *const r00AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00AD);
   ir_variable *const r00AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00AE);
   ir_variable *const r00AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00AF);
   ir_variable *const r00B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00B0);
   ir_variable *const r00B1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r00B1, add(r00AC, r00AE), 0x01));

   body.emit(assign(r00B0, r00B1, 0x01));

   ir_expression *const r00B2 = add(r00AB, r00AD);
   ir_expression *const r00B3 = less(r00B1, r00AC);
   ir_expression *const r00B4 = expr(ir_unop_b2i, r00B3);
   ir_expression *const r00B5 = expr(ir_unop_i2u, r00B4);
   body.emit(assign(r00AF, add(r00B2, r00B5), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00B6);
   ir_variable *const r00B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00B7);
   ir_variable *const r00B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00B8);
   ir_variable *const r00B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00B9);
   ir_variable *const r00BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00BA);
   ir_variable *const r00BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00BB);
   body.emit(assign(r00BB, sub(r00B7, r00B9), 0x01));

   ir_expression *const r00BC = sub(r00B6, r00B8);
   ir_expression *const r00BD = less(r00B7, r00B9);
   ir_expression *const r00BE = expr(ir_unop_b2i, r00BD);
   ir_expression *const r00BF = expr(ir_unop_i2u, r00BE);
   body.emit(assign(r00BA, sub(r00BC, r00BF), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
eq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00C0);
   ir_variable *const r00C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00C1);
   ir_variable *const r00C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00C2);
   ir_variable *const r00C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00C3);
   ir_expression *const r00C4 = equal(r00C0, r00C2);
   ir_expression *const r00C5 = equal(r00C1, r00C3);
   ir_expression *const r00C6 = logic_and(r00C4, r00C5);
   body.emit(ret(r00C6));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
float64_is_signaling_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00C7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r00C7);
   ir_expression *const r00C8 = rshift(swizzle_y(r00C7), body.constant(int(19)));
   ir_expression *const r00C9 = bit_and(r00C8, body.constant(4095u));
   ir_expression *const r00CA = equal(r00C9, body.constant(4094u));
   ir_expression *const r00CB = nequal(swizzle_x(r00C7), body.constant(0u));
   ir_expression *const r00CC = bit_and(swizzle_y(r00C7), body.constant(524287u));
   ir_expression *const r00CD = nequal(r00CC, body.constant(0u));
   ir_expression *const r00CE = logic_or(r00CB, r00CD);
   ir_expression *const r00CF = logic_and(r00CA, r00CE);
   body.emit(ret(r00CF));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00D0);
   ir_variable *const r00D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00D1);
   ir_variable *const r00D2 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00D2);
   ir_variable *const r00D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D3);
   ir_variable *const r00D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D4);
   ir_variable *const r00D5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00D5);
   ir_variable *const r00D6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00D6);
   ir_variable *const r00D7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r00D8 = neg(r00D2);
   body.emit(assign(r00D7, bit_and(r00D8, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r00DA = equal(r00D2, body.constant(int(0)));
   ir_if *f00D9 = new(mem_ctx) ir_if(operand(r00DA).val);
   exec_list *const f00D9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f00D9->then_instructions;

      body.emit(assign(r00D5, r00D1, 0x01));

      body.emit(assign(r00D6, r00D0, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f00D9->else_instructions;

      /* IF CONDITION */
      ir_expression *const r00DC = less(r00D2, body.constant(int(32)));
      ir_if *f00DB = new(mem_ctx) ir_if(operand(r00DC).val);
      exec_list *const f00DB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f00DB->then_instructions;

         ir_expression *const r00DD = lshift(r00D0, r00D7);
         ir_expression *const r00DE = rshift(r00D1, r00D2);
         ir_expression *const r00DF = bit_or(r00DD, r00DE);
         ir_expression *const r00E0 = lshift(r00D1, r00D7);
         ir_expression *const r00E1 = nequal(r00E0, body.constant(0u));
         ir_expression *const r00E2 = expr(ir_unop_b2i, r00E1);
         ir_expression *const r00E3 = expr(ir_unop_i2u, r00E2);
         body.emit(assign(r00D5, bit_or(r00DF, r00E3), 0x01));

         body.emit(assign(r00D6, rshift(r00D0, r00D2), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f00DB->else_instructions;

         /* IF CONDITION */
         ir_expression *const r00E5 = equal(r00D2, body.constant(int(32)));
         ir_if *f00E4 = new(mem_ctx) ir_if(operand(r00E5).val);
         exec_list *const f00E4_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f00E4->then_instructions;

            ir_expression *const r00E6 = nequal(r00D1, body.constant(0u));
            ir_expression *const r00E7 = expr(ir_unop_b2i, r00E6);
            ir_expression *const r00E8 = expr(ir_unop_i2u, r00E7);
            body.emit(assign(r00D5, bit_or(r00D0, r00E8), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f00E4->else_instructions;

            /* IF CONDITION */
            ir_expression *const r00EA = less(r00D2, body.constant(int(64)));
            ir_if *f00E9 = new(mem_ctx) ir_if(operand(r00EA).val);
            exec_list *const f00E9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f00E9->then_instructions;

               ir_expression *const r00EB = bit_and(r00D2, body.constant(int(31)));
               ir_expression *const r00EC = rshift(r00D0, r00EB);
               ir_expression *const r00ED = lshift(r00D0, r00D7);
               ir_expression *const r00EE = bit_or(r00ED, r00D1);
               ir_expression *const r00EF = nequal(r00EE, body.constant(0u));
               ir_expression *const r00F0 = expr(ir_unop_b2i, r00EF);
               ir_expression *const r00F1 = expr(ir_unop_i2u, r00F0);
               body.emit(assign(r00D5, bit_or(r00EC, r00F1), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f00E9->else_instructions;

               ir_expression *const r00F2 = bit_or(r00D0, r00D1);
               ir_expression *const r00F3 = nequal(r00F2, body.constant(0u));
               ir_expression *const r00F4 = expr(ir_unop_b2i, r00F3);
               body.emit(assign(r00D5, expr(ir_unop_i2u, r00F4), 0x01));


            body.instructions = f00E9_parent_instructions;
            body.emit(f00E9);

            /* END IF */


         body.instructions = f00E4_parent_instructions;
         body.emit(f00E4);

         /* END IF */

         body.emit(assign(r00D6, body.constant(0u), 0x01));


      body.instructions = f00DB_parent_instructions;
      body.emit(f00DB);

      /* END IF */


   body.instructions = f00D9_parent_instructions;
   body.emit(f00D9);

   /* END IF */

   body.emit(assign(r00D4, r00D5, 0x01));

   body.emit(assign(r00D3, r00D6, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64ExtraRightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00F5);
   ir_variable *const r00F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00F6);
   ir_variable *const r00F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r00F7);
   ir_variable *const r00F8 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00F8);
   ir_variable *const r00F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00F9);
   ir_variable *const r00FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00FA);
   ir_variable *const r00FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00FB);
   ir_variable *const r00FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
   body.emit(r00FC);
   ir_variable *const r00FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00FD);
   ir_variable *const r00FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00FE);
   ir_variable *const r00FF = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r0100 = neg(r00F8);
   body.emit(assign(r00FF, bit_and(r0100, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0102 = equal(r00F8, body.constant(int(0)));
   ir_if *f0101 = new(mem_ctx) ir_if(operand(r0102).val);
   exec_list *const f0101_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0101->then_instructions;

      body.emit(assign(r00FC, r00F7, 0x01));

      body.emit(assign(r00FD, r00F6, 0x01));

      body.emit(assign(r00FE, r00F5, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0101->else_instructions;

      /* IF CONDITION */
      ir_expression *const r0104 = less(r00F8, body.constant(int(32)));
      ir_if *f0103 = new(mem_ctx) ir_if(operand(r0104).val);
      exec_list *const f0103_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0103->then_instructions;

         body.emit(assign(r00FC, lshift(r00F6, r00FF), 0x01));

         ir_expression *const r0105 = lshift(r00F5, r00FF);
         ir_expression *const r0106 = rshift(r00F6, r00F8);
         body.emit(assign(r00FD, bit_or(r0105, r0106), 0x01));

         body.emit(assign(r00FE, rshift(r00F5, r00F8), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0103->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0108 = equal(r00F8, body.constant(int(32)));
         ir_if *f0107 = new(mem_ctx) ir_if(operand(r0108).val);
         exec_list *const f0107_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0107->then_instructions;

            body.emit(assign(r00FC, r00F6, 0x01));

            body.emit(assign(r00FD, r00F5, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0107->else_instructions;

            body.emit(assign(r00F7, bit_or(r00F7, r00F6), 0x01));

            /* IF CONDITION */
            ir_expression *const r010A = less(r00F8, body.constant(int(64)));
            ir_if *f0109 = new(mem_ctx) ir_if(operand(r010A).val);
            exec_list *const f0109_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0109->then_instructions;

               body.emit(assign(r00FC, lshift(r00F5, r00FF), 0x01));

               ir_expression *const r010B = bit_and(r00F8, body.constant(int(31)));
               body.emit(assign(r00FD, rshift(r00F5, r010B), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0109->else_instructions;

               ir_variable *const r010C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r010E = equal(r00F8, body.constant(int(64)));
               ir_if *f010D = new(mem_ctx) ir_if(operand(r010E).val);
               exec_list *const f010D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f010D->then_instructions;

                  body.emit(assign(r010C, r00F5, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f010D->else_instructions;

                  ir_expression *const r010F = nequal(r00F5, body.constant(0u));
                  ir_expression *const r0110 = expr(ir_unop_b2i, r010F);
                  body.emit(assign(r010C, expr(ir_unop_i2u, r0110), 0x01));


               body.instructions = f010D_parent_instructions;
               body.emit(f010D);

               /* END IF */

               body.emit(assign(r00FC, r010C, 0x01));

               body.emit(assign(r00FD, body.constant(0u), 0x01));


            body.instructions = f0109_parent_instructions;
            body.emit(f0109);

            /* END IF */


         body.instructions = f0107_parent_instructions;
         body.emit(f0107);

         /* END IF */

         body.emit(assign(r00FE, body.constant(0u), 0x01));


      body.instructions = f0103_parent_instructions;
      body.emit(f0103);

      /* END IF */

      ir_expression *const r0111 = nequal(r00F7, body.constant(0u));
      ir_expression *const r0112 = expr(ir_unop_b2i, r0111);
      ir_expression *const r0113 = expr(ir_unop_i2u, r0112);
      body.emit(assign(r00FC, bit_or(r00FC, r0113), 0x01));


   body.instructions = f0101_parent_instructions;
   body.emit(f0101);

   /* END IF */

   body.emit(assign(r00FB, r00FC, 0x01));

   body.emit(assign(r00FA, r00FD, 0x01));

   body.emit(assign(r00F9, r00FE, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shortShift64Left(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0114 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0114);
   ir_variable *const r0115 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0115);
   ir_variable *const r0116 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r0116);
   ir_variable *const r0117 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0117);
   ir_variable *const r0118 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0118);
   body.emit(assign(r0118, lshift(r0115, r0116), 0x01));

   ir_variable *const r0119 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   /* IF CONDITION */
   ir_expression *const r011B = equal(r0116, body.constant(int(0)));
   ir_if *f011A = new(mem_ctx) ir_if(operand(r011B).val);
   exec_list *const f011A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f011A->then_instructions;

      body.emit(assign(r0119, r0114, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f011A->else_instructions;

      ir_expression *const r011C = lshift(r0114, r0116);
      ir_expression *const r011D = neg(r0116);
      ir_expression *const r011E = bit_and(r011D, body.constant(int(31)));
      ir_expression *const r011F = rshift(r0115, r011E);
      body.emit(assign(r0119, bit_or(r011C, r011F), 0x01));


   body.instructions = f011A_parent_instructions;
   body.emit(f011A);

   /* END IF */

   body.emit(assign(r0117, r0119, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0120 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0120);
   ir_variable *const r0121 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0121);
   ir_variable *const r0122 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0122);
   ir_variable *const r0123 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0123);
   ir_variable *const r0124 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
   body.emit(r0124);
   ir_expression *const r0125 = lshift(r0120, body.constant(int(31)));
   ir_expression *const r0126 = expr(ir_unop_i2u, r0121);
   ir_expression *const r0127 = lshift(r0126, body.constant(int(20)));
   ir_expression *const r0128 = add(r0125, r0127);
   body.emit(assign(r0124, add(r0128, r0122), 0x02));

   body.emit(assign(r0124, r0123, 0x01));

   body.emit(ret(r0124));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0129 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0129);
   ir_variable *const r012A = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r012A);
   ir_variable *const r012B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r012B);
   ir_variable *const r012C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r012C);
   ir_variable *const r012D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_function_in);
   sig_parameters.push_tail(r012D);
   ir_variable *const r012E = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r012E, body.constant(true), 0x01));

   ir_variable *const r012F = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0130 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r0130);
   ir_expression *const r0131 = expr(ir_unop_u2i, r012D);
   body.emit(assign(r0130, less(r0131, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0133 = lequal(body.constant(int(2045)), r012A);
   ir_if *f0132 = new(mem_ctx) ir_if(operand(r0133).val);
   exec_list *const f0132_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0132->then_instructions;

      ir_variable *const r0134 = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r0136 = less(body.constant(int(2045)), r012A);
      ir_if *f0135 = new(mem_ctx) ir_if(operand(r0136).val);
      exec_list *const f0135_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0135->then_instructions;

         body.emit(assign(r0134, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0135->else_instructions;

         ir_variable *const r0137 = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r0139 = equal(r012A, body.constant(int(2045)));
         ir_if *f0138 = new(mem_ctx) ir_if(operand(r0139).val);
         exec_list *const f0138_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0138->then_instructions;

            ir_expression *const r013A = equal(body.constant(2097151u), r012B);
            ir_expression *const r013B = equal(body.constant(4294967295u), r012C);
            body.emit(assign(r0137, logic_and(r013A, r013B), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0138->else_instructions;

            body.emit(assign(r0137, body.constant(false), 0x01));


         body.instructions = f0138_parent_instructions;
         body.emit(f0138);

         /* END IF */

         body.emit(assign(r0134, logic_and(r0137, r0130), 0x01));


      body.instructions = f0135_parent_instructions;
      body.emit(f0135);

      /* END IF */

      /* IF CONDITION */
      ir_if *f013C = new(mem_ctx) ir_if(operand(r0134).val);
      exec_list *const f013C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f013C->then_instructions;

         ir_variable *const r013D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r013D);
         ir_expression *const r013E = lshift(r0129, body.constant(int(31)));
         body.emit(assign(r013D, add(r013E, body.constant(2146435072u)), 0x02));

         body.emit(assign(r013D, body.constant(0u), 0x01));

         body.emit(assign(r012F, r013D, 0x03));

         body.emit(assign(r012E, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f013C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0140 = less(r012A, body.constant(int(0)));
         ir_if *f013F = new(mem_ctx) ir_if(operand(r0140).val);
         exec_list *const f013F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f013F->then_instructions;

            ir_variable *const r0141 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r0141, r012D, 0x01));

            ir_variable *const r0142 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r0142, neg(r012A), 0x01));

            ir_variable *const r0143 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r0143);
            ir_variable *const r0144 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0144);
            ir_variable *const r0145 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0145);
            ir_variable *const r0146 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0147 = neg(r0142);
            body.emit(assign(r0146, bit_and(r0147, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0149 = equal(r0142, body.constant(int(0)));
            ir_if *f0148 = new(mem_ctx) ir_if(operand(r0149).val);
            exec_list *const f0148_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0148->then_instructions;

               body.emit(assign(r0143, r012D, 0x01));

               body.emit(assign(r0144, r012C, 0x01));

               body.emit(assign(r0145, r012B, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0148->else_instructions;

               /* IF CONDITION */
               ir_expression *const r014B = less(r0142, body.constant(int(32)));
               ir_if *f014A = new(mem_ctx) ir_if(operand(r014B).val);
               exec_list *const f014A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f014A->then_instructions;

                  body.emit(assign(r0143, lshift(r012C, r0146), 0x01));

                  ir_expression *const r014C = lshift(r012B, r0146);
                  ir_expression *const r014D = rshift(r012C, r0142);
                  body.emit(assign(r0144, bit_or(r014C, r014D), 0x01));

                  body.emit(assign(r0145, rshift(r012B, r0142), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f014A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r014F = equal(r0142, body.constant(int(32)));
                  ir_if *f014E = new(mem_ctx) ir_if(operand(r014F).val);
                  exec_list *const f014E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f014E->then_instructions;

                     body.emit(assign(r0143, r012C, 0x01));

                     body.emit(assign(r0144, r012B, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f014E->else_instructions;

                     body.emit(assign(r0141, bit_or(r012D, r012C), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0151 = less(r0142, body.constant(int(64)));
                     ir_if *f0150 = new(mem_ctx) ir_if(operand(r0151).val);
                     exec_list *const f0150_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0150->then_instructions;

                        body.emit(assign(r0143, lshift(r012B, r0146), 0x01));

                        ir_expression *const r0152 = bit_and(r0142, body.constant(int(31)));
                        body.emit(assign(r0144, rshift(r012B, r0152), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0150->else_instructions;

                        ir_variable *const r0153 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0155 = equal(r0142, body.constant(int(64)));
                        ir_if *f0154 = new(mem_ctx) ir_if(operand(r0155).val);
                        exec_list *const f0154_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0154->then_instructions;

                           body.emit(assign(r0153, r012B, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0154->else_instructions;

                           ir_expression *const r0156 = nequal(r012B, body.constant(0u));
                           ir_expression *const r0157 = expr(ir_unop_b2i, r0156);
                           body.emit(assign(r0153, expr(ir_unop_i2u, r0157), 0x01));


                        body.instructions = f0154_parent_instructions;
                        body.emit(f0154);

                        /* END IF */

                        body.emit(assign(r0143, r0153, 0x01));

                        body.emit(assign(r0144, body.constant(0u), 0x01));


                     body.instructions = f0150_parent_instructions;
                     body.emit(f0150);

                     /* END IF */


                  body.instructions = f014E_parent_instructions;
                  body.emit(f014E);

                  /* END IF */

                  body.emit(assign(r0145, body.constant(0u), 0x01));


               body.instructions = f014A_parent_instructions;
               body.emit(f014A);

               /* END IF */

               ir_expression *const r0158 = nequal(r0141, body.constant(0u));
               ir_expression *const r0159 = expr(ir_unop_b2i, r0158);
               ir_expression *const r015A = expr(ir_unop_i2u, r0159);
               body.emit(assign(r0143, bit_or(r0143, r015A), 0x01));


            body.instructions = f0148_parent_instructions;
            body.emit(f0148);

            /* END IF */

            body.emit(assign(r012B, r0145, 0x01));

            body.emit(assign(r012C, r0144, 0x01));

            body.emit(assign(r012D, r0143, 0x01));

            body.emit(assign(r012A, body.constant(int(0)), 0x01));

            body.emit(assign(r0130, less(r0143, body.constant(0u)), 0x01));


         body.instructions = f013F_parent_instructions;
         body.emit(f013F);

         /* END IF */


      body.instructions = f013C_parent_instructions;
      body.emit(f013C);

      /* END IF */


   body.instructions = f0132_parent_instructions;
   body.emit(f0132);

   /* END IF */

   /* IF CONDITION */
   ir_if *f015B = new(mem_ctx) ir_if(operand(r012E).val);
   exec_list *const f015B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f015B->then_instructions;

      /* IF CONDITION */
      ir_if *f015C = new(mem_ctx) ir_if(operand(r0130).val);
      exec_list *const f015C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f015C->then_instructions;

         ir_variable *const r015D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r015D, add(r012C, body.constant(1u)), 0x01));

         ir_expression *const r015E = less(r015D, r012C);
         ir_expression *const r015F = expr(ir_unop_b2i, r015E);
         ir_expression *const r0160 = expr(ir_unop_i2u, r015F);
         body.emit(assign(r012B, add(r012B, r0160), 0x01));

         ir_expression *const r0161 = equal(r012D, body.constant(0u));
         ir_expression *const r0162 = expr(ir_unop_b2i, r0161);
         ir_expression *const r0163 = expr(ir_unop_i2u, r0162);
         ir_expression *const r0164 = add(r012D, r0163);
         ir_expression *const r0165 = bit_and(r0164, body.constant(1u));
         ir_expression *const r0166 = expr(ir_unop_bit_not, r0165);
         body.emit(assign(r012C, bit_and(r015D, r0166), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f015C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0168 = bit_or(r012B, r012C);
         ir_expression *const r0169 = equal(r0168, body.constant(0u));
         ir_if *f0167 = new(mem_ctx) ir_if(operand(r0169).val);
         exec_list *const f0167_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0167->then_instructions;

            body.emit(assign(r012A, body.constant(int(0)), 0x01));


         body.instructions = f0167_parent_instructions;
         body.emit(f0167);

         /* END IF */


      body.instructions = f015C_parent_instructions;
      body.emit(f015C);

      /* END IF */

      ir_variable *const r016A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r016A);
      ir_expression *const r016B = lshift(r0129, body.constant(int(31)));
      ir_expression *const r016C = expr(ir_unop_i2u, r012A);
      ir_expression *const r016D = lshift(r016C, body.constant(int(20)));
      ir_expression *const r016E = add(r016B, r016D);
      body.emit(assign(r016A, add(r016E, r012B), 0x02));

      body.emit(assign(r016A, r012C, 0x01));

      body.emit(assign(r012F, r016A, 0x03));

      body.emit(assign(r012E, body.constant(false), 0x01));


   body.instructions = f015B_parent_instructions;
   body.emit(f015B);

   /* END IF */

   body.emit(ret(r012F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
countLeadingZeros32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r016F = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r016F);
   ir_variable *const r0170 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r0171 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r0171);
   /* IF CONDITION */
   ir_expression *const r0173 = equal(r016F, body.constant(0u));
   ir_if *f0172 = new(mem_ctx) ir_if(operand(r0173).val);
   exec_list *const f0172_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0172->then_instructions;

      body.emit(assign(r0170, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0172->else_instructions;

      body.emit(assign(r0171, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r0175 = bit_and(r016F, body.constant(4294901760u));
      ir_expression *const r0176 = equal(r0175, body.constant(0u));
      ir_if *f0174 = new(mem_ctx) ir_if(operand(r0176).val);
      exec_list *const f0174_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0174->then_instructions;

         body.emit(assign(r0171, body.constant(int(16)), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(16))), 0x01));


      body.instructions = f0174_parent_instructions;
      body.emit(f0174);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0178 = bit_and(r016F, body.constant(4278190080u));
      ir_expression *const r0179 = equal(r0178, body.constant(0u));
      ir_if *f0177 = new(mem_ctx) ir_if(operand(r0179).val);
      exec_list *const f0177_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0177->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(8))), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(8))), 0x01));


      body.instructions = f0177_parent_instructions;
      body.emit(f0177);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017B = bit_and(r016F, body.constant(4026531840u));
      ir_expression *const r017C = equal(r017B, body.constant(0u));
      ir_if *f017A = new(mem_ctx) ir_if(operand(r017C).val);
      exec_list *const f017A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017A->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(4))), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(4))), 0x01));


      body.instructions = f017A_parent_instructions;
      body.emit(f017A);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017E = bit_and(r016F, body.constant(3221225472u));
      ir_expression *const r017F = equal(r017E, body.constant(0u));
      ir_if *f017D = new(mem_ctx) ir_if(operand(r017F).val);
      exec_list *const f017D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017D->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(2))), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(2))), 0x01));


      body.instructions = f017D_parent_instructions;
      body.emit(f017D);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0181 = bit_and(r016F, body.constant(2147483648u));
      ir_expression *const r0182 = equal(r0181, body.constant(0u));
      ir_if *f0180 = new(mem_ctx) ir_if(operand(r0182).val);
      exec_list *const f0180_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0180->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(1))), 0x01));


      body.instructions = f0180_parent_instructions;
      body.emit(f0180);

      /* END IF */

      body.emit(assign(r0170, r0171, 0x01));


   body.instructions = f0172_parent_instructions;
   body.emit(f0172);

   /* END IF */

   body.emit(ret(r0170));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeRoundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0183 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0183);
   ir_variable *const r0184 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0184);
   ir_variable *const r0185 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0185);
   ir_variable *const r0186 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0186);
   ir_variable *const r0187 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r0187);
   ir_variable *const r0188 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r0188);
   /* IF CONDITION */
   ir_expression *const r018A = equal(r0185, body.constant(0u));
   ir_if *f0189 = new(mem_ctx) ir_if(operand(r018A).val);
   exec_list *const f0189_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0189->then_instructions;

      body.emit(assign(r0185, r0186, 0x01));

      body.emit(assign(r0186, body.constant(0u), 0x01));

      body.emit(assign(r0184, add(r0184, body.constant(int(-32))), 0x01));


   body.instructions = f0189_parent_instructions;
   body.emit(f0189);

   /* END IF */

   ir_variable *const r018B = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r018B, r0185, 0x01));

   ir_variable *const r018C = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r018D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r018D);
   /* IF CONDITION */
   ir_expression *const r018F = equal(r0185, body.constant(0u));
   ir_if *f018E = new(mem_ctx) ir_if(operand(r018F).val);
   exec_list *const f018E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f018E->then_instructions;

      body.emit(assign(r018C, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f018E->else_instructions;

      body.emit(assign(r018D, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r0191 = bit_and(r0185, body.constant(4294901760u));
      ir_expression *const r0192 = equal(r0191, body.constant(0u));
      ir_if *f0190 = new(mem_ctx) ir_if(operand(r0192).val);
      exec_list *const f0190_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0190->then_instructions;

         body.emit(assign(r018D, body.constant(int(16)), 0x01));

         body.emit(assign(r018B, lshift(r0185, body.constant(int(16))), 0x01));


      body.instructions = f0190_parent_instructions;
      body.emit(f0190);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0194 = bit_and(r018B, body.constant(4278190080u));
      ir_expression *const r0195 = equal(r0194, body.constant(0u));
      ir_if *f0193 = new(mem_ctx) ir_if(operand(r0195).val);
      exec_list *const f0193_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0193->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(8))), 0x01));

         body.emit(assign(r018B, lshift(r018B, body.constant(int(8))), 0x01));


      body.instructions = f0193_parent_instructions;
      body.emit(f0193);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0197 = bit_and(r018B, body.constant(4026531840u));
      ir_expression *const r0198 = equal(r0197, body.constant(0u));
      ir_if *f0196 = new(mem_ctx) ir_if(operand(r0198).val);
      exec_list *const f0196_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0196->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(4))), 0x01));

         body.emit(assign(r018B, lshift(r018B, body.constant(int(4))), 0x01));


      body.instructions = f0196_parent_instructions;
      body.emit(f0196);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r019A = bit_and(r018B, body.constant(3221225472u));
      ir_expression *const r019B = equal(r019A, body.constant(0u));
      ir_if *f0199 = new(mem_ctx) ir_if(operand(r019B).val);
      exec_list *const f0199_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0199->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(2))), 0x01));

         body.emit(assign(r018B, lshift(r018B, body.constant(int(2))), 0x01));


      body.instructions = f0199_parent_instructions;
      body.emit(f0199);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r019D = bit_and(r018B, body.constant(2147483648u));
      ir_expression *const r019E = equal(r019D, body.constant(0u));
      ir_if *f019C = new(mem_ctx) ir_if(operand(r019E).val);
      exec_list *const f019C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f019C->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(1))), 0x01));


      body.instructions = f019C_parent_instructions;
      body.emit(f019C);

      /* END IF */

      body.emit(assign(r018C, r018D, 0x01));


   body.instructions = f018E_parent_instructions;
   body.emit(f018E);

   /* END IF */

   body.emit(assign(r0188, add(r018C, body.constant(int(-11))), 0x01));

   /* IF CONDITION */
   ir_expression *const r01A0 = lequal(body.constant(int(0)), r0188);
   ir_if *f019F = new(mem_ctx) ir_if(operand(r01A0).val);
   exec_list *const f019F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f019F->then_instructions;

      body.emit(assign(r0187, body.constant(0u), 0x01));

      ir_variable *const r01A1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r01A1, lshift(r0186, r0188), 0x01));

      ir_variable *const r01A2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r01A4 = equal(r0188, body.constant(int(0)));
      ir_if *f01A3 = new(mem_ctx) ir_if(operand(r01A4).val);
      exec_list *const f01A3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01A3->then_instructions;

         body.emit(assign(r01A2, r0185, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01A3->else_instructions;

         ir_expression *const r01A5 = lshift(r0185, r0188);
         ir_expression *const r01A6 = neg(r0188);
         ir_expression *const r01A7 = bit_and(r01A6, body.constant(int(31)));
         ir_expression *const r01A8 = rshift(r0186, r01A7);
         body.emit(assign(r01A2, bit_or(r01A5, r01A8), 0x01));


      body.instructions = f01A3_parent_instructions;
      body.emit(f01A3);

      /* END IF */

      body.emit(assign(r0185, r01A2, 0x01));

      body.emit(assign(r0186, r01A1, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f019F->else_instructions;

      ir_variable *const r01A9 = body.make_temp(glsl_type::uint_type, "a2");
      body.emit(assign(r01A9, body.constant(0u), 0x01));

      ir_variable *const r01AA = body.make_temp(glsl_type::int_type, "count");
      body.emit(assign(r01AA, neg(r0188), 0x01));

      ir_variable *const r01AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
      body.emit(r01AB);
      ir_variable *const r01AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r01AC);
      ir_variable *const r01AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r01AD);
      ir_variable *const r01AE = body.make_temp(glsl_type::int_type, "assignment_tmp");
      ir_expression *const r01AF = neg(r01AA);
      body.emit(assign(r01AE, bit_and(r01AF, body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r01B1 = equal(r01AA, body.constant(int(0)));
      ir_if *f01B0 = new(mem_ctx) ir_if(operand(r01B1).val);
      exec_list *const f01B0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01B0->then_instructions;

         body.emit(assign(r01AB, r01A9, 0x01));

         body.emit(assign(r01AC, r0186, 0x01));

         body.emit(assign(r01AD, r0185, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01B0->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01B3 = less(r01AA, body.constant(int(32)));
         ir_if *f01B2 = new(mem_ctx) ir_if(operand(r01B3).val);
         exec_list *const f01B2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01B2->then_instructions;

            body.emit(assign(r01AB, lshift(r0186, r01AE), 0x01));

            ir_expression *const r01B4 = lshift(r0185, r01AE);
            ir_expression *const r01B5 = rshift(r0186, r01AA);
            body.emit(assign(r01AC, bit_or(r01B4, r01B5), 0x01));

            body.emit(assign(r01AD, rshift(r0185, r01AA), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01B2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r01B7 = equal(r01AA, body.constant(int(32)));
            ir_if *f01B6 = new(mem_ctx) ir_if(operand(r01B7).val);
            exec_list *const f01B6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01B6->then_instructions;

               body.emit(assign(r01AB, r0186, 0x01));

               body.emit(assign(r01AC, r0185, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01B6->else_instructions;

               body.emit(assign(r01A9, bit_or(body.constant(0u), r0186), 0x01));

               /* IF CONDITION */
               ir_expression *const r01B9 = less(r01AA, body.constant(int(64)));
               ir_if *f01B8 = new(mem_ctx) ir_if(operand(r01B9).val);
               exec_list *const f01B8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01B8->then_instructions;

                  body.emit(assign(r01AB, lshift(r0185, r01AE), 0x01));

                  ir_expression *const r01BA = bit_and(r01AA, body.constant(int(31)));
                  body.emit(assign(r01AC, rshift(r0185, r01BA), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01B8->else_instructions;

                  ir_variable *const r01BB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r01BD = equal(r01AA, body.constant(int(64)));
                  ir_if *f01BC = new(mem_ctx) ir_if(operand(r01BD).val);
                  exec_list *const f01BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01BC->then_instructions;

                     body.emit(assign(r01BB, r0185, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01BC->else_instructions;

                     ir_expression *const r01BE = nequal(r0185, body.constant(0u));
                     ir_expression *const r01BF = expr(ir_unop_b2i, r01BE);
                     body.emit(assign(r01BB, expr(ir_unop_i2u, r01BF), 0x01));


                  body.instructions = f01BC_parent_instructions;
                  body.emit(f01BC);

                  /* END IF */

                  body.emit(assign(r01AB, r01BB, 0x01));

                  body.emit(assign(r01AC, body.constant(0u), 0x01));


               body.instructions = f01B8_parent_instructions;
               body.emit(f01B8);

               /* END IF */


            body.instructions = f01B6_parent_instructions;
            body.emit(f01B6);

            /* END IF */

            body.emit(assign(r01AD, body.constant(0u), 0x01));


         body.instructions = f01B2_parent_instructions;
         body.emit(f01B2);

         /* END IF */

         ir_expression *const r01C0 = nequal(r01A9, body.constant(0u));
         ir_expression *const r01C1 = expr(ir_unop_b2i, r01C0);
         ir_expression *const r01C2 = expr(ir_unop_i2u, r01C1);
         body.emit(assign(r01AB, bit_or(r01AB, r01C2), 0x01));


      body.instructions = f01B0_parent_instructions;
      body.emit(f01B0);

      /* END IF */

      body.emit(assign(r0185, r01AD, 0x01));

      body.emit(assign(r0186, r01AC, 0x01));

      body.emit(assign(r0187, r01AB, 0x01));


   body.instructions = f019F_parent_instructions;
   body.emit(f019F);

   /* END IF */

   body.emit(assign(r0184, sub(r0184, r0188), 0x01));

   ir_variable *const r01C3 = body.make_temp(glsl_type::int_type, "zExp");
   body.emit(assign(r01C3, r0184, 0x01));

   ir_variable *const r01C4 = body.make_temp(glsl_type::uint_type, "zFrac0");
   body.emit(assign(r01C4, r0185, 0x01));

   ir_variable *const r01C5 = body.make_temp(glsl_type::uint_type, "zFrac1");
   body.emit(assign(r01C5, r0186, 0x01));

   ir_variable *const r01C6 = body.make_temp(glsl_type::uint_type, "zFrac2");
   body.emit(assign(r01C6, r0187, 0x01));

   ir_variable *const r01C7 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r01C7, body.constant(true), 0x01));

   ir_variable *const r01C8 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r01C9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r01C9);
   ir_expression *const r01CA = expr(ir_unop_u2i, r0187);
   body.emit(assign(r01C9, less(r01CA, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r01CC = lequal(body.constant(int(2045)), r0184);
   ir_if *f01CB = new(mem_ctx) ir_if(operand(r01CC).val);
   exec_list *const f01CB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01CB->then_instructions;

      ir_variable *const r01CD = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r01CF = less(body.constant(int(2045)), r0184);
      ir_if *f01CE = new(mem_ctx) ir_if(operand(r01CF).val);
      exec_list *const f01CE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01CE->then_instructions;

         body.emit(assign(r01CD, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01CE->else_instructions;

         ir_variable *const r01D0 = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r01D2 = equal(r0184, body.constant(int(2045)));
         ir_if *f01D1 = new(mem_ctx) ir_if(operand(r01D2).val);
         exec_list *const f01D1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01D1->then_instructions;

            ir_expression *const r01D3 = equal(body.constant(2097151u), r0185);
            ir_expression *const r01D4 = equal(body.constant(4294967295u), r0186);
            body.emit(assign(r01D0, logic_and(r01D3, r01D4), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01D1->else_instructions;

            body.emit(assign(r01D0, body.constant(false), 0x01));


         body.instructions = f01D1_parent_instructions;
         body.emit(f01D1);

         /* END IF */

         body.emit(assign(r01CD, logic_and(r01D0, r01C9), 0x01));


      body.instructions = f01CE_parent_instructions;
      body.emit(f01CE);

      /* END IF */

      /* IF CONDITION */
      ir_if *f01D5 = new(mem_ctx) ir_if(operand(r01CD).val);
      exec_list *const f01D5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01D5->then_instructions;

         ir_variable *const r01D6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r01D6);
         ir_expression *const r01D7 = lshift(r0183, body.constant(int(31)));
         body.emit(assign(r01D6, add(r01D7, body.constant(2146435072u)), 0x02));

         body.emit(assign(r01D6, body.constant(0u), 0x01));

         body.emit(assign(r01C8, r01D6, 0x03));

         body.emit(assign(r01C7, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01D5->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01D9 = less(r0184, body.constant(int(0)));
         ir_if *f01D8 = new(mem_ctx) ir_if(operand(r01D9).val);
         exec_list *const f01D8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01D8->then_instructions;

            ir_variable *const r01DA = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r01DA, r0187, 0x01));

            ir_variable *const r01DB = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r01DB, neg(r0184), 0x01));

            ir_variable *const r01DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r01DC);
            ir_variable *const r01DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r01DD);
            ir_variable *const r01DE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r01DE);
            ir_variable *const r01DF = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r01E0 = neg(r01DB);
            body.emit(assign(r01DF, bit_and(r01E0, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r01E2 = equal(r01DB, body.constant(int(0)));
            ir_if *f01E1 = new(mem_ctx) ir_if(operand(r01E2).val);
            exec_list *const f01E1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01E1->then_instructions;

               body.emit(assign(r01DC, r0187, 0x01));

               body.emit(assign(r01DD, r0186, 0x01));

               body.emit(assign(r01DE, r0185, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01E1->else_instructions;

               /* IF CONDITION */
               ir_expression *const r01E4 = less(r01DB, body.constant(int(32)));
               ir_if *f01E3 = new(mem_ctx) ir_if(operand(r01E4).val);
               exec_list *const f01E3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01E3->then_instructions;

                  body.emit(assign(r01DC, lshift(r0186, r01DF), 0x01));

                  ir_expression *const r01E5 = lshift(r0185, r01DF);
                  ir_expression *const r01E6 = rshift(r0186, r01DB);
                  body.emit(assign(r01DD, bit_or(r01E5, r01E6), 0x01));

                  body.emit(assign(r01DE, rshift(r0185, r01DB), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01E3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r01E8 = equal(r01DB, body.constant(int(32)));
                  ir_if *f01E7 = new(mem_ctx) ir_if(operand(r01E8).val);
                  exec_list *const f01E7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01E7->then_instructions;

                     body.emit(assign(r01DC, r0186, 0x01));

                     body.emit(assign(r01DD, r0185, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01E7->else_instructions;

                     body.emit(assign(r01DA, bit_or(r0187, r0186), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r01EA = less(r01DB, body.constant(int(64)));
                     ir_if *f01E9 = new(mem_ctx) ir_if(operand(r01EA).val);
                     exec_list *const f01E9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f01E9->then_instructions;

                        body.emit(assign(r01DC, lshift(r0185, r01DF), 0x01));

                        ir_expression *const r01EB = bit_and(r01DB, body.constant(int(31)));
                        body.emit(assign(r01DD, rshift(r0185, r01EB), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f01E9->else_instructions;

                        ir_variable *const r01EC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r01EE = equal(r01DB, body.constant(int(64)));
                        ir_if *f01ED = new(mem_ctx) ir_if(operand(r01EE).val);
                        exec_list *const f01ED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f01ED->then_instructions;

                           body.emit(assign(r01EC, r0185, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f01ED->else_instructions;

                           ir_expression *const r01EF = nequal(r0185, body.constant(0u));
                           ir_expression *const r01F0 = expr(ir_unop_b2i, r01EF);
                           body.emit(assign(r01EC, expr(ir_unop_i2u, r01F0), 0x01));


                        body.instructions = f01ED_parent_instructions;
                        body.emit(f01ED);

                        /* END IF */

                        body.emit(assign(r01DC, r01EC, 0x01));

                        body.emit(assign(r01DD, body.constant(0u), 0x01));


                     body.instructions = f01E9_parent_instructions;
                     body.emit(f01E9);

                     /* END IF */


                  body.instructions = f01E7_parent_instructions;
                  body.emit(f01E7);

                  /* END IF */

                  body.emit(assign(r01DE, body.constant(0u), 0x01));


               body.instructions = f01E3_parent_instructions;
               body.emit(f01E3);

               /* END IF */

               ir_expression *const r01F1 = nequal(r01DA, body.constant(0u));
               ir_expression *const r01F2 = expr(ir_unop_b2i, r01F1);
               ir_expression *const r01F3 = expr(ir_unop_i2u, r01F2);
               body.emit(assign(r01DC, bit_or(r01DC, r01F3), 0x01));


            body.instructions = f01E1_parent_instructions;
            body.emit(f01E1);

            /* END IF */

            body.emit(assign(r01C4, r01DE, 0x01));

            body.emit(assign(r01C5, r01DD, 0x01));

            body.emit(assign(r01C6, r01DC, 0x01));

            body.emit(assign(r01C3, body.constant(int(0)), 0x01));

            body.emit(assign(r01C9, less(r01DC, body.constant(0u)), 0x01));


         body.instructions = f01D8_parent_instructions;
         body.emit(f01D8);

         /* END IF */


      body.instructions = f01D5_parent_instructions;
      body.emit(f01D5);

      /* END IF */


   body.instructions = f01CB_parent_instructions;
   body.emit(f01CB);

   /* END IF */

   /* IF CONDITION */
   ir_if *f01F4 = new(mem_ctx) ir_if(operand(r01C7).val);
   exec_list *const f01F4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01F4->then_instructions;

      /* IF CONDITION */
      ir_if *f01F5 = new(mem_ctx) ir_if(operand(r01C9).val);
      exec_list *const f01F5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01F5->then_instructions;

         ir_variable *const r01F6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r01F6, add(r01C5, body.constant(1u)), 0x01));

         ir_expression *const r01F7 = less(r01F6, r01C5);
         ir_expression *const r01F8 = expr(ir_unop_b2i, r01F7);
         ir_expression *const r01F9 = expr(ir_unop_i2u, r01F8);
         body.emit(assign(r01C4, add(r01C4, r01F9), 0x01));

         ir_expression *const r01FA = equal(r01C6, body.constant(0u));
         ir_expression *const r01FB = expr(ir_unop_b2i, r01FA);
         ir_expression *const r01FC = expr(ir_unop_i2u, r01FB);
         ir_expression *const r01FD = add(r01C6, r01FC);
         ir_expression *const r01FE = bit_and(r01FD, body.constant(1u));
         ir_expression *const r01FF = expr(ir_unop_bit_not, r01FE);
         body.emit(assign(r01C5, bit_and(r01F6, r01FF), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01F5->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0201 = bit_or(r01C4, r01C5);
         ir_expression *const r0202 = equal(r0201, body.constant(0u));
         ir_if *f0200 = new(mem_ctx) ir_if(operand(r0202).val);
         exec_list *const f0200_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0200->then_instructions;

            body.emit(assign(r01C3, body.constant(int(0)), 0x01));


         body.instructions = f0200_parent_instructions;
         body.emit(f0200);

         /* END IF */


      body.instructions = f01F5_parent_instructions;
      body.emit(f01F5);

      /* END IF */

      ir_variable *const r0203 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r0203);
      ir_expression *const r0204 = lshift(r0183, body.constant(int(31)));
      ir_expression *const r0205 = expr(ir_unop_i2u, r01C3);
      ir_expression *const r0206 = lshift(r0205, body.constant(int(20)));
      ir_expression *const r0207 = add(r0204, r0206);
      body.emit(assign(r0203, add(r0207, r01C4), 0x02));

      body.emit(assign(r0203, r01C5, 0x01));

      body.emit(assign(r01C8, r0203, 0x03));

      body.emit(assign(r01C7, body.constant(false), 0x01));


   body.instructions = f01F4_parent_instructions;
   body.emit(f01F4);

   /* END IF */

   body.emit(ret(r01C8));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
propagateFloat64NaN(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0208 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0208);
   ir_variable *const r0209 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0209);
   ir_variable *const r020A = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r020B = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r020C = lshift(swizzle_y(r0208), body.constant(int(1)));
   ir_expression *const r020D = lequal(body.constant(4292870144u), r020C);
   ir_expression *const r020E = nequal(swizzle_x(r0208), body.constant(0u));
   ir_expression *const r020F = bit_and(swizzle_y(r0208), body.constant(1048575u));
   ir_expression *const r0210 = nequal(r020F, body.constant(0u));
   ir_expression *const r0211 = logic_or(r020E, r0210);
   body.emit(assign(r020B, logic_and(r020D, r0211), 0x01));

   ir_variable *const r0212 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
   ir_expression *const r0213 = rshift(swizzle_y(r0208), body.constant(int(19)));
   ir_expression *const r0214 = bit_and(r0213, body.constant(4095u));
   ir_expression *const r0215 = equal(r0214, body.constant(4094u));
   ir_expression *const r0216 = nequal(swizzle_x(r0208), body.constant(0u));
   ir_expression *const r0217 = bit_and(swizzle_y(r0208), body.constant(524287u));
   ir_expression *const r0218 = nequal(r0217, body.constant(0u));
   ir_expression *const r0219 = logic_or(r0216, r0218);
   body.emit(assign(r0212, logic_and(r0215, r0219), 0x01));

   ir_variable *const r021A = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r021B = lshift(swizzle_y(r0209), body.constant(int(1)));
   ir_expression *const r021C = lequal(body.constant(4292870144u), r021B);
   ir_expression *const r021D = nequal(swizzle_x(r0209), body.constant(0u));
   ir_expression *const r021E = bit_and(swizzle_y(r0209), body.constant(1048575u));
   ir_expression *const r021F = nequal(r021E, body.constant(0u));
   ir_expression *const r0220 = logic_or(r021D, r021F);
   body.emit(assign(r021A, logic_and(r021C, r0220), 0x01));

   body.emit(assign(r0208, bit_or(swizzle_y(r0208), body.constant(524288u)), 0x02));

   body.emit(assign(r0209, bit_or(swizzle_y(r0209), body.constant(524288u)), 0x02));

   /* IF CONDITION */
   ir_if *f0221 = new(mem_ctx) ir_if(operand(r020B).val);
   exec_list *const f0221_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0221->then_instructions;

      ir_variable *const r0222 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r0224 = logic_and(r0212, r021A);
      ir_if *f0223 = new(mem_ctx) ir_if(operand(r0224).val);
      exec_list *const f0223_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0223->then_instructions;

         body.emit(assign(r0222, r0209, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0223->else_instructions;

         body.emit(assign(r0222, r0208, 0x03));


      body.instructions = f0223_parent_instructions;
      body.emit(f0223);

      /* END IF */

      body.emit(assign(r020A, r0222, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0221->else_instructions;

      body.emit(assign(r020A, r0209, 0x03));


   body.instructions = f0221_parent_instructions;
   body.emit(f0221);

   /* END IF */

   body.emit(ret(r020A));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
addFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0225 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0225);
   ir_variable *const r0226 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0226);
   ir_variable *const r0227 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0227);
   ir_variable *const r0228 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r0228, body.constant(true), 0x01));

   ir_variable *const r0229 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r022A = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r022A);
   ir_variable *const r022B = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r022B);
   ir_variable *const r022C = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r022C);
   ir_variable *const r022D = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r022D);
   ir_variable *const r022E = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r022E);
   ir_variable *const r022F = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r022F);
   ir_variable *const r0230 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r0230);
   ir_variable *const r0231 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r0231);
   body.emit(assign(r0231, body.constant(0u), 0x01));

   body.emit(assign(r0230, body.constant(0u), 0x01));

   ir_variable *const r0232 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r0232, swizzle_x(r0225), 0x01));

   body.emit(assign(r022E, r0232, 0x01));

   ir_variable *const r0233 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r0233, bit_and(swizzle_y(r0225), body.constant(1048575u)), 0x01));

   body.emit(assign(r022D, r0233, 0x01));

   ir_variable *const r0234 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r0234, swizzle_x(r0226), 0x01));

   body.emit(assign(r022C, r0234, 0x01));

   ir_variable *const r0235 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r0235, bit_and(swizzle_y(r0226), body.constant(1048575u)), 0x01));

   body.emit(assign(r022B, r0235, 0x01));

   ir_variable *const r0236 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0237 = rshift(swizzle_y(r0225), body.constant(int(20)));
   ir_expression *const r0238 = bit_and(r0237, body.constant(2047u));
   body.emit(assign(r0236, expr(ir_unop_u2i, r0238), 0x01));

   ir_variable *const r0239 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r023A = rshift(swizzle_y(r0226), body.constant(int(20)));
   ir_expression *const r023B = bit_and(r023A, body.constant(2047u));
   body.emit(assign(r0239, expr(ir_unop_u2i, r023B), 0x01));

   ir_variable *const r023C = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r023C, sub(r0236, r0239), 0x01));

   body.emit(assign(r022A, r023C, 0x01));

   /* IF CONDITION */
   ir_expression *const r023E = less(body.constant(int(0)), r023C);
   ir_if *f023D = new(mem_ctx) ir_if(operand(r023E).val);
   exec_list *const f023D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f023D->then_instructions;

      /* IF CONDITION */
      ir_expression *const r0240 = equal(r0236, body.constant(int(2047)));
      ir_if *f023F = new(mem_ctx) ir_if(operand(r0240).val);
      exec_list *const f023F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f023F->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0242 = bit_or(r0233, swizzle_x(r0225));
         ir_expression *const r0243 = nequal(r0242, body.constant(0u));
         ir_if *f0241 = new(mem_ctx) ir_if(operand(r0243).val);
         exec_list *const f0241_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0241->then_instructions;

            ir_variable *const r0244 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r0244, swizzle_x(r0225), 0x01));

            ir_variable *const r0245 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r0245, swizzle_x(r0226), 0x01));

            ir_variable *const r0246 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0247 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r0248 = rshift(swizzle_y(r0225), body.constant(int(19)));
            ir_expression *const r0249 = bit_and(r0248, body.constant(4095u));
            ir_expression *const r024A = equal(r0249, body.constant(4094u));
            ir_expression *const r024B = nequal(swizzle_x(r0225), body.constant(0u));
            ir_expression *const r024C = bit_and(swizzle_y(r0225), body.constant(524287u));
            ir_expression *const r024D = nequal(r024C, body.constant(0u));
            ir_expression *const r024E = logic_or(r024B, r024D);
            body.emit(assign(r0247, logic_and(r024A, r024E), 0x01));

            ir_variable *const r024F = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r0250 = lshift(swizzle_y(r0226), body.constant(int(1)));
            ir_expression *const r0251 = lequal(body.constant(4292870144u), r0250);
            ir_expression *const r0252 = nequal(swizzle_x(r0226), body.constant(0u));
            ir_expression *const r0253 = bit_and(swizzle_y(r0226), body.constant(1048575u));
            ir_expression *const r0254 = nequal(r0253, body.constant(0u));
            ir_expression *const r0255 = logic_or(r0252, r0254);
            body.emit(assign(r024F, logic_and(r0251, r0255), 0x01));

            body.emit(assign(r0244, bit_or(swizzle_y(r0225), body.constant(524288u)), 0x02));

            body.emit(assign(r0245, bit_or(swizzle_y(r0226), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0257 = lshift(swizzle_y(r0225), body.constant(int(1)));
            ir_expression *const r0258 = lequal(body.constant(4292870144u), r0257);
            ir_expression *const r0259 = nequal(swizzle_x(r0225), body.constant(0u));
            ir_expression *const r025A = bit_and(swizzle_y(r0225), body.constant(1048575u));
            ir_expression *const r025B = nequal(r025A, body.constant(0u));
            ir_expression *const r025C = logic_or(r0259, r025B);
            ir_expression *const r025D = logic_and(r0258, r025C);
            ir_if *f0256 = new(mem_ctx) ir_if(operand(r025D).val);
            exec_list *const f0256_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0256->then_instructions;

               ir_variable *const r025E = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0260 = logic_and(r0247, r024F);
               ir_if *f025F = new(mem_ctx) ir_if(operand(r0260).val);
               exec_list *const f025F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f025F->then_instructions;

                  body.emit(assign(r025E, r0245, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f025F->else_instructions;

                  body.emit(assign(r025E, r0244, 0x03));


               body.instructions = f025F_parent_instructions;
               body.emit(f025F);

               /* END IF */

               body.emit(assign(r0246, r025E, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0256->else_instructions;

               body.emit(assign(r0246, r0245, 0x03));


            body.instructions = f0256_parent_instructions;
            body.emit(f0256);

            /* END IF */

            body.emit(assign(r0229, r0246, 0x03));

            body.emit(assign(r0228, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0241->else_instructions;

            body.emit(assign(r0229, r0225, 0x03));

            body.emit(assign(r0228, body.constant(false), 0x01));


         body.instructions = f0241_parent_instructions;
         body.emit(f0241);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f023F->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0262 = equal(r0239, body.constant(int(0)));
         ir_if *f0261 = new(mem_ctx) ir_if(operand(r0262).val);
         exec_list *const f0261_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0261->then_instructions;

            body.emit(assign(r022A, add(r023C, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0261->else_instructions;

            body.emit(assign(r022B, bit_or(r0235, body.constant(1048576u)), 0x01));


         body.instructions = f0261_parent_instructions;
         body.emit(f0261);

         /* END IF */

         ir_variable *const r0263 = body.make_temp(glsl_type::uint_type, "a2");
         body.emit(assign(r0263, body.constant(0u), 0x01));

         ir_variable *const r0264 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r0264);
         ir_variable *const r0265 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0265);
         ir_variable *const r0266 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0266);
         ir_variable *const r0267 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0268 = neg(r022A);
         body.emit(assign(r0267, bit_and(r0268, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r026A = equal(r022A, body.constant(int(0)));
         ir_if *f0269 = new(mem_ctx) ir_if(operand(r026A).val);
         exec_list *const f0269_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0269->then_instructions;

            body.emit(assign(r0264, r0263, 0x01));

            body.emit(assign(r0265, r0234, 0x01));

            body.emit(assign(r0266, r022B, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0269->else_instructions;

            /* IF CONDITION */
            ir_expression *const r026C = less(r022A, body.constant(int(32)));
            ir_if *f026B = new(mem_ctx) ir_if(operand(r026C).val);
            exec_list *const f026B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f026B->then_instructions;

               body.emit(assign(r0264, lshift(swizzle_x(r0226), r0267), 0x01));

               ir_expression *const r026D = lshift(r022B, r0267);
               ir_expression *const r026E = rshift(swizzle_x(r0226), r022A);
               body.emit(assign(r0265, bit_or(r026D, r026E), 0x01));

               body.emit(assign(r0266, rshift(r022B, r022A), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f026B->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0270 = equal(r022A, body.constant(int(32)));
               ir_if *f026F = new(mem_ctx) ir_if(operand(r0270).val);
               exec_list *const f026F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f026F->then_instructions;

                  body.emit(assign(r0264, r0234, 0x01));

                  body.emit(assign(r0265, r022B, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f026F->else_instructions;

                  body.emit(assign(r0263, bit_or(body.constant(0u), swizzle_x(r0226)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0272 = less(r022A, body.constant(int(64)));
                  ir_if *f0271 = new(mem_ctx) ir_if(operand(r0272).val);
                  exec_list *const f0271_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0271->then_instructions;

                     body.emit(assign(r0264, lshift(r022B, r0267), 0x01));

                     ir_expression *const r0273 = bit_and(r022A, body.constant(int(31)));
                     body.emit(assign(r0265, rshift(r022B, r0273), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0271->else_instructions;

                     ir_variable *const r0274 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0276 = equal(r022A, body.constant(int(64)));
                     ir_if *f0275 = new(mem_ctx) ir_if(operand(r0276).val);
                     exec_list *const f0275_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0275->then_instructions;

                        body.emit(assign(r0274, r022B, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0275->else_instructions;

                        ir_expression *const r0277 = nequal(r022B, body.constant(0u));
                        ir_expression *const r0278 = expr(ir_unop_b2i, r0277);
                        body.emit(assign(r0274, expr(ir_unop_i2u, r0278), 0x01));


                     body.instructions = f0275_parent_instructions;
                     body.emit(f0275);

                     /* END IF */

                     body.emit(assign(r0264, r0274, 0x01));

                     body.emit(assign(r0265, body.constant(0u), 0x01));


                  body.instructions = f0271_parent_instructions;
                  body.emit(f0271);

                  /* END IF */


               body.instructions = f026F_parent_instructions;
               body.emit(f026F);

               /* END IF */

               body.emit(assign(r0266, body.constant(0u), 0x01));


            body.instructions = f026B_parent_instructions;
            body.emit(f026B);

            /* END IF */

            ir_expression *const r0279 = nequal(r0263, body.constant(0u));
            ir_expression *const r027A = expr(ir_unop_b2i, r0279);
            ir_expression *const r027B = expr(ir_unop_i2u, r027A);
            body.emit(assign(r0264, bit_or(r0264, r027B), 0x01));


         body.instructions = f0269_parent_instructions;
         body.emit(f0269);

         /* END IF */

         body.emit(assign(r022B, r0266, 0x01));

         body.emit(assign(r022C, r0265, 0x01));

         body.emit(assign(r0230, r0264, 0x01));

         body.emit(assign(r022F, r0236, 0x01));


      body.instructions = f023F_parent_instructions;
      body.emit(f023F);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f023D->else_instructions;

      /* IF CONDITION */
      ir_expression *const r027D = less(r022A, body.constant(int(0)));
      ir_if *f027C = new(mem_ctx) ir_if(operand(r027D).val);
      exec_list *const f027C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f027C->then_instructions;

         /* IF CONDITION */
         ir_expression *const r027F = equal(r0239, body.constant(int(2047)));
         ir_if *f027E = new(mem_ctx) ir_if(operand(r027F).val);
         exec_list *const f027E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f027E->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0281 = bit_or(r022B, r022C);
            ir_expression *const r0282 = nequal(r0281, body.constant(0u));
            ir_if *f0280 = new(mem_ctx) ir_if(operand(r0282).val);
            exec_list *const f0280_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0280->then_instructions;

               ir_variable *const r0283 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0283, swizzle_x(r0225), 0x01));

               ir_variable *const r0284 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0284, swizzle_x(r0226), 0x01));

               ir_variable *const r0285 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0286 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0287 = rshift(swizzle_y(r0225), body.constant(int(19)));
               ir_expression *const r0288 = bit_and(r0287, body.constant(4095u));
               ir_expression *const r0289 = equal(r0288, body.constant(4094u));
               ir_expression *const r028A = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r028B = bit_and(swizzle_y(r0225), body.constant(524287u));
               ir_expression *const r028C = nequal(r028B, body.constant(0u));
               ir_expression *const r028D = logic_or(r028A, r028C);
               body.emit(assign(r0286, logic_and(r0289, r028D), 0x01));

               ir_variable *const r028E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r028F = lshift(swizzle_y(r0226), body.constant(int(1)));
               ir_expression *const r0290 = lequal(body.constant(4292870144u), r028F);
               ir_expression *const r0291 = nequal(swizzle_x(r0226), body.constant(0u));
               ir_expression *const r0292 = bit_and(swizzle_y(r0226), body.constant(1048575u));
               ir_expression *const r0293 = nequal(r0292, body.constant(0u));
               ir_expression *const r0294 = logic_or(r0291, r0293);
               body.emit(assign(r028E, logic_and(r0290, r0294), 0x01));

               body.emit(assign(r0283, bit_or(swizzle_y(r0225), body.constant(524288u)), 0x02));

               body.emit(assign(r0284, bit_or(swizzle_y(r0226), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r0296 = lshift(swizzle_y(r0225), body.constant(int(1)));
               ir_expression *const r0297 = lequal(body.constant(4292870144u), r0296);
               ir_expression *const r0298 = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r0299 = bit_and(swizzle_y(r0225), body.constant(1048575u));
               ir_expression *const r029A = nequal(r0299, body.constant(0u));
               ir_expression *const r029B = logic_or(r0298, r029A);
               ir_expression *const r029C = logic_and(r0297, r029B);
               ir_if *f0295 = new(mem_ctx) ir_if(operand(r029C).val);
               exec_list *const f0295_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0295->then_instructions;

                  ir_variable *const r029D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r029F = logic_and(r0286, r028E);
                  ir_if *f029E = new(mem_ctx) ir_if(operand(r029F).val);
                  exec_list *const f029E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f029E->then_instructions;

                     body.emit(assign(r029D, r0284, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f029E->else_instructions;

                     body.emit(assign(r029D, r0283, 0x03));


                  body.instructions = f029E_parent_instructions;
                  body.emit(f029E);

                  /* END IF */

                  body.emit(assign(r0285, r029D, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0295->else_instructions;

                  body.emit(assign(r0285, r0284, 0x03));


               body.instructions = f0295_parent_instructions;
               body.emit(f0295);

               /* END IF */

               body.emit(assign(r0229, r0285, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0280->else_instructions;

               ir_variable *const r02A0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r02A0);
               ir_expression *const r02A1 = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r02A0, add(r02A1, body.constant(2146435072u)), 0x02));

               body.emit(assign(r02A0, body.constant(0u), 0x01));

               body.emit(assign(r0229, r02A0, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


            body.instructions = f0280_parent_instructions;
            body.emit(f0280);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f027E->else_instructions;

            /* IF CONDITION */
            ir_expression *const r02A3 = equal(r0236, body.constant(int(0)));
            ir_if *f02A2 = new(mem_ctx) ir_if(operand(r02A3).val);
            exec_list *const f02A2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02A2->then_instructions;

               body.emit(assign(r022A, add(r022A, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02A2->else_instructions;

               body.emit(assign(r022D, bit_or(r0233, body.constant(1048576u)), 0x01));


            body.instructions = f02A2_parent_instructions;
            body.emit(f02A2);

            /* END IF */

            ir_variable *const r02A4 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r02A4, body.constant(0u), 0x01));

            ir_variable *const r02A5 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r02A5, neg(r022A), 0x01));

            ir_variable *const r02A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r02A6);
            ir_variable *const r02A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r02A7);
            ir_variable *const r02A8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r02A8);
            ir_variable *const r02A9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r02AA = neg(r02A5);
            body.emit(assign(r02A9, bit_and(r02AA, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r02AC = equal(r02A5, body.constant(int(0)));
            ir_if *f02AB = new(mem_ctx) ir_if(operand(r02AC).val);
            exec_list *const f02AB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02AB->then_instructions;

               body.emit(assign(r02A6, r02A4, 0x01));

               body.emit(assign(r02A7, r0232, 0x01));

               body.emit(assign(r02A8, r022D, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02AB->else_instructions;

               /* IF CONDITION */
               ir_expression *const r02AE = less(r02A5, body.constant(int(32)));
               ir_if *f02AD = new(mem_ctx) ir_if(operand(r02AE).val);
               exec_list *const f02AD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02AD->then_instructions;

                  body.emit(assign(r02A6, lshift(swizzle_x(r0225), r02A9), 0x01));

                  ir_expression *const r02AF = lshift(r022D, r02A9);
                  ir_expression *const r02B0 = rshift(swizzle_x(r0225), r02A5);
                  body.emit(assign(r02A7, bit_or(r02AF, r02B0), 0x01));

                  body.emit(assign(r02A8, rshift(r022D, r02A5), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02AD->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r02B2 = equal(r02A5, body.constant(int(32)));
                  ir_if *f02B1 = new(mem_ctx) ir_if(operand(r02B2).val);
                  exec_list *const f02B1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02B1->then_instructions;

                     body.emit(assign(r02A6, r0232, 0x01));

                     body.emit(assign(r02A7, r022D, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02B1->else_instructions;

                     body.emit(assign(r02A4, bit_or(body.constant(0u), swizzle_x(r0225)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r02B4 = less(r02A5, body.constant(int(64)));
                     ir_if *f02B3 = new(mem_ctx) ir_if(operand(r02B4).val);
                     exec_list *const f02B3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02B3->then_instructions;

                        body.emit(assign(r02A6, lshift(r022D, r02A9), 0x01));

                        ir_expression *const r02B5 = bit_and(r02A5, body.constant(int(31)));
                        body.emit(assign(r02A7, rshift(r022D, r02B5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02B3->else_instructions;

                        ir_variable *const r02B6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r02B8 = equal(r02A5, body.constant(int(64)));
                        ir_if *f02B7 = new(mem_ctx) ir_if(operand(r02B8).val);
                        exec_list *const f02B7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f02B7->then_instructions;

                           body.emit(assign(r02B6, r022D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f02B7->else_instructions;

                           ir_expression *const r02B9 = nequal(r022D, body.constant(0u));
                           ir_expression *const r02BA = expr(ir_unop_b2i, r02B9);
                           body.emit(assign(r02B6, expr(ir_unop_i2u, r02BA), 0x01));


                        body.instructions = f02B7_parent_instructions;
                        body.emit(f02B7);

                        /* END IF */

                        body.emit(assign(r02A6, r02B6, 0x01));

                        body.emit(assign(r02A7, body.constant(0u), 0x01));


                     body.instructions = f02B3_parent_instructions;
                     body.emit(f02B3);

                     /* END IF */


                  body.instructions = f02B1_parent_instructions;
                  body.emit(f02B1);

                  /* END IF */

                  body.emit(assign(r02A8, body.constant(0u), 0x01));


               body.instructions = f02AD_parent_instructions;
               body.emit(f02AD);

               /* END IF */

               ir_expression *const r02BB = nequal(r02A4, body.constant(0u));
               ir_expression *const r02BC = expr(ir_unop_b2i, r02BB);
               ir_expression *const r02BD = expr(ir_unop_i2u, r02BC);
               body.emit(assign(r02A6, bit_or(r02A6, r02BD), 0x01));


            body.instructions = f02AB_parent_instructions;
            body.emit(f02AB);

            /* END IF */

            body.emit(assign(r022D, r02A8, 0x01));

            body.emit(assign(r022E, r02A7, 0x01));

            body.emit(assign(r0230, r02A6, 0x01));

            body.emit(assign(r022F, r0239, 0x01));


         body.instructions = f027E_parent_instructions;
         body.emit(f027E);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f027C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r02BF = equal(r0236, body.constant(int(2047)));
         ir_if *f02BE = new(mem_ctx) ir_if(operand(r02BF).val);
         exec_list *const f02BE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f02BE->then_instructions;

            /* IF CONDITION */
            ir_expression *const r02C1 = bit_or(r022D, r022E);
            ir_expression *const r02C2 = bit_or(r022B, r022C);
            ir_expression *const r02C3 = bit_or(r02C1, r02C2);
            ir_expression *const r02C4 = nequal(r02C3, body.constant(0u));
            ir_if *f02C0 = new(mem_ctx) ir_if(operand(r02C4).val);
            exec_list *const f02C0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02C0->then_instructions;

               ir_variable *const r02C5 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r02C5, swizzle_x(r0225), 0x01));

               ir_variable *const r02C6 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r02C6, swizzle_x(r0226), 0x01));

               ir_variable *const r02C7 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02C8 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r02C9 = rshift(swizzle_y(r0225), body.constant(int(19)));
               ir_expression *const r02CA = bit_and(r02C9, body.constant(4095u));
               ir_expression *const r02CB = equal(r02CA, body.constant(4094u));
               ir_expression *const r02CC = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r02CD = bit_and(swizzle_y(r0225), body.constant(524287u));
               ir_expression *const r02CE = nequal(r02CD, body.constant(0u));
               ir_expression *const r02CF = logic_or(r02CC, r02CE);
               body.emit(assign(r02C8, logic_and(r02CB, r02CF), 0x01));

               ir_variable *const r02D0 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r02D1 = lshift(swizzle_y(r0226), body.constant(int(1)));
               ir_expression *const r02D2 = lequal(body.constant(4292870144u), r02D1);
               ir_expression *const r02D3 = nequal(swizzle_x(r0226), body.constant(0u));
               ir_expression *const r02D4 = bit_and(swizzle_y(r0226), body.constant(1048575u));
               ir_expression *const r02D5 = nequal(r02D4, body.constant(0u));
               ir_expression *const r02D6 = logic_or(r02D3, r02D5);
               body.emit(assign(r02D0, logic_and(r02D2, r02D6), 0x01));

               body.emit(assign(r02C5, bit_or(swizzle_y(r0225), body.constant(524288u)), 0x02));

               body.emit(assign(r02C6, bit_or(swizzle_y(r0226), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r02D8 = lshift(swizzle_y(r0225), body.constant(int(1)));
               ir_expression *const r02D9 = lequal(body.constant(4292870144u), r02D8);
               ir_expression *const r02DA = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r02DB = bit_and(swizzle_y(r0225), body.constant(1048575u));
               ir_expression *const r02DC = nequal(r02DB, body.constant(0u));
               ir_expression *const r02DD = logic_or(r02DA, r02DC);
               ir_expression *const r02DE = logic_and(r02D9, r02DD);
               ir_if *f02D7 = new(mem_ctx) ir_if(operand(r02DE).val);
               exec_list *const f02D7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02D7->then_instructions;

                  ir_variable *const r02DF = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02E1 = logic_and(r02C8, r02D0);
                  ir_if *f02E0 = new(mem_ctx) ir_if(operand(r02E1).val);
                  exec_list *const f02E0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02E0->then_instructions;

                     body.emit(assign(r02DF, r02C6, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02E0->else_instructions;

                     body.emit(assign(r02DF, r02C5, 0x03));


                  body.instructions = f02E0_parent_instructions;
                  body.emit(f02E0);

                  /* END IF */

                  body.emit(assign(r02C7, r02DF, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02D7->else_instructions;

                  body.emit(assign(r02C7, r02C6, 0x03));


               body.instructions = f02D7_parent_instructions;
               body.emit(f02D7);

               /* END IF */

               body.emit(assign(r0229, r02C7, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02C0->else_instructions;

               body.emit(assign(r0229, r0225, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


            body.instructions = f02C0_parent_instructions;
            body.emit(f02C0);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f02BE->else_instructions;

            ir_variable *const r02E2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r02E3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r02E3, add(r022E, r022C), 0x01));

            ir_expression *const r02E4 = add(r022D, r022B);
            ir_expression *const r02E5 = less(r02E3, r022E);
            ir_expression *const r02E6 = expr(ir_unop_b2i, r02E5);
            ir_expression *const r02E7 = expr(ir_unop_i2u, r02E6);
            body.emit(assign(r02E2, add(r02E4, r02E7), 0x01));

            body.emit(assign(r0231, r02E2, 0x01));

            /* IF CONDITION */
            ir_expression *const r02E9 = equal(r0236, body.constant(int(0)));
            ir_if *f02E8 = new(mem_ctx) ir_if(operand(r02E9).val);
            exec_list *const f02E8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02E8->then_instructions;

               ir_variable *const r02EA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r02EA);
               ir_expression *const r02EB = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r02EA, add(r02EB, r02E2), 0x02));

               body.emit(assign(r02EA, r02E3, 0x01));

               body.emit(assign(r0229, r02EA, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02E8->else_instructions;

               body.emit(assign(r0231, bit_or(r02E2, body.constant(2097152u)), 0x01));

               body.emit(assign(r022F, r0236, 0x01));

               ir_variable *const r02EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r02EC);
               ir_variable *const r02ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r02ED);
               ir_variable *const r02EE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r02EE);
               body.emit(assign(r02EC, lshift(r02E3, body.constant(int(31))), 0x01));

               ir_expression *const r02EF = lshift(r0231, body.constant(int(31)));
               ir_expression *const r02F0 = rshift(r02E3, body.constant(int(1)));
               body.emit(assign(r02ED, bit_or(r02EF, r02F0), 0x01));

               body.emit(assign(r02EE, rshift(r0231, body.constant(int(1))), 0x01));

               body.emit(assign(r02EC, bit_or(r02EC, body.constant(0u)), 0x01));

               body.emit(assign(r0231, r02EE, 0x01));

               body.emit(assign(r0230, r02EC, 0x01));

               ir_variable *const r02F1 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r02F1, r0236, 0x01));

               ir_variable *const r02F2 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r02F2, r02EE, 0x01));

               ir_variable *const r02F3 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r02F3, r02ED, 0x01));

               ir_variable *const r02F4 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r02F4, r02EC, 0x01));

               ir_variable *const r02F5 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r02F5, body.constant(true), 0x01));

               ir_variable *const r02F6 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02F7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r02F7);
               ir_expression *const r02F8 = expr(ir_unop_u2i, r02EC);
               body.emit(assign(r02F7, less(r02F8, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r02FA = lequal(body.constant(int(2045)), r0236);
               ir_if *f02F9 = new(mem_ctx) ir_if(operand(r02FA).val);
               exec_list *const f02F9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02F9->then_instructions;

                  ir_variable *const r02FB = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02FD = less(body.constant(int(2045)), r0236);
                  ir_if *f02FC = new(mem_ctx) ir_if(operand(r02FD).val);
                  exec_list *const f02FC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02FC->then_instructions;

                     body.emit(assign(r02FB, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02FC->else_instructions;

                     ir_variable *const r02FE = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0300 = equal(r0236, body.constant(int(2045)));
                     ir_if *f02FF = new(mem_ctx) ir_if(operand(r0300).val);
                     exec_list *const f02FF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02FF->then_instructions;

                        ir_expression *const r0301 = equal(body.constant(2097151u), r02EE);
                        ir_expression *const r0302 = equal(body.constant(4294967295u), r02ED);
                        body.emit(assign(r02FE, logic_and(r0301, r0302), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02FF->else_instructions;

                        body.emit(assign(r02FE, body.constant(false), 0x01));


                     body.instructions = f02FF_parent_instructions;
                     body.emit(f02FF);

                     /* END IF */

                     body.emit(assign(r02FB, logic_and(r02FE, r02F7), 0x01));


                  body.instructions = f02FC_parent_instructions;
                  body.emit(f02FC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0303 = new(mem_ctx) ir_if(operand(r02FB).val);
                  exec_list *const f0303_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0303->then_instructions;

                     ir_variable *const r0304 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0304);
                     ir_expression *const r0305 = lshift(r0227, body.constant(int(31)));
                     body.emit(assign(r0304, add(r0305, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0304, body.constant(0u), 0x01));

                     body.emit(assign(r02F6, r0304, 0x03));

                     body.emit(assign(r02F5, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0303->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0307 = less(r0236, body.constant(int(0)));
                     ir_if *f0306 = new(mem_ctx) ir_if(operand(r0307).val);
                     exec_list *const f0306_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0306->then_instructions;

                        ir_variable *const r0308 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0308, r02EC, 0x01));

                        ir_variable *const r0309 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0309, neg(r0236), 0x01));

                        ir_variable *const r030A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r030A);
                        ir_variable *const r030B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r030B);
                        ir_variable *const r030C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r030C);
                        ir_variable *const r030D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r030E = neg(r0309);
                        body.emit(assign(r030D, bit_and(r030E, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0310 = equal(r0309, body.constant(int(0)));
                        ir_if *f030F = new(mem_ctx) ir_if(operand(r0310).val);
                        exec_list *const f030F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f030F->then_instructions;

                           body.emit(assign(r030A, r02EC, 0x01));

                           body.emit(assign(r030B, r02ED, 0x01));

                           body.emit(assign(r030C, r02EE, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f030F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0312 = less(r0309, body.constant(int(32)));
                           ir_if *f0311 = new(mem_ctx) ir_if(operand(r0312).val);
                           exec_list *const f0311_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0311->then_instructions;

                              body.emit(assign(r030A, lshift(r02ED, r030D), 0x01));

                              ir_expression *const r0313 = lshift(r02EE, r030D);
                              ir_expression *const r0314 = rshift(r02ED, r0309);
                              body.emit(assign(r030B, bit_or(r0313, r0314), 0x01));

                              body.emit(assign(r030C, rshift(r02EE, r0309), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0311->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0316 = equal(r0309, body.constant(int(32)));
                              ir_if *f0315 = new(mem_ctx) ir_if(operand(r0316).val);
                              exec_list *const f0315_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0315->then_instructions;

                                 body.emit(assign(r030A, r02ED, 0x01));

                                 body.emit(assign(r030B, r02EE, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0315->else_instructions;

                                 body.emit(assign(r0308, bit_or(r02EC, r02ED), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0318 = less(r0309, body.constant(int(64)));
                                 ir_if *f0317 = new(mem_ctx) ir_if(operand(r0318).val);
                                 exec_list *const f0317_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0317->then_instructions;

                                    body.emit(assign(r030A, lshift(r02EE, r030D), 0x01));

                                    ir_expression *const r0319 = bit_and(r0309, body.constant(int(31)));
                                    body.emit(assign(r030B, rshift(r02EE, r0319), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0317->else_instructions;

                                    ir_variable *const r031A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r031C = equal(r0309, body.constant(int(64)));
                                    ir_if *f031B = new(mem_ctx) ir_if(operand(r031C).val);
                                    exec_list *const f031B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f031B->then_instructions;

                                       body.emit(assign(r031A, r02EE, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f031B->else_instructions;

                                       ir_expression *const r031D = nequal(r02EE, body.constant(0u));
                                       ir_expression *const r031E = expr(ir_unop_b2i, r031D);
                                       body.emit(assign(r031A, expr(ir_unop_i2u, r031E), 0x01));


                                    body.instructions = f031B_parent_instructions;
                                    body.emit(f031B);

                                    /* END IF */

                                    body.emit(assign(r030A, r031A, 0x01));

                                    body.emit(assign(r030B, body.constant(0u), 0x01));


                                 body.instructions = f0317_parent_instructions;
                                 body.emit(f0317);

                                 /* END IF */


                              body.instructions = f0315_parent_instructions;
                              body.emit(f0315);

                              /* END IF */

                              body.emit(assign(r030C, body.constant(0u), 0x01));


                           body.instructions = f0311_parent_instructions;
                           body.emit(f0311);

                           /* END IF */

                           ir_expression *const r031F = nequal(r0308, body.constant(0u));
                           ir_expression *const r0320 = expr(ir_unop_b2i, r031F);
                           ir_expression *const r0321 = expr(ir_unop_i2u, r0320);
                           body.emit(assign(r030A, bit_or(r030A, r0321), 0x01));


                        body.instructions = f030F_parent_instructions;
                        body.emit(f030F);

                        /* END IF */

                        body.emit(assign(r02F2, r030C, 0x01));

                        body.emit(assign(r02F3, r030B, 0x01));

                        body.emit(assign(r02F4, r030A, 0x01));

                        body.emit(assign(r02F1, body.constant(int(0)), 0x01));

                        body.emit(assign(r02F7, less(r030A, body.constant(0u)), 0x01));


                     body.instructions = f0306_parent_instructions;
                     body.emit(f0306);

                     /* END IF */


                  body.instructions = f0303_parent_instructions;
                  body.emit(f0303);

                  /* END IF */


               body.instructions = f02F9_parent_instructions;
               body.emit(f02F9);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0322 = new(mem_ctx) ir_if(operand(r02F5).val);
               exec_list *const f0322_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0322->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0323 = new(mem_ctx) ir_if(operand(r02F7).val);
                  exec_list *const f0323_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0323->then_instructions;

                     ir_variable *const r0324 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0324, add(r02F3, body.constant(1u)), 0x01));

                     ir_expression *const r0325 = less(r0324, r02F3);
                     ir_expression *const r0326 = expr(ir_unop_b2i, r0325);
                     ir_expression *const r0327 = expr(ir_unop_i2u, r0326);
                     body.emit(assign(r02F2, add(r02F2, r0327), 0x01));

                     ir_expression *const r0328 = equal(r02F4, body.constant(0u));
                     ir_expression *const r0329 = expr(ir_unop_b2i, r0328);
                     ir_expression *const r032A = expr(ir_unop_i2u, r0329);
                     ir_expression *const r032B = add(r02F4, r032A);
                     ir_expression *const r032C = bit_and(r032B, body.constant(1u));
                     ir_expression *const r032D = expr(ir_unop_bit_not, r032C);
                     body.emit(assign(r02F3, bit_and(r0324, r032D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0323->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r032F = bit_or(r02F2, r02F3);
                     ir_expression *const r0330 = equal(r032F, body.constant(0u));
                     ir_if *f032E = new(mem_ctx) ir_if(operand(r0330).val);
                     exec_list *const f032E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f032E->then_instructions;

                        body.emit(assign(r02F1, body.constant(int(0)), 0x01));


                     body.instructions = f032E_parent_instructions;
                     body.emit(f032E);

                     /* END IF */


                  body.instructions = f0323_parent_instructions;
                  body.emit(f0323);

                  /* END IF */

                  ir_variable *const r0331 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0331);
                  ir_expression *const r0332 = lshift(r0227, body.constant(int(31)));
                  ir_expression *const r0333 = expr(ir_unop_i2u, r02F1);
                  ir_expression *const r0334 = lshift(r0333, body.constant(int(20)));
                  ir_expression *const r0335 = add(r0332, r0334);
                  body.emit(assign(r0331, add(r0335, r02F2), 0x02));

                  body.emit(assign(r0331, r02F3, 0x01));

                  body.emit(assign(r02F6, r0331, 0x03));

                  body.emit(assign(r02F5, body.constant(false), 0x01));


               body.instructions = f0322_parent_instructions;
               body.emit(f0322);

               /* END IF */

               body.emit(assign(r0229, r02F6, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


            body.instructions = f02E8_parent_instructions;
            body.emit(f02E8);

            /* END IF */


         body.instructions = f02BE_parent_instructions;
         body.emit(f02BE);

         /* END IF */


      body.instructions = f027C_parent_instructions;
      body.emit(f027C);

      /* END IF */


   body.instructions = f023D_parent_instructions;
   body.emit(f023D);

   /* END IF */

   /* IF CONDITION */
   ir_if *f0336 = new(mem_ctx) ir_if(operand(r0228).val);
   exec_list *const f0336_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0336->then_instructions;

      body.emit(assign(r022D, bit_or(r022D, body.constant(1048576u)), 0x01));

      ir_variable *const r0337 = body.make_temp(glsl_type::uint_type, "z0Ptr");
      ir_variable *const r0338 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r0338, add(r022E, r022C), 0x01));

      ir_expression *const r0339 = add(r022D, r022B);
      ir_expression *const r033A = less(r0338, r022E);
      ir_expression *const r033B = expr(ir_unop_b2i, r033A);
      ir_expression *const r033C = expr(ir_unop_i2u, r033B);
      body.emit(assign(r0337, add(r0339, r033C), 0x01));

      body.emit(assign(r0231, r0337, 0x01));

      body.emit(assign(r022F, add(r022F, body.constant(int(-1))), 0x01));

      /* IF CONDITION */
      ir_expression *const r033E = less(r0337, body.constant(2097152u));
      ir_if *f033D = new(mem_ctx) ir_if(operand(r033E).val);
      exec_list *const f033D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f033D->then_instructions;

         ir_variable *const r033F = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r033F, r022F, 0x01));

         ir_variable *const r0340 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0340, r0337, 0x01));

         ir_variable *const r0341 = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r0341, r0338, 0x01));

         ir_variable *const r0342 = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r0342, r0230, 0x01));

         ir_variable *const r0343 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r0343, body.constant(true), 0x01));

         ir_variable *const r0344 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0345 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0345);
         ir_expression *const r0346 = expr(ir_unop_u2i, r0230);
         body.emit(assign(r0345, less(r0346, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0348 = lequal(body.constant(int(2045)), r022F);
         ir_if *f0347 = new(mem_ctx) ir_if(operand(r0348).val);
         exec_list *const f0347_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0347->then_instructions;

            ir_variable *const r0349 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r034B = less(body.constant(int(2045)), r022F);
            ir_if *f034A = new(mem_ctx) ir_if(operand(r034B).val);
            exec_list *const f034A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f034A->then_instructions;

               body.emit(assign(r0349, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f034A->else_instructions;

               ir_variable *const r034C = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r034E = equal(r022F, body.constant(int(2045)));
               ir_if *f034D = new(mem_ctx) ir_if(operand(r034E).val);
               exec_list *const f034D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f034D->then_instructions;

                  ir_expression *const r034F = equal(body.constant(2097151u), r0337);
                  ir_expression *const r0350 = equal(body.constant(4294967295u), r0338);
                  body.emit(assign(r034C, logic_and(r034F, r0350), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f034D->else_instructions;

                  body.emit(assign(r034C, body.constant(false), 0x01));


               body.instructions = f034D_parent_instructions;
               body.emit(f034D);

               /* END IF */

               body.emit(assign(r0349, logic_and(r034C, r0345), 0x01));


            body.instructions = f034A_parent_instructions;
            body.emit(f034A);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0351 = new(mem_ctx) ir_if(operand(r0349).val);
            exec_list *const f0351_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0351->then_instructions;

               ir_variable *const r0352 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0352);
               ir_expression *const r0353 = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r0352, add(r0353, body.constant(2146435072u)), 0x02));

               body.emit(assign(r0352, body.constant(0u), 0x01));

               body.emit(assign(r0344, r0352, 0x03));

               body.emit(assign(r0343, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0351->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0355 = less(r022F, body.constant(int(0)));
               ir_if *f0354 = new(mem_ctx) ir_if(operand(r0355).val);
               exec_list *const f0354_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0354->then_instructions;

                  ir_variable *const r0356 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0356, r0230, 0x01));

                  ir_variable *const r0357 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0357, neg(r022F), 0x01));

                  ir_variable *const r0358 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0358);
                  ir_variable *const r0359 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0359);
                  ir_variable *const r035A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r035A);
                  ir_variable *const r035B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r035C = neg(r0357);
                  body.emit(assign(r035B, bit_and(r035C, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r035E = equal(r0357, body.constant(int(0)));
                  ir_if *f035D = new(mem_ctx) ir_if(operand(r035E).val);
                  exec_list *const f035D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f035D->then_instructions;

                     body.emit(assign(r0358, r0230, 0x01));

                     body.emit(assign(r0359, r0338, 0x01));

                     body.emit(assign(r035A, r0337, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f035D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0360 = less(r0357, body.constant(int(32)));
                     ir_if *f035F = new(mem_ctx) ir_if(operand(r0360).val);
                     exec_list *const f035F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f035F->then_instructions;

                        body.emit(assign(r0358, lshift(r0338, r035B), 0x01));

                        ir_expression *const r0361 = lshift(r0337, r035B);
                        ir_expression *const r0362 = rshift(r0338, r0357);
                        body.emit(assign(r0359, bit_or(r0361, r0362), 0x01));

                        body.emit(assign(r035A, rshift(r0337, r0357), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f035F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0364 = equal(r0357, body.constant(int(32)));
                        ir_if *f0363 = new(mem_ctx) ir_if(operand(r0364).val);
                        exec_list *const f0363_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0363->then_instructions;

                           body.emit(assign(r0358, r0338, 0x01));

                           body.emit(assign(r0359, r0337, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0363->else_instructions;

                           body.emit(assign(r0356, bit_or(r0230, r0338), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0366 = less(r0357, body.constant(int(64)));
                           ir_if *f0365 = new(mem_ctx) ir_if(operand(r0366).val);
                           exec_list *const f0365_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0365->then_instructions;

                              body.emit(assign(r0358, lshift(r0337, r035B), 0x01));

                              ir_expression *const r0367 = bit_and(r0357, body.constant(int(31)));
                              body.emit(assign(r0359, rshift(r0337, r0367), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0365->else_instructions;

                              ir_variable *const r0368 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r036A = equal(r0357, body.constant(int(64)));
                              ir_if *f0369 = new(mem_ctx) ir_if(operand(r036A).val);
                              exec_list *const f0369_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0369->then_instructions;

                                 body.emit(assign(r0368, r0337, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0369->else_instructions;

                                 ir_expression *const r036B = nequal(r0337, body.constant(0u));
                                 ir_expression *const r036C = expr(ir_unop_b2i, r036B);
                                 body.emit(assign(r0368, expr(ir_unop_i2u, r036C), 0x01));


                              body.instructions = f0369_parent_instructions;
                              body.emit(f0369);

                              /* END IF */

                              body.emit(assign(r0358, r0368, 0x01));

                              body.emit(assign(r0359, body.constant(0u), 0x01));


                           body.instructions = f0365_parent_instructions;
                           body.emit(f0365);

                           /* END IF */


                        body.instructions = f0363_parent_instructions;
                        body.emit(f0363);

                        /* END IF */

                        body.emit(assign(r035A, body.constant(0u), 0x01));


                     body.instructions = f035F_parent_instructions;
                     body.emit(f035F);

                     /* END IF */

                     ir_expression *const r036D = nequal(r0356, body.constant(0u));
                     ir_expression *const r036E = expr(ir_unop_b2i, r036D);
                     ir_expression *const r036F = expr(ir_unop_i2u, r036E);
                     body.emit(assign(r0358, bit_or(r0358, r036F), 0x01));


                  body.instructions = f035D_parent_instructions;
                  body.emit(f035D);

                  /* END IF */

                  body.emit(assign(r0340, r035A, 0x01));

                  body.emit(assign(r0341, r0359, 0x01));

                  body.emit(assign(r0342, r0358, 0x01));

                  body.emit(assign(r033F, body.constant(int(0)), 0x01));

                  body.emit(assign(r0345, less(r0358, body.constant(0u)), 0x01));


               body.instructions = f0354_parent_instructions;
               body.emit(f0354);

               /* END IF */


            body.instructions = f0351_parent_instructions;
            body.emit(f0351);

            /* END IF */


         body.instructions = f0347_parent_instructions;
         body.emit(f0347);

         /* END IF */

         /* IF CONDITION */
         ir_if *f0370 = new(mem_ctx) ir_if(operand(r0343).val);
         exec_list *const f0370_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0370->then_instructions;

            /* IF CONDITION */
            ir_if *f0371 = new(mem_ctx) ir_if(operand(r0345).val);
            exec_list *const f0371_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0371->then_instructions;

               ir_variable *const r0372 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0372, add(r0341, body.constant(1u)), 0x01));

               ir_expression *const r0373 = less(r0372, r0341);
               ir_expression *const r0374 = expr(ir_unop_b2i, r0373);
               ir_expression *const r0375 = expr(ir_unop_i2u, r0374);
               body.emit(assign(r0340, add(r0340, r0375), 0x01));

               ir_expression *const r0376 = equal(r0342, body.constant(0u));
               ir_expression *const r0377 = expr(ir_unop_b2i, r0376);
               ir_expression *const r0378 = expr(ir_unop_i2u, r0377);
               ir_expression *const r0379 = add(r0342, r0378);
               ir_expression *const r037A = bit_and(r0379, body.constant(1u));
               ir_expression *const r037B = expr(ir_unop_bit_not, r037A);
               body.emit(assign(r0341, bit_and(r0372, r037B), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0371->else_instructions;

               /* IF CONDITION */
               ir_expression *const r037D = bit_or(r0340, r0341);
               ir_expression *const r037E = equal(r037D, body.constant(0u));
               ir_if *f037C = new(mem_ctx) ir_if(operand(r037E).val);
               exec_list *const f037C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f037C->then_instructions;

                  body.emit(assign(r033F, body.constant(int(0)), 0x01));


               body.instructions = f037C_parent_instructions;
               body.emit(f037C);

               /* END IF */


            body.instructions = f0371_parent_instructions;
            body.emit(f0371);

            /* END IF */

            ir_variable *const r037F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r037F);
            ir_expression *const r0380 = lshift(r0227, body.constant(int(31)));
            ir_expression *const r0381 = expr(ir_unop_i2u, r033F);
            ir_expression *const r0382 = lshift(r0381, body.constant(int(20)));
            ir_expression *const r0383 = add(r0380, r0382);
            body.emit(assign(r037F, add(r0383, r0340), 0x02));

            body.emit(assign(r037F, r0341, 0x01));

            body.emit(assign(r0344, r037F, 0x03));

            body.emit(assign(r0343, body.constant(false), 0x01));


         body.instructions = f0370_parent_instructions;
         body.emit(f0370);

         /* END IF */

         body.emit(assign(r0229, r0344, 0x03));

         body.emit(assign(r0228, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f033D->else_instructions;

         body.emit(assign(r022F, add(r022F, body.constant(int(1))), 0x01));

         ir_variable *const r0384 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r0384);
         ir_variable *const r0385 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0385);
         ir_variable *const r0386 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0386);
         body.emit(assign(r0384, lshift(r0338, body.constant(int(31))), 0x01));

         ir_expression *const r0387 = lshift(r0337, body.constant(int(31)));
         ir_expression *const r0388 = rshift(r0338, body.constant(int(1)));
         body.emit(assign(r0385, bit_or(r0387, r0388), 0x01));

         body.emit(assign(r0386, rshift(r0337, body.constant(int(1))), 0x01));

         ir_expression *const r0389 = nequal(r0230, body.constant(0u));
         ir_expression *const r038A = expr(ir_unop_b2i, r0389);
         ir_expression *const r038B = expr(ir_unop_i2u, r038A);
         body.emit(assign(r0384, bit_or(r0384, r038B), 0x01));

         body.emit(assign(r0231, r0386, 0x01));

         body.emit(assign(r0230, r0384, 0x01));

         ir_variable *const r038C = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r038C, r022F, 0x01));

         ir_variable *const r038D = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r038D, r0386, 0x01));

         ir_variable *const r038E = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r038E, r0385, 0x01));

         ir_variable *const r038F = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r038F, r0384, 0x01));

         ir_variable *const r0390 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r0390, body.constant(true), 0x01));

         ir_variable *const r0391 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0392 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0392);
         ir_expression *const r0393 = expr(ir_unop_u2i, r0384);
         body.emit(assign(r0392, less(r0393, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0395 = lequal(body.constant(int(2045)), r022F);
         ir_if *f0394 = new(mem_ctx) ir_if(operand(r0395).val);
         exec_list *const f0394_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0394->then_instructions;

            ir_variable *const r0396 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0398 = less(body.constant(int(2045)), r022F);
            ir_if *f0397 = new(mem_ctx) ir_if(operand(r0398).val);
            exec_list *const f0397_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0397->then_instructions;

               body.emit(assign(r0396, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0397->else_instructions;

               ir_variable *const r0399 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r039B = equal(r022F, body.constant(int(2045)));
               ir_if *f039A = new(mem_ctx) ir_if(operand(r039B).val);
               exec_list *const f039A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f039A->then_instructions;

                  ir_expression *const r039C = equal(body.constant(2097151u), r0386);
                  ir_expression *const r039D = equal(body.constant(4294967295u), r0385);
                  body.emit(assign(r0399, logic_and(r039C, r039D), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f039A->else_instructions;

                  body.emit(assign(r0399, body.constant(false), 0x01));


               body.instructions = f039A_parent_instructions;
               body.emit(f039A);

               /* END IF */

               body.emit(assign(r0396, logic_and(r0399, r0392), 0x01));


            body.instructions = f0397_parent_instructions;
            body.emit(f0397);

            /* END IF */

            /* IF CONDITION */
            ir_if *f039E = new(mem_ctx) ir_if(operand(r0396).val);
            exec_list *const f039E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f039E->then_instructions;

               ir_variable *const r039F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r039F);
               ir_expression *const r03A0 = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r039F, add(r03A0, body.constant(2146435072u)), 0x02));

               body.emit(assign(r039F, body.constant(0u), 0x01));

               body.emit(assign(r0391, r039F, 0x03));

               body.emit(assign(r0390, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f039E->else_instructions;

               /* IF CONDITION */
               ir_expression *const r03A2 = less(r022F, body.constant(int(0)));
               ir_if *f03A1 = new(mem_ctx) ir_if(operand(r03A2).val);
               exec_list *const f03A1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f03A1->then_instructions;

                  ir_variable *const r03A3 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r03A3, r0384, 0x01));

                  ir_variable *const r03A4 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r03A4, neg(r022F), 0x01));

                  ir_variable *const r03A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r03A5);
                  ir_variable *const r03A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r03A6);
                  ir_variable *const r03A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r03A7);
                  ir_variable *const r03A8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r03A9 = neg(r03A4);
                  body.emit(assign(r03A8, bit_and(r03A9, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r03AB = equal(r03A4, body.constant(int(0)));
                  ir_if *f03AA = new(mem_ctx) ir_if(operand(r03AB).val);
                  exec_list *const f03AA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f03AA->then_instructions;

                     body.emit(assign(r03A5, r0384, 0x01));

                     body.emit(assign(r03A6, r0385, 0x01));

                     body.emit(assign(r03A7, r0386, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f03AA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r03AD = less(r03A4, body.constant(int(32)));
                     ir_if *f03AC = new(mem_ctx) ir_if(operand(r03AD).val);
                     exec_list *const f03AC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f03AC->then_instructions;

                        body.emit(assign(r03A5, lshift(r0385, r03A8), 0x01));

                        ir_expression *const r03AE = lshift(r0386, r03A8);
                        ir_expression *const r03AF = rshift(r0385, r03A4);
                        body.emit(assign(r03A6, bit_or(r03AE, r03AF), 0x01));

                        body.emit(assign(r03A7, rshift(r0386, r03A4), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f03AC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r03B1 = equal(r03A4, body.constant(int(32)));
                        ir_if *f03B0 = new(mem_ctx) ir_if(operand(r03B1).val);
                        exec_list *const f03B0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f03B0->then_instructions;

                           body.emit(assign(r03A5, r0385, 0x01));

                           body.emit(assign(r03A6, r0386, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f03B0->else_instructions;

                           body.emit(assign(r03A3, bit_or(r0384, r0385), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r03B3 = less(r03A4, body.constant(int(64)));
                           ir_if *f03B2 = new(mem_ctx) ir_if(operand(r03B3).val);
                           exec_list *const f03B2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f03B2->then_instructions;

                              body.emit(assign(r03A5, lshift(r0386, r03A8), 0x01));

                              ir_expression *const r03B4 = bit_and(r03A4, body.constant(int(31)));
                              body.emit(assign(r03A6, rshift(r0386, r03B4), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f03B2->else_instructions;

                              ir_variable *const r03B5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r03B7 = equal(r03A4, body.constant(int(64)));
                              ir_if *f03B6 = new(mem_ctx) ir_if(operand(r03B7).val);
                              exec_list *const f03B6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f03B6->then_instructions;

                                 body.emit(assign(r03B5, r0386, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f03B6->else_instructions;

                                 ir_expression *const r03B8 = nequal(r0386, body.constant(0u));
                                 ir_expression *const r03B9 = expr(ir_unop_b2i, r03B8);
                                 body.emit(assign(r03B5, expr(ir_unop_i2u, r03B9), 0x01));


                              body.instructions = f03B6_parent_instructions;
                              body.emit(f03B6);

                              /* END IF */

                              body.emit(assign(r03A5, r03B5, 0x01));

                              body.emit(assign(r03A6, body.constant(0u), 0x01));


                           body.instructions = f03B2_parent_instructions;
                           body.emit(f03B2);

                           /* END IF */


                        body.instructions = f03B0_parent_instructions;
                        body.emit(f03B0);

                        /* END IF */

                        body.emit(assign(r03A7, body.constant(0u), 0x01));


                     body.instructions = f03AC_parent_instructions;
                     body.emit(f03AC);

                     /* END IF */

                     ir_expression *const r03BA = nequal(r03A3, body.constant(0u));
                     ir_expression *const r03BB = expr(ir_unop_b2i, r03BA);
                     ir_expression *const r03BC = expr(ir_unop_i2u, r03BB);
                     body.emit(assign(r03A5, bit_or(r03A5, r03BC), 0x01));


                  body.instructions = f03AA_parent_instructions;
                  body.emit(f03AA);

                  /* END IF */

                  body.emit(assign(r038D, r03A7, 0x01));

                  body.emit(assign(r038E, r03A6, 0x01));

                  body.emit(assign(r038F, r03A5, 0x01));

                  body.emit(assign(r038C, body.constant(int(0)), 0x01));

                  body.emit(assign(r0392, less(r03A5, body.constant(0u)), 0x01));


               body.instructions = f03A1_parent_instructions;
               body.emit(f03A1);

               /* END IF */


            body.instructions = f039E_parent_instructions;
            body.emit(f039E);

            /* END IF */


         body.instructions = f0394_parent_instructions;
         body.emit(f0394);

         /* END IF */

         /* IF CONDITION */
         ir_if *f03BD = new(mem_ctx) ir_if(operand(r0390).val);
         exec_list *const f03BD_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03BD->then_instructions;

            /* IF CONDITION */
            ir_if *f03BE = new(mem_ctx) ir_if(operand(r0392).val);
            exec_list *const f03BE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f03BE->then_instructions;

               ir_variable *const r03BF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r03BF, add(r038E, body.constant(1u)), 0x01));

               ir_expression *const r03C0 = less(r03BF, r038E);
               ir_expression *const r03C1 = expr(ir_unop_b2i, r03C0);
               ir_expression *const r03C2 = expr(ir_unop_i2u, r03C1);
               body.emit(assign(r038D, add(r038D, r03C2), 0x01));

               ir_expression *const r03C3 = equal(r038F, body.constant(0u));
               ir_expression *const r03C4 = expr(ir_unop_b2i, r03C3);
               ir_expression *const r03C5 = expr(ir_unop_i2u, r03C4);
               ir_expression *const r03C6 = add(r038F, r03C5);
               ir_expression *const r03C7 = bit_and(r03C6, body.constant(1u));
               ir_expression *const r03C8 = expr(ir_unop_bit_not, r03C7);
               body.emit(assign(r038E, bit_and(r03BF, r03C8), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f03BE->else_instructions;

               /* IF CONDITION */
               ir_expression *const r03CA = bit_or(r038D, r038E);
               ir_expression *const r03CB = equal(r03CA, body.constant(0u));
               ir_if *f03C9 = new(mem_ctx) ir_if(operand(r03CB).val);
               exec_list *const f03C9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f03C9->then_instructions;

                  body.emit(assign(r038C, body.constant(int(0)), 0x01));


               body.instructions = f03C9_parent_instructions;
               body.emit(f03C9);

               /* END IF */


            body.instructions = f03BE_parent_instructions;
            body.emit(f03BE);

            /* END IF */

            ir_variable *const r03CC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r03CC);
            ir_expression *const r03CD = lshift(r0227, body.constant(int(31)));
            ir_expression *const r03CE = expr(ir_unop_i2u, r038C);
            ir_expression *const r03CF = lshift(r03CE, body.constant(int(20)));
            ir_expression *const r03D0 = add(r03CD, r03CF);
            body.emit(assign(r03CC, add(r03D0, r038D), 0x02));

            body.emit(assign(r03CC, r038E, 0x01));

            body.emit(assign(r0391, r03CC, 0x03));

            body.emit(assign(r0390, body.constant(false), 0x01));


         body.instructions = f03BD_parent_instructions;
         body.emit(f03BD);

         /* END IF */

         body.emit(assign(r0229, r0391, 0x03));

         body.emit(assign(r0228, body.constant(false), 0x01));


      body.instructions = f033D_parent_instructions;
      body.emit(f033D);

      /* END IF */


   body.instructions = f0336_parent_instructions;
   body.emit(f0336);

   /* END IF */

   body.emit(ret(r0229));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
subFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r03D1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r03D1);
   ir_variable *const r03D2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r03D2);
   ir_variable *const r03D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r03D3);
   ir_variable *const r03D4 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r03D5 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r03D5);
   ir_variable *const r03D6 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r03D6);
   ir_variable *const r03D7 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r03D7);
   ir_variable *const r03D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r03D8);
   ir_variable *const r03D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r03D9);
   ir_variable *const r03DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r03DA);
   ir_variable *const r03DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r03DB);
   ir_variable *const r03DC = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r03DC);
   ir_variable *const r03DD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03DE = rshift(swizzle_y(r03D1), body.constant(int(20)));
   ir_expression *const r03DF = bit_and(r03DE, body.constant(2047u));
   body.emit(assign(r03DD, expr(ir_unop_u2i, r03DF), 0x01));

   body.emit(assign(r03D7, r03DD, 0x01));

   ir_variable *const r03E0 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03E1 = rshift(swizzle_y(r03D2), body.constant(int(20)));
   ir_expression *const r03E2 = bit_and(r03E1, body.constant(2047u));
   body.emit(assign(r03E0, expr(ir_unop_u2i, r03E2), 0x01));

   body.emit(assign(r03D6, r03E0, 0x01));

   body.emit(assign(r03D5, sub(r03DD, r03E0), 0x01));

   ir_variable *const r03E3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E3, lshift(swizzle_x(r03D1), body.constant(int(10))), 0x01));

   ir_variable *const r03E4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03E5 = bit_and(swizzle_y(r03D1), body.constant(1048575u));
   ir_expression *const r03E6 = lshift(r03E5, body.constant(int(10)));
   ir_expression *const r03E7 = rshift(swizzle_x(r03D1), body.constant(int(22)));
   body.emit(assign(r03E4, bit_or(r03E6, r03E7), 0x01));

   body.emit(assign(r03DA, r03E4, 0x01));

   body.emit(assign(r03DB, r03E3, 0x01));

   ir_variable *const r03E8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E8, lshift(swizzle_x(r03D2), body.constant(int(10))), 0x01));

   ir_variable *const r03E9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03EA = bit_and(swizzle_y(r03D2), body.constant(1048575u));
   ir_expression *const r03EB = lshift(r03EA, body.constant(int(10)));
   ir_expression *const r03EC = rshift(swizzle_x(r03D2), body.constant(int(22)));
   body.emit(assign(r03E9, bit_or(r03EB, r03EC), 0x01));

   body.emit(assign(r03D8, r03E9, 0x01));

   body.emit(assign(r03D9, r03E8, 0x01));

   /* IF CONDITION */
   ir_expression *const r03EE = less(body.constant(int(0)), r03D5);
   ir_if *f03ED = new(mem_ctx) ir_if(operand(r03EE).val);
   exec_list *const f03ED_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f03ED->then_instructions;

      /* IF CONDITION */
      ir_expression *const r03F0 = equal(r03DD, body.constant(int(2047)));
      ir_if *f03EF = new(mem_ctx) ir_if(operand(r03F0).val);
      exec_list *const f03EF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f03EF->then_instructions;

         /* IF CONDITION */
         ir_expression *const r03F2 = bit_or(r03E4, r03E3);
         ir_expression *const r03F3 = nequal(r03F2, body.constant(0u));
         ir_if *f03F1 = new(mem_ctx) ir_if(operand(r03F3).val);
         exec_list *const f03F1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03F1->then_instructions;

            ir_variable *const r03F4 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r03F4, swizzle_x(r03D1), 0x01));

            ir_variable *const r03F5 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r03F5, swizzle_x(r03D2), 0x01));

            ir_variable *const r03F6 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r03F7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r03F8 = rshift(swizzle_y(r03D1), body.constant(int(19)));
            ir_expression *const r03F9 = bit_and(r03F8, body.constant(4095u));
            ir_expression *const r03FA = equal(r03F9, body.constant(4094u));
            ir_expression *const r03FB = nequal(swizzle_x(r03D1), body.constant(0u));
            ir_expression *const r03FC = bit_and(swizzle_y(r03D1), body.constant(524287u));
            ir_expression *const r03FD = nequal(r03FC, body.constant(0u));
            ir_expression *const r03FE = logic_or(r03FB, r03FD);
            body.emit(assign(r03F7, logic_and(r03FA, r03FE), 0x01));

            ir_variable *const r03FF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r0400 = lshift(swizzle_y(r03D2), body.constant(int(1)));
            ir_expression *const r0401 = lequal(body.constant(4292870144u), r0400);
            ir_expression *const r0402 = nequal(swizzle_x(r03D2), body.constant(0u));
            ir_expression *const r0403 = bit_and(swizzle_y(r03D2), body.constant(1048575u));
            ir_expression *const r0404 = nequal(r0403, body.constant(0u));
            ir_expression *const r0405 = logic_or(r0402, r0404);
            body.emit(assign(r03FF, logic_and(r0401, r0405), 0x01));

            body.emit(assign(r03F4, bit_or(swizzle_y(r03D1), body.constant(524288u)), 0x02));

            body.emit(assign(r03F5, bit_or(swizzle_y(r03D2), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0407 = lshift(swizzle_y(r03D1), body.constant(int(1)));
            ir_expression *const r0408 = lequal(body.constant(4292870144u), r0407);
            ir_expression *const r0409 = nequal(swizzle_x(r03D1), body.constant(0u));
            ir_expression *const r040A = bit_and(swizzle_y(r03D1), body.constant(1048575u));
            ir_expression *const r040B = nequal(r040A, body.constant(0u));
            ir_expression *const r040C = logic_or(r0409, r040B);
            ir_expression *const r040D = logic_and(r0408, r040C);
            ir_if *f0406 = new(mem_ctx) ir_if(operand(r040D).val);
            exec_list *const f0406_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0406->then_instructions;

               ir_variable *const r040E = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0410 = logic_and(r03F7, r03FF);
               ir_if *f040F = new(mem_ctx) ir_if(operand(r0410).val);
               exec_list *const f040F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f040F->then_instructions;

                  body.emit(assign(r040E, r03F5, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f040F->else_instructions;

                  body.emit(assign(r040E, r03F4, 0x03));


               body.instructions = f040F_parent_instructions;
               body.emit(f040F);

               /* END IF */

               body.emit(assign(r03F6, r040E, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0406->else_instructions;

               body.emit(assign(r03F6, r03F5, 0x03));


            body.instructions = f0406_parent_instructions;
            body.emit(f0406);

            /* END IF */

            body.emit(assign(r03D4, r03F6, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f03F1->else_instructions;

            body.emit(assign(r03D4, r03D1, 0x03));


         body.instructions = f03F1_parent_instructions;
         body.emit(f03F1);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f03EF->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0412 = equal(r03E0, body.constant(int(0)));
         ir_if *f0411 = new(mem_ctx) ir_if(operand(r0412).val);
         exec_list *const f0411_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0411->then_instructions;

            body.emit(assign(r03D5, add(r03D5, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0411->else_instructions;

            body.emit(assign(r03D8, bit_or(r03E9, body.constant(1073741824u)), 0x01));


         body.instructions = f0411_parent_instructions;
         body.emit(f0411);

         /* END IF */

         ir_variable *const r0413 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0413);
         ir_variable *const r0414 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0414);
         ir_variable *const r0415 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0416 = neg(r03D5);
         body.emit(assign(r0415, bit_and(r0416, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0418 = equal(r03D5, body.constant(int(0)));
         ir_if *f0417 = new(mem_ctx) ir_if(operand(r0418).val);
         exec_list *const f0417_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0417->then_instructions;

            body.emit(assign(r0413, r03E8, 0x01));

            body.emit(assign(r0414, r03D8, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0417->else_instructions;

            /* IF CONDITION */
            ir_expression *const r041A = less(r03D5, body.constant(int(32)));
            ir_if *f0419 = new(mem_ctx) ir_if(operand(r041A).val);
            exec_list *const f0419_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0419->then_instructions;

               ir_expression *const r041B = lshift(r03D8, r0415);
               ir_expression *const r041C = rshift(r03E8, r03D5);
               ir_expression *const r041D = bit_or(r041B, r041C);
               ir_expression *const r041E = lshift(r03E8, r0415);
               ir_expression *const r041F = nequal(r041E, body.constant(0u));
               ir_expression *const r0420 = expr(ir_unop_b2i, r041F);
               ir_expression *const r0421 = expr(ir_unop_i2u, r0420);
               body.emit(assign(r0413, bit_or(r041D, r0421), 0x01));

               body.emit(assign(r0414, rshift(r03D8, r03D5), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0419->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0423 = equal(r03D5, body.constant(int(32)));
               ir_if *f0422 = new(mem_ctx) ir_if(operand(r0423).val);
               exec_list *const f0422_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0422->then_instructions;

                  ir_expression *const r0424 = nequal(r03E8, body.constant(0u));
                  ir_expression *const r0425 = expr(ir_unop_b2i, r0424);
                  ir_expression *const r0426 = expr(ir_unop_i2u, r0425);
                  body.emit(assign(r0413, bit_or(r03D8, r0426), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0422->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0428 = less(r03D5, body.constant(int(64)));
                  ir_if *f0427 = new(mem_ctx) ir_if(operand(r0428).val);
                  exec_list *const f0427_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0427->then_instructions;

                     ir_expression *const r0429 = bit_and(r03D5, body.constant(int(31)));
                     ir_expression *const r042A = rshift(r03D8, r0429);
                     ir_expression *const r042B = lshift(r03D8, r0415);
                     ir_expression *const r042C = bit_or(r042B, r03E8);
                     ir_expression *const r042D = nequal(r042C, body.constant(0u));
                     ir_expression *const r042E = expr(ir_unop_b2i, r042D);
                     ir_expression *const r042F = expr(ir_unop_i2u, r042E);
                     body.emit(assign(r0413, bit_or(r042A, r042F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0427->else_instructions;

                     ir_expression *const r0430 = bit_or(r03D8, r03E8);
                     ir_expression *const r0431 = nequal(r0430, body.constant(0u));
                     ir_expression *const r0432 = expr(ir_unop_b2i, r0431);
                     body.emit(assign(r0413, expr(ir_unop_i2u, r0432), 0x01));


                  body.instructions = f0427_parent_instructions;
                  body.emit(f0427);

                  /* END IF */


               body.instructions = f0422_parent_instructions;
               body.emit(f0422);

               /* END IF */

               body.emit(assign(r0414, body.constant(0u), 0x01));


            body.instructions = f0419_parent_instructions;
            body.emit(f0419);

            /* END IF */


         body.instructions = f0417_parent_instructions;
         body.emit(f0417);

         /* END IF */

         body.emit(assign(r03D8, r0414, 0x01));

         body.emit(assign(r03D9, r0413, 0x01));

         body.emit(assign(r03DA, bit_or(r03E4, body.constant(1073741824u)), 0x01));

         ir_variable *const r0433 = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r0434 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r0434, sub(r03E3, r0413), 0x01));

         ir_expression *const r0435 = sub(r03DA, r0414);
         ir_expression *const r0436 = less(r03E3, r0413);
         ir_expression *const r0437 = expr(ir_unop_b2i, r0436);
         ir_expression *const r0438 = expr(ir_unop_i2u, r0437);
         body.emit(assign(r0433, sub(r0435, r0438), 0x01));

         body.emit(assign(r03DC, add(r03DD, body.constant(int(-1))), 0x01));

         ir_variable *const r0439 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0439, add(r03DC, body.constant(int(-10))), 0x01));

         ir_variable *const r043A = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r043A, r0433, 0x01));

         ir_variable *const r043B = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r043B, r0434, 0x01));

         ir_variable *const r043C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r043C);
         ir_variable *const r043D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r043D);
         /* IF CONDITION */
         ir_expression *const r043F = equal(r0433, body.constant(0u));
         ir_if *f043E = new(mem_ctx) ir_if(operand(r043F).val);
         exec_list *const f043E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f043E->then_instructions;

            body.emit(assign(r043A, r0434, 0x01));

            body.emit(assign(r043B, body.constant(0u), 0x01));

            body.emit(assign(r0439, add(r0439, body.constant(int(-32))), 0x01));


         body.instructions = f043E_parent_instructions;
         body.emit(f043E);

         /* END IF */

         ir_variable *const r0440 = body.make_temp(glsl_type::uint_type, "a");
         body.emit(assign(r0440, r043A, 0x01));

         ir_variable *const r0441 = body.make_temp(glsl_type::int_type, "return_value");
         ir_variable *const r0442 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r0442);
         /* IF CONDITION */
         ir_expression *const r0444 = equal(r043A, body.constant(0u));
         ir_if *f0443 = new(mem_ctx) ir_if(operand(r0444).val);
         exec_list *const f0443_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0443->then_instructions;

            body.emit(assign(r0441, body.constant(int(32)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0443->else_instructions;

            body.emit(assign(r0442, body.constant(int(0)), 0x01));

            /* IF CONDITION */
            ir_expression *const r0446 = bit_and(r043A, body.constant(4294901760u));
            ir_expression *const r0447 = equal(r0446, body.constant(0u));
            ir_if *f0445 = new(mem_ctx) ir_if(operand(r0447).val);
            exec_list *const f0445_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0445->then_instructions;

               body.emit(assign(r0442, body.constant(int(16)), 0x01));

               body.emit(assign(r0440, lshift(r043A, body.constant(int(16))), 0x01));


            body.instructions = f0445_parent_instructions;
            body.emit(f0445);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0449 = bit_and(r0440, body.constant(4278190080u));
            ir_expression *const r044A = equal(r0449, body.constant(0u));
            ir_if *f0448 = new(mem_ctx) ir_if(operand(r044A).val);
            exec_list *const f0448_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0448->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(8))), 0x01));

               body.emit(assign(r0440, lshift(r0440, body.constant(int(8))), 0x01));


            body.instructions = f0448_parent_instructions;
            body.emit(f0448);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044C = bit_and(r0440, body.constant(4026531840u));
            ir_expression *const r044D = equal(r044C, body.constant(0u));
            ir_if *f044B = new(mem_ctx) ir_if(operand(r044D).val);
            exec_list *const f044B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f044B->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(4))), 0x01));

               body.emit(assign(r0440, lshift(r0440, body.constant(int(4))), 0x01));


            body.instructions = f044B_parent_instructions;
            body.emit(f044B);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044F = bit_and(r0440, body.constant(3221225472u));
            ir_expression *const r0450 = equal(r044F, body.constant(0u));
            ir_if *f044E = new(mem_ctx) ir_if(operand(r0450).val);
            exec_list *const f044E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f044E->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(2))), 0x01));

               body.emit(assign(r0440, lshift(r0440, body.constant(int(2))), 0x01));


            body.instructions = f044E_parent_instructions;
            body.emit(f044E);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0452 = bit_and(r0440, body.constant(2147483648u));
            ir_expression *const r0453 = equal(r0452, body.constant(0u));
            ir_if *f0451 = new(mem_ctx) ir_if(operand(r0453).val);
            exec_list *const f0451_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0451->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(1))), 0x01));


            body.instructions = f0451_parent_instructions;
            body.emit(f0451);

            /* END IF */

            body.emit(assign(r0441, r0442, 0x01));


         body.instructions = f0443_parent_instructions;
         body.emit(f0443);

         /* END IF */

         body.emit(assign(r043D, add(r0441, body.constant(int(-11))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0455 = lequal(body.constant(int(0)), r043D);
         ir_if *f0454 = new(mem_ctx) ir_if(operand(r0455).val);
         exec_list *const f0454_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0454->then_instructions;

            body.emit(assign(r043C, body.constant(0u), 0x01));

            ir_variable *const r0456 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0456, lshift(r043B, r043D), 0x01));

            ir_variable *const r0457 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r0459 = equal(r043D, body.constant(int(0)));
            ir_if *f0458 = new(mem_ctx) ir_if(operand(r0459).val);
            exec_list *const f0458_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0458->then_instructions;

               body.emit(assign(r0457, r043A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0458->else_instructions;

               ir_expression *const r045A = lshift(r043A, r043D);
               ir_expression *const r045B = neg(r043D);
               ir_expression *const r045C = bit_and(r045B, body.constant(int(31)));
               ir_expression *const r045D = rshift(r043B, r045C);
               body.emit(assign(r0457, bit_or(r045A, r045D), 0x01));


            body.instructions = f0458_parent_instructions;
            body.emit(f0458);

            /* END IF */

            body.emit(assign(r043A, r0457, 0x01));

            body.emit(assign(r043B, r0456, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0454->else_instructions;

            ir_variable *const r045E = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r045E, body.constant(0u), 0x01));

            ir_variable *const r045F = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r045F, neg(r043D), 0x01));

            ir_variable *const r0460 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r0460);
            ir_variable *const r0461 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0461);
            ir_variable *const r0462 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0462);
            ir_variable *const r0463 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0464 = neg(r045F);
            body.emit(assign(r0463, bit_and(r0464, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0466 = equal(r045F, body.constant(int(0)));
            ir_if *f0465 = new(mem_ctx) ir_if(operand(r0466).val);
            exec_list *const f0465_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0465->then_instructions;

               body.emit(assign(r0460, r045E, 0x01));

               body.emit(assign(r0461, r043B, 0x01));

               body.emit(assign(r0462, r043A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0465->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0468 = less(r045F, body.constant(int(32)));
               ir_if *f0467 = new(mem_ctx) ir_if(operand(r0468).val);
               exec_list *const f0467_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0467->then_instructions;

                  body.emit(assign(r0460, lshift(r043B, r0463), 0x01));

                  ir_expression *const r0469 = lshift(r043A, r0463);
                  ir_expression *const r046A = rshift(r043B, r045F);
                  body.emit(assign(r0461, bit_or(r0469, r046A), 0x01));

                  body.emit(assign(r0462, rshift(r043A, r045F), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0467->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r046C = equal(r045F, body.constant(int(32)));
                  ir_if *f046B = new(mem_ctx) ir_if(operand(r046C).val);
                  exec_list *const f046B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f046B->then_instructions;

                     body.emit(assign(r0460, r043B, 0x01));

                     body.emit(assign(r0461, r043A, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f046B->else_instructions;

                     body.emit(assign(r045E, bit_or(body.constant(0u), r043B), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r046E = less(r045F, body.constant(int(64)));
                     ir_if *f046D = new(mem_ctx) ir_if(operand(r046E).val);
                     exec_list *const f046D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f046D->then_instructions;

                        body.emit(assign(r0460, lshift(r043A, r0463), 0x01));

                        ir_expression *const r046F = bit_and(r045F, body.constant(int(31)));
                        body.emit(assign(r0461, rshift(r043A, r046F), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f046D->else_instructions;

                        ir_variable *const r0470 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0472 = equal(r045F, body.constant(int(64)));
                        ir_if *f0471 = new(mem_ctx) ir_if(operand(r0472).val);
                        exec_list *const f0471_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0471->then_instructions;

                           body.emit(assign(r0470, r043A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0471->else_instructions;

                           ir_expression *const r0473 = nequal(r043A, body.constant(0u));
                           ir_expression *const r0474 = expr(ir_unop_b2i, r0473);
                           body.emit(assign(r0470, expr(ir_unop_i2u, r0474), 0x01));


                        body.instructions = f0471_parent_instructions;
                        body.emit(f0471);

                        /* END IF */

                        body.emit(assign(r0460, r0470, 0x01));

                        body.emit(assign(r0461, body.constant(0u), 0x01));


                     body.instructions = f046D_parent_instructions;
                     body.emit(f046D);

                     /* END IF */


                  body.instructions = f046B_parent_instructions;
                  body.emit(f046B);

                  /* END IF */

                  body.emit(assign(r0462, body.constant(0u), 0x01));


               body.instructions = f0467_parent_instructions;
               body.emit(f0467);

               /* END IF */

               ir_expression *const r0475 = nequal(r045E, body.constant(0u));
               ir_expression *const r0476 = expr(ir_unop_b2i, r0475);
               ir_expression *const r0477 = expr(ir_unop_i2u, r0476);
               body.emit(assign(r0460, bit_or(r0460, r0477), 0x01));


            body.instructions = f0465_parent_instructions;
            body.emit(f0465);

            /* END IF */

            body.emit(assign(r043A, r0462, 0x01));

            body.emit(assign(r043B, r0461, 0x01));

            body.emit(assign(r043C, r0460, 0x01));


         body.instructions = f0454_parent_instructions;
         body.emit(f0454);

         /* END IF */

         body.emit(assign(r0439, sub(r0439, r043D), 0x01));

         ir_variable *const r0478 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0478, r0439, 0x01));

         ir_variable *const r0479 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0479, r043A, 0x01));

         ir_variable *const r047A = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r047A, r043B, 0x01));

         ir_variable *const r047B = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r047B, r043C, 0x01));

         ir_variable *const r047C = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r047C, body.constant(true), 0x01));

         ir_variable *const r047D = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r047E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r047E);
         ir_expression *const r047F = expr(ir_unop_u2i, r043C);
         body.emit(assign(r047E, less(r047F, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0481 = lequal(body.constant(int(2045)), r0439);
         ir_if *f0480 = new(mem_ctx) ir_if(operand(r0481).val);
         exec_list *const f0480_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0480->then_instructions;

            ir_variable *const r0482 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0484 = less(body.constant(int(2045)), r0439);
            ir_if *f0483 = new(mem_ctx) ir_if(operand(r0484).val);
            exec_list *const f0483_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0483->then_instructions;

               body.emit(assign(r0482, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0483->else_instructions;

               ir_variable *const r0485 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r0487 = equal(r0439, body.constant(int(2045)));
               ir_if *f0486 = new(mem_ctx) ir_if(operand(r0487).val);
               exec_list *const f0486_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0486->then_instructions;

                  ir_expression *const r0488 = equal(body.constant(2097151u), r043A);
                  ir_expression *const r0489 = equal(body.constant(4294967295u), r043B);
                  body.emit(assign(r0485, logic_and(r0488, r0489), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0486->else_instructions;

                  body.emit(assign(r0485, body.constant(false), 0x01));


               body.instructions = f0486_parent_instructions;
               body.emit(f0486);

               /* END IF */

               body.emit(assign(r0482, logic_and(r0485, r047E), 0x01));


            body.instructions = f0483_parent_instructions;
            body.emit(f0483);

            /* END IF */

            /* IF CONDITION */
            ir_if *f048A = new(mem_ctx) ir_if(operand(r0482).val);
            exec_list *const f048A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f048A->then_instructions;

               ir_variable *const r048B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r048B);
               ir_expression *const r048C = lshift(r03D3, body.constant(int(31)));
               body.emit(assign(r048B, add(r048C, body.constant(2146435072u)), 0x02));

               body.emit(assign(r048B, body.constant(0u), 0x01));

               body.emit(assign(r047D, r048B, 0x03));

               body.emit(assign(r047C, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f048A->else_instructions;

               /* IF CONDITION */
               ir_expression *const r048E = less(r0439, body.constant(int(0)));
               ir_if *f048D = new(mem_ctx) ir_if(operand(r048E).val);
               exec_list *const f048D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f048D->then_instructions;

                  ir_variable *const r048F = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r048F, r043C, 0x01));

                  ir_variable *const r0490 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0490, neg(r0439), 0x01));

                  ir_variable *const r0491 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0491);
                  ir_variable *const r0492 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0492);
                  ir_variable *const r0493 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0493);
                  ir_variable *const r0494 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0495 = neg(r0490);
                  body.emit(assign(r0494, bit_and(r0495, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0497 = equal(r0490, body.constant(int(0)));
                  ir_if *f0496 = new(mem_ctx) ir_if(operand(r0497).val);
                  exec_list *const f0496_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0496->then_instructions;

                     body.emit(assign(r0491, r043C, 0x01));

                     body.emit(assign(r0492, r043B, 0x01));

                     body.emit(assign(r0493, r043A, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0496->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0499 = less(r0490, body.constant(int(32)));
                     ir_if *f0498 = new(mem_ctx) ir_if(operand(r0499).val);
                     exec_list *const f0498_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0498->then_instructions;

                        body.emit(assign(r0491, lshift(r043B, r0494), 0x01));

                        ir_expression *const r049A = lshift(r043A, r0494);
                        ir_expression *const r049B = rshift(r043B, r0490);
                        body.emit(assign(r0492, bit_or(r049A, r049B), 0x01));

                        body.emit(assign(r0493, rshift(r043A, r0490), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0498->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r049D = equal(r0490, body.constant(int(32)));
                        ir_if *f049C = new(mem_ctx) ir_if(operand(r049D).val);
                        exec_list *const f049C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f049C->then_instructions;

                           body.emit(assign(r0491, r043B, 0x01));

                           body.emit(assign(r0492, r043A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f049C->else_instructions;

                           body.emit(assign(r048F, bit_or(r043C, r043B), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r049F = less(r0490, body.constant(int(64)));
                           ir_if *f049E = new(mem_ctx) ir_if(operand(r049F).val);
                           exec_list *const f049E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f049E->then_instructions;

                              body.emit(assign(r0491, lshift(r043A, r0494), 0x01));

                              ir_expression *const r04A0 = bit_and(r0490, body.constant(int(31)));
                              body.emit(assign(r0492, rshift(r043A, r04A0), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f049E->else_instructions;

                              ir_variable *const r04A1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r04A3 = equal(r0490, body.constant(int(64)));
                              ir_if *f04A2 = new(mem_ctx) ir_if(operand(r04A3).val);
                              exec_list *const f04A2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f04A2->then_instructions;

                                 body.emit(assign(r04A1, r043A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f04A2->else_instructions;

                                 ir_expression *const r04A4 = nequal(r043A, body.constant(0u));
                                 ir_expression *const r04A5 = expr(ir_unop_b2i, r04A4);
                                 body.emit(assign(r04A1, expr(ir_unop_i2u, r04A5), 0x01));


                              body.instructions = f04A2_parent_instructions;
                              body.emit(f04A2);

                              /* END IF */

                              body.emit(assign(r0491, r04A1, 0x01));

                              body.emit(assign(r0492, body.constant(0u), 0x01));


                           body.instructions = f049E_parent_instructions;
                           body.emit(f049E);

                           /* END IF */


                        body.instructions = f049C_parent_instructions;
                        body.emit(f049C);

                        /* END IF */

                        body.emit(assign(r0493, body.constant(0u), 0x01));


                     body.instructions = f0498_parent_instructions;
                     body.emit(f0498);

                     /* END IF */

                     ir_expression *const r04A6 = nequal(r048F, body.constant(0u));
                     ir_expression *const r04A7 = expr(ir_unop_b2i, r04A6);
                     ir_expression *const r04A8 = expr(ir_unop_i2u, r04A7);
                     body.emit(assign(r0491, bit_or(r0491, r04A8), 0x01));


                  body.instructions = f0496_parent_instructions;
                  body.emit(f0496);

                  /* END IF */

                  body.emit(assign(r0479, r0493, 0x01));

                  body.emit(assign(r047A, r0492, 0x01));

                  body.emit(assign(r047B, r0491, 0x01));

                  body.emit(assign(r0478, body.constant(int(0)), 0x01));

                  body.emit(assign(r047E, less(r0491, body.constant(0u)), 0x01));


               body.instructions = f048D_parent_instructions;
               body.emit(f048D);

               /* END IF */


            body.instructions = f048A_parent_instructions;
            body.emit(f048A);

            /* END IF */


         body.instructions = f0480_parent_instructions;
         body.emit(f0480);

         /* END IF */

         /* IF CONDITION */
         ir_if *f04A9 = new(mem_ctx) ir_if(operand(r047C).val);
         exec_list *const f04A9_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04A9->then_instructions;

            /* IF CONDITION */
            ir_if *f04AA = new(mem_ctx) ir_if(operand(r047E).val);
            exec_list *const f04AA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04AA->then_instructions;

               ir_variable *const r04AB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r04AB, add(r047A, body.constant(1u)), 0x01));

               ir_expression *const r04AC = less(r04AB, r047A);
               ir_expression *const r04AD = expr(ir_unop_b2i, r04AC);
               ir_expression *const r04AE = expr(ir_unop_i2u, r04AD);
               body.emit(assign(r0479, add(r0479, r04AE), 0x01));

               ir_expression *const r04AF = equal(r047B, body.constant(0u));
               ir_expression *const r04B0 = expr(ir_unop_b2i, r04AF);
               ir_expression *const r04B1 = expr(ir_unop_i2u, r04B0);
               ir_expression *const r04B2 = add(r047B, r04B1);
               ir_expression *const r04B3 = bit_and(r04B2, body.constant(1u));
               ir_expression *const r04B4 = expr(ir_unop_bit_not, r04B3);
               body.emit(assign(r047A, bit_and(r04AB, r04B4), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04AA->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04B6 = bit_or(r0479, r047A);
               ir_expression *const r04B7 = equal(r04B6, body.constant(0u));
               ir_if *f04B5 = new(mem_ctx) ir_if(operand(r04B7).val);
               exec_list *const f04B5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04B5->then_instructions;

                  body.emit(assign(r0478, body.constant(int(0)), 0x01));


               body.instructions = f04B5_parent_instructions;
               body.emit(f04B5);

               /* END IF */


            body.instructions = f04AA_parent_instructions;
            body.emit(f04AA);

            /* END IF */

            ir_variable *const r04B8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r04B8);
            ir_expression *const r04B9 = lshift(r03D3, body.constant(int(31)));
            ir_expression *const r04BA = expr(ir_unop_i2u, r0478);
            ir_expression *const r04BB = lshift(r04BA, body.constant(int(20)));
            ir_expression *const r04BC = add(r04B9, r04BB);
            body.emit(assign(r04B8, add(r04BC, r0479), 0x02));

            body.emit(assign(r04B8, r047A, 0x01));

            body.emit(assign(r047D, r04B8, 0x03));

            body.emit(assign(r047C, body.constant(false), 0x01));


         body.instructions = f04A9_parent_instructions;
         body.emit(f04A9);

         /* END IF */

         body.emit(assign(r03D4, r047D, 0x03));


      body.instructions = f03EF_parent_instructions;
      body.emit(f03EF);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f03ED->else_instructions;

      /* IF CONDITION */
      ir_expression *const r04BE = less(r03D5, body.constant(int(0)));
      ir_if *f04BD = new(mem_ctx) ir_if(operand(r04BE).val);
      exec_list *const f04BD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f04BD->then_instructions;

         /* IF CONDITION */
         ir_expression *const r04C0 = equal(r03E0, body.constant(int(2047)));
         ir_if *f04BF = new(mem_ctx) ir_if(operand(r04C0).val);
         exec_list *const f04BF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04BF->then_instructions;

            /* IF CONDITION */
            ir_expression *const r04C2 = bit_or(r03D8, r03D9);
            ir_expression *const r04C3 = nequal(r04C2, body.constant(0u));
            ir_if *f04C1 = new(mem_ctx) ir_if(operand(r04C3).val);
            exec_list *const f04C1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04C1->then_instructions;

               ir_variable *const r04C4 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r04C4, swizzle_x(r03D1), 0x01));

               ir_variable *const r04C5 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r04C5, swizzle_x(r03D2), 0x01));

               ir_variable *const r04C6 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r04C7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r04C8 = rshift(swizzle_y(r03D1), body.constant(int(19)));
               ir_expression *const r04C9 = bit_and(r04C8, body.constant(4095u));
               ir_expression *const r04CA = equal(r04C9, body.constant(4094u));
               ir_expression *const r04CB = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r04CC = bit_and(swizzle_y(r03D1), body.constant(524287u));
               ir_expression *const r04CD = nequal(r04CC, body.constant(0u));
               ir_expression *const r04CE = logic_or(r04CB, r04CD);
               body.emit(assign(r04C7, logic_and(r04CA, r04CE), 0x01));

               ir_variable *const r04CF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r04D0 = lshift(swizzle_y(r03D2), body.constant(int(1)));
               ir_expression *const r04D1 = lequal(body.constant(4292870144u), r04D0);
               ir_expression *const r04D2 = nequal(swizzle_x(r03D2), body.constant(0u));
               ir_expression *const r04D3 = bit_and(swizzle_y(r03D2), body.constant(1048575u));
               ir_expression *const r04D4 = nequal(r04D3, body.constant(0u));
               ir_expression *const r04D5 = logic_or(r04D2, r04D4);
               body.emit(assign(r04CF, logic_and(r04D1, r04D5), 0x01));

               body.emit(assign(r04C4, bit_or(swizzle_y(r03D1), body.constant(524288u)), 0x02));

               body.emit(assign(r04C5, bit_or(swizzle_y(r03D2), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r04D7 = lshift(swizzle_y(r03D1), body.constant(int(1)));
               ir_expression *const r04D8 = lequal(body.constant(4292870144u), r04D7);
               ir_expression *const r04D9 = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r04DA = bit_and(swizzle_y(r03D1), body.constant(1048575u));
               ir_expression *const r04DB = nequal(r04DA, body.constant(0u));
               ir_expression *const r04DC = logic_or(r04D9, r04DB);
               ir_expression *const r04DD = logic_and(r04D8, r04DC);
               ir_if *f04D6 = new(mem_ctx) ir_if(operand(r04DD).val);
               exec_list *const f04D6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04D6->then_instructions;

                  ir_variable *const r04DE = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r04E0 = logic_and(r04C7, r04CF);
                  ir_if *f04DF = new(mem_ctx) ir_if(operand(r04E0).val);
                  exec_list *const f04DF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04DF->then_instructions;

                     body.emit(assign(r04DE, r04C5, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04DF->else_instructions;

                     body.emit(assign(r04DE, r04C4, 0x03));


                  body.instructions = f04DF_parent_instructions;
                  body.emit(f04DF);

                  /* END IF */

                  body.emit(assign(r04C6, r04DE, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04D6->else_instructions;

                  body.emit(assign(r04C6, r04C5, 0x03));


               body.instructions = f04D6_parent_instructions;
               body.emit(f04D6);

               /* END IF */

               body.emit(assign(r03D4, r04C6, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04C1->else_instructions;

               ir_variable *const r04E1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r04E1);
               ir_expression *const r04E2 = bit_xor(r03D3, body.constant(1u));
               ir_expression *const r04E3 = lshift(r04E2, body.constant(int(31)));
               body.emit(assign(r04E1, add(r04E3, body.constant(2146435072u)), 0x02));

               body.emit(assign(r04E1, body.constant(0u), 0x01));

               body.emit(assign(r03D4, r04E1, 0x03));


            body.instructions = f04C1_parent_instructions;
            body.emit(f04C1);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f04BF->else_instructions;

            /* IF CONDITION */
            ir_expression *const r04E5 = equal(r03DD, body.constant(int(0)));
            ir_if *f04E4 = new(mem_ctx) ir_if(operand(r04E5).val);
            exec_list *const f04E4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04E4->then_instructions;

               body.emit(assign(r03D5, add(r03D5, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04E4->else_instructions;

               body.emit(assign(r03DA, bit_or(r03DA, body.constant(1073741824u)), 0x01));


            body.instructions = f04E4_parent_instructions;
            body.emit(f04E4);

            /* END IF */

            ir_variable *const r04E6 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r04E6, neg(r03D5), 0x01));

            ir_variable *const r04E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r04E7);
            ir_variable *const r04E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r04E8);
            ir_variable *const r04E9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r04EA = neg(r04E6);
            body.emit(assign(r04E9, bit_and(r04EA, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r04EC = equal(r04E6, body.constant(int(0)));
            ir_if *f04EB = new(mem_ctx) ir_if(operand(r04EC).val);
            exec_list *const f04EB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04EB->then_instructions;

               body.emit(assign(r04E7, r03E3, 0x01));

               body.emit(assign(r04E8, r03DA, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04EB->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04EE = less(r04E6, body.constant(int(32)));
               ir_if *f04ED = new(mem_ctx) ir_if(operand(r04EE).val);
               exec_list *const f04ED_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04ED->then_instructions;

                  ir_expression *const r04EF = lshift(r03DA, r04E9);
                  ir_expression *const r04F0 = rshift(r03E3, r04E6);
                  ir_expression *const r04F1 = bit_or(r04EF, r04F0);
                  ir_expression *const r04F2 = lshift(r03E3, r04E9);
                  ir_expression *const r04F3 = nequal(r04F2, body.constant(0u));
                  ir_expression *const r04F4 = expr(ir_unop_b2i, r04F3);
                  ir_expression *const r04F5 = expr(ir_unop_i2u, r04F4);
                  body.emit(assign(r04E7, bit_or(r04F1, r04F5), 0x01));

                  body.emit(assign(r04E8, rshift(r03DA, r04E6), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04ED->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r04F7 = equal(r04E6, body.constant(int(32)));
                  ir_if *f04F6 = new(mem_ctx) ir_if(operand(r04F7).val);
                  exec_list *const f04F6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04F6->then_instructions;

                     ir_expression *const r04F8 = nequal(r03E3, body.constant(0u));
                     ir_expression *const r04F9 = expr(ir_unop_b2i, r04F8);
                     ir_expression *const r04FA = expr(ir_unop_i2u, r04F9);
                     body.emit(assign(r04E7, bit_or(r03DA, r04FA), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04F6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r04FC = less(r04E6, body.constant(int(64)));
                     ir_if *f04FB = new(mem_ctx) ir_if(operand(r04FC).val);
                     exec_list *const f04FB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f04FB->then_instructions;

                        ir_expression *const r04FD = bit_and(r04E6, body.constant(int(31)));
                        ir_expression *const r04FE = rshift(r03DA, r04FD);
                        ir_expression *const r04FF = lshift(r03DA, r04E9);
                        ir_expression *const r0500 = bit_or(r04FF, r03E3);
                        ir_expression *const r0501 = nequal(r0500, body.constant(0u));
                        ir_expression *const r0502 = expr(ir_unop_b2i, r0501);
                        ir_expression *const r0503 = expr(ir_unop_i2u, r0502);
                        body.emit(assign(r04E7, bit_or(r04FE, r0503), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f04FB->else_instructions;

                        ir_expression *const r0504 = bit_or(r03DA, r03E3);
                        ir_expression *const r0505 = nequal(r0504, body.constant(0u));
                        ir_expression *const r0506 = expr(ir_unop_b2i, r0505);
                        body.emit(assign(r04E7, expr(ir_unop_i2u, r0506), 0x01));


                     body.instructions = f04FB_parent_instructions;
                     body.emit(f04FB);

                     /* END IF */


                  body.instructions = f04F6_parent_instructions;
                  body.emit(f04F6);

                  /* END IF */

                  body.emit(assign(r04E8, body.constant(0u), 0x01));


               body.instructions = f04ED_parent_instructions;
               body.emit(f04ED);

               /* END IF */


            body.instructions = f04EB_parent_instructions;
            body.emit(f04EB);

            /* END IF */

            body.emit(assign(r03DA, r04E8, 0x01));

            body.emit(assign(r03DB, r04E7, 0x01));

            body.emit(assign(r03D8, bit_or(r03D8, body.constant(1073741824u)), 0x01));

            ir_variable *const r0507 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r0508 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0508, sub(r03D9, r04E7), 0x01));

            ir_expression *const r0509 = sub(r03D8, r04E8);
            ir_expression *const r050A = less(r03D9, r04E7);
            ir_expression *const r050B = expr(ir_unop_b2i, r050A);
            ir_expression *const r050C = expr(ir_unop_i2u, r050B);
            body.emit(assign(r0507, sub(r0509, r050C), 0x01));

            body.emit(assign(r03D3, bit_xor(r03D3, body.constant(1u)), 0x01));

            body.emit(assign(r03DC, add(r03E0, body.constant(int(-1))), 0x01));

            ir_variable *const r050D = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r050D, add(r03DC, body.constant(int(-10))), 0x01));

            ir_variable *const r050E = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r050E, r0507, 0x01));

            ir_variable *const r050F = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r050F, r0508, 0x01));

            ir_variable *const r0510 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0510);
            ir_variable *const r0511 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0511);
            /* IF CONDITION */
            ir_expression *const r0513 = equal(r0507, body.constant(0u));
            ir_if *f0512 = new(mem_ctx) ir_if(operand(r0513).val);
            exec_list *const f0512_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0512->then_instructions;

               body.emit(assign(r050E, r0508, 0x01));

               body.emit(assign(r050F, body.constant(0u), 0x01));

               body.emit(assign(r050D, add(r050D, body.constant(int(-32))), 0x01));


            body.instructions = f0512_parent_instructions;
            body.emit(f0512);

            /* END IF */

            ir_variable *const r0514 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0514, r050E, 0x01));

            ir_variable *const r0515 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0516 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0516);
            /* IF CONDITION */
            ir_expression *const r0518 = equal(r050E, body.constant(0u));
            ir_if *f0517 = new(mem_ctx) ir_if(operand(r0518).val);
            exec_list *const f0517_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0517->then_instructions;

               body.emit(assign(r0515, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0517->else_instructions;

               body.emit(assign(r0516, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r051A = bit_and(r050E, body.constant(4294901760u));
               ir_expression *const r051B = equal(r051A, body.constant(0u));
               ir_if *f0519 = new(mem_ctx) ir_if(operand(r051B).val);
               exec_list *const f0519_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0519->then_instructions;

                  body.emit(assign(r0516, body.constant(int(16)), 0x01));

                  body.emit(assign(r0514, lshift(r050E, body.constant(int(16))), 0x01));


               body.instructions = f0519_parent_instructions;
               body.emit(f0519);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r051D = bit_and(r0514, body.constant(4278190080u));
               ir_expression *const r051E = equal(r051D, body.constant(0u));
               ir_if *f051C = new(mem_ctx) ir_if(operand(r051E).val);
               exec_list *const f051C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051C->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(8))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(8))), 0x01));


               body.instructions = f051C_parent_instructions;
               body.emit(f051C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0520 = bit_and(r0514, body.constant(4026531840u));
               ir_expression *const r0521 = equal(r0520, body.constant(0u));
               ir_if *f051F = new(mem_ctx) ir_if(operand(r0521).val);
               exec_list *const f051F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051F->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(4))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(4))), 0x01));


               body.instructions = f051F_parent_instructions;
               body.emit(f051F);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0523 = bit_and(r0514, body.constant(3221225472u));
               ir_expression *const r0524 = equal(r0523, body.constant(0u));
               ir_if *f0522 = new(mem_ctx) ir_if(operand(r0524).val);
               exec_list *const f0522_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0522->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(2))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(2))), 0x01));


               body.instructions = f0522_parent_instructions;
               body.emit(f0522);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0526 = bit_and(r0514, body.constant(2147483648u));
               ir_expression *const r0527 = equal(r0526, body.constant(0u));
               ir_if *f0525 = new(mem_ctx) ir_if(operand(r0527).val);
               exec_list *const f0525_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0525->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(1))), 0x01));


               body.instructions = f0525_parent_instructions;
               body.emit(f0525);

               /* END IF */

               body.emit(assign(r0515, r0516, 0x01));


            body.instructions = f0517_parent_instructions;
            body.emit(f0517);

            /* END IF */

            body.emit(assign(r0511, add(r0515, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0529 = lequal(body.constant(int(0)), r0511);
            ir_if *f0528 = new(mem_ctx) ir_if(operand(r0529).val);
            exec_list *const f0528_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0528->then_instructions;

               body.emit(assign(r0510, body.constant(0u), 0x01));

               ir_variable *const r052A = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r052A, lshift(r050F, r0511), 0x01));

               ir_variable *const r052B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r052D = equal(r0511, body.constant(int(0)));
               ir_if *f052C = new(mem_ctx) ir_if(operand(r052D).val);
               exec_list *const f052C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f052C->then_instructions;

                  body.emit(assign(r052B, r050E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f052C->else_instructions;

                  ir_expression *const r052E = lshift(r050E, r0511);
                  ir_expression *const r052F = neg(r0511);
                  ir_expression *const r0530 = bit_and(r052F, body.constant(int(31)));
                  ir_expression *const r0531 = rshift(r050F, r0530);
                  body.emit(assign(r052B, bit_or(r052E, r0531), 0x01));


               body.instructions = f052C_parent_instructions;
               body.emit(f052C);

               /* END IF */

               body.emit(assign(r050E, r052B, 0x01));

               body.emit(assign(r050F, r052A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0528->else_instructions;

               ir_variable *const r0532 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0532, body.constant(0u), 0x01));

               ir_variable *const r0533 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0533, neg(r0511), 0x01));

               ir_variable *const r0534 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0534);
               ir_variable *const r0535 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0535);
               ir_variable *const r0536 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0536);
               ir_variable *const r0537 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0538 = neg(r0533);
               body.emit(assign(r0537, bit_and(r0538, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r053A = equal(r0533, body.constant(int(0)));
               ir_if *f0539 = new(mem_ctx) ir_if(operand(r053A).val);
               exec_list *const f0539_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0539->then_instructions;

                  body.emit(assign(r0534, r0532, 0x01));

                  body.emit(assign(r0535, r050F, 0x01));

                  body.emit(assign(r0536, r050E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0539->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r053C = less(r0533, body.constant(int(32)));
                  ir_if *f053B = new(mem_ctx) ir_if(operand(r053C).val);
                  exec_list *const f053B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f053B->then_instructions;

                     body.emit(assign(r0534, lshift(r050F, r0537), 0x01));

                     ir_expression *const r053D = lshift(r050E, r0537);
                     ir_expression *const r053E = rshift(r050F, r0533);
                     body.emit(assign(r0535, bit_or(r053D, r053E), 0x01));

                     body.emit(assign(r0536, rshift(r050E, r0533), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f053B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0540 = equal(r0533, body.constant(int(32)));
                     ir_if *f053F = new(mem_ctx) ir_if(operand(r0540).val);
                     exec_list *const f053F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f053F->then_instructions;

                        body.emit(assign(r0534, r050F, 0x01));

                        body.emit(assign(r0535, r050E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f053F->else_instructions;

                        body.emit(assign(r0532, bit_or(body.constant(0u), r050F), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0542 = less(r0533, body.constant(int(64)));
                        ir_if *f0541 = new(mem_ctx) ir_if(operand(r0542).val);
                        exec_list *const f0541_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0541->then_instructions;

                           body.emit(assign(r0534, lshift(r050E, r0537), 0x01));

                           ir_expression *const r0543 = bit_and(r0533, body.constant(int(31)));
                           body.emit(assign(r0535, rshift(r050E, r0543), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0541->else_instructions;

                           ir_variable *const r0544 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0546 = equal(r0533, body.constant(int(64)));
                           ir_if *f0545 = new(mem_ctx) ir_if(operand(r0546).val);
                           exec_list *const f0545_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0545->then_instructions;

                              body.emit(assign(r0544, r050E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0545->else_instructions;

                              ir_expression *const r0547 = nequal(r050E, body.constant(0u));
                              ir_expression *const r0548 = expr(ir_unop_b2i, r0547);
                              body.emit(assign(r0544, expr(ir_unop_i2u, r0548), 0x01));


                           body.instructions = f0545_parent_instructions;
                           body.emit(f0545);

                           /* END IF */

                           body.emit(assign(r0534, r0544, 0x01));

                           body.emit(assign(r0535, body.constant(0u), 0x01));


                        body.instructions = f0541_parent_instructions;
                        body.emit(f0541);

                        /* END IF */


                     body.instructions = f053F_parent_instructions;
                     body.emit(f053F);

                     /* END IF */

                     body.emit(assign(r0536, body.constant(0u), 0x01));


                  body.instructions = f053B_parent_instructions;
                  body.emit(f053B);

                  /* END IF */

                  ir_expression *const r0549 = nequal(r0532, body.constant(0u));
                  ir_expression *const r054A = expr(ir_unop_b2i, r0549);
                  ir_expression *const r054B = expr(ir_unop_i2u, r054A);
                  body.emit(assign(r0534, bit_or(r0534, r054B), 0x01));


               body.instructions = f0539_parent_instructions;
               body.emit(f0539);

               /* END IF */

               body.emit(assign(r050E, r0536, 0x01));

               body.emit(assign(r050F, r0535, 0x01));

               body.emit(assign(r0510, r0534, 0x01));


            body.instructions = f0528_parent_instructions;
            body.emit(f0528);

            /* END IF */

            body.emit(assign(r050D, sub(r050D, r0511), 0x01));

            ir_variable *const r054C = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r054C, r050D, 0x01));

            ir_variable *const r054D = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r054D, r050E, 0x01));

            ir_variable *const r054E = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r054E, r050F, 0x01));

            ir_variable *const r054F = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r054F, r0510, 0x01));

            ir_variable *const r0550 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0550, body.constant(true), 0x01));

            ir_variable *const r0551 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0552 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0552);
            ir_expression *const r0553 = expr(ir_unop_u2i, r0510);
            body.emit(assign(r0552, less(r0553, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0555 = lequal(body.constant(int(2045)), r050D);
            ir_if *f0554 = new(mem_ctx) ir_if(operand(r0555).val);
            exec_list *const f0554_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0554->then_instructions;

               ir_variable *const r0556 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0558 = less(body.constant(int(2045)), r050D);
               ir_if *f0557 = new(mem_ctx) ir_if(operand(r0558).val);
               exec_list *const f0557_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0557->then_instructions;

                  body.emit(assign(r0556, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0557->else_instructions;

                  ir_variable *const r0559 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r055B = equal(r050D, body.constant(int(2045)));
                  ir_if *f055A = new(mem_ctx) ir_if(operand(r055B).val);
                  exec_list *const f055A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f055A->then_instructions;

                     ir_expression *const r055C = equal(body.constant(2097151u), r050E);
                     ir_expression *const r055D = equal(body.constant(4294967295u), r050F);
                     body.emit(assign(r0559, logic_and(r055C, r055D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f055A->else_instructions;

                     body.emit(assign(r0559, body.constant(false), 0x01));


                  body.instructions = f055A_parent_instructions;
                  body.emit(f055A);

                  /* END IF */

                  body.emit(assign(r0556, logic_and(r0559, r0552), 0x01));


               body.instructions = f0557_parent_instructions;
               body.emit(f0557);

               /* END IF */

               /* IF CONDITION */
               ir_if *f055E = new(mem_ctx) ir_if(operand(r0556).val);
               exec_list *const f055E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f055E->then_instructions;

                  ir_variable *const r055F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r055F);
                  ir_expression *const r0560 = lshift(r03D3, body.constant(int(31)));
                  body.emit(assign(r055F, add(r0560, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r055F, body.constant(0u), 0x01));

                  body.emit(assign(r0551, r055F, 0x03));

                  body.emit(assign(r0550, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f055E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0562 = less(r050D, body.constant(int(0)));
                  ir_if *f0561 = new(mem_ctx) ir_if(operand(r0562).val);
                  exec_list *const f0561_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0561->then_instructions;

                     ir_variable *const r0563 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0563, r0510, 0x01));

                     ir_variable *const r0564 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0564, neg(r050D), 0x01));

                     ir_variable *const r0565 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0565);
                     ir_variable *const r0566 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0566);
                     ir_variable *const r0567 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0567);
                     ir_variable *const r0568 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0569 = neg(r0564);
                     body.emit(assign(r0568, bit_and(r0569, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r056B = equal(r0564, body.constant(int(0)));
                     ir_if *f056A = new(mem_ctx) ir_if(operand(r056B).val);
                     exec_list *const f056A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f056A->then_instructions;

                        body.emit(assign(r0565, r0510, 0x01));

                        body.emit(assign(r0566, r050F, 0x01));

                        body.emit(assign(r0567, r050E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f056A->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r056D = less(r0564, body.constant(int(32)));
                        ir_if *f056C = new(mem_ctx) ir_if(operand(r056D).val);
                        exec_list *const f056C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f056C->then_instructions;

                           body.emit(assign(r0565, lshift(r050F, r0568), 0x01));

                           ir_expression *const r056E = lshift(r050E, r0568);
                           ir_expression *const r056F = rshift(r050F, r0564);
                           body.emit(assign(r0566, bit_or(r056E, r056F), 0x01));

                           body.emit(assign(r0567, rshift(r050E, r0564), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f056C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0571 = equal(r0564, body.constant(int(32)));
                           ir_if *f0570 = new(mem_ctx) ir_if(operand(r0571).val);
                           exec_list *const f0570_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0570->then_instructions;

                              body.emit(assign(r0565, r050F, 0x01));

                              body.emit(assign(r0566, r050E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0570->else_instructions;

                              body.emit(assign(r0563, bit_or(r0510, r050F), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0573 = less(r0564, body.constant(int(64)));
                              ir_if *f0572 = new(mem_ctx) ir_if(operand(r0573).val);
                              exec_list *const f0572_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0572->then_instructions;

                                 body.emit(assign(r0565, lshift(r050E, r0568), 0x01));

                                 ir_expression *const r0574 = bit_and(r0564, body.constant(int(31)));
                                 body.emit(assign(r0566, rshift(r050E, r0574), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0572->else_instructions;

                                 ir_variable *const r0575 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0577 = equal(r0564, body.constant(int(64)));
                                 ir_if *f0576 = new(mem_ctx) ir_if(operand(r0577).val);
                                 exec_list *const f0576_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0576->then_instructions;

                                    body.emit(assign(r0575, r050E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0576->else_instructions;

                                    ir_expression *const r0578 = nequal(r050E, body.constant(0u));
                                    ir_expression *const r0579 = expr(ir_unop_b2i, r0578);
                                    body.emit(assign(r0575, expr(ir_unop_i2u, r0579), 0x01));


                                 body.instructions = f0576_parent_instructions;
                                 body.emit(f0576);

                                 /* END IF */

                                 body.emit(assign(r0565, r0575, 0x01));

                                 body.emit(assign(r0566, body.constant(0u), 0x01));


                              body.instructions = f0572_parent_instructions;
                              body.emit(f0572);

                              /* END IF */


                           body.instructions = f0570_parent_instructions;
                           body.emit(f0570);

                           /* END IF */

                           body.emit(assign(r0567, body.constant(0u), 0x01));


                        body.instructions = f056C_parent_instructions;
                        body.emit(f056C);

                        /* END IF */

                        ir_expression *const r057A = nequal(r0563, body.constant(0u));
                        ir_expression *const r057B = expr(ir_unop_b2i, r057A);
                        ir_expression *const r057C = expr(ir_unop_i2u, r057B);
                        body.emit(assign(r0565, bit_or(r0565, r057C), 0x01));


                     body.instructions = f056A_parent_instructions;
                     body.emit(f056A);

                     /* END IF */

                     body.emit(assign(r054D, r0567, 0x01));

                     body.emit(assign(r054E, r0566, 0x01));

                     body.emit(assign(r054F, r0565, 0x01));

                     body.emit(assign(r054C, body.constant(int(0)), 0x01));

                     body.emit(assign(r0552, less(r0565, body.constant(0u)), 0x01));


                  body.instructions = f0561_parent_instructions;
                  body.emit(f0561);

                  /* END IF */


               body.instructions = f055E_parent_instructions;
               body.emit(f055E);

               /* END IF */


            body.instructions = f0554_parent_instructions;
            body.emit(f0554);

            /* END IF */

            /* IF CONDITION */
            ir_if *f057D = new(mem_ctx) ir_if(operand(r0550).val);
            exec_list *const f057D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f057D->then_instructions;

               /* IF CONDITION */
               ir_if *f057E = new(mem_ctx) ir_if(operand(r0552).val);
               exec_list *const f057E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f057E->then_instructions;

                  ir_variable *const r057F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r057F, add(r054E, body.constant(1u)), 0x01));

                  ir_expression *const r0580 = less(r057F, r054E);
                  ir_expression *const r0581 = expr(ir_unop_b2i, r0580);
                  ir_expression *const r0582 = expr(ir_unop_i2u, r0581);
                  body.emit(assign(r054D, add(r054D, r0582), 0x01));

                  ir_expression *const r0583 = equal(r054F, body.constant(0u));
                  ir_expression *const r0584 = expr(ir_unop_b2i, r0583);
                  ir_expression *const r0585 = expr(ir_unop_i2u, r0584);
                  ir_expression *const r0586 = add(r054F, r0585);
                  ir_expression *const r0587 = bit_and(r0586, body.constant(1u));
                  ir_expression *const r0588 = expr(ir_unop_bit_not, r0587);
                  body.emit(assign(r054E, bit_and(r057F, r0588), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f057E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r058A = bit_or(r054D, r054E);
                  ir_expression *const r058B = equal(r058A, body.constant(0u));
                  ir_if *f0589 = new(mem_ctx) ir_if(operand(r058B).val);
                  exec_list *const f0589_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0589->then_instructions;

                     body.emit(assign(r054C, body.constant(int(0)), 0x01));


                  body.instructions = f0589_parent_instructions;
                  body.emit(f0589);

                  /* END IF */


               body.instructions = f057E_parent_instructions;
               body.emit(f057E);

               /* END IF */

               ir_variable *const r058C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r058C);
               ir_expression *const r058D = lshift(r03D3, body.constant(int(31)));
               ir_expression *const r058E = expr(ir_unop_i2u, r054C);
               ir_expression *const r058F = lshift(r058E, body.constant(int(20)));
               ir_expression *const r0590 = add(r058D, r058F);
               body.emit(assign(r058C, add(r0590, r054D), 0x02));

               body.emit(assign(r058C, r054E, 0x01));

               body.emit(assign(r0551, r058C, 0x03));

               body.emit(assign(r0550, body.constant(false), 0x01));


            body.instructions = f057D_parent_instructions;
            body.emit(f057D);

            /* END IF */

            body.emit(assign(r03D4, r0551, 0x03));


         body.instructions = f04BF_parent_instructions;
         body.emit(f04BF);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f04BD->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0592 = equal(r03DD, body.constant(int(2047)));
         ir_if *f0591 = new(mem_ctx) ir_if(operand(r0592).val);
         exec_list *const f0591_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0591->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0594 = bit_or(r03DA, r03DB);
            ir_expression *const r0595 = bit_or(r03D8, r03D9);
            ir_expression *const r0596 = bit_or(r0594, r0595);
            ir_expression *const r0597 = nequal(r0596, body.constant(0u));
            ir_if *f0593 = new(mem_ctx) ir_if(operand(r0597).val);
            exec_list *const f0593_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0593->then_instructions;

               ir_variable *const r0598 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0598, swizzle_x(r03D1), 0x01));

               ir_variable *const r0599 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0599, swizzle_x(r03D2), 0x01));

               ir_variable *const r059A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r059B = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r059C = rshift(swizzle_y(r03D1), body.constant(int(19)));
               ir_expression *const r059D = bit_and(r059C, body.constant(4095u));
               ir_expression *const r059E = equal(r059D, body.constant(4094u));
               ir_expression *const r059F = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r05A0 = bit_and(swizzle_y(r03D1), body.constant(524287u));
               ir_expression *const r05A1 = nequal(r05A0, body.constant(0u));
               ir_expression *const r05A2 = logic_or(r059F, r05A1);
               body.emit(assign(r059B, logic_and(r059E, r05A2), 0x01));

               ir_variable *const r05A3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r05A4 = lshift(swizzle_y(r03D2), body.constant(int(1)));
               ir_expression *const r05A5 = lequal(body.constant(4292870144u), r05A4);
               ir_expression *const r05A6 = nequal(swizzle_x(r03D2), body.constant(0u));
               ir_expression *const r05A7 = bit_and(swizzle_y(r03D2), body.constant(1048575u));
               ir_expression *const r05A8 = nequal(r05A7, body.constant(0u));
               ir_expression *const r05A9 = logic_or(r05A6, r05A8);
               body.emit(assign(r05A3, logic_and(r05A5, r05A9), 0x01));

               body.emit(assign(r0598, bit_or(swizzle_y(r03D1), body.constant(524288u)), 0x02));

               body.emit(assign(r0599, bit_or(swizzle_y(r03D2), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r05AB = lshift(swizzle_y(r03D1), body.constant(int(1)));
               ir_expression *const r05AC = lequal(body.constant(4292870144u), r05AB);
               ir_expression *const r05AD = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r05AE = bit_and(swizzle_y(r03D1), body.constant(1048575u));
               ir_expression *const r05AF = nequal(r05AE, body.constant(0u));
               ir_expression *const r05B0 = logic_or(r05AD, r05AF);
               ir_expression *const r05B1 = logic_and(r05AC, r05B0);
               ir_if *f05AA = new(mem_ctx) ir_if(operand(r05B1).val);
               exec_list *const f05AA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05AA->then_instructions;

                  ir_variable *const r05B2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05B4 = logic_and(r059B, r05A3);
                  ir_if *f05B3 = new(mem_ctx) ir_if(operand(r05B4).val);
                  exec_list *const f05B3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05B3->then_instructions;

                     body.emit(assign(r05B2, r0599, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05B3->else_instructions;

                     body.emit(assign(r05B2, r0598, 0x03));


                  body.instructions = f05B3_parent_instructions;
                  body.emit(f05B3);

                  /* END IF */

                  body.emit(assign(r059A, r05B2, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05AA->else_instructions;

                  body.emit(assign(r059A, r0599, 0x03));


               body.instructions = f05AA_parent_instructions;
               body.emit(f05AA);

               /* END IF */

               body.emit(assign(r03D4, r059A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0593->else_instructions;

               ir_constant_data r05B5_data;
               memset(&r05B5_data, 0, sizeof(ir_constant_data));
               r05B5_data.u[0] = 4294967295;
               r05B5_data.u[1] = 4294967295;
               ir_constant *const r05B5 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r05B5_data);
               body.emit(assign(r03D4, r05B5, 0x03));


            body.instructions = f0593_parent_instructions;
            body.emit(f0593);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0591->else_instructions;

            /* IF CONDITION */
            ir_expression *const r05B7 = equal(r03DD, body.constant(int(0)));
            ir_if *f05B6 = new(mem_ctx) ir_if(operand(r05B7).val);
            exec_list *const f05B6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B6->then_instructions;

               body.emit(assign(r03D7, body.constant(int(1)), 0x01));

               body.emit(assign(r03D6, body.constant(int(1)), 0x01));


            body.instructions = f05B6_parent_instructions;
            body.emit(f05B6);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r05B9 = less(r03D8, r03DA);
            ir_if *f05B8 = new(mem_ctx) ir_if(operand(r05B9).val);
            exec_list *const f05B8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B8->then_instructions;

               ir_variable *const r05BA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r05BB = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r05BB, sub(r03DB, r03D9), 0x01));

               ir_expression *const r05BC = sub(r03DA, r03D8);
               ir_expression *const r05BD = less(r03DB, r03D9);
               ir_expression *const r05BE = expr(ir_unop_b2i, r05BD);
               ir_expression *const r05BF = expr(ir_unop_i2u, r05BE);
               body.emit(assign(r05BA, sub(r05BC, r05BF), 0x01));

               body.emit(assign(r03DC, add(r03D7, body.constant(int(-1))), 0x01));

               ir_variable *const r05C0 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05C0, add(r03DC, body.constant(int(-10))), 0x01));

               ir_variable *const r05C1 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r05C1, r05BA, 0x01));

               ir_variable *const r05C2 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r05C2, r05BB, 0x01));

               ir_variable *const r05C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r05C3);
               ir_variable *const r05C4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05C4);
               /* IF CONDITION */
               ir_expression *const r05C6 = equal(r05BA, body.constant(0u));
               ir_if *f05C5 = new(mem_ctx) ir_if(operand(r05C6).val);
               exec_list *const f05C5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05C5->then_instructions;

                  body.emit(assign(r05C1, r05BB, 0x01));

                  body.emit(assign(r05C2, body.constant(0u), 0x01));

                  body.emit(assign(r05C0, add(r05C0, body.constant(int(-32))), 0x01));


               body.instructions = f05C5_parent_instructions;
               body.emit(f05C5);

               /* END IF */

               ir_variable *const r05C7 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r05C7, r05C1, 0x01));

               ir_variable *const r05C8 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r05C9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05C9);
               /* IF CONDITION */
               ir_expression *const r05CB = equal(r05C1, body.constant(0u));
               ir_if *f05CA = new(mem_ctx) ir_if(operand(r05CB).val);
               exec_list *const f05CA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05CA->then_instructions;

                  body.emit(assign(r05C8, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05CA->else_instructions;

                  body.emit(assign(r05C9, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05CD = bit_and(r05C1, body.constant(4294901760u));
                  ir_expression *const r05CE = equal(r05CD, body.constant(0u));
                  ir_if *f05CC = new(mem_ctx) ir_if(operand(r05CE).val);
                  exec_list *const f05CC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CC->then_instructions;

                     body.emit(assign(r05C9, body.constant(int(16)), 0x01));

                     body.emit(assign(r05C7, lshift(r05C1, body.constant(int(16))), 0x01));


                  body.instructions = f05CC_parent_instructions;
                  body.emit(f05CC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D0 = bit_and(r05C7, body.constant(4278190080u));
                  ir_expression *const r05D1 = equal(r05D0, body.constant(0u));
                  ir_if *f05CF = new(mem_ctx) ir_if(operand(r05D1).val);
                  exec_list *const f05CF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CF->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(8))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(8))), 0x01));


                  body.instructions = f05CF_parent_instructions;
                  body.emit(f05CF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D3 = bit_and(r05C7, body.constant(4026531840u));
                  ir_expression *const r05D4 = equal(r05D3, body.constant(0u));
                  ir_if *f05D2 = new(mem_ctx) ir_if(operand(r05D4).val);
                  exec_list *const f05D2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D2->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(4))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(4))), 0x01));


                  body.instructions = f05D2_parent_instructions;
                  body.emit(f05D2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D6 = bit_and(r05C7, body.constant(3221225472u));
                  ir_expression *const r05D7 = equal(r05D6, body.constant(0u));
                  ir_if *f05D5 = new(mem_ctx) ir_if(operand(r05D7).val);
                  exec_list *const f05D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D5->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(2))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(2))), 0x01));


                  body.instructions = f05D5_parent_instructions;
                  body.emit(f05D5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D9 = bit_and(r05C7, body.constant(2147483648u));
                  ir_expression *const r05DA = equal(r05D9, body.constant(0u));
                  ir_if *f05D8 = new(mem_ctx) ir_if(operand(r05DA).val);
                  exec_list *const f05D8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D8->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(1))), 0x01));


                  body.instructions = f05D8_parent_instructions;
                  body.emit(f05D8);

                  /* END IF */

                  body.emit(assign(r05C8, r05C9, 0x01));


               body.instructions = f05CA_parent_instructions;
               body.emit(f05CA);

               /* END IF */

               body.emit(assign(r05C4, add(r05C8, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r05DC = lequal(body.constant(int(0)), r05C4);
               ir_if *f05DB = new(mem_ctx) ir_if(operand(r05DC).val);
               exec_list *const f05DB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05DB->then_instructions;

                  body.emit(assign(r05C3, body.constant(0u), 0x01));

                  ir_variable *const r05DD = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r05DD, lshift(r05C2, r05C4), 0x01));

                  ir_variable *const r05DE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05E0 = equal(r05C4, body.constant(int(0)));
                  ir_if *f05DF = new(mem_ctx) ir_if(operand(r05E0).val);
                  exec_list *const f05DF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05DF->then_instructions;

                     body.emit(assign(r05DE, r05C1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05DF->else_instructions;

                     ir_expression *const r05E1 = lshift(r05C1, r05C4);
                     ir_expression *const r05E2 = neg(r05C4);
                     ir_expression *const r05E3 = bit_and(r05E2, body.constant(int(31)));
                     ir_expression *const r05E4 = rshift(r05C2, r05E3);
                     body.emit(assign(r05DE, bit_or(r05E1, r05E4), 0x01));


                  body.instructions = f05DF_parent_instructions;
                  body.emit(f05DF);

                  /* END IF */

                  body.emit(assign(r05C1, r05DE, 0x01));

                  body.emit(assign(r05C2, r05DD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05DB->else_instructions;

                  ir_variable *const r05E5 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r05E5, body.constant(0u), 0x01));

                  ir_variable *const r05E6 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r05E6, neg(r05C4), 0x01));

                  ir_variable *const r05E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r05E7);
                  ir_variable *const r05E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r05E8);
                  ir_variable *const r05E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r05E9);
                  ir_variable *const r05EA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r05EB = neg(r05E6);
                  body.emit(assign(r05EA, bit_and(r05EB, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05ED = equal(r05E6, body.constant(int(0)));
                  ir_if *f05EC = new(mem_ctx) ir_if(operand(r05ED).val);
                  exec_list *const f05EC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05EC->then_instructions;

                     body.emit(assign(r05E7, r05E5, 0x01));

                     body.emit(assign(r05E8, r05C2, 0x01));

                     body.emit(assign(r05E9, r05C1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05EC->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r05EF = less(r05E6, body.constant(int(32)));
                     ir_if *f05EE = new(mem_ctx) ir_if(operand(r05EF).val);
                     exec_list *const f05EE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f05EE->then_instructions;

                        body.emit(assign(r05E7, lshift(r05C2, r05EA), 0x01));

                        ir_expression *const r05F0 = lshift(r05C1, r05EA);
                        ir_expression *const r05F1 = rshift(r05C2, r05E6);
                        body.emit(assign(r05E8, bit_or(r05F0, r05F1), 0x01));

                        body.emit(assign(r05E9, rshift(r05C1, r05E6), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f05EE->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r05F3 = equal(r05E6, body.constant(int(32)));
                        ir_if *f05F2 = new(mem_ctx) ir_if(operand(r05F3).val);
                        exec_list *const f05F2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f05F2->then_instructions;

                           body.emit(assign(r05E7, r05C2, 0x01));

                           body.emit(assign(r05E8, r05C1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f05F2->else_instructions;

                           body.emit(assign(r05E5, bit_or(body.constant(0u), r05C2), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r05F5 = less(r05E6, body.constant(int(64)));
                           ir_if *f05F4 = new(mem_ctx) ir_if(operand(r05F5).val);
                           exec_list *const f05F4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f05F4->then_instructions;

                              body.emit(assign(r05E7, lshift(r05C1, r05EA), 0x01));

                              ir_expression *const r05F6 = bit_and(r05E6, body.constant(int(31)));
                              body.emit(assign(r05E8, rshift(r05C1, r05F6), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f05F4->else_instructions;

                              ir_variable *const r05F7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r05F9 = equal(r05E6, body.constant(int(64)));
                              ir_if *f05F8 = new(mem_ctx) ir_if(operand(r05F9).val);
                              exec_list *const f05F8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f05F8->then_instructions;

                                 body.emit(assign(r05F7, r05C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f05F8->else_instructions;

                                 ir_expression *const r05FA = nequal(r05C1, body.constant(0u));
                                 ir_expression *const r05FB = expr(ir_unop_b2i, r05FA);
                                 body.emit(assign(r05F7, expr(ir_unop_i2u, r05FB), 0x01));


                              body.instructions = f05F8_parent_instructions;
                              body.emit(f05F8);

                              /* END IF */

                              body.emit(assign(r05E7, r05F7, 0x01));

                              body.emit(assign(r05E8, body.constant(0u), 0x01));


                           body.instructions = f05F4_parent_instructions;
                           body.emit(f05F4);

                           /* END IF */


                        body.instructions = f05F2_parent_instructions;
                        body.emit(f05F2);

                        /* END IF */

                        body.emit(assign(r05E9, body.constant(0u), 0x01));


                     body.instructions = f05EE_parent_instructions;
                     body.emit(f05EE);

                     /* END IF */

                     ir_expression *const r05FC = nequal(r05E5, body.constant(0u));
                     ir_expression *const r05FD = expr(ir_unop_b2i, r05FC);
                     ir_expression *const r05FE = expr(ir_unop_i2u, r05FD);
                     body.emit(assign(r05E7, bit_or(r05E7, r05FE), 0x01));


                  body.instructions = f05EC_parent_instructions;
                  body.emit(f05EC);

                  /* END IF */

                  body.emit(assign(r05C1, r05E9, 0x01));

                  body.emit(assign(r05C2, r05E8, 0x01));

                  body.emit(assign(r05C3, r05E7, 0x01));


               body.instructions = f05DB_parent_instructions;
               body.emit(f05DB);

               /* END IF */

               body.emit(assign(r05C0, sub(r05C0, r05C4), 0x01));

               ir_variable *const r05FF = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05FF, r05C0, 0x01));

               ir_variable *const r0600 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0600, r05C1, 0x01));

               ir_variable *const r0601 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0601, r05C2, 0x01));

               ir_variable *const r0602 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0602, r05C3, 0x01));

               ir_variable *const r0603 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0603, body.constant(true), 0x01));

               ir_variable *const r0604 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0605 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0605);
               ir_expression *const r0606 = expr(ir_unop_u2i, r05C3);
               body.emit(assign(r0605, less(r0606, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0608 = lequal(body.constant(int(2045)), r05C0);
               ir_if *f0607 = new(mem_ctx) ir_if(operand(r0608).val);
               exec_list *const f0607_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0607->then_instructions;

                  ir_variable *const r0609 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r060B = less(body.constant(int(2045)), r05C0);
                  ir_if *f060A = new(mem_ctx) ir_if(operand(r060B).val);
                  exec_list *const f060A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f060A->then_instructions;

                     body.emit(assign(r0609, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f060A->else_instructions;

                     ir_variable *const r060C = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r060E = equal(r05C0, body.constant(int(2045)));
                     ir_if *f060D = new(mem_ctx) ir_if(operand(r060E).val);
                     exec_list *const f060D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f060D->then_instructions;

                        ir_expression *const r060F = equal(body.constant(2097151u), r05C1);
                        ir_expression *const r0610 = equal(body.constant(4294967295u), r05C2);
                        body.emit(assign(r060C, logic_and(r060F, r0610), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f060D->else_instructions;

                        body.emit(assign(r060C, body.constant(false), 0x01));


                     body.instructions = f060D_parent_instructions;
                     body.emit(f060D);

                     /* END IF */

                     body.emit(assign(r0609, logic_and(r060C, r0605), 0x01));


                  body.instructions = f060A_parent_instructions;
                  body.emit(f060A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0611 = new(mem_ctx) ir_if(operand(r0609).val);
                  exec_list *const f0611_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0611->then_instructions;

                     ir_variable *const r0612 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0612);
                     ir_expression *const r0613 = lshift(r03D3, body.constant(int(31)));
                     body.emit(assign(r0612, add(r0613, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0612, body.constant(0u), 0x01));

                     body.emit(assign(r0604, r0612, 0x03));

                     body.emit(assign(r0603, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0611->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0615 = less(r05C0, body.constant(int(0)));
                     ir_if *f0614 = new(mem_ctx) ir_if(operand(r0615).val);
                     exec_list *const f0614_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0614->then_instructions;

                        ir_variable *const r0616 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0616, r05C3, 0x01));

                        ir_variable *const r0617 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0617, neg(r05C0), 0x01));

                        ir_variable *const r0618 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0618);
                        ir_variable *const r0619 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0619);
                        ir_variable *const r061A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r061A);
                        ir_variable *const r061B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r061C = neg(r0617);
                        body.emit(assign(r061B, bit_and(r061C, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r061E = equal(r0617, body.constant(int(0)));
                        ir_if *f061D = new(mem_ctx) ir_if(operand(r061E).val);
                        exec_list *const f061D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f061D->then_instructions;

                           body.emit(assign(r0618, r05C3, 0x01));

                           body.emit(assign(r0619, r05C2, 0x01));

                           body.emit(assign(r061A, r05C1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f061D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0620 = less(r0617, body.constant(int(32)));
                           ir_if *f061F = new(mem_ctx) ir_if(operand(r0620).val);
                           exec_list *const f061F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f061F->then_instructions;

                              body.emit(assign(r0618, lshift(r05C2, r061B), 0x01));

                              ir_expression *const r0621 = lshift(r05C1, r061B);
                              ir_expression *const r0622 = rshift(r05C2, r0617);
                              body.emit(assign(r0619, bit_or(r0621, r0622), 0x01));

                              body.emit(assign(r061A, rshift(r05C1, r0617), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f061F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0624 = equal(r0617, body.constant(int(32)));
                              ir_if *f0623 = new(mem_ctx) ir_if(operand(r0624).val);
                              exec_list *const f0623_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0623->then_instructions;

                                 body.emit(assign(r0618, r05C2, 0x01));

                                 body.emit(assign(r0619, r05C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0623->else_instructions;

                                 body.emit(assign(r0616, bit_or(r05C3, r05C2), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0626 = less(r0617, body.constant(int(64)));
                                 ir_if *f0625 = new(mem_ctx) ir_if(operand(r0626).val);
                                 exec_list *const f0625_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0625->then_instructions;

                                    body.emit(assign(r0618, lshift(r05C1, r061B), 0x01));

                                    ir_expression *const r0627 = bit_and(r0617, body.constant(int(31)));
                                    body.emit(assign(r0619, rshift(r05C1, r0627), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0625->else_instructions;

                                    ir_variable *const r0628 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r062A = equal(r0617, body.constant(int(64)));
                                    ir_if *f0629 = new(mem_ctx) ir_if(operand(r062A).val);
                                    exec_list *const f0629_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0629->then_instructions;

                                       body.emit(assign(r0628, r05C1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0629->else_instructions;

                                       ir_expression *const r062B = nequal(r05C1, body.constant(0u));
                                       ir_expression *const r062C = expr(ir_unop_b2i, r062B);
                                       body.emit(assign(r0628, expr(ir_unop_i2u, r062C), 0x01));


                                    body.instructions = f0629_parent_instructions;
                                    body.emit(f0629);

                                    /* END IF */

                                    body.emit(assign(r0618, r0628, 0x01));

                                    body.emit(assign(r0619, body.constant(0u), 0x01));


                                 body.instructions = f0625_parent_instructions;
                                 body.emit(f0625);

                                 /* END IF */


                              body.instructions = f0623_parent_instructions;
                              body.emit(f0623);

                              /* END IF */

                              body.emit(assign(r061A, body.constant(0u), 0x01));


                           body.instructions = f061F_parent_instructions;
                           body.emit(f061F);

                           /* END IF */

                           ir_expression *const r062D = nequal(r0616, body.constant(0u));
                           ir_expression *const r062E = expr(ir_unop_b2i, r062D);
                           ir_expression *const r062F = expr(ir_unop_i2u, r062E);
                           body.emit(assign(r0618, bit_or(r0618, r062F), 0x01));


                        body.instructions = f061D_parent_instructions;
                        body.emit(f061D);

                        /* END IF */

                        body.emit(assign(r0600, r061A, 0x01));

                        body.emit(assign(r0601, r0619, 0x01));

                        body.emit(assign(r0602, r0618, 0x01));

                        body.emit(assign(r05FF, body.constant(int(0)), 0x01));

                        body.emit(assign(r0605, less(r0618, body.constant(0u)), 0x01));


                     body.instructions = f0614_parent_instructions;
                     body.emit(f0614);

                     /* END IF */


                  body.instructions = f0611_parent_instructions;
                  body.emit(f0611);

                  /* END IF */


               body.instructions = f0607_parent_instructions;
               body.emit(f0607);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0630 = new(mem_ctx) ir_if(operand(r0603).val);
               exec_list *const f0630_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0630->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0631 = new(mem_ctx) ir_if(operand(r0605).val);
                  exec_list *const f0631_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0631->then_instructions;

                     ir_variable *const r0632 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0632, add(r0601, body.constant(1u)), 0x01));

                     ir_expression *const r0633 = less(r0632, r0601);
                     ir_expression *const r0634 = expr(ir_unop_b2i, r0633);
                     ir_expression *const r0635 = expr(ir_unop_i2u, r0634);
                     body.emit(assign(r0600, add(r0600, r0635), 0x01));

                     ir_expression *const r0636 = equal(r0602, body.constant(0u));
                     ir_expression *const r0637 = expr(ir_unop_b2i, r0636);
                     ir_expression *const r0638 = expr(ir_unop_i2u, r0637);
                     ir_expression *const r0639 = add(r0602, r0638);
                     ir_expression *const r063A = bit_and(r0639, body.constant(1u));
                     ir_expression *const r063B = expr(ir_unop_bit_not, r063A);
                     body.emit(assign(r0601, bit_and(r0632, r063B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0631->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r063D = bit_or(r0600, r0601);
                     ir_expression *const r063E = equal(r063D, body.constant(0u));
                     ir_if *f063C = new(mem_ctx) ir_if(operand(r063E).val);
                     exec_list *const f063C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f063C->then_instructions;

                        body.emit(assign(r05FF, body.constant(int(0)), 0x01));


                     body.instructions = f063C_parent_instructions;
                     body.emit(f063C);

                     /* END IF */


                  body.instructions = f0631_parent_instructions;
                  body.emit(f0631);

                  /* END IF */

                  ir_variable *const r063F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r063F);
                  ir_expression *const r0640 = lshift(r03D3, body.constant(int(31)));
                  ir_expression *const r0641 = expr(ir_unop_i2u, r05FF);
                  ir_expression *const r0642 = lshift(r0641, body.constant(int(20)));
                  ir_expression *const r0643 = add(r0640, r0642);
                  body.emit(assign(r063F, add(r0643, r0600), 0x02));

                  body.emit(assign(r063F, r0601, 0x01));

                  body.emit(assign(r0604, r063F, 0x03));

                  body.emit(assign(r0603, body.constant(false), 0x01));


               body.instructions = f0630_parent_instructions;
               body.emit(f0630);

               /* END IF */

               body.emit(assign(r03D4, r0604, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f05B8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0645 = less(r03DA, r03D8);
               ir_if *f0644 = new(mem_ctx) ir_if(operand(r0645).val);
               exec_list *const f0644_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0644->then_instructions;

                  ir_variable *const r0646 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0647 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0647, sub(r03D9, r03DB), 0x01));

                  ir_expression *const r0648 = sub(r03D8, r03DA);
                  ir_expression *const r0649 = less(r03D9, r03DB);
                  ir_expression *const r064A = expr(ir_unop_b2i, r0649);
                  ir_expression *const r064B = expr(ir_unop_i2u, r064A);
                  body.emit(assign(r0646, sub(r0648, r064B), 0x01));

                  body.emit(assign(r03D3, bit_xor(r03D3, body.constant(1u)), 0x01));

                  body.emit(assign(r03DC, add(r03D6, body.constant(int(-1))), 0x01));

                  ir_variable *const r064C = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r064C, add(r03DC, body.constant(int(-10))), 0x01));

                  ir_variable *const r064D = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r064D, r0646, 0x01));

                  ir_variable *const r064E = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r064E, r0647, 0x01));

                  ir_variable *const r064F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r064F);
                  ir_variable *const r0650 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0650);
                  /* IF CONDITION */
                  ir_expression *const r0652 = equal(r0646, body.constant(0u));
                  ir_if *f0651 = new(mem_ctx) ir_if(operand(r0652).val);
                  exec_list *const f0651_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0651->then_instructions;

                     body.emit(assign(r064D, r0647, 0x01));

                     body.emit(assign(r064E, body.constant(0u), 0x01));

                     body.emit(assign(r064C, add(r064C, body.constant(int(-32))), 0x01));


                  body.instructions = f0651_parent_instructions;
                  body.emit(f0651);

                  /* END IF */

                  ir_variable *const r0653 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0653, r064D, 0x01));

                  ir_variable *const r0654 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0655 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0655);
                  /* IF CONDITION */
                  ir_expression *const r0657 = equal(r064D, body.constant(0u));
                  ir_if *f0656 = new(mem_ctx) ir_if(operand(r0657).val);
                  exec_list *const f0656_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0656->then_instructions;

                     body.emit(assign(r0654, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0656->else_instructions;

                     body.emit(assign(r0655, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0659 = bit_and(r064D, body.constant(4294901760u));
                     ir_expression *const r065A = equal(r0659, body.constant(0u));
                     ir_if *f0658 = new(mem_ctx) ir_if(operand(r065A).val);
                     exec_list *const f0658_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0658->then_instructions;

                        body.emit(assign(r0655, body.constant(int(16)), 0x01));

                        body.emit(assign(r0653, lshift(r064D, body.constant(int(16))), 0x01));


                     body.instructions = f0658_parent_instructions;
                     body.emit(f0658);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065C = bit_and(r0653, body.constant(4278190080u));
                     ir_expression *const r065D = equal(r065C, body.constant(0u));
                     ir_if *f065B = new(mem_ctx) ir_if(operand(r065D).val);
                     exec_list *const f065B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065B->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(8))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(8))), 0x01));


                     body.instructions = f065B_parent_instructions;
                     body.emit(f065B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065F = bit_and(r0653, body.constant(4026531840u));
                     ir_expression *const r0660 = equal(r065F, body.constant(0u));
                     ir_if *f065E = new(mem_ctx) ir_if(operand(r0660).val);
                     exec_list *const f065E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065E->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(4))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(4))), 0x01));


                     body.instructions = f065E_parent_instructions;
                     body.emit(f065E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0662 = bit_and(r0653, body.constant(3221225472u));
                     ir_expression *const r0663 = equal(r0662, body.constant(0u));
                     ir_if *f0661 = new(mem_ctx) ir_if(operand(r0663).val);
                     exec_list *const f0661_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0661->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(2))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(2))), 0x01));


                     body.instructions = f0661_parent_instructions;
                     body.emit(f0661);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0665 = bit_and(r0653, body.constant(2147483648u));
                     ir_expression *const r0666 = equal(r0665, body.constant(0u));
                     ir_if *f0664 = new(mem_ctx) ir_if(operand(r0666).val);
                     exec_list *const f0664_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0664->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(1))), 0x01));


                     body.instructions = f0664_parent_instructions;
                     body.emit(f0664);

                     /* END IF */

                     body.emit(assign(r0654, r0655, 0x01));


                  body.instructions = f0656_parent_instructions;
                  body.emit(f0656);

                  /* END IF */

                  body.emit(assign(r0650, add(r0654, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0668 = lequal(body.constant(int(0)), r0650);
                  ir_if *f0667 = new(mem_ctx) ir_if(operand(r0668).val);
                  exec_list *const f0667_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0667->then_instructions;

                     body.emit(assign(r064F, body.constant(0u), 0x01));

                     ir_variable *const r0669 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0669, lshift(r064E, r0650), 0x01));

                     ir_variable *const r066A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r066C = equal(r0650, body.constant(int(0)));
                     ir_if *f066B = new(mem_ctx) ir_if(operand(r066C).val);
                     exec_list *const f066B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f066B->then_instructions;

                        body.emit(assign(r066A, r064D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f066B->else_instructions;

                        ir_expression *const r066D = lshift(r064D, r0650);
                        ir_expression *const r066E = neg(r0650);
                        ir_expression *const r066F = bit_and(r066E, body.constant(int(31)));
                        ir_expression *const r0670 = rshift(r064E, r066F);
                        body.emit(assign(r066A, bit_or(r066D, r0670), 0x01));


                     body.instructions = f066B_parent_instructions;
                     body.emit(f066B);

                     /* END IF */

                     body.emit(assign(r064D, r066A, 0x01));

                     body.emit(assign(r064E, r0669, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0667->else_instructions;

                     ir_variable *const r0671 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0671, body.constant(0u), 0x01));

                     ir_variable *const r0672 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0672, neg(r0650), 0x01));

                     ir_variable *const r0673 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0673);
                     ir_variable *const r0674 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0674);
                     ir_variable *const r0675 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0675);
                     ir_variable *const r0676 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0677 = neg(r0672);
                     body.emit(assign(r0676, bit_and(r0677, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0679 = equal(r0672, body.constant(int(0)));
                     ir_if *f0678 = new(mem_ctx) ir_if(operand(r0679).val);
                     exec_list *const f0678_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0678->then_instructions;

                        body.emit(assign(r0673, r0671, 0x01));

                        body.emit(assign(r0674, r064E, 0x01));

                        body.emit(assign(r0675, r064D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0678->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r067B = less(r0672, body.constant(int(32)));
                        ir_if *f067A = new(mem_ctx) ir_if(operand(r067B).val);
                        exec_list *const f067A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f067A->then_instructions;

                           body.emit(assign(r0673, lshift(r064E, r0676), 0x01));

                           ir_expression *const r067C = lshift(r064D, r0676);
                           ir_expression *const r067D = rshift(r064E, r0672);
                           body.emit(assign(r0674, bit_or(r067C, r067D), 0x01));

                           body.emit(assign(r0675, rshift(r064D, r0672), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f067A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r067F = equal(r0672, body.constant(int(32)));
                           ir_if *f067E = new(mem_ctx) ir_if(operand(r067F).val);
                           exec_list *const f067E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f067E->then_instructions;

                              body.emit(assign(r0673, r064E, 0x01));

                              body.emit(assign(r0674, r064D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f067E->else_instructions;

                              body.emit(assign(r0671, bit_or(body.constant(0u), r064E), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0681 = less(r0672, body.constant(int(64)));
                              ir_if *f0680 = new(mem_ctx) ir_if(operand(r0681).val);
                              exec_list *const f0680_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0680->then_instructions;

                                 body.emit(assign(r0673, lshift(r064D, r0676), 0x01));

                                 ir_expression *const r0682 = bit_and(r0672, body.constant(int(31)));
                                 body.emit(assign(r0674, rshift(r064D, r0682), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0680->else_instructions;

                                 ir_variable *const r0683 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0685 = equal(r0672, body.constant(int(64)));
                                 ir_if *f0684 = new(mem_ctx) ir_if(operand(r0685).val);
                                 exec_list *const f0684_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0684->then_instructions;

                                    body.emit(assign(r0683, r064D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0684->else_instructions;

                                    ir_expression *const r0686 = nequal(r064D, body.constant(0u));
                                    ir_expression *const r0687 = expr(ir_unop_b2i, r0686);
                                    body.emit(assign(r0683, expr(ir_unop_i2u, r0687), 0x01));


                                 body.instructions = f0684_parent_instructions;
                                 body.emit(f0684);

                                 /* END IF */

                                 body.emit(assign(r0673, r0683, 0x01));

                                 body.emit(assign(r0674, body.constant(0u), 0x01));


                              body.instructions = f0680_parent_instructions;
                              body.emit(f0680);

                              /* END IF */


                           body.instructions = f067E_parent_instructions;
                           body.emit(f067E);

                           /* END IF */

                           body.emit(assign(r0675, body.constant(0u), 0x01));


                        body.instructions = f067A_parent_instructions;
                        body.emit(f067A);

                        /* END IF */

                        ir_expression *const r0688 = nequal(r0671, body.constant(0u));
                        ir_expression *const r0689 = expr(ir_unop_b2i, r0688);
                        ir_expression *const r068A = expr(ir_unop_i2u, r0689);
                        body.emit(assign(r0673, bit_or(r0673, r068A), 0x01));


                     body.instructions = f0678_parent_instructions;
                     body.emit(f0678);

                     /* END IF */

                     body.emit(assign(r064D, r0675, 0x01));

                     body.emit(assign(r064E, r0674, 0x01));

                     body.emit(assign(r064F, r0673, 0x01));


                  body.instructions = f0667_parent_instructions;
                  body.emit(f0667);

                  /* END IF */

                  body.emit(assign(r064C, sub(r064C, r0650), 0x01));

                  ir_variable *const r068B = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r068B, r064C, 0x01));

                  ir_variable *const r068C = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r068C, r064D, 0x01));

                  ir_variable *const r068D = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r068D, r064E, 0x01));

                  ir_variable *const r068E = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r068E, r064F, 0x01));

                  ir_variable *const r068F = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r068F, body.constant(true), 0x01));

                  ir_variable *const r0690 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0691 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0691);
                  ir_expression *const r0692 = expr(ir_unop_u2i, r064F);
                  body.emit(assign(r0691, less(r0692, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0694 = lequal(body.constant(int(2045)), r064C);
                  ir_if *f0693 = new(mem_ctx) ir_if(operand(r0694).val);
                  exec_list *const f0693_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0693->then_instructions;

                     ir_variable *const r0695 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0697 = less(body.constant(int(2045)), r064C);
                     ir_if *f0696 = new(mem_ctx) ir_if(operand(r0697).val);
                     exec_list *const f0696_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0696->then_instructions;

                        body.emit(assign(r0695, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0696->else_instructions;

                        ir_variable *const r0698 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r069A = equal(r064C, body.constant(int(2045)));
                        ir_if *f0699 = new(mem_ctx) ir_if(operand(r069A).val);
                        exec_list *const f0699_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0699->then_instructions;

                           ir_expression *const r069B = equal(body.constant(2097151u), r064D);
                           ir_expression *const r069C = equal(body.constant(4294967295u), r064E);
                           body.emit(assign(r0698, logic_and(r069B, r069C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0699->else_instructions;

                           body.emit(assign(r0698, body.constant(false), 0x01));


                        body.instructions = f0699_parent_instructions;
                        body.emit(f0699);

                        /* END IF */

                        body.emit(assign(r0695, logic_and(r0698, r0691), 0x01));


                     body.instructions = f0696_parent_instructions;
                     body.emit(f0696);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f069D = new(mem_ctx) ir_if(operand(r0695).val);
                     exec_list *const f069D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f069D->then_instructions;

                        ir_variable *const r069E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r069E);
                        ir_expression *const r069F = lshift(r03D3, body.constant(int(31)));
                        body.emit(assign(r069E, add(r069F, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r069E, body.constant(0u), 0x01));

                        body.emit(assign(r0690, r069E, 0x03));

                        body.emit(assign(r068F, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f069D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r06A1 = less(r064C, body.constant(int(0)));
                        ir_if *f06A0 = new(mem_ctx) ir_if(operand(r06A1).val);
                        exec_list *const f06A0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06A0->then_instructions;

                           ir_variable *const r06A2 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r06A2, r064F, 0x01));

                           ir_variable *const r06A3 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r06A3, neg(r064C), 0x01));

                           ir_variable *const r06A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r06A4);
                           ir_variable *const r06A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r06A5);
                           ir_variable *const r06A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r06A6);
                           ir_variable *const r06A7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r06A8 = neg(r06A3);
                           body.emit(assign(r06A7, bit_and(r06A8, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r06AA = equal(r06A3, body.constant(int(0)));
                           ir_if *f06A9 = new(mem_ctx) ir_if(operand(r06AA).val);
                           exec_list *const f06A9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f06A9->then_instructions;

                              body.emit(assign(r06A4, r064F, 0x01));

                              body.emit(assign(r06A5, r064E, 0x01));

                              body.emit(assign(r06A6, r064D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f06A9->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r06AC = less(r06A3, body.constant(int(32)));
                              ir_if *f06AB = new(mem_ctx) ir_if(operand(r06AC).val);
                              exec_list *const f06AB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f06AB->then_instructions;

                                 body.emit(assign(r06A4, lshift(r064E, r06A7), 0x01));

                                 ir_expression *const r06AD = lshift(r064D, r06A7);
                                 ir_expression *const r06AE = rshift(r064E, r06A3);
                                 body.emit(assign(r06A5, bit_or(r06AD, r06AE), 0x01));

                                 body.emit(assign(r06A6, rshift(r064D, r06A3), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f06AB->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r06B0 = equal(r06A3, body.constant(int(32)));
                                 ir_if *f06AF = new(mem_ctx) ir_if(operand(r06B0).val);
                                 exec_list *const f06AF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f06AF->then_instructions;

                                    body.emit(assign(r06A4, r064E, 0x01));

                                    body.emit(assign(r06A5, r064D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f06AF->else_instructions;

                                    body.emit(assign(r06A2, bit_or(r064F, r064E), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r06B2 = less(r06A3, body.constant(int(64)));
                                    ir_if *f06B1 = new(mem_ctx) ir_if(operand(r06B2).val);
                                    exec_list *const f06B1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f06B1->then_instructions;

                                       body.emit(assign(r06A4, lshift(r064D, r06A7), 0x01));

                                       ir_expression *const r06B3 = bit_and(r06A3, body.constant(int(31)));
                                       body.emit(assign(r06A5, rshift(r064D, r06B3), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f06B1->else_instructions;

                                       ir_variable *const r06B4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r06B6 = equal(r06A3, body.constant(int(64)));
                                       ir_if *f06B5 = new(mem_ctx) ir_if(operand(r06B6).val);
                                       exec_list *const f06B5_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f06B5->then_instructions;

                                          body.emit(assign(r06B4, r064D, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f06B5->else_instructions;

                                          ir_expression *const r06B7 = nequal(r064D, body.constant(0u));
                                          ir_expression *const r06B8 = expr(ir_unop_b2i, r06B7);
                                          body.emit(assign(r06B4, expr(ir_unop_i2u, r06B8), 0x01));


                                       body.instructions = f06B5_parent_instructions;
                                       body.emit(f06B5);

                                       /* END IF */

                                       body.emit(assign(r06A4, r06B4, 0x01));

                                       body.emit(assign(r06A5, body.constant(0u), 0x01));


                                    body.instructions = f06B1_parent_instructions;
                                    body.emit(f06B1);

                                    /* END IF */


                                 body.instructions = f06AF_parent_instructions;
                                 body.emit(f06AF);

                                 /* END IF */

                                 body.emit(assign(r06A6, body.constant(0u), 0x01));


                              body.instructions = f06AB_parent_instructions;
                              body.emit(f06AB);

                              /* END IF */

                              ir_expression *const r06B9 = nequal(r06A2, body.constant(0u));
                              ir_expression *const r06BA = expr(ir_unop_b2i, r06B9);
                              ir_expression *const r06BB = expr(ir_unop_i2u, r06BA);
                              body.emit(assign(r06A4, bit_or(r06A4, r06BB), 0x01));


                           body.instructions = f06A9_parent_instructions;
                           body.emit(f06A9);

                           /* END IF */

                           body.emit(assign(r068C, r06A6, 0x01));

                           body.emit(assign(r068D, r06A5, 0x01));

                           body.emit(assign(r068E, r06A4, 0x01));

                           body.emit(assign(r068B, body.constant(int(0)), 0x01));

                           body.emit(assign(r0691, less(r06A4, body.constant(0u)), 0x01));


                        body.instructions = f06A0_parent_instructions;
                        body.emit(f06A0);

                        /* END IF */


                     body.instructions = f069D_parent_instructions;
                     body.emit(f069D);

                     /* END IF */


                  body.instructions = f0693_parent_instructions;
                  body.emit(f0693);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f06BC = new(mem_ctx) ir_if(operand(r068F).val);
                  exec_list *const f06BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06BC->then_instructions;

                     /* IF CONDITION */
                     ir_if *f06BD = new(mem_ctx) ir_if(operand(r0691).val);
                     exec_list *const f06BD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06BD->then_instructions;

                        ir_variable *const r06BE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r06BE, add(r068D, body.constant(1u)), 0x01));

                        ir_expression *const r06BF = less(r06BE, r068D);
                        ir_expression *const r06C0 = expr(ir_unop_b2i, r06BF);
                        ir_expression *const r06C1 = expr(ir_unop_i2u, r06C0);
                        body.emit(assign(r068C, add(r068C, r06C1), 0x01));

                        ir_expression *const r06C2 = equal(r068E, body.constant(0u));
                        ir_expression *const r06C3 = expr(ir_unop_b2i, r06C2);
                        ir_expression *const r06C4 = expr(ir_unop_i2u, r06C3);
                        ir_expression *const r06C5 = add(r068E, r06C4);
                        ir_expression *const r06C6 = bit_and(r06C5, body.constant(1u));
                        ir_expression *const r06C7 = expr(ir_unop_bit_not, r06C6);
                        body.emit(assign(r068D, bit_and(r06BE, r06C7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06BD->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r06C9 = bit_or(r068C, r068D);
                        ir_expression *const r06CA = equal(r06C9, body.constant(0u));
                        ir_if *f06C8 = new(mem_ctx) ir_if(operand(r06CA).val);
                        exec_list *const f06C8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06C8->then_instructions;

                           body.emit(assign(r068B, body.constant(int(0)), 0x01));


                        body.instructions = f06C8_parent_instructions;
                        body.emit(f06C8);

                        /* END IF */


                     body.instructions = f06BD_parent_instructions;
                     body.emit(f06BD);

                     /* END IF */

                     ir_variable *const r06CB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r06CB);
                     ir_expression *const r06CC = lshift(r03D3, body.constant(int(31)));
                     ir_expression *const r06CD = expr(ir_unop_i2u, r068B);
                     ir_expression *const r06CE = lshift(r06CD, body.constant(int(20)));
                     ir_expression *const r06CF = add(r06CC, r06CE);
                     body.emit(assign(r06CB, add(r06CF, r068C), 0x02));

                     body.emit(assign(r06CB, r068D, 0x01));

                     body.emit(assign(r0690, r06CB, 0x03));

                     body.emit(assign(r068F, body.constant(false), 0x01));


                  body.instructions = f06BC_parent_instructions;
                  body.emit(f06BC);

                  /* END IF */

                  body.emit(assign(r03D4, r0690, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0644->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r06D1 = less(r03D9, r03DB);
                  ir_if *f06D0 = new(mem_ctx) ir_if(operand(r06D1).val);
                  exec_list *const f06D0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06D0->then_instructions;

                     ir_variable *const r06D2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r06D3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r06D3, sub(r03DB, r03D9), 0x01));

                     ir_expression *const r06D4 = sub(r03DA, r03D8);
                     ir_expression *const r06D5 = less(r03DB, r03D9);
                     ir_expression *const r06D6 = expr(ir_unop_b2i, r06D5);
                     ir_expression *const r06D7 = expr(ir_unop_i2u, r06D6);
                     body.emit(assign(r06D2, sub(r06D4, r06D7), 0x01));

                     body.emit(assign(r03DC, add(r03D7, body.constant(int(-1))), 0x01));

                     ir_variable *const r06D8 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r06D8, add(r03DC, body.constant(int(-10))), 0x01));

                     ir_variable *const r06D9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r06D9, r06D2, 0x01));

                     ir_variable *const r06DA = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r06DA, r06D3, 0x01));

                     ir_variable *const r06DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r06DB);
                     ir_variable *const r06DC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06DC);
                     /* IF CONDITION */
                     ir_expression *const r06DE = equal(r06D2, body.constant(0u));
                     ir_if *f06DD = new(mem_ctx) ir_if(operand(r06DE).val);
                     exec_list *const f06DD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06DD->then_instructions;

                        body.emit(assign(r06D9, r06D3, 0x01));

                        body.emit(assign(r06DA, body.constant(0u), 0x01));

                        body.emit(assign(r06D8, add(r06D8, body.constant(int(-32))), 0x01));


                     body.instructions = f06DD_parent_instructions;
                     body.emit(f06DD);

                     /* END IF */

                     ir_variable *const r06DF = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r06DF, r06D9, 0x01));

                     ir_variable *const r06E0 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r06E1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06E1);
                     /* IF CONDITION */
                     ir_expression *const r06E3 = equal(r06D9, body.constant(0u));
                     ir_if *f06E2 = new(mem_ctx) ir_if(operand(r06E3).val);
                     exec_list *const f06E2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06E2->then_instructions;

                        body.emit(assign(r06E0, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06E2->else_instructions;

                        body.emit(assign(r06E1, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r06E5 = bit_and(r06D9, body.constant(4294901760u));
                        ir_expression *const r06E6 = equal(r06E5, body.constant(0u));
                        ir_if *f06E4 = new(mem_ctx) ir_if(operand(r06E6).val);
                        exec_list *const f06E4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E4->then_instructions;

                           body.emit(assign(r06E1, body.constant(int(16)), 0x01));

                           body.emit(assign(r06DF, lshift(r06D9, body.constant(int(16))), 0x01));


                        body.instructions = f06E4_parent_instructions;
                        body.emit(f06E4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06E8 = bit_and(r06DF, body.constant(4278190080u));
                        ir_expression *const r06E9 = equal(r06E8, body.constant(0u));
                        ir_if *f06E7 = new(mem_ctx) ir_if(operand(r06E9).val);
                        exec_list *const f06E7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E7->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(8))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(8))), 0x01));


                        body.instructions = f06E7_parent_instructions;
                        body.emit(f06E7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06EB = bit_and(r06DF, body.constant(4026531840u));
                        ir_expression *const r06EC = equal(r06EB, body.constant(0u));
                        ir_if *f06EA = new(mem_ctx) ir_if(operand(r06EC).val);
                        exec_list *const f06EA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06EA->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(4))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(4))), 0x01));


                        body.instructions = f06EA_parent_instructions;
                        body.emit(f06EA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06EE = bit_and(r06DF, body.constant(3221225472u));
                        ir_expression *const r06EF = equal(r06EE, body.constant(0u));
                        ir_if *f06ED = new(mem_ctx) ir_if(operand(r06EF).val);
                        exec_list *const f06ED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06ED->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(2))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(2))), 0x01));


                        body.instructions = f06ED_parent_instructions;
                        body.emit(f06ED);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06F1 = bit_and(r06DF, body.constant(2147483648u));
                        ir_expression *const r06F2 = equal(r06F1, body.constant(0u));
                        ir_if *f06F0 = new(mem_ctx) ir_if(operand(r06F2).val);
                        exec_list *const f06F0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06F0->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(1))), 0x01));


                        body.instructions = f06F0_parent_instructions;
                        body.emit(f06F0);

                        /* END IF */

                        body.emit(assign(r06E0, r06E1, 0x01));


                     body.instructions = f06E2_parent_instructions;
                     body.emit(f06E2);

                     /* END IF */

                     body.emit(assign(r06DC, add(r06E0, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r06F4 = lequal(body.constant(int(0)), r06DC);
                     ir_if *f06F3 = new(mem_ctx) ir_if(operand(r06F4).val);
                     exec_list *const f06F3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06F3->then_instructions;

                        body.emit(assign(r06DB, body.constant(0u), 0x01));

                        ir_variable *const r06F5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r06F5, lshift(r06DA, r06DC), 0x01));

                        ir_variable *const r06F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r06F8 = equal(r06DC, body.constant(int(0)));
                        ir_if *f06F7 = new(mem_ctx) ir_if(operand(r06F8).val);
                        exec_list *const f06F7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06F7->then_instructions;

                           body.emit(assign(r06F6, r06D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f06F7->else_instructions;

                           ir_expression *const r06F9 = lshift(r06D9, r06DC);
                           ir_expression *const r06FA = neg(r06DC);
                           ir_expression *const r06FB = bit_and(r06FA, body.constant(int(31)));
                           ir_expression *const r06FC = rshift(r06DA, r06FB);
                           body.emit(assign(r06F6, bit_or(r06F9, r06FC), 0x01));


                        body.instructions = f06F7_parent_instructions;
                        body.emit(f06F7);

                        /* END IF */

                        body.emit(assign(r06D9, r06F6, 0x01));

                        body.emit(assign(r06DA, r06F5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06F3->else_instructions;

                        ir_variable *const r06FD = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r06FD, body.constant(0u), 0x01));

                        ir_variable *const r06FE = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r06FE, neg(r06DC), 0x01));

                        ir_variable *const r06FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r06FF);
                        ir_variable *const r0700 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0700);
                        ir_variable *const r0701 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0701);
                        ir_variable *const r0702 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0703 = neg(r06FE);
                        body.emit(assign(r0702, bit_and(r0703, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0705 = equal(r06FE, body.constant(int(0)));
                        ir_if *f0704 = new(mem_ctx) ir_if(operand(r0705).val);
                        exec_list *const f0704_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0704->then_instructions;

                           body.emit(assign(r06FF, r06FD, 0x01));

                           body.emit(assign(r0700, r06DA, 0x01));

                           body.emit(assign(r0701, r06D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0704->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0707 = less(r06FE, body.constant(int(32)));
                           ir_if *f0706 = new(mem_ctx) ir_if(operand(r0707).val);
                           exec_list *const f0706_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0706->then_instructions;

                              body.emit(assign(r06FF, lshift(r06DA, r0702), 0x01));

                              ir_expression *const r0708 = lshift(r06D9, r0702);
                              ir_expression *const r0709 = rshift(r06DA, r06FE);
                              body.emit(assign(r0700, bit_or(r0708, r0709), 0x01));

                              body.emit(assign(r0701, rshift(r06D9, r06FE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0706->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r070B = equal(r06FE, body.constant(int(32)));
                              ir_if *f070A = new(mem_ctx) ir_if(operand(r070B).val);
                              exec_list *const f070A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f070A->then_instructions;

                                 body.emit(assign(r06FF, r06DA, 0x01));

                                 body.emit(assign(r0700, r06D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f070A->else_instructions;

                                 body.emit(assign(r06FD, bit_or(body.constant(0u), r06DA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r070D = less(r06FE, body.constant(int(64)));
                                 ir_if *f070C = new(mem_ctx) ir_if(operand(r070D).val);
                                 exec_list *const f070C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f070C->then_instructions;

                                    body.emit(assign(r06FF, lshift(r06D9, r0702), 0x01));

                                    ir_expression *const r070E = bit_and(r06FE, body.constant(int(31)));
                                    body.emit(assign(r0700, rshift(r06D9, r070E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f070C->else_instructions;

                                    ir_variable *const r070F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0711 = equal(r06FE, body.constant(int(64)));
                                    ir_if *f0710 = new(mem_ctx) ir_if(operand(r0711).val);
                                    exec_list *const f0710_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0710->then_instructions;

                                       body.emit(assign(r070F, r06D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0710->else_instructions;

                                       ir_expression *const r0712 = nequal(r06D9, body.constant(0u));
                                       ir_expression *const r0713 = expr(ir_unop_b2i, r0712);
                                       body.emit(assign(r070F, expr(ir_unop_i2u, r0713), 0x01));


                                    body.instructions = f0710_parent_instructions;
                                    body.emit(f0710);

                                    /* END IF */

                                    body.emit(assign(r06FF, r070F, 0x01));

                                    body.emit(assign(r0700, body.constant(0u), 0x01));


                                 body.instructions = f070C_parent_instructions;
                                 body.emit(f070C);

                                 /* END IF */


                              body.instructions = f070A_parent_instructions;
                              body.emit(f070A);

                              /* END IF */

                              body.emit(assign(r0701, body.constant(0u), 0x01));


                           body.instructions = f0706_parent_instructions;
                           body.emit(f0706);

                           /* END IF */

                           ir_expression *const r0714 = nequal(r06FD, body.constant(0u));
                           ir_expression *const r0715 = expr(ir_unop_b2i, r0714);
                           ir_expression *const r0716 = expr(ir_unop_i2u, r0715);
                           body.emit(assign(r06FF, bit_or(r06FF, r0716), 0x01));


                        body.instructions = f0704_parent_instructions;
                        body.emit(f0704);

                        /* END IF */

                        body.emit(assign(r06D9, r0701, 0x01));

                        body.emit(assign(r06DA, r0700, 0x01));

                        body.emit(assign(r06DB, r06FF, 0x01));


                     body.instructions = f06F3_parent_instructions;
                     body.emit(f06F3);

                     /* END IF */

                     body.emit(assign(r06D8, sub(r06D8, r06DC), 0x01));

                     ir_variable *const r0717 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0717, r06D8, 0x01));

                     ir_variable *const r0718 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0718, r06D9, 0x01));

                     ir_variable *const r0719 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0719, r06DA, 0x01));

                     ir_variable *const r071A = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r071A, r06DB, 0x01));

                     ir_variable *const r071B = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r071B, body.constant(true), 0x01));

                     ir_variable *const r071C = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r071D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r071D);
                     ir_expression *const r071E = expr(ir_unop_u2i, r06DB);
                     body.emit(assign(r071D, less(r071E, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0720 = lequal(body.constant(int(2045)), r06D8);
                     ir_if *f071F = new(mem_ctx) ir_if(operand(r0720).val);
                     exec_list *const f071F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f071F->then_instructions;

                        ir_variable *const r0721 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0723 = less(body.constant(int(2045)), r06D8);
                        ir_if *f0722 = new(mem_ctx) ir_if(operand(r0723).val);
                        exec_list *const f0722_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0722->then_instructions;

                           body.emit(assign(r0721, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0722->else_instructions;

                           ir_variable *const r0724 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0726 = equal(r06D8, body.constant(int(2045)));
                           ir_if *f0725 = new(mem_ctx) ir_if(operand(r0726).val);
                           exec_list *const f0725_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0725->then_instructions;

                              ir_expression *const r0727 = equal(body.constant(2097151u), r06D9);
                              ir_expression *const r0728 = equal(body.constant(4294967295u), r06DA);
                              body.emit(assign(r0724, logic_and(r0727, r0728), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0725->else_instructions;

                              body.emit(assign(r0724, body.constant(false), 0x01));


                           body.instructions = f0725_parent_instructions;
                           body.emit(f0725);

                           /* END IF */

                           body.emit(assign(r0721, logic_and(r0724, r071D), 0x01));


                        body.instructions = f0722_parent_instructions;
                        body.emit(f0722);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0729 = new(mem_ctx) ir_if(operand(r0721).val);
                        exec_list *const f0729_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0729->then_instructions;

                           ir_variable *const r072A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r072A);
                           ir_expression *const r072B = lshift(r03D3, body.constant(int(31)));
                           body.emit(assign(r072A, add(r072B, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r072A, body.constant(0u), 0x01));

                           body.emit(assign(r071C, r072A, 0x03));

                           body.emit(assign(r071B, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0729->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r072D = less(r06D8, body.constant(int(0)));
                           ir_if *f072C = new(mem_ctx) ir_if(operand(r072D).val);
                           exec_list *const f072C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f072C->then_instructions;

                              ir_variable *const r072E = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r072E, r06DB, 0x01));

                              ir_variable *const r072F = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r072F, neg(r06D8), 0x01));

                              ir_variable *const r0730 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0730);
                              ir_variable *const r0731 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0731);
                              ir_variable *const r0732 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0732);
                              ir_variable *const r0733 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0734 = neg(r072F);
                              body.emit(assign(r0733, bit_and(r0734, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0736 = equal(r072F, body.constant(int(0)));
                              ir_if *f0735 = new(mem_ctx) ir_if(operand(r0736).val);
                              exec_list *const f0735_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0735->then_instructions;

                                 body.emit(assign(r0730, r06DB, 0x01));

                                 body.emit(assign(r0731, r06DA, 0x01));

                                 body.emit(assign(r0732, r06D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0735->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0738 = less(r072F, body.constant(int(32)));
                                 ir_if *f0737 = new(mem_ctx) ir_if(operand(r0738).val);
                                 exec_list *const f0737_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0737->then_instructions;

                                    body.emit(assign(r0730, lshift(r06DA, r0733), 0x01));

                                    ir_expression *const r0739 = lshift(r06D9, r0733);
                                    ir_expression *const r073A = rshift(r06DA, r072F);
                                    body.emit(assign(r0731, bit_or(r0739, r073A), 0x01));

                                    body.emit(assign(r0732, rshift(r06D9, r072F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0737->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r073C = equal(r072F, body.constant(int(32)));
                                    ir_if *f073B = new(mem_ctx) ir_if(operand(r073C).val);
                                    exec_list *const f073B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f073B->then_instructions;

                                       body.emit(assign(r0730, r06DA, 0x01));

                                       body.emit(assign(r0731, r06D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f073B->else_instructions;

                                       body.emit(assign(r072E, bit_or(r06DB, r06DA), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r073E = less(r072F, body.constant(int(64)));
                                       ir_if *f073D = new(mem_ctx) ir_if(operand(r073E).val);
                                       exec_list *const f073D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f073D->then_instructions;

                                          body.emit(assign(r0730, lshift(r06D9, r0733), 0x01));

                                          ir_expression *const r073F = bit_and(r072F, body.constant(int(31)));
                                          body.emit(assign(r0731, rshift(r06D9, r073F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f073D->else_instructions;

                                          ir_variable *const r0740 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0742 = equal(r072F, body.constant(int(64)));
                                          ir_if *f0741 = new(mem_ctx) ir_if(operand(r0742).val);
                                          exec_list *const f0741_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0741->then_instructions;

                                             body.emit(assign(r0740, r06D9, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0741->else_instructions;

                                             ir_expression *const r0743 = nequal(r06D9, body.constant(0u));
                                             ir_expression *const r0744 = expr(ir_unop_b2i, r0743);
                                             body.emit(assign(r0740, expr(ir_unop_i2u, r0744), 0x01));


                                          body.instructions = f0741_parent_instructions;
                                          body.emit(f0741);

                                          /* END IF */

                                          body.emit(assign(r0730, r0740, 0x01));

                                          body.emit(assign(r0731, body.constant(0u), 0x01));


                                       body.instructions = f073D_parent_instructions;
                                       body.emit(f073D);

                                       /* END IF */


                                    body.instructions = f073B_parent_instructions;
                                    body.emit(f073B);

                                    /* END IF */

                                    body.emit(assign(r0732, body.constant(0u), 0x01));


                                 body.instructions = f0737_parent_instructions;
                                 body.emit(f0737);

                                 /* END IF */

                                 ir_expression *const r0745 = nequal(r072E, body.constant(0u));
                                 ir_expression *const r0746 = expr(ir_unop_b2i, r0745);
                                 ir_expression *const r0747 = expr(ir_unop_i2u, r0746);
                                 body.emit(assign(r0730, bit_or(r0730, r0747), 0x01));


                              body.instructions = f0735_parent_instructions;
                              body.emit(f0735);

                              /* END IF */

                              body.emit(assign(r0718, r0732, 0x01));

                              body.emit(assign(r0719, r0731, 0x01));

                              body.emit(assign(r071A, r0730, 0x01));

                              body.emit(assign(r0717, body.constant(int(0)), 0x01));

                              body.emit(assign(r071D, less(r0730, body.constant(0u)), 0x01));


                           body.instructions = f072C_parent_instructions;
                           body.emit(f072C);

                           /* END IF */


                        body.instructions = f0729_parent_instructions;
                        body.emit(f0729);

                        /* END IF */


                     body.instructions = f071F_parent_instructions;
                     body.emit(f071F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0748 = new(mem_ctx) ir_if(operand(r071B).val);
                     exec_list *const f0748_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0748->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0749 = new(mem_ctx) ir_if(operand(r071D).val);
                        exec_list *const f0749_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0749->then_instructions;

                           ir_variable *const r074A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r074A, add(r0719, body.constant(1u)), 0x01));

                           ir_expression *const r074B = less(r074A, r0719);
                           ir_expression *const r074C = expr(ir_unop_b2i, r074B);
                           ir_expression *const r074D = expr(ir_unop_i2u, r074C);
                           body.emit(assign(r0718, add(r0718, r074D), 0x01));

                           ir_expression *const r074E = equal(r071A, body.constant(0u));
                           ir_expression *const r074F = expr(ir_unop_b2i, r074E);
                           ir_expression *const r0750 = expr(ir_unop_i2u, r074F);
                           ir_expression *const r0751 = add(r071A, r0750);
                           ir_expression *const r0752 = bit_and(r0751, body.constant(1u));
                           ir_expression *const r0753 = expr(ir_unop_bit_not, r0752);
                           body.emit(assign(r0719, bit_and(r074A, r0753), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0749->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0755 = bit_or(r0718, r0719);
                           ir_expression *const r0756 = equal(r0755, body.constant(0u));
                           ir_if *f0754 = new(mem_ctx) ir_if(operand(r0756).val);
                           exec_list *const f0754_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0754->then_instructions;

                              body.emit(assign(r0717, body.constant(int(0)), 0x01));


                           body.instructions = f0754_parent_instructions;
                           body.emit(f0754);

                           /* END IF */


                        body.instructions = f0749_parent_instructions;
                        body.emit(f0749);

                        /* END IF */

                        ir_variable *const r0757 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0757);
                        ir_expression *const r0758 = lshift(r03D3, body.constant(int(31)));
                        ir_expression *const r0759 = expr(ir_unop_i2u, r0717);
                        ir_expression *const r075A = lshift(r0759, body.constant(int(20)));
                        ir_expression *const r075B = add(r0758, r075A);
                        body.emit(assign(r0757, add(r075B, r0718), 0x02));

                        body.emit(assign(r0757, r0719, 0x01));

                        body.emit(assign(r071C, r0757, 0x03));

                        body.emit(assign(r071B, body.constant(false), 0x01));


                     body.instructions = f0748_parent_instructions;
                     body.emit(f0748);

                     /* END IF */

                     body.emit(assign(r03D4, r071C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f06D0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r075D = less(r03DB, r03D9);
                     ir_if *f075C = new(mem_ctx) ir_if(operand(r075D).val);
                     exec_list *const f075C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f075C->then_instructions;

                        ir_variable *const r075E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r075F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r075F, sub(r03D9, r03DB), 0x01));

                        ir_expression *const r0760 = sub(r03D8, r03DA);
                        ir_expression *const r0761 = less(r03D9, r03DB);
                        ir_expression *const r0762 = expr(ir_unop_b2i, r0761);
                        ir_expression *const r0763 = expr(ir_unop_i2u, r0762);
                        body.emit(assign(r075E, sub(r0760, r0763), 0x01));

                        body.emit(assign(r03D3, bit_xor(r03D3, body.constant(1u)), 0x01));

                        body.emit(assign(r03DC, add(r03D6, body.constant(int(-1))), 0x01));

                        ir_variable *const r0764 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0764, add(r03DC, body.constant(int(-10))), 0x01));

                        ir_variable *const r0765 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0765, r075E, 0x01));

                        ir_variable *const r0766 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0766, r075F, 0x01));

                        ir_variable *const r0767 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0767);
                        ir_variable *const r0768 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0768);
                        /* IF CONDITION */
                        ir_expression *const r076A = equal(r075E, body.constant(0u));
                        ir_if *f0769 = new(mem_ctx) ir_if(operand(r076A).val);
                        exec_list *const f0769_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0769->then_instructions;

                           body.emit(assign(r0765, r075F, 0x01));

                           body.emit(assign(r0766, body.constant(0u), 0x01));

                           body.emit(assign(r0764, add(r0764, body.constant(int(-32))), 0x01));


                        body.instructions = f0769_parent_instructions;
                        body.emit(f0769);

                        /* END IF */

                        ir_variable *const r076B = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r076B, r0765, 0x01));

                        ir_variable *const r076C = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r076D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r076D);
                        /* IF CONDITION */
                        ir_expression *const r076F = equal(r0765, body.constant(0u));
                        ir_if *f076E = new(mem_ctx) ir_if(operand(r076F).val);
                        exec_list *const f076E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f076E->then_instructions;

                           body.emit(assign(r076C, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f076E->else_instructions;

                           body.emit(assign(r076D, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0771 = bit_and(r0765, body.constant(4294901760u));
                           ir_expression *const r0772 = equal(r0771, body.constant(0u));
                           ir_if *f0770 = new(mem_ctx) ir_if(operand(r0772).val);
                           exec_list *const f0770_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0770->then_instructions;

                              body.emit(assign(r076D, body.constant(int(16)), 0x01));

                              body.emit(assign(r076B, lshift(r0765, body.constant(int(16))), 0x01));


                           body.instructions = f0770_parent_instructions;
                           body.emit(f0770);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0774 = bit_and(r076B, body.constant(4278190080u));
                           ir_expression *const r0775 = equal(r0774, body.constant(0u));
                           ir_if *f0773 = new(mem_ctx) ir_if(operand(r0775).val);
                           exec_list *const f0773_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0773->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(8))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(8))), 0x01));


                           body.instructions = f0773_parent_instructions;
                           body.emit(f0773);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0777 = bit_and(r076B, body.constant(4026531840u));
                           ir_expression *const r0778 = equal(r0777, body.constant(0u));
                           ir_if *f0776 = new(mem_ctx) ir_if(operand(r0778).val);
                           exec_list *const f0776_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0776->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(4))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(4))), 0x01));


                           body.instructions = f0776_parent_instructions;
                           body.emit(f0776);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r077A = bit_and(r076B, body.constant(3221225472u));
                           ir_expression *const r077B = equal(r077A, body.constant(0u));
                           ir_if *f0779 = new(mem_ctx) ir_if(operand(r077B).val);
                           exec_list *const f0779_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0779->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(2))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(2))), 0x01));


                           body.instructions = f0779_parent_instructions;
                           body.emit(f0779);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r077D = bit_and(r076B, body.constant(2147483648u));
                           ir_expression *const r077E = equal(r077D, body.constant(0u));
                           ir_if *f077C = new(mem_ctx) ir_if(operand(r077E).val);
                           exec_list *const f077C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f077C->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(1))), 0x01));


                           body.instructions = f077C_parent_instructions;
                           body.emit(f077C);

                           /* END IF */

                           body.emit(assign(r076C, r076D, 0x01));


                        body.instructions = f076E_parent_instructions;
                        body.emit(f076E);

                        /* END IF */

                        body.emit(assign(r0768, add(r076C, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0780 = lequal(body.constant(int(0)), r0768);
                        ir_if *f077F = new(mem_ctx) ir_if(operand(r0780).val);
                        exec_list *const f077F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f077F->then_instructions;

                           body.emit(assign(r0767, body.constant(0u), 0x01));

                           ir_variable *const r0781 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0781, lshift(r0766, r0768), 0x01));

                           ir_variable *const r0782 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0784 = equal(r0768, body.constant(int(0)));
                           ir_if *f0783 = new(mem_ctx) ir_if(operand(r0784).val);
                           exec_list *const f0783_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0783->then_instructions;

                              body.emit(assign(r0782, r0765, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0783->else_instructions;

                              ir_expression *const r0785 = lshift(r0765, r0768);
                              ir_expression *const r0786 = neg(r0768);
                              ir_expression *const r0787 = bit_and(r0786, body.constant(int(31)));
                              ir_expression *const r0788 = rshift(r0766, r0787);
                              body.emit(assign(r0782, bit_or(r0785, r0788), 0x01));


                           body.instructions = f0783_parent_instructions;
                           body.emit(f0783);

                           /* END IF */

                           body.emit(assign(r0765, r0782, 0x01));

                           body.emit(assign(r0766, r0781, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f077F->else_instructions;

                           ir_variable *const r0789 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0789, body.constant(0u), 0x01));

                           ir_variable *const r078A = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r078A, neg(r0768), 0x01));

                           ir_variable *const r078B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r078B);
                           ir_variable *const r078C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r078C);
                           ir_variable *const r078D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r078D);
                           ir_variable *const r078E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r078F = neg(r078A);
                           body.emit(assign(r078E, bit_and(r078F, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0791 = equal(r078A, body.constant(int(0)));
                           ir_if *f0790 = new(mem_ctx) ir_if(operand(r0791).val);
                           exec_list *const f0790_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0790->then_instructions;

                              body.emit(assign(r078B, r0789, 0x01));

                              body.emit(assign(r078C, r0766, 0x01));

                              body.emit(assign(r078D, r0765, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0790->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0793 = less(r078A, body.constant(int(32)));
                              ir_if *f0792 = new(mem_ctx) ir_if(operand(r0793).val);
                              exec_list *const f0792_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0792->then_instructions;

                                 body.emit(assign(r078B, lshift(r0766, r078E), 0x01));

                                 ir_expression *const r0794 = lshift(r0765, r078E);
                                 ir_expression *const r0795 = rshift(r0766, r078A);
                                 body.emit(assign(r078C, bit_or(r0794, r0795), 0x01));

                                 body.emit(assign(r078D, rshift(r0765, r078A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0792->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0797 = equal(r078A, body.constant(int(32)));
                                 ir_if *f0796 = new(mem_ctx) ir_if(operand(r0797).val);
                                 exec_list *const f0796_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0796->then_instructions;

                                    body.emit(assign(r078B, r0766, 0x01));

                                    body.emit(assign(r078C, r0765, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0796->else_instructions;

                                    body.emit(assign(r0789, bit_or(body.constant(0u), r0766), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0799 = less(r078A, body.constant(int(64)));
                                    ir_if *f0798 = new(mem_ctx) ir_if(operand(r0799).val);
                                    exec_list *const f0798_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0798->then_instructions;

                                       body.emit(assign(r078B, lshift(r0765, r078E), 0x01));

                                       ir_expression *const r079A = bit_and(r078A, body.constant(int(31)));
                                       body.emit(assign(r078C, rshift(r0765, r079A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0798->else_instructions;

                                       ir_variable *const r079B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r079D = equal(r078A, body.constant(int(64)));
                                       ir_if *f079C = new(mem_ctx) ir_if(operand(r079D).val);
                                       exec_list *const f079C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f079C->then_instructions;

                                          body.emit(assign(r079B, r0765, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f079C->else_instructions;

                                          ir_expression *const r079E = nequal(r0765, body.constant(0u));
                                          ir_expression *const r079F = expr(ir_unop_b2i, r079E);
                                          body.emit(assign(r079B, expr(ir_unop_i2u, r079F), 0x01));


                                       body.instructions = f079C_parent_instructions;
                                       body.emit(f079C);

                                       /* END IF */

                                       body.emit(assign(r078B, r079B, 0x01));

                                       body.emit(assign(r078C, body.constant(0u), 0x01));


                                    body.instructions = f0798_parent_instructions;
                                    body.emit(f0798);

                                    /* END IF */


                                 body.instructions = f0796_parent_instructions;
                                 body.emit(f0796);

                                 /* END IF */

                                 body.emit(assign(r078D, body.constant(0u), 0x01));


                              body.instructions = f0792_parent_instructions;
                              body.emit(f0792);

                              /* END IF */

                              ir_expression *const r07A0 = nequal(r0789, body.constant(0u));
                              ir_expression *const r07A1 = expr(ir_unop_b2i, r07A0);
                              ir_expression *const r07A2 = expr(ir_unop_i2u, r07A1);
                              body.emit(assign(r078B, bit_or(r078B, r07A2), 0x01));


                           body.instructions = f0790_parent_instructions;
                           body.emit(f0790);

                           /* END IF */

                           body.emit(assign(r0765, r078D, 0x01));

                           body.emit(assign(r0766, r078C, 0x01));

                           body.emit(assign(r0767, r078B, 0x01));


                        body.instructions = f077F_parent_instructions;
                        body.emit(f077F);

                        /* END IF */

                        body.emit(assign(r0764, sub(r0764, r0768), 0x01));

                        ir_variable *const r07A3 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r07A3, r0764, 0x01));

                        ir_variable *const r07A4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r07A4, r0765, 0x01));

                        ir_variable *const r07A5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r07A5, r0766, 0x01));

                        ir_variable *const r07A6 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r07A6, r0767, 0x01));

                        ir_variable *const r07A7 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r07A7, body.constant(true), 0x01));

                        ir_variable *const r07A8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r07A9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r07A9);
                        ir_expression *const r07AA = expr(ir_unop_u2i, r0767);
                        body.emit(assign(r07A9, less(r07AA, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r07AC = lequal(body.constant(int(2045)), r0764);
                        ir_if *f07AB = new(mem_ctx) ir_if(operand(r07AC).val);
                        exec_list *const f07AB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07AB->then_instructions;

                           ir_variable *const r07AD = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r07AF = less(body.constant(int(2045)), r0764);
                           ir_if *f07AE = new(mem_ctx) ir_if(operand(r07AF).val);
                           exec_list *const f07AE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07AE->then_instructions;

                              body.emit(assign(r07AD, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07AE->else_instructions;

                              ir_variable *const r07B0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r07B2 = equal(r0764, body.constant(int(2045)));
                              ir_if *f07B1 = new(mem_ctx) ir_if(operand(r07B2).val);
                              exec_list *const f07B1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07B1->then_instructions;

                                 ir_expression *const r07B3 = equal(body.constant(2097151u), r0765);
                                 ir_expression *const r07B4 = equal(body.constant(4294967295u), r0766);
                                 body.emit(assign(r07B0, logic_and(r07B3, r07B4), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f07B1->else_instructions;

                                 body.emit(assign(r07B0, body.constant(false), 0x01));


                              body.instructions = f07B1_parent_instructions;
                              body.emit(f07B1);

                              /* END IF */

                              body.emit(assign(r07AD, logic_and(r07B0, r07A9), 0x01));


                           body.instructions = f07AE_parent_instructions;
                           body.emit(f07AE);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f07B5 = new(mem_ctx) ir_if(operand(r07AD).val);
                           exec_list *const f07B5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07B5->then_instructions;

                              ir_variable *const r07B6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r07B6);
                              ir_expression *const r07B7 = lshift(r03D3, body.constant(int(31)));
                              body.emit(assign(r07B6, add(r07B7, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r07B6, body.constant(0u), 0x01));

                              body.emit(assign(r07A8, r07B6, 0x03));

                              body.emit(assign(r07A7, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07B5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07B9 = less(r0764, body.constant(int(0)));
                              ir_if *f07B8 = new(mem_ctx) ir_if(operand(r07B9).val);
                              exec_list *const f07B8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07B8->then_instructions;

                                 ir_variable *const r07BA = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r07BA, r0767, 0x01));

                                 ir_variable *const r07BB = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r07BB, neg(r0764), 0x01));

                                 ir_variable *const r07BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r07BC);
                                 ir_variable *const r07BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r07BD);
                                 ir_variable *const r07BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r07BE);
                                 ir_variable *const r07BF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r07C0 = neg(r07BB);
                                 body.emit(assign(r07BF, bit_and(r07C0, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r07C2 = equal(r07BB, body.constant(int(0)));
                                 ir_if *f07C1 = new(mem_ctx) ir_if(operand(r07C2).val);
                                 exec_list *const f07C1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f07C1->then_instructions;

                                    body.emit(assign(r07BC, r0767, 0x01));

                                    body.emit(assign(r07BD, r0766, 0x01));

                                    body.emit(assign(r07BE, r0765, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f07C1->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r07C4 = less(r07BB, body.constant(int(32)));
                                    ir_if *f07C3 = new(mem_ctx) ir_if(operand(r07C4).val);
                                    exec_list *const f07C3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f07C3->then_instructions;

                                       body.emit(assign(r07BC, lshift(r0766, r07BF), 0x01));

                                       ir_expression *const r07C5 = lshift(r0765, r07BF);
                                       ir_expression *const r07C6 = rshift(r0766, r07BB);
                                       body.emit(assign(r07BD, bit_or(r07C5, r07C6), 0x01));

                                       body.emit(assign(r07BE, rshift(r0765, r07BB), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f07C3->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r07C8 = equal(r07BB, body.constant(int(32)));
                                       ir_if *f07C7 = new(mem_ctx) ir_if(operand(r07C8).val);
                                       exec_list *const f07C7_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f07C7->then_instructions;

                                          body.emit(assign(r07BC, r0766, 0x01));

                                          body.emit(assign(r07BD, r0765, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f07C7->else_instructions;

                                          body.emit(assign(r07BA, bit_or(r0767, r0766), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r07CA = less(r07BB, body.constant(int(64)));
                                          ir_if *f07C9 = new(mem_ctx) ir_if(operand(r07CA).val);
                                          exec_list *const f07C9_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f07C9->then_instructions;

                                             body.emit(assign(r07BC, lshift(r0765, r07BF), 0x01));

                                             ir_expression *const r07CB = bit_and(r07BB, body.constant(int(31)));
                                             body.emit(assign(r07BD, rshift(r0765, r07CB), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f07C9->else_instructions;

                                             ir_variable *const r07CC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r07CE = equal(r07BB, body.constant(int(64)));
                                             ir_if *f07CD = new(mem_ctx) ir_if(operand(r07CE).val);
                                             exec_list *const f07CD_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f07CD->then_instructions;

                                                body.emit(assign(r07CC, r0765, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f07CD->else_instructions;

                                                ir_expression *const r07CF = nequal(r0765, body.constant(0u));
                                                ir_expression *const r07D0 = expr(ir_unop_b2i, r07CF);
                                                body.emit(assign(r07CC, expr(ir_unop_i2u, r07D0), 0x01));


                                             body.instructions = f07CD_parent_instructions;
                                             body.emit(f07CD);

                                             /* END IF */

                                             body.emit(assign(r07BC, r07CC, 0x01));

                                             body.emit(assign(r07BD, body.constant(0u), 0x01));


                                          body.instructions = f07C9_parent_instructions;
                                          body.emit(f07C9);

                                          /* END IF */


                                       body.instructions = f07C7_parent_instructions;
                                       body.emit(f07C7);

                                       /* END IF */

                                       body.emit(assign(r07BE, body.constant(0u), 0x01));


                                    body.instructions = f07C3_parent_instructions;
                                    body.emit(f07C3);

                                    /* END IF */

                                    ir_expression *const r07D1 = nequal(r07BA, body.constant(0u));
                                    ir_expression *const r07D2 = expr(ir_unop_b2i, r07D1);
                                    ir_expression *const r07D3 = expr(ir_unop_i2u, r07D2);
                                    body.emit(assign(r07BC, bit_or(r07BC, r07D3), 0x01));


                                 body.instructions = f07C1_parent_instructions;
                                 body.emit(f07C1);

                                 /* END IF */

                                 body.emit(assign(r07A4, r07BE, 0x01));

                                 body.emit(assign(r07A5, r07BD, 0x01));

                                 body.emit(assign(r07A6, r07BC, 0x01));

                                 body.emit(assign(r07A3, body.constant(int(0)), 0x01));

                                 body.emit(assign(r07A9, less(r07BC, body.constant(0u)), 0x01));


                              body.instructions = f07B8_parent_instructions;
                              body.emit(f07B8);

                              /* END IF */


                           body.instructions = f07B5_parent_instructions;
                           body.emit(f07B5);

                           /* END IF */


                        body.instructions = f07AB_parent_instructions;
                        body.emit(f07AB);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f07D4 = new(mem_ctx) ir_if(operand(r07A7).val);
                        exec_list *const f07D4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07D4->then_instructions;

                           /* IF CONDITION */
                           ir_if *f07D5 = new(mem_ctx) ir_if(operand(r07A9).val);
                           exec_list *const f07D5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07D5->then_instructions;

                              ir_variable *const r07D6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r07D6, add(r07A5, body.constant(1u)), 0x01));

                              ir_expression *const r07D7 = less(r07D6, r07A5);
                              ir_expression *const r07D8 = expr(ir_unop_b2i, r07D7);
                              ir_expression *const r07D9 = expr(ir_unop_i2u, r07D8);
                              body.emit(assign(r07A4, add(r07A4, r07D9), 0x01));

                              ir_expression *const r07DA = equal(r07A6, body.constant(0u));
                              ir_expression *const r07DB = expr(ir_unop_b2i, r07DA);
                              ir_expression *const r07DC = expr(ir_unop_i2u, r07DB);
                              ir_expression *const r07DD = add(r07A6, r07DC);
                              ir_expression *const r07DE = bit_and(r07DD, body.constant(1u));
                              ir_expression *const r07DF = expr(ir_unop_bit_not, r07DE);
                              body.emit(assign(r07A5, bit_and(r07D6, r07DF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07D5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07E1 = bit_or(r07A4, r07A5);
                              ir_expression *const r07E2 = equal(r07E1, body.constant(0u));
                              ir_if *f07E0 = new(mem_ctx) ir_if(operand(r07E2).val);
                              exec_list *const f07E0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07E0->then_instructions;

                                 body.emit(assign(r07A3, body.constant(int(0)), 0x01));


                              body.instructions = f07E0_parent_instructions;
                              body.emit(f07E0);

                              /* END IF */


                           body.instructions = f07D5_parent_instructions;
                           body.emit(f07D5);

                           /* END IF */

                           ir_variable *const r07E3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r07E3);
                           ir_expression *const r07E4 = lshift(r03D3, body.constant(int(31)));
                           ir_expression *const r07E5 = expr(ir_unop_i2u, r07A3);
                           ir_expression *const r07E6 = lshift(r07E5, body.constant(int(20)));
                           ir_expression *const r07E7 = add(r07E4, r07E6);
                           body.emit(assign(r07E3, add(r07E7, r07A4), 0x02));

                           body.emit(assign(r07E3, r07A5, 0x01));

                           body.emit(assign(r07A8, r07E3, 0x03));

                           body.emit(assign(r07A7, body.constant(false), 0x01));


                        body.instructions = f07D4_parent_instructions;
                        body.emit(f07D4);

                        /* END IF */

                        body.emit(assign(r03D4, r07A8, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f075C->else_instructions;

                        ir_variable *const r07E8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r07E8);
                        body.emit(assign(r07E8, body.constant(0u), 0x02));

                        body.emit(assign(r07E8, body.constant(0u), 0x01));

                        body.emit(assign(r03D4, r07E8, 0x03));


                     body.instructions = f075C_parent_instructions;
                     body.emit(f075C);

                     /* END IF */


                  body.instructions = f06D0_parent_instructions;
                  body.emit(f06D0);

                  /* END IF */


               body.instructions = f0644_parent_instructions;
               body.emit(f0644);

               /* END IF */


            body.instructions = f05B8_parent_instructions;
            body.emit(f05B8);

            /* END IF */


         body.instructions = f0591_parent_instructions;
         body.emit(f0591);

         /* END IF */


      body.instructions = f04BD_parent_instructions;
      body.emit(f04BD);

      /* END IF */


   body.instructions = f03ED_parent_instructions;
   body.emit(f03ED);

   /* END IF */

   body.emit(ret(r03D4));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fadd64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r07E9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r07E9);
   ir_variable *const r07EA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r07EA);
   ir_variable *const r07EB = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r07EC = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07EC, rshift(swizzle_y(r07E9), body.constant(int(31))), 0x01));

   ir_variable *const r07ED = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07ED, rshift(swizzle_y(r07EA), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r07EF = equal(r07EC, r07ED);
   ir_if *f07EE = new(mem_ctx) ir_if(operand(r07EF).val);
   exec_list *const f07EE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f07EE->then_instructions;

      ir_variable *const r07F0 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r07F0, body.constant(true), 0x01));

      ir_variable *const r07F1 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r07F2 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r07F2);
      ir_variable *const r07F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r07F3);
      ir_variable *const r07F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r07F4);
      ir_variable *const r07F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r07F5);
      ir_variable *const r07F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r07F6);
      ir_variable *const r07F7 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r07F7);
      ir_variable *const r07F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r07F8);
      ir_variable *const r07F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r07F9);
      body.emit(assign(r07F9, body.constant(0u), 0x01));

      body.emit(assign(r07F8, body.constant(0u), 0x01));

      ir_variable *const r07FA = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r07FA, swizzle_x(r07E9), 0x01));

      body.emit(assign(r07F6, r07FA, 0x01));

      ir_variable *const r07FB = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r07FB, bit_and(swizzle_y(r07E9), body.constant(1048575u)), 0x01));

      body.emit(assign(r07F5, r07FB, 0x01));

      ir_variable *const r07FC = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r07FC, swizzle_x(r07EA), 0x01));

      body.emit(assign(r07F4, r07FC, 0x01));

      ir_variable *const r07FD = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r07FD, bit_and(swizzle_y(r07EA), body.constant(1048575u)), 0x01));

      body.emit(assign(r07F3, r07FD, 0x01));

      ir_variable *const r07FE = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r07FF = rshift(swizzle_y(r07E9), body.constant(int(20)));
      ir_expression *const r0800 = bit_and(r07FF, body.constant(2047u));
      body.emit(assign(r07FE, expr(ir_unop_u2i, r0800), 0x01));

      ir_variable *const r0801 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r0802 = rshift(swizzle_y(r07EA), body.constant(int(20)));
      ir_expression *const r0803 = bit_and(r0802, body.constant(2047u));
      body.emit(assign(r0801, expr(ir_unop_u2i, r0803), 0x01));

      ir_variable *const r0804 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r0804, sub(r07FE, r0801), 0x01));

      body.emit(assign(r07F2, r0804, 0x01));

      /* IF CONDITION */
      ir_expression *const r0806 = less(body.constant(int(0)), r0804);
      ir_if *f0805 = new(mem_ctx) ir_if(operand(r0806).val);
      exec_list *const f0805_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0805->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0808 = equal(r07FE, body.constant(int(2047)));
         ir_if *f0807 = new(mem_ctx) ir_if(operand(r0808).val);
         exec_list *const f0807_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0807->then_instructions;

            /* IF CONDITION */
            ir_expression *const r080A = bit_or(r07FB, swizzle_x(r07E9));
            ir_expression *const r080B = nequal(r080A, body.constant(0u));
            ir_if *f0809 = new(mem_ctx) ir_if(operand(r080B).val);
            exec_list *const f0809_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0809->then_instructions;

               ir_variable *const r080C = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r080C, swizzle_x(r07E9), 0x01));

               ir_variable *const r080D = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r080D, swizzle_x(r07EA), 0x01));

               ir_variable *const r080E = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r080F = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0810 = rshift(swizzle_y(r07E9), body.constant(int(19)));
               ir_expression *const r0811 = bit_and(r0810, body.constant(4095u));
               ir_expression *const r0812 = equal(r0811, body.constant(4094u));
               ir_expression *const r0813 = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r0814 = bit_and(swizzle_y(r07E9), body.constant(524287u));
               ir_expression *const r0815 = nequal(r0814, body.constant(0u));
               ir_expression *const r0816 = logic_or(r0813, r0815);
               body.emit(assign(r080F, logic_and(r0812, r0816), 0x01));

               ir_variable *const r0817 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r0818 = lshift(swizzle_y(r07EA), body.constant(int(1)));
               ir_expression *const r0819 = lequal(body.constant(4292870144u), r0818);
               ir_expression *const r081A = nequal(swizzle_x(r07EA), body.constant(0u));
               ir_expression *const r081B = bit_and(swizzle_y(r07EA), body.constant(1048575u));
               ir_expression *const r081C = nequal(r081B, body.constant(0u));
               ir_expression *const r081D = logic_or(r081A, r081C);
               body.emit(assign(r0817, logic_and(r0819, r081D), 0x01));

               body.emit(assign(r080C, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

               body.emit(assign(r080D, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r081F = lshift(swizzle_y(r07E9), body.constant(int(1)));
               ir_expression *const r0820 = lequal(body.constant(4292870144u), r081F);
               ir_expression *const r0821 = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r0822 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
               ir_expression *const r0823 = nequal(r0822, body.constant(0u));
               ir_expression *const r0824 = logic_or(r0821, r0823);
               ir_expression *const r0825 = logic_and(r0820, r0824);
               ir_if *f081E = new(mem_ctx) ir_if(operand(r0825).val);
               exec_list *const f081E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f081E->then_instructions;

                  ir_variable *const r0826 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0828 = logic_and(r080F, r0817);
                  ir_if *f0827 = new(mem_ctx) ir_if(operand(r0828).val);
                  exec_list *const f0827_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0827->then_instructions;

                     body.emit(assign(r0826, r080D, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0827->else_instructions;

                     body.emit(assign(r0826, r080C, 0x03));


                  body.instructions = f0827_parent_instructions;
                  body.emit(f0827);

                  /* END IF */

                  body.emit(assign(r080E, r0826, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f081E->else_instructions;

                  body.emit(assign(r080E, r080D, 0x03));


               body.instructions = f081E_parent_instructions;
               body.emit(f081E);

               /* END IF */

               body.emit(assign(r07F1, r080E, 0x03));

               body.emit(assign(r07F0, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0809->else_instructions;

               body.emit(assign(r07F1, r07E9, 0x03));

               body.emit(assign(r07F0, body.constant(false), 0x01));


            body.instructions = f0809_parent_instructions;
            body.emit(f0809);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0807->else_instructions;

            /* IF CONDITION */
            ir_expression *const r082A = equal(r0801, body.constant(int(0)));
            ir_if *f0829 = new(mem_ctx) ir_if(operand(r082A).val);
            exec_list *const f0829_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0829->then_instructions;

               body.emit(assign(r07F2, add(r0804, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0829->else_instructions;

               body.emit(assign(r07F3, bit_or(r07FD, body.constant(1048576u)), 0x01));


            body.instructions = f0829_parent_instructions;
            body.emit(f0829);

            /* END IF */

            ir_variable *const r082B = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r082B, body.constant(0u), 0x01));

            ir_variable *const r082C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r082C);
            ir_variable *const r082D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r082D);
            ir_variable *const r082E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r082E);
            ir_variable *const r082F = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0830 = neg(r07F2);
            body.emit(assign(r082F, bit_and(r0830, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0832 = equal(r07F2, body.constant(int(0)));
            ir_if *f0831 = new(mem_ctx) ir_if(operand(r0832).val);
            exec_list *const f0831_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0831->then_instructions;

               body.emit(assign(r082C, r082B, 0x01));

               body.emit(assign(r082D, r07FC, 0x01));

               body.emit(assign(r082E, r07F3, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0831->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0834 = less(r07F2, body.constant(int(32)));
               ir_if *f0833 = new(mem_ctx) ir_if(operand(r0834).val);
               exec_list *const f0833_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0833->then_instructions;

                  body.emit(assign(r082C, lshift(swizzle_x(r07EA), r082F), 0x01));

                  ir_expression *const r0835 = lshift(r07F3, r082F);
                  ir_expression *const r0836 = rshift(swizzle_x(r07EA), r07F2);
                  body.emit(assign(r082D, bit_or(r0835, r0836), 0x01));

                  body.emit(assign(r082E, rshift(r07F3, r07F2), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0833->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0838 = equal(r07F2, body.constant(int(32)));
                  ir_if *f0837 = new(mem_ctx) ir_if(operand(r0838).val);
                  exec_list *const f0837_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0837->then_instructions;

                     body.emit(assign(r082C, r07FC, 0x01));

                     body.emit(assign(r082D, r07F3, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0837->else_instructions;

                     body.emit(assign(r082B, bit_or(body.constant(0u), swizzle_x(r07EA)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r083A = less(r07F2, body.constant(int(64)));
                     ir_if *f0839 = new(mem_ctx) ir_if(operand(r083A).val);
                     exec_list *const f0839_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0839->then_instructions;

                        body.emit(assign(r082C, lshift(r07F3, r082F), 0x01));

                        ir_expression *const r083B = bit_and(r07F2, body.constant(int(31)));
                        body.emit(assign(r082D, rshift(r07F3, r083B), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0839->else_instructions;

                        ir_variable *const r083C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r083E = equal(r07F2, body.constant(int(64)));
                        ir_if *f083D = new(mem_ctx) ir_if(operand(r083E).val);
                        exec_list *const f083D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f083D->then_instructions;

                           body.emit(assign(r083C, r07F3, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f083D->else_instructions;

                           ir_expression *const r083F = nequal(r07F3, body.constant(0u));
                           ir_expression *const r0840 = expr(ir_unop_b2i, r083F);
                           body.emit(assign(r083C, expr(ir_unop_i2u, r0840), 0x01));


                        body.instructions = f083D_parent_instructions;
                        body.emit(f083D);

                        /* END IF */

                        body.emit(assign(r082C, r083C, 0x01));

                        body.emit(assign(r082D, body.constant(0u), 0x01));


                     body.instructions = f0839_parent_instructions;
                     body.emit(f0839);

                     /* END IF */


                  body.instructions = f0837_parent_instructions;
                  body.emit(f0837);

                  /* END IF */

                  body.emit(assign(r082E, body.constant(0u), 0x01));


               body.instructions = f0833_parent_instructions;
               body.emit(f0833);

               /* END IF */

               ir_expression *const r0841 = nequal(r082B, body.constant(0u));
               ir_expression *const r0842 = expr(ir_unop_b2i, r0841);
               ir_expression *const r0843 = expr(ir_unop_i2u, r0842);
               body.emit(assign(r082C, bit_or(r082C, r0843), 0x01));


            body.instructions = f0831_parent_instructions;
            body.emit(f0831);

            /* END IF */

            body.emit(assign(r07F3, r082E, 0x01));

            body.emit(assign(r07F4, r082D, 0x01));

            body.emit(assign(r07F8, r082C, 0x01));

            body.emit(assign(r07F7, r07FE, 0x01));


         body.instructions = f0807_parent_instructions;
         body.emit(f0807);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0805->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0845 = less(r07F2, body.constant(int(0)));
         ir_if *f0844 = new(mem_ctx) ir_if(operand(r0845).val);
         exec_list *const f0844_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0844->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0847 = equal(r0801, body.constant(int(2047)));
            ir_if *f0846 = new(mem_ctx) ir_if(operand(r0847).val);
            exec_list *const f0846_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0846->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0849 = bit_or(r07F3, r07F4);
               ir_expression *const r084A = nequal(r0849, body.constant(0u));
               ir_if *f0848 = new(mem_ctx) ir_if(operand(r084A).val);
               exec_list *const f0848_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0848->then_instructions;

                  ir_variable *const r084B = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r084B, swizzle_x(r07E9), 0x01));

                  ir_variable *const r084C = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r084C, swizzle_x(r07EA), 0x01));

                  ir_variable *const r084D = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r084E = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r084F = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0850 = bit_and(r084F, body.constant(4095u));
                  ir_expression *const r0851 = equal(r0850, body.constant(4094u));
                  ir_expression *const r0852 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0853 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0854 = nequal(r0853, body.constant(0u));
                  ir_expression *const r0855 = logic_or(r0852, r0854);
                  body.emit(assign(r084E, logic_and(r0851, r0855), 0x01));

                  ir_variable *const r0856 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0857 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0858 = lequal(body.constant(4292870144u), r0857);
                  ir_expression *const r0859 = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r085A = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r085B = nequal(r085A, body.constant(0u));
                  ir_expression *const r085C = logic_or(r0859, r085B);
                  body.emit(assign(r0856, logic_and(r0858, r085C), 0x01));

                  body.emit(assign(r084B, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r084C, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r085E = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r085F = lequal(body.constant(4292870144u), r085E);
                  ir_expression *const r0860 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0861 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0862 = nequal(r0861, body.constant(0u));
                  ir_expression *const r0863 = logic_or(r0860, r0862);
                  ir_expression *const r0864 = logic_and(r085F, r0863);
                  ir_if *f085D = new(mem_ctx) ir_if(operand(r0864).val);
                  exec_list *const f085D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f085D->then_instructions;

                     ir_variable *const r0865 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0867 = logic_and(r084E, r0856);
                     ir_if *f0866 = new(mem_ctx) ir_if(operand(r0867).val);
                     exec_list *const f0866_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0866->then_instructions;

                        body.emit(assign(r0865, r084C, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0866->else_instructions;

                        body.emit(assign(r0865, r084B, 0x03));


                     body.instructions = f0866_parent_instructions;
                     body.emit(f0866);

                     /* END IF */

                     body.emit(assign(r084D, r0865, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f085D->else_instructions;

                     body.emit(assign(r084D, r084C, 0x03));


                  body.instructions = f085D_parent_instructions;
                  body.emit(f085D);

                  /* END IF */

                  body.emit(assign(r07F1, r084D, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0848->else_instructions;

                  ir_variable *const r0868 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0868);
                  ir_expression *const r0869 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0868, add(r0869, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0868, body.constant(0u), 0x01));

                  body.emit(assign(r07F1, r0868, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f0848_parent_instructions;
               body.emit(f0848);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0846->else_instructions;

               /* IF CONDITION */
               ir_expression *const r086B = equal(r07FE, body.constant(int(0)));
               ir_if *f086A = new(mem_ctx) ir_if(operand(r086B).val);
               exec_list *const f086A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f086A->then_instructions;

                  body.emit(assign(r07F2, add(r07F2, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f086A->else_instructions;

                  body.emit(assign(r07F5, bit_or(r07FB, body.constant(1048576u)), 0x01));


               body.instructions = f086A_parent_instructions;
               body.emit(f086A);

               /* END IF */

               ir_variable *const r086C = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r086C, body.constant(0u), 0x01));

               ir_variable *const r086D = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r086D, neg(r07F2), 0x01));

               ir_variable *const r086E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r086E);
               ir_variable *const r086F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r086F);
               ir_variable *const r0870 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0870);
               ir_variable *const r0871 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0872 = neg(r086D);
               body.emit(assign(r0871, bit_and(r0872, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0874 = equal(r086D, body.constant(int(0)));
               ir_if *f0873 = new(mem_ctx) ir_if(operand(r0874).val);
               exec_list *const f0873_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0873->then_instructions;

                  body.emit(assign(r086E, r086C, 0x01));

                  body.emit(assign(r086F, r07FA, 0x01));

                  body.emit(assign(r0870, r07F5, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0873->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0876 = less(r086D, body.constant(int(32)));
                  ir_if *f0875 = new(mem_ctx) ir_if(operand(r0876).val);
                  exec_list *const f0875_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0875->then_instructions;

                     body.emit(assign(r086E, lshift(swizzle_x(r07E9), r0871), 0x01));

                     ir_expression *const r0877 = lshift(r07F5, r0871);
                     ir_expression *const r0878 = rshift(swizzle_x(r07E9), r086D);
                     body.emit(assign(r086F, bit_or(r0877, r0878), 0x01));

                     body.emit(assign(r0870, rshift(r07F5, r086D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0875->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r087A = equal(r086D, body.constant(int(32)));
                     ir_if *f0879 = new(mem_ctx) ir_if(operand(r087A).val);
                     exec_list *const f0879_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0879->then_instructions;

                        body.emit(assign(r086E, r07FA, 0x01));

                        body.emit(assign(r086F, r07F5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0879->else_instructions;

                        body.emit(assign(r086C, bit_or(body.constant(0u), swizzle_x(r07E9)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r087C = less(r086D, body.constant(int(64)));
                        ir_if *f087B = new(mem_ctx) ir_if(operand(r087C).val);
                        exec_list *const f087B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f087B->then_instructions;

                           body.emit(assign(r086E, lshift(r07F5, r0871), 0x01));

                           ir_expression *const r087D = bit_and(r086D, body.constant(int(31)));
                           body.emit(assign(r086F, rshift(r07F5, r087D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f087B->else_instructions;

                           ir_variable *const r087E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0880 = equal(r086D, body.constant(int(64)));
                           ir_if *f087F = new(mem_ctx) ir_if(operand(r0880).val);
                           exec_list *const f087F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f087F->then_instructions;

                              body.emit(assign(r087E, r07F5, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f087F->else_instructions;

                              ir_expression *const r0881 = nequal(r07F5, body.constant(0u));
                              ir_expression *const r0882 = expr(ir_unop_b2i, r0881);
                              body.emit(assign(r087E, expr(ir_unop_i2u, r0882), 0x01));


                           body.instructions = f087F_parent_instructions;
                           body.emit(f087F);

                           /* END IF */

                           body.emit(assign(r086E, r087E, 0x01));

                           body.emit(assign(r086F, body.constant(0u), 0x01));


                        body.instructions = f087B_parent_instructions;
                        body.emit(f087B);

                        /* END IF */


                     body.instructions = f0879_parent_instructions;
                     body.emit(f0879);

                     /* END IF */

                     body.emit(assign(r0870, body.constant(0u), 0x01));


                  body.instructions = f0875_parent_instructions;
                  body.emit(f0875);

                  /* END IF */

                  ir_expression *const r0883 = nequal(r086C, body.constant(0u));
                  ir_expression *const r0884 = expr(ir_unop_b2i, r0883);
                  ir_expression *const r0885 = expr(ir_unop_i2u, r0884);
                  body.emit(assign(r086E, bit_or(r086E, r0885), 0x01));


               body.instructions = f0873_parent_instructions;
               body.emit(f0873);

               /* END IF */

               body.emit(assign(r07F5, r0870, 0x01));

               body.emit(assign(r07F6, r086F, 0x01));

               body.emit(assign(r07F8, r086E, 0x01));

               body.emit(assign(r07F7, r0801, 0x01));


            body.instructions = f0846_parent_instructions;
            body.emit(f0846);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0844->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0887 = equal(r07FE, body.constant(int(2047)));
            ir_if *f0886 = new(mem_ctx) ir_if(operand(r0887).val);
            exec_list *const f0886_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0886->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0889 = bit_or(r07F5, r07F6);
               ir_expression *const r088A = bit_or(r07F3, r07F4);
               ir_expression *const r088B = bit_or(r0889, r088A);
               ir_expression *const r088C = nequal(r088B, body.constant(0u));
               ir_if *f0888 = new(mem_ctx) ir_if(operand(r088C).val);
               exec_list *const f0888_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0888->then_instructions;

                  ir_variable *const r088D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r088D, swizzle_x(r07E9), 0x01));

                  ir_variable *const r088E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r088E, swizzle_x(r07EA), 0x01));

                  ir_variable *const r088F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0890 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0891 = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0892 = bit_and(r0891, body.constant(4095u));
                  ir_expression *const r0893 = equal(r0892, body.constant(4094u));
                  ir_expression *const r0894 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0895 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0896 = nequal(r0895, body.constant(0u));
                  ir_expression *const r0897 = logic_or(r0894, r0896);
                  body.emit(assign(r0890, logic_and(r0893, r0897), 0x01));

                  ir_variable *const r0898 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0899 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r089A = lequal(body.constant(4292870144u), r0899);
                  ir_expression *const r089B = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r089C = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r089D = nequal(r089C, body.constant(0u));
                  ir_expression *const r089E = logic_or(r089B, r089D);
                  body.emit(assign(r0898, logic_and(r089A, r089E), 0x01));

                  body.emit(assign(r088D, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r088E, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r08A0 = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r08A1 = lequal(body.constant(4292870144u), r08A0);
                  ir_expression *const r08A2 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r08A3 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r08A4 = nequal(r08A3, body.constant(0u));
                  ir_expression *const r08A5 = logic_or(r08A2, r08A4);
                  ir_expression *const r08A6 = logic_and(r08A1, r08A5);
                  ir_if *f089F = new(mem_ctx) ir_if(operand(r08A6).val);
                  exec_list *const f089F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f089F->then_instructions;

                     ir_variable *const r08A7 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08A9 = logic_and(r0890, r0898);
                     ir_if *f08A8 = new(mem_ctx) ir_if(operand(r08A9).val);
                     exec_list *const f08A8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08A8->then_instructions;

                        body.emit(assign(r08A7, r088E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08A8->else_instructions;

                        body.emit(assign(r08A7, r088D, 0x03));


                     body.instructions = f08A8_parent_instructions;
                     body.emit(f08A8);

                     /* END IF */

                     body.emit(assign(r088F, r08A7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f089F->else_instructions;

                     body.emit(assign(r088F, r088E, 0x03));


                  body.instructions = f089F_parent_instructions;
                  body.emit(f089F);

                  /* END IF */

                  body.emit(assign(r07F1, r088F, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0888->else_instructions;

                  body.emit(assign(r07F1, r07E9, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f0888_parent_instructions;
               body.emit(f0888);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0886->else_instructions;

               ir_variable *const r08AA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r08AB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r08AB, add(r07F6, r07F4), 0x01));

               ir_expression *const r08AC = add(r07F5, r07F3);
               ir_expression *const r08AD = less(r08AB, r07F6);
               ir_expression *const r08AE = expr(ir_unop_b2i, r08AD);
               ir_expression *const r08AF = expr(ir_unop_i2u, r08AE);
               body.emit(assign(r08AA, add(r08AC, r08AF), 0x01));

               body.emit(assign(r07F9, r08AA, 0x01));

               /* IF CONDITION */
               ir_expression *const r08B1 = equal(r07FE, body.constant(int(0)));
               ir_if *f08B0 = new(mem_ctx) ir_if(operand(r08B1).val);
               exec_list *const f08B0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f08B0->then_instructions;

                  ir_variable *const r08B2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r08B2);
                  ir_expression *const r08B3 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r08B2, add(r08B3, r08AA), 0x02));

                  body.emit(assign(r08B2, r08AB, 0x01));

                  body.emit(assign(r07F1, r08B2, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f08B0->else_instructions;

                  body.emit(assign(r07F9, bit_or(r08AA, body.constant(2097152u)), 0x01));

                  body.emit(assign(r07F7, r07FE, 0x01));

                  ir_variable *const r08B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r08B4);
                  ir_variable *const r08B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r08B5);
                  ir_variable *const r08B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r08B6);
                  body.emit(assign(r08B4, lshift(r08AB, body.constant(int(31))), 0x01));

                  ir_expression *const r08B7 = lshift(r07F9, body.constant(int(31)));
                  ir_expression *const r08B8 = rshift(r08AB, body.constant(int(1)));
                  body.emit(assign(r08B5, bit_or(r08B7, r08B8), 0x01));

                  body.emit(assign(r08B6, rshift(r07F9, body.constant(int(1))), 0x01));

                  body.emit(assign(r08B4, bit_or(r08B4, body.constant(0u)), 0x01));

                  body.emit(assign(r07F9, r08B6, 0x01));

                  body.emit(assign(r07F8, r08B4, 0x01));

                  ir_variable *const r08B9 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r08B9, r07FE, 0x01));

                  ir_variable *const r08BA = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r08BA, r08B6, 0x01));

                  ir_variable *const r08BB = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r08BB, r08B5, 0x01));

                  ir_variable *const r08BC = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r08BC, r08B4, 0x01));

                  ir_variable *const r08BD = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r08BD, body.constant(true), 0x01));

                  ir_variable *const r08BE = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r08BF = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r08BF);
                  ir_expression *const r08C0 = expr(ir_unop_u2i, r08B4);
                  body.emit(assign(r08BF, less(r08C0, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r08C2 = lequal(body.constant(int(2045)), r07FE);
                  ir_if *f08C1 = new(mem_ctx) ir_if(operand(r08C2).val);
                  exec_list *const f08C1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08C1->then_instructions;

                     ir_variable *const r08C3 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08C5 = less(body.constant(int(2045)), r07FE);
                     ir_if *f08C4 = new(mem_ctx) ir_if(operand(r08C5).val);
                     exec_list *const f08C4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08C4->then_instructions;

                        body.emit(assign(r08C3, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08C4->else_instructions;

                        ir_variable *const r08C6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r08C8 = equal(r07FE, body.constant(int(2045)));
                        ir_if *f08C7 = new(mem_ctx) ir_if(operand(r08C8).val);
                        exec_list *const f08C7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08C7->then_instructions;

                           ir_expression *const r08C9 = equal(body.constant(2097151u), r08B6);
                           ir_expression *const r08CA = equal(body.constant(4294967295u), r08B5);
                           body.emit(assign(r08C6, logic_and(r08C9, r08CA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f08C7->else_instructions;

                           body.emit(assign(r08C6, body.constant(false), 0x01));


                        body.instructions = f08C7_parent_instructions;
                        body.emit(f08C7);

                        /* END IF */

                        body.emit(assign(r08C3, logic_and(r08C6, r08BF), 0x01));


                     body.instructions = f08C4_parent_instructions;
                     body.emit(f08C4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f08CB = new(mem_ctx) ir_if(operand(r08C3).val);
                     exec_list *const f08CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08CB->then_instructions;

                        ir_variable *const r08CC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r08CC);
                        ir_expression *const r08CD = lshift(r07EC, body.constant(int(31)));
                        body.emit(assign(r08CC, add(r08CD, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r08CC, body.constant(0u), 0x01));

                        body.emit(assign(r08BE, r08CC, 0x03));

                        body.emit(assign(r08BD, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08CB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08CF = less(r07FE, body.constant(int(0)));
                        ir_if *f08CE = new(mem_ctx) ir_if(operand(r08CF).val);
                        exec_list *const f08CE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08CE->then_instructions;

                           ir_variable *const r08D0 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r08D0, r08B4, 0x01));

                           ir_variable *const r08D1 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r08D1, neg(r07FE), 0x01));

                           ir_variable *const r08D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r08D2);
                           ir_variable *const r08D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r08D3);
                           ir_variable *const r08D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r08D4);
                           ir_variable *const r08D5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r08D6 = neg(r08D1);
                           body.emit(assign(r08D5, bit_and(r08D6, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r08D8 = equal(r08D1, body.constant(int(0)));
                           ir_if *f08D7 = new(mem_ctx) ir_if(operand(r08D8).val);
                           exec_list *const f08D7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f08D7->then_instructions;

                              body.emit(assign(r08D2, r08B4, 0x01));

                              body.emit(assign(r08D3, r08B5, 0x01));

                              body.emit(assign(r08D4, r08B6, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f08D7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r08DA = less(r08D1, body.constant(int(32)));
                              ir_if *f08D9 = new(mem_ctx) ir_if(operand(r08DA).val);
                              exec_list *const f08D9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f08D9->then_instructions;

                                 body.emit(assign(r08D2, lshift(r08B5, r08D5), 0x01));

                                 ir_expression *const r08DB = lshift(r08B6, r08D5);
                                 ir_expression *const r08DC = rshift(r08B5, r08D1);
                                 body.emit(assign(r08D3, bit_or(r08DB, r08DC), 0x01));

                                 body.emit(assign(r08D4, rshift(r08B6, r08D1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f08D9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r08DE = equal(r08D1, body.constant(int(32)));
                                 ir_if *f08DD = new(mem_ctx) ir_if(operand(r08DE).val);
                                 exec_list *const f08DD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f08DD->then_instructions;

                                    body.emit(assign(r08D2, r08B5, 0x01));

                                    body.emit(assign(r08D3, r08B6, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f08DD->else_instructions;

                                    body.emit(assign(r08D0, bit_or(r08B4, r08B5), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r08E0 = less(r08D1, body.constant(int(64)));
                                    ir_if *f08DF = new(mem_ctx) ir_if(operand(r08E0).val);
                                    exec_list *const f08DF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f08DF->then_instructions;

                                       body.emit(assign(r08D2, lshift(r08B6, r08D5), 0x01));

                                       ir_expression *const r08E1 = bit_and(r08D1, body.constant(int(31)));
                                       body.emit(assign(r08D3, rshift(r08B6, r08E1), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f08DF->else_instructions;

                                       ir_variable *const r08E2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r08E4 = equal(r08D1, body.constant(int(64)));
                                       ir_if *f08E3 = new(mem_ctx) ir_if(operand(r08E4).val);
                                       exec_list *const f08E3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f08E3->then_instructions;

                                          body.emit(assign(r08E2, r08B6, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f08E3->else_instructions;

                                          ir_expression *const r08E5 = nequal(r08B6, body.constant(0u));
                                          ir_expression *const r08E6 = expr(ir_unop_b2i, r08E5);
                                          body.emit(assign(r08E2, expr(ir_unop_i2u, r08E6), 0x01));


                                       body.instructions = f08E3_parent_instructions;
                                       body.emit(f08E3);

                                       /* END IF */

                                       body.emit(assign(r08D2, r08E2, 0x01));

                                       body.emit(assign(r08D3, body.constant(0u), 0x01));


                                    body.instructions = f08DF_parent_instructions;
                                    body.emit(f08DF);

                                    /* END IF */


                                 body.instructions = f08DD_parent_instructions;
                                 body.emit(f08DD);

                                 /* END IF */

                                 body.emit(assign(r08D4, body.constant(0u), 0x01));


                              body.instructions = f08D9_parent_instructions;
                              body.emit(f08D9);

                              /* END IF */

                              ir_expression *const r08E7 = nequal(r08D0, body.constant(0u));
                              ir_expression *const r08E8 = expr(ir_unop_b2i, r08E7);
                              ir_expression *const r08E9 = expr(ir_unop_i2u, r08E8);
                              body.emit(assign(r08D2, bit_or(r08D2, r08E9), 0x01));


                           body.instructions = f08D7_parent_instructions;
                           body.emit(f08D7);

                           /* END IF */

                           body.emit(assign(r08BA, r08D4, 0x01));

                           body.emit(assign(r08BB, r08D3, 0x01));

                           body.emit(assign(r08BC, r08D2, 0x01));

                           body.emit(assign(r08B9, body.constant(int(0)), 0x01));

                           body.emit(assign(r08BF, less(r08D2, body.constant(0u)), 0x01));


                        body.instructions = f08CE_parent_instructions;
                        body.emit(f08CE);

                        /* END IF */


                     body.instructions = f08CB_parent_instructions;
                     body.emit(f08CB);

                     /* END IF */


                  body.instructions = f08C1_parent_instructions;
                  body.emit(f08C1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f08EA = new(mem_ctx) ir_if(operand(r08BD).val);
                  exec_list *const f08EA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08EA->then_instructions;

                     /* IF CONDITION */
                     ir_if *f08EB = new(mem_ctx) ir_if(operand(r08BF).val);
                     exec_list *const f08EB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08EB->then_instructions;

                        ir_variable *const r08EC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r08EC, add(r08BB, body.constant(1u)), 0x01));

                        ir_expression *const r08ED = less(r08EC, r08BB);
                        ir_expression *const r08EE = expr(ir_unop_b2i, r08ED);
                        ir_expression *const r08EF = expr(ir_unop_i2u, r08EE);
                        body.emit(assign(r08BA, add(r08BA, r08EF), 0x01));

                        ir_expression *const r08F0 = equal(r08BC, body.constant(0u));
                        ir_expression *const r08F1 = expr(ir_unop_b2i, r08F0);
                        ir_expression *const r08F2 = expr(ir_unop_i2u, r08F1);
                        ir_expression *const r08F3 = add(r08BC, r08F2);
                        ir_expression *const r08F4 = bit_and(r08F3, body.constant(1u));
                        ir_expression *const r08F5 = expr(ir_unop_bit_not, r08F4);
                        body.emit(assign(r08BB, bit_and(r08EC, r08F5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08EB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08F7 = bit_or(r08BA, r08BB);
                        ir_expression *const r08F8 = equal(r08F7, body.constant(0u));
                        ir_if *f08F6 = new(mem_ctx) ir_if(operand(r08F8).val);
                        exec_list *const f08F6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08F6->then_instructions;

                           body.emit(assign(r08B9, body.constant(int(0)), 0x01));


                        body.instructions = f08F6_parent_instructions;
                        body.emit(f08F6);

                        /* END IF */


                     body.instructions = f08EB_parent_instructions;
                     body.emit(f08EB);

                     /* END IF */

                     ir_variable *const r08F9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r08F9);
                     ir_expression *const r08FA = lshift(r07EC, body.constant(int(31)));
                     ir_expression *const r08FB = expr(ir_unop_i2u, r08B9);
                     ir_expression *const r08FC = lshift(r08FB, body.constant(int(20)));
                     ir_expression *const r08FD = add(r08FA, r08FC);
                     body.emit(assign(r08F9, add(r08FD, r08BA), 0x02));

                     body.emit(assign(r08F9, r08BB, 0x01));

                     body.emit(assign(r08BE, r08F9, 0x03));

                     body.emit(assign(r08BD, body.constant(false), 0x01));


                  body.instructions = f08EA_parent_instructions;
                  body.emit(f08EA);

                  /* END IF */

                  body.emit(assign(r07F1, r08BE, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f08B0_parent_instructions;
               body.emit(f08B0);

               /* END IF */


            body.instructions = f0886_parent_instructions;
            body.emit(f0886);

            /* END IF */


         body.instructions = f0844_parent_instructions;
         body.emit(f0844);

         /* END IF */


      body.instructions = f0805_parent_instructions;
      body.emit(f0805);

      /* END IF */

      /* IF CONDITION */
      ir_if *f08FE = new(mem_ctx) ir_if(operand(r07F0).val);
      exec_list *const f08FE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f08FE->then_instructions;

         body.emit(assign(r07F5, bit_or(r07F5, body.constant(1048576u)), 0x01));

         ir_variable *const r08FF = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r0900 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r0900, add(r07F6, r07F4), 0x01));

         ir_expression *const r0901 = add(r07F5, r07F3);
         ir_expression *const r0902 = less(r0900, r07F6);
         ir_expression *const r0903 = expr(ir_unop_b2i, r0902);
         ir_expression *const r0904 = expr(ir_unop_i2u, r0903);
         body.emit(assign(r08FF, add(r0901, r0904), 0x01));

         body.emit(assign(r07F9, r08FF, 0x01));

         body.emit(assign(r07F7, add(r07F7, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0906 = less(r08FF, body.constant(2097152u));
         ir_if *f0905 = new(mem_ctx) ir_if(operand(r0906).val);
         exec_list *const f0905_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0905->then_instructions;

            ir_variable *const r0907 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0907, r07F7, 0x01));

            ir_variable *const r0908 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0908, r08FF, 0x01));

            ir_variable *const r0909 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0909, r0900, 0x01));

            ir_variable *const r090A = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r090A, r07F8, 0x01));

            ir_variable *const r090B = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r090B, body.constant(true), 0x01));

            ir_variable *const r090C = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r090D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r090D);
            ir_expression *const r090E = expr(ir_unop_u2i, r07F8);
            body.emit(assign(r090D, less(r090E, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0910 = lequal(body.constant(int(2045)), r07F7);
            ir_if *f090F = new(mem_ctx) ir_if(operand(r0910).val);
            exec_list *const f090F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f090F->then_instructions;

               ir_variable *const r0911 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0913 = less(body.constant(int(2045)), r07F7);
               ir_if *f0912 = new(mem_ctx) ir_if(operand(r0913).val);
               exec_list *const f0912_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0912->then_instructions;

                  body.emit(assign(r0911, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0912->else_instructions;

                  ir_variable *const r0914 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0916 = equal(r07F7, body.constant(int(2045)));
                  ir_if *f0915 = new(mem_ctx) ir_if(operand(r0916).val);
                  exec_list *const f0915_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0915->then_instructions;

                     ir_expression *const r0917 = equal(body.constant(2097151u), r08FF);
                     ir_expression *const r0918 = equal(body.constant(4294967295u), r0900);
                     body.emit(assign(r0914, logic_and(r0917, r0918), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0915->else_instructions;

                     body.emit(assign(r0914, body.constant(false), 0x01));


                  body.instructions = f0915_parent_instructions;
                  body.emit(f0915);

                  /* END IF */

                  body.emit(assign(r0911, logic_and(r0914, r090D), 0x01));


               body.instructions = f0912_parent_instructions;
               body.emit(f0912);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0919 = new(mem_ctx) ir_if(operand(r0911).val);
               exec_list *const f0919_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0919->then_instructions;

                  ir_variable *const r091A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r091A);
                  ir_expression *const r091B = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r091A, add(r091B, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r091A, body.constant(0u), 0x01));

                  body.emit(assign(r090C, r091A, 0x03));

                  body.emit(assign(r090B, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0919->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r091D = less(r07F7, body.constant(int(0)));
                  ir_if *f091C = new(mem_ctx) ir_if(operand(r091D).val);
                  exec_list *const f091C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f091C->then_instructions;

                     ir_variable *const r091E = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r091E, r07F8, 0x01));

                     ir_variable *const r091F = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r091F, neg(r07F7), 0x01));

                     ir_variable *const r0920 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0920);
                     ir_variable *const r0921 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0921);
                     ir_variable *const r0922 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0922);
                     ir_variable *const r0923 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0924 = neg(r091F);
                     body.emit(assign(r0923, bit_and(r0924, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0926 = equal(r091F, body.constant(int(0)));
                     ir_if *f0925 = new(mem_ctx) ir_if(operand(r0926).val);
                     exec_list *const f0925_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0925->then_instructions;

                        body.emit(assign(r0920, r07F8, 0x01));

                        body.emit(assign(r0921, r0900, 0x01));

                        body.emit(assign(r0922, r08FF, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0925->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0928 = less(r091F, body.constant(int(32)));
                        ir_if *f0927 = new(mem_ctx) ir_if(operand(r0928).val);
                        exec_list *const f0927_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0927->then_instructions;

                           body.emit(assign(r0920, lshift(r0900, r0923), 0x01));

                           ir_expression *const r0929 = lshift(r08FF, r0923);
                           ir_expression *const r092A = rshift(r0900, r091F);
                           body.emit(assign(r0921, bit_or(r0929, r092A), 0x01));

                           body.emit(assign(r0922, rshift(r08FF, r091F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0927->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r092C = equal(r091F, body.constant(int(32)));
                           ir_if *f092B = new(mem_ctx) ir_if(operand(r092C).val);
                           exec_list *const f092B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f092B->then_instructions;

                              body.emit(assign(r0920, r0900, 0x01));

                              body.emit(assign(r0921, r08FF, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f092B->else_instructions;

                              body.emit(assign(r091E, bit_or(r07F8, r0900), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r092E = less(r091F, body.constant(int(64)));
                              ir_if *f092D = new(mem_ctx) ir_if(operand(r092E).val);
                              exec_list *const f092D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f092D->then_instructions;

                                 body.emit(assign(r0920, lshift(r08FF, r0923), 0x01));

                                 ir_expression *const r092F = bit_and(r091F, body.constant(int(31)));
                                 body.emit(assign(r0921, rshift(r08FF, r092F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f092D->else_instructions;

                                 ir_variable *const r0930 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0932 = equal(r091F, body.constant(int(64)));
                                 ir_if *f0931 = new(mem_ctx) ir_if(operand(r0932).val);
                                 exec_list *const f0931_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0931->then_instructions;

                                    body.emit(assign(r0930, r08FF, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0931->else_instructions;

                                    ir_expression *const r0933 = nequal(r08FF, body.constant(0u));
                                    ir_expression *const r0934 = expr(ir_unop_b2i, r0933);
                                    body.emit(assign(r0930, expr(ir_unop_i2u, r0934), 0x01));


                                 body.instructions = f0931_parent_instructions;
                                 body.emit(f0931);

                                 /* END IF */

                                 body.emit(assign(r0920, r0930, 0x01));

                                 body.emit(assign(r0921, body.constant(0u), 0x01));


                              body.instructions = f092D_parent_instructions;
                              body.emit(f092D);

                              /* END IF */


                           body.instructions = f092B_parent_instructions;
                           body.emit(f092B);

                           /* END IF */

                           body.emit(assign(r0922, body.constant(0u), 0x01));


                        body.instructions = f0927_parent_instructions;
                        body.emit(f0927);

                        /* END IF */

                        ir_expression *const r0935 = nequal(r091E, body.constant(0u));
                        ir_expression *const r0936 = expr(ir_unop_b2i, r0935);
                        ir_expression *const r0937 = expr(ir_unop_i2u, r0936);
                        body.emit(assign(r0920, bit_or(r0920, r0937), 0x01));


                     body.instructions = f0925_parent_instructions;
                     body.emit(f0925);

                     /* END IF */

                     body.emit(assign(r0908, r0922, 0x01));

                     body.emit(assign(r0909, r0921, 0x01));

                     body.emit(assign(r090A, r0920, 0x01));

                     body.emit(assign(r0907, body.constant(int(0)), 0x01));

                     body.emit(assign(r090D, less(r0920, body.constant(0u)), 0x01));


                  body.instructions = f091C_parent_instructions;
                  body.emit(f091C);

                  /* END IF */


               body.instructions = f0919_parent_instructions;
               body.emit(f0919);

               /* END IF */


            body.instructions = f090F_parent_instructions;
            body.emit(f090F);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0938 = new(mem_ctx) ir_if(operand(r090B).val);
            exec_list *const f0938_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0938->then_instructions;

               /* IF CONDITION */
               ir_if *f0939 = new(mem_ctx) ir_if(operand(r090D).val);
               exec_list *const f0939_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0939->then_instructions;

                  ir_variable *const r093A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r093A, add(r0909, body.constant(1u)), 0x01));

                  ir_expression *const r093B = less(r093A, r0909);
                  ir_expression *const r093C = expr(ir_unop_b2i, r093B);
                  ir_expression *const r093D = expr(ir_unop_i2u, r093C);
                  body.emit(assign(r0908, add(r0908, r093D), 0x01));

                  ir_expression *const r093E = equal(r090A, body.constant(0u));
                  ir_expression *const r093F = expr(ir_unop_b2i, r093E);
                  ir_expression *const r0940 = expr(ir_unop_i2u, r093F);
                  ir_expression *const r0941 = add(r090A, r0940);
                  ir_expression *const r0942 = bit_and(r0941, body.constant(1u));
                  ir_expression *const r0943 = expr(ir_unop_bit_not, r0942);
                  body.emit(assign(r0909, bit_and(r093A, r0943), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0939->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0945 = bit_or(r0908, r0909);
                  ir_expression *const r0946 = equal(r0945, body.constant(0u));
                  ir_if *f0944 = new(mem_ctx) ir_if(operand(r0946).val);
                  exec_list *const f0944_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0944->then_instructions;

                     body.emit(assign(r0907, body.constant(int(0)), 0x01));


                  body.instructions = f0944_parent_instructions;
                  body.emit(f0944);

                  /* END IF */


               body.instructions = f0939_parent_instructions;
               body.emit(f0939);

               /* END IF */

               ir_variable *const r0947 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0947);
               ir_expression *const r0948 = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0949 = expr(ir_unop_i2u, r0907);
               ir_expression *const r094A = lshift(r0949, body.constant(int(20)));
               ir_expression *const r094B = add(r0948, r094A);
               body.emit(assign(r0947, add(r094B, r0908), 0x02));

               body.emit(assign(r0947, r0909, 0x01));

               body.emit(assign(r090C, r0947, 0x03));

               body.emit(assign(r090B, body.constant(false), 0x01));


            body.instructions = f0938_parent_instructions;
            body.emit(f0938);

            /* END IF */

            body.emit(assign(r07F1, r090C, 0x03));

            body.emit(assign(r07F0, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0905->else_instructions;

            body.emit(assign(r07F7, add(r07F7, body.constant(int(1))), 0x01));

            ir_variable *const r094C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r094C);
            ir_variable *const r094D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r094D);
            ir_variable *const r094E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r094E);
            body.emit(assign(r094C, lshift(r0900, body.constant(int(31))), 0x01));

            ir_expression *const r094F = lshift(r08FF, body.constant(int(31)));
            ir_expression *const r0950 = rshift(r0900, body.constant(int(1)));
            body.emit(assign(r094D, bit_or(r094F, r0950), 0x01));

            body.emit(assign(r094E, rshift(r08FF, body.constant(int(1))), 0x01));

            ir_expression *const r0951 = nequal(r07F8, body.constant(0u));
            ir_expression *const r0952 = expr(ir_unop_b2i, r0951);
            ir_expression *const r0953 = expr(ir_unop_i2u, r0952);
            body.emit(assign(r094C, bit_or(r094C, r0953), 0x01));

            body.emit(assign(r07F9, r094E, 0x01));

            body.emit(assign(r07F8, r094C, 0x01));

            ir_variable *const r0954 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0954, r07F7, 0x01));

            ir_variable *const r0955 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0955, r094E, 0x01));

            ir_variable *const r0956 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0956, r094D, 0x01));

            ir_variable *const r0957 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0957, r094C, 0x01));

            ir_variable *const r0958 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0958, body.constant(true), 0x01));

            ir_variable *const r0959 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r095A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r095A);
            ir_expression *const r095B = expr(ir_unop_u2i, r094C);
            body.emit(assign(r095A, less(r095B, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r095D = lequal(body.constant(int(2045)), r07F7);
            ir_if *f095C = new(mem_ctx) ir_if(operand(r095D).val);
            exec_list *const f095C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f095C->then_instructions;

               ir_variable *const r095E = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0960 = less(body.constant(int(2045)), r07F7);
               ir_if *f095F = new(mem_ctx) ir_if(operand(r0960).val);
               exec_list *const f095F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f095F->then_instructions;

                  body.emit(assign(r095E, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f095F->else_instructions;

                  ir_variable *const r0961 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0963 = equal(r07F7, body.constant(int(2045)));
                  ir_if *f0962 = new(mem_ctx) ir_if(operand(r0963).val);
                  exec_list *const f0962_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0962->then_instructions;

                     ir_expression *const r0964 = equal(body.constant(2097151u), r094E);
                     ir_expression *const r0965 = equal(body.constant(4294967295u), r094D);
                     body.emit(assign(r0961, logic_and(r0964, r0965), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0962->else_instructions;

                     body.emit(assign(r0961, body.constant(false), 0x01));


                  body.instructions = f0962_parent_instructions;
                  body.emit(f0962);

                  /* END IF */

                  body.emit(assign(r095E, logic_and(r0961, r095A), 0x01));


               body.instructions = f095F_parent_instructions;
               body.emit(f095F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0966 = new(mem_ctx) ir_if(operand(r095E).val);
               exec_list *const f0966_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0966->then_instructions;

                  ir_variable *const r0967 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0967);
                  ir_expression *const r0968 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0967, add(r0968, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0967, body.constant(0u), 0x01));

                  body.emit(assign(r0959, r0967, 0x03));

                  body.emit(assign(r0958, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0966->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r096A = less(r07F7, body.constant(int(0)));
                  ir_if *f0969 = new(mem_ctx) ir_if(operand(r096A).val);
                  exec_list *const f0969_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0969->then_instructions;

                     ir_variable *const r096B = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r096B, r094C, 0x01));

                     ir_variable *const r096C = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r096C, neg(r07F7), 0x01));

                     ir_variable *const r096D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r096D);
                     ir_variable *const r096E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r096E);
                     ir_variable *const r096F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r096F);
                     ir_variable *const r0970 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0971 = neg(r096C);
                     body.emit(assign(r0970, bit_and(r0971, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0973 = equal(r096C, body.constant(int(0)));
                     ir_if *f0972 = new(mem_ctx) ir_if(operand(r0973).val);
                     exec_list *const f0972_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0972->then_instructions;

                        body.emit(assign(r096D, r094C, 0x01));

                        body.emit(assign(r096E, r094D, 0x01));

                        body.emit(assign(r096F, r094E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0972->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0975 = less(r096C, body.constant(int(32)));
                        ir_if *f0974 = new(mem_ctx) ir_if(operand(r0975).val);
                        exec_list *const f0974_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0974->then_instructions;

                           body.emit(assign(r096D, lshift(r094D, r0970), 0x01));

                           ir_expression *const r0976 = lshift(r094E, r0970);
                           ir_expression *const r0977 = rshift(r094D, r096C);
                           body.emit(assign(r096E, bit_or(r0976, r0977), 0x01));

                           body.emit(assign(r096F, rshift(r094E, r096C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0974->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0979 = equal(r096C, body.constant(int(32)));
                           ir_if *f0978 = new(mem_ctx) ir_if(operand(r0979).val);
                           exec_list *const f0978_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0978->then_instructions;

                              body.emit(assign(r096D, r094D, 0x01));

                              body.emit(assign(r096E, r094E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0978->else_instructions;

                              body.emit(assign(r096B, bit_or(r094C, r094D), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r097B = less(r096C, body.constant(int(64)));
                              ir_if *f097A = new(mem_ctx) ir_if(operand(r097B).val);
                              exec_list *const f097A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f097A->then_instructions;

                                 body.emit(assign(r096D, lshift(r094E, r0970), 0x01));

                                 ir_expression *const r097C = bit_and(r096C, body.constant(int(31)));
                                 body.emit(assign(r096E, rshift(r094E, r097C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f097A->else_instructions;

                                 ir_variable *const r097D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r097F = equal(r096C, body.constant(int(64)));
                                 ir_if *f097E = new(mem_ctx) ir_if(operand(r097F).val);
                                 exec_list *const f097E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f097E->then_instructions;

                                    body.emit(assign(r097D, r094E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f097E->else_instructions;

                                    ir_expression *const r0980 = nequal(r094E, body.constant(0u));
                                    ir_expression *const r0981 = expr(ir_unop_b2i, r0980);
                                    body.emit(assign(r097D, expr(ir_unop_i2u, r0981), 0x01));


                                 body.instructions = f097E_parent_instructions;
                                 body.emit(f097E);

                                 /* END IF */

                                 body.emit(assign(r096D, r097D, 0x01));

                                 body.emit(assign(r096E, body.constant(0u), 0x01));


                              body.instructions = f097A_parent_instructions;
                              body.emit(f097A);

                              /* END IF */


                           body.instructions = f0978_parent_instructions;
                           body.emit(f0978);

                           /* END IF */

                           body.emit(assign(r096F, body.constant(0u), 0x01));


                        body.instructions = f0974_parent_instructions;
                        body.emit(f0974);

                        /* END IF */

                        ir_expression *const r0982 = nequal(r096B, body.constant(0u));
                        ir_expression *const r0983 = expr(ir_unop_b2i, r0982);
                        ir_expression *const r0984 = expr(ir_unop_i2u, r0983);
                        body.emit(assign(r096D, bit_or(r096D, r0984), 0x01));


                     body.instructions = f0972_parent_instructions;
                     body.emit(f0972);

                     /* END IF */

                     body.emit(assign(r0955, r096F, 0x01));

                     body.emit(assign(r0956, r096E, 0x01));

                     body.emit(assign(r0957, r096D, 0x01));

                     body.emit(assign(r0954, body.constant(int(0)), 0x01));

                     body.emit(assign(r095A, less(r096D, body.constant(0u)), 0x01));


                  body.instructions = f0969_parent_instructions;
                  body.emit(f0969);

                  /* END IF */


               body.instructions = f0966_parent_instructions;
               body.emit(f0966);

               /* END IF */


            body.instructions = f095C_parent_instructions;
            body.emit(f095C);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0985 = new(mem_ctx) ir_if(operand(r0958).val);
            exec_list *const f0985_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0985->then_instructions;

               /* IF CONDITION */
               ir_if *f0986 = new(mem_ctx) ir_if(operand(r095A).val);
               exec_list *const f0986_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0986->then_instructions;

                  ir_variable *const r0987 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0987, add(r0956, body.constant(1u)), 0x01));

                  ir_expression *const r0988 = less(r0987, r0956);
                  ir_expression *const r0989 = expr(ir_unop_b2i, r0988);
                  ir_expression *const r098A = expr(ir_unop_i2u, r0989);
                  body.emit(assign(r0955, add(r0955, r098A), 0x01));

                  ir_expression *const r098B = equal(r0957, body.constant(0u));
                  ir_expression *const r098C = expr(ir_unop_b2i, r098B);
                  ir_expression *const r098D = expr(ir_unop_i2u, r098C);
                  ir_expression *const r098E = add(r0957, r098D);
                  ir_expression *const r098F = bit_and(r098E, body.constant(1u));
                  ir_expression *const r0990 = expr(ir_unop_bit_not, r098F);
                  body.emit(assign(r0956, bit_and(r0987, r0990), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0986->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0992 = bit_or(r0955, r0956);
                  ir_expression *const r0993 = equal(r0992, body.constant(0u));
                  ir_if *f0991 = new(mem_ctx) ir_if(operand(r0993).val);
                  exec_list *const f0991_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0991->then_instructions;

                     body.emit(assign(r0954, body.constant(int(0)), 0x01));


                  body.instructions = f0991_parent_instructions;
                  body.emit(f0991);

                  /* END IF */


               body.instructions = f0986_parent_instructions;
               body.emit(f0986);

               /* END IF */

               ir_variable *const r0994 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0994);
               ir_expression *const r0995 = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0996 = expr(ir_unop_i2u, r0954);
               ir_expression *const r0997 = lshift(r0996, body.constant(int(20)));
               ir_expression *const r0998 = add(r0995, r0997);
               body.emit(assign(r0994, add(r0998, r0955), 0x02));

               body.emit(assign(r0994, r0956, 0x01));

               body.emit(assign(r0959, r0994, 0x03));

               body.emit(assign(r0958, body.constant(false), 0x01));


            body.instructions = f0985_parent_instructions;
            body.emit(f0985);

            /* END IF */

            body.emit(assign(r07F1, r0959, 0x03));

            body.emit(assign(r07F0, body.constant(false), 0x01));


         body.instructions = f0905_parent_instructions;
         body.emit(f0905);

         /* END IF */


      body.instructions = f08FE_parent_instructions;
      body.emit(f08FE);

      /* END IF */

      body.emit(assign(r07EB, r07F1, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f07EE->else_instructions;

      ir_variable *const r0999 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r0999, r07EC, 0x01));

      ir_variable *const r099A = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r099B = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r099B);
      ir_variable *const r099C = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r099C);
      ir_variable *const r099D = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r099D);
      ir_variable *const r099E = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r099E);
      ir_variable *const r099F = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r099F);
      ir_variable *const r09A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r09A0);
      ir_variable *const r09A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r09A1);
      ir_variable *const r09A2 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r09A2);
      ir_variable *const r09A3 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r09A4 = rshift(swizzle_y(r07E9), body.constant(int(20)));
      ir_expression *const r09A5 = bit_and(r09A4, body.constant(2047u));
      body.emit(assign(r09A3, expr(ir_unop_u2i, r09A5), 0x01));

      body.emit(assign(r099D, r09A3, 0x01));

      ir_variable *const r09A6 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r09A7 = rshift(swizzle_y(r07EA), body.constant(int(20)));
      ir_expression *const r09A8 = bit_and(r09A7, body.constant(2047u));
      body.emit(assign(r09A6, expr(ir_unop_u2i, r09A8), 0x01));

      body.emit(assign(r099C, r09A6, 0x01));

      body.emit(assign(r099B, sub(r09A3, r09A6), 0x01));

      ir_variable *const r09A9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09A9, lshift(swizzle_x(r07E9), body.constant(int(10))), 0x01));

      ir_variable *const r09AA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09AB = bit_and(swizzle_y(r07E9), body.constant(1048575u));
      ir_expression *const r09AC = lshift(r09AB, body.constant(int(10)));
      ir_expression *const r09AD = rshift(swizzle_x(r07E9), body.constant(int(22)));
      body.emit(assign(r09AA, bit_or(r09AC, r09AD), 0x01));

      body.emit(assign(r09A0, r09AA, 0x01));

      body.emit(assign(r09A1, r09A9, 0x01));

      ir_variable *const r09AE = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09AE, lshift(swizzle_x(r07EA), body.constant(int(10))), 0x01));

      ir_variable *const r09AF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09B0 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
      ir_expression *const r09B1 = lshift(r09B0, body.constant(int(10)));
      ir_expression *const r09B2 = rshift(swizzle_x(r07EA), body.constant(int(22)));
      body.emit(assign(r09AF, bit_or(r09B1, r09B2), 0x01));

      body.emit(assign(r099E, r09AF, 0x01));

      body.emit(assign(r099F, r09AE, 0x01));

      /* IF CONDITION */
      ir_expression *const r09B4 = less(body.constant(int(0)), r099B);
      ir_if *f09B3 = new(mem_ctx) ir_if(operand(r09B4).val);
      exec_list *const f09B3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f09B3->then_instructions;

         /* IF CONDITION */
         ir_expression *const r09B6 = equal(r09A3, body.constant(int(2047)));
         ir_if *f09B5 = new(mem_ctx) ir_if(operand(r09B6).val);
         exec_list *const f09B5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f09B5->then_instructions;

            /* IF CONDITION */
            ir_expression *const r09B8 = bit_or(r09AA, r09A9);
            ir_expression *const r09B9 = nequal(r09B8, body.constant(0u));
            ir_if *f09B7 = new(mem_ctx) ir_if(operand(r09B9).val);
            exec_list *const f09B7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09B7->then_instructions;

               ir_variable *const r09BA = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r09BA, swizzle_x(r07E9), 0x01));

               ir_variable *const r09BB = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r09BB, swizzle_x(r07EA), 0x01));

               ir_variable *const r09BC = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r09BD = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r09BE = rshift(swizzle_y(r07E9), body.constant(int(19)));
               ir_expression *const r09BF = bit_and(r09BE, body.constant(4095u));
               ir_expression *const r09C0 = equal(r09BF, body.constant(4094u));
               ir_expression *const r09C1 = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r09C2 = bit_and(swizzle_y(r07E9), body.constant(524287u));
               ir_expression *const r09C3 = nequal(r09C2, body.constant(0u));
               ir_expression *const r09C4 = logic_or(r09C1, r09C3);
               body.emit(assign(r09BD, logic_and(r09C0, r09C4), 0x01));

               ir_variable *const r09C5 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r09C6 = lshift(swizzle_y(r07EA), body.constant(int(1)));
               ir_expression *const r09C7 = lequal(body.constant(4292870144u), r09C6);
               ir_expression *const r09C8 = nequal(swizzle_x(r07EA), body.constant(0u));
               ir_expression *const r09C9 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
               ir_expression *const r09CA = nequal(r09C9, body.constant(0u));
               ir_expression *const r09CB = logic_or(r09C8, r09CA);
               body.emit(assign(r09C5, logic_and(r09C7, r09CB), 0x01));

               body.emit(assign(r09BA, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

               body.emit(assign(r09BB, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r09CD = lshift(swizzle_y(r07E9), body.constant(int(1)));
               ir_expression *const r09CE = lequal(body.constant(4292870144u), r09CD);
               ir_expression *const r09CF = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r09D0 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
               ir_expression *const r09D1 = nequal(r09D0, body.constant(0u));
               ir_expression *const r09D2 = logic_or(r09CF, r09D1);
               ir_expression *const r09D3 = logic_and(r09CE, r09D2);
               ir_if *f09CC = new(mem_ctx) ir_if(operand(r09D3).val);
               exec_list *const f09CC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09CC->then_instructions;

                  ir_variable *const r09D4 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r09D6 = logic_and(r09BD, r09C5);
                  ir_if *f09D5 = new(mem_ctx) ir_if(operand(r09D6).val);
                  exec_list *const f09D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09D5->then_instructions;

                     body.emit(assign(r09D4, r09BB, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09D5->else_instructions;

                     body.emit(assign(r09D4, r09BA, 0x03));


                  body.instructions = f09D5_parent_instructions;
                  body.emit(f09D5);

                  /* END IF */

                  body.emit(assign(r09BC, r09D4, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09CC->else_instructions;

                  body.emit(assign(r09BC, r09BB, 0x03));


               body.instructions = f09CC_parent_instructions;
               body.emit(f09CC);

               /* END IF */

               body.emit(assign(r099A, r09BC, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09B7->else_instructions;

               body.emit(assign(r099A, r07E9, 0x03));


            body.instructions = f09B7_parent_instructions;
            body.emit(f09B7);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f09B5->else_instructions;

            /* IF CONDITION */
            ir_expression *const r09D8 = equal(r09A6, body.constant(int(0)));
            ir_if *f09D7 = new(mem_ctx) ir_if(operand(r09D8).val);
            exec_list *const f09D7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09D7->then_instructions;

               body.emit(assign(r099B, add(r099B, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09D7->else_instructions;

               body.emit(assign(r099E, bit_or(r09AF, body.constant(1073741824u)), 0x01));


            body.instructions = f09D7_parent_instructions;
            body.emit(f09D7);

            /* END IF */

            ir_variable *const r09D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r09D9);
            ir_variable *const r09DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r09DA);
            ir_variable *const r09DB = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r09DC = neg(r099B);
            body.emit(assign(r09DB, bit_and(r09DC, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r09DE = equal(r099B, body.constant(int(0)));
            ir_if *f09DD = new(mem_ctx) ir_if(operand(r09DE).val);
            exec_list *const f09DD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09DD->then_instructions;

               body.emit(assign(r09D9, r09AE, 0x01));

               body.emit(assign(r09DA, r099E, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09DD->else_instructions;

               /* IF CONDITION */
               ir_expression *const r09E0 = less(r099B, body.constant(int(32)));
               ir_if *f09DF = new(mem_ctx) ir_if(operand(r09E0).val);
               exec_list *const f09DF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09DF->then_instructions;

                  ir_expression *const r09E1 = lshift(r099E, r09DB);
                  ir_expression *const r09E2 = rshift(r09AE, r099B);
                  ir_expression *const r09E3 = bit_or(r09E1, r09E2);
                  ir_expression *const r09E4 = lshift(r09AE, r09DB);
                  ir_expression *const r09E5 = nequal(r09E4, body.constant(0u));
                  ir_expression *const r09E6 = expr(ir_unop_b2i, r09E5);
                  ir_expression *const r09E7 = expr(ir_unop_i2u, r09E6);
                  body.emit(assign(r09D9, bit_or(r09E3, r09E7), 0x01));

                  body.emit(assign(r09DA, rshift(r099E, r099B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09DF->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r09E9 = equal(r099B, body.constant(int(32)));
                  ir_if *f09E8 = new(mem_ctx) ir_if(operand(r09E9).val);
                  exec_list *const f09E8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09E8->then_instructions;

                     ir_expression *const r09EA = nequal(r09AE, body.constant(0u));
                     ir_expression *const r09EB = expr(ir_unop_b2i, r09EA);
                     ir_expression *const r09EC = expr(ir_unop_i2u, r09EB);
                     body.emit(assign(r09D9, bit_or(r099E, r09EC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09E8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r09EE = less(r099B, body.constant(int(64)));
                     ir_if *f09ED = new(mem_ctx) ir_if(operand(r09EE).val);
                     exec_list *const f09ED_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f09ED->then_instructions;

                        ir_expression *const r09EF = bit_and(r099B, body.constant(int(31)));
                        ir_expression *const r09F0 = rshift(r099E, r09EF);
                        ir_expression *const r09F1 = lshift(r099E, r09DB);
                        ir_expression *const r09F2 = bit_or(r09F1, r09AE);
                        ir_expression *const r09F3 = nequal(r09F2, body.constant(0u));
                        ir_expression *const r09F4 = expr(ir_unop_b2i, r09F3);
                        ir_expression *const r09F5 = expr(ir_unop_i2u, r09F4);
                        body.emit(assign(r09D9, bit_or(r09F0, r09F5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f09ED->else_instructions;

                        ir_expression *const r09F6 = bit_or(r099E, r09AE);
                        ir_expression *const r09F7 = nequal(r09F6, body.constant(0u));
                        ir_expression *const r09F8 = expr(ir_unop_b2i, r09F7);
                        body.emit(assign(r09D9, expr(ir_unop_i2u, r09F8), 0x01));


                     body.instructions = f09ED_parent_instructions;
                     body.emit(f09ED);

                     /* END IF */


                  body.instructions = f09E8_parent_instructions;
                  body.emit(f09E8);

                  /* END IF */

                  body.emit(assign(r09DA, body.constant(0u), 0x01));


               body.instructions = f09DF_parent_instructions;
               body.emit(f09DF);

               /* END IF */


            body.instructions = f09DD_parent_instructions;
            body.emit(f09DD);

            /* END IF */

            body.emit(assign(r099E, r09DA, 0x01));

            body.emit(assign(r099F, r09D9, 0x01));

            body.emit(assign(r09A0, bit_or(r09AA, body.constant(1073741824u)), 0x01));

            ir_variable *const r09F9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r09FA = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r09FA, sub(r09A9, r09D9), 0x01));

            ir_expression *const r09FB = sub(r09A0, r09DA);
            ir_expression *const r09FC = less(r09A9, r09D9);
            ir_expression *const r09FD = expr(ir_unop_b2i, r09FC);
            ir_expression *const r09FE = expr(ir_unop_i2u, r09FD);
            body.emit(assign(r09F9, sub(r09FB, r09FE), 0x01));

            body.emit(assign(r09A2, add(r09A3, body.constant(int(-1))), 0x01));

            ir_variable *const r09FF = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r09FF, add(r09A2, body.constant(int(-10))), 0x01));

            ir_variable *const r0A00 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0A00, r09F9, 0x01));

            ir_variable *const r0A01 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0A01, r09FA, 0x01));

            ir_variable *const r0A02 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0A02);
            ir_variable *const r0A03 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0A03);
            /* IF CONDITION */
            ir_expression *const r0A05 = equal(r09F9, body.constant(0u));
            ir_if *f0A04 = new(mem_ctx) ir_if(operand(r0A05).val);
            exec_list *const f0A04_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A04->then_instructions;

               body.emit(assign(r0A00, r09FA, 0x01));

               body.emit(assign(r0A01, body.constant(0u), 0x01));

               body.emit(assign(r09FF, add(r09FF, body.constant(int(-32))), 0x01));


            body.instructions = f0A04_parent_instructions;
            body.emit(f0A04);

            /* END IF */

            ir_variable *const r0A06 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0A06, r0A00, 0x01));

            ir_variable *const r0A07 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0A08 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0A08);
            /* IF CONDITION */
            ir_expression *const r0A0A = equal(r0A00, body.constant(0u));
            ir_if *f0A09 = new(mem_ctx) ir_if(operand(r0A0A).val);
            exec_list *const f0A09_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A09->then_instructions;

               body.emit(assign(r0A07, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A09->else_instructions;

               body.emit(assign(r0A08, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A0C = bit_and(r0A00, body.constant(4294901760u));
               ir_expression *const r0A0D = equal(r0A0C, body.constant(0u));
               ir_if *f0A0B = new(mem_ctx) ir_if(operand(r0A0D).val);
               exec_list *const f0A0B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0B->then_instructions;

                  body.emit(assign(r0A08, body.constant(int(16)), 0x01));

                  body.emit(assign(r0A06, lshift(r0A00, body.constant(int(16))), 0x01));


               body.instructions = f0A0B_parent_instructions;
               body.emit(f0A0B);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A0F = bit_and(r0A06, body.constant(4278190080u));
               ir_expression *const r0A10 = equal(r0A0F, body.constant(0u));
               ir_if *f0A0E = new(mem_ctx) ir_if(operand(r0A10).val);
               exec_list *const f0A0E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0E->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(8))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(8))), 0x01));


               body.instructions = f0A0E_parent_instructions;
               body.emit(f0A0E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A12 = bit_and(r0A06, body.constant(4026531840u));
               ir_expression *const r0A13 = equal(r0A12, body.constant(0u));
               ir_if *f0A11 = new(mem_ctx) ir_if(operand(r0A13).val);
               exec_list *const f0A11_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A11->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(4))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(4))), 0x01));


               body.instructions = f0A11_parent_instructions;
               body.emit(f0A11);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A15 = bit_and(r0A06, body.constant(3221225472u));
               ir_expression *const r0A16 = equal(r0A15, body.constant(0u));
               ir_if *f0A14 = new(mem_ctx) ir_if(operand(r0A16).val);
               exec_list *const f0A14_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A14->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(2))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(2))), 0x01));


               body.instructions = f0A14_parent_instructions;
               body.emit(f0A14);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A18 = bit_and(r0A06, body.constant(2147483648u));
               ir_expression *const r0A19 = equal(r0A18, body.constant(0u));
               ir_if *f0A17 = new(mem_ctx) ir_if(operand(r0A19).val);
               exec_list *const f0A17_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A17->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(1))), 0x01));


               body.instructions = f0A17_parent_instructions;
               body.emit(f0A17);

               /* END IF */

               body.emit(assign(r0A07, r0A08, 0x01));


            body.instructions = f0A09_parent_instructions;
            body.emit(f0A09);

            /* END IF */

            body.emit(assign(r0A03, add(r0A07, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A1B = lequal(body.constant(int(0)), r0A03);
            ir_if *f0A1A = new(mem_ctx) ir_if(operand(r0A1B).val);
            exec_list *const f0A1A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A1A->then_instructions;

               body.emit(assign(r0A02, body.constant(0u), 0x01));

               ir_variable *const r0A1C = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0A1C, lshift(r0A01, r0A03), 0x01));

               ir_variable *const r0A1D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0A1F = equal(r0A03, body.constant(int(0)));
               ir_if *f0A1E = new(mem_ctx) ir_if(operand(r0A1F).val);
               exec_list *const f0A1E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A1E->then_instructions;

                  body.emit(assign(r0A1D, r0A00, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A1E->else_instructions;

                  ir_expression *const r0A20 = lshift(r0A00, r0A03);
                  ir_expression *const r0A21 = neg(r0A03);
                  ir_expression *const r0A22 = bit_and(r0A21, body.constant(int(31)));
                  ir_expression *const r0A23 = rshift(r0A01, r0A22);
                  body.emit(assign(r0A1D, bit_or(r0A20, r0A23), 0x01));


               body.instructions = f0A1E_parent_instructions;
               body.emit(f0A1E);

               /* END IF */

               body.emit(assign(r0A00, r0A1D, 0x01));

               body.emit(assign(r0A01, r0A1C, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A1A->else_instructions;

               ir_variable *const r0A24 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0A24, body.constant(0u), 0x01));

               ir_variable *const r0A25 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0A25, neg(r0A03), 0x01));

               ir_variable *const r0A26 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0A26);
               ir_variable *const r0A27 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0A27);
               ir_variable *const r0A28 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0A28);
               ir_variable *const r0A29 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0A2A = neg(r0A25);
               body.emit(assign(r0A29, bit_and(r0A2A, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A2C = equal(r0A25, body.constant(int(0)));
               ir_if *f0A2B = new(mem_ctx) ir_if(operand(r0A2C).val);
               exec_list *const f0A2B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A2B->then_instructions;

                  body.emit(assign(r0A26, r0A24, 0x01));

                  body.emit(assign(r0A27, r0A01, 0x01));

                  body.emit(assign(r0A28, r0A00, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A2B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A2E = less(r0A25, body.constant(int(32)));
                  ir_if *f0A2D = new(mem_ctx) ir_if(operand(r0A2E).val);
                  exec_list *const f0A2D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A2D->then_instructions;

                     body.emit(assign(r0A26, lshift(r0A01, r0A29), 0x01));

                     ir_expression *const r0A2F = lshift(r0A00, r0A29);
                     ir_expression *const r0A30 = rshift(r0A01, r0A25);
                     body.emit(assign(r0A27, bit_or(r0A2F, r0A30), 0x01));

                     body.emit(assign(r0A28, rshift(r0A00, r0A25), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A2D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0A32 = equal(r0A25, body.constant(int(32)));
                     ir_if *f0A31 = new(mem_ctx) ir_if(operand(r0A32).val);
                     exec_list *const f0A31_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A31->then_instructions;

                        body.emit(assign(r0A26, r0A01, 0x01));

                        body.emit(assign(r0A27, r0A00, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A31->else_instructions;

                        body.emit(assign(r0A24, bit_or(body.constant(0u), r0A01), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0A34 = less(r0A25, body.constant(int(64)));
                        ir_if *f0A33 = new(mem_ctx) ir_if(operand(r0A34).val);
                        exec_list *const f0A33_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A33->then_instructions;

                           body.emit(assign(r0A26, lshift(r0A00, r0A29), 0x01));

                           ir_expression *const r0A35 = bit_and(r0A25, body.constant(int(31)));
                           body.emit(assign(r0A27, rshift(r0A00, r0A35), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A33->else_instructions;

                           ir_variable *const r0A36 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0A38 = equal(r0A25, body.constant(int(64)));
                           ir_if *f0A37 = new(mem_ctx) ir_if(operand(r0A38).val);
                           exec_list *const f0A37_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A37->then_instructions;

                              body.emit(assign(r0A36, r0A00, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A37->else_instructions;

                              ir_expression *const r0A39 = nequal(r0A00, body.constant(0u));
                              ir_expression *const r0A3A = expr(ir_unop_b2i, r0A39);
                              body.emit(assign(r0A36, expr(ir_unop_i2u, r0A3A), 0x01));


                           body.instructions = f0A37_parent_instructions;
                           body.emit(f0A37);

                           /* END IF */

                           body.emit(assign(r0A26, r0A36, 0x01));

                           body.emit(assign(r0A27, body.constant(0u), 0x01));


                        body.instructions = f0A33_parent_instructions;
                        body.emit(f0A33);

                        /* END IF */


                     body.instructions = f0A31_parent_instructions;
                     body.emit(f0A31);

                     /* END IF */

                     body.emit(assign(r0A28, body.constant(0u), 0x01));


                  body.instructions = f0A2D_parent_instructions;
                  body.emit(f0A2D);

                  /* END IF */

                  ir_expression *const r0A3B = nequal(r0A24, body.constant(0u));
                  ir_expression *const r0A3C = expr(ir_unop_b2i, r0A3B);
                  ir_expression *const r0A3D = expr(ir_unop_i2u, r0A3C);
                  body.emit(assign(r0A26, bit_or(r0A26, r0A3D), 0x01));


               body.instructions = f0A2B_parent_instructions;
               body.emit(f0A2B);

               /* END IF */

               body.emit(assign(r0A00, r0A28, 0x01));

               body.emit(assign(r0A01, r0A27, 0x01));

               body.emit(assign(r0A02, r0A26, 0x01));


            body.instructions = f0A1A_parent_instructions;
            body.emit(f0A1A);

            /* END IF */

            body.emit(assign(r09FF, sub(r09FF, r0A03), 0x01));

            ir_variable *const r0A3E = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0A3E, r09FF, 0x01));

            ir_variable *const r0A3F = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0A3F, r0A00, 0x01));

            ir_variable *const r0A40 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0A40, r0A01, 0x01));

            ir_variable *const r0A41 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0A41, r0A02, 0x01));

            ir_variable *const r0A42 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0A42, body.constant(true), 0x01));

            ir_variable *const r0A43 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0A44 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0A44);
            ir_expression *const r0A45 = expr(ir_unop_u2i, r0A02);
            body.emit(assign(r0A44, less(r0A45, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A47 = lequal(body.constant(int(2045)), r09FF);
            ir_if *f0A46 = new(mem_ctx) ir_if(operand(r0A47).val);
            exec_list *const f0A46_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A46->then_instructions;

               ir_variable *const r0A48 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0A4A = less(body.constant(int(2045)), r09FF);
               ir_if *f0A49 = new(mem_ctx) ir_if(operand(r0A4A).val);
               exec_list *const f0A49_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A49->then_instructions;

                  body.emit(assign(r0A48, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A49->else_instructions;

                  ir_variable *const r0A4B = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0A4D = equal(r09FF, body.constant(int(2045)));
                  ir_if *f0A4C = new(mem_ctx) ir_if(operand(r0A4D).val);
                  exec_list *const f0A4C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A4C->then_instructions;

                     ir_expression *const r0A4E = equal(body.constant(2097151u), r0A00);
                     ir_expression *const r0A4F = equal(body.constant(4294967295u), r0A01);
                     body.emit(assign(r0A4B, logic_and(r0A4E, r0A4F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A4C->else_instructions;

                     body.emit(assign(r0A4B, body.constant(false), 0x01));


                  body.instructions = f0A4C_parent_instructions;
                  body.emit(f0A4C);

                  /* END IF */

                  body.emit(assign(r0A48, logic_and(r0A4B, r0A44), 0x01));


               body.instructions = f0A49_parent_instructions;
               body.emit(f0A49);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0A50 = new(mem_ctx) ir_if(operand(r0A48).val);
               exec_list *const f0A50_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A50->then_instructions;

                  ir_variable *const r0A51 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0A51);
                  ir_expression *const r0A52 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0A51, add(r0A52, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0A51, body.constant(0u), 0x01));

                  body.emit(assign(r0A43, r0A51, 0x03));

                  body.emit(assign(r0A42, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A50->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A54 = less(r09FF, body.constant(int(0)));
                  ir_if *f0A53 = new(mem_ctx) ir_if(operand(r0A54).val);
                  exec_list *const f0A53_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A53->then_instructions;

                     ir_variable *const r0A55 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0A55, r0A02, 0x01));

                     ir_variable *const r0A56 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0A56, neg(r09FF), 0x01));

                     ir_variable *const r0A57 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0A57);
                     ir_variable *const r0A58 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0A58);
                     ir_variable *const r0A59 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0A59);
                     ir_variable *const r0A5A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0A5B = neg(r0A56);
                     body.emit(assign(r0A5A, bit_and(r0A5B, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0A5D = equal(r0A56, body.constant(int(0)));
                     ir_if *f0A5C = new(mem_ctx) ir_if(operand(r0A5D).val);
                     exec_list *const f0A5C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A5C->then_instructions;

                        body.emit(assign(r0A57, r0A02, 0x01));

                        body.emit(assign(r0A58, r0A01, 0x01));

                        body.emit(assign(r0A59, r0A00, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A5C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0A5F = less(r0A56, body.constant(int(32)));
                        ir_if *f0A5E = new(mem_ctx) ir_if(operand(r0A5F).val);
                        exec_list *const f0A5E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A5E->then_instructions;

                           body.emit(assign(r0A57, lshift(r0A01, r0A5A), 0x01));

                           ir_expression *const r0A60 = lshift(r0A00, r0A5A);
                           ir_expression *const r0A61 = rshift(r0A01, r0A56);
                           body.emit(assign(r0A58, bit_or(r0A60, r0A61), 0x01));

                           body.emit(assign(r0A59, rshift(r0A00, r0A56), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A5E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0A63 = equal(r0A56, body.constant(int(32)));
                           ir_if *f0A62 = new(mem_ctx) ir_if(operand(r0A63).val);
                           exec_list *const f0A62_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A62->then_instructions;

                              body.emit(assign(r0A57, r0A01, 0x01));

                              body.emit(assign(r0A58, r0A00, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A62->else_instructions;

                              body.emit(assign(r0A55, bit_or(r0A02, r0A01), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0A65 = less(r0A56, body.constant(int(64)));
                              ir_if *f0A64 = new(mem_ctx) ir_if(operand(r0A65).val);
                              exec_list *const f0A64_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0A64->then_instructions;

                                 body.emit(assign(r0A57, lshift(r0A00, r0A5A), 0x01));

                                 ir_expression *const r0A66 = bit_and(r0A56, body.constant(int(31)));
                                 body.emit(assign(r0A58, rshift(r0A00, r0A66), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0A64->else_instructions;

                                 ir_variable *const r0A67 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0A69 = equal(r0A56, body.constant(int(64)));
                                 ir_if *f0A68 = new(mem_ctx) ir_if(operand(r0A69).val);
                                 exec_list *const f0A68_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0A68->then_instructions;

                                    body.emit(assign(r0A67, r0A00, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0A68->else_instructions;

                                    ir_expression *const r0A6A = nequal(r0A00, body.constant(0u));
                                    ir_expression *const r0A6B = expr(ir_unop_b2i, r0A6A);
                                    body.emit(assign(r0A67, expr(ir_unop_i2u, r0A6B), 0x01));


                                 body.instructions = f0A68_parent_instructions;
                                 body.emit(f0A68);

                                 /* END IF */

                                 body.emit(assign(r0A57, r0A67, 0x01));

                                 body.emit(assign(r0A58, body.constant(0u), 0x01));


                              body.instructions = f0A64_parent_instructions;
                              body.emit(f0A64);

                              /* END IF */


                           body.instructions = f0A62_parent_instructions;
                           body.emit(f0A62);

                           /* END IF */

                           body.emit(assign(r0A59, body.constant(0u), 0x01));


                        body.instructions = f0A5E_parent_instructions;
                        body.emit(f0A5E);

                        /* END IF */

                        ir_expression *const r0A6C = nequal(r0A55, body.constant(0u));
                        ir_expression *const r0A6D = expr(ir_unop_b2i, r0A6C);
                        ir_expression *const r0A6E = expr(ir_unop_i2u, r0A6D);
                        body.emit(assign(r0A57, bit_or(r0A57, r0A6E), 0x01));


                     body.instructions = f0A5C_parent_instructions;
                     body.emit(f0A5C);

                     /* END IF */

                     body.emit(assign(r0A3F, r0A59, 0x01));

                     body.emit(assign(r0A40, r0A58, 0x01));

                     body.emit(assign(r0A41, r0A57, 0x01));

                     body.emit(assign(r0A3E, body.constant(int(0)), 0x01));

                     body.emit(assign(r0A44, less(r0A57, body.constant(0u)), 0x01));


                  body.instructions = f0A53_parent_instructions;
                  body.emit(f0A53);

                  /* END IF */


               body.instructions = f0A50_parent_instructions;
               body.emit(f0A50);

               /* END IF */


            body.instructions = f0A46_parent_instructions;
            body.emit(f0A46);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0A6F = new(mem_ctx) ir_if(operand(r0A42).val);
            exec_list *const f0A6F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A6F->then_instructions;

               /* IF CONDITION */
               ir_if *f0A70 = new(mem_ctx) ir_if(operand(r0A44).val);
               exec_list *const f0A70_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A70->then_instructions;

                  ir_variable *const r0A71 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0A71, add(r0A40, body.constant(1u)), 0x01));

                  ir_expression *const r0A72 = less(r0A71, r0A40);
                  ir_expression *const r0A73 = expr(ir_unop_b2i, r0A72);
                  ir_expression *const r0A74 = expr(ir_unop_i2u, r0A73);
                  body.emit(assign(r0A3F, add(r0A3F, r0A74), 0x01));

                  ir_expression *const r0A75 = equal(r0A41, body.constant(0u));
                  ir_expression *const r0A76 = expr(ir_unop_b2i, r0A75);
                  ir_expression *const r0A77 = expr(ir_unop_i2u, r0A76);
                  ir_expression *const r0A78 = add(r0A41, r0A77);
                  ir_expression *const r0A79 = bit_and(r0A78, body.constant(1u));
                  ir_expression *const r0A7A = expr(ir_unop_bit_not, r0A79);
                  body.emit(assign(r0A40, bit_and(r0A71, r0A7A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A70->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A7C = bit_or(r0A3F, r0A40);
                  ir_expression *const r0A7D = equal(r0A7C, body.constant(0u));
                  ir_if *f0A7B = new(mem_ctx) ir_if(operand(r0A7D).val);
                  exec_list *const f0A7B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A7B->then_instructions;

                     body.emit(assign(r0A3E, body.constant(int(0)), 0x01));


                  body.instructions = f0A7B_parent_instructions;
                  body.emit(f0A7B);

                  /* END IF */


               body.instructions = f0A70_parent_instructions;
               body.emit(f0A70);

               /* END IF */

               ir_variable *const r0A7E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0A7E);
               ir_expression *const r0A7F = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0A80 = expr(ir_unop_i2u, r0A3E);
               ir_expression *const r0A81 = lshift(r0A80, body.constant(int(20)));
               ir_expression *const r0A82 = add(r0A7F, r0A81);
               body.emit(assign(r0A7E, add(r0A82, r0A3F), 0x02));

               body.emit(assign(r0A7E, r0A40, 0x01));

               body.emit(assign(r0A43, r0A7E, 0x03));

               body.emit(assign(r0A42, body.constant(false), 0x01));


            body.instructions = f0A6F_parent_instructions;
            body.emit(f0A6F);

            /* END IF */

            body.emit(assign(r099A, r0A43, 0x03));


         body.instructions = f09B5_parent_instructions;
         body.emit(f09B5);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f09B3->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0A84 = less(r099B, body.constant(int(0)));
         ir_if *f0A83 = new(mem_ctx) ir_if(operand(r0A84).val);
         exec_list *const f0A83_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0A83->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0A86 = equal(r09A6, body.constant(int(2047)));
            ir_if *f0A85 = new(mem_ctx) ir_if(operand(r0A86).val);
            exec_list *const f0A85_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A85->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0A88 = bit_or(r099E, r099F);
               ir_expression *const r0A89 = nequal(r0A88, body.constant(0u));
               ir_if *f0A87 = new(mem_ctx) ir_if(operand(r0A89).val);
               exec_list *const f0A87_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A87->then_instructions;

                  ir_variable *const r0A8A = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0A8A, swizzle_x(r07E9), 0x01));

                  ir_variable *const r0A8B = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0A8B, swizzle_x(r07EA), 0x01));

                  ir_variable *const r0A8C = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0A8D = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0A8E = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0A8F = bit_and(r0A8E, body.constant(4095u));
                  ir_expression *const r0A90 = equal(r0A8F, body.constant(4094u));
                  ir_expression *const r0A91 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0A92 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0A93 = nequal(r0A92, body.constant(0u));
                  ir_expression *const r0A94 = logic_or(r0A91, r0A93);
                  body.emit(assign(r0A8D, logic_and(r0A90, r0A94), 0x01));

                  ir_variable *const r0A95 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0A96 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0A97 = lequal(body.constant(4292870144u), r0A96);
                  ir_expression *const r0A98 = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0A99 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0A9A = nequal(r0A99, body.constant(0u));
                  ir_expression *const r0A9B = logic_or(r0A98, r0A9A);
                  body.emit(assign(r0A95, logic_and(r0A97, r0A9B), 0x01));

                  body.emit(assign(r0A8A, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r0A8B, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0A9D = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r0A9E = lequal(body.constant(4292870144u), r0A9D);
                  ir_expression *const r0A9F = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0AA0 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0AA1 = nequal(r0AA0, body.constant(0u));
                  ir_expression *const r0AA2 = logic_or(r0A9F, r0AA1);
                  ir_expression *const r0AA3 = logic_and(r0A9E, r0AA2);
                  ir_if *f0A9C = new(mem_ctx) ir_if(operand(r0AA3).val);
                  exec_list *const f0A9C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A9C->then_instructions;

                     ir_variable *const r0AA4 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0AA6 = logic_and(r0A8D, r0A95);
                     ir_if *f0AA5 = new(mem_ctx) ir_if(operand(r0AA6).val);
                     exec_list *const f0AA5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0AA5->then_instructions;

                        body.emit(assign(r0AA4, r0A8B, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0AA5->else_instructions;

                        body.emit(assign(r0AA4, r0A8A, 0x03));


                     body.instructions = f0AA5_parent_instructions;
                     body.emit(f0AA5);

                     /* END IF */

                     body.emit(assign(r0A8C, r0AA4, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A9C->else_instructions;

                     body.emit(assign(r0A8C, r0A8B, 0x03));


                  body.instructions = f0A9C_parent_instructions;
                  body.emit(f0A9C);

                  /* END IF */

                  body.emit(assign(r099A, r0A8C, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A87->else_instructions;

                  ir_variable *const r0AA7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0AA7);
                  ir_expression *const r0AA8 = bit_xor(r07EC, body.constant(1u));
                  ir_expression *const r0AA9 = lshift(r0AA8, body.constant(int(31)));
                  body.emit(assign(r0AA7, add(r0AA9, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0AA7, body.constant(0u), 0x01));

                  body.emit(assign(r099A, r0AA7, 0x03));


               body.instructions = f0A87_parent_instructions;
               body.emit(f0A87);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A85->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0AAB = equal(r09A3, body.constant(int(0)));
               ir_if *f0AAA = new(mem_ctx) ir_if(operand(r0AAB).val);
               exec_list *const f0AAA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AAA->then_instructions;

                  body.emit(assign(r099B, add(r099B, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AAA->else_instructions;

                  body.emit(assign(r09A0, bit_or(r09A0, body.constant(1073741824u)), 0x01));


               body.instructions = f0AAA_parent_instructions;
               body.emit(f0AAA);

               /* END IF */

               ir_variable *const r0AAC = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0AAC, neg(r099B), 0x01));

               ir_variable *const r0AAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0AAD);
               ir_variable *const r0AAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0AAE);
               ir_variable *const r0AAF = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0AB0 = neg(r0AAC);
               body.emit(assign(r0AAF, bit_and(r0AB0, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AB2 = equal(r0AAC, body.constant(int(0)));
               ir_if *f0AB1 = new(mem_ctx) ir_if(operand(r0AB2).val);
               exec_list *const f0AB1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AB1->then_instructions;

                  body.emit(assign(r0AAD, r09A9, 0x01));

                  body.emit(assign(r0AAE, r09A0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AB1->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0AB4 = less(r0AAC, body.constant(int(32)));
                  ir_if *f0AB3 = new(mem_ctx) ir_if(operand(r0AB4).val);
                  exec_list *const f0AB3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AB3->then_instructions;

                     ir_expression *const r0AB5 = lshift(r09A0, r0AAF);
                     ir_expression *const r0AB6 = rshift(r09A9, r0AAC);
                     ir_expression *const r0AB7 = bit_or(r0AB5, r0AB6);
                     ir_expression *const r0AB8 = lshift(r09A9, r0AAF);
                     ir_expression *const r0AB9 = nequal(r0AB8, body.constant(0u));
                     ir_expression *const r0ABA = expr(ir_unop_b2i, r0AB9);
                     ir_expression *const r0ABB = expr(ir_unop_i2u, r0ABA);
                     body.emit(assign(r0AAD, bit_or(r0AB7, r0ABB), 0x01));

                     body.emit(assign(r0AAE, rshift(r09A0, r0AAC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AB3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0ABD = equal(r0AAC, body.constant(int(32)));
                     ir_if *f0ABC = new(mem_ctx) ir_if(operand(r0ABD).val);
                     exec_list *const f0ABC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0ABC->then_instructions;

                        ir_expression *const r0ABE = nequal(r09A9, body.constant(0u));
                        ir_expression *const r0ABF = expr(ir_unop_b2i, r0ABE);
                        ir_expression *const r0AC0 = expr(ir_unop_i2u, r0ABF);
                        body.emit(assign(r0AAD, bit_or(r09A0, r0AC0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0ABC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0AC2 = less(r0AAC, body.constant(int(64)));
                        ir_if *f0AC1 = new(mem_ctx) ir_if(operand(r0AC2).val);
                        exec_list *const f0AC1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0AC1->then_instructions;

                           ir_expression *const r0AC3 = bit_and(r0AAC, body.constant(int(31)));
                           ir_expression *const r0AC4 = rshift(r09A0, r0AC3);
                           ir_expression *const r0AC5 = lshift(r09A0, r0AAF);
                           ir_expression *const r0AC6 = bit_or(r0AC5, r09A9);
                           ir_expression *const r0AC7 = nequal(r0AC6, body.constant(0u));
                           ir_expression *const r0AC8 = expr(ir_unop_b2i, r0AC7);
                           ir_expression *const r0AC9 = expr(ir_unop_i2u, r0AC8);
                           body.emit(assign(r0AAD, bit_or(r0AC4, r0AC9), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0AC1->else_instructions;

                           ir_expression *const r0ACA = bit_or(r09A0, r09A9);
                           ir_expression *const r0ACB = nequal(r0ACA, body.constant(0u));
                           ir_expression *const r0ACC = expr(ir_unop_b2i, r0ACB);
                           body.emit(assign(r0AAD, expr(ir_unop_i2u, r0ACC), 0x01));


                        body.instructions = f0AC1_parent_instructions;
                        body.emit(f0AC1);

                        /* END IF */


                     body.instructions = f0ABC_parent_instructions;
                     body.emit(f0ABC);

                     /* END IF */

                     body.emit(assign(r0AAE, body.constant(0u), 0x01));


                  body.instructions = f0AB3_parent_instructions;
                  body.emit(f0AB3);

                  /* END IF */


               body.instructions = f0AB1_parent_instructions;
               body.emit(f0AB1);

               /* END IF */

               body.emit(assign(r09A0, r0AAE, 0x01));

               body.emit(assign(r09A1, r0AAD, 0x01));

               body.emit(assign(r099E, bit_or(r099E, body.constant(1073741824u)), 0x01));

               ir_variable *const r0ACD = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0ACE = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0ACE, sub(r099F, r0AAD), 0x01));

               ir_expression *const r0ACF = sub(r099E, r0AAE);
               ir_expression *const r0AD0 = less(r099F, r0AAD);
               ir_expression *const r0AD1 = expr(ir_unop_b2i, r0AD0);
               ir_expression *const r0AD2 = expr(ir_unop_i2u, r0AD1);
               body.emit(assign(r0ACD, sub(r0ACF, r0AD2), 0x01));

               body.emit(assign(r0999, bit_xor(r07EC, body.constant(1u)), 0x01));

               body.emit(assign(r09A2, add(r09A6, body.constant(int(-1))), 0x01));

               ir_variable *const r0AD3 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0AD3, add(r09A2, body.constant(int(-10))), 0x01));

               ir_variable *const r0AD4 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0AD4, r0ACD, 0x01));

               ir_variable *const r0AD5 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0AD5, r0ACE, 0x01));

               ir_variable *const r0AD6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r0AD6);
               ir_variable *const r0AD7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0AD7);
               /* IF CONDITION */
               ir_expression *const r0AD9 = equal(r0ACD, body.constant(0u));
               ir_if *f0AD8 = new(mem_ctx) ir_if(operand(r0AD9).val);
               exec_list *const f0AD8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AD8->then_instructions;

                  body.emit(assign(r0AD4, r0ACE, 0x01));

                  body.emit(assign(r0AD5, body.constant(0u), 0x01));

                  body.emit(assign(r0AD3, add(r0AD3, body.constant(int(-32))), 0x01));


               body.instructions = f0AD8_parent_instructions;
               body.emit(f0AD8);

               /* END IF */

               ir_variable *const r0ADA = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r0ADA, r0AD4, 0x01));

               ir_variable *const r0ADB = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r0ADC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0ADC);
               /* IF CONDITION */
               ir_expression *const r0ADE = equal(r0AD4, body.constant(0u));
               ir_if *f0ADD = new(mem_ctx) ir_if(operand(r0ADE).val);
               exec_list *const f0ADD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ADD->then_instructions;

                  body.emit(assign(r0ADB, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0ADD->else_instructions;

                  body.emit(assign(r0ADC, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0AE0 = bit_and(r0AD4, body.constant(4294901760u));
                  ir_expression *const r0AE1 = equal(r0AE0, body.constant(0u));
                  ir_if *f0ADF = new(mem_ctx) ir_if(operand(r0AE1).val);
                  exec_list *const f0ADF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0ADF->then_instructions;

                     body.emit(assign(r0ADC, body.constant(int(16)), 0x01));

                     body.emit(assign(r0ADA, lshift(r0AD4, body.constant(int(16))), 0x01));


                  body.instructions = f0ADF_parent_instructions;
                  body.emit(f0ADF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE3 = bit_and(r0ADA, body.constant(4278190080u));
                  ir_expression *const r0AE4 = equal(r0AE3, body.constant(0u));
                  ir_if *f0AE2 = new(mem_ctx) ir_if(operand(r0AE4).val);
                  exec_list *const f0AE2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE2->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(8))), 0x01));

                     body.emit(assign(r0ADA, lshift(r0ADA, body.constant(int(8))), 0x01));


                  body.instructions = f0AE2_parent_instructions;
                  body.emit(f0AE2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE6 = bit_and(r0ADA, body.constant(4026531840u));
                  ir_expression *const r0AE7 = equal(r0AE6, body.constant(0u));
                  ir_if *f0AE5 = new(mem_ctx) ir_if(operand(r0AE7).val);
                  exec_list *const f0AE5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE5->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(4))), 0x01));

                     body.emit(assign(r0ADA, lshift(r0ADA, body.constant(int(4))), 0x01));


                  body.instructions = f0AE5_parent_instructions;
                  body.emit(f0AE5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE9 = bit_and(r0ADA, body.constant(3221225472u));
                  ir_expression *const r0AEA = equal(r0AE9, body.constant(0u));
                  ir_if *f0AE8 = new(mem_ctx) ir_if(operand(r0AEA).val);
                  exec_list *const f0AE8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE8->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(2))), 0x01));

                     body.emit(assign(r0ADA, lshift(r0ADA, body.constant(int(2))), 0x01));


                  body.instructions = f0AE8_parent_instructions;
                  body.emit(f0AE8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AEC = bit_and(r0ADA, body.constant(2147483648u));
                  ir_expression *const r0AED = equal(r0AEC, body.constant(0u));
                  ir_if *f0AEB = new(mem_ctx) ir_if(operand(r0AED).val);
                  exec_list *const f0AEB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AEB->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(1))), 0x01));


                  body.instructions = f0AEB_parent_instructions;
                  body.emit(f0AEB);

                  /* END IF */

                  body.emit(assign(r0ADB, r0ADC, 0x01));


               body.instructions = f0ADD_parent_instructions;
               body.emit(f0ADD);

               /* END IF */

               body.emit(assign(r0AD7, add(r0ADB, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AEF = lequal(body.constant(int(0)), r0AD7);
               ir_if *f0AEE = new(mem_ctx) ir_if(operand(r0AEF).val);
               exec_list *const f0AEE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AEE->then_instructions;

                  body.emit(assign(r0AD6, body.constant(0u), 0x01));

                  ir_variable *const r0AF0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0AF0, lshift(r0AD5, r0AD7), 0x01));

                  ir_variable *const r0AF1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0AF3 = equal(r0AD7, body.constant(int(0)));
                  ir_if *f0AF2 = new(mem_ctx) ir_if(operand(r0AF3).val);
                  exec_list *const f0AF2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AF2->then_instructions;

                     body.emit(assign(r0AF1, r0AD4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AF2->else_instructions;

                     ir_expression *const r0AF4 = lshift(r0AD4, r0AD7);
                     ir_expression *const r0AF5 = neg(r0AD7);
                     ir_expression *const r0AF6 = bit_and(r0AF5, body.constant(int(31)));
                     ir_expression *const r0AF7 = rshift(r0AD5, r0AF6);
                     body.emit(assign(r0AF1, bit_or(r0AF4, r0AF7), 0x01));


                  body.instructions = f0AF2_parent_instructions;
                  body.emit(f0AF2);

                  /* END IF */

                  body.emit(assign(r0AD4, r0AF1, 0x01));

                  body.emit(assign(r0AD5, r0AF0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AEE->else_instructions;

                  ir_variable *const r0AF8 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0AF8, body.constant(0u), 0x01));

                  ir_variable *const r0AF9 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0AF9, neg(r0AD7), 0x01));

                  ir_variable *const r0AFA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0AFA);
                  ir_variable *const r0AFB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0AFB);
                  ir_variable *const r0AFC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0AFC);
                  ir_variable *const r0AFD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0AFE = neg(r0AF9);
                  body.emit(assign(r0AFD, bit_and(r0AFE, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0B00 = equal(r0AF9, body.constant(int(0)));
                  ir_if *f0AFF = new(mem_ctx) ir_if(operand(r0B00).val);
                  exec_list *const f0AFF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AFF->then_instructions;

                     body.emit(assign(r0AFA, r0AF8, 0x01));

                     body.emit(assign(r0AFB, r0AD5, 0x01));

                     body.emit(assign(r0AFC, r0AD4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AFF->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B02 = less(r0AF9, body.constant(int(32)));
                     ir_if *f0B01 = new(mem_ctx) ir_if(operand(r0B02).val);
                     exec_list *const f0B01_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B01->then_instructions;

                        body.emit(assign(r0AFA, lshift(r0AD5, r0AFD), 0x01));

                        ir_expression *const r0B03 = lshift(r0AD4, r0AFD);
                        ir_expression *const r0B04 = rshift(r0AD5, r0AF9);
                        body.emit(assign(r0AFB, bit_or(r0B03, r0B04), 0x01));

                        body.emit(assign(r0AFC, rshift(r0AD4, r0AF9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B01->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0B06 = equal(r0AF9, body.constant(int(32)));
                        ir_if *f0B05 = new(mem_ctx) ir_if(operand(r0B06).val);
                        exec_list *const f0B05_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0B05->then_instructions;

                           body.emit(assign(r0AFA, r0AD5, 0x01));

                           body.emit(assign(r0AFB, r0AD4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0B05->else_instructions;

                           body.emit(assign(r0AF8, bit_or(body.constant(0u), r0AD5), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0B08 = less(r0AF9, body.constant(int(64)));
                           ir_if *f0B07 = new(mem_ctx) ir_if(operand(r0B08).val);
                           exec_list *const f0B07_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B07->then_instructions;

                              body.emit(assign(r0AFA, lshift(r0AD4, r0AFD), 0x01));

                              ir_expression *const r0B09 = bit_and(r0AF9, body.constant(int(31)));
                              body.emit(assign(r0AFB, rshift(r0AD4, r0B09), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B07->else_instructions;

                              ir_variable *const r0B0A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0B0C = equal(r0AF9, body.constant(int(64)));
                              ir_if *f0B0B = new(mem_ctx) ir_if(operand(r0B0C).val);
                              exec_list *const f0B0B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B0B->then_instructions;

                                 body.emit(assign(r0B0A, r0AD4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B0B->else_instructions;

                                 ir_expression *const r0B0D = nequal(r0AD4, body.constant(0u));
                                 ir_expression *const r0B0E = expr(ir_unop_b2i, r0B0D);
                                 body.emit(assign(r0B0A, expr(ir_unop_i2u, r0B0E), 0x01));


                              body.instructions = f0B0B_parent_instructions;
                              body.emit(f0B0B);

                              /* END IF */

                              body.emit(assign(r0AFA, r0B0A, 0x01));

                              body.emit(assign(r0AFB, body.constant(0u), 0x01));


                           body.instructions = f0B07_parent_instructions;
                           body.emit(f0B07);

                           /* END IF */


                        body.instructions = f0B05_parent_instructions;
                        body.emit(f0B05);

                        /* END IF */

                        body.emit(assign(r0AFC, body.constant(0u), 0x01));


                     body.instructions = f0B01_parent_instructions;
                     body.emit(f0B01);

                     /* END IF */

                     ir_expression *const r0B0F = nequal(r0AF8, body.constant(0u));
                     ir_expression *const r0B10 = expr(ir_unop_b2i, r0B0F);
                     ir_expression *const r0B11 = expr(ir_unop_i2u, r0B10);
                     body.emit(assign(r0AFA, bit_or(r0AFA, r0B11), 0x01));


                  body.instructions = f0AFF_parent_instructions;
                  body.emit(f0AFF);

                  /* END IF */

                  body.emit(assign(r0AD4, r0AFC, 0x01));

                  body.emit(assign(r0AD5, r0AFB, 0x01));

                  body.emit(assign(r0AD6, r0AFA, 0x01));


               body.instructions = f0AEE_parent_instructions;
               body.emit(f0AEE);

               /* END IF */

               body.emit(assign(r0AD3, sub(r0AD3, r0AD7), 0x01));

               ir_variable *const r0B12 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0B12, r0AD3, 0x01));

               ir_variable *const r0B13 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0B13, r0AD4, 0x01));

               ir_variable *const r0B14 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0B14, r0AD5, 0x01));

               ir_variable *const r0B15 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0B15, r0AD6, 0x01));

               ir_variable *const r0B16 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0B16, body.constant(true), 0x01));

               ir_variable *const r0B17 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0B18 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0B18);
               ir_expression *const r0B19 = expr(ir_unop_u2i, r0AD6);
               body.emit(assign(r0B18, less(r0B19, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0B1B = lequal(body.constant(int(2045)), r0AD3);
               ir_if *f0B1A = new(mem_ctx) ir_if(operand(r0B1B).val);
               exec_list *const f0B1A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B1A->then_instructions;

                  ir_variable *const r0B1C = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0B1E = less(body.constant(int(2045)), r0AD3);
                  ir_if *f0B1D = new(mem_ctx) ir_if(operand(r0B1E).val);
                  exec_list *const f0B1D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B1D->then_instructions;

                     body.emit(assign(r0B1C, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B1D->else_instructions;

                     ir_variable *const r0B1F = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B21 = equal(r0AD3, body.constant(int(2045)));
                     ir_if *f0B20 = new(mem_ctx) ir_if(operand(r0B21).val);
                     exec_list *const f0B20_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B20->then_instructions;

                        ir_expression *const r0B22 = equal(body.constant(2097151u), r0AD4);
                        ir_expression *const r0B23 = equal(body.constant(4294967295u), r0AD5);
                        body.emit(assign(r0B1F, logic_and(r0B22, r0B23), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B20->else_instructions;

                        body.emit(assign(r0B1F, body.constant(false), 0x01));


                     body.instructions = f0B20_parent_instructions;
                     body.emit(f0B20);

                     /* END IF */

                     body.emit(assign(r0B1C, logic_and(r0B1F, r0B18), 0x01));


                  body.instructions = f0B1D_parent_instructions;
                  body.emit(f0B1D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0B24 = new(mem_ctx) ir_if(operand(r0B1C).val);
                  exec_list *const f0B24_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B24->then_instructions;

                     ir_variable *const r0B25 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0B25);
                     ir_expression *const r0B26 = lshift(r0999, body.constant(int(31)));
                     body.emit(assign(r0B25, add(r0B26, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0B25, body.constant(0u), 0x01));

                     body.emit(assign(r0B17, r0B25, 0x03));

                     body.emit(assign(r0B16, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B24->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B28 = less(r0AD3, body.constant(int(0)));
                     ir_if *f0B27 = new(mem_ctx) ir_if(operand(r0B28).val);
                     exec_list *const f0B27_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B27->then_instructions;

                        ir_variable *const r0B29 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0B29, r0AD6, 0x01));

                        ir_variable *const r0B2A = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0B2A, neg(r0AD3), 0x01));

                        ir_variable *const r0B2B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0B2B);
                        ir_variable *const r0B2C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0B2C);
                        ir_variable *const r0B2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0B2D);
                        ir_variable *const r0B2E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0B2F = neg(r0B2A);
                        body.emit(assign(r0B2E, bit_and(r0B2F, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0B31 = equal(r0B2A, body.constant(int(0)));
                        ir_if *f0B30 = new(mem_ctx) ir_if(operand(r0B31).val);
                        exec_list *const f0B30_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0B30->then_instructions;

                           body.emit(assign(r0B2B, r0AD6, 0x01));

                           body.emit(assign(r0B2C, r0AD5, 0x01));

                           body.emit(assign(r0B2D, r0AD4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0B30->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0B33 = less(r0B2A, body.constant(int(32)));
                           ir_if *f0B32 = new(mem_ctx) ir_if(operand(r0B33).val);
                           exec_list *const f0B32_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B32->then_instructions;

                              body.emit(assign(r0B2B, lshift(r0AD5, r0B2E), 0x01));

                              ir_expression *const r0B34 = lshift(r0AD4, r0B2E);
                              ir_expression *const r0B35 = rshift(r0AD5, r0B2A);
                              body.emit(assign(r0B2C, bit_or(r0B34, r0B35), 0x01));

                              body.emit(assign(r0B2D, rshift(r0AD4, r0B2A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B32->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0B37 = equal(r0B2A, body.constant(int(32)));
                              ir_if *f0B36 = new(mem_ctx) ir_if(operand(r0B37).val);
                              exec_list *const f0B36_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B36->then_instructions;

                                 body.emit(assign(r0B2B, r0AD5, 0x01));

                                 body.emit(assign(r0B2C, r0AD4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B36->else_instructions;

                                 body.emit(assign(r0B29, bit_or(r0AD6, r0AD5), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0B39 = less(r0B2A, body.constant(int(64)));
                                 ir_if *f0B38 = new(mem_ctx) ir_if(operand(r0B39).val);
                                 exec_list *const f0B38_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0B38->then_instructions;

                                    body.emit(assign(r0B2B, lshift(r0AD4, r0B2E), 0x01));

                                    ir_expression *const r0B3A = bit_and(r0B2A, body.constant(int(31)));
                                    body.emit(assign(r0B2C, rshift(r0AD4, r0B3A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0B38->else_instructions;

                                    ir_variable *const r0B3B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0B3D = equal(r0B2A, body.constant(int(64)));
                                    ir_if *f0B3C = new(mem_ctx) ir_if(operand(r0B3D).val);
                                    exec_list *const f0B3C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0B3C->then_instructions;

                                       body.emit(assign(r0B3B, r0AD4, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0B3C->else_instructions;

                                       ir_expression *const r0B3E = nequal(r0AD4, body.constant(0u));
                                       ir_expression *const r0B3F = expr(ir_unop_b2i, r0B3E);
                                       body.emit(assign(r0B3B, expr(ir_unop_i2u, r0B3F), 0x01));


                                    body.instructions = f0B3C_parent_instructions;
                                    body.emit(f0B3C);

                                    /* END IF */

                                    body.emit(assign(r0B2B, r0B3B, 0x01));

                                    body.emit(assign(r0B2C, body.constant(0u), 0x01));


                                 body.instructions = f0B38_parent_instructions;
                                 body.emit(f0B38);

                                 /* END IF */


                              body.instructions = f0B36_parent_instructions;
                              body.emit(f0B36);

                              /* END IF */

                              body.emit(assign(r0B2D, body.constant(0u), 0x01));


                           body.instructions = f0B32_parent_instructions;
                           body.emit(f0B32);

                           /* END IF */

                           ir_expression *const r0B40 = nequal(r0B29, body.constant(0u));
                           ir_expression *const r0B41 = expr(ir_unop_b2i, r0B40);
                           ir_expression *const r0B42 = expr(ir_unop_i2u, r0B41);
                           body.emit(assign(r0B2B, bit_or(r0B2B, r0B42), 0x01));


                        body.instructions = f0B30_parent_instructions;
                        body.emit(f0B30);

                        /* END IF */

                        body.emit(assign(r0B13, r0B2D, 0x01));

                        body.emit(assign(r0B14, r0B2C, 0x01));

                        body.emit(assign(r0B15, r0B2B, 0x01));

                        body.emit(assign(r0B12, body.constant(int(0)), 0x01));

                        body.emit(assign(r0B18, less(r0B2B, body.constant(0u)), 0x01));


                     body.instructions = f0B27_parent_instructions;
                     body.emit(f0B27);

                     /* END IF */


                  body.instructions = f0B24_parent_instructions;
                  body.emit(f0B24);

                  /* END IF */


               body.instructions = f0B1A_parent_instructions;
               body.emit(f0B1A);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0B43 = new(mem_ctx) ir_if(operand(r0B16).val);
               exec_list *const f0B43_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B43->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0B44 = new(mem_ctx) ir_if(operand(r0B18).val);
                  exec_list *const f0B44_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B44->then_instructions;

                     ir_variable *const r0B45 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0B45, add(r0B14, body.constant(1u)), 0x01));

                     ir_expression *const r0B46 = less(r0B45, r0B14);
                     ir_expression *const r0B47 = expr(ir_unop_b2i, r0B46);
                     ir_expression *const r0B48 = expr(ir_unop_i2u, r0B47);
                     body.emit(assign(r0B13, add(r0B13, r0B48), 0x01));

                     ir_expression *const r0B49 = equal(r0B15, body.constant(0u));
                     ir_expression *const r0B4A = expr(ir_unop_b2i, r0B49);
                     ir_expression *const r0B4B = expr(ir_unop_i2u, r0B4A);
                     ir_expression *const r0B4C = add(r0B15, r0B4B);
                     ir_expression *const r0B4D = bit_and(r0B4C, body.constant(1u));
                     ir_expression *const r0B4E = expr(ir_unop_bit_not, r0B4D);
                     body.emit(assign(r0B14, bit_and(r0B45, r0B4E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B44->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B50 = bit_or(r0B13, r0B14);
                     ir_expression *const r0B51 = equal(r0B50, body.constant(0u));
                     ir_if *f0B4F = new(mem_ctx) ir_if(operand(r0B51).val);
                     exec_list *const f0B4F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B4F->then_instructions;

                        body.emit(assign(r0B12, body.constant(int(0)), 0x01));


                     body.instructions = f0B4F_parent_instructions;
                     body.emit(f0B4F);

                     /* END IF */


                  body.instructions = f0B44_parent_instructions;
                  body.emit(f0B44);

                  /* END IF */

                  ir_variable *const r0B52 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0B52);
                  ir_expression *const r0B53 = lshift(r0999, body.constant(int(31)));
                  ir_expression *const r0B54 = expr(ir_unop_i2u, r0B12);
                  ir_expression *const r0B55 = lshift(r0B54, body.constant(int(20)));
                  ir_expression *const r0B56 = add(r0B53, r0B55);
                  body.emit(assign(r0B52, add(r0B56, r0B13), 0x02));

                  body.emit(assign(r0B52, r0B14, 0x01));

                  body.emit(assign(r0B17, r0B52, 0x03));

                  body.emit(assign(r0B16, body.constant(false), 0x01));


               body.instructions = f0B43_parent_instructions;
               body.emit(f0B43);

               /* END IF */

               body.emit(assign(r099A, r0B17, 0x03));


            body.instructions = f0A85_parent_instructions;
            body.emit(f0A85);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0A83->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0B58 = equal(r09A3, body.constant(int(2047)));
            ir_if *f0B57 = new(mem_ctx) ir_if(operand(r0B58).val);
            exec_list *const f0B57_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0B57->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0B5A = bit_or(r09A0, r09A1);
               ir_expression *const r0B5B = bit_or(r099E, r099F);
               ir_expression *const r0B5C = bit_or(r0B5A, r0B5B);
               ir_expression *const r0B5D = nequal(r0B5C, body.constant(0u));
               ir_if *f0B59 = new(mem_ctx) ir_if(operand(r0B5D).val);
               exec_list *const f0B59_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B59->then_instructions;

                  ir_variable *const r0B5E = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0B5E, swizzle_x(r07E9), 0x01));

                  ir_variable *const r0B5F = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0B5F, swizzle_x(r07EA), 0x01));

                  ir_variable *const r0B60 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0B61 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0B62 = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0B63 = bit_and(r0B62, body.constant(4095u));
                  ir_expression *const r0B64 = equal(r0B63, body.constant(4094u));
                  ir_expression *const r0B65 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0B66 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0B67 = nequal(r0B66, body.constant(0u));
                  ir_expression *const r0B68 = logic_or(r0B65, r0B67);
                  body.emit(assign(r0B61, logic_and(r0B64, r0B68), 0x01));

                  ir_variable *const r0B69 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0B6A = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0B6B = lequal(body.constant(4292870144u), r0B6A);
                  ir_expression *const r0B6C = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0B6D = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0B6E = nequal(r0B6D, body.constant(0u));
                  ir_expression *const r0B6F = logic_or(r0B6C, r0B6E);
                  body.emit(assign(r0B69, logic_and(r0B6B, r0B6F), 0x01));

                  body.emit(assign(r0B5E, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r0B5F, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0B71 = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r0B72 = lequal(body.constant(4292870144u), r0B71);
                  ir_expression *const r0B73 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0B74 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0B75 = nequal(r0B74, body.constant(0u));
                  ir_expression *const r0B76 = logic_or(r0B73, r0B75);
                  ir_expression *const r0B77 = logic_and(r0B72, r0B76);
                  ir_if *f0B70 = new(mem_ctx) ir_if(operand(r0B77).val);
                  exec_list *const f0B70_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B70->then_instructions;

                     ir_variable *const r0B78 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B7A = logic_and(r0B61, r0B69);
                     ir_if *f0B79 = new(mem_ctx) ir_if(operand(r0B7A).val);
                     exec_list *const f0B79_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B79->then_instructions;

                        body.emit(assign(r0B78, r0B5F, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B79->else_instructions;

                        body.emit(assign(r0B78, r0B5E, 0x03));


                     body.instructions = f0B79_parent_instructions;
                     body.emit(f0B79);

                     /* END IF */

                     body.emit(assign(r0B60, r0B78, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B70->else_instructions;

                     body.emit(assign(r0B60, r0B5F, 0x03));


                  body.instructions = f0B70_parent_instructions;
                  body.emit(f0B70);

                  /* END IF */

                  body.emit(assign(r099A, r0B60, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B59->else_instructions;

                  ir_constant_data r0B7B_data;
                  memset(&r0B7B_data, 0, sizeof(ir_constant_data));
                  r0B7B_data.u[0] = 4294967295;
                  r0B7B_data.u[1] = 4294967295;
                  ir_constant *const r0B7B = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0B7B_data);
                  body.emit(assign(r099A, r0B7B, 0x03));


               body.instructions = f0B59_parent_instructions;
               body.emit(f0B59);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0B57->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0B7D = equal(r09A3, body.constant(int(0)));
               ir_if *f0B7C = new(mem_ctx) ir_if(operand(r0B7D).val);
               exec_list *const f0B7C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B7C->then_instructions;

                  body.emit(assign(r099D, body.constant(int(1)), 0x01));

                  body.emit(assign(r099C, body.constant(int(1)), 0x01));


               body.instructions = f0B7C_parent_instructions;
               body.emit(f0B7C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0B7F = less(r099E, r09A0);
               ir_if *f0B7E = new(mem_ctx) ir_if(operand(r0B7F).val);
               exec_list *const f0B7E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B7E->then_instructions;

                  ir_variable *const r0B80 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0B81 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0B81, sub(r09A1, r099F), 0x01));

                  ir_expression *const r0B82 = sub(r09A0, r099E);
                  ir_expression *const r0B83 = less(r09A1, r099F);
                  ir_expression *const r0B84 = expr(ir_unop_b2i, r0B83);
                  ir_expression *const r0B85 = expr(ir_unop_i2u, r0B84);
                  body.emit(assign(r0B80, sub(r0B82, r0B85), 0x01));

                  body.emit(assign(r09A2, add(r099D, body.constant(int(-1))), 0x01));

                  ir_variable *const r0B86 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0B86, add(r09A2, body.constant(int(-10))), 0x01));

                  ir_variable *const r0B87 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0B87, r0B80, 0x01));

                  ir_variable *const r0B88 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0B88, r0B81, 0x01));

                  ir_variable *const r0B89 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r0B89);
                  ir_variable *const r0B8A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B8A);
                  /* IF CONDITION */
                  ir_expression *const r0B8C = equal(r0B80, body.constant(0u));
                  ir_if *f0B8B = new(mem_ctx) ir_if(operand(r0B8C).val);
                  exec_list *const f0B8B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B8B->then_instructions;

                     body.emit(assign(r0B87, r0B81, 0x01));

                     body.emit(assign(r0B88, body.constant(0u), 0x01));

                     body.emit(assign(r0B86, add(r0B86, body.constant(int(-32))), 0x01));


                  body.instructions = f0B8B_parent_instructions;
                  body.emit(f0B8B);

                  /* END IF */

                  ir_variable *const r0B8D = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0B8D, r0B87, 0x01));

                  ir_variable *const r0B8E = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0B8F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B8F);
                  /* IF CONDITION */
                  ir_expression *const r0B91 = equal(r0B87, body.constant(0u));
                  ir_if *f0B90 = new(mem_ctx) ir_if(operand(r0B91).val);
                  exec_list *const f0B90_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B90->then_instructions;

                     body.emit(assign(r0B8E, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B90->else_instructions;

                     body.emit(assign(r0B8F, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0B93 = bit_and(r0B87, body.constant(4294901760u));
                     ir_expression *const r0B94 = equal(r0B93, body.constant(0u));
                     ir_if *f0B92 = new(mem_ctx) ir_if(operand(r0B94).val);
                     exec_list *const f0B92_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B92->then_instructions;

                        body.emit(assign(r0B8F, body.constant(int(16)), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B87, body.constant(int(16))), 0x01));


                     body.instructions = f0B92_parent_instructions;
                     body.emit(f0B92);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B96 = bit_and(r0B8D, body.constant(4278190080u));
                     ir_expression *const r0B97 = equal(r0B96, body.constant(0u));
                     ir_if *f0B95 = new(mem_ctx) ir_if(operand(r0B97).val);
                     exec_list *const f0B95_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B95->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(8))), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B8D, body.constant(int(8))), 0x01));


                     body.instructions = f0B95_parent_instructions;
                     body.emit(f0B95);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B99 = bit_and(r0B8D, body.constant(4026531840u));
                     ir_expression *const r0B9A = equal(r0B99, body.constant(0u));
                     ir_if *f0B98 = new(mem_ctx) ir_if(operand(r0B9A).val);
                     exec_list *const f0B98_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B98->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(4))), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B8D, body.constant(int(4))), 0x01));


                     body.instructions = f0B98_parent_instructions;
                     body.emit(f0B98);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B9C = bit_and(r0B8D, body.constant(3221225472u));
                     ir_expression *const r0B9D = equal(r0B9C, body.constant(0u));
                     ir_if *f0B9B = new(mem_ctx) ir_if(operand(r0B9D).val);
                     exec_list *const f0B9B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B9B->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(2))), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B8D, body.constant(int(2))), 0x01));


                     body.instructions = f0B9B_parent_instructions;
                     body.emit(f0B9B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B9F = bit_and(r0B8D, body.constant(2147483648u));
                     ir_expression *const r0BA0 = equal(r0B9F, body.constant(0u));
                     ir_if *f0B9E = new(mem_ctx) ir_if(operand(r0BA0).val);
                     exec_list *const f0B9E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B9E->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(1))), 0x01));


                     body.instructions = f0B9E_parent_instructions;
                     body.emit(f0B9E);

                     /* END IF */

                     body.emit(assign(r0B8E, r0B8F, 0x01));


                  body.instructions = f0B90_parent_instructions;
                  body.emit(f0B90);

                  /* END IF */

                  body.emit(assign(r0B8A, add(r0B8E, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0BA2 = lequal(body.constant(int(0)), r0B8A);
                  ir_if *f0BA1 = new(mem_ctx) ir_if(operand(r0BA2).val);
                  exec_list *const f0BA1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BA1->then_instructions;

                     body.emit(assign(r0B89, body.constant(0u), 0x01));

                     ir_variable *const r0BA3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0BA3, lshift(r0B88, r0B8A), 0x01));

                     ir_variable *const r0BA4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0BA6 = equal(r0B8A, body.constant(int(0)));
                     ir_if *f0BA5 = new(mem_ctx) ir_if(operand(r0BA6).val);
                     exec_list *const f0BA5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BA5->then_instructions;

                        body.emit(assign(r0BA4, r0B87, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BA5->else_instructions;

                        ir_expression *const r0BA7 = lshift(r0B87, r0B8A);
                        ir_expression *const r0BA8 = neg(r0B8A);
                        ir_expression *const r0BA9 = bit_and(r0BA8, body.constant(int(31)));
                        ir_expression *const r0BAA = rshift(r0B88, r0BA9);
                        body.emit(assign(r0BA4, bit_or(r0BA7, r0BAA), 0x01));


                     body.instructions = f0BA5_parent_instructions;
                     body.emit(f0BA5);

                     /* END IF */

                     body.emit(assign(r0B87, r0BA4, 0x01));

                     body.emit(assign(r0B88, r0BA3, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0BA1->else_instructions;

                     ir_variable *const r0BAB = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0BAB, body.constant(0u), 0x01));

                     ir_variable *const r0BAC = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0BAC, neg(r0B8A), 0x01));

                     ir_variable *const r0BAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0BAD);
                     ir_variable *const r0BAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0BAE);
                     ir_variable *const r0BAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0BAF);
                     ir_variable *const r0BB0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0BB1 = neg(r0BAC);
                     body.emit(assign(r0BB0, bit_and(r0BB1, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0BB3 = equal(r0BAC, body.constant(int(0)));
                     ir_if *f0BB2 = new(mem_ctx) ir_if(operand(r0BB3).val);
                     exec_list *const f0BB2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BB2->then_instructions;

                        body.emit(assign(r0BAD, r0BAB, 0x01));

                        body.emit(assign(r0BAE, r0B88, 0x01));

                        body.emit(assign(r0BAF, r0B87, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BB2->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BB5 = less(r0BAC, body.constant(int(32)));
                        ir_if *f0BB4 = new(mem_ctx) ir_if(operand(r0BB5).val);
                        exec_list *const f0BB4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BB4->then_instructions;

                           body.emit(assign(r0BAD, lshift(r0B88, r0BB0), 0x01));

                           ir_expression *const r0BB6 = lshift(r0B87, r0BB0);
                           ir_expression *const r0BB7 = rshift(r0B88, r0BAC);
                           body.emit(assign(r0BAE, bit_or(r0BB6, r0BB7), 0x01));

                           body.emit(assign(r0BAF, rshift(r0B87, r0BAC), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BB4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0BB9 = equal(r0BAC, body.constant(int(32)));
                           ir_if *f0BB8 = new(mem_ctx) ir_if(operand(r0BB9).val);
                           exec_list *const f0BB8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BB8->then_instructions;

                              body.emit(assign(r0BAD, r0B88, 0x01));

                              body.emit(assign(r0BAE, r0B87, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BB8->else_instructions;

                              body.emit(assign(r0BAB, bit_or(body.constant(0u), r0B88), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0BBB = less(r0BAC, body.constant(int(64)));
                              ir_if *f0BBA = new(mem_ctx) ir_if(operand(r0BBB).val);
                              exec_list *const f0BBA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BBA->then_instructions;

                                 body.emit(assign(r0BAD, lshift(r0B87, r0BB0), 0x01));

                                 ir_expression *const r0BBC = bit_and(r0BAC, body.constant(int(31)));
                                 body.emit(assign(r0BAE, rshift(r0B87, r0BBC), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BBA->else_instructions;

                                 ir_variable *const r0BBD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0BBF = equal(r0BAC, body.constant(int(64)));
                                 ir_if *f0BBE = new(mem_ctx) ir_if(operand(r0BBF).val);
                                 exec_list *const f0BBE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BBE->then_instructions;

                                    body.emit(assign(r0BBD, r0B87, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BBE->else_instructions;

                                    ir_expression *const r0BC0 = nequal(r0B87, body.constant(0u));
                                    ir_expression *const r0BC1 = expr(ir_unop_b2i, r0BC0);
                                    body.emit(assign(r0BBD, expr(ir_unop_i2u, r0BC1), 0x01));


                                 body.instructions = f0BBE_parent_instructions;
                                 body.emit(f0BBE);

                                 /* END IF */

                                 body.emit(assign(r0BAD, r0BBD, 0x01));

                                 body.emit(assign(r0BAE, body.constant(0u), 0x01));


                              body.instructions = f0BBA_parent_instructions;
                              body.emit(f0BBA);

                              /* END IF */


                           body.instructions = f0BB8_parent_instructions;
                           body.emit(f0BB8);

                           /* END IF */

                           body.emit(assign(r0BAF, body.constant(0u), 0x01));


                        body.instructions = f0BB4_parent_instructions;
                        body.emit(f0BB4);

                        /* END IF */

                        ir_expression *const r0BC2 = nequal(r0BAB, body.constant(0u));
                        ir_expression *const r0BC3 = expr(ir_unop_b2i, r0BC2);
                        ir_expression *const r0BC4 = expr(ir_unop_i2u, r0BC3);
                        body.emit(assign(r0BAD, bit_or(r0BAD, r0BC4), 0x01));


                     body.instructions = f0BB2_parent_instructions;
                     body.emit(f0BB2);

                     /* END IF */

                     body.emit(assign(r0B87, r0BAF, 0x01));

                     body.emit(assign(r0B88, r0BAE, 0x01));

                     body.emit(assign(r0B89, r0BAD, 0x01));


                  body.instructions = f0BA1_parent_instructions;
                  body.emit(f0BA1);

                  /* END IF */

                  body.emit(assign(r0B86, sub(r0B86, r0B8A), 0x01));

                  ir_variable *const r0BC5 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0BC5, r0B86, 0x01));

                  ir_variable *const r0BC6 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0BC6, r0B87, 0x01));

                  ir_variable *const r0BC7 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0BC7, r0B88, 0x01));

                  ir_variable *const r0BC8 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r0BC8, r0B89, 0x01));

                  ir_variable *const r0BC9 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r0BC9, body.constant(true), 0x01));

                  ir_variable *const r0BCA = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0BCB = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0BCB);
                  ir_expression *const r0BCC = expr(ir_unop_u2i, r0B89);
                  body.emit(assign(r0BCB, less(r0BCC, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0BCE = lequal(body.constant(int(2045)), r0B86);
                  ir_if *f0BCD = new(mem_ctx) ir_if(operand(r0BCE).val);
                  exec_list *const f0BCD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BCD->then_instructions;

                     ir_variable *const r0BCF = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0BD1 = less(body.constant(int(2045)), r0B86);
                     ir_if *f0BD0 = new(mem_ctx) ir_if(operand(r0BD1).val);
                     exec_list *const f0BD0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BD0->then_instructions;

                        body.emit(assign(r0BCF, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BD0->else_instructions;

                        ir_variable *const r0BD2 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0BD4 = equal(r0B86, body.constant(int(2045)));
                        ir_if *f0BD3 = new(mem_ctx) ir_if(operand(r0BD4).val);
                        exec_list *const f0BD3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BD3->then_instructions;

                           ir_expression *const r0BD5 = equal(body.constant(2097151u), r0B87);
                           ir_expression *const r0BD6 = equal(body.constant(4294967295u), r0B88);
                           body.emit(assign(r0BD2, logic_and(r0BD5, r0BD6), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BD3->else_instructions;

                           body.emit(assign(r0BD2, body.constant(false), 0x01));


                        body.instructions = f0BD3_parent_instructions;
                        body.emit(f0BD3);

                        /* END IF */

                        body.emit(assign(r0BCF, logic_and(r0BD2, r0BCB), 0x01));


                     body.instructions = f0BD0_parent_instructions;
                     body.emit(f0BD0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0BD7 = new(mem_ctx) ir_if(operand(r0BCF).val);
                     exec_list *const f0BD7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BD7->then_instructions;

                        ir_variable *const r0BD8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0BD8);
                        ir_expression *const r0BD9 = lshift(r0999, body.constant(int(31)));
                        body.emit(assign(r0BD8, add(r0BD9, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r0BD8, body.constant(0u), 0x01));

                        body.emit(assign(r0BCA, r0BD8, 0x03));

                        body.emit(assign(r0BC9, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BD7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BDB = less(r0B86, body.constant(int(0)));
                        ir_if *f0BDA = new(mem_ctx) ir_if(operand(r0BDB).val);
                        exec_list *const f0BDA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BDA->then_instructions;

                           ir_variable *const r0BDC = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0BDC, r0B89, 0x01));

                           ir_variable *const r0BDD = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0BDD, neg(r0B86), 0x01));

                           ir_variable *const r0BDE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0BDE);
                           ir_variable *const r0BDF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0BDF);
                           ir_variable *const r0BE0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0BE0);
                           ir_variable *const r0BE1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0BE2 = neg(r0BDD);
                           body.emit(assign(r0BE1, bit_and(r0BE2, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0BE4 = equal(r0BDD, body.constant(int(0)));
                           ir_if *f0BE3 = new(mem_ctx) ir_if(operand(r0BE4).val);
                           exec_list *const f0BE3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BE3->then_instructions;

                              body.emit(assign(r0BDE, r0B89, 0x01));

                              body.emit(assign(r0BDF, r0B88, 0x01));

                              body.emit(assign(r0BE0, r0B87, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BE3->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0BE6 = less(r0BDD, body.constant(int(32)));
                              ir_if *f0BE5 = new(mem_ctx) ir_if(operand(r0BE6).val);
                              exec_list *const f0BE5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BE5->then_instructions;

                                 body.emit(assign(r0BDE, lshift(r0B88, r0BE1), 0x01));

                                 ir_expression *const r0BE7 = lshift(r0B87, r0BE1);
                                 ir_expression *const r0BE8 = rshift(r0B88, r0BDD);
                                 body.emit(assign(r0BDF, bit_or(r0BE7, r0BE8), 0x01));

                                 body.emit(assign(r0BE0, rshift(r0B87, r0BDD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BE5->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0BEA = equal(r0BDD, body.constant(int(32)));
                                 ir_if *f0BE9 = new(mem_ctx) ir_if(operand(r0BEA).val);
                                 exec_list *const f0BE9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BE9->then_instructions;

                                    body.emit(assign(r0BDE, r0B88, 0x01));

                                    body.emit(assign(r0BDF, r0B87, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BE9->else_instructions;

                                    body.emit(assign(r0BDC, bit_or(r0B89, r0B88), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0BEC = less(r0BDD, body.constant(int(64)));
                                    ir_if *f0BEB = new(mem_ctx) ir_if(operand(r0BEC).val);
                                    exec_list *const f0BEB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0BEB->then_instructions;

                                       body.emit(assign(r0BDE, lshift(r0B87, r0BE1), 0x01));

                                       ir_expression *const r0BED = bit_and(r0BDD, body.constant(int(31)));
                                       body.emit(assign(r0BDF, rshift(r0B87, r0BED), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0BEB->else_instructions;

                                       ir_variable *const r0BEE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0BF0 = equal(r0BDD, body.constant(int(64)));
                                       ir_if *f0BEF = new(mem_ctx) ir_if(operand(r0BF0).val);
                                       exec_list *const f0BEF_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0BEF->then_instructions;

                                          body.emit(assign(r0BEE, r0B87, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0BEF->else_instructions;

                                          ir_expression *const r0BF1 = nequal(r0B87, body.constant(0u));
                                          ir_expression *const r0BF2 = expr(ir_unop_b2i, r0BF1);
                                          body.emit(assign(r0BEE, expr(ir_unop_i2u, r0BF2), 0x01));


                                       body.instructions = f0BEF_parent_instructions;
                                       body.emit(f0BEF);

                                       /* END IF */

                                       body.emit(assign(r0BDE, r0BEE, 0x01));

                                       body.emit(assign(r0BDF, body.constant(0u), 0x01));


                                    body.instructions = f0BEB_parent_instructions;
                                    body.emit(f0BEB);

                                    /* END IF */


                                 body.instructions = f0BE9_parent_instructions;
                                 body.emit(f0BE9);

                                 /* END IF */

                                 body.emit(assign(r0BE0, body.constant(0u), 0x01));


                              body.instructions = f0BE5_parent_instructions;
                              body.emit(f0BE5);

                              /* END IF */

                              ir_expression *const r0BF3 = nequal(r0BDC, body.constant(0u));
                              ir_expression *const r0BF4 = expr(ir_unop_b2i, r0BF3);
                              ir_expression *const r0BF5 = expr(ir_unop_i2u, r0BF4);
                              body.emit(assign(r0BDE, bit_or(r0BDE, r0BF5), 0x01));


                           body.instructions = f0BE3_parent_instructions;
                           body.emit(f0BE3);

                           /* END IF */

                           body.emit(assign(r0BC6, r0BE0, 0x01));

                           body.emit(assign(r0BC7, r0BDF, 0x01));

                           body.emit(assign(r0BC8, r0BDE, 0x01));

                           body.emit(assign(r0BC5, body.constant(int(0)), 0x01));

                           body.emit(assign(r0BCB, less(r0BDE, body.constant(0u)), 0x01));


                        body.instructions = f0BDA_parent_instructions;
                        body.emit(f0BDA);

                        /* END IF */


                     body.instructions = f0BD7_parent_instructions;
                     body.emit(f0BD7);

                     /* END IF */


                  body.instructions = f0BCD_parent_instructions;
                  body.emit(f0BCD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0BF6 = new(mem_ctx) ir_if(operand(r0BC9).val);
                  exec_list *const f0BF6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BF6->then_instructions;

                     /* IF CONDITION */
                     ir_if *f0BF7 = new(mem_ctx) ir_if(operand(r0BCB).val);
                     exec_list *const f0BF7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BF7->then_instructions;

                        ir_variable *const r0BF8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r0BF8, add(r0BC7, body.constant(1u)), 0x01));

                        ir_expression *const r0BF9 = less(r0BF8, r0BC7);
                        ir_expression *const r0BFA = expr(ir_unop_b2i, r0BF9);
                        ir_expression *const r0BFB = expr(ir_unop_i2u, r0BFA);
                        body.emit(assign(r0BC6, add(r0BC6, r0BFB), 0x01));

                        ir_expression *const r0BFC = equal(r0BC8, body.constant(0u));
                        ir_expression *const r0BFD = expr(ir_unop_b2i, r0BFC);
                        ir_expression *const r0BFE = expr(ir_unop_i2u, r0BFD);
                        ir_expression *const r0BFF = add(r0BC8, r0BFE);
                        ir_expression *const r0C00 = bit_and(r0BFF, body.constant(1u));
                        ir_expression *const r0C01 = expr(ir_unop_bit_not, r0C00);
                        body.emit(assign(r0BC7, bit_and(r0BF8, r0C01), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BF7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0C03 = bit_or(r0BC6, r0BC7);
                        ir_expression *const r0C04 = equal(r0C03, body.constant(0u));
                        ir_if *f0C02 = new(mem_ctx) ir_if(operand(r0C04).val);
                        exec_list *const f0C02_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C02->then_instructions;

                           body.emit(assign(r0BC5, body.constant(int(0)), 0x01));


                        body.instructions = f0C02_parent_instructions;
                        body.emit(f0C02);

                        /* END IF */


                     body.instructions = f0BF7_parent_instructions;
                     body.emit(f0BF7);

                     /* END IF */

                     ir_variable *const r0C05 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0C05);
                     ir_expression *const r0C06 = lshift(r0999, body.constant(int(31)));
                     ir_expression *const r0C07 = expr(ir_unop_i2u, r0BC5);
                     ir_expression *const r0C08 = lshift(r0C07, body.constant(int(20)));
                     ir_expression *const r0C09 = add(r0C06, r0C08);
                     body.emit(assign(r0C05, add(r0C09, r0BC6), 0x02));

                     body.emit(assign(r0C05, r0BC7, 0x01));

                     body.emit(assign(r0BCA, r0C05, 0x03));

                     body.emit(assign(r0BC9, body.constant(false), 0x01));


                  body.instructions = f0BF6_parent_instructions;
                  body.emit(f0BF6);

                  /* END IF */

                  body.emit(assign(r099A, r0BCA, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B7E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0C0B = less(r09A0, r099E);
                  ir_if *f0C0A = new(mem_ctx) ir_if(operand(r0C0B).val);
                  exec_list *const f0C0A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0C0A->then_instructions;

                     ir_variable *const r0C0C = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r0C0D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0C0D, sub(r099F, r09A1), 0x01));

                     ir_expression *const r0C0E = sub(r099E, r09A0);
                     ir_expression *const r0C0F = less(r099F, r09A1);
                     ir_expression *const r0C10 = expr(ir_unop_b2i, r0C0F);
                     ir_expression *const r0C11 = expr(ir_unop_i2u, r0C10);
                     body.emit(assign(r0C0C, sub(r0C0E, r0C11), 0x01));

                     body.emit(assign(r0999, bit_xor(r0999, body.constant(1u)), 0x01));

                     body.emit(assign(r09A2, add(r099C, body.constant(int(-1))), 0x01));

                     ir_variable *const r0C12 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C12, add(r09A2, body.constant(int(-10))), 0x01));

                     ir_variable *const r0C13 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C13, r0C0C, 0x01));

                     ir_variable *const r0C14 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C14, r0C0D, 0x01));

                     ir_variable *const r0C15 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r0C15);
                     ir_variable *const r0C16 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C16);
                     /* IF CONDITION */
                     ir_expression *const r0C18 = equal(r0C0C, body.constant(0u));
                     ir_if *f0C17 = new(mem_ctx) ir_if(operand(r0C18).val);
                     exec_list *const f0C17_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C17->then_instructions;

                        body.emit(assign(r0C13, r0C0D, 0x01));

                        body.emit(assign(r0C14, body.constant(0u), 0x01));

                        body.emit(assign(r0C12, add(r0C12, body.constant(int(-32))), 0x01));


                     body.instructions = f0C17_parent_instructions;
                     body.emit(f0C17);

                     /* END IF */

                     ir_variable *const r0C19 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r0C19, r0C13, 0x01));

                     ir_variable *const r0C1A = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r0C1B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C1B);
                     /* IF CONDITION */
                     ir_expression *const r0C1D = equal(r0C13, body.constant(0u));
                     ir_if *f0C1C = new(mem_ctx) ir_if(operand(r0C1D).val);
                     exec_list *const f0C1C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C1C->then_instructions;

                        body.emit(assign(r0C1A, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C1C->else_instructions;

                        body.emit(assign(r0C1B, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C1F = bit_and(r0C13, body.constant(4294901760u));
                        ir_expression *const r0C20 = equal(r0C1F, body.constant(0u));
                        ir_if *f0C1E = new(mem_ctx) ir_if(operand(r0C20).val);
                        exec_list *const f0C1E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C1E->then_instructions;

                           body.emit(assign(r0C1B, body.constant(int(16)), 0x01));

                           body.emit(assign(r0C19, lshift(r0C13, body.constant(int(16))), 0x01));


                        body.instructions = f0C1E_parent_instructions;
                        body.emit(f0C1E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C22 = bit_and(r0C19, body.constant(4278190080u));
                        ir_expression *const r0C23 = equal(r0C22, body.constant(0u));
                        ir_if *f0C21 = new(mem_ctx) ir_if(operand(r0C23).val);
                        exec_list *const f0C21_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C21->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(8))), 0x01));

                           body.emit(assign(r0C19, lshift(r0C19, body.constant(int(8))), 0x01));


                        body.instructions = f0C21_parent_instructions;
                        body.emit(f0C21);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C25 = bit_and(r0C19, body.constant(4026531840u));
                        ir_expression *const r0C26 = equal(r0C25, body.constant(0u));
                        ir_if *f0C24 = new(mem_ctx) ir_if(operand(r0C26).val);
                        exec_list *const f0C24_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C24->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(4))), 0x01));

                           body.emit(assign(r0C19, lshift(r0C19, body.constant(int(4))), 0x01));


                        body.instructions = f0C24_parent_instructions;
                        body.emit(f0C24);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C28 = bit_and(r0C19, body.constant(3221225472u));
                        ir_expression *const r0C29 = equal(r0C28, body.constant(0u));
                        ir_if *f0C27 = new(mem_ctx) ir_if(operand(r0C29).val);
                        exec_list *const f0C27_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C27->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(2))), 0x01));

                           body.emit(assign(r0C19, lshift(r0C19, body.constant(int(2))), 0x01));


                        body.instructions = f0C27_parent_instructions;
                        body.emit(f0C27);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C2B = bit_and(r0C19, body.constant(2147483648u));
                        ir_expression *const r0C2C = equal(r0C2B, body.constant(0u));
                        ir_if *f0C2A = new(mem_ctx) ir_if(operand(r0C2C).val);
                        exec_list *const f0C2A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C2A->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(1))), 0x01));


                        body.instructions = f0C2A_parent_instructions;
                        body.emit(f0C2A);

                        /* END IF */

                        body.emit(assign(r0C1A, r0C1B, 0x01));


                     body.instructions = f0C1C_parent_instructions;
                     body.emit(f0C1C);

                     /* END IF */

                     body.emit(assign(r0C16, add(r0C1A, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C2E = lequal(body.constant(int(0)), r0C16);
                     ir_if *f0C2D = new(mem_ctx) ir_if(operand(r0C2E).val);
                     exec_list *const f0C2D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C2D->then_instructions;

                        body.emit(assign(r0C15, body.constant(0u), 0x01));

                        ir_variable *const r0C2F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C2F, lshift(r0C14, r0C16), 0x01));

                        ir_variable *const r0C30 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C32 = equal(r0C16, body.constant(int(0)));
                        ir_if *f0C31 = new(mem_ctx) ir_if(operand(r0C32).val);
                        exec_list *const f0C31_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C31->then_instructions;

                           body.emit(assign(r0C30, r0C13, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C31->else_instructions;

                           ir_expression *const r0C33 = lshift(r0C13, r0C16);
                           ir_expression *const r0C34 = neg(r0C16);
                           ir_expression *const r0C35 = bit_and(r0C34, body.constant(int(31)));
                           ir_expression *const r0C36 = rshift(r0C14, r0C35);
                           body.emit(assign(r0C30, bit_or(r0C33, r0C36), 0x01));


                        body.instructions = f0C31_parent_instructions;
                        body.emit(f0C31);

                        /* END IF */

                        body.emit(assign(r0C13, r0C30, 0x01));

                        body.emit(assign(r0C14, r0C2F, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C2D->else_instructions;

                        ir_variable *const r0C37 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0C37, body.constant(0u), 0x01));

                        ir_variable *const r0C38 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0C38, neg(r0C16), 0x01));

                        ir_variable *const r0C39 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0C39);
                        ir_variable *const r0C3A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0C3A);
                        ir_variable *const r0C3B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0C3B);
                        ir_variable *const r0C3C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0C3D = neg(r0C38);
                        body.emit(assign(r0C3C, bit_and(r0C3D, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C3F = equal(r0C38, body.constant(int(0)));
                        ir_if *f0C3E = new(mem_ctx) ir_if(operand(r0C3F).val);
                        exec_list *const f0C3E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C3E->then_instructions;

                           body.emit(assign(r0C39, r0C37, 0x01));

                           body.emit(assign(r0C3A, r0C14, 0x01));

                           body.emit(assign(r0C3B, r0C13, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C3E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C41 = less(r0C38, body.constant(int(32)));
                           ir_if *f0C40 = new(mem_ctx) ir_if(operand(r0C41).val);
                           exec_list *const f0C40_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C40->then_instructions;

                              body.emit(assign(r0C39, lshift(r0C14, r0C3C), 0x01));

                              ir_expression *const r0C42 = lshift(r0C13, r0C3C);
                              ir_expression *const r0C43 = rshift(r0C14, r0C38);
                              body.emit(assign(r0C3A, bit_or(r0C42, r0C43), 0x01));

                              body.emit(assign(r0C3B, rshift(r0C13, r0C38), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C40->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0C45 = equal(r0C38, body.constant(int(32)));
                              ir_if *f0C44 = new(mem_ctx) ir_if(operand(r0C45).val);
                              exec_list *const f0C44_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C44->then_instructions;

                                 body.emit(assign(r0C39, r0C14, 0x01));

                                 body.emit(assign(r0C3A, r0C13, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C44->else_instructions;

                                 body.emit(assign(r0C37, bit_or(body.constant(0u), r0C14), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0C47 = less(r0C38, body.constant(int(64)));
                                 ir_if *f0C46 = new(mem_ctx) ir_if(operand(r0C47).val);
                                 exec_list *const f0C46_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C46->then_instructions;

                                    body.emit(assign(r0C39, lshift(r0C13, r0C3C), 0x01));

                                    ir_expression *const r0C48 = bit_and(r0C38, body.constant(int(31)));
                                    body.emit(assign(r0C3A, rshift(r0C13, r0C48), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C46->else_instructions;

                                    ir_variable *const r0C49 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0C4B = equal(r0C38, body.constant(int(64)));
                                    ir_if *f0C4A = new(mem_ctx) ir_if(operand(r0C4B).val);
                                    exec_list *const f0C4A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C4A->then_instructions;

                                       body.emit(assign(r0C49, r0C13, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C4A->else_instructions;

                                       ir_expression *const r0C4C = nequal(r0C13, body.constant(0u));
                                       ir_expression *const r0C4D = expr(ir_unop_b2i, r0C4C);
                                       body.emit(assign(r0C49, expr(ir_unop_i2u, r0C4D), 0x01));


                                    body.instructions = f0C4A_parent_instructions;
                                    body.emit(f0C4A);

                                    /* END IF */

                                    body.emit(assign(r0C39, r0C49, 0x01));

                                    body.emit(assign(r0C3A, body.constant(0u), 0x01));


                                 body.instructions = f0C46_parent_instructions;
                                 body.emit(f0C46);

                                 /* END IF */


                              body.instructions = f0C44_parent_instructions;
                              body.emit(f0C44);

                              /* END IF */

                              body.emit(assign(r0C3B, body.constant(0u), 0x01));


                           body.instructions = f0C40_parent_instructions;
                           body.emit(f0C40);

                           /* END IF */

                           ir_expression *const r0C4E = nequal(r0C37, body.constant(0u));
                           ir_expression *const r0C4F = expr(ir_unop_b2i, r0C4E);
                           ir_expression *const r0C50 = expr(ir_unop_i2u, r0C4F);
                           body.emit(assign(r0C39, bit_or(r0C39, r0C50), 0x01));


                        body.instructions = f0C3E_parent_instructions;
                        body.emit(f0C3E);

                        /* END IF */

                        body.emit(assign(r0C13, r0C3B, 0x01));

                        body.emit(assign(r0C14, r0C3A, 0x01));

                        body.emit(assign(r0C15, r0C39, 0x01));


                     body.instructions = f0C2D_parent_instructions;
                     body.emit(f0C2D);

                     /* END IF */

                     body.emit(assign(r0C12, sub(r0C12, r0C16), 0x01));

                     ir_variable *const r0C51 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C51, r0C12, 0x01));

                     ir_variable *const r0C52 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C52, r0C13, 0x01));

                     ir_variable *const r0C53 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C53, r0C14, 0x01));

                     ir_variable *const r0C54 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r0C54, r0C15, 0x01));

                     ir_variable *const r0C55 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r0C55, body.constant(true), 0x01));

                     ir_variable *const r0C56 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r0C57 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r0C57);
                     ir_expression *const r0C58 = expr(ir_unop_u2i, r0C15);
                     body.emit(assign(r0C57, less(r0C58, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C5A = lequal(body.constant(int(2045)), r0C12);
                     ir_if *f0C59 = new(mem_ctx) ir_if(operand(r0C5A).val);
                     exec_list *const f0C59_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C59->then_instructions;

                        ir_variable *const r0C5B = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C5D = less(body.constant(int(2045)), r0C12);
                        ir_if *f0C5C = new(mem_ctx) ir_if(operand(r0C5D).val);
                        exec_list *const f0C5C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C5C->then_instructions;

                           body.emit(assign(r0C5B, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C5C->else_instructions;

                           ir_variable *const r0C5E = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0C60 = equal(r0C12, body.constant(int(2045)));
                           ir_if *f0C5F = new(mem_ctx) ir_if(operand(r0C60).val);
                           exec_list *const f0C5F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C5F->then_instructions;

                              ir_expression *const r0C61 = equal(body.constant(2097151u), r0C13);
                              ir_expression *const r0C62 = equal(body.constant(4294967295u), r0C14);
                              body.emit(assign(r0C5E, logic_and(r0C61, r0C62), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C5F->else_instructions;

                              body.emit(assign(r0C5E, body.constant(false), 0x01));


                           body.instructions = f0C5F_parent_instructions;
                           body.emit(f0C5F);

                           /* END IF */

                           body.emit(assign(r0C5B, logic_and(r0C5E, r0C57), 0x01));


                        body.instructions = f0C5C_parent_instructions;
                        body.emit(f0C5C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0C63 = new(mem_ctx) ir_if(operand(r0C5B).val);
                        exec_list *const f0C63_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C63->then_instructions;

                           ir_variable *const r0C64 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0C64);
                           ir_expression *const r0C65 = lshift(r0999, body.constant(int(31)));
                           body.emit(assign(r0C64, add(r0C65, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r0C64, body.constant(0u), 0x01));

                           body.emit(assign(r0C56, r0C64, 0x03));

                           body.emit(assign(r0C55, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C63->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C67 = less(r0C12, body.constant(int(0)));
                           ir_if *f0C66 = new(mem_ctx) ir_if(operand(r0C67).val);
                           exec_list *const f0C66_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C66->then_instructions;

                              ir_variable *const r0C68 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0C68, r0C15, 0x01));

                              ir_variable *const r0C69 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0C69, neg(r0C12), 0x01));

                              ir_variable *const r0C6A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0C6A);
                              ir_variable *const r0C6B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0C6B);
                              ir_variable *const r0C6C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0C6C);
                              ir_variable *const r0C6D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0C6E = neg(r0C69);
                              body.emit(assign(r0C6D, bit_and(r0C6E, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0C70 = equal(r0C69, body.constant(int(0)));
                              ir_if *f0C6F = new(mem_ctx) ir_if(operand(r0C70).val);
                              exec_list *const f0C6F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C6F->then_instructions;

                                 body.emit(assign(r0C6A, r0C15, 0x01));

                                 body.emit(assign(r0C6B, r0C14, 0x01));

                                 body.emit(assign(r0C6C, r0C13, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C6F->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0C72 = less(r0C69, body.constant(int(32)));
                                 ir_if *f0C71 = new(mem_ctx) ir_if(operand(r0C72).val);
                                 exec_list *const f0C71_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C71->then_instructions;

                                    body.emit(assign(r0C6A, lshift(r0C14, r0C6D), 0x01));

                                    ir_expression *const r0C73 = lshift(r0C13, r0C6D);
                                    ir_expression *const r0C74 = rshift(r0C14, r0C69);
                                    body.emit(assign(r0C6B, bit_or(r0C73, r0C74), 0x01));

                                    body.emit(assign(r0C6C, rshift(r0C13, r0C69), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C71->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0C76 = equal(r0C69, body.constant(int(32)));
                                    ir_if *f0C75 = new(mem_ctx) ir_if(operand(r0C76).val);
                                    exec_list *const f0C75_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C75->then_instructions;

                                       body.emit(assign(r0C6A, r0C14, 0x01));

                                       body.emit(assign(r0C6B, r0C13, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C75->else_instructions;

                                       body.emit(assign(r0C68, bit_or(r0C15, r0C14), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0C78 = less(r0C69, body.constant(int(64)));
                                       ir_if *f0C77 = new(mem_ctx) ir_if(operand(r0C78).val);
                                       exec_list *const f0C77_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0C77->then_instructions;

                                          body.emit(assign(r0C6A, lshift(r0C13, r0C6D), 0x01));

                                          ir_expression *const r0C79 = bit_and(r0C69, body.constant(int(31)));
                                          body.emit(assign(r0C6B, rshift(r0C13, r0C79), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0C77->else_instructions;

                                          ir_variable *const r0C7A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0C7C = equal(r0C69, body.constant(int(64)));
                                          ir_if *f0C7B = new(mem_ctx) ir_if(operand(r0C7C).val);
                                          exec_list *const f0C7B_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0C7B->then_instructions;

                                             body.emit(assign(r0C7A, r0C13, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0C7B->else_instructions;

                                             ir_expression *const r0C7D = nequal(r0C13, body.constant(0u));
                                             ir_expression *const r0C7E = expr(ir_unop_b2i, r0C7D);
                                             body.emit(assign(r0C7A, expr(ir_unop_i2u, r0C7E), 0x01));


                                          body.instructions = f0C7B_parent_instructions;
                                          body.emit(f0C7B);

                                          /* END IF */

                                          body.emit(assign(r0C6A, r0C7A, 0x01));

                                          body.emit(assign(r0C6B, body.constant(0u), 0x01));


                                       body.instructions = f0C77_parent_instructions;
                                       body.emit(f0C77);

                                       /* END IF */


                                    body.instructions = f0C75_parent_instructions;
                                    body.emit(f0C75);

                                    /* END IF */

                                    body.emit(assign(r0C6C, body.constant(0u), 0x01));


                                 body.instructions = f0C71_parent_instructions;
                                 body.emit(f0C71);

                                 /* END IF */

                                 ir_expression *const r0C7F = nequal(r0C68, body.constant(0u));
                                 ir_expression *const r0C80 = expr(ir_unop_b2i, r0C7F);
                                 ir_expression *const r0C81 = expr(ir_unop_i2u, r0C80);
                                 body.emit(assign(r0C6A, bit_or(r0C6A, r0C81), 0x01));


                              body.instructions = f0C6F_parent_instructions;
                              body.emit(f0C6F);

                              /* END IF */

                              body.emit(assign(r0C52, r0C6C, 0x01));

                              body.emit(assign(r0C53, r0C6B, 0x01));

                              body.emit(assign(r0C54, r0C6A, 0x01));

                              body.emit(assign(r0C51, body.constant(int(0)), 0x01));

                              body.emit(assign(r0C57, less(r0C6A, body.constant(0u)), 0x01));


                           body.instructions = f0C66_parent_instructions;
                           body.emit(f0C66);

                           /* END IF */


                        body.instructions = f0C63_parent_instructions;
                        body.emit(f0C63);

                        /* END IF */


                     body.instructions = f0C59_parent_instructions;
                     body.emit(f0C59);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0C82 = new(mem_ctx) ir_if(operand(r0C55).val);
                     exec_list *const f0C82_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C82->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0C83 = new(mem_ctx) ir_if(operand(r0C57).val);
                        exec_list *const f0C83_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C83->then_instructions;

                           ir_variable *const r0C84 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r0C84, add(r0C53, body.constant(1u)), 0x01));

                           ir_expression *const r0C85 = less(r0C84, r0C53);
                           ir_expression *const r0C86 = expr(ir_unop_b2i, r0C85);
                           ir_expression *const r0C87 = expr(ir_unop_i2u, r0C86);
                           body.emit(assign(r0C52, add(r0C52, r0C87), 0x01));

                           ir_expression *const r0C88 = equal(r0C54, body.constant(0u));
                           ir_expression *const r0C89 = expr(ir_unop_b2i, r0C88);
                           ir_expression *const r0C8A = expr(ir_unop_i2u, r0C89);
                           ir_expression *const r0C8B = add(r0C54, r0C8A);
                           ir_expression *const r0C8C = bit_and(r0C8B, body.constant(1u));
                           ir_expression *const r0C8D = expr(ir_unop_bit_not, r0C8C);
                           body.emit(assign(r0C53, bit_and(r0C84, r0C8D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C83->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C8F = bit_or(r0C52, r0C53);
                           ir_expression *const r0C90 = equal(r0C8F, body.constant(0u));
                           ir_if *f0C8E = new(mem_ctx) ir_if(operand(r0C90).val);
                           exec_list *const f0C8E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C8E->then_instructions;

                              body.emit(assign(r0C51, body.constant(int(0)), 0x01));


                           body.instructions = f0C8E_parent_instructions;
                           body.emit(f0C8E);

                           /* END IF */


                        body.instructions = f0C83_parent_instructions;
                        body.emit(f0C83);

                        /* END IF */

                        ir_variable *const r0C91 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0C91);
                        ir_expression *const r0C92 = lshift(r0999, body.constant(int(31)));
                        ir_expression *const r0C93 = expr(ir_unop_i2u, r0C51);
                        ir_expression *const r0C94 = lshift(r0C93, body.constant(int(20)));
                        ir_expression *const r0C95 = add(r0C92, r0C94);
                        body.emit(assign(r0C91, add(r0C95, r0C52), 0x02));

                        body.emit(assign(r0C91, r0C53, 0x01));

                        body.emit(assign(r0C56, r0C91, 0x03));

                        body.emit(assign(r0C55, body.constant(false), 0x01));


                     body.instructions = f0C82_parent_instructions;
                     body.emit(f0C82);

                     /* END IF */

                     body.emit(assign(r099A, r0C56, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0C0A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0C97 = less(r099F, r09A1);
                     ir_if *f0C96 = new(mem_ctx) ir_if(operand(r0C97).val);
                     exec_list *const f0C96_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C96->then_instructions;

                        ir_variable *const r0C98 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r0C99 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C99, sub(r09A1, r099F), 0x01));

                        ir_expression *const r0C9A = sub(r09A0, r099E);
                        ir_expression *const r0C9B = less(r09A1, r099F);
                        ir_expression *const r0C9C = expr(ir_unop_b2i, r0C9B);
                        ir_expression *const r0C9D = expr(ir_unop_i2u, r0C9C);
                        body.emit(assign(r0C98, sub(r0C9A, r0C9D), 0x01));

                        body.emit(assign(r09A2, add(r099D, body.constant(int(-1))), 0x01));

                        ir_variable *const r0C9E = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0C9E, add(r09A2, body.constant(int(-10))), 0x01));

                        ir_variable *const r0C9F = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0C9F, r0C98, 0x01));

                        ir_variable *const r0CA0 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0CA0, r0C99, 0x01));

                        ir_variable *const r0CA1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0CA1);
                        ir_variable *const r0CA2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0CA2);
                        /* IF CONDITION */
                        ir_expression *const r0CA4 = equal(r0C98, body.constant(0u));
                        ir_if *f0CA3 = new(mem_ctx) ir_if(operand(r0CA4).val);
                        exec_list *const f0CA3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CA3->then_instructions;

                           body.emit(assign(r0C9F, r0C99, 0x01));

                           body.emit(assign(r0CA0, body.constant(0u), 0x01));

                           body.emit(assign(r0C9E, add(r0C9E, body.constant(int(-32))), 0x01));


                        body.instructions = f0CA3_parent_instructions;
                        body.emit(f0CA3);

                        /* END IF */

                        ir_variable *const r0CA5 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r0CA5, r0C9F, 0x01));

                        ir_variable *const r0CA6 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r0CA7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0CA7);
                        /* IF CONDITION */
                        ir_expression *const r0CA9 = equal(r0C9F, body.constant(0u));
                        ir_if *f0CA8 = new(mem_ctx) ir_if(operand(r0CA9).val);
                        exec_list *const f0CA8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CA8->then_instructions;

                           body.emit(assign(r0CA6, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CA8->else_instructions;

                           body.emit(assign(r0CA7, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CAB = bit_and(r0C9F, body.constant(4294901760u));
                           ir_expression *const r0CAC = equal(r0CAB, body.constant(0u));
                           ir_if *f0CAA = new(mem_ctx) ir_if(operand(r0CAC).val);
                           exec_list *const f0CAA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAA->then_instructions;

                              body.emit(assign(r0CA7, body.constant(int(16)), 0x01));

                              body.emit(assign(r0CA5, lshift(r0C9F, body.constant(int(16))), 0x01));


                           body.instructions = f0CAA_parent_instructions;
                           body.emit(f0CAA);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CAE = bit_and(r0CA5, body.constant(4278190080u));
                           ir_expression *const r0CAF = equal(r0CAE, body.constant(0u));
                           ir_if *f0CAD = new(mem_ctx) ir_if(operand(r0CAF).val);
                           exec_list *const f0CAD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAD->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(8))), 0x01));

                              body.emit(assign(r0CA5, lshift(r0CA5, body.constant(int(8))), 0x01));


                           body.instructions = f0CAD_parent_instructions;
                           body.emit(f0CAD);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB1 = bit_and(r0CA5, body.constant(4026531840u));
                           ir_expression *const r0CB2 = equal(r0CB1, body.constant(0u));
                           ir_if *f0CB0 = new(mem_ctx) ir_if(operand(r0CB2).val);
                           exec_list *const f0CB0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB0->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(4))), 0x01));

                              body.emit(assign(r0CA5, lshift(r0CA5, body.constant(int(4))), 0x01));


                           body.instructions = f0CB0_parent_instructions;
                           body.emit(f0CB0);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB4 = bit_and(r0CA5, body.constant(3221225472u));
                           ir_expression *const r0CB5 = equal(r0CB4, body.constant(0u));
                           ir_if *f0CB3 = new(mem_ctx) ir_if(operand(r0CB5).val);
                           exec_list *const f0CB3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB3->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(2))), 0x01));

                              body.emit(assign(r0CA5, lshift(r0CA5, body.constant(int(2))), 0x01));


                           body.instructions = f0CB3_parent_instructions;
                           body.emit(f0CB3);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB7 = bit_and(r0CA5, body.constant(2147483648u));
                           ir_expression *const r0CB8 = equal(r0CB7, body.constant(0u));
                           ir_if *f0CB6 = new(mem_ctx) ir_if(operand(r0CB8).val);
                           exec_list *const f0CB6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB6->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(1))), 0x01));


                           body.instructions = f0CB6_parent_instructions;
                           body.emit(f0CB6);

                           /* END IF */

                           body.emit(assign(r0CA6, r0CA7, 0x01));


                        body.instructions = f0CA8_parent_instructions;
                        body.emit(f0CA8);

                        /* END IF */

                        body.emit(assign(r0CA2, add(r0CA6, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CBA = lequal(body.constant(int(0)), r0CA2);
                        ir_if *f0CB9 = new(mem_ctx) ir_if(operand(r0CBA).val);
                        exec_list *const f0CB9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CB9->then_instructions;

                           body.emit(assign(r0CA1, body.constant(0u), 0x01));

                           ir_variable *const r0CBB = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0CBB, lshift(r0CA0, r0CA2), 0x01));

                           ir_variable *const r0CBC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CBE = equal(r0CA2, body.constant(int(0)));
                           ir_if *f0CBD = new(mem_ctx) ir_if(operand(r0CBE).val);
                           exec_list *const f0CBD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CBD->then_instructions;

                              body.emit(assign(r0CBC, r0C9F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CBD->else_instructions;

                              ir_expression *const r0CBF = lshift(r0C9F, r0CA2);
                              ir_expression *const r0CC0 = neg(r0CA2);
                              ir_expression *const r0CC1 = bit_and(r0CC0, body.constant(int(31)));
                              ir_expression *const r0CC2 = rshift(r0CA0, r0CC1);
                              body.emit(assign(r0CBC, bit_or(r0CBF, r0CC2), 0x01));


                           body.instructions = f0CBD_parent_instructions;
                           body.emit(f0CBD);

                           /* END IF */

                           body.emit(assign(r0C9F, r0CBC, 0x01));

                           body.emit(assign(r0CA0, r0CBB, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CB9->else_instructions;

                           ir_variable *const r0CC3 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0CC3, body.constant(0u), 0x01));

                           ir_variable *const r0CC4 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0CC4, neg(r0CA2), 0x01));

                           ir_variable *const r0CC5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0CC5);
                           ir_variable *const r0CC6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0CC6);
                           ir_variable *const r0CC7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0CC7);
                           ir_variable *const r0CC8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0CC9 = neg(r0CC4);
                           body.emit(assign(r0CC8, bit_and(r0CC9, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CCB = equal(r0CC4, body.constant(int(0)));
                           ir_if *f0CCA = new(mem_ctx) ir_if(operand(r0CCB).val);
                           exec_list *const f0CCA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CCA->then_instructions;

                              body.emit(assign(r0CC5, r0CC3, 0x01));

                              body.emit(assign(r0CC6, r0CA0, 0x01));

                              body.emit(assign(r0CC7, r0C9F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CCA->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CCD = less(r0CC4, body.constant(int(32)));
                              ir_if *f0CCC = new(mem_ctx) ir_if(operand(r0CCD).val);
                              exec_list *const f0CCC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CCC->then_instructions;

                                 body.emit(assign(r0CC5, lshift(r0CA0, r0CC8), 0x01));

                                 ir_expression *const r0CCE = lshift(r0C9F, r0CC8);
                                 ir_expression *const r0CCF = rshift(r0CA0, r0CC4);
                                 body.emit(assign(r0CC6, bit_or(r0CCE, r0CCF), 0x01));

                                 body.emit(assign(r0CC7, rshift(r0C9F, r0CC4), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CCC->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0CD1 = equal(r0CC4, body.constant(int(32)));
                                 ir_if *f0CD0 = new(mem_ctx) ir_if(operand(r0CD1).val);
                                 exec_list *const f0CD0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CD0->then_instructions;

                                    body.emit(assign(r0CC5, r0CA0, 0x01));

                                    body.emit(assign(r0CC6, r0C9F, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CD0->else_instructions;

                                    body.emit(assign(r0CC3, bit_or(body.constant(0u), r0CA0), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0CD3 = less(r0CC4, body.constant(int(64)));
                                    ir_if *f0CD2 = new(mem_ctx) ir_if(operand(r0CD3).val);
                                    exec_list *const f0CD2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CD2->then_instructions;

                                       body.emit(assign(r0CC5, lshift(r0C9F, r0CC8), 0x01));

                                       ir_expression *const r0CD4 = bit_and(r0CC4, body.constant(int(31)));
                                       body.emit(assign(r0CC6, rshift(r0C9F, r0CD4), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CD2->else_instructions;

                                       ir_variable *const r0CD5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0CD7 = equal(r0CC4, body.constant(int(64)));
                                       ir_if *f0CD6 = new(mem_ctx) ir_if(operand(r0CD7).val);
                                       exec_list *const f0CD6_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0CD6->then_instructions;

                                          body.emit(assign(r0CD5, r0C9F, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0CD6->else_instructions;

                                          ir_expression *const r0CD8 = nequal(r0C9F, body.constant(0u));
                                          ir_expression *const r0CD9 = expr(ir_unop_b2i, r0CD8);
                                          body.emit(assign(r0CD5, expr(ir_unop_i2u, r0CD9), 0x01));


                                       body.instructions = f0CD6_parent_instructions;
                                       body.emit(f0CD6);

                                       /* END IF */

                                       body.emit(assign(r0CC5, r0CD5, 0x01));

                                       body.emit(assign(r0CC6, body.constant(0u), 0x01));


                                    body.instructions = f0CD2_parent_instructions;
                                    body.emit(f0CD2);

                                    /* END IF */


                                 body.instructions = f0CD0_parent_instructions;
                                 body.emit(f0CD0);

                                 /* END IF */

                                 body.emit(assign(r0CC7, body.constant(0u), 0x01));


                              body.instructions = f0CCC_parent_instructions;
                              body.emit(f0CCC);

                              /* END IF */

                              ir_expression *const r0CDA = nequal(r0CC3, body.constant(0u));
                              ir_expression *const r0CDB = expr(ir_unop_b2i, r0CDA);
                              ir_expression *const r0CDC = expr(ir_unop_i2u, r0CDB);
                              body.emit(assign(r0CC5, bit_or(r0CC5, r0CDC), 0x01));


                           body.instructions = f0CCA_parent_instructions;
                           body.emit(f0CCA);

                           /* END IF */

                           body.emit(assign(r0C9F, r0CC7, 0x01));

                           body.emit(assign(r0CA0, r0CC6, 0x01));

                           body.emit(assign(r0CA1, r0CC5, 0x01));


                        body.instructions = f0CB9_parent_instructions;
                        body.emit(f0CB9);

                        /* END IF */

                        body.emit(assign(r0C9E, sub(r0C9E, r0CA2), 0x01));

                        ir_variable *const r0CDD = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0CDD, r0C9E, 0x01));

                        ir_variable *const r0CDE = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0CDE, r0C9F, 0x01));

                        ir_variable *const r0CDF = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0CDF, r0CA0, 0x01));

                        ir_variable *const r0CE0 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r0CE0, r0CA1, 0x01));

                        ir_variable *const r0CE1 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r0CE1, body.constant(true), 0x01));

                        ir_variable *const r0CE2 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r0CE3 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r0CE3);
                        ir_expression *const r0CE4 = expr(ir_unop_u2i, r0CA1);
                        body.emit(assign(r0CE3, less(r0CE4, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CE6 = lequal(body.constant(int(2045)), r0C9E);
                        ir_if *f0CE5 = new(mem_ctx) ir_if(operand(r0CE6).val);
                        exec_list *const f0CE5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CE5->then_instructions;

                           ir_variable *const r0CE7 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CE9 = less(body.constant(int(2045)), r0C9E);
                           ir_if *f0CE8 = new(mem_ctx) ir_if(operand(r0CE9).val);
                           exec_list *const f0CE8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CE8->then_instructions;

                              body.emit(assign(r0CE7, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CE8->else_instructions;

                              ir_variable *const r0CEA = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0CEC = equal(r0C9E, body.constant(int(2045)));
                              ir_if *f0CEB = new(mem_ctx) ir_if(operand(r0CEC).val);
                              exec_list *const f0CEB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CEB->then_instructions;

                                 ir_expression *const r0CED = equal(body.constant(2097151u), r0C9F);
                                 ir_expression *const r0CEE = equal(body.constant(4294967295u), r0CA0);
                                 body.emit(assign(r0CEA, logic_and(r0CED, r0CEE), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CEB->else_instructions;

                                 body.emit(assign(r0CEA, body.constant(false), 0x01));


                              body.instructions = f0CEB_parent_instructions;
                              body.emit(f0CEB);

                              /* END IF */

                              body.emit(assign(r0CE7, logic_and(r0CEA, r0CE3), 0x01));


                           body.instructions = f0CE8_parent_instructions;
                           body.emit(f0CE8);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0CEF = new(mem_ctx) ir_if(operand(r0CE7).val);
                           exec_list *const f0CEF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CEF->then_instructions;

                              ir_variable *const r0CF0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0CF0);
                              ir_expression *const r0CF1 = lshift(r0999, body.constant(int(31)));
                              body.emit(assign(r0CF0, add(r0CF1, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r0CF0, body.constant(0u), 0x01));

                              body.emit(assign(r0CE2, r0CF0, 0x03));

                              body.emit(assign(r0CE1, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CEF->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CF3 = less(r0C9E, body.constant(int(0)));
                              ir_if *f0CF2 = new(mem_ctx) ir_if(operand(r0CF3).val);
                              exec_list *const f0CF2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CF2->then_instructions;

                                 ir_variable *const r0CF4 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r0CF4, r0CA1, 0x01));

                                 ir_variable *const r0CF5 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r0CF5, neg(r0C9E), 0x01));

                                 ir_variable *const r0CF6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r0CF6);
                                 ir_variable *const r0CF7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r0CF7);
                                 ir_variable *const r0CF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r0CF8);
                                 ir_variable *const r0CF9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r0CFA = neg(r0CF5);
                                 body.emit(assign(r0CF9, bit_and(r0CFA, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0CFC = equal(r0CF5, body.constant(int(0)));
                                 ir_if *f0CFB = new(mem_ctx) ir_if(operand(r0CFC).val);
                                 exec_list *const f0CFB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CFB->then_instructions;

                                    body.emit(assign(r0CF6, r0CA1, 0x01));

                                    body.emit(assign(r0CF7, r0CA0, 0x01));

                                    body.emit(assign(r0CF8, r0C9F, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CFB->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0CFE = less(r0CF5, body.constant(int(32)));
                                    ir_if *f0CFD = new(mem_ctx) ir_if(operand(r0CFE).val);
                                    exec_list *const f0CFD_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CFD->then_instructions;

                                       body.emit(assign(r0CF6, lshift(r0CA0, r0CF9), 0x01));

                                       ir_expression *const r0CFF = lshift(r0C9F, r0CF9);
                                       ir_expression *const r0D00 = rshift(r0CA0, r0CF5);
                                       body.emit(assign(r0CF7, bit_or(r0CFF, r0D00), 0x01));

                                       body.emit(assign(r0CF8, rshift(r0C9F, r0CF5), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CFD->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0D02 = equal(r0CF5, body.constant(int(32)));
                                       ir_if *f0D01 = new(mem_ctx) ir_if(operand(r0D02).val);
                                       exec_list *const f0D01_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D01->then_instructions;

                                          body.emit(assign(r0CF6, r0CA0, 0x01));

                                          body.emit(assign(r0CF7, r0C9F, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D01->else_instructions;

                                          body.emit(assign(r0CF4, bit_or(r0CA1, r0CA0), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r0D04 = less(r0CF5, body.constant(int(64)));
                                          ir_if *f0D03 = new(mem_ctx) ir_if(operand(r0D04).val);
                                          exec_list *const f0D03_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D03->then_instructions;

                                             body.emit(assign(r0CF6, lshift(r0C9F, r0CF9), 0x01));

                                             ir_expression *const r0D05 = bit_and(r0CF5, body.constant(int(31)));
                                             body.emit(assign(r0CF7, rshift(r0C9F, r0D05), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D03->else_instructions;

                                             ir_variable *const r0D06 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r0D08 = equal(r0CF5, body.constant(int(64)));
                                             ir_if *f0D07 = new(mem_ctx) ir_if(operand(r0D08).val);
                                             exec_list *const f0D07_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D07->then_instructions;

                                                body.emit(assign(r0D06, r0C9F, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D07->else_instructions;

                                                ir_expression *const r0D09 = nequal(r0C9F, body.constant(0u));
                                                ir_expression *const r0D0A = expr(ir_unop_b2i, r0D09);
                                                body.emit(assign(r0D06, expr(ir_unop_i2u, r0D0A), 0x01));


                                             body.instructions = f0D07_parent_instructions;
                                             body.emit(f0D07);

                                             /* END IF */

                                             body.emit(assign(r0CF6, r0D06, 0x01));

                                             body.emit(assign(r0CF7, body.constant(0u), 0x01));


                                          body.instructions = f0D03_parent_instructions;
                                          body.emit(f0D03);

                                          /* END IF */


                                       body.instructions = f0D01_parent_instructions;
                                       body.emit(f0D01);

                                       /* END IF */

                                       body.emit(assign(r0CF8, body.constant(0u), 0x01));


                                    body.instructions = f0CFD_parent_instructions;
                                    body.emit(f0CFD);

                                    /* END IF */

                                    ir_expression *const r0D0B = nequal(r0CF4, body.constant(0u));
                                    ir_expression *const r0D0C = expr(ir_unop_b2i, r0D0B);
                                    ir_expression *const r0D0D = expr(ir_unop_i2u, r0D0C);
                                    body.emit(assign(r0CF6, bit_or(r0CF6, r0D0D), 0x01));


                                 body.instructions = f0CFB_parent_instructions;
                                 body.emit(f0CFB);

                                 /* END IF */

                                 body.emit(assign(r0CDE, r0CF8, 0x01));

                                 body.emit(assign(r0CDF, r0CF7, 0x01));

                                 body.emit(assign(r0CE0, r0CF6, 0x01));

                                 body.emit(assign(r0CDD, body.constant(int(0)), 0x01));

                                 body.emit(assign(r0CE3, less(r0CF6, body.constant(0u)), 0x01));


                              body.instructions = f0CF2_parent_instructions;
                              body.emit(f0CF2);

                              /* END IF */


                           body.instructions = f0CEF_parent_instructions;
                           body.emit(f0CEF);

                           /* END IF */


                        body.instructions = f0CE5_parent_instructions;
                        body.emit(f0CE5);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0D0E = new(mem_ctx) ir_if(operand(r0CE1).val);
                        exec_list *const f0D0E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D0E->then_instructions;

                           /* IF CONDITION */
                           ir_if *f0D0F = new(mem_ctx) ir_if(operand(r0CE3).val);
                           exec_list *const f0D0F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D0F->then_instructions;

                              ir_variable *const r0D10 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r0D10, add(r0CDF, body.constant(1u)), 0x01));

                              ir_expression *const r0D11 = less(r0D10, r0CDF);
                              ir_expression *const r0D12 = expr(ir_unop_b2i, r0D11);
                              ir_expression *const r0D13 = expr(ir_unop_i2u, r0D12);
                              body.emit(assign(r0CDE, add(r0CDE, r0D13), 0x01));

                              ir_expression *const r0D14 = equal(r0CE0, body.constant(0u));
                              ir_expression *const r0D15 = expr(ir_unop_b2i, r0D14);
                              ir_expression *const r0D16 = expr(ir_unop_i2u, r0D15);
                              ir_expression *const r0D17 = add(r0CE0, r0D16);
                              ir_expression *const r0D18 = bit_and(r0D17, body.constant(1u));
                              ir_expression *const r0D19 = expr(ir_unop_bit_not, r0D18);
                              body.emit(assign(r0CDF, bit_and(r0D10, r0D19), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D0F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0D1B = bit_or(r0CDE, r0CDF);
                              ir_expression *const r0D1C = equal(r0D1B, body.constant(0u));
                              ir_if *f0D1A = new(mem_ctx) ir_if(operand(r0D1C).val);
                              exec_list *const f0D1A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D1A->then_instructions;

                                 body.emit(assign(r0CDD, body.constant(int(0)), 0x01));


                              body.instructions = f0D1A_parent_instructions;
                              body.emit(f0D1A);

                              /* END IF */


                           body.instructions = f0D0F_parent_instructions;
                           body.emit(f0D0F);

                           /* END IF */

                           ir_variable *const r0D1D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0D1D);
                           ir_expression *const r0D1E = lshift(r0999, body.constant(int(31)));
                           ir_expression *const r0D1F = expr(ir_unop_i2u, r0CDD);
                           ir_expression *const r0D20 = lshift(r0D1F, body.constant(int(20)));
                           ir_expression *const r0D21 = add(r0D1E, r0D20);
                           body.emit(assign(r0D1D, add(r0D21, r0CDE), 0x02));

                           body.emit(assign(r0D1D, r0CDF, 0x01));

                           body.emit(assign(r0CE2, r0D1D, 0x03));

                           body.emit(assign(r0CE1, body.constant(false), 0x01));


                        body.instructions = f0D0E_parent_instructions;
                        body.emit(f0D0E);

                        /* END IF */

                        body.emit(assign(r099A, r0CE2, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C96->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0D23 = less(r09A1, r099F);
                        ir_if *f0D22 = new(mem_ctx) ir_if(operand(r0D23).val);
                        exec_list *const f0D22_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D22->then_instructions;

                           ir_variable *const r0D24 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r0D25 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0D25, sub(r099F, r09A1), 0x01));

                           ir_expression *const r0D26 = sub(r099E, r09A0);
                           ir_expression *const r0D27 = less(r099F, r09A1);
                           ir_expression *const r0D28 = expr(ir_unop_b2i, r0D27);
                           ir_expression *const r0D29 = expr(ir_unop_i2u, r0D28);
                           body.emit(assign(r0D24, sub(r0D26, r0D29), 0x01));

                           body.emit(assign(r0999, bit_xor(r0999, body.constant(1u)), 0x01));

                           body.emit(assign(r09A2, add(r099C, body.constant(int(-1))), 0x01));

                           ir_variable *const r0D2A = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D2A, add(r09A2, body.constant(int(-10))), 0x01));

                           ir_variable *const r0D2B = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D2B, r0D24, 0x01));

                           ir_variable *const r0D2C = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D2C, r0D25, 0x01));

                           ir_variable *const r0D2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r0D2D);
                           ir_variable *const r0D2E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D2E);
                           /* IF CONDITION */
                           ir_expression *const r0D30 = equal(r0D24, body.constant(0u));
                           ir_if *f0D2F = new(mem_ctx) ir_if(operand(r0D30).val);
                           exec_list *const f0D2F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D2F->then_instructions;

                              body.emit(assign(r0D2B, r0D25, 0x01));

                              body.emit(assign(r0D2C, body.constant(0u), 0x01));

                              body.emit(assign(r0D2A, add(r0D2A, body.constant(int(-32))), 0x01));


                           body.instructions = f0D2F_parent_instructions;
                           body.emit(f0D2F);

                           /* END IF */

                           ir_variable *const r0D31 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r0D31, r0D2B, 0x01));

                           ir_variable *const r0D32 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r0D33 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D33);
                           /* IF CONDITION */
                           ir_expression *const r0D35 = equal(r0D2B, body.constant(0u));
                           ir_if *f0D34 = new(mem_ctx) ir_if(operand(r0D35).val);
                           exec_list *const f0D34_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D34->then_instructions;

                              body.emit(assign(r0D32, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D34->else_instructions;

                              body.emit(assign(r0D33, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D37 = bit_and(r0D2B, body.constant(4294901760u));
                              ir_expression *const r0D38 = equal(r0D37, body.constant(0u));
                              ir_if *f0D36 = new(mem_ctx) ir_if(operand(r0D38).val);
                              exec_list *const f0D36_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D36->then_instructions;

                                 body.emit(assign(r0D33, body.constant(int(16)), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D2B, body.constant(int(16))), 0x01));


                              body.instructions = f0D36_parent_instructions;
                              body.emit(f0D36);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D3A = bit_and(r0D31, body.constant(4278190080u));
                              ir_expression *const r0D3B = equal(r0D3A, body.constant(0u));
                              ir_if *f0D39 = new(mem_ctx) ir_if(operand(r0D3B).val);
                              exec_list *const f0D39_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D39->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(8))), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D31, body.constant(int(8))), 0x01));


                              body.instructions = f0D39_parent_instructions;
                              body.emit(f0D39);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D3D = bit_and(r0D31, body.constant(4026531840u));
                              ir_expression *const r0D3E = equal(r0D3D, body.constant(0u));
                              ir_if *f0D3C = new(mem_ctx) ir_if(operand(r0D3E).val);
                              exec_list *const f0D3C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D3C->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(4))), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D31, body.constant(int(4))), 0x01));


                              body.instructions = f0D3C_parent_instructions;
                              body.emit(f0D3C);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D40 = bit_and(r0D31, body.constant(3221225472u));
                              ir_expression *const r0D41 = equal(r0D40, body.constant(0u));
                              ir_if *f0D3F = new(mem_ctx) ir_if(operand(r0D41).val);
                              exec_list *const f0D3F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D3F->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(2))), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D31, body.constant(int(2))), 0x01));


                              body.instructions = f0D3F_parent_instructions;
                              body.emit(f0D3F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D43 = bit_and(r0D31, body.constant(2147483648u));
                              ir_expression *const r0D44 = equal(r0D43, body.constant(0u));
                              ir_if *f0D42 = new(mem_ctx) ir_if(operand(r0D44).val);
                              exec_list *const f0D42_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D42->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(1))), 0x01));


                              body.instructions = f0D42_parent_instructions;
                              body.emit(f0D42);

                              /* END IF */

                              body.emit(assign(r0D32, r0D33, 0x01));


                           body.instructions = f0D34_parent_instructions;
                           body.emit(f0D34);

                           /* END IF */

                           body.emit(assign(r0D2E, add(r0D32, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D46 = lequal(body.constant(int(0)), r0D2E);
                           ir_if *f0D45 = new(mem_ctx) ir_if(operand(r0D46).val);
                           exec_list *const f0D45_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D45->then_instructions;

                              body.emit(assign(r0D2D, body.constant(0u), 0x01));

                              ir_variable *const r0D47 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r0D47, lshift(r0D2C, r0D2E), 0x01));

                              ir_variable *const r0D48 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D4A = equal(r0D2E, body.constant(int(0)));
                              ir_if *f0D49 = new(mem_ctx) ir_if(operand(r0D4A).val);
                              exec_list *const f0D49_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D49->then_instructions;

                                 body.emit(assign(r0D48, r0D2B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D49->else_instructions;

                                 ir_expression *const r0D4B = lshift(r0D2B, r0D2E);
                                 ir_expression *const r0D4C = neg(r0D2E);
                                 ir_expression *const r0D4D = bit_and(r0D4C, body.constant(int(31)));
                                 ir_expression *const r0D4E = rshift(r0D2C, r0D4D);
                                 body.emit(assign(r0D48, bit_or(r0D4B, r0D4E), 0x01));


                              body.instructions = f0D49_parent_instructions;
                              body.emit(f0D49);

                              /* END IF */

                              body.emit(assign(r0D2B, r0D48, 0x01));

                              body.emit(assign(r0D2C, r0D47, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D45->else_instructions;

                              ir_variable *const r0D4F = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0D4F, body.constant(0u), 0x01));

                              ir_variable *const r0D50 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0D50, neg(r0D2E), 0x01));

                              ir_variable *const r0D51 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0D51);
                              ir_variable *const r0D52 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0D52);
                              ir_variable *const r0D53 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0D53);
                              ir_variable *const r0D54 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0D55 = neg(r0D50);
                              body.emit(assign(r0D54, bit_and(r0D55, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D57 = equal(r0D50, body.constant(int(0)));
                              ir_if *f0D56 = new(mem_ctx) ir_if(operand(r0D57).val);
                              exec_list *const f0D56_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D56->then_instructions;

                                 body.emit(assign(r0D51, r0D4F, 0x01));

                                 body.emit(assign(r0D52, r0D2C, 0x01));

                                 body.emit(assign(r0D53, r0D2B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D56->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D59 = less(r0D50, body.constant(int(32)));
                                 ir_if *f0D58 = new(mem_ctx) ir_if(operand(r0D59).val);
                                 exec_list *const f0D58_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D58->then_instructions;

                                    body.emit(assign(r0D51, lshift(r0D2C, r0D54), 0x01));

                                    ir_expression *const r0D5A = lshift(r0D2B, r0D54);
                                    ir_expression *const r0D5B = rshift(r0D2C, r0D50);
                                    body.emit(assign(r0D52, bit_or(r0D5A, r0D5B), 0x01));

                                    body.emit(assign(r0D53, rshift(r0D2B, r0D50), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D58->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0D5D = equal(r0D50, body.constant(int(32)));
                                    ir_if *f0D5C = new(mem_ctx) ir_if(operand(r0D5D).val);
                                    exec_list *const f0D5C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D5C->then_instructions;

                                       body.emit(assign(r0D51, r0D2C, 0x01));

                                       body.emit(assign(r0D52, r0D2B, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D5C->else_instructions;

                                       body.emit(assign(r0D4F, bit_or(body.constant(0u), r0D2C), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0D5F = less(r0D50, body.constant(int(64)));
                                       ir_if *f0D5E = new(mem_ctx) ir_if(operand(r0D5F).val);
                                       exec_list *const f0D5E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D5E->then_instructions;

                                          body.emit(assign(r0D51, lshift(r0D2B, r0D54), 0x01));

                                          ir_expression *const r0D60 = bit_and(r0D50, body.constant(int(31)));
                                          body.emit(assign(r0D52, rshift(r0D2B, r0D60), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D5E->else_instructions;

                                          ir_variable *const r0D61 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0D63 = equal(r0D50, body.constant(int(64)));
                                          ir_if *f0D62 = new(mem_ctx) ir_if(operand(r0D63).val);
                                          exec_list *const f0D62_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D62->then_instructions;

                                             body.emit(assign(r0D61, r0D2B, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D62->else_instructions;

                                             ir_expression *const r0D64 = nequal(r0D2B, body.constant(0u));
                                             ir_expression *const r0D65 = expr(ir_unop_b2i, r0D64);
                                             body.emit(assign(r0D61, expr(ir_unop_i2u, r0D65), 0x01));


                                          body.instructions = f0D62_parent_instructions;
                                          body.emit(f0D62);

                                          /* END IF */

                                          body.emit(assign(r0D51, r0D61, 0x01));

                                          body.emit(assign(r0D52, body.constant(0u), 0x01));


                                       body.instructions = f0D5E_parent_instructions;
                                       body.emit(f0D5E);

                                       /* END IF */


                                    body.instructions = f0D5C_parent_instructions;
                                    body.emit(f0D5C);

                                    /* END IF */

                                    body.emit(assign(r0D53, body.constant(0u), 0x01));


                                 body.instructions = f0D58_parent_instructions;
                                 body.emit(f0D58);

                                 /* END IF */

                                 ir_expression *const r0D66 = nequal(r0D4F, body.constant(0u));
                                 ir_expression *const r0D67 = expr(ir_unop_b2i, r0D66);
                                 ir_expression *const r0D68 = expr(ir_unop_i2u, r0D67);
                                 body.emit(assign(r0D51, bit_or(r0D51, r0D68), 0x01));


                              body.instructions = f0D56_parent_instructions;
                              body.emit(f0D56);

                              /* END IF */

                              body.emit(assign(r0D2B, r0D53, 0x01));

                              body.emit(assign(r0D2C, r0D52, 0x01));

                              body.emit(assign(r0D2D, r0D51, 0x01));


                           body.instructions = f0D45_parent_instructions;
                           body.emit(f0D45);

                           /* END IF */

                           body.emit(assign(r0D2A, sub(r0D2A, r0D2E), 0x01));

                           ir_variable *const r0D69 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D69, r0D2A, 0x01));

                           ir_variable *const r0D6A = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D6A, r0D2B, 0x01));

                           ir_variable *const r0D6B = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D6B, r0D2C, 0x01));

                           ir_variable *const r0D6C = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r0D6C, r0D2D, 0x01));

                           ir_variable *const r0D6D = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r0D6D, body.constant(true), 0x01));

                           ir_variable *const r0D6E = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r0D6F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r0D6F);
                           ir_expression *const r0D70 = expr(ir_unop_u2i, r0D2D);
                           body.emit(assign(r0D6F, less(r0D70, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D72 = lequal(body.constant(int(2045)), r0D2A);
                           ir_if *f0D71 = new(mem_ctx) ir_if(operand(r0D72).val);
                           exec_list *const f0D71_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D71->then_instructions;

                              ir_variable *const r0D73 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D75 = less(body.constant(int(2045)), r0D2A);
                              ir_if *f0D74 = new(mem_ctx) ir_if(operand(r0D75).val);
                              exec_list *const f0D74_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D74->then_instructions;

                                 body.emit(assign(r0D73, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D74->else_instructions;

                                 ir_variable *const r0D76 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0D78 = equal(r0D2A, body.constant(int(2045)));
                                 ir_if *f0D77 = new(mem_ctx) ir_if(operand(r0D78).val);
                                 exec_list *const f0D77_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D77->then_instructions;

                                    ir_expression *const r0D79 = equal(body.constant(2097151u), r0D2B);
                                    ir_expression *const r0D7A = equal(body.constant(4294967295u), r0D2C);
                                    body.emit(assign(r0D76, logic_and(r0D79, r0D7A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D77->else_instructions;

                                    body.emit(assign(r0D76, body.constant(false), 0x01));


                                 body.instructions = f0D77_parent_instructions;
                                 body.emit(f0D77);

                                 /* END IF */

                                 body.emit(assign(r0D73, logic_and(r0D76, r0D6F), 0x01));


                              body.instructions = f0D74_parent_instructions;
                              body.emit(f0D74);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f0D7B = new(mem_ctx) ir_if(operand(r0D73).val);
                              exec_list *const f0D7B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D7B->then_instructions;

                                 ir_variable *const r0D7C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r0D7C);
                                 ir_expression *const r0D7D = lshift(r0999, body.constant(int(31)));
                                 body.emit(assign(r0D7C, add(r0D7D, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r0D7C, body.constant(0u), 0x01));

                                 body.emit(assign(r0D6E, r0D7C, 0x03));

                                 body.emit(assign(r0D6D, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D7B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D7F = less(r0D2A, body.constant(int(0)));
                                 ir_if *f0D7E = new(mem_ctx) ir_if(operand(r0D7F).val);
                                 exec_list *const f0D7E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D7E->then_instructions;

                                    ir_variable *const r0D80 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r0D80, r0D2D, 0x01));

                                    ir_variable *const r0D81 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r0D81, neg(r0D2A), 0x01));

                                    ir_variable *const r0D82 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r0D82);
                                    ir_variable *const r0D83 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r0D83);
                                    ir_variable *const r0D84 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r0D84);
                                    ir_variable *const r0D85 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r0D86 = neg(r0D81);
                                    body.emit(assign(r0D85, bit_and(r0D86, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0D88 = equal(r0D81, body.constant(int(0)));
                                    ir_if *f0D87 = new(mem_ctx) ir_if(operand(r0D88).val);
                                    exec_list *const f0D87_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D87->then_instructions;

                                       body.emit(assign(r0D82, r0D2D, 0x01));

                                       body.emit(assign(r0D83, r0D2C, 0x01));

                                       body.emit(assign(r0D84, r0D2B, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D87->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0D8A = less(r0D81, body.constant(int(32)));
                                       ir_if *f0D89 = new(mem_ctx) ir_if(operand(r0D8A).val);
                                       exec_list *const f0D89_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D89->then_instructions;

                                          body.emit(assign(r0D82, lshift(r0D2C, r0D85), 0x01));

                                          ir_expression *const r0D8B = lshift(r0D2B, r0D85);
                                          ir_expression *const r0D8C = rshift(r0D2C, r0D81);
                                          body.emit(assign(r0D83, bit_or(r0D8B, r0D8C), 0x01));

                                          body.emit(assign(r0D84, rshift(r0D2B, r0D81), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D89->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r0D8E = equal(r0D81, body.constant(int(32)));
                                          ir_if *f0D8D = new(mem_ctx) ir_if(operand(r0D8E).val);
                                          exec_list *const f0D8D_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D8D->then_instructions;

                                             body.emit(assign(r0D82, r0D2C, 0x01));

                                             body.emit(assign(r0D83, r0D2B, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D8D->else_instructions;

                                             body.emit(assign(r0D80, bit_or(r0D2D, r0D2C), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r0D90 = less(r0D81, body.constant(int(64)));
                                             ir_if *f0D8F = new(mem_ctx) ir_if(operand(r0D90).val);
                                             exec_list *const f0D8F_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D8F->then_instructions;

                                                body.emit(assign(r0D82, lshift(r0D2B, r0D85), 0x01));

                                                ir_expression *const r0D91 = bit_and(r0D81, body.constant(int(31)));
                                                body.emit(assign(r0D83, rshift(r0D2B, r0D91), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D8F->else_instructions;

                                                ir_variable *const r0D92 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r0D94 = equal(r0D81, body.constant(int(64)));
                                                ir_if *f0D93 = new(mem_ctx) ir_if(operand(r0D94).val);
                                                exec_list *const f0D93_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f0D93->then_instructions;

                                                   body.emit(assign(r0D92, r0D2B, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f0D93->else_instructions;

                                                   ir_expression *const r0D95 = nequal(r0D2B, body.constant(0u));
                                                   ir_expression *const r0D96 = expr(ir_unop_b2i, r0D95);
                                                   body.emit(assign(r0D92, expr(ir_unop_i2u, r0D96), 0x01));


                                                body.instructions = f0D93_parent_instructions;
                                                body.emit(f0D93);

                                                /* END IF */

                                                body.emit(assign(r0D82, r0D92, 0x01));

                                                body.emit(assign(r0D83, body.constant(0u), 0x01));


                                             body.instructions = f0D8F_parent_instructions;
                                             body.emit(f0D8F);

                                             /* END IF */


                                          body.instructions = f0D8D_parent_instructions;
                                          body.emit(f0D8D);

                                          /* END IF */

                                          body.emit(assign(r0D84, body.constant(0u), 0x01));


                                       body.instructions = f0D89_parent_instructions;
                                       body.emit(f0D89);

                                       /* END IF */

                                       ir_expression *const r0D97 = nequal(r0D80, body.constant(0u));
                                       ir_expression *const r0D98 = expr(ir_unop_b2i, r0D97);
                                       ir_expression *const r0D99 = expr(ir_unop_i2u, r0D98);
                                       body.emit(assign(r0D82, bit_or(r0D82, r0D99), 0x01));


                                    body.instructions = f0D87_parent_instructions;
                                    body.emit(f0D87);

                                    /* END IF */

                                    body.emit(assign(r0D6A, r0D84, 0x01));

                                    body.emit(assign(r0D6B, r0D83, 0x01));

                                    body.emit(assign(r0D6C, r0D82, 0x01));

                                    body.emit(assign(r0D69, body.constant(int(0)), 0x01));

                                    body.emit(assign(r0D6F, less(r0D82, body.constant(0u)), 0x01));


                                 body.instructions = f0D7E_parent_instructions;
                                 body.emit(f0D7E);

                                 /* END IF */


                              body.instructions = f0D7B_parent_instructions;
                              body.emit(f0D7B);

                              /* END IF */


                           body.instructions = f0D71_parent_instructions;
                           body.emit(f0D71);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0D9A = new(mem_ctx) ir_if(operand(r0D6D).val);
                           exec_list *const f0D9A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D9A->then_instructions;

                              /* IF CONDITION */
                              ir_if *f0D9B = new(mem_ctx) ir_if(operand(r0D6F).val);
                              exec_list *const f0D9B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D9B->then_instructions;

                                 ir_variable *const r0D9C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r0D9C, add(r0D6B, body.constant(1u)), 0x01));

                                 ir_expression *const r0D9D = less(r0D9C, r0D6B);
                                 ir_expression *const r0D9E = expr(ir_unop_b2i, r0D9D);
                                 ir_expression *const r0D9F = expr(ir_unop_i2u, r0D9E);
                                 body.emit(assign(r0D6A, add(r0D6A, r0D9F), 0x01));

                                 ir_expression *const r0DA0 = equal(r0D6C, body.constant(0u));
                                 ir_expression *const r0DA1 = expr(ir_unop_b2i, r0DA0);
                                 ir_expression *const r0DA2 = expr(ir_unop_i2u, r0DA1);
                                 ir_expression *const r0DA3 = add(r0D6C, r0DA2);
                                 ir_expression *const r0DA4 = bit_and(r0DA3, body.constant(1u));
                                 ir_expression *const r0DA5 = expr(ir_unop_bit_not, r0DA4);
                                 body.emit(assign(r0D6B, bit_and(r0D9C, r0DA5), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D9B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0DA7 = bit_or(r0D6A, r0D6B);
                                 ir_expression *const r0DA8 = equal(r0DA7, body.constant(0u));
                                 ir_if *f0DA6 = new(mem_ctx) ir_if(operand(r0DA8).val);
                                 exec_list *const f0DA6_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0DA6->then_instructions;

                                    body.emit(assign(r0D69, body.constant(int(0)), 0x01));


                                 body.instructions = f0DA6_parent_instructions;
                                 body.emit(f0DA6);

                                 /* END IF */


                              body.instructions = f0D9B_parent_instructions;
                              body.emit(f0D9B);

                              /* END IF */

                              ir_variable *const r0DA9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0DA9);
                              ir_expression *const r0DAA = lshift(r0999, body.constant(int(31)));
                              ir_expression *const r0DAB = expr(ir_unop_i2u, r0D69);
                              ir_expression *const r0DAC = lshift(r0DAB, body.constant(int(20)));
                              ir_expression *const r0DAD = add(r0DAA, r0DAC);
                              body.emit(assign(r0DA9, add(r0DAD, r0D6A), 0x02));

                              body.emit(assign(r0DA9, r0D6B, 0x01));

                              body.emit(assign(r0D6E, r0DA9, 0x03));

                              body.emit(assign(r0D6D, body.constant(false), 0x01));


                           body.instructions = f0D9A_parent_instructions;
                           body.emit(f0D9A);

                           /* END IF */

                           body.emit(assign(r099A, r0D6E, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0D22->else_instructions;

                           ir_variable *const r0DAE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0DAE);
                           body.emit(assign(r0DAE, body.constant(0u), 0x02));

                           body.emit(assign(r0DAE, body.constant(0u), 0x01));

                           body.emit(assign(r099A, r0DAE, 0x03));


                        body.instructions = f0D22_parent_instructions;
                        body.emit(f0D22);

                        /* END IF */


                     body.instructions = f0C96_parent_instructions;
                     body.emit(f0C96);

                     /* END IF */


                  body.instructions = f0C0A_parent_instructions;
                  body.emit(f0C0A);

                  /* END IF */


               body.instructions = f0B7E_parent_instructions;
               body.emit(f0B7E);

               /* END IF */


            body.instructions = f0B57_parent_instructions;
            body.emit(f0B57);

            /* END IF */


         body.instructions = f0A83_parent_instructions;
         body.emit(f0A83);

         /* END IF */


      body.instructions = f09B3_parent_instructions;
      body.emit(f09B3);

      /* END IF */

      body.emit(assign(r07EB, r099A, 0x03));


   body.instructions = f07EE_parent_instructions;
   body.emit(f07EE);

   /* END IF */

   body.emit(ret(r07EB));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul32To64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0DAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0DAF);
   ir_variable *const r0DB0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0DB0);
   ir_variable *const r0DB1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DB1);
   ir_variable *const r0DB2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DB2);
   ir_variable *const r0DB3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r0DB3);
   ir_variable *const r0DB4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r0DB4);
   ir_variable *const r0DB5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r0DB5);
   ir_variable *const r0DB6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DB6, bit_and(r0DAF, body.constant(65535u)), 0x01));

   ir_variable *const r0DB7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DB7, rshift(r0DAF, body.constant(int(16))), 0x01));

   ir_variable *const r0DB8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DB8, bit_and(r0DB0, body.constant(65535u)), 0x01));

   ir_variable *const r0DB9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DB9, rshift(r0DB0, body.constant(int(16))), 0x01));

   ir_variable *const r0DBA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DBA, mul(r0DB7, r0DB8), 0x01));

   ir_expression *const r0DBB = mul(r0DB6, r0DB9);
   body.emit(assign(r0DB4, add(r0DBB, r0DBA), 0x01));

   ir_expression *const r0DBC = mul(r0DB7, r0DB9);
   ir_expression *const r0DBD = less(r0DB4, r0DBA);
   ir_expression *const r0DBE = expr(ir_unop_b2i, r0DBD);
   ir_expression *const r0DBF = expr(ir_unop_i2u, r0DBE);
   ir_expression *const r0DC0 = lshift(r0DBF, body.constant(int(16)));
   ir_expression *const r0DC1 = rshift(r0DB4, body.constant(int(16)));
   ir_expression *const r0DC2 = add(r0DC0, r0DC1);
   body.emit(assign(r0DB3, add(r0DBC, r0DC2), 0x01));

   body.emit(assign(r0DB4, lshift(r0DB4, body.constant(int(16))), 0x01));

   ir_expression *const r0DC3 = mul(r0DB6, r0DB8);
   body.emit(assign(r0DB5, add(r0DC3, r0DB4), 0x01));

   ir_expression *const r0DC4 = less(r0DB5, r0DB4);
   ir_expression *const r0DC5 = expr(ir_unop_b2i, r0DC4);
   ir_expression *const r0DC6 = expr(ir_unop_i2u, r0DC5);
   body.emit(assign(r0DB3, add(r0DB3, r0DC6), 0x01));

   body.emit(assign(r0DB2, r0DB5, 0x01));

   body.emit(assign(r0DB1, r0DB3, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul64To128(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0DC7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0DC7);
   ir_variable *const r0DC8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0DC8);
   ir_variable *const r0DC9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r0DC9);
   ir_variable *const r0DCA = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r0DCA);
   ir_variable *const r0DCB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DCB);
   ir_variable *const r0DCC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DCC);
   ir_variable *const r0DCD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DCD);
   ir_variable *const r0DCE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z3Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DCE);
   ir_variable *const r0DCF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r0DCF);
   ir_variable *const r0DD0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r0DD0);
   ir_variable *const r0DD1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r0DD1);
   ir_variable *const r0DD2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DD2, bit_and(r0DC8, body.constant(65535u)), 0x01));

   ir_variable *const r0DD3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DD3, rshift(r0DC8, body.constant(int(16))), 0x01));

   ir_variable *const r0DD4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DD4, bit_and(r0DCA, body.constant(65535u)), 0x01));

   ir_variable *const r0DD5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DD5, rshift(r0DCA, body.constant(int(16))), 0x01));

   ir_variable *const r0DD6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DD6, mul(r0DD3, r0DD4), 0x01));

   ir_expression *const r0DD7 = mul(r0DD2, r0DD5);
   body.emit(assign(r0DD0, add(r0DD7, r0DD6), 0x01));

   ir_expression *const r0DD8 = mul(r0DD3, r0DD5);
   ir_expression *const r0DD9 = less(r0DD0, r0DD6);
   ir_expression *const r0DDA = expr(ir_unop_b2i, r0DD9);
   ir_expression *const r0DDB = expr(ir_unop_i2u, r0DDA);
   ir_expression *const r0DDC = lshift(r0DDB, body.constant(int(16)));
   ir_expression *const r0DDD = rshift(r0DD0, body.constant(int(16)));
   ir_expression *const r0DDE = add(r0DDC, r0DDD);
   body.emit(assign(r0DCF, add(r0DD8, r0DDE), 0x01));

   body.emit(assign(r0DD0, lshift(r0DD0, body.constant(int(16))), 0x01));

   ir_expression *const r0DDF = mul(r0DD2, r0DD4);
   body.emit(assign(r0DD1, add(r0DDF, r0DD0), 0x01));

   ir_expression *const r0DE0 = less(r0DD1, r0DD0);
   ir_expression *const r0DE1 = expr(ir_unop_b2i, r0DE0);
   ir_expression *const r0DE2 = expr(ir_unop_i2u, r0DE1);
   body.emit(assign(r0DCF, add(r0DCF, r0DE2), 0x01));

   ir_variable *const r0DE3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r0DE3);
   ir_variable *const r0DE4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r0DE4);
   ir_variable *const r0DE5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r0DE5);
   ir_variable *const r0DE6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DE6, bit_and(r0DC8, body.constant(65535u)), 0x01));

   ir_variable *const r0DE7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DE7, rshift(r0DC8, body.constant(int(16))), 0x01));

   ir_variable *const r0DE8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DE8, bit_and(r0DC9, body.constant(65535u)), 0x01));

   ir_variable *const r0DE9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DE9, rshift(r0DC9, body.constant(int(16))), 0x01));

   ir_variable *const r0DEA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DEA, mul(r0DE7, r0DE8), 0x01));

   ir_expression *const r0DEB = mul(r0DE6, r0DE9);
   body.emit(assign(r0DE4, add(r0DEB, r0DEA), 0x01));

   ir_expression *const r0DEC = mul(r0DE7, r0DE9);
   ir_expression *const r0DED = less(r0DE4, r0DEA);
   ir_expression *const r0DEE = expr(ir_unop_b2i, r0DED);
   ir_expression *const r0DEF = expr(ir_unop_i2u, r0DEE);
   ir_expression *const r0DF0 = lshift(r0DEF, body.constant(int(16)));
   ir_expression *const r0DF1 = rshift(r0DE4, body.constant(int(16)));
   ir_expression *const r0DF2 = add(r0DF0, r0DF1);
   body.emit(assign(r0DE3, add(r0DEC, r0DF2), 0x01));

   body.emit(assign(r0DE4, lshift(r0DE4, body.constant(int(16))), 0x01));

   ir_expression *const r0DF3 = mul(r0DE6, r0DE8);
   body.emit(assign(r0DE5, add(r0DF3, r0DE4), 0x01));

   ir_expression *const r0DF4 = less(r0DE5, r0DE4);
   ir_expression *const r0DF5 = expr(ir_unop_b2i, r0DF4);
   ir_expression *const r0DF6 = expr(ir_unop_i2u, r0DF5);
   body.emit(assign(r0DE3, add(r0DE3, r0DF6), 0x01));

   ir_variable *const r0DF7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DF7, add(r0DE5, r0DCF), 0x01));

   ir_variable *const r0DF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r0DF8);
   ir_variable *const r0DF9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r0DF9);
   ir_variable *const r0DFA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r0DFA);
   ir_variable *const r0DFB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DFB, bit_and(r0DC7, body.constant(65535u)), 0x01));

   ir_variable *const r0DFC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DFC, rshift(r0DC7, body.constant(int(16))), 0x01));

   ir_variable *const r0DFD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DFD, bit_and(r0DC9, body.constant(65535u)), 0x01));

   ir_variable *const r0DFE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DFE, rshift(r0DC9, body.constant(int(16))), 0x01));

   ir_variable *const r0DFF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DFF, mul(r0DFC, r0DFD), 0x01));

   ir_expression *const r0E00 = mul(r0DFB, r0DFE);
   body.emit(assign(r0DF9, add(r0E00, r0DFF), 0x01));

   ir_expression *const r0E01 = mul(r0DFC, r0DFE);
   ir_expression *const r0E02 = less(r0DF9, r0DFF);
   ir_expression *const r0E03 = expr(ir_unop_b2i, r0E02);
   ir_expression *const r0E04 = expr(ir_unop_i2u, r0E03);
   ir_expression *const r0E05 = lshift(r0E04, body.constant(int(16)));
   ir_expression *const r0E06 = rshift(r0DF9, body.constant(int(16)));
   ir_expression *const r0E07 = add(r0E05, r0E06);
   body.emit(assign(r0DF8, add(r0E01, r0E07), 0x01));

   body.emit(assign(r0DF9, lshift(r0DF9, body.constant(int(16))), 0x01));

   ir_expression *const r0E08 = mul(r0DFB, r0DFD);
   body.emit(assign(r0DFA, add(r0E08, r0DF9), 0x01));

   ir_expression *const r0E09 = less(r0DFA, r0DF9);
   ir_expression *const r0E0A = expr(ir_unop_b2i, r0E09);
   ir_expression *const r0E0B = expr(ir_unop_i2u, r0E0A);
   body.emit(assign(r0DF8, add(r0DF8, r0E0B), 0x01));

   ir_variable *const r0E0C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r0E0D = less(r0DF7, r0DE5);
   ir_expression *const r0E0E = expr(ir_unop_b2i, r0E0D);
   ir_expression *const r0E0F = expr(ir_unop_i2u, r0E0E);
   ir_expression *const r0E10 = add(r0DE3, r0E0F);
   body.emit(assign(r0E0C, add(r0DFA, r0E10), 0x01));

   ir_variable *const r0E11 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r0E11);
   ir_variable *const r0E12 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r0E12);
   ir_variable *const r0E13 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r0E13);
   ir_variable *const r0E14 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0E14, bit_and(r0DC7, body.constant(65535u)), 0x01));

   ir_variable *const r0E15 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0E15, rshift(r0DC7, body.constant(int(16))), 0x01));

   ir_variable *const r0E16 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0E16, bit_and(r0DCA, body.constant(65535u)), 0x01));

   ir_variable *const r0E17 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0E17, rshift(r0DCA, body.constant(int(16))), 0x01));

   ir_variable *const r0E18 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0E18, mul(r0E15, r0E16), 0x01));

   ir_expression *const r0E19 = mul(r0E14, r0E17);
   body.emit(assign(r0E12, add(r0E19, r0E18), 0x01));

   ir_expression *const r0E1A = mul(r0E15, r0E17);
   ir_expression *const r0E1B = less(r0E12, r0E18);
   ir_expression *const r0E1C = expr(ir_unop_b2i, r0E1B);
   ir_expression *const r0E1D = expr(ir_unop_i2u, r0E1C);
   ir_expression *const r0E1E = lshift(r0E1D, body.constant(int(16)));
   ir_expression *const r0E1F = rshift(r0E12, body.constant(int(16)));
   ir_expression *const r0E20 = add(r0E1E, r0E1F);
   body.emit(assign(r0E11, add(r0E1A, r0E20), 0x01));

   body.emit(assign(r0E12, lshift(r0E12, body.constant(int(16))), 0x01));

   ir_expression *const r0E21 = mul(r0E14, r0E16);
   body.emit(assign(r0E13, add(r0E21, r0E12), 0x01));

   ir_expression *const r0E22 = less(r0E13, r0E12);
   ir_expression *const r0E23 = expr(ir_unop_b2i, r0E22);
   ir_expression *const r0E24 = expr(ir_unop_i2u, r0E23);
   body.emit(assign(r0E11, add(r0E11, r0E24), 0x01));

   ir_variable *const r0E25 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0E25, add(r0E13, r0DF7), 0x01));

   ir_variable *const r0E26 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r0E27 = less(r0E25, r0E13);
   ir_expression *const r0E28 = expr(ir_unop_b2i, r0E27);
   ir_expression *const r0E29 = expr(ir_unop_i2u, r0E28);
   ir_expression *const r0E2A = add(r0E11, r0E29);
   body.emit(assign(r0E26, add(r0E0C, r0E2A), 0x01));

   body.emit(assign(r0DCE, r0DD1, 0x01));

   body.emit(assign(r0DCD, r0E25, 0x01));

   body.emit(assign(r0DCC, r0E26, 0x01));

   ir_expression *const r0E2B = less(r0E0C, r0DFA);
   ir_expression *const r0E2C = expr(ir_unop_b2i, r0E2B);
   ir_expression *const r0E2D = expr(ir_unop_i2u, r0E2C);
   ir_expression *const r0E2E = add(r0DF8, r0E2D);
   ir_expression *const r0E2F = less(r0E26, r0E0C);
   ir_expression *const r0E30 = expr(ir_unop_b2i, r0E2F);
   ir_expression *const r0E31 = expr(ir_unop_i2u, r0E30);
   body.emit(assign(r0DCB, add(r0E2E, r0E31), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat64Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0E32 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0E32);
   ir_variable *const r0E33 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0E33);
   ir_variable *const r0E34 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r0E34);
   ir_variable *const r0E35 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0E35);
   ir_variable *const r0E36 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0E36);
   ir_variable *const r0E37 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r0E37);
   /* IF CONDITION */
   ir_expression *const r0E39 = equal(r0E32, body.constant(0u));
   ir_if *f0E38 = new(mem_ctx) ir_if(operand(r0E39).val);
   exec_list *const f0E38_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0E38->then_instructions;

      ir_variable *const r0E3A = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r0E3A, r0E33, 0x01));

      ir_variable *const r0E3B = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r0E3C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r0E3C);
      /* IF CONDITION */
      ir_expression *const r0E3E = equal(r0E33, body.constant(0u));
      ir_if *f0E3D = new(mem_ctx) ir_if(operand(r0E3E).val);
      exec_list *const f0E3D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0E3D->then_instructions;

         body.emit(assign(r0E3B, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0E3D->else_instructions;

         body.emit(assign(r0E3C, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r0E40 = bit_and(r0E33, body.constant(4294901760u));
         ir_expression *const r0E41 = equal(r0E40, body.constant(0u));
         ir_if *f0E3F = new(mem_ctx) ir_if(operand(r0E41).val);
         exec_list *const f0E3F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E3F->then_instructions;

            body.emit(assign(r0E3C, body.constant(int(16)), 0x01));

            body.emit(assign(r0E3A, lshift(r0E33, body.constant(int(16))), 0x01));


         body.instructions = f0E3F_parent_instructions;
         body.emit(f0E3F);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E43 = bit_and(r0E3A, body.constant(4278190080u));
         ir_expression *const r0E44 = equal(r0E43, body.constant(0u));
         ir_if *f0E42 = new(mem_ctx) ir_if(operand(r0E44).val);
         exec_list *const f0E42_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E42->then_instructions;

            body.emit(assign(r0E3C, add(r0E3C, body.constant(int(8))), 0x01));

            body.emit(assign(r0E3A, lshift(r0E3A, body.constant(int(8))), 0x01));


         body.instructions = f0E42_parent_instructions;
         body.emit(f0E42);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E46 = bit_and(r0E3A, body.constant(4026531840u));
         ir_expression *const r0E47 = equal(r0E46, body.constant(0u));
         ir_if *f0E45 = new(mem_ctx) ir_if(operand(r0E47).val);
         exec_list *const f0E45_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E45->then_instructions;

            body.emit(assign(r0E3C, add(r0E3C, body.constant(int(4))), 0x01));

            body.emit(assign(r0E3A, lshift(r0E3A, body.constant(int(4))), 0x01));


         body.instructions = f0E45_parent_instructions;
         body.emit(f0E45);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E49 = bit_and(r0E3A, body.constant(3221225472u));
         ir_expression *const r0E4A = equal(r0E49, body.constant(0u));
         ir_if *f0E48 = new(mem_ctx) ir_if(operand(r0E4A).val);
         exec_list *const f0E48_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E48->then_instructions;

            body.emit(assign(r0E3C, add(r0E3C, body.constant(int(2))), 0x01));

            body.emit(assign(r0E3A, lshift(r0E3A, body.constant(int(2))), 0x01));


         body.instructions = f0E48_parent_instructions;
         body.emit(f0E48);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E4C = bit_and(r0E3A, body.constant(2147483648u));
         ir_expression *const r0E4D = equal(r0E4C, body.constant(0u));
         ir_if *f0E4B = new(mem_ctx) ir_if(operand(r0E4D).val);
         exec_list *const f0E4B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E4B->then_instructions;

            body.emit(assign(r0E3C, add(r0E3C, body.constant(int(1))), 0x01));


         body.instructions = f0E4B_parent_instructions;
         body.emit(f0E4B);

         /* END IF */

         body.emit(assign(r0E3B, r0E3C, 0x01));


      body.instructions = f0E3D_parent_instructions;
      body.emit(f0E3D);

      /* END IF */

      body.emit(assign(r0E37, add(r0E3B, body.constant(int(-11))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0E4F = less(r0E37, body.constant(int(0)));
      ir_if *f0E4E = new(mem_ctx) ir_if(operand(r0E4F).val);
      exec_list *const f0E4E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0E4E->then_instructions;

         ir_expression *const r0E50 = neg(r0E37);
         body.emit(assign(r0E35, rshift(r0E33, r0E50), 0x01));

         ir_expression *const r0E51 = bit_and(r0E37, body.constant(int(31)));
         body.emit(assign(r0E36, lshift(r0E33, r0E51), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0E4E->else_instructions;

         body.emit(assign(r0E35, lshift(r0E33, r0E37), 0x01));

         body.emit(assign(r0E36, body.constant(0u), 0x01));


      body.instructions = f0E4E_parent_instructions;
      body.emit(f0E4E);

      /* END IF */

      body.emit(assign(r0E34, sub(body.constant(int(-31)), r0E37), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0E38->else_instructions;

      ir_variable *const r0E52 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r0E52, r0E32, 0x01));

      ir_variable *const r0E53 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r0E54 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r0E54);
      /* IF CONDITION */
      ir_expression *const r0E56 = equal(r0E32, body.constant(0u));
      ir_if *f0E55 = new(mem_ctx) ir_if(operand(r0E56).val);
      exec_list *const f0E55_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0E55->then_instructions;

         body.emit(assign(r0E53, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0E55->else_instructions;

         body.emit(assign(r0E54, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r0E58 = bit_and(r0E32, body.constant(4294901760u));
         ir_expression *const r0E59 = equal(r0E58, body.constant(0u));
         ir_if *f0E57 = new(mem_ctx) ir_if(operand(r0E59).val);
         exec_list *const f0E57_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E57->then_instructions;

            body.emit(assign(r0E54, body.constant(int(16)), 0x01));

            body.emit(assign(r0E52, lshift(r0E32, body.constant(int(16))), 0x01));


         body.instructions = f0E57_parent_instructions;
         body.emit(f0E57);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E5B = bit_and(r0E52, body.constant(4278190080u));
         ir_expression *const r0E5C = equal(r0E5B, body.constant(0u));
         ir_if *f0E5A = new(mem_ctx) ir_if(operand(r0E5C).val);
         exec_list *const f0E5A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E5A->then_instructions;

            body.emit(assign(r0E54, add(r0E54, body.constant(int(8))), 0x01));

            body.emit(assign(r0E52, lshift(r0E52, body.constant(int(8))), 0x01));


         body.instructions = f0E5A_parent_instructions;
         body.emit(f0E5A);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E5E = bit_and(r0E52, body.constant(4026531840u));
         ir_expression *const r0E5F = equal(r0E5E, body.constant(0u));
         ir_if *f0E5D = new(mem_ctx) ir_if(operand(r0E5F).val);
         exec_list *const f0E5D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E5D->then_instructions;

            body.emit(assign(r0E54, add(r0E54, body.constant(int(4))), 0x01));

            body.emit(assign(r0E52, lshift(r0E52, body.constant(int(4))), 0x01));


         body.instructions = f0E5D_parent_instructions;
         body.emit(f0E5D);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E61 = bit_and(r0E52, body.constant(3221225472u));
         ir_expression *const r0E62 = equal(r0E61, body.constant(0u));
         ir_if *f0E60 = new(mem_ctx) ir_if(operand(r0E62).val);
         exec_list *const f0E60_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E60->then_instructions;

            body.emit(assign(r0E54, add(r0E54, body.constant(int(2))), 0x01));

            body.emit(assign(r0E52, lshift(r0E52, body.constant(int(2))), 0x01));


         body.instructions = f0E60_parent_instructions;
         body.emit(f0E60);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E64 = bit_and(r0E52, body.constant(2147483648u));
         ir_expression *const r0E65 = equal(r0E64, body.constant(0u));
         ir_if *f0E63 = new(mem_ctx) ir_if(operand(r0E65).val);
         exec_list *const f0E63_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E63->then_instructions;

            body.emit(assign(r0E54, add(r0E54, body.constant(int(1))), 0x01));


         body.instructions = f0E63_parent_instructions;
         body.emit(f0E63);

         /* END IF */

         body.emit(assign(r0E53, r0E54, 0x01));


      body.instructions = f0E55_parent_instructions;
      body.emit(f0E55);

      /* END IF */

      body.emit(assign(r0E37, add(r0E53, body.constant(int(-11))), 0x01));

      ir_variable *const r0E66 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r0E66, lshift(r0E33, r0E37), 0x01));

      ir_variable *const r0E67 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r0E69 = equal(r0E37, body.constant(int(0)));
      ir_if *f0E68 = new(mem_ctx) ir_if(operand(r0E69).val);
      exec_list *const f0E68_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0E68->then_instructions;

         body.emit(assign(r0E67, r0E32, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0E68->else_instructions;

         ir_expression *const r0E6A = lshift(r0E32, r0E37);
         ir_expression *const r0E6B = neg(r0E37);
         ir_expression *const r0E6C = bit_and(r0E6B, body.constant(int(31)));
         ir_expression *const r0E6D = rshift(r0E33, r0E6C);
         body.emit(assign(r0E67, bit_or(r0E6A, r0E6D), 0x01));


      body.instructions = f0E68_parent_instructions;
      body.emit(f0E68);

      /* END IF */

      body.emit(assign(r0E35, r0E67, 0x01));

      body.emit(assign(r0E36, r0E66, 0x01));

      body.emit(assign(r0E34, sub(body.constant(int(1)), r0E37), 0x01));


   body.instructions = f0E38_parent_instructions;
   body.emit(f0E38);

   /* END IF */

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fmul64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0E6E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0E6E);
   ir_variable *const r0E6F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0E6F);
   ir_variable *const r0E70 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r0E70, body.constant(true), 0x01));

   ir_variable *const r0E71 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0E72 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r0E72);
   ir_variable *const r0E73 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r0E73);
   ir_variable *const r0E74 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r0E74);
   ir_variable *const r0E75 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r0E75);
   ir_variable *const r0E76 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r0E76);
   ir_variable *const r0E77 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r0E77);
   ir_variable *const r0E78 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r0E78);
   ir_variable *const r0E79 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r0E79);
   ir_variable *const r0E7A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r0E7A);
   ir_variable *const r0E7B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r0E7B);
   ir_variable *const r0E7C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r0E7C);
   body.emit(assign(r0E7C, body.constant(0u), 0x01));

   body.emit(assign(r0E7B, body.constant(0u), 0x01));

   body.emit(assign(r0E7A, body.constant(0u), 0x01));

   ir_variable *const r0E7D = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r0E7D, swizzle_x(r0E6E), 0x01));

   body.emit(assign(r0E78, r0E7D, 0x01));

   ir_variable *const r0E7E = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r0E7E, bit_and(swizzle_y(r0E6E), body.constant(1048575u)), 0x01));

   body.emit(assign(r0E77, r0E7E, 0x01));

   ir_variable *const r0E7F = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r0E7F, swizzle_x(r0E6F), 0x01));

   body.emit(assign(r0E76, r0E7F, 0x01));

   ir_variable *const r0E80 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r0E80, bit_and(swizzle_y(r0E6F), body.constant(1048575u)), 0x01));

   body.emit(assign(r0E75, r0E80, 0x01));

   ir_variable *const r0E81 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0E82 = rshift(swizzle_y(r0E6E), body.constant(int(20)));
   ir_expression *const r0E83 = bit_and(r0E82, body.constant(2047u));
   body.emit(assign(r0E81, expr(ir_unop_u2i, r0E83), 0x01));

   body.emit(assign(r0E74, r0E81, 0x01));

   ir_variable *const r0E84 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0E85 = rshift(swizzle_y(r0E6F), body.constant(int(20)));
   ir_expression *const r0E86 = bit_and(r0E85, body.constant(2047u));
   body.emit(assign(r0E84, expr(ir_unop_u2i, r0E86), 0x01));

   body.emit(assign(r0E73, r0E84, 0x01));

   ir_expression *const r0E87 = rshift(swizzle_y(r0E6E), body.constant(int(31)));
   ir_expression *const r0E88 = rshift(swizzle_y(r0E6F), body.constant(int(31)));
   body.emit(assign(r0E72, bit_xor(r0E87, r0E88), 0x01));

   /* IF CONDITION */
   ir_expression *const r0E8A = equal(r0E81, body.constant(int(2047)));
   ir_if *f0E89 = new(mem_ctx) ir_if(operand(r0E8A).val);
   exec_list *const f0E89_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0E89->then_instructions;

      /* IF CONDITION */
      ir_expression *const r0E8C = bit_or(r0E7E, swizzle_x(r0E6E));
      ir_expression *const r0E8D = nequal(r0E8C, body.constant(0u));
      ir_expression *const r0E8E = equal(r0E84, body.constant(int(2047)));
      ir_expression *const r0E8F = bit_or(r0E80, swizzle_x(r0E6F));
      ir_expression *const r0E90 = nequal(r0E8F, body.constant(0u));
      ir_expression *const r0E91 = logic_and(r0E8E, r0E90);
      ir_expression *const r0E92 = logic_or(r0E8D, r0E91);
      ir_if *f0E8B = new(mem_ctx) ir_if(operand(r0E92).val);
      exec_list *const f0E8B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0E8B->then_instructions;

         ir_variable *const r0E93 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r0E93, swizzle_x(r0E6E), 0x01));

         ir_variable *const r0E94 = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r0E94, swizzle_x(r0E6F), 0x01));

         ir_variable *const r0E95 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0E96 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r0E97 = rshift(swizzle_y(r0E6E), body.constant(int(19)));
         ir_expression *const r0E98 = bit_and(r0E97, body.constant(4095u));
         ir_expression *const r0E99 = equal(r0E98, body.constant(4094u));
         ir_expression *const r0E9A = nequal(swizzle_x(r0E6E), body.constant(0u));
         ir_expression *const r0E9B = bit_and(swizzle_y(r0E6E), body.constant(524287u));
         ir_expression *const r0E9C = nequal(r0E9B, body.constant(0u));
         ir_expression *const r0E9D = logic_or(r0E9A, r0E9C);
         body.emit(assign(r0E96, logic_and(r0E99, r0E9D), 0x01));

         ir_variable *const r0E9E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r0E9F = lshift(swizzle_y(r0E6F), body.constant(int(1)));
         ir_expression *const r0EA0 = lequal(body.constant(4292870144u), r0E9F);
         ir_expression *const r0EA1 = nequal(swizzle_x(r0E6F), body.constant(0u));
         ir_expression *const r0EA2 = bit_and(swizzle_y(r0E6F), body.constant(1048575u));
         ir_expression *const r0EA3 = nequal(r0EA2, body.constant(0u));
         ir_expression *const r0EA4 = logic_or(r0EA1, r0EA3);
         body.emit(assign(r0E9E, logic_and(r0EA0, r0EA4), 0x01));

         body.emit(assign(r0E93, bit_or(swizzle_y(r0E6E), body.constant(524288u)), 0x02));

         body.emit(assign(r0E94, bit_or(swizzle_y(r0E6F), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r0EA6 = lshift(swizzle_y(r0E6E), body.constant(int(1)));
         ir_expression *const r0EA7 = lequal(body.constant(4292870144u), r0EA6);
         ir_expression *const r0EA8 = nequal(swizzle_x(r0E6E), body.constant(0u));
         ir_expression *const r0EA9 = bit_and(swizzle_y(r0E6E), body.constant(1048575u));
         ir_expression *const r0EAA = nequal(r0EA9, body.constant(0u));
         ir_expression *const r0EAB = logic_or(r0EA8, r0EAA);
         ir_expression *const r0EAC = logic_and(r0EA7, r0EAB);
         ir_if *f0EA5 = new(mem_ctx) ir_if(operand(r0EAC).val);
         exec_list *const f0EA5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0EA5->then_instructions;

            ir_variable *const r0EAD = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r0EAF = logic_and(r0E96, r0E9E);
            ir_if *f0EAE = new(mem_ctx) ir_if(operand(r0EAF).val);
            exec_list *const f0EAE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0EAE->then_instructions;

               body.emit(assign(r0EAD, r0E94, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0EAE->else_instructions;

               body.emit(assign(r0EAD, r0E93, 0x03));


            body.instructions = f0EAE_parent_instructions;
            body.emit(f0EAE);

            /* END IF */

            body.emit(assign(r0E95, r0EAD, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0EA5->else_instructions;

            body.emit(assign(r0E95, r0E94, 0x03));


         body.instructions = f0EA5_parent_instructions;
         body.emit(f0EA5);

         /* END IF */

         body.emit(assign(r0E71, r0E95, 0x03));

         body.emit(assign(r0E70, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0E8B->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0EB1 = expr(ir_unop_i2u, r0E84);
         ir_expression *const r0EB2 = bit_or(r0EB1, r0E80);
         ir_expression *const r0EB3 = bit_or(r0EB2, swizzle_x(r0E6F));
         ir_expression *const r0EB4 = equal(r0EB3, body.constant(0u));
         ir_if *f0EB0 = new(mem_ctx) ir_if(operand(r0EB4).val);
         exec_list *const f0EB0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0EB0->then_instructions;

            ir_constant_data r0EB5_data;
            memset(&r0EB5_data, 0, sizeof(ir_constant_data));
            r0EB5_data.u[0] = 4294967295;
            r0EB5_data.u[1] = 4294967295;
            ir_constant *const r0EB5 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0EB5_data);
            body.emit(assign(r0E71, r0EB5, 0x03));

            body.emit(assign(r0E70, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0EB0->else_instructions;

            ir_variable *const r0EB6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r0EB6);
            ir_expression *const r0EB7 = lshift(r0E72, body.constant(int(31)));
            body.emit(assign(r0EB6, add(r0EB7, body.constant(2146435072u)), 0x02));

            body.emit(assign(r0EB6, body.constant(0u), 0x01));

            body.emit(assign(r0E71, r0EB6, 0x03));

            body.emit(assign(r0E70, body.constant(false), 0x01));


         body.instructions = f0EB0_parent_instructions;
         body.emit(f0EB0);

         /* END IF */


      body.instructions = f0E8B_parent_instructions;
      body.emit(f0E8B);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0E89->else_instructions;

      /* IF CONDITION */
      ir_expression *const r0EB9 = equal(r0E84, body.constant(int(2047)));
      ir_if *f0EB8 = new(mem_ctx) ir_if(operand(r0EB9).val);
      exec_list *const f0EB8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0EB8->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0EBB = bit_or(r0E80, swizzle_x(r0E6F));
         ir_expression *const r0EBC = nequal(r0EBB, body.constant(0u));
         ir_if *f0EBA = new(mem_ctx) ir_if(operand(r0EBC).val);
         exec_list *const f0EBA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0EBA->then_instructions;

            ir_variable *const r0EBD = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r0EBD, swizzle_x(r0E6E), 0x01));

            ir_variable *const r0EBE = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r0EBE, swizzle_x(r0E6F), 0x01));

            ir_variable *const r0EBF = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0EC0 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r0EC1 = rshift(swizzle_y(r0E6E), body.constant(int(19)));
            ir_expression *const r0EC2 = bit_and(r0EC1, body.constant(4095u));
            ir_expression *const r0EC3 = equal(r0EC2, body.constant(4094u));
            ir_expression *const r0EC4 = nequal(swizzle_x(r0E6E), body.constant(0u));
            ir_expression *const r0EC5 = bit_and(swizzle_y(r0E6E), body.constant(524287u));
            ir_expression *const r0EC6 = nequal(r0EC5, body.constant(0u));
            ir_expression *const r0EC7 = logic_or(r0EC4, r0EC6);
            body.emit(assign(r0EC0, logic_and(r0EC3, r0EC7), 0x01));

            ir_variable *const r0EC8 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r0EC9 = lshift(swizzle_y(r0E6F), body.constant(int(1)));
            ir_expression *const r0ECA = lequal(body.constant(4292870144u), r0EC9);
            ir_expression *const r0ECB = nequal(swizzle_x(r0E6F), body.constant(0u));
            ir_expression *const r0ECC = bit_and(swizzle_y(r0E6F), body.constant(1048575u));
            ir_expression *const r0ECD = nequal(r0ECC, body.constant(0u));
            ir_expression *const r0ECE = logic_or(r0ECB, r0ECD);
            body.emit(assign(r0EC8, logic_and(r0ECA, r0ECE), 0x01));

            body.emit(assign(r0EBD, bit_or(swizzle_y(r0E6E), body.constant(524288u)), 0x02));

            body.emit(assign(r0EBE, bit_or(swizzle_y(r0E6F), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0ED0 = lshift(swizzle_y(r0E6E), body.constant(int(1)));
            ir_expression *const r0ED1 = lequal(body.constant(4292870144u), r0ED0);
            ir_expression *const r0ED2 = nequal(swizzle_x(r0E6E), body.constant(0u));
            ir_expression *const r0ED3 = bit_and(swizzle_y(r0E6E), body.constant(1048575u));
            ir_expression *const r0ED4 = nequal(r0ED3, body.constant(0u));
            ir_expression *const r0ED5 = logic_or(r0ED2, r0ED4);
            ir_expression *const r0ED6 = logic_and(r0ED1, r0ED5);
            ir_if *f0ECF = new(mem_ctx) ir_if(operand(r0ED6).val);
            exec_list *const f0ECF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0ECF->then_instructions;

               ir_variable *const r0ED7 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0ED9 = logic_and(r0EC0, r0EC8);
               ir_if *f0ED8 = new(mem_ctx) ir_if(operand(r0ED9).val);
               exec_list *const f0ED8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ED8->then_instructions;

                  body.emit(assign(r0ED7, r0EBE, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0ED8->else_instructions;

                  body.emit(assign(r0ED7, r0EBD, 0x03));


               body.instructions = f0ED8_parent_instructions;
               body.emit(f0ED8);

               /* END IF */

               body.emit(assign(r0EBF, r0ED7, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0ECF->else_instructions;

               body.emit(assign(r0EBF, r0EBE, 0x03));


            body.instructions = f0ECF_parent_instructions;
            body.emit(f0ECF);

            /* END IF */

            body.emit(assign(r0E71, r0EBF, 0x03));

            body.emit(assign(r0E70, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0EBA->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0EDB = expr(ir_unop_i2u, r0E81);
            ir_expression *const r0EDC = bit_or(r0EDB, r0E7E);
            ir_expression *const r0EDD = bit_or(r0EDC, swizzle_x(r0E6E));
            ir_expression *const r0EDE = equal(r0EDD, body.constant(0u));
            ir_if *f0EDA = new(mem_ctx) ir_if(operand(r0EDE).val);
            exec_list *const f0EDA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0EDA->then_instructions;

               ir_constant_data r0EDF_data;
               memset(&r0EDF_data, 0, sizeof(ir_constant_data));
               r0EDF_data.u[0] = 4294967295;
               r0EDF_data.u[1] = 4294967295;
               ir_constant *const r0EDF = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0EDF_data);
               body.emit(assign(r0E71, r0EDF, 0x03));

               body.emit(assign(r0E70, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0EDA->else_instructions;

               ir_variable *const r0EE0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0EE0);
               ir_expression *const r0EE1 = lshift(r0E72, body.constant(int(31)));
               body.emit(assign(r0EE0, add(r0EE1, body.constant(2146435072u)), 0x02));

               body.emit(assign(r0EE0, body.constant(0u), 0x01));

               body.emit(assign(r0E71, r0EE0, 0x03));

               body.emit(assign(r0E70, body.constant(false), 0x01));


            body.instructions = f0EDA_parent_instructions;
            body.emit(f0EDA);

            /* END IF */


         body.instructions = f0EBA_parent_instructions;
         body.emit(f0EBA);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0EB8->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0EE3 = equal(r0E81, body.constant(int(0)));
         ir_if *f0EE2 = new(mem_ctx) ir_if(operand(r0EE3).val);
         exec_list *const f0EE2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0EE2->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0EE5 = bit_or(r0E7E, swizzle_x(r0E6E));
            ir_expression *const r0EE6 = equal(r0EE5, body.constant(0u));
            ir_if *f0EE4 = new(mem_ctx) ir_if(operand(r0EE6).val);
            exec_list *const f0EE4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0EE4->then_instructions;

               ir_variable *const r0EE7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0EE7);
               body.emit(assign(r0EE7, lshift(r0E72, body.constant(int(31))), 0x02));

               body.emit(assign(r0EE7, body.constant(0u), 0x01));

               body.emit(assign(r0E71, r0EE7, 0x03));

               body.emit(assign(r0E70, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0EE4->else_instructions;

               ir_variable *const r0EE8 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r0EE8, r0E81, 0x01));

               ir_variable *const r0EE9 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r0EE9, r0E7E, 0x01));

               ir_variable *const r0EEA = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r0EEA, r0E7D, 0x01));

               ir_variable *const r0EEB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0EEB);
               /* IF CONDITION */
               ir_expression *const r0EED = equal(r0E7E, body.constant(0u));
               ir_if *f0EEC = new(mem_ctx) ir_if(operand(r0EED).val);
               exec_list *const f0EEC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EEC->then_instructions;

                  ir_variable *const r0EEE = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0EEE, r0E7D, 0x01));

                  ir_variable *const r0EEF = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0EF0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0EF0);
                  /* IF CONDITION */
                  ir_expression *const r0EF2 = equal(swizzle_x(r0E6E), body.constant(0u));
                  ir_if *f0EF1 = new(mem_ctx) ir_if(operand(r0EF2).val);
                  exec_list *const f0EF1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0EF1->then_instructions;

                     body.emit(assign(r0EEF, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0EF1->else_instructions;

                     body.emit(assign(r0EF0, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0EF4 = bit_and(swizzle_x(r0E6E), body.constant(4294901760u));
                     ir_expression *const r0EF5 = equal(r0EF4, body.constant(0u));
                     ir_if *f0EF3 = new(mem_ctx) ir_if(operand(r0EF5).val);
                     exec_list *const f0EF3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EF3->then_instructions;

                        body.emit(assign(r0EF0, body.constant(int(16)), 0x01));

                        body.emit(assign(r0EEE, lshift(swizzle_x(r0E6E), body.constant(int(16))), 0x01));


                     body.instructions = f0EF3_parent_instructions;
                     body.emit(f0EF3);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0EF7 = bit_and(r0EEE, body.constant(4278190080u));
                     ir_expression *const r0EF8 = equal(r0EF7, body.constant(0u));
                     ir_if *f0EF6 = new(mem_ctx) ir_if(operand(r0EF8).val);
                     exec_list *const f0EF6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EF6->then_instructions;

                        body.emit(assign(r0EF0, add(r0EF0, body.constant(int(8))), 0x01));

                        body.emit(assign(r0EEE, lshift(r0EEE, body.constant(int(8))), 0x01));


                     body.instructions = f0EF6_parent_instructions;
                     body.emit(f0EF6);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0EFA = bit_and(r0EEE, body.constant(4026531840u));
                     ir_expression *const r0EFB = equal(r0EFA, body.constant(0u));
                     ir_if *f0EF9 = new(mem_ctx) ir_if(operand(r0EFB).val);
                     exec_list *const f0EF9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EF9->then_instructions;

                        body.emit(assign(r0EF0, add(r0EF0, body.constant(int(4))), 0x01));

                        body.emit(assign(r0EEE, lshift(r0EEE, body.constant(int(4))), 0x01));


                     body.instructions = f0EF9_parent_instructions;
                     body.emit(f0EF9);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0EFD = bit_and(r0EEE, body.constant(3221225472u));
                     ir_expression *const r0EFE = equal(r0EFD, body.constant(0u));
                     ir_if *f0EFC = new(mem_ctx) ir_if(operand(r0EFE).val);
                     exec_list *const f0EFC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EFC->then_instructions;

                        body.emit(assign(r0EF0, add(r0EF0, body.constant(int(2))), 0x01));

                        body.emit(assign(r0EEE, lshift(r0EEE, body.constant(int(2))), 0x01));


                     body.instructions = f0EFC_parent_instructions;
                     body.emit(f0EFC);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0F00 = bit_and(r0EEE, body.constant(2147483648u));
                     ir_expression *const r0F01 = equal(r0F00, body.constant(0u));
                     ir_if *f0EFF = new(mem_ctx) ir_if(operand(r0F01).val);
                     exec_list *const f0EFF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EFF->then_instructions;

                        body.emit(assign(r0EF0, add(r0EF0, body.constant(int(1))), 0x01));


                     body.instructions = f0EFF_parent_instructions;
                     body.emit(f0EFF);

                     /* END IF */

                     body.emit(assign(r0EEF, r0EF0, 0x01));


                  body.instructions = f0EF1_parent_instructions;
                  body.emit(f0EF1);

                  /* END IF */

                  body.emit(assign(r0EEB, add(r0EEF, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0F03 = less(r0EEB, body.constant(int(0)));
                  ir_if *f0F02 = new(mem_ctx) ir_if(operand(r0F03).val);
                  exec_list *const f0F02_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F02->then_instructions;

                     ir_expression *const r0F04 = neg(r0EEB);
                     body.emit(assign(r0EE9, rshift(swizzle_x(r0E6E), r0F04), 0x01));

                     ir_expression *const r0F05 = bit_and(r0EEB, body.constant(int(31)));
                     body.emit(assign(r0EEA, lshift(swizzle_x(r0E6E), r0F05), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F02->else_instructions;

                     body.emit(assign(r0EE9, lshift(swizzle_x(r0E6E), r0EEB), 0x01));

                     body.emit(assign(r0EEA, body.constant(0u), 0x01));


                  body.instructions = f0F02_parent_instructions;
                  body.emit(f0F02);

                  /* END IF */

                  body.emit(assign(r0EE8, sub(body.constant(int(-31)), r0EEB), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EEC->else_instructions;

                  ir_variable *const r0F06 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0F06, r0E7E, 0x01));

                  ir_variable *const r0F07 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0F08 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0F08);
                  /* IF CONDITION */
                  ir_expression *const r0F0A = equal(r0E7E, body.constant(0u));
                  ir_if *f0F09 = new(mem_ctx) ir_if(operand(r0F0A).val);
                  exec_list *const f0F09_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F09->then_instructions;

                     body.emit(assign(r0F07, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F09->else_instructions;

                     body.emit(assign(r0F08, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0F0C = bit_and(r0E7E, body.constant(4294901760u));
                     ir_expression *const r0F0D = equal(r0F0C, body.constant(0u));
                     ir_if *f0F0B = new(mem_ctx) ir_if(operand(r0F0D).val);
                     exec_list *const f0F0B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F0B->then_instructions;

                        body.emit(assign(r0F08, body.constant(int(16)), 0x01));

                        body.emit(assign(r0F06, lshift(r0E7E, body.constant(int(16))), 0x01));


                     body.instructions = f0F0B_parent_instructions;
                     body.emit(f0F0B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0F0F = bit_and(r0F06, body.constant(4278190080u));
                     ir_expression *const r0F10 = equal(r0F0F, body.constant(0u));
                     ir_if *f0F0E = new(mem_ctx) ir_if(operand(r0F10).val);
                     exec_list *const f0F0E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F0E->then_instructions;

                        body.emit(assign(r0F08, add(r0F08, body.constant(int(8))), 0x01));

                        body.emit(assign(r0F06, lshift(r0F06, body.constant(int(8))), 0x01));


                     body.instructions = f0F0E_parent_instructions;
                     body.emit(f0F0E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0F12 = bit_and(r0F06, body.constant(4026531840u));
                     ir_expression *const r0F13 = equal(r0F12, body.constant(0u));
                     ir_if *f0F11 = new(mem_ctx) ir_if(operand(r0F13).val);
                     exec_list *const f0F11_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F11->then_instructions;

                        body.emit(assign(r0F08, add(r0F08, body.constant(int(4))), 0x01));

                        body.emit(assign(r0F06, lshift(r0F06, body.constant(int(4))), 0x01));


                     body.instructions = f0F11_parent_instructions;
                     body.emit(f0F11);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0F15 = bit_and(r0F06, body.constant(3221225472u));
                     ir_expression *const r0F16 = equal(r0F15, body.constant(0u));
                     ir_if *f0F14 = new(mem_ctx) ir_if(operand(r0F16).val);
                     exec_list *const f0F14_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F14->then_instructions;

                        body.emit(assign(r0F08, add(r0F08, body.constant(int(2))), 0x01));

                        body.emit(assign(r0F06, lshift(r0F06, body.constant(int(2))), 0x01));


                     body.instructions = f0F14_parent_instructions;
                     body.emit(f0F14);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0F18 = bit_and(r0F06, body.constant(2147483648u));
                     ir_expression *const r0F19 = equal(r0F18, body.constant(0u));
                     ir_if *f0F17 = new(mem_ctx) ir_if(operand(r0F19).val);
                     exec_list *const f0F17_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F17->then_instructions;

                        body.emit(assign(r0F08, add(r0F08, body.constant(int(1))), 0x01));


                     body.instructions = f0F17_parent_instructions;
                     body.emit(f0F17);

                     /* END IF */

                     body.emit(assign(r0F07, r0F08, 0x01));


                  body.instructions = f0F09_parent_instructions;
                  body.emit(f0F09);

                  /* END IF */

                  body.emit(assign(r0EEB, add(r0F07, body.constant(int(-11))), 0x01));

                  ir_variable *const r0F1A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0F1A, lshift(swizzle_x(r0E6E), r0EEB), 0x01));

                  ir_variable *const r0F1B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0F1D = equal(r0EEB, body.constant(int(0)));
                  ir_if *f0F1C = new(mem_ctx) ir_if(operand(r0F1D).val);
                  exec_list *const f0F1C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F1C->then_instructions;

                     body.emit(assign(r0F1B, r0E7E, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F1C->else_instructions;

                     ir_expression *const r0F1E = lshift(r0E7E, r0EEB);
                     ir_expression *const r0F1F = neg(r0EEB);
                     ir_expression *const r0F20 = bit_and(r0F1F, body.constant(int(31)));
                     ir_expression *const r0F21 = rshift(swizzle_x(r0E6E), r0F20);
                     body.emit(assign(r0F1B, bit_or(r0F1E, r0F21), 0x01));


                  body.instructions = f0F1C_parent_instructions;
                  body.emit(f0F1C);

                  /* END IF */

                  body.emit(assign(r0EE9, r0F1B, 0x01));

                  body.emit(assign(r0EEA, r0F1A, 0x01));

                  body.emit(assign(r0EE8, sub(body.constant(int(1)), r0EEB), 0x01));


               body.instructions = f0EEC_parent_instructions;
               body.emit(f0EEC);

               /* END IF */

               body.emit(assign(r0E74, r0EE8, 0x01));

               body.emit(assign(r0E77, r0EE9, 0x01));

               body.emit(assign(r0E78, r0EEA, 0x01));


            body.instructions = f0EE4_parent_instructions;
            body.emit(f0EE4);

            /* END IF */


         body.instructions = f0EE2_parent_instructions;
         body.emit(f0EE2);

         /* END IF */

         /* IF CONDITION */
         ir_if *f0F22 = new(mem_ctx) ir_if(operand(r0E70).val);
         exec_list *const f0F22_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0F22->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0F24 = equal(r0E84, body.constant(int(0)));
            ir_if *f0F23 = new(mem_ctx) ir_if(operand(r0F24).val);
            exec_list *const f0F23_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0F23->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0F26 = bit_or(r0E80, swizzle_x(r0E6F));
               ir_expression *const r0F27 = equal(r0F26, body.constant(0u));
               ir_if *f0F25 = new(mem_ctx) ir_if(operand(r0F27).val);
               exec_list *const f0F25_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F25->then_instructions;

                  ir_variable *const r0F28 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0F28);
                  body.emit(assign(r0F28, lshift(r0E72, body.constant(int(31))), 0x02));

                  body.emit(assign(r0F28, body.constant(0u), 0x01));

                  body.emit(assign(r0E71, r0F28, 0x03));

                  body.emit(assign(r0E70, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F25->else_instructions;

                  ir_variable *const r0F29 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r0F29, r0E84, 0x01));

                  ir_variable *const r0F2A = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r0F2A, r0E80, 0x01));

                  ir_variable *const r0F2B = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r0F2B, r0E7F, 0x01));

                  ir_variable *const r0F2C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0F2C);
                  /* IF CONDITION */
                  ir_expression *const r0F2E = equal(r0E80, body.constant(0u));
                  ir_if *f0F2D = new(mem_ctx) ir_if(operand(r0F2E).val);
                  exec_list *const f0F2D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F2D->then_instructions;

                     ir_variable *const r0F2F = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r0F2F, r0E7F, 0x01));

                     ir_variable *const r0F30 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r0F31 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0F31);
                     /* IF CONDITION */
                     ir_expression *const r0F33 = equal(swizzle_x(r0E6F), body.constant(0u));
                     ir_if *f0F32 = new(mem_ctx) ir_if(operand(r0F33).val);
                     exec_list *const f0F32_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F32->then_instructions;

                        body.emit(assign(r0F30, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F32->else_instructions;

                        body.emit(assign(r0F31, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0F35 = bit_and(swizzle_x(r0E6F), body.constant(4294901760u));
                        ir_expression *const r0F36 = equal(r0F35, body.constant(0u));
                        ir_if *f0F34 = new(mem_ctx) ir_if(operand(r0F36).val);
                        exec_list *const f0F34_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F34->then_instructions;

                           body.emit(assign(r0F31, body.constant(int(16)), 0x01));

                           body.emit(assign(r0F2F, lshift(swizzle_x(r0E6F), body.constant(int(16))), 0x01));


                        body.instructions = f0F34_parent_instructions;
                        body.emit(f0F34);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F38 = bit_and(r0F2F, body.constant(4278190080u));
                        ir_expression *const r0F39 = equal(r0F38, body.constant(0u));
                        ir_if *f0F37 = new(mem_ctx) ir_if(operand(r0F39).val);
                        exec_list *const f0F37_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F37->then_instructions;

                           body.emit(assign(r0F31, add(r0F31, body.constant(int(8))), 0x01));

                           body.emit(assign(r0F2F, lshift(r0F2F, body.constant(int(8))), 0x01));


                        body.instructions = f0F37_parent_instructions;
                        body.emit(f0F37);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F3B = bit_and(r0F2F, body.constant(4026531840u));
                        ir_expression *const r0F3C = equal(r0F3B, body.constant(0u));
                        ir_if *f0F3A = new(mem_ctx) ir_if(operand(r0F3C).val);
                        exec_list *const f0F3A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F3A->then_instructions;

                           body.emit(assign(r0F31, add(r0F31, body.constant(int(4))), 0x01));

                           body.emit(assign(r0F2F, lshift(r0F2F, body.constant(int(4))), 0x01));


                        body.instructions = f0F3A_parent_instructions;
                        body.emit(f0F3A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F3E = bit_and(r0F2F, body.constant(3221225472u));
                        ir_expression *const r0F3F = equal(r0F3E, body.constant(0u));
                        ir_if *f0F3D = new(mem_ctx) ir_if(operand(r0F3F).val);
                        exec_list *const f0F3D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F3D->then_instructions;

                           body.emit(assign(r0F31, add(r0F31, body.constant(int(2))), 0x01));

                           body.emit(assign(r0F2F, lshift(r0F2F, body.constant(int(2))), 0x01));


                        body.instructions = f0F3D_parent_instructions;
                        body.emit(f0F3D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F41 = bit_and(r0F2F, body.constant(2147483648u));
                        ir_expression *const r0F42 = equal(r0F41, body.constant(0u));
                        ir_if *f0F40 = new(mem_ctx) ir_if(operand(r0F42).val);
                        exec_list *const f0F40_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F40->then_instructions;

                           body.emit(assign(r0F31, add(r0F31, body.constant(int(1))), 0x01));


                        body.instructions = f0F40_parent_instructions;
                        body.emit(f0F40);

                        /* END IF */

                        body.emit(assign(r0F30, r0F31, 0x01));


                     body.instructions = f0F32_parent_instructions;
                     body.emit(f0F32);

                     /* END IF */

                     body.emit(assign(r0F2C, add(r0F30, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0F44 = less(r0F2C, body.constant(int(0)));
                     ir_if *f0F43 = new(mem_ctx) ir_if(operand(r0F44).val);
                     exec_list *const f0F43_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F43->then_instructions;

                        ir_expression *const r0F45 = neg(r0F2C);
                        body.emit(assign(r0F2A, rshift(swizzle_x(r0E6F), r0F45), 0x01));

                        ir_expression *const r0F46 = bit_and(r0F2C, body.constant(int(31)));
                        body.emit(assign(r0F2B, lshift(swizzle_x(r0E6F), r0F46), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F43->else_instructions;

                        body.emit(assign(r0F2A, lshift(swizzle_x(r0E6F), r0F2C), 0x01));

                        body.emit(assign(r0F2B, body.constant(0u), 0x01));


                     body.instructions = f0F43_parent_instructions;
                     body.emit(f0F43);

                     /* END IF */

                     body.emit(assign(r0F29, sub(body.constant(int(-31)), r0F2C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F2D->else_instructions;

                     ir_variable *const r0F47 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r0F47, r0E80, 0x01));

                     ir_variable *const r0F48 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r0F49 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0F49);
                     /* IF CONDITION */
                     ir_expression *const r0F4B = equal(r0E80, body.constant(0u));
                     ir_if *f0F4A = new(mem_ctx) ir_if(operand(r0F4B).val);
                     exec_list *const f0F4A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F4A->then_instructions;

                        body.emit(assign(r0F48, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F4A->else_instructions;

                        body.emit(assign(r0F49, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0F4D = bit_and(r0E80, body.constant(4294901760u));
                        ir_expression *const r0F4E = equal(r0F4D, body.constant(0u));
                        ir_if *f0F4C = new(mem_ctx) ir_if(operand(r0F4E).val);
                        exec_list *const f0F4C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F4C->then_instructions;

                           body.emit(assign(r0F49, body.constant(int(16)), 0x01));

                           body.emit(assign(r0F47, lshift(r0E80, body.constant(int(16))), 0x01));


                        body.instructions = f0F4C_parent_instructions;
                        body.emit(f0F4C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F50 = bit_and(r0F47, body.constant(4278190080u));
                        ir_expression *const r0F51 = equal(r0F50, body.constant(0u));
                        ir_if *f0F4F = new(mem_ctx) ir_if(operand(r0F51).val);
                        exec_list *const f0F4F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F4F->then_instructions;

                           body.emit(assign(r0F49, add(r0F49, body.constant(int(8))), 0x01));

                           body.emit(assign(r0F47, lshift(r0F47, body.constant(int(8))), 0x01));


                        body.instructions = f0F4F_parent_instructions;
                        body.emit(f0F4F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F53 = bit_and(r0F47, body.constant(4026531840u));
                        ir_expression *const r0F54 = equal(r0F53, body.constant(0u));
                        ir_if *f0F52 = new(mem_ctx) ir_if(operand(r0F54).val);
                        exec_list *const f0F52_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F52->then_instructions;

                           body.emit(assign(r0F49, add(r0F49, body.constant(int(4))), 0x01));

                           body.emit(assign(r0F47, lshift(r0F47, body.constant(int(4))), 0x01));


                        body.instructions = f0F52_parent_instructions;
                        body.emit(f0F52);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F56 = bit_and(r0F47, body.constant(3221225472u));
                        ir_expression *const r0F57 = equal(r0F56, body.constant(0u));
                        ir_if *f0F55 = new(mem_ctx) ir_if(operand(r0F57).val);
                        exec_list *const f0F55_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F55->then_instructions;

                           body.emit(assign(r0F49, add(r0F49, body.constant(int(2))), 0x01));

                           body.emit(assign(r0F47, lshift(r0F47, body.constant(int(2))), 0x01));


                        body.instructions = f0F55_parent_instructions;
                        body.emit(f0F55);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F59 = bit_and(r0F47, body.constant(2147483648u));
                        ir_expression *const r0F5A = equal(r0F59, body.constant(0u));
                        ir_if *f0F58 = new(mem_ctx) ir_if(operand(r0F5A).val);
                        exec_list *const f0F58_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F58->then_instructions;

                           body.emit(assign(r0F49, add(r0F49, body.constant(int(1))), 0x01));


                        body.instructions = f0F58_parent_instructions;
                        body.emit(f0F58);

                        /* END IF */

                        body.emit(assign(r0F48, r0F49, 0x01));


                     body.instructions = f0F4A_parent_instructions;
                     body.emit(f0F4A);

                     /* END IF */

                     body.emit(assign(r0F2C, add(r0F48, body.constant(int(-11))), 0x01));

                     ir_variable *const r0F5B = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0F5B, lshift(swizzle_x(r0E6F), r0F2C), 0x01));

                     ir_variable *const r0F5C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0F5E = equal(r0F2C, body.constant(int(0)));
                     ir_if *f0F5D = new(mem_ctx) ir_if(operand(r0F5E).val);
                     exec_list *const f0F5D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F5D->then_instructions;

                        body.emit(assign(r0F5C, r0E80, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F5D->else_instructions;

                        ir_expression *const r0F5F = lshift(r0E80, r0F2C);
                        ir_expression *const r0F60 = neg(r0F2C);
                        ir_expression *const r0F61 = bit_and(r0F60, body.constant(int(31)));
                        ir_expression *const r0F62 = rshift(swizzle_x(r0E6F), r0F61);
                        body.emit(assign(r0F5C, bit_or(r0F5F, r0F62), 0x01));


                     body.instructions = f0F5D_parent_instructions;
                     body.emit(f0F5D);

                     /* END IF */

                     body.emit(assign(r0F2A, r0F5C, 0x01));

                     body.emit(assign(r0F2B, r0F5B, 0x01));

                     body.emit(assign(r0F29, sub(body.constant(int(1)), r0F2C), 0x01));


                  body.instructions = f0F2D_parent_instructions;
                  body.emit(f0F2D);

                  /* END IF */

                  body.emit(assign(r0E73, r0F29, 0x01));

                  body.emit(assign(r0E75, r0F2A, 0x01));

                  body.emit(assign(r0E76, r0F2B, 0x01));


               body.instructions = f0F25_parent_instructions;
               body.emit(f0F25);

               /* END IF */


            body.instructions = f0F23_parent_instructions;
            body.emit(f0F23);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0F63 = new(mem_ctx) ir_if(operand(r0E70).val);
            exec_list *const f0F63_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0F63->then_instructions;

               ir_expression *const r0F64 = add(r0E74, r0E73);
               body.emit(assign(r0E79, add(r0F64, body.constant(int(-1024))), 0x01));

               body.emit(assign(r0E77, bit_or(r0E77, body.constant(1048576u)), 0x01));

               ir_variable *const r0F65 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0F65, lshift(r0E76, body.constant(int(12))), 0x01));

               ir_variable *const r0F66 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r0F67 = lshift(r0E75, body.constant(int(12)));
               ir_expression *const r0F68 = rshift(r0E76, body.constant(int(20)));
               body.emit(assign(r0F66, bit_or(r0F67, r0F68), 0x01));

               body.emit(assign(r0E75, r0F66, 0x01));

               body.emit(assign(r0E76, r0F65, 0x01));

               ir_variable *const r0F69 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0F69);
               ir_variable *const r0F6A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r0F6A);
               ir_variable *const r0F6B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0F6B);
               ir_variable *const r0F6C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F6C, bit_and(r0E78, body.constant(65535u)), 0x01));

               ir_variable *const r0F6D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F6D, rshift(r0E78, body.constant(int(16))), 0x01));

               ir_variable *const r0F6E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F6E, bit_and(r0F65, body.constant(65535u)), 0x01));

               ir_variable *const r0F6F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F6F, rshift(r0F65, body.constant(int(16))), 0x01));

               ir_variable *const r0F70 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F70, mul(r0F6D, r0F6E), 0x01));

               ir_expression *const r0F71 = mul(r0F6C, r0F6F);
               body.emit(assign(r0F6A, add(r0F71, r0F70), 0x01));

               ir_expression *const r0F72 = mul(r0F6D, r0F6F);
               ir_expression *const r0F73 = less(r0F6A, r0F70);
               ir_expression *const r0F74 = expr(ir_unop_b2i, r0F73);
               ir_expression *const r0F75 = expr(ir_unop_i2u, r0F74);
               ir_expression *const r0F76 = lshift(r0F75, body.constant(int(16)));
               ir_expression *const r0F77 = rshift(r0F6A, body.constant(int(16)));
               ir_expression *const r0F78 = add(r0F76, r0F77);
               body.emit(assign(r0F69, add(r0F72, r0F78), 0x01));

               body.emit(assign(r0F6A, lshift(r0F6A, body.constant(int(16))), 0x01));

               ir_expression *const r0F79 = mul(r0F6C, r0F6E);
               body.emit(assign(r0F6B, add(r0F79, r0F6A), 0x01));

               ir_expression *const r0F7A = less(r0F6B, r0F6A);
               ir_expression *const r0F7B = expr(ir_unop_b2i, r0F7A);
               ir_expression *const r0F7C = expr(ir_unop_i2u, r0F7B);
               body.emit(assign(r0F69, add(r0F69, r0F7C), 0x01));

               ir_variable *const r0F7D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0F7D);
               ir_variable *const r0F7E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r0F7E);
               ir_variable *const r0F7F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0F7F);
               ir_variable *const r0F80 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F80, bit_and(r0E78, body.constant(65535u)), 0x01));

               ir_variable *const r0F81 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F81, rshift(r0E78, body.constant(int(16))), 0x01));

               ir_variable *const r0F82 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F82, bit_and(r0F66, body.constant(65535u)), 0x01));

               ir_variable *const r0F83 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F83, rshift(r0F66, body.constant(int(16))), 0x01));

               ir_variable *const r0F84 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F84, mul(r0F81, r0F82), 0x01));

               ir_expression *const r0F85 = mul(r0F80, r0F83);
               body.emit(assign(r0F7E, add(r0F85, r0F84), 0x01));

               ir_expression *const r0F86 = mul(r0F81, r0F83);
               ir_expression *const r0F87 = less(r0F7E, r0F84);
               ir_expression *const r0F88 = expr(ir_unop_b2i, r0F87);
               ir_expression *const r0F89 = expr(ir_unop_i2u, r0F88);
               ir_expression *const r0F8A = lshift(r0F89, body.constant(int(16)));
               ir_expression *const r0F8B = rshift(r0F7E, body.constant(int(16)));
               ir_expression *const r0F8C = add(r0F8A, r0F8B);
               body.emit(assign(r0F7D, add(r0F86, r0F8C), 0x01));

               body.emit(assign(r0F7E, lshift(r0F7E, body.constant(int(16))), 0x01));

               ir_expression *const r0F8D = mul(r0F80, r0F82);
               body.emit(assign(r0F7F, add(r0F8D, r0F7E), 0x01));

               ir_expression *const r0F8E = less(r0F7F, r0F7E);
               ir_expression *const r0F8F = expr(ir_unop_b2i, r0F8E);
               ir_expression *const r0F90 = expr(ir_unop_i2u, r0F8F);
               body.emit(assign(r0F7D, add(r0F7D, r0F90), 0x01));

               ir_variable *const r0F91 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F91, add(r0F7F, r0F69), 0x01));

               ir_variable *const r0F92 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0F92);
               ir_variable *const r0F93 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r0F93);
               ir_variable *const r0F94 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0F94);
               ir_variable *const r0F95 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F95, bit_and(r0E77, body.constant(65535u)), 0x01));

               ir_variable *const r0F96 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F96, rshift(r0E77, body.constant(int(16))), 0x01));

               ir_variable *const r0F97 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F97, bit_and(r0F66, body.constant(65535u)), 0x01));

               ir_variable *const r0F98 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F98, rshift(r0F66, body.constant(int(16))), 0x01));

               ir_variable *const r0F99 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F99, mul(r0F96, r0F97), 0x01));

               ir_expression *const r0F9A = mul(r0F95, r0F98);
               body.emit(assign(r0F93, add(r0F9A, r0F99), 0x01));

               ir_expression *const r0F9B = mul(r0F96, r0F98);
               ir_expression *const r0F9C = less(r0F93, r0F99);
               ir_expression *const r0F9D = expr(ir_unop_b2i, r0F9C);
               ir_expression *const r0F9E = expr(ir_unop_i2u, r0F9D);
               ir_expression *const r0F9F = lshift(r0F9E, body.constant(int(16)));
               ir_expression *const r0FA0 = rshift(r0F93, body.constant(int(16)));
               ir_expression *const r0FA1 = add(r0F9F, r0FA0);
               body.emit(assign(r0F92, add(r0F9B, r0FA1), 0x01));

               body.emit(assign(r0F93, lshift(r0F93, body.constant(int(16))), 0x01));

               ir_expression *const r0FA2 = mul(r0F95, r0F97);
               body.emit(assign(r0F94, add(r0FA2, r0F93), 0x01));

               ir_expression *const r0FA3 = less(r0F94, r0F93);
               ir_expression *const r0FA4 = expr(ir_unop_b2i, r0FA3);
               ir_expression *const r0FA5 = expr(ir_unop_i2u, r0FA4);
               body.emit(assign(r0F92, add(r0F92, r0FA5), 0x01));

               ir_variable *const r0FA6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r0FA7 = less(r0F91, r0F7F);
               ir_expression *const r0FA8 = expr(ir_unop_b2i, r0FA7);
               ir_expression *const r0FA9 = expr(ir_unop_i2u, r0FA8);
               ir_expression *const r0FAA = add(r0F7D, r0FA9);
               body.emit(assign(r0FA6, add(r0F94, r0FAA), 0x01));

               ir_variable *const r0FAB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0FAB);
               ir_variable *const r0FAC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r0FAC);
               ir_variable *const r0FAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0FAD);
               ir_variable *const r0FAE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0FAE, bit_and(r0E77, body.constant(65535u)), 0x01));

               ir_variable *const r0FAF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0FAF, rshift(r0E77, body.constant(int(16))), 0x01));

               ir_variable *const r0FB0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0FB0, bit_and(r0F65, body.constant(65535u)), 0x01));

               ir_variable *const r0FB1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0FB1, rshift(r0F65, body.constant(int(16))), 0x01));

               ir_variable *const r0FB2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0FB2, mul(r0FAF, r0FB0), 0x01));

               ir_expression *const r0FB3 = mul(r0FAE, r0FB1);
               body.emit(assign(r0FAC, add(r0FB3, r0FB2), 0x01));

               ir_expression *const r0FB4 = mul(r0FAF, r0FB1);
               ir_expression *const r0FB5 = less(r0FAC, r0FB2);
               ir_expression *const r0FB6 = expr(ir_unop_b2i, r0FB5);
               ir_expression *const r0FB7 = expr(ir_unop_i2u, r0FB6);
               ir_expression *const r0FB8 = lshift(r0FB7, body.constant(int(16)));
               ir_expression *const r0FB9 = rshift(r0FAC, body.constant(int(16)));
               ir_expression *const r0FBA = add(r0FB8, r0FB9);
               body.emit(assign(r0FAB, add(r0FB4, r0FBA), 0x01));

               body.emit(assign(r0FAC, lshift(r0FAC, body.constant(int(16))), 0x01));

               ir_expression *const r0FBB = mul(r0FAE, r0FB0);
               body.emit(assign(r0FAD, add(r0FBB, r0FAC), 0x01));

               ir_expression *const r0FBC = less(r0FAD, r0FAC);
               ir_expression *const r0FBD = expr(ir_unop_b2i, r0FBC);
               ir_expression *const r0FBE = expr(ir_unop_i2u, r0FBD);
               body.emit(assign(r0FAB, add(r0FAB, r0FBE), 0x01));

               ir_variable *const r0FBF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0FBF, add(r0FAD, r0F91), 0x01));

               ir_variable *const r0FC0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r0FC1 = less(r0FBF, r0FAD);
               ir_expression *const r0FC2 = expr(ir_unop_b2i, r0FC1);
               ir_expression *const r0FC3 = expr(ir_unop_i2u, r0FC2);
               ir_expression *const r0FC4 = add(r0FAB, r0FC3);
               body.emit(assign(r0FC0, add(r0FA6, r0FC4), 0x01));

               ir_variable *const r0FC5 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0FC6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0FC6, add(r0FC0, r0E78), 0x01));

               ir_expression *const r0FC7 = less(r0FA6, r0F94);
               ir_expression *const r0FC8 = expr(ir_unop_b2i, r0FC7);
               ir_expression *const r0FC9 = expr(ir_unop_i2u, r0FC8);
               ir_expression *const r0FCA = add(r0F92, r0FC9);
               ir_expression *const r0FCB = less(r0FC0, r0FA6);
               ir_expression *const r0FCC = expr(ir_unop_b2i, r0FCB);
               ir_expression *const r0FCD = expr(ir_unop_i2u, r0FCC);
               ir_expression *const r0FCE = add(r0FCA, r0FCD);
               ir_expression *const r0FCF = add(r0FCE, r0E77);
               ir_expression *const r0FD0 = less(r0FC6, r0FC0);
               ir_expression *const r0FD1 = expr(ir_unop_b2i, r0FD0);
               ir_expression *const r0FD2 = expr(ir_unop_i2u, r0FD1);
               body.emit(assign(r0FC5, add(r0FCF, r0FD2), 0x01));

               body.emit(assign(r0E7C, r0FC5, 0x01));

               body.emit(assign(r0E7B, r0FC6, 0x01));

               ir_expression *const r0FD3 = nequal(r0F6B, body.constant(0u));
               ir_expression *const r0FD4 = expr(ir_unop_b2i, r0FD3);
               ir_expression *const r0FD5 = expr(ir_unop_i2u, r0FD4);
               body.emit(assign(r0E7A, bit_or(r0FBF, r0FD5), 0x01));

               /* IF CONDITION */
               ir_expression *const r0FD7 = lequal(body.constant(2097152u), r0FC5);
               ir_if *f0FD6 = new(mem_ctx) ir_if(operand(r0FD7).val);
               exec_list *const f0FD6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0FD6->then_instructions;

                  ir_variable *const r0FD8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0FD8);
                  body.emit(assign(r0FD8, lshift(r0FC6, body.constant(int(31))), 0x01));

                  ir_expression *const r0FD9 = nequal(r0E7A, body.constant(0u));
                  ir_expression *const r0FDA = expr(ir_unop_b2i, r0FD9);
                  ir_expression *const r0FDB = expr(ir_unop_i2u, r0FDA);
                  body.emit(assign(r0FD8, bit_or(r0FD8, r0FDB), 0x01));

                  body.emit(assign(r0E7C, rshift(r0FC5, body.constant(int(1))), 0x01));

                  ir_expression *const r0FDC = lshift(r0FC5, body.constant(int(31)));
                  ir_expression *const r0FDD = rshift(r0FC6, body.constant(int(1)));
                  body.emit(assign(r0E7B, bit_or(r0FDC, r0FDD), 0x01));

                  body.emit(assign(r0E7A, r0FD8, 0x01));

                  body.emit(assign(r0E79, add(r0E79, body.constant(int(1))), 0x01));


               body.instructions = f0FD6_parent_instructions;
               body.emit(f0FD6);

               /* END IF */

               ir_variable *const r0FDE = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0FDE, r0E79, 0x01));

               ir_variable *const r0FDF = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0FDF, r0E7C, 0x01));

               ir_variable *const r0FE0 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0FE0, r0E7B, 0x01));

               ir_variable *const r0FE1 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0FE1, r0E7A, 0x01));

               ir_variable *const r0FE2 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0FE2, body.constant(true), 0x01));

               ir_variable *const r0FE3 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0FE4 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0FE4);
               ir_expression *const r0FE5 = expr(ir_unop_u2i, r0E7A);
               body.emit(assign(r0FE4, less(r0FE5, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0FE7 = lequal(body.constant(int(2045)), r0E79);
               ir_if *f0FE6 = new(mem_ctx) ir_if(operand(r0FE7).val);
               exec_list *const f0FE6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0FE6->then_instructions;

                  ir_variable *const r0FE8 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0FEA = less(body.constant(int(2045)), r0E79);
                  ir_if *f0FE9 = new(mem_ctx) ir_if(operand(r0FEA).val);
                  exec_list *const f0FE9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FE9->then_instructions;

                     body.emit(assign(r0FE8, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FE9->else_instructions;

                     ir_variable *const r0FEB = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0FED = equal(r0E79, body.constant(int(2045)));
                     ir_if *f0FEC = new(mem_ctx) ir_if(operand(r0FED).val);
                     exec_list *const f0FEC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FEC->then_instructions;

                        ir_expression *const r0FEE = equal(body.constant(2097151u), r0E7C);
                        ir_expression *const r0FEF = equal(body.constant(4294967295u), r0E7B);
                        body.emit(assign(r0FEB, logic_and(r0FEE, r0FEF), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FEC->else_instructions;

                        body.emit(assign(r0FEB, body.constant(false), 0x01));


                     body.instructions = f0FEC_parent_instructions;
                     body.emit(f0FEC);

                     /* END IF */

                     body.emit(assign(r0FE8, logic_and(r0FEB, r0FE4), 0x01));


                  body.instructions = f0FE9_parent_instructions;
                  body.emit(f0FE9);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0FF0 = new(mem_ctx) ir_if(operand(r0FE8).val);
                  exec_list *const f0FF0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FF0->then_instructions;

                     ir_variable *const r0FF1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0FF1);
                     ir_expression *const r0FF2 = lshift(r0E72, body.constant(int(31)));
                     body.emit(assign(r0FF1, add(r0FF2, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0FF1, body.constant(0u), 0x01));

                     body.emit(assign(r0FE3, r0FF1, 0x03));

                     body.emit(assign(r0FE2, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FF0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0FF4 = less(r0E79, body.constant(int(0)));
                     ir_if *f0FF3 = new(mem_ctx) ir_if(operand(r0FF4).val);
                     exec_list *const f0FF3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FF3->then_instructions;

                        ir_variable *const r0FF5 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0FF5, r0E7A, 0x01));

                        ir_variable *const r0FF6 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0FF6, neg(r0E79), 0x01));

                        ir_variable *const r0FF7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0FF7);
                        ir_variable *const r0FF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0FF8);
                        ir_variable *const r0FF9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0FF9);
                        ir_variable *const r0FFA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0FFB = neg(r0FF6);
                        body.emit(assign(r0FFA, bit_and(r0FFB, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0FFD = equal(r0FF6, body.constant(int(0)));
                        ir_if *f0FFC = new(mem_ctx) ir_if(operand(r0FFD).val);
                        exec_list *const f0FFC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FFC->then_instructions;

                           body.emit(assign(r0FF7, r0E7A, 0x01));

                           body.emit(assign(r0FF8, r0E7B, 0x01));

                           body.emit(assign(r0FF9, r0E7C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0FFC->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0FFF = less(r0FF6, body.constant(int(32)));
                           ir_if *f0FFE = new(mem_ctx) ir_if(operand(r0FFF).val);
                           exec_list *const f0FFE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0FFE->then_instructions;

                              body.emit(assign(r0FF7, lshift(r0E7B, r0FFA), 0x01));

                              ir_expression *const r1000 = lshift(r0E7C, r0FFA);
                              ir_expression *const r1001 = rshift(r0E7B, r0FF6);
                              body.emit(assign(r0FF8, bit_or(r1000, r1001), 0x01));

                              body.emit(assign(r0FF9, rshift(r0E7C, r0FF6), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0FFE->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1003 = equal(r0FF6, body.constant(int(32)));
                              ir_if *f1002 = new(mem_ctx) ir_if(operand(r1003).val);
                              exec_list *const f1002_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1002->then_instructions;

                                 body.emit(assign(r0FF7, r0E7B, 0x01));

                                 body.emit(assign(r0FF8, r0E7C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1002->else_instructions;

                                 body.emit(assign(r0FF5, bit_or(r0E7A, r0E7B), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1005 = less(r0FF6, body.constant(int(64)));
                                 ir_if *f1004 = new(mem_ctx) ir_if(operand(r1005).val);
                                 exec_list *const f1004_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1004->then_instructions;

                                    body.emit(assign(r0FF7, lshift(r0E7C, r0FFA), 0x01));

                                    ir_expression *const r1006 = bit_and(r0FF6, body.constant(int(31)));
                                    body.emit(assign(r0FF8, rshift(r0E7C, r1006), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1004->else_instructions;

                                    ir_variable *const r1007 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1009 = equal(r0FF6, body.constant(int(64)));
                                    ir_if *f1008 = new(mem_ctx) ir_if(operand(r1009).val);
                                    exec_list *const f1008_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1008->then_instructions;

                                       body.emit(assign(r1007, r0E7C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1008->else_instructions;

                                       ir_expression *const r100A = nequal(r0E7C, body.constant(0u));
                                       ir_expression *const r100B = expr(ir_unop_b2i, r100A);
                                       body.emit(assign(r1007, expr(ir_unop_i2u, r100B), 0x01));


                                    body.instructions = f1008_parent_instructions;
                                    body.emit(f1008);

                                    /* END IF */

                                    body.emit(assign(r0FF7, r1007, 0x01));

                                    body.emit(assign(r0FF8, body.constant(0u), 0x01));


                                 body.instructions = f1004_parent_instructions;
                                 body.emit(f1004);

                                 /* END IF */


                              body.instructions = f1002_parent_instructions;
                              body.emit(f1002);

                              /* END IF */

                              body.emit(assign(r0FF9, body.constant(0u), 0x01));


                           body.instructions = f0FFE_parent_instructions;
                           body.emit(f0FFE);

                           /* END IF */

                           ir_expression *const r100C = nequal(r0FF5, body.constant(0u));
                           ir_expression *const r100D = expr(ir_unop_b2i, r100C);
                           ir_expression *const r100E = expr(ir_unop_i2u, r100D);
                           body.emit(assign(r0FF7, bit_or(r0FF7, r100E), 0x01));


                        body.instructions = f0FFC_parent_instructions;
                        body.emit(f0FFC);

                        /* END IF */

                        body.emit(assign(r0FDF, r0FF9, 0x01));

                        body.emit(assign(r0FE0, r0FF8, 0x01));

                        body.emit(assign(r0FE1, r0FF7, 0x01));

                        body.emit(assign(r0FDE, body.constant(int(0)), 0x01));

                        body.emit(assign(r0FE4, less(r0FF7, body.constant(0u)), 0x01));


                     body.instructions = f0FF3_parent_instructions;
                     body.emit(f0FF3);

                     /* END IF */


                  body.instructions = f0FF0_parent_instructions;
                  body.emit(f0FF0);

                  /* END IF */


               body.instructions = f0FE6_parent_instructions;
               body.emit(f0FE6);

               /* END IF */

               /* IF CONDITION */
               ir_if *f100F = new(mem_ctx) ir_if(operand(r0FE2).val);
               exec_list *const f100F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f100F->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1010 = new(mem_ctx) ir_if(operand(r0FE4).val);
                  exec_list *const f1010_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1010->then_instructions;

                     ir_variable *const r1011 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1011, add(r0FE0, body.constant(1u)), 0x01));

                     ir_expression *const r1012 = less(r1011, r0FE0);
                     ir_expression *const r1013 = expr(ir_unop_b2i, r1012);
                     ir_expression *const r1014 = expr(ir_unop_i2u, r1013);
                     body.emit(assign(r0FDF, add(r0FDF, r1014), 0x01));

                     ir_expression *const r1015 = equal(r0FE1, body.constant(0u));
                     ir_expression *const r1016 = expr(ir_unop_b2i, r1015);
                     ir_expression *const r1017 = expr(ir_unop_i2u, r1016);
                     ir_expression *const r1018 = add(r0FE1, r1017);
                     ir_expression *const r1019 = bit_and(r1018, body.constant(1u));
                     ir_expression *const r101A = expr(ir_unop_bit_not, r1019);
                     body.emit(assign(r0FE0, bit_and(r1011, r101A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1010->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r101C = bit_or(r0FDF, r0FE0);
                     ir_expression *const r101D = equal(r101C, body.constant(0u));
                     ir_if *f101B = new(mem_ctx) ir_if(operand(r101D).val);
                     exec_list *const f101B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f101B->then_instructions;

                        body.emit(assign(r0FDE, body.constant(int(0)), 0x01));


                     body.instructions = f101B_parent_instructions;
                     body.emit(f101B);

                     /* END IF */


                  body.instructions = f1010_parent_instructions;
                  body.emit(f1010);

                  /* END IF */

                  ir_variable *const r101E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r101E);
                  ir_expression *const r101F = lshift(r0E72, body.constant(int(31)));
                  ir_expression *const r1020 = expr(ir_unop_i2u, r0FDE);
                  ir_expression *const r1021 = lshift(r1020, body.constant(int(20)));
                  ir_expression *const r1022 = add(r101F, r1021);
                  body.emit(assign(r101E, add(r1022, r0FDF), 0x02));

                  body.emit(assign(r101E, r0FE0, 0x01));

                  body.emit(assign(r0FE3, r101E, 0x03));

                  body.emit(assign(r0FE2, body.constant(false), 0x01));


               body.instructions = f100F_parent_instructions;
               body.emit(f100F);

               /* END IF */

               body.emit(assign(r0E71, r0FE3, 0x03));

               body.emit(assign(r0E70, body.constant(false), 0x01));


            body.instructions = f0F63_parent_instructions;
            body.emit(f0F63);

            /* END IF */


         body.instructions = f0F22_parent_instructions;
         body.emit(f0F22);

         /* END IF */


      body.instructions = f0EB8_parent_instructions;
      body.emit(f0EB8);

      /* END IF */


   body.instructions = f0E89_parent_instructions;
   body.emit(f0E89);

   /* END IF */

   body.emit(ret(r0E71));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1023 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1023);
   ir_variable *const r1024 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1024);
   ir_variable *const r1025 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r1025);
   ir_variable *const r1026 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r1026);
   ir_variable *const r1027 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r1027);
   ir_variable *const r1028 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r1028);
   ir_variable *const r1029 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1029);
   ir_variable *const r102A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r102A);
   ir_variable *const r102B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r102B);
   ir_variable *const r102C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r102C);
   ir_variable *const r102D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r102D);
   ir_variable *const r102E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r102E, add(r1025, r1028), 0x01));

   ir_variable *const r102F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r1030 = less(r102E, r1025);
   ir_expression *const r1031 = expr(ir_unop_b2i, r1030);
   body.emit(assign(r102F, expr(ir_unop_i2u, r1031), 0x01));

   ir_variable *const r1032 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1032, add(r1024, r1027), 0x01));

   body.emit(assign(r102D, add(r1032, r102F), 0x01));

   ir_expression *const r1033 = add(r1023, r1026);
   ir_expression *const r1034 = less(r102D, r102F);
   ir_expression *const r1035 = expr(ir_unop_b2i, r1034);
   ir_expression *const r1036 = expr(ir_unop_i2u, r1035);
   body.emit(assign(r102C, add(r1033, r1036), 0x01));

   ir_expression *const r1037 = less(r1032, r1024);
   ir_expression *const r1038 = expr(ir_unop_b2i, r1037);
   ir_expression *const r1039 = expr(ir_unop_i2u, r1038);
   body.emit(assign(r102C, add(r102C, r1039), 0x01));

   body.emit(assign(r102B, r102E, 0x01));

   body.emit(assign(r102A, r102D, 0x01));

   body.emit(assign(r1029, r102C, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r103A = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r103A);
   ir_variable *const r103B = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r103B);
   ir_variable *const r103C = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r103C);
   ir_variable *const r103D = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r103D);
   ir_variable *const r103E = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r103E);
   ir_variable *const r103F = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r103F);
   ir_variable *const r1040 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1040);
   ir_variable *const r1041 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1041);
   ir_variable *const r1042 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1042);
   ir_variable *const r1043 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1043);
   ir_variable *const r1044 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r1045 = less(r103C, r103F);
   ir_expression *const r1046 = expr(ir_unop_b2i, r1045);
   body.emit(assign(r1044, expr(ir_unop_i2u, r1046), 0x01));

   ir_variable *const r1047 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1047, sub(r103B, r103E), 0x01));

   ir_expression *const r1048 = sub(r103A, r103D);
   ir_expression *const r1049 = less(r1047, r1044);
   ir_expression *const r104A = expr(ir_unop_b2i, r1049);
   ir_expression *const r104B = expr(ir_unop_i2u, r104A);
   body.emit(assign(r1043, sub(r1048, r104B), 0x01));

   ir_expression *const r104C = less(r103B, r103E);
   ir_expression *const r104D = expr(ir_unop_b2i, r104C);
   ir_expression *const r104E = expr(ir_unop_i2u, r104D);
   body.emit(assign(r1043, sub(r1043, r104E), 0x01));

   body.emit(assign(r1042, sub(r103C, r103F), 0x01));

   body.emit(assign(r1041, sub(r1047, r1044), 0x01));

   body.emit(assign(r1040, r1043, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64Right(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r104F = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r104F);
   ir_variable *const r1050 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1050);
   ir_variable *const r1051 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r1051);
   ir_variable *const r1052 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1052);
   ir_variable *const r1053 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1053);
   ir_variable *const r1054 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1054);
   ir_variable *const r1055 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1055);
   ir_variable *const r1056 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1057 = neg(r1051);
   body.emit(assign(r1056, bit_and(r1057, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1059 = equal(r1051, body.constant(int(0)));
   ir_if *f1058 = new(mem_ctx) ir_if(operand(r1059).val);
   exec_list *const f1058_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1058->then_instructions;

      body.emit(assign(r1054, r1050, 0x01));

      body.emit(assign(r1055, r104F, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1058->else_instructions;

      /* IF CONDITION */
      ir_expression *const r105B = less(r1051, body.constant(int(32)));
      ir_if *f105A = new(mem_ctx) ir_if(operand(r105B).val);
      exec_list *const f105A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f105A->then_instructions;

         ir_expression *const r105C = lshift(r104F, r1056);
         ir_expression *const r105D = rshift(r1050, r1051);
         body.emit(assign(r1054, bit_or(r105C, r105D), 0x01));

         body.emit(assign(r1055, rshift(r104F, r1051), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f105A->else_instructions;

         ir_variable *const r105E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1060 = less(r1051, body.constant(int(64)));
         ir_if *f105F = new(mem_ctx) ir_if(operand(r1060).val);
         exec_list *const f105F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f105F->then_instructions;

            ir_expression *const r1061 = bit_and(r1051, body.constant(int(31)));
            body.emit(assign(r105E, rshift(r104F, r1061), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f105F->else_instructions;

            body.emit(assign(r105E, body.constant(0u), 0x01));


         body.instructions = f105F_parent_instructions;
         body.emit(f105F);

         /* END IF */

         body.emit(assign(r1054, r105E, 0x01));

         body.emit(assign(r1055, body.constant(0u), 0x01));


      body.instructions = f105A_parent_instructions;
      body.emit(f105A);

      /* END IF */


   body.instructions = f1058_parent_instructions;
   body.emit(f1058);

   /* END IF */

   body.emit(assign(r1053, r1054, 0x01));

   body.emit(assign(r1052, r1055, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
estimateDiv64To32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1062 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1062);
   ir_variable *const r1063 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1063);
   ir_variable *const r1064 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1064);
   ir_variable *const r1065 = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1066 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r1066);
   ir_variable *const r1067 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r1067);
   ir_variable *const r1068 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r1068);
   ir_variable *const r1069 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
   body.emit(r1069);
   body.emit(assign(r1068, body.constant(0u), 0x01));

   body.emit(assign(r1067, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r106B = lequal(r1064, r1062);
   ir_if *f106A = new(mem_ctx) ir_if(operand(r106B).val);
   exec_list *const f106A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f106A->then_instructions;

      body.emit(assign(r1065, body.constant(4294967295u), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f106A->else_instructions;

      body.emit(assign(r1069, rshift(r1064, body.constant(int(16))), 0x01));

      ir_variable *const r106C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r106E = lshift(r1069, body.constant(int(16)));
      ir_expression *const r106F = lequal(r106E, r1062);
      ir_if *f106D = new(mem_ctx) ir_if(operand(r106F).val);
      exec_list *const f106D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f106D->then_instructions;

         body.emit(assign(r106C, body.constant(4294901760u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f106D->else_instructions;

         ir_expression *const r1070 = expr(ir_binop_div, r1062, r1069);
         body.emit(assign(r106C, lshift(r1070, body.constant(int(16))), 0x01));


      body.instructions = f106D_parent_instructions;
      body.emit(f106D);

      /* END IF */

      body.emit(assign(r1066, r106C, 0x01));

      ir_variable *const r1071 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r1071);
      ir_variable *const r1072 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
      body.emit(r1072);
      ir_variable *const r1073 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r1073);
      ir_variable *const r1074 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1074, bit_and(r1064, body.constant(65535u)), 0x01));

      ir_variable *const r1075 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1075, rshift(r1064, body.constant(int(16))), 0x01));

      ir_variable *const r1076 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1076, bit_and(r106C, body.constant(65535u)), 0x01));

      ir_variable *const r1077 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1077, rshift(r106C, body.constant(int(16))), 0x01));

      ir_variable *const r1078 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1078, mul(r1075, r1076), 0x01));

      ir_expression *const r1079 = mul(r1074, r1077);
      body.emit(assign(r1072, add(r1079, r1078), 0x01));

      ir_expression *const r107A = mul(r1075, r1077);
      ir_expression *const r107B = less(r1072, r1078);
      ir_expression *const r107C = expr(ir_unop_b2i, r107B);
      ir_expression *const r107D = expr(ir_unop_i2u, r107C);
      ir_expression *const r107E = lshift(r107D, body.constant(int(16)));
      ir_expression *const r107F = rshift(r1072, body.constant(int(16)));
      ir_expression *const r1080 = add(r107E, r107F);
      body.emit(assign(r1071, add(r107A, r1080), 0x01));

      body.emit(assign(r1072, lshift(r1072, body.constant(int(16))), 0x01));

      ir_expression *const r1081 = mul(r1074, r1076);
      body.emit(assign(r1073, add(r1081, r1072), 0x01));

      ir_expression *const r1082 = less(r1073, r1072);
      ir_expression *const r1083 = expr(ir_unop_b2i, r1082);
      ir_expression *const r1084 = expr(ir_unop_i2u, r1083);
      body.emit(assign(r1071, add(r1071, r1084), 0x01));

      ir_expression *const r1085 = sub(r1062, r1071);
      ir_expression *const r1086 = less(r1063, r1073);
      ir_expression *const r1087 = expr(ir_unop_b2i, r1086);
      ir_expression *const r1088 = expr(ir_unop_i2u, r1087);
      body.emit(assign(r1068, sub(r1085, r1088), 0x01));

      body.emit(assign(r1067, sub(r1063, r1073), 0x01));

      /* LOOP BEGIN */
      ir_loop *f1089 = new(mem_ctx) ir_loop();
      exec_list *const f1089_parent_instructions = body.instructions;

         body.instructions = &f1089->body_instructions;

         /* IF CONDITION */
         ir_expression *const r108B = expr(ir_unop_u2i, r1068);
         ir_expression *const r108C = gequal(r108B, body.constant(int(0)));
         ir_if *f108A = new(mem_ctx) ir_if(operand(r108C).val);
         exec_list *const f108A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f108A->then_instructions;

            body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


         body.instructions = f108A_parent_instructions;
         body.emit(f108A);

         /* END IF */

         body.emit(assign(r1066, add(r1066, body.constant(4294901760u)), 0x01));

         ir_variable *const r108D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         ir_expression *const r108E = lshift(r1064, body.constant(int(16)));
         body.emit(assign(r108D, add(r1067, r108E), 0x01));

         ir_expression *const r108F = add(r1068, r1069);
         ir_expression *const r1090 = less(r108D, r1067);
         ir_expression *const r1091 = expr(ir_unop_b2i, r1090);
         ir_expression *const r1092 = expr(ir_unop_i2u, r1091);
         body.emit(assign(r1068, add(r108F, r1092), 0x01));

         body.emit(assign(r1067, r108D, 0x01));

      /* LOOP END */

      body.instructions = f1089_parent_instructions;
      body.emit(f1089);

      ir_expression *const r1093 = lshift(r1068, body.constant(int(16)));
      ir_expression *const r1094 = rshift(r1067, body.constant(int(16)));
      body.emit(assign(r1068, bit_or(r1093, r1094), 0x01));

      ir_variable *const r1095 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1097 = lshift(r1069, body.constant(int(16)));
      ir_expression *const r1098 = lequal(r1097, r1068);
      ir_if *f1096 = new(mem_ctx) ir_if(operand(r1098).val);
      exec_list *const f1096_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1096->then_instructions;

         body.emit(assign(r1095, body.constant(65535u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1096->else_instructions;

         body.emit(assign(r1095, expr(ir_binop_div, r1068, r1069), 0x01));


      body.instructions = f1096_parent_instructions;
      body.emit(f1096);

      /* END IF */

      body.emit(assign(r1066, bit_or(r1066, r1095), 0x01));

      body.emit(assign(r1065, r1066, 0x01));


   body.instructions = f106A_parent_instructions;
   body.emit(f106A);

   /* END IF */

   body.emit(ret(r1065));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul64By32To96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1099 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1099);
   ir_variable *const r109A = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r109A);
   ir_variable *const r109B = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r109B);
   ir_variable *const r109C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r109C);
   ir_variable *const r109D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r109D);
   ir_variable *const r109E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r109E);
   ir_variable *const r109F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r109F);
   ir_variable *const r10A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r10A0);
   ir_variable *const r10A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r10A1);
   ir_variable *const r10A2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r10A2, bit_and(r109A, body.constant(65535u)), 0x01));

   ir_variable *const r10A3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r10A3, rshift(r109A, body.constant(int(16))), 0x01));

   ir_variable *const r10A4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r10A4, bit_and(r109B, body.constant(65535u)), 0x01));

   ir_variable *const r10A5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r10A5, rshift(r109B, body.constant(int(16))), 0x01));

   ir_variable *const r10A6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r10A6, mul(r10A3, r10A4), 0x01));

   ir_expression *const r10A7 = mul(r10A2, r10A5);
   body.emit(assign(r10A0, add(r10A7, r10A6), 0x01));

   ir_expression *const r10A8 = mul(r10A3, r10A5);
   ir_expression *const r10A9 = less(r10A0, r10A6);
   ir_expression *const r10AA = expr(ir_unop_b2i, r10A9);
   ir_expression *const r10AB = expr(ir_unop_i2u, r10AA);
   ir_expression *const r10AC = lshift(r10AB, body.constant(int(16)));
   ir_expression *const r10AD = rshift(r10A0, body.constant(int(16)));
   ir_expression *const r10AE = add(r10AC, r10AD);
   body.emit(assign(r109F, add(r10A8, r10AE), 0x01));

   body.emit(assign(r10A0, lshift(r10A0, body.constant(int(16))), 0x01));

   ir_expression *const r10AF = mul(r10A2, r10A4);
   body.emit(assign(r10A1, add(r10AF, r10A0), 0x01));

   ir_expression *const r10B0 = less(r10A1, r10A0);
   ir_expression *const r10B1 = expr(ir_unop_b2i, r10B0);
   ir_expression *const r10B2 = expr(ir_unop_i2u, r10B1);
   body.emit(assign(r109F, add(r109F, r10B2), 0x01));

   ir_variable *const r10B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r10B3);
   ir_variable *const r10B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r10B4);
   ir_variable *const r10B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r10B5);
   ir_variable *const r10B6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r10B6, bit_and(r1099, body.constant(65535u)), 0x01));

   ir_variable *const r10B7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r10B7, rshift(r1099, body.constant(int(16))), 0x01));

   ir_variable *const r10B8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r10B8, bit_and(r109B, body.constant(65535u)), 0x01));

   ir_variable *const r10B9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r10B9, rshift(r109B, body.constant(int(16))), 0x01));

   ir_variable *const r10BA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r10BA, mul(r10B7, r10B8), 0x01));

   ir_expression *const r10BB = mul(r10B6, r10B9);
   body.emit(assign(r10B4, add(r10BB, r10BA), 0x01));

   ir_expression *const r10BC = mul(r10B7, r10B9);
   ir_expression *const r10BD = less(r10B4, r10BA);
   ir_expression *const r10BE = expr(ir_unop_b2i, r10BD);
   ir_expression *const r10BF = expr(ir_unop_i2u, r10BE);
   ir_expression *const r10C0 = lshift(r10BF, body.constant(int(16)));
   ir_expression *const r10C1 = rshift(r10B4, body.constant(int(16)));
   ir_expression *const r10C2 = add(r10C0, r10C1);
   body.emit(assign(r10B3, add(r10BC, r10C2), 0x01));

   body.emit(assign(r10B4, lshift(r10B4, body.constant(int(16))), 0x01));

   ir_expression *const r10C3 = mul(r10B6, r10B8);
   body.emit(assign(r10B5, add(r10C3, r10B4), 0x01));

   ir_expression *const r10C4 = less(r10B5, r10B4);
   ir_expression *const r10C5 = expr(ir_unop_b2i, r10C4);
   ir_expression *const r10C6 = expr(ir_unop_i2u, r10C5);
   body.emit(assign(r10B3, add(r10B3, r10C6), 0x01));

   ir_variable *const r10C7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r10C7, add(r10B5, r109F), 0x01));

   body.emit(assign(r109E, r10A1, 0x01));

   body.emit(assign(r109D, r10C7, 0x01));

   ir_expression *const r10C8 = less(r10C7, r10B5);
   ir_expression *const r10C9 = expr(ir_unop_b2i, r10C8);
   ir_expression *const r10CA = expr(ir_unop_i2u, r10C9);
   body.emit(assign(r109C, add(r10B3, r10CA), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fdiv64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r10CB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r10CB);
   ir_variable *const r10CC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r10CC);
   ir_variable *const r10CD = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r10CD, body.constant(true), 0x01));

   ir_variable *const r10CE = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r10CF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r10CF);
   ir_variable *const r10D0 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r10D0);
   ir_variable *const r10D1 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r10D1);
   ir_variable *const r10D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r10D2);
   ir_variable *const r10D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r10D3);
   ir_variable *const r10D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r10D4);
   ir_variable *const r10D5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r10D5);
   ir_variable *const r10D6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem3", ir_var_auto);
   body.emit(r10D6);
   ir_variable *const r10D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem2", ir_var_auto);
   body.emit(r10D7);
   ir_variable *const r10D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r10D8);
   ir_variable *const r10D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r10D9);
   ir_variable *const r10DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r10DA);
   ir_variable *const r10DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r10DB);
   ir_variable *const r10DC = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r10DC);
   body.emit(assign(r10DB, body.constant(0u), 0x01));

   body.emit(assign(r10DA, body.constant(0u), 0x01));

   body.emit(assign(r10D9, body.constant(0u), 0x01));

   body.emit(assign(r10D8, body.constant(0u), 0x01));

   body.emit(assign(r10D7, body.constant(0u), 0x01));

   body.emit(assign(r10D6, body.constant(0u), 0x01));

   ir_variable *const r10DD = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r10DD, swizzle_x(r10CB), 0x01));

   body.emit(assign(r10D5, r10DD, 0x01));

   ir_variable *const r10DE = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r10DE, bit_and(swizzle_y(r10CB), body.constant(1048575u)), 0x01));

   body.emit(assign(r10D4, r10DE, 0x01));

   ir_variable *const r10DF = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r10DF, swizzle_x(r10CC), 0x01));

   body.emit(assign(r10D3, r10DF, 0x01));

   ir_variable *const r10E0 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r10E0, bit_and(swizzle_y(r10CC), body.constant(1048575u)), 0x01));

   body.emit(assign(r10D2, r10E0, 0x01));

   ir_variable *const r10E1 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r10E2 = rshift(swizzle_y(r10CB), body.constant(int(20)));
   ir_expression *const r10E3 = bit_and(r10E2, body.constant(2047u));
   body.emit(assign(r10E1, expr(ir_unop_u2i, r10E3), 0x01));

   body.emit(assign(r10D1, r10E1, 0x01));

   ir_variable *const r10E4 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r10E5 = rshift(swizzle_y(r10CC), body.constant(int(20)));
   ir_expression *const r10E6 = bit_and(r10E5, body.constant(2047u));
   body.emit(assign(r10E4, expr(ir_unop_u2i, r10E6), 0x01));

   body.emit(assign(r10D0, r10E4, 0x01));

   ir_expression *const r10E7 = rshift(swizzle_y(r10CB), body.constant(int(31)));
   ir_expression *const r10E8 = rshift(swizzle_y(r10CC), body.constant(int(31)));
   body.emit(assign(r10CF, bit_xor(r10E7, r10E8), 0x01));

   /* IF CONDITION */
   ir_expression *const r10EA = equal(r10E1, body.constant(int(2047)));
   ir_if *f10E9 = new(mem_ctx) ir_if(operand(r10EA).val);
   exec_list *const f10E9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f10E9->then_instructions;

      /* IF CONDITION */
      ir_expression *const r10EC = bit_or(r10DE, swizzle_x(r10CB));
      ir_expression *const r10ED = nequal(r10EC, body.constant(0u));
      ir_if *f10EB = new(mem_ctx) ir_if(operand(r10ED).val);
      exec_list *const f10EB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f10EB->then_instructions;

         ir_variable *const r10EE = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r10EE, swizzle_x(r10CB), 0x01));

         ir_variable *const r10EF = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r10EF, swizzle_x(r10CC), 0x01));

         ir_variable *const r10F0 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r10F1 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r10F2 = rshift(swizzle_y(r10CB), body.constant(int(19)));
         ir_expression *const r10F3 = bit_and(r10F2, body.constant(4095u));
         ir_expression *const r10F4 = equal(r10F3, body.constant(4094u));
         ir_expression *const r10F5 = nequal(swizzle_x(r10CB), body.constant(0u));
         ir_expression *const r10F6 = bit_and(swizzle_y(r10CB), body.constant(524287u));
         ir_expression *const r10F7 = nequal(r10F6, body.constant(0u));
         ir_expression *const r10F8 = logic_or(r10F5, r10F7);
         body.emit(assign(r10F1, logic_and(r10F4, r10F8), 0x01));

         ir_variable *const r10F9 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r10FA = lshift(swizzle_y(r10CC), body.constant(int(1)));
         ir_expression *const r10FB = lequal(body.constant(4292870144u), r10FA);
         ir_expression *const r10FC = nequal(swizzle_x(r10CC), body.constant(0u));
         ir_expression *const r10FD = bit_and(swizzle_y(r10CC), body.constant(1048575u));
         ir_expression *const r10FE = nequal(r10FD, body.constant(0u));
         ir_expression *const r10FF = logic_or(r10FC, r10FE);
         body.emit(assign(r10F9, logic_and(r10FB, r10FF), 0x01));

         body.emit(assign(r10EE, bit_or(swizzle_y(r10CB), body.constant(524288u)), 0x02));

         body.emit(assign(r10EF, bit_or(swizzle_y(r10CC), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r1101 = lshift(swizzle_y(r10CB), body.constant(int(1)));
         ir_expression *const r1102 = lequal(body.constant(4292870144u), r1101);
         ir_expression *const r1103 = nequal(swizzle_x(r10CB), body.constant(0u));
         ir_expression *const r1104 = bit_and(swizzle_y(r10CB), body.constant(1048575u));
         ir_expression *const r1105 = nequal(r1104, body.constant(0u));
         ir_expression *const r1106 = logic_or(r1103, r1105);
         ir_expression *const r1107 = logic_and(r1102, r1106);
         ir_if *f1100 = new(mem_ctx) ir_if(operand(r1107).val);
         exec_list *const f1100_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1100->then_instructions;

            ir_variable *const r1108 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r110A = logic_and(r10F1, r10F9);
            ir_if *f1109 = new(mem_ctx) ir_if(operand(r110A).val);
            exec_list *const f1109_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1109->then_instructions;

               body.emit(assign(r1108, r10EF, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1109->else_instructions;

               body.emit(assign(r1108, r10EE, 0x03));


            body.instructions = f1109_parent_instructions;
            body.emit(f1109);

            /* END IF */

            body.emit(assign(r10F0, r1108, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1100->else_instructions;

            body.emit(assign(r10F0, r10EF, 0x03));


         body.instructions = f1100_parent_instructions;
         body.emit(f1100);

         /* END IF */

         body.emit(assign(r10CE, r10F0, 0x03));

         body.emit(assign(r10CD, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f10EB->else_instructions;

         /* IF CONDITION */
         ir_expression *const r110C = equal(r10E4, body.constant(int(2047)));
         ir_if *f110B = new(mem_ctx) ir_if(operand(r110C).val);
         exec_list *const f110B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f110B->then_instructions;

            /* IF CONDITION */
            ir_expression *const r110E = bit_or(r10E0, swizzle_x(r10CC));
            ir_expression *const r110F = nequal(r110E, body.constant(0u));
            ir_if *f110D = new(mem_ctx) ir_if(operand(r110F).val);
            exec_list *const f110D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f110D->then_instructions;

               ir_variable *const r1110 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r1110, swizzle_x(r10CB), 0x01));

               ir_variable *const r1111 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r1111, swizzle_x(r10CC), 0x01));

               ir_variable *const r1112 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1113 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r1114 = rshift(swizzle_y(r10CB), body.constant(int(19)));
               ir_expression *const r1115 = bit_and(r1114, body.constant(4095u));
               ir_expression *const r1116 = equal(r1115, body.constant(4094u));
               ir_expression *const r1117 = nequal(swizzle_x(r10CB), body.constant(0u));
               ir_expression *const r1118 = bit_and(swizzle_y(r10CB), body.constant(524287u));
               ir_expression *const r1119 = nequal(r1118, body.constant(0u));
               ir_expression *const r111A = logic_or(r1117, r1119);
               body.emit(assign(r1113, logic_and(r1116, r111A), 0x01));

               ir_variable *const r111B = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r111C = lshift(swizzle_y(r10CC), body.constant(int(1)));
               ir_expression *const r111D = lequal(body.constant(4292870144u), r111C);
               ir_expression *const r111E = nequal(swizzle_x(r10CC), body.constant(0u));
               ir_expression *const r111F = bit_and(swizzle_y(r10CC), body.constant(1048575u));
               ir_expression *const r1120 = nequal(r111F, body.constant(0u));
               ir_expression *const r1121 = logic_or(r111E, r1120);
               body.emit(assign(r111B, logic_and(r111D, r1121), 0x01));

               body.emit(assign(r1110, bit_or(swizzle_y(r10CB), body.constant(524288u)), 0x02));

               body.emit(assign(r1111, bit_or(swizzle_y(r10CC), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r1123 = lshift(swizzle_y(r10CB), body.constant(int(1)));
               ir_expression *const r1124 = lequal(body.constant(4292870144u), r1123);
               ir_expression *const r1125 = nequal(swizzle_x(r10CB), body.constant(0u));
               ir_expression *const r1126 = bit_and(swizzle_y(r10CB), body.constant(1048575u));
               ir_expression *const r1127 = nequal(r1126, body.constant(0u));
               ir_expression *const r1128 = logic_or(r1125, r1127);
               ir_expression *const r1129 = logic_and(r1124, r1128);
               ir_if *f1122 = new(mem_ctx) ir_if(operand(r1129).val);
               exec_list *const f1122_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1122->then_instructions;

                  ir_variable *const r112A = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r112C = logic_and(r1113, r111B);
                  ir_if *f112B = new(mem_ctx) ir_if(operand(r112C).val);
                  exec_list *const f112B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f112B->then_instructions;

                     body.emit(assign(r112A, r1111, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f112B->else_instructions;

                     body.emit(assign(r112A, r1110, 0x03));


                  body.instructions = f112B_parent_instructions;
                  body.emit(f112B);

                  /* END IF */

                  body.emit(assign(r1112, r112A, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1122->else_instructions;

                  body.emit(assign(r1112, r1111, 0x03));


               body.instructions = f1122_parent_instructions;
               body.emit(f1122);

               /* END IF */

               body.emit(assign(r10CE, r1112, 0x03));

               body.emit(assign(r10CD, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f110D->else_instructions;

               ir_constant_data r112D_data;
               memset(&r112D_data, 0, sizeof(ir_constant_data));
               r112D_data.u[0] = 4294967295;
               r112D_data.u[1] = 4294967295;
               ir_constant *const r112D = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r112D_data);
               body.emit(assign(r10CE, r112D, 0x03));

               body.emit(assign(r10CD, body.constant(false), 0x01));


            body.instructions = f110D_parent_instructions;
            body.emit(f110D);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f110B->else_instructions;

            ir_variable *const r112E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r112E);
            ir_expression *const r112F = lshift(r10CF, body.constant(int(31)));
            body.emit(assign(r112E, add(r112F, body.constant(2146435072u)), 0x02));

            body.emit(assign(r112E, body.constant(0u), 0x01));

            body.emit(assign(r10CE, r112E, 0x03));

            body.emit(assign(r10CD, body.constant(false), 0x01));


         body.instructions = f110B_parent_instructions;
         body.emit(f110B);

         /* END IF */


      body.instructions = f10EB_parent_instructions;
      body.emit(f10EB);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f10E9->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1131 = equal(r10E4, body.constant(int(2047)));
      ir_if *f1130 = new(mem_ctx) ir_if(operand(r1131).val);
      exec_list *const f1130_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1130->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1133 = bit_or(r10E0, swizzle_x(r10CC));
         ir_expression *const r1134 = nequal(r1133, body.constant(0u));
         ir_if *f1132 = new(mem_ctx) ir_if(operand(r1134).val);
         exec_list *const f1132_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1132->then_instructions;

            ir_variable *const r1135 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r1135, swizzle_x(r10CB), 0x01));

            ir_variable *const r1136 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r1136, swizzle_x(r10CC), 0x01));

            ir_variable *const r1137 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r1138 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r1139 = rshift(swizzle_y(r10CB), body.constant(int(19)));
            ir_expression *const r113A = bit_and(r1139, body.constant(4095u));
            ir_expression *const r113B = equal(r113A, body.constant(4094u));
            ir_expression *const r113C = nequal(swizzle_x(r10CB), body.constant(0u));
            ir_expression *const r113D = bit_and(swizzle_y(r10CB), body.constant(524287u));
            ir_expression *const r113E = nequal(r113D, body.constant(0u));
            ir_expression *const r113F = logic_or(r113C, r113E);
            body.emit(assign(r1138, logic_and(r113B, r113F), 0x01));

            ir_variable *const r1140 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r1141 = lshift(swizzle_y(r10CC), body.constant(int(1)));
            ir_expression *const r1142 = lequal(body.constant(4292870144u), r1141);
            ir_expression *const r1143 = nequal(swizzle_x(r10CC), body.constant(0u));
            ir_expression *const r1144 = bit_and(swizzle_y(r10CC), body.constant(1048575u));
            ir_expression *const r1145 = nequal(r1144, body.constant(0u));
            ir_expression *const r1146 = logic_or(r1143, r1145);
            body.emit(assign(r1140, logic_and(r1142, r1146), 0x01));

            body.emit(assign(r1135, bit_or(swizzle_y(r10CB), body.constant(524288u)), 0x02));

            body.emit(assign(r1136, bit_or(swizzle_y(r10CC), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r1148 = lshift(swizzle_y(r10CB), body.constant(int(1)));
            ir_expression *const r1149 = lequal(body.constant(4292870144u), r1148);
            ir_expression *const r114A = nequal(swizzle_x(r10CB), body.constant(0u));
            ir_expression *const r114B = bit_and(swizzle_y(r10CB), body.constant(1048575u));
            ir_expression *const r114C = nequal(r114B, body.constant(0u));
            ir_expression *const r114D = logic_or(r114A, r114C);
            ir_expression *const r114E = logic_and(r1149, r114D);
            ir_if *f1147 = new(mem_ctx) ir_if(operand(r114E).val);
            exec_list *const f1147_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1147->then_instructions;

               ir_variable *const r114F = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1151 = logic_and(r1138, r1140);
               ir_if *f1150 = new(mem_ctx) ir_if(operand(r1151).val);
               exec_list *const f1150_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1150->then_instructions;

                  body.emit(assign(r114F, r1136, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1150->else_instructions;

                  body.emit(assign(r114F, r1135, 0x03));


               body.instructions = f1150_parent_instructions;
               body.emit(f1150);

               /* END IF */

               body.emit(assign(r1137, r114F, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1147->else_instructions;

               body.emit(assign(r1137, r1136, 0x03));


            body.instructions = f1147_parent_instructions;
            body.emit(f1147);

            /* END IF */

            body.emit(assign(r10CE, r1137, 0x03));

            body.emit(assign(r10CD, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1132->else_instructions;

            ir_variable *const r1152 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r1152);
            body.emit(assign(r1152, lshift(r10CF, body.constant(int(31))), 0x02));

            body.emit(assign(r1152, body.constant(0u), 0x01));

            body.emit(assign(r10CE, r1152, 0x03));

            body.emit(assign(r10CD, body.constant(false), 0x01));


         body.instructions = f1132_parent_instructions;
         body.emit(f1132);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1130->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1154 = equal(r10E4, body.constant(int(0)));
         ir_if *f1153 = new(mem_ctx) ir_if(operand(r1154).val);
         exec_list *const f1153_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1153->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1156 = bit_or(r10E0, swizzle_x(r10CC));
            ir_expression *const r1157 = equal(r1156, body.constant(0u));
            ir_if *f1155 = new(mem_ctx) ir_if(operand(r1157).val);
            exec_list *const f1155_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1155->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1159 = expr(ir_unop_i2u, r10E1);
               ir_expression *const r115A = bit_or(r1159, r10DE);
               ir_expression *const r115B = bit_or(r115A, swizzle_x(r10CB));
               ir_expression *const r115C = equal(r115B, body.constant(0u));
               ir_if *f1158 = new(mem_ctx) ir_if(operand(r115C).val);
               exec_list *const f1158_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1158->then_instructions;

                  ir_constant_data r115D_data;
                  memset(&r115D_data, 0, sizeof(ir_constant_data));
                  r115D_data.u[0] = 4294967295;
                  r115D_data.u[1] = 4294967295;
                  ir_constant *const r115D = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r115D_data);
                  body.emit(assign(r10CE, r115D, 0x03));

                  body.emit(assign(r10CD, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1158->else_instructions;

                  ir_variable *const r115E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r115E);
                  ir_expression *const r115F = lshift(r10CF, body.constant(int(31)));
                  body.emit(assign(r115E, add(r115F, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r115E, body.constant(0u), 0x01));

                  body.emit(assign(r10CE, r115E, 0x03));

                  body.emit(assign(r10CD, body.constant(false), 0x01));


               body.instructions = f1158_parent_instructions;
               body.emit(f1158);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1155->else_instructions;

               ir_variable *const r1160 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r1160, r10E4, 0x01));

               ir_variable *const r1161 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r1161, r10E0, 0x01));

               ir_variable *const r1162 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r1162, r10DF, 0x01));

               ir_variable *const r1163 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1163);
               /* IF CONDITION */
               ir_expression *const r1165 = equal(r10E0, body.constant(0u));
               ir_if *f1164 = new(mem_ctx) ir_if(operand(r1165).val);
               exec_list *const f1164_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1164->then_instructions;

                  ir_variable *const r1166 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r1166, r10DF, 0x01));

                  ir_variable *const r1167 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r1168 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1168);
                  /* IF CONDITION */
                  ir_expression *const r116A = equal(swizzle_x(r10CC), body.constant(0u));
                  ir_if *f1169 = new(mem_ctx) ir_if(operand(r116A).val);
                  exec_list *const f1169_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1169->then_instructions;

                     body.emit(assign(r1167, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1169->else_instructions;

                     body.emit(assign(r1168, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r116C = bit_and(swizzle_x(r10CC), body.constant(4294901760u));
                     ir_expression *const r116D = equal(r116C, body.constant(0u));
                     ir_if *f116B = new(mem_ctx) ir_if(operand(r116D).val);
                     exec_list *const f116B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f116B->then_instructions;

                        body.emit(assign(r1168, body.constant(int(16)), 0x01));

                        body.emit(assign(r1166, lshift(swizzle_x(r10CC), body.constant(int(16))), 0x01));


                     body.instructions = f116B_parent_instructions;
                     body.emit(f116B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r116F = bit_and(r1166, body.constant(4278190080u));
                     ir_expression *const r1170 = equal(r116F, body.constant(0u));
                     ir_if *f116E = new(mem_ctx) ir_if(operand(r1170).val);
                     exec_list *const f116E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f116E->then_instructions;

                        body.emit(assign(r1168, add(r1168, body.constant(int(8))), 0x01));

                        body.emit(assign(r1166, lshift(r1166, body.constant(int(8))), 0x01));


                     body.instructions = f116E_parent_instructions;
                     body.emit(f116E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1172 = bit_and(r1166, body.constant(4026531840u));
                     ir_expression *const r1173 = equal(r1172, body.constant(0u));
                     ir_if *f1171 = new(mem_ctx) ir_if(operand(r1173).val);
                     exec_list *const f1171_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1171->then_instructions;

                        body.emit(assign(r1168, add(r1168, body.constant(int(4))), 0x01));

                        body.emit(assign(r1166, lshift(r1166, body.constant(int(4))), 0x01));


                     body.instructions = f1171_parent_instructions;
                     body.emit(f1171);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1175 = bit_and(r1166, body.constant(3221225472u));
                     ir_expression *const r1176 = equal(r1175, body.constant(0u));
                     ir_if *f1174 = new(mem_ctx) ir_if(operand(r1176).val);
                     exec_list *const f1174_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1174->then_instructions;

                        body.emit(assign(r1168, add(r1168, body.constant(int(2))), 0x01));

                        body.emit(assign(r1166, lshift(r1166, body.constant(int(2))), 0x01));


                     body.instructions = f1174_parent_instructions;
                     body.emit(f1174);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1178 = bit_and(r1166, body.constant(2147483648u));
                     ir_expression *const r1179 = equal(r1178, body.constant(0u));
                     ir_if *f1177 = new(mem_ctx) ir_if(operand(r1179).val);
                     exec_list *const f1177_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1177->then_instructions;

                        body.emit(assign(r1168, add(r1168, body.constant(int(1))), 0x01));


                     body.instructions = f1177_parent_instructions;
                     body.emit(f1177);

                     /* END IF */

                     body.emit(assign(r1167, r1168, 0x01));


                  body.instructions = f1169_parent_instructions;
                  body.emit(f1169);

                  /* END IF */

                  body.emit(assign(r1163, add(r1167, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r117B = less(r1163, body.constant(int(0)));
                  ir_if *f117A = new(mem_ctx) ir_if(operand(r117B).val);
                  exec_list *const f117A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f117A->then_instructions;

                     ir_expression *const r117C = neg(r1163);
                     body.emit(assign(r1161, rshift(swizzle_x(r10CC), r117C), 0x01));

                     ir_expression *const r117D = bit_and(r1163, body.constant(int(31)));
                     body.emit(assign(r1162, lshift(swizzle_x(r10CC), r117D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f117A->else_instructions;

                     body.emit(assign(r1161, lshift(swizzle_x(r10CC), r1163), 0x01));

                     body.emit(assign(r1162, body.constant(0u), 0x01));


                  body.instructions = f117A_parent_instructions;
                  body.emit(f117A);

                  /* END IF */

                  body.emit(assign(r1160, sub(body.constant(int(-31)), r1163), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1164->else_instructions;

                  ir_variable *const r117E = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r117E, r10E0, 0x01));

                  ir_variable *const r117F = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r1180 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1180);
                  /* IF CONDITION */
                  ir_expression *const r1182 = equal(r10E0, body.constant(0u));
                  ir_if *f1181 = new(mem_ctx) ir_if(operand(r1182).val);
                  exec_list *const f1181_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1181->then_instructions;

                     body.emit(assign(r117F, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1181->else_instructions;

                     body.emit(assign(r1180, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1184 = bit_and(r10E0, body.constant(4294901760u));
                     ir_expression *const r1185 = equal(r1184, body.constant(0u));
                     ir_if *f1183 = new(mem_ctx) ir_if(operand(r1185).val);
                     exec_list *const f1183_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1183->then_instructions;

                        body.emit(assign(r1180, body.constant(int(16)), 0x01));

                        body.emit(assign(r117E, lshift(r10E0, body.constant(int(16))), 0x01));


                     body.instructions = f1183_parent_instructions;
                     body.emit(f1183);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1187 = bit_and(r117E, body.constant(4278190080u));
                     ir_expression *const r1188 = equal(r1187, body.constant(0u));
                     ir_if *f1186 = new(mem_ctx) ir_if(operand(r1188).val);
                     exec_list *const f1186_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1186->then_instructions;

                        body.emit(assign(r1180, add(r1180, body.constant(int(8))), 0x01));

                        body.emit(assign(r117E, lshift(r117E, body.constant(int(8))), 0x01));


                     body.instructions = f1186_parent_instructions;
                     body.emit(f1186);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r118A = bit_and(r117E, body.constant(4026531840u));
                     ir_expression *const r118B = equal(r118A, body.constant(0u));
                     ir_if *f1189 = new(mem_ctx) ir_if(operand(r118B).val);
                     exec_list *const f1189_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1189->then_instructions;

                        body.emit(assign(r1180, add(r1180, body.constant(int(4))), 0x01));

                        body.emit(assign(r117E, lshift(r117E, body.constant(int(4))), 0x01));


                     body.instructions = f1189_parent_instructions;
                     body.emit(f1189);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r118D = bit_and(r117E, body.constant(3221225472u));
                     ir_expression *const r118E = equal(r118D, body.constant(0u));
                     ir_if *f118C = new(mem_ctx) ir_if(operand(r118E).val);
                     exec_list *const f118C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f118C->then_instructions;

                        body.emit(assign(r1180, add(r1180, body.constant(int(2))), 0x01));

                        body.emit(assign(r117E, lshift(r117E, body.constant(int(2))), 0x01));


                     body.instructions = f118C_parent_instructions;
                     body.emit(f118C);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1190 = bit_and(r117E, body.constant(2147483648u));
                     ir_expression *const r1191 = equal(r1190, body.constant(0u));
                     ir_if *f118F = new(mem_ctx) ir_if(operand(r1191).val);
                     exec_list *const f118F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f118F->then_instructions;

                        body.emit(assign(r1180, add(r1180, body.constant(int(1))), 0x01));


                     body.instructions = f118F_parent_instructions;
                     body.emit(f118F);

                     /* END IF */

                     body.emit(assign(r117F, r1180, 0x01));


                  body.instructions = f1181_parent_instructions;
                  body.emit(f1181);

                  /* END IF */

                  body.emit(assign(r1163, add(r117F, body.constant(int(-11))), 0x01));

                  ir_variable *const r1192 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1192, lshift(swizzle_x(r10CC), r1163), 0x01));

                  ir_variable *const r1193 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1195 = equal(r1163, body.constant(int(0)));
                  ir_if *f1194 = new(mem_ctx) ir_if(operand(r1195).val);
                  exec_list *const f1194_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1194->then_instructions;

                     body.emit(assign(r1193, r10E0, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1194->else_instructions;

                     ir_expression *const r1196 = lshift(r10E0, r1163);
                     ir_expression *const r1197 = neg(r1163);
                     ir_expression *const r1198 = bit_and(r1197, body.constant(int(31)));
                     ir_expression *const r1199 = rshift(swizzle_x(r10CC), r1198);
                     body.emit(assign(r1193, bit_or(r1196, r1199), 0x01));


                  body.instructions = f1194_parent_instructions;
                  body.emit(f1194);

                  /* END IF */

                  body.emit(assign(r1161, r1193, 0x01));

                  body.emit(assign(r1162, r1192, 0x01));

                  body.emit(assign(r1160, sub(body.constant(int(1)), r1163), 0x01));


               body.instructions = f1164_parent_instructions;
               body.emit(f1164);

               /* END IF */

               body.emit(assign(r10D0, r1160, 0x01));

               body.emit(assign(r10D2, r1161, 0x01));

               body.emit(assign(r10D3, r1162, 0x01));


            body.instructions = f1155_parent_instructions;
            body.emit(f1155);

            /* END IF */


         body.instructions = f1153_parent_instructions;
         body.emit(f1153);

         /* END IF */

         /* IF CONDITION */
         ir_if *f119A = new(mem_ctx) ir_if(operand(r10CD).val);
         exec_list *const f119A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f119A->then_instructions;

            /* IF CONDITION */
            ir_expression *const r119C = equal(r10E1, body.constant(int(0)));
            ir_if *f119B = new(mem_ctx) ir_if(operand(r119C).val);
            exec_list *const f119B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f119B->then_instructions;

               /* IF CONDITION */
               ir_expression *const r119E = bit_or(r10DE, swizzle_x(r10CB));
               ir_expression *const r119F = equal(r119E, body.constant(0u));
               ir_if *f119D = new(mem_ctx) ir_if(operand(r119F).val);
               exec_list *const f119D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f119D->then_instructions;

                  ir_variable *const r11A0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r11A0);
                  body.emit(assign(r11A0, lshift(r10CF, body.constant(int(31))), 0x02));

                  body.emit(assign(r11A0, body.constant(0u), 0x01));

                  body.emit(assign(r10CE, r11A0, 0x03));

                  body.emit(assign(r10CD, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f119D->else_instructions;

                  ir_variable *const r11A1 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r11A1, r10E1, 0x01));

                  ir_variable *const r11A2 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r11A2, r10DE, 0x01));

                  ir_variable *const r11A3 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r11A3, r10DD, 0x01));

                  ir_variable *const r11A4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r11A4);
                  /* IF CONDITION */
                  ir_expression *const r11A6 = equal(r10DE, body.constant(0u));
                  ir_if *f11A5 = new(mem_ctx) ir_if(operand(r11A6).val);
                  exec_list *const f11A5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f11A5->then_instructions;

                     ir_variable *const r11A7 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r11A7, r10DD, 0x01));

                     ir_variable *const r11A8 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r11A9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r11A9);
                     /* IF CONDITION */
                     ir_expression *const r11AB = equal(swizzle_x(r10CB), body.constant(0u));
                     ir_if *f11AA = new(mem_ctx) ir_if(operand(r11AB).val);
                     exec_list *const f11AA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f11AA->then_instructions;

                        body.emit(assign(r11A8, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f11AA->else_instructions;

                        body.emit(assign(r11A9, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r11AD = bit_and(swizzle_x(r10CB), body.constant(4294901760u));
                        ir_expression *const r11AE = equal(r11AD, body.constant(0u));
                        ir_if *f11AC = new(mem_ctx) ir_if(operand(r11AE).val);
                        exec_list *const f11AC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f11AC->then_instructions;

                           body.emit(assign(r11A9, body.constant(int(16)), 0x01));

                           body.emit(assign(r11A7, lshift(swizzle_x(r10CB), body.constant(int(16))), 0x01));


                        body.instructions = f11AC_parent_instructions;
                        body.emit(f11AC);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r11B0 = bit_and(r11A7, body.constant(4278190080u));
                        ir_expression *const r11B1 = equal(r11B0, body.constant(0u));
                        ir_if *f11AF = new(mem_ctx) ir_if(operand(r11B1).val);
                        exec_list *const f11AF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f11AF->then_instructions;

                           body.emit(assign(r11A9, add(r11A9, body.constant(int(8))), 0x01));

                           body.emit(assign(r11A7, lshift(r11A7, body.constant(int(8))), 0x01));


                        body.instructions = f11AF_parent_instructions;
                        body.emit(f11AF);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r11B3 = bit_and(r11A7, body.constant(4026531840u));
                        ir_expression *const r11B4 = equal(r11B3, body.constant(0u));
                        ir_if *f11B2 = new(mem_ctx) ir_if(operand(r11B4).val);
                        exec_list *const f11B2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f11B2->then_instructions;

                           body.emit(assign(r11A9, add(r11A9, body.constant(int(4))), 0x01));

                           body.emit(assign(r11A7, lshift(r11A7, body.constant(int(4))), 0x01));


                        body.instructions = f11B2_parent_instructions;
                        body.emit(f11B2);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r11B6 = bit_and(r11A7, body.constant(3221225472u));
                        ir_expression *const r11B7 = equal(r11B6, body.constant(0u));
                        ir_if *f11B5 = new(mem_ctx) ir_if(operand(r11B7).val);
                        exec_list *const f11B5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f11B5->then_instructions;

                           body.emit(assign(r11A9, add(r11A9, body.constant(int(2))), 0x01));

                           body.emit(assign(r11A7, lshift(r11A7, body.constant(int(2))), 0x01));


                        body.instructions = f11B5_parent_instructions;
                        body.emit(f11B5);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r11B9 = bit_and(r11A7, body.constant(2147483648u));
                        ir_expression *const r11BA = equal(r11B9, body.constant(0u));
                        ir_if *f11B8 = new(mem_ctx) ir_if(operand(r11BA).val);
                        exec_list *const f11B8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f11B8->then_instructions;

                           body.emit(assign(r11A9, add(r11A9, body.constant(int(1))), 0x01));


                        body.instructions = f11B8_parent_instructions;
                        body.emit(f11B8);

                        /* END IF */

                        body.emit(assign(r11A8, r11A9, 0x01));


                     body.instructions = f11AA_parent_instructions;
                     body.emit(f11AA);

                     /* END IF */

                     body.emit(assign(r11A4, add(r11A8, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r11BC = less(r11A4, body.constant(int(0)));
                     ir_if *f11BB = new(mem_ctx) ir_if(operand(r11BC).val);
                     exec_list *const f11BB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f11BB->then_instructions;

                        ir_expression *const r11BD = neg(r11A4);
                        body.emit(assign(r11A2, rshift(swizzle_x(r10CB), r11BD), 0x01));

                        ir_expression *const r11BE = bit_and(r11A4, body.constant(int(31)));
                        body.emit(assign(r11A3, lshift(swizzle_x(r10CB), r11BE), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f11BB->else_instructions;

                        body.emit(assign(r11A2, lshift(swizzle_x(r10CB), r11A4), 0x01));

                        body.emit(assign(r11A3, body.constant(0u), 0x01));


                     body.instructions = f11BB_parent_instructions;
                     body.emit(f11BB);

                     /* END IF */

                     body.emit(assign(r11A1, sub(body.constant(int(-31)), r11A4), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f11A5->else_instructions;

                     ir_variable *const r11BF = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r11BF, r10DE, 0x01));

                     ir_variable *const r11C0 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r11C1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r11C1);
                     /* IF CONDITION */
                     ir_expression *const r11C3 = equal(r10DE, body.constant(0u));
                     ir_if *f11C2 = new(mem_ctx) ir_if(operand(r11C3).val);
                     exec_list *const f11C2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f11C2->then_instructions;

                        body.emit(assign(r11C0, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f11C2->else_instructions;

                        body.emit(assign(r11C1, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r11C5 = bit_and(r10DE, body.constant(4294901760u));
                        ir_expression *const r11C6 = equal(r11C5, body.constant(0u));
                        ir_if *f11C4 = new(mem_ctx) ir_if(operand(r11C6).val);
                        exec_list *const f11C4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f11C4->then_instructions;

                           body.emit(assign(r11C1, body.constant(int(16)), 0x01));

                           body.emit(assign(r11BF, lshift(r10DE, body.constant(int(16))), 0x01));


                        body.instructions = f11C4_parent_instructions;
                        body.emit(f11C4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r11C8 = bit_and(r11BF, body.constant(4278190080u));
                        ir_expression *const r11C9 = equal(r11C8, body.constant(0u));
                        ir_if *f11C7 = new(mem_ctx) ir_if(operand(r11C9).val);
                        exec_list *const f11C7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f11C7->then_instructions;

                           body.emit(assign(r11C1, add(r11C1, body.constant(int(8))), 0x01));

                           body.emit(assign(r11BF, lshift(r11BF, body.constant(int(8))), 0x01));


                        body.instructions = f11C7_parent_instructions;
                        body.emit(f11C7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r11CB = bit_and(r11BF, body.constant(4026531840u));
                        ir_expression *const r11CC = equal(r11CB, body.constant(0u));
                        ir_if *f11CA = new(mem_ctx) ir_if(operand(r11CC).val);
                        exec_list *const f11CA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f11CA->then_instructions;

                           body.emit(assign(r11C1, add(r11C1, body.constant(int(4))), 0x01));

                           body.emit(assign(r11BF, lshift(r11BF, body.constant(int(4))), 0x01));


                        body.instructions = f11CA_parent_instructions;
                        body.emit(f11CA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r11CE = bit_and(r11BF, body.constant(3221225472u));
                        ir_expression *const r11CF = equal(r11CE, body.constant(0u));
                        ir_if *f11CD = new(mem_ctx) ir_if(operand(r11CF).val);
                        exec_list *const f11CD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f11CD->then_instructions;

                           body.emit(assign(r11C1, add(r11C1, body.constant(int(2))), 0x01));

                           body.emit(assign(r11BF, lshift(r11BF, body.constant(int(2))), 0x01));


                        body.instructions = f11CD_parent_instructions;
                        body.emit(f11CD);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r11D1 = bit_and(r11BF, body.constant(2147483648u));
                        ir_expression *const r11D2 = equal(r11D1, body.constant(0u));
                        ir_if *f11D0 = new(mem_ctx) ir_if(operand(r11D2).val);
                        exec_list *const f11D0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f11D0->then_instructions;

                           body.emit(assign(r11C1, add(r11C1, body.constant(int(1))), 0x01));


                        body.instructions = f11D0_parent_instructions;
                        body.emit(f11D0);

                        /* END IF */

                        body.emit(assign(r11C0, r11C1, 0x01));


                     body.instructions = f11C2_parent_instructions;
                     body.emit(f11C2);

                     /* END IF */

                     body.emit(assign(r11A4, add(r11C0, body.constant(int(-11))), 0x01));

                     ir_variable *const r11D3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r11D3, lshift(swizzle_x(r10CB), r11A4), 0x01));

                     ir_variable *const r11D4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r11D6 = equal(r11A4, body.constant(int(0)));
                     ir_if *f11D5 = new(mem_ctx) ir_if(operand(r11D6).val);
                     exec_list *const f11D5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f11D5->then_instructions;

                        body.emit(assign(r11D4, r10DE, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f11D5->else_instructions;

                        ir_expression *const r11D7 = lshift(r10DE, r11A4);
                        ir_expression *const r11D8 = neg(r11A4);
                        ir_expression *const r11D9 = bit_and(r11D8, body.constant(int(31)));
                        ir_expression *const r11DA = rshift(swizzle_x(r10CB), r11D9);
                        body.emit(assign(r11D4, bit_or(r11D7, r11DA), 0x01));


                     body.instructions = f11D5_parent_instructions;
                     body.emit(f11D5);

                     /* END IF */

                     body.emit(assign(r11A2, r11D4, 0x01));

                     body.emit(assign(r11A3, r11D3, 0x01));

                     body.emit(assign(r11A1, sub(body.constant(int(1)), r11A4), 0x01));


                  body.instructions = f11A5_parent_instructions;
                  body.emit(f11A5);

                  /* END IF */

                  body.emit(assign(r10D1, r11A1, 0x01));

                  body.emit(assign(r10D4, r11A2, 0x01));

                  body.emit(assign(r10D5, r11A3, 0x01));


               body.instructions = f119D_parent_instructions;
               body.emit(f119D);

               /* END IF */


            body.instructions = f119B_parent_instructions;
            body.emit(f119B);

            /* END IF */

            /* IF CONDITION */
            ir_if *f11DB = new(mem_ctx) ir_if(operand(r10CD).val);
            exec_list *const f11DB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f11DB->then_instructions;

               ir_expression *const r11DC = sub(r10D1, r10D0);
               body.emit(assign(r10DC, add(r11DC, body.constant(int(1021))), 0x01));

               ir_variable *const r11DD = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r11DD, lshift(r10D5, body.constant(int(11))), 0x01));

               ir_variable *const r11DE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r11DF = bit_or(r10D4, body.constant(1048576u));
               ir_expression *const r11E0 = lshift(r11DF, body.constant(int(11)));
               ir_expression *const r11E1 = rshift(r10D5, body.constant(int(21)));
               body.emit(assign(r11DE, bit_or(r11E0, r11E1), 0x01));

               body.emit(assign(r10D4, r11DE, 0x01));

               body.emit(assign(r10D5, r11DD, 0x01));

               ir_variable *const r11E2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r11E2, lshift(r10D3, body.constant(int(11))), 0x01));

               ir_variable *const r11E3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r11E4 = bit_or(r10D2, body.constant(1048576u));
               ir_expression *const r11E5 = lshift(r11E4, body.constant(int(11)));
               ir_expression *const r11E6 = rshift(r10D3, body.constant(int(21)));
               body.emit(assign(r11E3, bit_or(r11E5, r11E6), 0x01));

               body.emit(assign(r10D2, r11E3, 0x01));

               body.emit(assign(r10D3, r11E2, 0x01));

               /* IF CONDITION */
               ir_expression *const r11E8 = less(r11E3, r11DE);
               ir_expression *const r11E9 = equal(r11E3, r11DE);
               ir_expression *const r11EA = lequal(r11E2, r11DD);
               ir_expression *const r11EB = logic_and(r11E9, r11EA);
               ir_expression *const r11EC = logic_or(r11E8, r11EB);
               ir_if *f11E7 = new(mem_ctx) ir_if(operand(r11EC).val);
               exec_list *const f11E7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f11E7->then_instructions;

                  body.emit(assign(r10D4, rshift(r11DE, body.constant(int(1))), 0x01));

                  ir_expression *const r11ED = lshift(r11DE, body.constant(int(31)));
                  ir_expression *const r11EE = rshift(r11DD, body.constant(int(1)));
                  body.emit(assign(r10D5, bit_or(r11ED, r11EE), 0x01));

                  body.emit(assign(r10DC, add(r10DC, body.constant(int(1))), 0x01));


               body.instructions = f11E7_parent_instructions;
               body.emit(f11E7);

               /* END IF */

               ir_variable *const r11EF = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r11F0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r11F0);
               ir_variable *const r11F1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r11F1);
               ir_variable *const r11F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r11F2);
               ir_variable *const r11F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r11F3);
               body.emit(assign(r11F2, body.constant(0u), 0x01));

               body.emit(assign(r11F1, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r11F5 = lequal(r11E3, r10D4);
               ir_if *f11F4 = new(mem_ctx) ir_if(operand(r11F5).val);
               exec_list *const f11F4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f11F4->then_instructions;

                  body.emit(assign(r11EF, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f11F4->else_instructions;

                  body.emit(assign(r11F3, rshift(r11E3, body.constant(int(16))), 0x01));

                  ir_variable *const r11F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r11F8 = lshift(r11F3, body.constant(int(16)));
                  ir_expression *const r11F9 = lequal(r11F8, r10D4);
                  ir_if *f11F7 = new(mem_ctx) ir_if(operand(r11F9).val);
                  exec_list *const f11F7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f11F7->then_instructions;

                     body.emit(assign(r11F6, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f11F7->else_instructions;

                     ir_expression *const r11FA = expr(ir_binop_div, r10D4, r11F3);
                     body.emit(assign(r11F6, lshift(r11FA, body.constant(int(16))), 0x01));


                  body.instructions = f11F7_parent_instructions;
                  body.emit(f11F7);

                  /* END IF */

                  body.emit(assign(r11F0, r11F6, 0x01));

                  ir_variable *const r11FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r11FB);
                  ir_variable *const r11FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r11FC);
                  ir_variable *const r11FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r11FD);
                  ir_variable *const r11FE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r11FE, bit_and(r11E3, body.constant(65535u)), 0x01));

                  ir_variable *const r11FF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r11FF, rshift(r11E3, body.constant(int(16))), 0x01));

                  ir_variable *const r1200 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1200, bit_and(r11F6, body.constant(65535u)), 0x01));

                  ir_variable *const r1201 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1201, rshift(r11F6, body.constant(int(16))), 0x01));

                  ir_variable *const r1202 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1202, mul(r11FF, r1200), 0x01));

                  ir_expression *const r1203 = mul(r11FE, r1201);
                  body.emit(assign(r11FC, add(r1203, r1202), 0x01));

                  ir_expression *const r1204 = mul(r11FF, r1201);
                  ir_expression *const r1205 = less(r11FC, r1202);
                  ir_expression *const r1206 = expr(ir_unop_b2i, r1205);
                  ir_expression *const r1207 = expr(ir_unop_i2u, r1206);
                  ir_expression *const r1208 = lshift(r1207, body.constant(int(16)));
                  ir_expression *const r1209 = rshift(r11FC, body.constant(int(16)));
                  ir_expression *const r120A = add(r1208, r1209);
                  body.emit(assign(r11FB, add(r1204, r120A), 0x01));

                  body.emit(assign(r11FC, lshift(r11FC, body.constant(int(16))), 0x01));

                  ir_expression *const r120B = mul(r11FE, r1200);
                  body.emit(assign(r11FD, add(r120B, r11FC), 0x01));

                  ir_expression *const r120C = less(r11FD, r11FC);
                  ir_expression *const r120D = expr(ir_unop_b2i, r120C);
                  ir_expression *const r120E = expr(ir_unop_i2u, r120D);
                  body.emit(assign(r11FB, add(r11FB, r120E), 0x01));

                  ir_expression *const r120F = sub(r10D4, r11FB);
                  ir_expression *const r1210 = less(r10D5, r11FD);
                  ir_expression *const r1211 = expr(ir_unop_b2i, r1210);
                  ir_expression *const r1212 = expr(ir_unop_i2u, r1211);
                  body.emit(assign(r11F2, sub(r120F, r1212), 0x01));

                  body.emit(assign(r11F1, sub(r10D5, r11FD), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f1213 = new(mem_ctx) ir_loop();
                  exec_list *const f1213_parent_instructions = body.instructions;

                     body.instructions = &f1213->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1215 = expr(ir_unop_u2i, r11F2);
                     ir_expression *const r1216 = gequal(r1215, body.constant(int(0)));
                     ir_if *f1214 = new(mem_ctx) ir_if(operand(r1216).val);
                     exec_list *const f1214_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1214->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f1214_parent_instructions;
                     body.emit(f1214);

                     /* END IF */

                     body.emit(assign(r11F0, add(r11F0, body.constant(4294901760u)), 0x01));

                     ir_variable *const r1217 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r1218 = lshift(r11E3, body.constant(int(16)));
                     body.emit(assign(r1217, add(r11F1, r1218), 0x01));

                     ir_expression *const r1219 = add(r11F2, r11F3);
                     ir_expression *const r121A = less(r1217, r11F1);
                     ir_expression *const r121B = expr(ir_unop_b2i, r121A);
                     ir_expression *const r121C = expr(ir_unop_i2u, r121B);
                     body.emit(assign(r11F2, add(r1219, r121C), 0x01));

                     body.emit(assign(r11F1, r1217, 0x01));

                  /* LOOP END */

                  body.instructions = f1213_parent_instructions;
                  body.emit(f1213);

                  ir_expression *const r121D = lshift(r11F2, body.constant(int(16)));
                  ir_expression *const r121E = rshift(r11F1, body.constant(int(16)));
                  body.emit(assign(r11F2, bit_or(r121D, r121E), 0x01));

                  ir_variable *const r121F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1221 = lshift(r11F3, body.constant(int(16)));
                  ir_expression *const r1222 = lequal(r1221, r11F2);
                  ir_if *f1220 = new(mem_ctx) ir_if(operand(r1222).val);
                  exec_list *const f1220_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1220->then_instructions;

                     body.emit(assign(r121F, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1220->else_instructions;

                     body.emit(assign(r121F, expr(ir_binop_div, r11F2, r11F3), 0x01));


                  body.instructions = f1220_parent_instructions;
                  body.emit(f1220);

                  /* END IF */

                  body.emit(assign(r11F0, bit_or(r11F0, r121F), 0x01));

                  body.emit(assign(r11EF, r11F0, 0x01));


               body.instructions = f11F4_parent_instructions;
               body.emit(f11F4);

               /* END IF */

               body.emit(assign(r10DB, r11EF, 0x01));

               ir_variable *const r1223 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1223);
               ir_variable *const r1224 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1224);
               ir_variable *const r1225 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1225);
               ir_variable *const r1226 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1226, bit_and(r11E2, body.constant(65535u)), 0x01));

               ir_variable *const r1227 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1227, rshift(r11E2, body.constant(int(16))), 0x01));

               ir_variable *const r1228 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1228, bit_and(r11EF, body.constant(65535u)), 0x01));

               ir_variable *const r1229 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1229, rshift(r11EF, body.constant(int(16))), 0x01));

               ir_variable *const r122A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r122A, mul(r1227, r1228), 0x01));

               ir_expression *const r122B = mul(r1226, r1229);
               body.emit(assign(r1224, add(r122B, r122A), 0x01));

               ir_expression *const r122C = mul(r1227, r1229);
               ir_expression *const r122D = less(r1224, r122A);
               ir_expression *const r122E = expr(ir_unop_b2i, r122D);
               ir_expression *const r122F = expr(ir_unop_i2u, r122E);
               ir_expression *const r1230 = lshift(r122F, body.constant(int(16)));
               ir_expression *const r1231 = rshift(r1224, body.constant(int(16)));
               ir_expression *const r1232 = add(r1230, r1231);
               body.emit(assign(r1223, add(r122C, r1232), 0x01));

               body.emit(assign(r1224, lshift(r1224, body.constant(int(16))), 0x01));

               ir_expression *const r1233 = mul(r1226, r1228);
               body.emit(assign(r1225, add(r1233, r1224), 0x01));

               ir_expression *const r1234 = less(r1225, r1224);
               ir_expression *const r1235 = expr(ir_unop_b2i, r1234);
               ir_expression *const r1236 = expr(ir_unop_i2u, r1235);
               body.emit(assign(r1223, add(r1223, r1236), 0x01));

               ir_variable *const r1237 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1237);
               ir_variable *const r1238 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1238);
               ir_variable *const r1239 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1239);
               ir_variable *const r123A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r123A, bit_and(r11E3, body.constant(65535u)), 0x01));

               ir_variable *const r123B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r123B, rshift(r11E3, body.constant(int(16))), 0x01));

               ir_variable *const r123C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r123C, bit_and(r11EF, body.constant(65535u)), 0x01));

               ir_variable *const r123D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r123D, rshift(r11EF, body.constant(int(16))), 0x01));

               ir_variable *const r123E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r123E, mul(r123B, r123C), 0x01));

               ir_expression *const r123F = mul(r123A, r123D);
               body.emit(assign(r1238, add(r123F, r123E), 0x01));

               ir_expression *const r1240 = mul(r123B, r123D);
               ir_expression *const r1241 = less(r1238, r123E);
               ir_expression *const r1242 = expr(ir_unop_b2i, r1241);
               ir_expression *const r1243 = expr(ir_unop_i2u, r1242);
               ir_expression *const r1244 = lshift(r1243, body.constant(int(16)));
               ir_expression *const r1245 = rshift(r1238, body.constant(int(16)));
               ir_expression *const r1246 = add(r1244, r1245);
               body.emit(assign(r1237, add(r1240, r1246), 0x01));

               body.emit(assign(r1238, lshift(r1238, body.constant(int(16))), 0x01));

               ir_expression *const r1247 = mul(r123A, r123C);
               body.emit(assign(r1239, add(r1247, r1238), 0x01));

               ir_expression *const r1248 = less(r1239, r1238);
               ir_expression *const r1249 = expr(ir_unop_b2i, r1248);
               ir_expression *const r124A = expr(ir_unop_i2u, r1249);
               body.emit(assign(r1237, add(r1237, r124A), 0x01));

               ir_variable *const r124B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r124B, add(r1239, r1223), 0x01));

               ir_variable *const r124C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r124C);
               ir_variable *const r124D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r124E = less(body.constant(0u), r1225);
               ir_expression *const r124F = expr(ir_unop_b2i, r124E);
               body.emit(assign(r124D, expr(ir_unop_i2u, r124F), 0x01));

               ir_variable *const r1250 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1250, sub(r10D5, r124B), 0x01));

               ir_expression *const r1251 = less(r124B, r1239);
               ir_expression *const r1252 = expr(ir_unop_b2i, r1251);
               ir_expression *const r1253 = expr(ir_unop_i2u, r1252);
               ir_expression *const r1254 = add(r1237, r1253);
               ir_expression *const r1255 = sub(r10D4, r1254);
               ir_expression *const r1256 = less(r1250, r124D);
               ir_expression *const r1257 = expr(ir_unop_b2i, r1256);
               ir_expression *const r1258 = expr(ir_unop_i2u, r1257);
               body.emit(assign(r124C, sub(r1255, r1258), 0x01));

               ir_expression *const r1259 = less(r10D5, r124B);
               ir_expression *const r125A = expr(ir_unop_b2i, r1259);
               ir_expression *const r125B = expr(ir_unop_i2u, r125A);
               body.emit(assign(r124C, sub(r124C, r125B), 0x01));

               body.emit(assign(r10D9, r124C, 0x01));

               body.emit(assign(r10D8, sub(r1250, r124D), 0x01));

               body.emit(assign(r10D7, neg(r1225), 0x01));

               /* LOOP BEGIN */
               ir_loop *f125C = new(mem_ctx) ir_loop();
               exec_list *const f125C_parent_instructions = body.instructions;

                  body.instructions = &f125C->body_instructions;

                  /* IF CONDITION */
                  ir_expression *const r125E = expr(ir_unop_u2i, r10D9);
                  ir_expression *const r125F = gequal(r125E, body.constant(int(0)));
                  ir_if *f125D = new(mem_ctx) ir_if(operand(r125F).val);
                  exec_list *const f125D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f125D->then_instructions;

                     body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                  body.instructions = f125D_parent_instructions;
                  body.emit(f125D);

                  /* END IF */

                  body.emit(assign(r10DB, add(r10DB, body.constant(4294967295u)), 0x01));

                  ir_variable *const r1260 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1260);
                  ir_variable *const r1261 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1261);
                  ir_variable *const r1262 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1262, add(r10D7, r11E2), 0x01));

                  ir_variable *const r1263 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r1264 = less(r1262, r10D7);
                  ir_expression *const r1265 = expr(ir_unop_b2i, r1264);
                  body.emit(assign(r1263, expr(ir_unop_i2u, r1265), 0x01));

                  ir_variable *const r1266 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1266, add(r10D8, r11E3), 0x01));

                  body.emit(assign(r1261, add(r1266, r1263), 0x01));

                  ir_expression *const r1267 = less(r1261, r1263);
                  ir_expression *const r1268 = expr(ir_unop_b2i, r1267);
                  ir_expression *const r1269 = expr(ir_unop_i2u, r1268);
                  body.emit(assign(r1260, add(r10D9, r1269), 0x01));

                  ir_expression *const r126A = less(r1266, r10D8);
                  ir_expression *const r126B = expr(ir_unop_b2i, r126A);
                  ir_expression *const r126C = expr(ir_unop_i2u, r126B);
                  body.emit(assign(r1260, add(r1260, r126C), 0x01));

                  body.emit(assign(r10D9, r1260, 0x01));

                  body.emit(assign(r10D8, r1261, 0x01));

                  body.emit(assign(r10D7, r1262, 0x01));

               /* LOOP END */

               body.instructions = f125C_parent_instructions;
               body.emit(f125C);

               ir_variable *const r126D = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r126E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r126E);
               ir_variable *const r126F = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r126F);
               ir_variable *const r1270 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r1270);
               ir_variable *const r1271 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r1271);
               body.emit(assign(r1270, body.constant(0u), 0x01));

               body.emit(assign(r126F, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r1273 = lequal(r11E3, r10D8);
               ir_if *f1272 = new(mem_ctx) ir_if(operand(r1273).val);
               exec_list *const f1272_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1272->then_instructions;

                  body.emit(assign(r126D, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1272->else_instructions;

                  body.emit(assign(r1271, rshift(r11E3, body.constant(int(16))), 0x01));

                  ir_variable *const r1274 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1276 = lshift(r1271, body.constant(int(16)));
                  ir_expression *const r1277 = lequal(r1276, r10D8);
                  ir_if *f1275 = new(mem_ctx) ir_if(operand(r1277).val);
                  exec_list *const f1275_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1275->then_instructions;

                     body.emit(assign(r1274, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1275->else_instructions;

                     ir_expression *const r1278 = expr(ir_binop_div, r10D8, r1271);
                     body.emit(assign(r1274, lshift(r1278, body.constant(int(16))), 0x01));


                  body.instructions = f1275_parent_instructions;
                  body.emit(f1275);

                  /* END IF */

                  body.emit(assign(r126E, r1274, 0x01));

                  ir_variable *const r1279 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1279);
                  ir_variable *const r127A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r127A);
                  ir_variable *const r127B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r127B);
                  ir_variable *const r127C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r127C, bit_and(r11E3, body.constant(65535u)), 0x01));

                  ir_variable *const r127D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r127D, rshift(r11E3, body.constant(int(16))), 0x01));

                  ir_variable *const r127E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r127E, bit_and(r1274, body.constant(65535u)), 0x01));

                  ir_variable *const r127F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r127F, rshift(r1274, body.constant(int(16))), 0x01));

                  ir_variable *const r1280 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1280, mul(r127D, r127E), 0x01));

                  ir_expression *const r1281 = mul(r127C, r127F);
                  body.emit(assign(r127A, add(r1281, r1280), 0x01));

                  ir_expression *const r1282 = mul(r127D, r127F);
                  ir_expression *const r1283 = less(r127A, r1280);
                  ir_expression *const r1284 = expr(ir_unop_b2i, r1283);
                  ir_expression *const r1285 = expr(ir_unop_i2u, r1284);
                  ir_expression *const r1286 = lshift(r1285, body.constant(int(16)));
                  ir_expression *const r1287 = rshift(r127A, body.constant(int(16)));
                  ir_expression *const r1288 = add(r1286, r1287);
                  body.emit(assign(r1279, add(r1282, r1288), 0x01));

                  body.emit(assign(r127A, lshift(r127A, body.constant(int(16))), 0x01));

                  ir_expression *const r1289 = mul(r127C, r127E);
                  body.emit(assign(r127B, add(r1289, r127A), 0x01));

                  ir_expression *const r128A = less(r127B, r127A);
                  ir_expression *const r128B = expr(ir_unop_b2i, r128A);
                  ir_expression *const r128C = expr(ir_unop_i2u, r128B);
                  body.emit(assign(r1279, add(r1279, r128C), 0x01));

                  ir_expression *const r128D = sub(r10D8, r1279);
                  ir_expression *const r128E = less(r10D7, r127B);
                  ir_expression *const r128F = expr(ir_unop_b2i, r128E);
                  ir_expression *const r1290 = expr(ir_unop_i2u, r128F);
                  body.emit(assign(r1270, sub(r128D, r1290), 0x01));

                  body.emit(assign(r126F, sub(r10D7, r127B), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f1291 = new(mem_ctx) ir_loop();
                  exec_list *const f1291_parent_instructions = body.instructions;

                     body.instructions = &f1291->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1293 = expr(ir_unop_u2i, r1270);
                     ir_expression *const r1294 = gequal(r1293, body.constant(int(0)));
                     ir_if *f1292 = new(mem_ctx) ir_if(operand(r1294).val);
                     exec_list *const f1292_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1292->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f1292_parent_instructions;
                     body.emit(f1292);

                     /* END IF */

                     body.emit(assign(r126E, add(r126E, body.constant(4294901760u)), 0x01));

                     ir_variable *const r1295 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r1296 = lshift(r11E3, body.constant(int(16)));
                     body.emit(assign(r1295, add(r126F, r1296), 0x01));

                     ir_expression *const r1297 = add(r1270, r1271);
                     ir_expression *const r1298 = less(r1295, r126F);
                     ir_expression *const r1299 = expr(ir_unop_b2i, r1298);
                     ir_expression *const r129A = expr(ir_unop_i2u, r1299);
                     body.emit(assign(r1270, add(r1297, r129A), 0x01));

                     body.emit(assign(r126F, r1295, 0x01));

                  /* LOOP END */

                  body.instructions = f1291_parent_instructions;
                  body.emit(f1291);

                  ir_expression *const r129B = lshift(r1270, body.constant(int(16)));
                  ir_expression *const r129C = rshift(r126F, body.constant(int(16)));
                  body.emit(assign(r1270, bit_or(r129B, r129C), 0x01));

                  ir_variable *const r129D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r129F = lshift(r1271, body.constant(int(16)));
                  ir_expression *const r12A0 = lequal(r129F, r1270);
                  ir_if *f129E = new(mem_ctx) ir_if(operand(r12A0).val);
                  exec_list *const f129E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f129E->then_instructions;

                     body.emit(assign(r129D, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f129E->else_instructions;

                     body.emit(assign(r129D, expr(ir_binop_div, r1270, r1271), 0x01));


                  body.instructions = f129E_parent_instructions;
                  body.emit(f129E);

                  /* END IF */

                  body.emit(assign(r126E, bit_or(r126E, r129D), 0x01));

                  body.emit(assign(r126D, r126E, 0x01));


               body.instructions = f1272_parent_instructions;
               body.emit(f1272);

               /* END IF */

               body.emit(assign(r10DA, r126D, 0x01));

               /* IF CONDITION */
               ir_expression *const r12A2 = bit_and(r126D, body.constant(1023u));
               ir_expression *const r12A3 = lequal(r12A2, body.constant(4u));
               ir_if *f12A1 = new(mem_ctx) ir_if(operand(r12A3).val);
               exec_list *const f12A1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f12A1->then_instructions;

                  ir_variable *const r12A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r12A4);
                  ir_variable *const r12A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r12A5);
                  ir_variable *const r12A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r12A6);
                  ir_variable *const r12A7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r12A7, bit_and(r11E2, body.constant(65535u)), 0x01));

                  ir_variable *const r12A8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r12A8, rshift(r11E2, body.constant(int(16))), 0x01));

                  ir_variable *const r12A9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r12A9, bit_and(r126D, body.constant(65535u)), 0x01));

                  ir_variable *const r12AA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r12AA, rshift(r126D, body.constant(int(16))), 0x01));

                  ir_variable *const r12AB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r12AB, mul(r12A8, r12A9), 0x01));

                  ir_expression *const r12AC = mul(r12A7, r12AA);
                  body.emit(assign(r12A5, add(r12AC, r12AB), 0x01));

                  ir_expression *const r12AD = mul(r12A8, r12AA);
                  ir_expression *const r12AE = less(r12A5, r12AB);
                  ir_expression *const r12AF = expr(ir_unop_b2i, r12AE);
                  ir_expression *const r12B0 = expr(ir_unop_i2u, r12AF);
                  ir_expression *const r12B1 = lshift(r12B0, body.constant(int(16)));
                  ir_expression *const r12B2 = rshift(r12A5, body.constant(int(16)));
                  ir_expression *const r12B3 = add(r12B1, r12B2);
                  body.emit(assign(r12A4, add(r12AD, r12B3), 0x01));

                  body.emit(assign(r12A5, lshift(r12A5, body.constant(int(16))), 0x01));

                  ir_expression *const r12B4 = mul(r12A7, r12A9);
                  body.emit(assign(r12A6, add(r12B4, r12A5), 0x01));

                  ir_expression *const r12B5 = less(r12A6, r12A5);
                  ir_expression *const r12B6 = expr(ir_unop_b2i, r12B5);
                  ir_expression *const r12B7 = expr(ir_unop_i2u, r12B6);
                  body.emit(assign(r12A4, add(r12A4, r12B7), 0x01));

                  ir_variable *const r12B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r12B8);
                  ir_variable *const r12B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r12B9);
                  ir_variable *const r12BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r12BA);
                  ir_variable *const r12BB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r12BB, bit_and(r11E3, body.constant(65535u)), 0x01));

                  ir_variable *const r12BC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r12BC, rshift(r11E3, body.constant(int(16))), 0x01));

                  ir_variable *const r12BD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r12BD, bit_and(r126D, body.constant(65535u)), 0x01));

                  ir_variable *const r12BE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r12BE, rshift(r126D, body.constant(int(16))), 0x01));

                  ir_variable *const r12BF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r12BF, mul(r12BC, r12BD), 0x01));

                  ir_expression *const r12C0 = mul(r12BB, r12BE);
                  body.emit(assign(r12B9, add(r12C0, r12BF), 0x01));

                  ir_expression *const r12C1 = mul(r12BC, r12BE);
                  ir_expression *const r12C2 = less(r12B9, r12BF);
                  ir_expression *const r12C3 = expr(ir_unop_b2i, r12C2);
                  ir_expression *const r12C4 = expr(ir_unop_i2u, r12C3);
                  ir_expression *const r12C5 = lshift(r12C4, body.constant(int(16)));
                  ir_expression *const r12C6 = rshift(r12B9, body.constant(int(16)));
                  ir_expression *const r12C7 = add(r12C5, r12C6);
                  body.emit(assign(r12B8, add(r12C1, r12C7), 0x01));

                  body.emit(assign(r12B9, lshift(r12B9, body.constant(int(16))), 0x01));

                  ir_expression *const r12C8 = mul(r12BB, r12BD);
                  body.emit(assign(r12BA, add(r12C8, r12B9), 0x01));

                  ir_expression *const r12C9 = less(r12BA, r12B9);
                  ir_expression *const r12CA = expr(ir_unop_b2i, r12C9);
                  ir_expression *const r12CB = expr(ir_unop_i2u, r12CA);
                  body.emit(assign(r12B8, add(r12B8, r12CB), 0x01));

                  ir_variable *const r12CC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r12CC, add(r12BA, r12A4), 0x01));

                  ir_variable *const r12CD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r12CD);
                  ir_variable *const r12CE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r12CF = less(body.constant(0u), r12A6);
                  ir_expression *const r12D0 = expr(ir_unop_b2i, r12CF);
                  body.emit(assign(r12CE, expr(ir_unop_i2u, r12D0), 0x01));

                  ir_variable *const r12D1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r12D1, sub(r10D7, r12CC), 0x01));

                  ir_expression *const r12D2 = less(r12CC, r12BA);
                  ir_expression *const r12D3 = expr(ir_unop_b2i, r12D2);
                  ir_expression *const r12D4 = expr(ir_unop_i2u, r12D3);
                  ir_expression *const r12D5 = add(r12B8, r12D4);
                  ir_expression *const r12D6 = sub(r10D8, r12D5);
                  ir_expression *const r12D7 = less(r12D1, r12CE);
                  ir_expression *const r12D8 = expr(ir_unop_b2i, r12D7);
                  ir_expression *const r12D9 = expr(ir_unop_i2u, r12D8);
                  body.emit(assign(r12CD, sub(r12D6, r12D9), 0x01));

                  ir_expression *const r12DA = less(r10D7, r12CC);
                  ir_expression *const r12DB = expr(ir_unop_b2i, r12DA);
                  ir_expression *const r12DC = expr(ir_unop_i2u, r12DB);
                  body.emit(assign(r12CD, sub(r12CD, r12DC), 0x01));

                  body.emit(assign(r10D8, r12CD, 0x01));

                  body.emit(assign(r10D7, sub(r12D1, r12CE), 0x01));

                  body.emit(assign(r10D6, neg(r12A6), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f12DD = new(mem_ctx) ir_loop();
                  exec_list *const f12DD_parent_instructions = body.instructions;

                     body.instructions = &f12DD->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r12DF = expr(ir_unop_u2i, r10D8);
                     ir_expression *const r12E0 = gequal(r12DF, body.constant(int(0)));
                     ir_if *f12DE = new(mem_ctx) ir_if(operand(r12E0).val);
                     exec_list *const f12DE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12DE->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f12DE_parent_instructions;
                     body.emit(f12DE);

                     /* END IF */

                     body.emit(assign(r10DA, add(r10DA, body.constant(4294967295u)), 0x01));

                     ir_variable *const r12E1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r12E1);
                     ir_variable *const r12E2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r12E2);
                     ir_variable *const r12E3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r12E3, add(r10D6, r11E2), 0x01));

                     ir_variable *const r12E4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r12E5 = less(r12E3, r10D6);
                     ir_expression *const r12E6 = expr(ir_unop_b2i, r12E5);
                     body.emit(assign(r12E4, expr(ir_unop_i2u, r12E6), 0x01));

                     ir_variable *const r12E7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r12E7, add(r10D7, r11E3), 0x01));

                     body.emit(assign(r12E2, add(r12E7, r12E4), 0x01));

                     ir_expression *const r12E8 = less(r12E2, r12E4);
                     ir_expression *const r12E9 = expr(ir_unop_b2i, r12E8);
                     ir_expression *const r12EA = expr(ir_unop_i2u, r12E9);
                     body.emit(assign(r12E1, add(r10D8, r12EA), 0x01));

                     ir_expression *const r12EB = less(r12E7, r10D7);
                     ir_expression *const r12EC = expr(ir_unop_b2i, r12EB);
                     ir_expression *const r12ED = expr(ir_unop_i2u, r12EC);
                     body.emit(assign(r12E1, add(r12E1, r12ED), 0x01));

                     body.emit(assign(r10D8, r12E1, 0x01));

                     body.emit(assign(r10D7, r12E2, 0x01));

                     body.emit(assign(r10D6, r12E3, 0x01));

                  /* LOOP END */

                  body.instructions = f12DD_parent_instructions;
                  body.emit(f12DD);

                  ir_expression *const r12EE = bit_or(r10D8, r10D7);
                  ir_expression *const r12EF = bit_or(r12EE, r10D6);
                  ir_expression *const r12F0 = nequal(r12EF, body.constant(0u));
                  ir_expression *const r12F1 = expr(ir_unop_b2i, r12F0);
                  ir_expression *const r12F2 = expr(ir_unop_i2u, r12F1);
                  body.emit(assign(r10DA, bit_or(r10DA, r12F2), 0x01));


               body.instructions = f12A1_parent_instructions;
               body.emit(f12A1);

               /* END IF */

               ir_variable *const r12F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r12F3);
               ir_variable *const r12F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r12F4);
               ir_variable *const r12F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r12F5);
               body.emit(assign(r12F3, lshift(r10DA, body.constant(int(21))), 0x01));

               ir_expression *const r12F6 = lshift(r10DB, body.constant(int(21)));
               ir_expression *const r12F7 = rshift(r10DA, body.constant(int(11)));
               body.emit(assign(r12F4, bit_or(r12F6, r12F7), 0x01));

               body.emit(assign(r12F5, rshift(r10DB, body.constant(int(11))), 0x01));

               body.emit(assign(r12F3, bit_or(r12F3, body.constant(0u)), 0x01));

               body.emit(assign(r10DB, r12F5, 0x01));

               body.emit(assign(r10DA, r12F4, 0x01));

               ir_variable *const r12F8 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r12F8, r10DC, 0x01));

               ir_variable *const r12F9 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r12F9, r12F5, 0x01));

               ir_variable *const r12FA = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r12FA, r12F4, 0x01));

               ir_variable *const r12FB = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r12FB, r12F3, 0x01));

               ir_variable *const r12FC = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r12FC, body.constant(true), 0x01));

               ir_variable *const r12FD = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r12FE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r12FE);
               ir_expression *const r12FF = expr(ir_unop_u2i, r12F3);
               body.emit(assign(r12FE, less(r12FF, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1301 = lequal(body.constant(int(2045)), r10DC);
               ir_if *f1300 = new(mem_ctx) ir_if(operand(r1301).val);
               exec_list *const f1300_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1300->then_instructions;

                  ir_variable *const r1302 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1304 = less(body.constant(int(2045)), r10DC);
                  ir_if *f1303 = new(mem_ctx) ir_if(operand(r1304).val);
                  exec_list *const f1303_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1303->then_instructions;

                     body.emit(assign(r1302, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1303->else_instructions;

                     ir_variable *const r1305 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1307 = equal(r10DC, body.constant(int(2045)));
                     ir_if *f1306 = new(mem_ctx) ir_if(operand(r1307).val);
                     exec_list *const f1306_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1306->then_instructions;

                        ir_expression *const r1308 = equal(body.constant(2097151u), r12F5);
                        ir_expression *const r1309 = equal(body.constant(4294967295u), r12F4);
                        body.emit(assign(r1305, logic_and(r1308, r1309), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1306->else_instructions;

                        body.emit(assign(r1305, body.constant(false), 0x01));


                     body.instructions = f1306_parent_instructions;
                     body.emit(f1306);

                     /* END IF */

                     body.emit(assign(r1302, logic_and(r1305, r12FE), 0x01));


                  body.instructions = f1303_parent_instructions;
                  body.emit(f1303);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f130A = new(mem_ctx) ir_if(operand(r1302).val);
                  exec_list *const f130A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f130A->then_instructions;

                     ir_variable *const r130B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r130B);
                     ir_expression *const r130C = lshift(r10CF, body.constant(int(31)));
                     body.emit(assign(r130B, add(r130C, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r130B, body.constant(0u), 0x01));

                     body.emit(assign(r12FD, r130B, 0x03));

                     body.emit(assign(r12FC, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f130A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r130E = less(r10DC, body.constant(int(0)));
                     ir_if *f130D = new(mem_ctx) ir_if(operand(r130E).val);
                     exec_list *const f130D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f130D->then_instructions;

                        ir_variable *const r130F = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r130F, r12F3, 0x01));

                        ir_variable *const r1310 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1310, neg(r10DC), 0x01));

                        ir_variable *const r1311 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1311);
                        ir_variable *const r1312 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1312);
                        ir_variable *const r1313 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1313);
                        ir_variable *const r1314 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1315 = neg(r1310);
                        body.emit(assign(r1314, bit_and(r1315, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1317 = equal(r1310, body.constant(int(0)));
                        ir_if *f1316 = new(mem_ctx) ir_if(operand(r1317).val);
                        exec_list *const f1316_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1316->then_instructions;

                           body.emit(assign(r1311, r12F3, 0x01));

                           body.emit(assign(r1312, r12F4, 0x01));

                           body.emit(assign(r1313, r12F5, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1316->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1319 = less(r1310, body.constant(int(32)));
                           ir_if *f1318 = new(mem_ctx) ir_if(operand(r1319).val);
                           exec_list *const f1318_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1318->then_instructions;

                              body.emit(assign(r1311, lshift(r12F4, r1314), 0x01));

                              ir_expression *const r131A = lshift(r12F5, r1314);
                              ir_expression *const r131B = rshift(r12F4, r1310);
                              body.emit(assign(r1312, bit_or(r131A, r131B), 0x01));

                              body.emit(assign(r1313, rshift(r12F5, r1310), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1318->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r131D = equal(r1310, body.constant(int(32)));
                              ir_if *f131C = new(mem_ctx) ir_if(operand(r131D).val);
                              exec_list *const f131C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f131C->then_instructions;

                                 body.emit(assign(r1311, r12F4, 0x01));

                                 body.emit(assign(r1312, r12F5, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f131C->else_instructions;

                                 body.emit(assign(r130F, bit_or(r12F3, r12F4), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r131F = less(r1310, body.constant(int(64)));
                                 ir_if *f131E = new(mem_ctx) ir_if(operand(r131F).val);
                                 exec_list *const f131E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f131E->then_instructions;

                                    body.emit(assign(r1311, lshift(r12F5, r1314), 0x01));

                                    ir_expression *const r1320 = bit_and(r1310, body.constant(int(31)));
                                    body.emit(assign(r1312, rshift(r12F5, r1320), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f131E->else_instructions;

                                    ir_variable *const r1321 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1323 = equal(r1310, body.constant(int(64)));
                                    ir_if *f1322 = new(mem_ctx) ir_if(operand(r1323).val);
                                    exec_list *const f1322_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1322->then_instructions;

                                       body.emit(assign(r1321, r12F5, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1322->else_instructions;

                                       ir_expression *const r1324 = nequal(r12F5, body.constant(0u));
                                       ir_expression *const r1325 = expr(ir_unop_b2i, r1324);
                                       body.emit(assign(r1321, expr(ir_unop_i2u, r1325), 0x01));


                                    body.instructions = f1322_parent_instructions;
                                    body.emit(f1322);

                                    /* END IF */

                                    body.emit(assign(r1311, r1321, 0x01));

                                    body.emit(assign(r1312, body.constant(0u), 0x01));


                                 body.instructions = f131E_parent_instructions;
                                 body.emit(f131E);

                                 /* END IF */


                              body.instructions = f131C_parent_instructions;
                              body.emit(f131C);

                              /* END IF */

                              body.emit(assign(r1313, body.constant(0u), 0x01));


                           body.instructions = f1318_parent_instructions;
                           body.emit(f1318);

                           /* END IF */

                           ir_expression *const r1326 = nequal(r130F, body.constant(0u));
                           ir_expression *const r1327 = expr(ir_unop_b2i, r1326);
                           ir_expression *const r1328 = expr(ir_unop_i2u, r1327);
                           body.emit(assign(r1311, bit_or(r1311, r1328), 0x01));


                        body.instructions = f1316_parent_instructions;
                        body.emit(f1316);

                        /* END IF */

                        body.emit(assign(r12F9, r1313, 0x01));

                        body.emit(assign(r12FA, r1312, 0x01));

                        body.emit(assign(r12FB, r1311, 0x01));

                        body.emit(assign(r12F8, body.constant(int(0)), 0x01));

                        body.emit(assign(r12FE, less(r1311, body.constant(0u)), 0x01));


                     body.instructions = f130D_parent_instructions;
                     body.emit(f130D);

                     /* END IF */


                  body.instructions = f130A_parent_instructions;
                  body.emit(f130A);

                  /* END IF */


               body.instructions = f1300_parent_instructions;
               body.emit(f1300);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1329 = new(mem_ctx) ir_if(operand(r12FC).val);
               exec_list *const f1329_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1329->then_instructions;

                  /* IF CONDITION */
                  ir_if *f132A = new(mem_ctx) ir_if(operand(r12FE).val);
                  exec_list *const f132A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f132A->then_instructions;

                     ir_variable *const r132B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r132B, add(r12FA, body.constant(1u)), 0x01));

                     ir_expression *const r132C = less(r132B, r12FA);
                     ir_expression *const r132D = expr(ir_unop_b2i, r132C);
                     ir_expression *const r132E = expr(ir_unop_i2u, r132D);
                     body.emit(assign(r12F9, add(r12F9, r132E), 0x01));

                     ir_expression *const r132F = equal(r12FB, body.constant(0u));
                     ir_expression *const r1330 = expr(ir_unop_b2i, r132F);
                     ir_expression *const r1331 = expr(ir_unop_i2u, r1330);
                     ir_expression *const r1332 = add(r12FB, r1331);
                     ir_expression *const r1333 = bit_and(r1332, body.constant(1u));
                     ir_expression *const r1334 = expr(ir_unop_bit_not, r1333);
                     body.emit(assign(r12FA, bit_and(r132B, r1334), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f132A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1336 = bit_or(r12F9, r12FA);
                     ir_expression *const r1337 = equal(r1336, body.constant(0u));
                     ir_if *f1335 = new(mem_ctx) ir_if(operand(r1337).val);
                     exec_list *const f1335_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1335->then_instructions;

                        body.emit(assign(r12F8, body.constant(int(0)), 0x01));


                     body.instructions = f1335_parent_instructions;
                     body.emit(f1335);

                     /* END IF */


                  body.instructions = f132A_parent_instructions;
                  body.emit(f132A);

                  /* END IF */

                  ir_variable *const r1338 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1338);
                  ir_expression *const r1339 = lshift(r10CF, body.constant(int(31)));
                  ir_expression *const r133A = expr(ir_unop_i2u, r12F8);
                  ir_expression *const r133B = lshift(r133A, body.constant(int(20)));
                  ir_expression *const r133C = add(r1339, r133B);
                  body.emit(assign(r1338, add(r133C, r12F9), 0x02));

                  body.emit(assign(r1338, r12FA, 0x01));

                  body.emit(assign(r12FD, r1338, 0x03));

                  body.emit(assign(r12FC, body.constant(false), 0x01));


               body.instructions = f1329_parent_instructions;
               body.emit(f1329);

               /* END IF */

               body.emit(assign(r10CE, r12FD, 0x03));

               body.emit(assign(r10CD, body.constant(false), 0x01));


            body.instructions = f11DB_parent_instructions;
            body.emit(f11DB);

            /* END IF */


         body.instructions = f119A_parent_instructions;
         body.emit(f119A);

         /* END IF */


      body.instructions = f1130_parent_instructions;
      body.emit(f1130);

      /* END IF */


   body.instructions = f10E9_parent_instructions;
   body.emit(f10E9);

   /* END IF */

   body.emit(ret(r10CE));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat32Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r133D = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_function_in);
   sig_parameters.push_tail(r133D);
   ir_variable *const r133E = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r133E);
   ir_variable *const r133F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFracPtr", ir_var_function_inout);
   sig_parameters.push_tail(r133F);
   ir_variable *const r1340 = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r1340, r133D, 0x01));

   ir_variable *const r1341 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r1342 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r1342);
   /* IF CONDITION */
   ir_expression *const r1344 = equal(r133D, body.constant(0u));
   ir_if *f1343 = new(mem_ctx) ir_if(operand(r1344).val);
   exec_list *const f1343_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1343->then_instructions;

      body.emit(assign(r1341, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1343->else_instructions;

      body.emit(assign(r1342, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r1346 = bit_and(r133D, body.constant(4294901760u));
      ir_expression *const r1347 = equal(r1346, body.constant(0u));
      ir_if *f1345 = new(mem_ctx) ir_if(operand(r1347).val);
      exec_list *const f1345_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1345->then_instructions;

         body.emit(assign(r1342, body.constant(int(16)), 0x01));

         body.emit(assign(r1340, lshift(r133D, body.constant(int(16))), 0x01));


      body.instructions = f1345_parent_instructions;
      body.emit(f1345);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1349 = bit_and(r1340, body.constant(4278190080u));
      ir_expression *const r134A = equal(r1349, body.constant(0u));
      ir_if *f1348 = new(mem_ctx) ir_if(operand(r134A).val);
      exec_list *const f1348_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1348->then_instructions;

         body.emit(assign(r1342, add(r1342, body.constant(int(8))), 0x01));

         body.emit(assign(r1340, lshift(r1340, body.constant(int(8))), 0x01));


      body.instructions = f1348_parent_instructions;
      body.emit(f1348);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r134C = bit_and(r1340, body.constant(4026531840u));
      ir_expression *const r134D = equal(r134C, body.constant(0u));
      ir_if *f134B = new(mem_ctx) ir_if(operand(r134D).val);
      exec_list *const f134B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f134B->then_instructions;

         body.emit(assign(r1342, add(r1342, body.constant(int(4))), 0x01));

         body.emit(assign(r1340, lshift(r1340, body.constant(int(4))), 0x01));


      body.instructions = f134B_parent_instructions;
      body.emit(f134B);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r134F = bit_and(r1340, body.constant(3221225472u));
      ir_expression *const r1350 = equal(r134F, body.constant(0u));
      ir_if *f134E = new(mem_ctx) ir_if(operand(r1350).val);
      exec_list *const f134E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f134E->then_instructions;

         body.emit(assign(r1342, add(r1342, body.constant(int(2))), 0x01));

         body.emit(assign(r1340, lshift(r1340, body.constant(int(2))), 0x01));


      body.instructions = f134E_parent_instructions;
      body.emit(f134E);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1352 = bit_and(r1340, body.constant(2147483648u));
      ir_expression *const r1353 = equal(r1352, body.constant(0u));
      ir_if *f1351 = new(mem_ctx) ir_if(operand(r1353).val);
      exec_list *const f1351_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1351->then_instructions;

         body.emit(assign(r1342, add(r1342, body.constant(int(1))), 0x01));


      body.instructions = f1351_parent_instructions;
      body.emit(f1351);

      /* END IF */

      body.emit(assign(r1341, r1342, 0x01));


   body.instructions = f1343_parent_instructions;
   body.emit(f1343);

   /* END IF */

   ir_variable *const r1354 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r1354, add(r1341, body.constant(int(-8))), 0x01));

   body.emit(assign(r133F, lshift(r133D, r1354), 0x01));

   body.emit(assign(r133E, sub(body.constant(int(1)), r1354), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Frac(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1355 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1355);
   ir_expression *const r1356 = bit_and(r1355, body.constant(8388607u));
   body.emit(ret(r1356));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1357 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1357);
   ir_expression *const r1358 = rshift(r1357, body.constant(int(23)));
   ir_expression *const r1359 = bit_and(r1358, body.constant(255u));
   ir_expression *const r135A = expr(ir_unop_u2i, r1359);
   body.emit(ret(r135A));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r135B = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r135B);
   ir_expression *const r135C = rshift(r135B, body.constant(int(31)));
   body.emit(ret(r135C));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp32_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r135D = new(mem_ctx) ir_variable(glsl_type::float_type, "f", ir_var_function_in);
   sig_parameters.push_tail(r135D);
   ir_variable *const r135E = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r135E, body.constant(true), 0x01));

   ir_variable *const r135F = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1360 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r1360);
   ir_variable *const r1361 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_auto);
   body.emit(r1361);
   ir_variable *const r1362 = body.make_temp(glsl_type::uint_type, "floatBitsToUint_retval");
   body.emit(assign(r1362, expr(ir_unop_bitcast_f2u, r135D), 0x01));

   ir_variable *const r1363 = body.make_temp(glsl_type::uint_type, "extractFloat32Frac_retval");
   body.emit(assign(r1363, bit_and(r1362, body.constant(8388607u)), 0x01));

   body.emit(assign(r1361, r1363, 0x01));

   ir_variable *const r1364 = body.make_temp(glsl_type::int_type, "extractFloat32Exp_retval");
   ir_expression *const r1365 = rshift(r1362, body.constant(int(23)));
   ir_expression *const r1366 = bit_and(r1365, body.constant(255u));
   body.emit(assign(r1364, expr(ir_unop_u2i, r1366), 0x01));

   body.emit(assign(r1360, r1364, 0x01));

   ir_variable *const r1367 = body.make_temp(glsl_type::uint_type, "extractFloat32Sign_retval");
   body.emit(assign(r1367, rshift(r1362, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1369 = equal(r1364, body.constant(int(255)));
   ir_if *f1368 = new(mem_ctx) ir_if(operand(r1369).val);
   exec_list *const f1368_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1368->then_instructions;

      /* IF CONDITION */
      ir_expression *const r136B = nequal(r1363, body.constant(0u));
      ir_if *f136A = new(mem_ctx) ir_if(operand(r136B).val);
      exec_list *const f136A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f136A->then_instructions;

         ir_variable *const r136C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r136C, lshift(r1362, body.constant(int(9))), 0x01));

         ir_variable *const r136D = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         ir_expression *const r136E = lshift(r136C, body.constant(int(20)));
         body.emit(assign(r136D, bit_or(r136E, body.constant(0u)), 0x01));

         ir_expression *const r136F = rshift(r136C, body.constant(int(12)));
         ir_expression *const r1370 = lshift(r1367, body.constant(int(31)));
         ir_expression *const r1371 = bit_or(r1370, body.constant(2146959360u));
         body.emit(assign(r136D, bit_or(r136F, r1371), 0x02));

         body.emit(assign(r135F, r136D, 0x03));

         body.emit(assign(r135E, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f136A->else_instructions;

         ir_variable *const r1372 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1372);
         ir_expression *const r1373 = lshift(r1367, body.constant(int(31)));
         body.emit(assign(r1372, add(r1373, body.constant(2146435072u)), 0x02));

         body.emit(assign(r1372, body.constant(0u), 0x01));

         body.emit(assign(r135F, r1372, 0x03));

         body.emit(assign(r135E, body.constant(false), 0x01));


      body.instructions = f136A_parent_instructions;
      body.emit(f136A);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1368->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1375 = equal(r1364, body.constant(int(0)));
      ir_if *f1374 = new(mem_ctx) ir_if(operand(r1375).val);
      exec_list *const f1374_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1374->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1377 = equal(r1363, body.constant(0u));
         ir_if *f1376 = new(mem_ctx) ir_if(operand(r1377).val);
         exec_list *const f1376_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1376->then_instructions;

            ir_variable *const r1378 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r1378);
            body.emit(assign(r1378, lshift(r1367, body.constant(int(31))), 0x02));

            body.emit(assign(r1378, body.constant(0u), 0x01));

            body.emit(assign(r135F, r1378, 0x03));

            body.emit(assign(r135E, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1376->else_instructions;

            ir_variable *const r1379 = body.make_temp(glsl_type::int_type, "zExpPtr");
            body.emit(assign(r1379, r1364, 0x01));

            ir_variable *const r137A = body.make_temp(glsl_type::uint_type, "zFracPtr");
            body.emit(assign(r137A, r1363, 0x01));

            ir_variable *const r137B = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r137B, r1363, 0x01));

            ir_variable *const r137C = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r137D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r137D);
            /* IF CONDITION */
            ir_expression *const r137F = equal(r1363, body.constant(0u));
            ir_if *f137E = new(mem_ctx) ir_if(operand(r137F).val);
            exec_list *const f137E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f137E->then_instructions;

               body.emit(assign(r137C, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f137E->else_instructions;

               body.emit(assign(r137D, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r1381 = bit_and(r1363, body.constant(4294901760u));
               ir_expression *const r1382 = equal(r1381, body.constant(0u));
               ir_if *f1380 = new(mem_ctx) ir_if(operand(r1382).val);
               exec_list *const f1380_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1380->then_instructions;

                  body.emit(assign(r137D, body.constant(int(16)), 0x01));

                  body.emit(assign(r137B, lshift(r1363, body.constant(int(16))), 0x01));


               body.instructions = f1380_parent_instructions;
               body.emit(f1380);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1384 = bit_and(r137B, body.constant(4278190080u));
               ir_expression *const r1385 = equal(r1384, body.constant(0u));
               ir_if *f1383 = new(mem_ctx) ir_if(operand(r1385).val);
               exec_list *const f1383_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1383->then_instructions;

                  body.emit(assign(r137D, add(r137D, body.constant(int(8))), 0x01));

                  body.emit(assign(r137B, lshift(r137B, body.constant(int(8))), 0x01));


               body.instructions = f1383_parent_instructions;
               body.emit(f1383);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1387 = bit_and(r137B, body.constant(4026531840u));
               ir_expression *const r1388 = equal(r1387, body.constant(0u));
               ir_if *f1386 = new(mem_ctx) ir_if(operand(r1388).val);
               exec_list *const f1386_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1386->then_instructions;

                  body.emit(assign(r137D, add(r137D, body.constant(int(4))), 0x01));

                  body.emit(assign(r137B, lshift(r137B, body.constant(int(4))), 0x01));


               body.instructions = f1386_parent_instructions;
               body.emit(f1386);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r138A = bit_and(r137B, body.constant(3221225472u));
               ir_expression *const r138B = equal(r138A, body.constant(0u));
               ir_if *f1389 = new(mem_ctx) ir_if(operand(r138B).val);
               exec_list *const f1389_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1389->then_instructions;

                  body.emit(assign(r137D, add(r137D, body.constant(int(2))), 0x01));

                  body.emit(assign(r137B, lshift(r137B, body.constant(int(2))), 0x01));


               body.instructions = f1389_parent_instructions;
               body.emit(f1389);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r138D = bit_and(r137B, body.constant(2147483648u));
               ir_expression *const r138E = equal(r138D, body.constant(0u));
               ir_if *f138C = new(mem_ctx) ir_if(operand(r138E).val);
               exec_list *const f138C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f138C->then_instructions;

                  body.emit(assign(r137D, add(r137D, body.constant(int(1))), 0x01));


               body.instructions = f138C_parent_instructions;
               body.emit(f138C);

               /* END IF */

               body.emit(assign(r137C, r137D, 0x01));


            body.instructions = f137E_parent_instructions;
            body.emit(f137E);

            /* END IF */

            ir_variable *const r138F = body.make_temp(glsl_type::int_type, "assignment_tmp");
            body.emit(assign(r138F, add(r137C, body.constant(int(-8))), 0x01));

            body.emit(assign(r137A, lshift(r1363, r138F), 0x01));

            body.emit(assign(r1379, sub(body.constant(int(1)), r138F), 0x01));

            body.emit(assign(r1361, r137A, 0x01));

            body.emit(assign(r1360, add(r1379, body.constant(int(-1))), 0x01));


         body.instructions = f1376_parent_instructions;
         body.emit(f1376);

         /* END IF */


      body.instructions = f1374_parent_instructions;
      body.emit(f1374);

      /* END IF */

      /* IF CONDITION */
      ir_if *f1390 = new(mem_ctx) ir_if(operand(r135E).val);
      exec_list *const f1390_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1390->then_instructions;

         ir_variable *const r1391 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1391);
         ir_expression *const r1392 = lshift(r1367, body.constant(int(31)));
         ir_expression *const r1393 = add(r1360, body.constant(int(896)));
         ir_expression *const r1394 = expr(ir_unop_i2u, r1393);
         ir_expression *const r1395 = lshift(r1394, body.constant(int(20)));
         ir_expression *const r1396 = add(r1392, r1395);
         ir_expression *const r1397 = rshift(r1361, body.constant(int(3)));
         body.emit(assign(r1391, add(r1396, r1397), 0x02));

         ir_expression *const r1398 = lshift(r1361, body.constant(int(29)));
         body.emit(assign(r1391, bit_or(r1398, body.constant(0u)), 0x01));

         body.emit(assign(r135F, r1391, 0x03));

         body.emit(assign(r135E, body.constant(false), 0x01));


      body.instructions = f1390_parent_instructions;
      body.emit(f1390);

      /* END IF */


   body.instructions = f1368_parent_instructions;
   body.emit(f1368);

   /* END IF */

   body.emit(ret(r135F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::float_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1399 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r1399);
   ir_variable *const r139A = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r139A);
   ir_variable *const r139B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r139B);
   ir_variable *const r139C = body.make_temp(glsl_type::float_type, "uintBitsToFloat_retval");
   ir_expression *const r139D = lshift(r1399, body.constant(int(31)));
   ir_expression *const r139E = expr(ir_unop_i2u, r139A);
   ir_expression *const r139F = lshift(r139E, body.constant(int(23)));
   ir_expression *const r13A0 = add(r139D, r139F);
   ir_expression *const r13A1 = add(r13A0, r139B);
   body.emit(assign(r139C, expr(ir_unop_bitcast_u2f, r13A1), 0x01));

   body.emit(ret(r139C));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift32RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r13A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r13A2);
   ir_variable *const r13A3 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r13A3);
   ir_variable *const r13A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zPtr", ir_var_function_inout);
   sig_parameters.push_tail(r13A4);
   ir_variable *const r13A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r13A5);
   /* IF CONDITION */
   ir_expression *const r13A7 = equal(r13A3, body.constant(int(0)));
   ir_if *f13A6 = new(mem_ctx) ir_if(operand(r13A7).val);
   exec_list *const f13A6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f13A6->then_instructions;

      body.emit(assign(r13A5, r13A2, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f13A6->else_instructions;

      /* IF CONDITION */
      ir_expression *const r13A9 = less(r13A3, body.constant(int(32)));
      ir_if *f13A8 = new(mem_ctx) ir_if(operand(r13A9).val);
      exec_list *const f13A8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f13A8->then_instructions;

         ir_expression *const r13AA = rshift(r13A2, r13A3);
         ir_expression *const r13AB = neg(r13A3);
         ir_expression *const r13AC = bit_and(r13AB, body.constant(int(31)));
         ir_expression *const r13AD = lshift(r13A2, r13AC);
         ir_expression *const r13AE = nequal(r13AD, body.constant(0u));
         ir_expression *const r13AF = expr(ir_unop_b2i, r13AE);
         ir_expression *const r13B0 = expr(ir_unop_i2u, r13AF);
         body.emit(assign(r13A5, bit_or(r13AA, r13B0), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f13A8->else_instructions;

         ir_expression *const r13B1 = nequal(r13A2, body.constant(0u));
         ir_expression *const r13B2 = expr(ir_unop_b2i, r13B1);
         body.emit(assign(r13A5, expr(ir_unop_i2u, r13B2), 0x01));


      body.instructions = f13A8_parent_instructions;
      body.emit(f13A8);

      /* END IF */


   body.instructions = f13A6_parent_instructions;
   body.emit(f13A6);

   /* END IF */

   body.emit(assign(r13A4, r13A5, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::float_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r13B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r13B3);
   ir_variable *const r13B4 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r13B4);
   ir_variable *const r13B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r13B5);
   ir_variable *const r13B6 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r13B6, body.constant(true), 0x01));

   ir_variable *const r13B7 = body.make_temp(glsl_type::float_type, "return_value");
   ir_variable *const r13B8 = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
   body.emit(r13B8);
   ir_expression *const r13B9 = bit_and(r13B5, body.constant(127u));
   body.emit(assign(r13B8, expr(ir_unop_u2i, r13B9), 0x01));

   /* IF CONDITION */
   ir_expression *const r13BB = expr(ir_unop_i2u, r13B4);
   ir_expression *const r13BC = lequal(body.constant(253u), r13BB);
   ir_if *f13BA = new(mem_ctx) ir_if(operand(r13BC).val);
   exec_list *const f13BA_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f13BA->then_instructions;

      /* IF CONDITION */
      ir_expression *const r13BE = less(body.constant(int(253)), r13B4);
      ir_expression *const r13BF = equal(r13B4, body.constant(int(253)));
      ir_expression *const r13C0 = expr(ir_unop_u2i, r13B5);
      ir_expression *const r13C1 = less(r13C0, body.constant(int(-64)));
      ir_expression *const r13C2 = logic_and(r13BF, r13C1);
      ir_expression *const r13C3 = logic_or(r13BE, r13C2);
      ir_if *f13BD = new(mem_ctx) ir_if(operand(r13C3).val);
      exec_list *const f13BD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f13BD->then_instructions;

         ir_expression *const r13C4 = lshift(r13B3, body.constant(int(31)));
         ir_expression *const r13C5 = add(r13C4, body.constant(2139095040u));
         body.emit(assign(r13B7, expr(ir_unop_bitcast_u2f, r13C5), 0x01));

         body.emit(assign(r13B6, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f13BD->else_instructions;

         /* IF CONDITION */
         ir_expression *const r13C7 = less(r13B4, body.constant(int(0)));
         ir_if *f13C6 = new(mem_ctx) ir_if(operand(r13C7).val);
         exec_list *const f13C6_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f13C6->then_instructions;

            ir_variable *const r13C8 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r13C8, neg(r13B4), 0x01));

            ir_variable *const r13C9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
            body.emit(r13C9);
            /* IF CONDITION */
            ir_expression *const r13CB = equal(r13C8, body.constant(int(0)));
            ir_if *f13CA = new(mem_ctx) ir_if(operand(r13CB).val);
            exec_list *const f13CA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f13CA->then_instructions;

               body.emit(assign(r13C9, r13B5, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f13CA->else_instructions;

               /* IF CONDITION */
               ir_expression *const r13CD = less(r13C8, body.constant(int(32)));
               ir_if *f13CC = new(mem_ctx) ir_if(operand(r13CD).val);
               exec_list *const f13CC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f13CC->then_instructions;

                  ir_expression *const r13CE = rshift(r13B5, r13C8);
                  ir_expression *const r13CF = neg(r13C8);
                  ir_expression *const r13D0 = bit_and(r13CF, body.constant(int(31)));
                  ir_expression *const r13D1 = lshift(r13B5, r13D0);
                  ir_expression *const r13D2 = nequal(r13D1, body.constant(0u));
                  ir_expression *const r13D3 = expr(ir_unop_b2i, r13D2);
                  ir_expression *const r13D4 = expr(ir_unop_i2u, r13D3);
                  body.emit(assign(r13C9, bit_or(r13CE, r13D4), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f13CC->else_instructions;

                  ir_expression *const r13D5 = nequal(r13B5, body.constant(0u));
                  ir_expression *const r13D6 = expr(ir_unop_b2i, r13D5);
                  body.emit(assign(r13C9, expr(ir_unop_i2u, r13D6), 0x01));


               body.instructions = f13CC_parent_instructions;
               body.emit(f13CC);

               /* END IF */


            body.instructions = f13CA_parent_instructions;
            body.emit(f13CA);

            /* END IF */

            body.emit(assign(r13B5, r13C9, 0x01));

            body.emit(assign(r13B4, body.constant(int(0)), 0x01));

            ir_expression *const r13D7 = expr(ir_unop_u2i, r13C9);
            body.emit(assign(r13B8, bit_and(r13D7, body.constant(int(127))), 0x01));


         body.instructions = f13C6_parent_instructions;
         body.emit(f13C6);

         /* END IF */


      body.instructions = f13BD_parent_instructions;
      body.emit(f13BD);

      /* END IF */


   body.instructions = f13BA_parent_instructions;
   body.emit(f13BA);

   /* END IF */

   /* IF CONDITION */
   ir_if *f13D8 = new(mem_ctx) ir_if(operand(r13B6).val);
   exec_list *const f13D8_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f13D8->then_instructions;

      ir_expression *const r13D9 = add(r13B5, body.constant(64u));
      body.emit(assign(r13B5, rshift(r13D9, body.constant(int(7))), 0x01));

      ir_expression *const r13DA = bit_xor(r13B8, body.constant(int(64)));
      ir_expression *const r13DB = equal(r13DA, body.constant(int(0)));
      ir_expression *const r13DC = expr(ir_unop_b2i, r13DB);
      ir_expression *const r13DD = expr(ir_unop_i2u, r13DC);
      ir_expression *const r13DE = expr(ir_unop_bit_not, r13DD);
      body.emit(assign(r13B5, bit_and(r13B5, r13DE), 0x01));

      /* IF CONDITION */
      ir_expression *const r13E0 = equal(r13B5, body.constant(0u));
      ir_if *f13DF = new(mem_ctx) ir_if(operand(r13E0).val);
      exec_list *const f13DF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f13DF->then_instructions;

         body.emit(assign(r13B4, body.constant(int(0)), 0x01));


      body.instructions = f13DF_parent_instructions;
      body.emit(f13DF);

      /* END IF */

      ir_expression *const r13E1 = lshift(r13B3, body.constant(int(31)));
      ir_expression *const r13E2 = expr(ir_unop_i2u, r13B4);
      ir_expression *const r13E3 = lshift(r13E2, body.constant(int(23)));
      ir_expression *const r13E4 = add(r13E1, r13E3);
      ir_expression *const r13E5 = add(r13E4, r13B5);
      body.emit(assign(r13B7, expr(ir_unop_bitcast_u2f, r13E5), 0x01));

      body.emit(assign(r13B6, body.constant(false), 0x01));


   body.instructions = f13D8_parent_instructions;
   body.emit(f13D8);

   /* END IF */

   body.emit(ret(r13B7));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_fp32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::float_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r13E6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r13E6);
   ir_variable *const r13E7 = body.make_temp(glsl_type::float_type, "return_value");
   ir_variable *const r13E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_auto);
   body.emit(r13E8);
   body.emit(assign(r13E8, body.constant(0u), 0x01));

   ir_variable *const r13E9 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r13E9, swizzle_x(r13E6), 0x01));

   ir_variable *const r13EA = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r13EA, bit_and(swizzle_y(r13E6), body.constant(1048575u)), 0x01));

   ir_variable *const r13EB = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r13EC = rshift(swizzle_y(r13E6), body.constant(int(20)));
   ir_expression *const r13ED = bit_and(r13EC, body.constant(2047u));
   body.emit(assign(r13EB, expr(ir_unop_u2i, r13ED), 0x01));

   ir_variable *const r13EE = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r13EE, rshift(swizzle_y(r13E6), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r13F0 = equal(r13EB, body.constant(int(2047)));
   ir_if *f13EF = new(mem_ctx) ir_if(operand(r13F0).val);
   exec_list *const f13EF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f13EF->then_instructions;

      /* IF CONDITION */
      ir_expression *const r13F2 = bit_or(r13EA, swizzle_x(r13E6));
      ir_expression *const r13F3 = nequal(r13F2, body.constant(0u));
      ir_if *f13F1 = new(mem_ctx) ir_if(operand(r13F3).val);
      exec_list *const f13F1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f13F1->then_instructions;

         ir_variable *const r13F4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r13F4, lshift(swizzle_x(r13E6), body.constant(int(12))), 0x01));

         ir_variable *const r13F5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r13F6 = lshift(swizzle_y(r13E6), body.constant(int(12)));
         ir_expression *const r13F7 = rshift(swizzle_x(r13E6), body.constant(int(20)));
         body.emit(assign(r13F5, bit_or(r13F6, r13F7), 0x01));

         body.emit(assign(r13E6, r13F5, 0x02));

         body.emit(assign(r13E6, r13F4, 0x01));

         ir_expression *const r13F8 = lshift(r13EE, body.constant(int(31)));
         ir_expression *const r13F9 = bit_or(r13F8, body.constant(2143289344u));
         ir_expression *const r13FA = rshift(r13F5, body.constant(int(9)));
         ir_expression *const r13FB = bit_or(r13F9, r13FA);
         body.emit(assign(r13E7, expr(ir_unop_bitcast_u2f, r13FB), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f13F1->else_instructions;

         ir_expression *const r13FC = lshift(r13EE, body.constant(int(31)));
         ir_expression *const r13FD = add(r13FC, body.constant(2139095040u));
         body.emit(assign(r13E7, expr(ir_unop_bitcast_u2f, r13FD), 0x01));


      body.instructions = f13F1_parent_instructions;
      body.emit(f13F1);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f13EF->else_instructions;

      ir_variable *const r13FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r13FE);
      ir_variable *const r13FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r13FF);
      ir_expression *const r1400 = lshift(r13EA, body.constant(int(10)));
      ir_expression *const r1401 = rshift(r13E9, body.constant(int(22)));
      ir_expression *const r1402 = bit_or(r1400, r1401);
      ir_expression *const r1403 = lshift(r13E9, body.constant(int(10)));
      ir_expression *const r1404 = nequal(r1403, body.constant(0u));
      ir_expression *const r1405 = expr(ir_unop_b2i, r1404);
      ir_expression *const r1406 = expr(ir_unop_i2u, r1405);
      body.emit(assign(r13FE, bit_or(r1402, r1406), 0x01));

      body.emit(assign(r13FF, rshift(r13EA, body.constant(int(22))), 0x01));

      body.emit(assign(r13E8, r13FE, 0x01));

      /* IF CONDITION */
      ir_expression *const r1408 = nequal(r13EB, body.constant(int(0)));
      ir_if *f1407 = new(mem_ctx) ir_if(operand(r1408).val);
      exec_list *const f1407_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1407->then_instructions;

         body.emit(assign(r13E8, bit_or(r13FE, body.constant(1073741824u)), 0x01));


      body.instructions = f1407_parent_instructions;
      body.emit(f1407);

      /* END IF */

      ir_variable *const r1409 = body.make_temp(glsl_type::int_type, "zExp");
      body.emit(assign(r1409, add(r13EB, body.constant(int(-897))), 0x01));

      ir_variable *const r140A = body.make_temp(glsl_type::uint_type, "zFrac");
      body.emit(assign(r140A, r13E8, 0x01));

      ir_variable *const r140B = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r140B, body.constant(true), 0x01));

      ir_variable *const r140C = body.make_temp(glsl_type::float_type, "return_value");
      ir_variable *const r140D = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
      body.emit(r140D);
      ir_expression *const r140E = bit_and(r13E8, body.constant(127u));
      body.emit(assign(r140D, expr(ir_unop_u2i, r140E), 0x01));

      /* IF CONDITION */
      ir_expression *const r1410 = expr(ir_unop_i2u, r1409);
      ir_expression *const r1411 = lequal(body.constant(253u), r1410);
      ir_if *f140F = new(mem_ctx) ir_if(operand(r1411).val);
      exec_list *const f140F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f140F->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1413 = less(body.constant(int(253)), r1409);
         ir_expression *const r1414 = equal(r1409, body.constant(int(253)));
         ir_expression *const r1415 = expr(ir_unop_u2i, r13E8);
         ir_expression *const r1416 = less(r1415, body.constant(int(-64)));
         ir_expression *const r1417 = logic_and(r1414, r1416);
         ir_expression *const r1418 = logic_or(r1413, r1417);
         ir_if *f1412 = new(mem_ctx) ir_if(operand(r1418).val);
         exec_list *const f1412_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1412->then_instructions;

            ir_expression *const r1419 = lshift(r13EE, body.constant(int(31)));
            ir_expression *const r141A = add(r1419, body.constant(2139095040u));
            body.emit(assign(r140C, expr(ir_unop_bitcast_u2f, r141A), 0x01));

            body.emit(assign(r140B, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1412->else_instructions;

            /* IF CONDITION */
            ir_expression *const r141C = less(r1409, body.constant(int(0)));
            ir_if *f141B = new(mem_ctx) ir_if(operand(r141C).val);
            exec_list *const f141B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f141B->then_instructions;

               ir_variable *const r141D = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r141D, neg(r1409), 0x01));

               ir_variable *const r141E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r141E);
               /* IF CONDITION */
               ir_expression *const r1420 = equal(r141D, body.constant(int(0)));
               ir_if *f141F = new(mem_ctx) ir_if(operand(r1420).val);
               exec_list *const f141F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f141F->then_instructions;

                  body.emit(assign(r141E, r13E8, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f141F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1422 = less(r141D, body.constant(int(32)));
                  ir_if *f1421 = new(mem_ctx) ir_if(operand(r1422).val);
                  exec_list *const f1421_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1421->then_instructions;

                     ir_expression *const r1423 = rshift(r13E8, r141D);
                     ir_expression *const r1424 = neg(r141D);
                     ir_expression *const r1425 = bit_and(r1424, body.constant(int(31)));
                     ir_expression *const r1426 = lshift(r13E8, r1425);
                     ir_expression *const r1427 = nequal(r1426, body.constant(0u));
                     ir_expression *const r1428 = expr(ir_unop_b2i, r1427);
                     ir_expression *const r1429 = expr(ir_unop_i2u, r1428);
                     body.emit(assign(r141E, bit_or(r1423, r1429), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1421->else_instructions;

                     ir_expression *const r142A = nequal(r13E8, body.constant(0u));
                     ir_expression *const r142B = expr(ir_unop_b2i, r142A);
                     body.emit(assign(r141E, expr(ir_unop_i2u, r142B), 0x01));


                  body.instructions = f1421_parent_instructions;
                  body.emit(f1421);

                  /* END IF */


               body.instructions = f141F_parent_instructions;
               body.emit(f141F);

               /* END IF */

               body.emit(assign(r140A, r141E, 0x01));

               body.emit(assign(r1409, body.constant(int(0)), 0x01));

               ir_expression *const r142C = expr(ir_unop_u2i, r141E);
               body.emit(assign(r140D, bit_and(r142C, body.constant(int(127))), 0x01));


            body.instructions = f141B_parent_instructions;
            body.emit(f141B);

            /* END IF */


         body.instructions = f1412_parent_instructions;
         body.emit(f1412);

         /* END IF */


      body.instructions = f140F_parent_instructions;
      body.emit(f140F);

      /* END IF */

      /* IF CONDITION */
      ir_if *f142D = new(mem_ctx) ir_if(operand(r140B).val);
      exec_list *const f142D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f142D->then_instructions;

         ir_expression *const r142E = add(r140A, body.constant(64u));
         body.emit(assign(r140A, rshift(r142E, body.constant(int(7))), 0x01));

         ir_expression *const r142F = bit_xor(r140D, body.constant(int(64)));
         ir_expression *const r1430 = equal(r142F, body.constant(int(0)));
         ir_expression *const r1431 = expr(ir_unop_b2i, r1430);
         ir_expression *const r1432 = expr(ir_unop_i2u, r1431);
         ir_expression *const r1433 = expr(ir_unop_bit_not, r1432);
         body.emit(assign(r140A, bit_and(r140A, r1433), 0x01));

         /* IF CONDITION */
         ir_expression *const r1435 = equal(r140A, body.constant(0u));
         ir_if *f1434 = new(mem_ctx) ir_if(operand(r1435).val);
         exec_list *const f1434_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1434->then_instructions;

            body.emit(assign(r1409, body.constant(int(0)), 0x01));


         body.instructions = f1434_parent_instructions;
         body.emit(f1434);

         /* END IF */

         ir_expression *const r1436 = lshift(r13EE, body.constant(int(31)));
         ir_expression *const r1437 = expr(ir_unop_i2u, r1409);
         ir_expression *const r1438 = lshift(r1437, body.constant(int(23)));
         ir_expression *const r1439 = add(r1436, r1438);
         ir_expression *const r143A = add(r1439, r140A);
         body.emit(assign(r140C, expr(ir_unop_bitcast_u2f, r143A), 0x01));

         body.emit(assign(r140B, body.constant(false), 0x01));


      body.instructions = f142D_parent_instructions;
      body.emit(f142D);

      /* END IF */

      body.emit(assign(r13E7, r140C, 0x01));


   body.instructions = f13EF_parent_instructions;
   body.emit(f13EF);

   /* END IF */

   body.emit(ret(r13E7));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_int(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r143B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r143B);
   ir_variable *const r143C = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r143C, body.constant(true), 0x01));

   ir_variable *const r143D = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r143E = new(mem_ctx) ir_variable(glsl_type::uint_type, "absZ", ir_var_auto);
   body.emit(r143E);
   ir_variable *const r143F = new(mem_ctx) ir_variable(glsl_type::uint_type, "aSign", ir_var_auto);
   body.emit(r143F);
   ir_variable *const r1440 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r1440);
   ir_variable *const r1441 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1441, bit_and(swizzle_y(r143B), body.constant(1048575u)), 0x01));

   body.emit(assign(r1440, r1441, 0x01));

   ir_variable *const r1442 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1443 = rshift(swizzle_y(r143B), body.constant(int(20)));
   ir_expression *const r1444 = bit_and(r1443, body.constant(2047u));
   body.emit(assign(r1442, expr(ir_unop_u2i, r1444), 0x01));

   body.emit(assign(r143F, rshift(swizzle_y(r143B), body.constant(int(31))), 0x01));

   body.emit(assign(r143E, body.constant(0u), 0x01));

   ir_variable *const r1445 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r1445, add(r1442, body.constant(int(-1043))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1447 = lequal(body.constant(int(0)), r1445);
   ir_if *f1446 = new(mem_ctx) ir_if(operand(r1447).val);
   exec_list *const f1446_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1446->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1449 = less(body.constant(int(1054)), r1442);
      ir_if *f1448 = new(mem_ctx) ir_if(operand(r1449).val);
      exec_list *const f1448_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1448->then_instructions;

         /* IF CONDITION */
         ir_expression *const r144B = equal(r1442, body.constant(int(2047)));
         ir_expression *const r144C = bit_or(r1441, swizzle_x(r143B));
         ir_expression *const r144D = expr(ir_unop_u2i, r144C);
         ir_expression *const r144E = expr(ir_unop_i2b, r144D);
         ir_expression *const r144F = logic_and(r144B, r144E);
         ir_if *f144A = new(mem_ctx) ir_if(operand(r144F).val);
         exec_list *const f144A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f144A->then_instructions;

            body.emit(assign(r143F, body.constant(0u), 0x01));


         body.instructions = f144A_parent_instructions;
         body.emit(f144A);

         /* END IF */

         ir_variable *const r1450 = body.make_temp(glsl_type::int_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1452 = expr(ir_unop_u2i, r143F);
         ir_expression *const r1453 = expr(ir_unop_i2b, r1452);
         ir_if *f1451 = new(mem_ctx) ir_if(operand(r1453).val);
         exec_list *const f1451_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1451->then_instructions;

            body.emit(assign(r1450, body.constant(int(-2147483648)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1451->else_instructions;

            body.emit(assign(r1450, body.constant(int(2147483647)), 0x01));


         body.instructions = f1451_parent_instructions;
         body.emit(f1451);

         /* END IF */

         body.emit(assign(r143D, r1450, 0x01));

         body.emit(assign(r143C, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1448->else_instructions;

         ir_variable *const r1454 = body.make_temp(glsl_type::uint_type, "a0");
         body.emit(assign(r1454, bit_or(r1441, body.constant(1048576u)), 0x01));

         ir_variable *const r1455 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1455, lshift(swizzle_x(r143B), r1445), 0x01));

         ir_variable *const r1456 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1458 = equal(r1445, body.constant(int(0)));
         ir_if *f1457 = new(mem_ctx) ir_if(operand(r1458).val);
         exec_list *const f1457_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1457->then_instructions;

            body.emit(assign(r1456, r1454, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1457->else_instructions;

            ir_expression *const r1459 = lshift(r1454, r1445);
            ir_expression *const r145A = neg(r1445);
            ir_expression *const r145B = bit_and(r145A, body.constant(int(31)));
            ir_expression *const r145C = rshift(swizzle_x(r143B), r145B);
            body.emit(assign(r1456, bit_or(r1459, r145C), 0x01));


         body.instructions = f1457_parent_instructions;
         body.emit(f1457);

         /* END IF */

         body.emit(assign(r143E, r1456, 0x01));


      body.instructions = f1448_parent_instructions;
      body.emit(f1448);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1446->else_instructions;

      /* IF CONDITION */
      ir_expression *const r145E = less(r1442, body.constant(int(1023)));
      ir_if *f145D = new(mem_ctx) ir_if(operand(r145E).val);
      exec_list *const f145D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f145D->then_instructions;

         body.emit(assign(r143D, body.constant(int(0)), 0x01));

         body.emit(assign(r143C, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f145D->else_instructions;

         body.emit(assign(r1440, bit_or(r1441, body.constant(1048576u)), 0x01));

         ir_expression *const r145F = neg(r1445);
         body.emit(assign(r143E, rshift(r1440, r145F), 0x01));


      body.instructions = f145D_parent_instructions;
      body.emit(f145D);

      /* END IF */


   body.instructions = f1446_parent_instructions;
   body.emit(f1446);

   /* END IF */

   /* IF CONDITION */
   ir_if *f1460 = new(mem_ctx) ir_if(operand(r143C).val);
   exec_list *const f1460_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1460->then_instructions;

      ir_variable *const r1461 = body.make_temp(glsl_type::int_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1463 = nequal(r143F, body.constant(0u));
      ir_if *f1462 = new(mem_ctx) ir_if(operand(r1463).val);
      exec_list *const f1462_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1462->then_instructions;

         ir_expression *const r1464 = expr(ir_unop_u2i, r143E);
         body.emit(assign(r1461, neg(r1464), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1462->else_instructions;

         body.emit(assign(r1461, expr(ir_unop_u2i, r143E), 0x01));


      body.instructions = f1462_parent_instructions;
      body.emit(f1462);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1466 = less(r1461, body.constant(int(0)));
      ir_expression *const r1467 = expr(ir_unop_b2i, r1466);
      ir_expression *const r1468 = expr(ir_unop_i2u, r1467);
      ir_expression *const r1469 = bit_xor(r143F, r1468);
      ir_expression *const r146A = expr(ir_unop_u2i, r1469);
      ir_expression *const r146B = expr(ir_unop_i2b, r146A);
      ir_expression *const r146C = expr(ir_unop_i2b, r1461);
      ir_expression *const r146D = logic_and(r146B, r146C);
      ir_if *f1465 = new(mem_ctx) ir_if(operand(r146D).val);
      exec_list *const f1465_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1465->then_instructions;

         ir_variable *const r146E = body.make_temp(glsl_type::int_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1470 = expr(ir_unop_u2i, r143F);
         ir_expression *const r1471 = expr(ir_unop_i2b, r1470);
         ir_if *f146F = new(mem_ctx) ir_if(operand(r1471).val);
         exec_list *const f146F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f146F->then_instructions;

            body.emit(assign(r146E, body.constant(int(-2147483648)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f146F->else_instructions;

            body.emit(assign(r146E, body.constant(int(2147483647)), 0x01));


         body.instructions = f146F_parent_instructions;
         body.emit(f146F);

         /* END IF */

         body.emit(assign(r143D, r146E, 0x01));

         body.emit(assign(r143C, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1465->else_instructions;

         body.emit(assign(r143D, r1461, 0x01));

         body.emit(assign(r143C, body.constant(false), 0x01));


      body.instructions = f1465_parent_instructions;
      body.emit(f1465);

      /* END IF */


   body.instructions = f1460_parent_instructions;
   body.emit(f1460);

   /* END IF */

   body.emit(ret(r143D));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
int_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1472 = new(mem_ctx) ir_variable(glsl_type::int_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1472);
   ir_variable *const r1473 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1474 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r1474);
   ir_variable *const r1475 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r1475);
   ir_variable *const r1476 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r1476);
   body.emit(assign(r1476, body.constant(0u), 0x01));

   body.emit(assign(r1475, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1478 = equal(r1472, body.constant(int(0)));
   ir_if *f1477 = new(mem_ctx) ir_if(operand(r1478).val);
   exec_list *const f1477_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1477->then_instructions;

      ir_variable *const r1479 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1479);
      body.emit(assign(r1479, body.constant(0u), 0x02));

      body.emit(assign(r1479, body.constant(0u), 0x01));

      body.emit(assign(r1473, r1479, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1477->else_instructions;

      ir_expression *const r147A = less(r1472, body.constant(int(0)));
      ir_expression *const r147B = expr(ir_unop_b2i, r147A);
      body.emit(assign(r1474, expr(ir_unop_i2u, r147B), 0x01));

      ir_variable *const r147C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r147E = less(r1472, body.constant(int(0)));
      ir_if *f147D = new(mem_ctx) ir_if(operand(r147E).val);
      exec_list *const f147D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f147D->then_instructions;

         ir_expression *const r147F = neg(r1472);
         body.emit(assign(r147C, expr(ir_unop_i2u, r147F), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f147D->else_instructions;

         body.emit(assign(r147C, expr(ir_unop_i2u, r1472), 0x01));


      body.instructions = f147D_parent_instructions;
      body.emit(f147D);

      /* END IF */

      ir_variable *const r1480 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1480, r147C, 0x01));

      ir_variable *const r1481 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1482 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1482);
      /* IF CONDITION */
      ir_expression *const r1484 = equal(r147C, body.constant(0u));
      ir_if *f1483 = new(mem_ctx) ir_if(operand(r1484).val);
      exec_list *const f1483_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1483->then_instructions;

         body.emit(assign(r1481, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1483->else_instructions;

         body.emit(assign(r1482, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1486 = bit_and(r147C, body.constant(4294901760u));
         ir_expression *const r1487 = equal(r1486, body.constant(0u));
         ir_if *f1485 = new(mem_ctx) ir_if(operand(r1487).val);
         exec_list *const f1485_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1485->then_instructions;

            body.emit(assign(r1482, body.constant(int(16)), 0x01));

            body.emit(assign(r1480, lshift(r147C, body.constant(int(16))), 0x01));


         body.instructions = f1485_parent_instructions;
         body.emit(f1485);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1489 = bit_and(r1480, body.constant(4278190080u));
         ir_expression *const r148A = equal(r1489, body.constant(0u));
         ir_if *f1488 = new(mem_ctx) ir_if(operand(r148A).val);
         exec_list *const f1488_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1488->then_instructions;

            body.emit(assign(r1482, add(r1482, body.constant(int(8))), 0x01));

            body.emit(assign(r1480, lshift(r1480, body.constant(int(8))), 0x01));


         body.instructions = f1488_parent_instructions;
         body.emit(f1488);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r148C = bit_and(r1480, body.constant(4026531840u));
         ir_expression *const r148D = equal(r148C, body.constant(0u));
         ir_if *f148B = new(mem_ctx) ir_if(operand(r148D).val);
         exec_list *const f148B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f148B->then_instructions;

            body.emit(assign(r1482, add(r1482, body.constant(int(4))), 0x01));

            body.emit(assign(r1480, lshift(r1480, body.constant(int(4))), 0x01));


         body.instructions = f148B_parent_instructions;
         body.emit(f148B);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r148F = bit_and(r1480, body.constant(3221225472u));
         ir_expression *const r1490 = equal(r148F, body.constant(0u));
         ir_if *f148E = new(mem_ctx) ir_if(operand(r1490).val);
         exec_list *const f148E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f148E->then_instructions;

            body.emit(assign(r1482, add(r1482, body.constant(int(2))), 0x01));

            body.emit(assign(r1480, lshift(r1480, body.constant(int(2))), 0x01));


         body.instructions = f148E_parent_instructions;
         body.emit(f148E);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1492 = bit_and(r1480, body.constant(2147483648u));
         ir_expression *const r1493 = equal(r1492, body.constant(0u));
         ir_if *f1491 = new(mem_ctx) ir_if(operand(r1493).val);
         exec_list *const f1491_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1491->then_instructions;

            body.emit(assign(r1482, add(r1482, body.constant(int(1))), 0x01));


         body.instructions = f1491_parent_instructions;
         body.emit(f1491);

         /* END IF */

         body.emit(assign(r1481, r1482, 0x01));


      body.instructions = f1483_parent_instructions;
      body.emit(f1483);

      /* END IF */

      ir_variable *const r1494 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r1494, add(r1481, body.constant(int(-11))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1496 = lequal(body.constant(int(0)), r1494);
      ir_if *f1495 = new(mem_ctx) ir_if(operand(r1496).val);
      exec_list *const f1495_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1495->then_instructions;

         body.emit(assign(r1476, lshift(r147C, r1494), 0x01));

         body.emit(assign(r1475, body.constant(0u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1495->else_instructions;

         ir_variable *const r1497 = body.make_temp(glsl_type::uint_type, "a1");
         body.emit(assign(r1497, body.constant(0u), 0x01));

         ir_variable *const r1498 = body.make_temp(glsl_type::int_type, "count");
         body.emit(assign(r1498, neg(r1494), 0x01));

         ir_variable *const r1499 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r1499);
         ir_variable *const r149A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r149A);
         ir_variable *const r149B = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r149C = neg(r1498);
         body.emit(assign(r149B, bit_and(r149C, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r149E = equal(r1498, body.constant(int(0)));
         ir_if *f149D = new(mem_ctx) ir_if(operand(r149E).val);
         exec_list *const f149D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f149D->then_instructions;

            body.emit(assign(r1499, body.constant(0u), 0x01));

            body.emit(assign(r149A, r147C, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f149D->else_instructions;

            /* IF CONDITION */
            ir_expression *const r14A0 = less(r1498, body.constant(int(32)));
            ir_if *f149F = new(mem_ctx) ir_if(operand(r14A0).val);
            exec_list *const f149F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f149F->then_instructions;

               ir_expression *const r14A1 = lshift(r147C, r149B);
               body.emit(assign(r1499, bit_or(r14A1, body.constant(0u)), 0x01));

               body.emit(assign(r149A, rshift(r147C, r1498), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f149F->else_instructions;

               ir_variable *const r14A2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r14A4 = less(r1498, body.constant(int(64)));
               ir_if *f14A3 = new(mem_ctx) ir_if(operand(r14A4).val);
               exec_list *const f14A3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f14A3->then_instructions;

                  ir_expression *const r14A5 = bit_and(r1498, body.constant(int(31)));
                  body.emit(assign(r14A2, rshift(r147C, r14A5), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f14A3->else_instructions;

                  body.emit(assign(r14A2, body.constant(0u), 0x01));


               body.instructions = f14A3_parent_instructions;
               body.emit(f14A3);

               /* END IF */

               body.emit(assign(r1499, r14A2, 0x01));

               body.emit(assign(r149A, body.constant(0u), 0x01));


            body.instructions = f149F_parent_instructions;
            body.emit(f149F);

            /* END IF */


         body.instructions = f149D_parent_instructions;
         body.emit(f149D);

         /* END IF */

         body.emit(assign(r1476, r149A, 0x01));

         body.emit(assign(r1475, r1499, 0x01));


      body.instructions = f1495_parent_instructions;
      body.emit(f1495);

      /* END IF */

      ir_variable *const r14A6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r14A6);
      ir_expression *const r14A7 = lshift(r1474, body.constant(int(31)));
      ir_expression *const r14A8 = sub(body.constant(int(1042)), r1494);
      ir_expression *const r14A9 = expr(ir_unop_i2u, r14A8);
      ir_expression *const r14AA = lshift(r14A9, body.constant(int(20)));
      ir_expression *const r14AB = add(r14A7, r14AA);
      body.emit(assign(r14A6, add(r14AB, r1476), 0x02));

      body.emit(assign(r14A6, r1475, 0x01));

      body.emit(assign(r1473, r14A6, 0x03));


   body.instructions = f1477_parent_instructions;
   body.emit(f1477);

   /* END IF */

   body.emit(ret(r1473));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sqrtOddAdjustments(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r14AC = new(mem_ctx) ir_variable(glsl_type::int_type, "index", ir_var_function_in);
   sig_parameters.push_tail(r14AC);
   ir_variable *const r14AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
   body.emit(r14AD);
   body.emit(assign(r14AD, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r14AF = equal(r14AC, body.constant(int(0)));
   ir_if *f14AE = new(mem_ctx) ir_if(operand(r14AF).val);
   exec_list *const f14AE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14AE->then_instructions;

      body.emit(assign(r14AD, body.constant(4u), 0x01));


   body.instructions = f14AE_parent_instructions;
   body.emit(f14AE);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14B1 = equal(r14AC, body.constant(int(1)));
   ir_if *f14B0 = new(mem_ctx) ir_if(operand(r14B1).val);
   exec_list *const f14B0_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14B0->then_instructions;

      body.emit(assign(r14AD, body.constant(34u), 0x01));


   body.instructions = f14B0_parent_instructions;
   body.emit(f14B0);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14B3 = equal(r14AC, body.constant(int(2)));
   ir_if *f14B2 = new(mem_ctx) ir_if(operand(r14B3).val);
   exec_list *const f14B2_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14B2->then_instructions;

      body.emit(assign(r14AD, body.constant(93u), 0x01));


   body.instructions = f14B2_parent_instructions;
   body.emit(f14B2);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14B5 = equal(r14AC, body.constant(int(3)));
   ir_if *f14B4 = new(mem_ctx) ir_if(operand(r14B5).val);
   exec_list *const f14B4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14B4->then_instructions;

      body.emit(assign(r14AD, body.constant(177u), 0x01));


   body.instructions = f14B4_parent_instructions;
   body.emit(f14B4);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14B7 = equal(r14AC, body.constant(int(4)));
   ir_if *f14B6 = new(mem_ctx) ir_if(operand(r14B7).val);
   exec_list *const f14B6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14B6->then_instructions;

      body.emit(assign(r14AD, body.constant(285u), 0x01));


   body.instructions = f14B6_parent_instructions;
   body.emit(f14B6);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14B9 = equal(r14AC, body.constant(int(5)));
   ir_if *f14B8 = new(mem_ctx) ir_if(operand(r14B9).val);
   exec_list *const f14B8_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14B8->then_instructions;

      body.emit(assign(r14AD, body.constant(415u), 0x01));


   body.instructions = f14B8_parent_instructions;
   body.emit(f14B8);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14BB = equal(r14AC, body.constant(int(6)));
   ir_if *f14BA = new(mem_ctx) ir_if(operand(r14BB).val);
   exec_list *const f14BA_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14BA->then_instructions;

      body.emit(assign(r14AD, body.constant(566u), 0x01));


   body.instructions = f14BA_parent_instructions;
   body.emit(f14BA);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14BD = equal(r14AC, body.constant(int(7)));
   ir_if *f14BC = new(mem_ctx) ir_if(operand(r14BD).val);
   exec_list *const f14BC_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14BC->then_instructions;

      body.emit(assign(r14AD, body.constant(736u), 0x01));


   body.instructions = f14BC_parent_instructions;
   body.emit(f14BC);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14BF = equal(r14AC, body.constant(int(8)));
   ir_if *f14BE = new(mem_ctx) ir_if(operand(r14BF).val);
   exec_list *const f14BE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14BE->then_instructions;

      body.emit(assign(r14AD, body.constant(924u), 0x01));


   body.instructions = f14BE_parent_instructions;
   body.emit(f14BE);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14C1 = equal(r14AC, body.constant(int(9)));
   ir_if *f14C0 = new(mem_ctx) ir_if(operand(r14C1).val);
   exec_list *const f14C0_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14C0->then_instructions;

      body.emit(assign(r14AD, body.constant(1128u), 0x01));


   body.instructions = f14C0_parent_instructions;
   body.emit(f14C0);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14C3 = equal(r14AC, body.constant(int(10)));
   ir_if *f14C2 = new(mem_ctx) ir_if(operand(r14C3).val);
   exec_list *const f14C2_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14C2->then_instructions;

      body.emit(assign(r14AD, body.constant(1349u), 0x01));


   body.instructions = f14C2_parent_instructions;
   body.emit(f14C2);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14C5 = equal(r14AC, body.constant(int(11)));
   ir_if *f14C4 = new(mem_ctx) ir_if(operand(r14C5).val);
   exec_list *const f14C4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14C4->then_instructions;

      body.emit(assign(r14AD, body.constant(1585u), 0x01));


   body.instructions = f14C4_parent_instructions;
   body.emit(f14C4);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14C7 = equal(r14AC, body.constant(int(12)));
   ir_if *f14C6 = new(mem_ctx) ir_if(operand(r14C7).val);
   exec_list *const f14C6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14C6->then_instructions;

      body.emit(assign(r14AD, body.constant(1835u), 0x01));


   body.instructions = f14C6_parent_instructions;
   body.emit(f14C6);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14C9 = equal(r14AC, body.constant(int(13)));
   ir_if *f14C8 = new(mem_ctx) ir_if(operand(r14C9).val);
   exec_list *const f14C8_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14C8->then_instructions;

      body.emit(assign(r14AD, body.constant(2098u), 0x01));


   body.instructions = f14C8_parent_instructions;
   body.emit(f14C8);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14CB = equal(r14AC, body.constant(int(14)));
   ir_if *f14CA = new(mem_ctx) ir_if(operand(r14CB).val);
   exec_list *const f14CA_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14CA->then_instructions;

      body.emit(assign(r14AD, body.constant(2374u), 0x01));


   body.instructions = f14CA_parent_instructions;
   body.emit(f14CA);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14CD = equal(r14AC, body.constant(int(15)));
   ir_if *f14CC = new(mem_ctx) ir_if(operand(r14CD).val);
   exec_list *const f14CC_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14CC->then_instructions;

      body.emit(assign(r14AD, body.constant(2663u), 0x01));


   body.instructions = f14CC_parent_instructions;
   body.emit(f14CC);

   /* END IF */

   body.emit(ret(r14AD));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sqrtEvenAdjustments(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r14CE = new(mem_ctx) ir_variable(glsl_type::int_type, "index", ir_var_function_in);
   sig_parameters.push_tail(r14CE);
   ir_variable *const r14CF = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
   body.emit(r14CF);
   body.emit(assign(r14CF, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r14D1 = equal(r14CE, body.constant(int(0)));
   ir_if *f14D0 = new(mem_ctx) ir_if(operand(r14D1).val);
   exec_list *const f14D0_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14D0->then_instructions;

      body.emit(assign(r14CF, body.constant(2605u), 0x01));


   body.instructions = f14D0_parent_instructions;
   body.emit(f14D0);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14D3 = equal(r14CE, body.constant(int(1)));
   ir_if *f14D2 = new(mem_ctx) ir_if(operand(r14D3).val);
   exec_list *const f14D2_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14D2->then_instructions;

      body.emit(assign(r14CF, body.constant(2223u), 0x01));


   body.instructions = f14D2_parent_instructions;
   body.emit(f14D2);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14D5 = equal(r14CE, body.constant(int(2)));
   ir_if *f14D4 = new(mem_ctx) ir_if(operand(r14D5).val);
   exec_list *const f14D4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14D4->then_instructions;

      body.emit(assign(r14CF, body.constant(1882u), 0x01));


   body.instructions = f14D4_parent_instructions;
   body.emit(f14D4);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14D7 = equal(r14CE, body.constant(int(3)));
   ir_if *f14D6 = new(mem_ctx) ir_if(operand(r14D7).val);
   exec_list *const f14D6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14D6->then_instructions;

      body.emit(assign(r14CF, body.constant(1577u), 0x01));


   body.instructions = f14D6_parent_instructions;
   body.emit(f14D6);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14D9 = equal(r14CE, body.constant(int(4)));
   ir_if *f14D8 = new(mem_ctx) ir_if(operand(r14D9).val);
   exec_list *const f14D8_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14D8->then_instructions;

      body.emit(assign(r14CF, body.constant(1306u), 0x01));


   body.instructions = f14D8_parent_instructions;
   body.emit(f14D8);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14DB = equal(r14CE, body.constant(int(5)));
   ir_if *f14DA = new(mem_ctx) ir_if(operand(r14DB).val);
   exec_list *const f14DA_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14DA->then_instructions;

      body.emit(assign(r14CF, body.constant(1065u), 0x01));


   body.instructions = f14DA_parent_instructions;
   body.emit(f14DA);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14DD = equal(r14CE, body.constant(int(6)));
   ir_if *f14DC = new(mem_ctx) ir_if(operand(r14DD).val);
   exec_list *const f14DC_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14DC->then_instructions;

      body.emit(assign(r14CF, body.constant(854u), 0x01));


   body.instructions = f14DC_parent_instructions;
   body.emit(f14DC);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14DF = equal(r14CE, body.constant(int(7)));
   ir_if *f14DE = new(mem_ctx) ir_if(operand(r14DF).val);
   exec_list *const f14DE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14DE->then_instructions;

      body.emit(assign(r14CF, body.constant(670u), 0x01));


   body.instructions = f14DE_parent_instructions;
   body.emit(f14DE);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14E1 = equal(r14CE, body.constant(int(8)));
   ir_if *f14E0 = new(mem_ctx) ir_if(operand(r14E1).val);
   exec_list *const f14E0_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14E0->then_instructions;

      body.emit(assign(r14CF, body.constant(512u), 0x01));


   body.instructions = f14E0_parent_instructions;
   body.emit(f14E0);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14E3 = equal(r14CE, body.constant(int(9)));
   ir_if *f14E2 = new(mem_ctx) ir_if(operand(r14E3).val);
   exec_list *const f14E2_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14E2->then_instructions;

      body.emit(assign(r14CF, body.constant(377u), 0x01));


   body.instructions = f14E2_parent_instructions;
   body.emit(f14E2);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14E5 = equal(r14CE, body.constant(int(10)));
   ir_if *f14E4 = new(mem_ctx) ir_if(operand(r14E5).val);
   exec_list *const f14E4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14E4->then_instructions;

      body.emit(assign(r14CF, body.constant(265u), 0x01));


   body.instructions = f14E4_parent_instructions;
   body.emit(f14E4);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14E7 = equal(r14CE, body.constant(int(11)));
   ir_if *f14E6 = new(mem_ctx) ir_if(operand(r14E7).val);
   exec_list *const f14E6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14E6->then_instructions;

      body.emit(assign(r14CF, body.constant(175u), 0x01));


   body.instructions = f14E6_parent_instructions;
   body.emit(f14E6);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14E9 = equal(r14CE, body.constant(int(12)));
   ir_if *f14E8 = new(mem_ctx) ir_if(operand(r14E9).val);
   exec_list *const f14E8_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14E8->then_instructions;

      body.emit(assign(r14CF, body.constant(104u), 0x01));


   body.instructions = f14E8_parent_instructions;
   body.emit(f14E8);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14EB = equal(r14CE, body.constant(int(13)));
   ir_if *f14EA = new(mem_ctx) ir_if(operand(r14EB).val);
   exec_list *const f14EA_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14EA->then_instructions;

      body.emit(assign(r14CF, body.constant(52u), 0x01));


   body.instructions = f14EA_parent_instructions;
   body.emit(f14EA);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14ED = equal(r14CE, body.constant(int(14)));
   ir_if *f14EC = new(mem_ctx) ir_if(operand(r14ED).val);
   exec_list *const f14EC_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14EC->then_instructions;

      body.emit(assign(r14CF, body.constant(18u), 0x01));


   body.instructions = f14EC_parent_instructions;
   body.emit(f14EC);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r14EF = equal(r14CE, body.constant(int(15)));
   ir_if *f14EE = new(mem_ctx) ir_if(operand(r14EF).val);
   exec_list *const f14EE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14EE->then_instructions;

      body.emit(assign(r14CF, body.constant(2u), 0x01));


   body.instructions = f14EE_parent_instructions;
   body.emit(f14EE);

   /* END IF */

   body.emit(ret(r14CF));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
estimateSqrt32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r14F0 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_function_in);
   sig_parameters.push_tail(r14F0);
   ir_variable *const r14F1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r14F1);
   ir_variable *const r14F2 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r14F2, body.constant(true), 0x01));

   ir_variable *const r14F3 = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r14F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r14F4);
   ir_variable *const r14F5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r14F6 = rshift(r14F1, body.constant(int(27)));
   ir_expression *const r14F7 = bit_and(r14F6, body.constant(15u));
   body.emit(assign(r14F5, expr(ir_unop_u2i, r14F7), 0x01));

   /* IF CONDITION */
   ir_expression *const r14F9 = bit_and(r14F0, body.constant(int(1)));
   ir_expression *const r14FA = nequal(r14F9, body.constant(int(0)));
   ir_if *f14F8 = new(mem_ctx) ir_if(operand(r14FA).val);
   exec_list *const f14F8_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f14F8->then_instructions;

      ir_variable *const r14FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
      body.emit(r14FB);
      body.emit(assign(r14FB, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r14FD = equal(r14F5, body.constant(int(0)));
      ir_if *f14FC = new(mem_ctx) ir_if(operand(r14FD).val);
      exec_list *const f14FC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f14FC->then_instructions;

         body.emit(assign(r14FB, body.constant(4u), 0x01));


      body.instructions = f14FC_parent_instructions;
      body.emit(f14FC);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r14FF = equal(r14F5, body.constant(int(1)));
      ir_if *f14FE = new(mem_ctx) ir_if(operand(r14FF).val);
      exec_list *const f14FE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f14FE->then_instructions;

         body.emit(assign(r14FB, body.constant(34u), 0x01));


      body.instructions = f14FE_parent_instructions;
      body.emit(f14FE);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1501 = equal(r14F5, body.constant(int(2)));
      ir_if *f1500 = new(mem_ctx) ir_if(operand(r1501).val);
      exec_list *const f1500_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1500->then_instructions;

         body.emit(assign(r14FB, body.constant(93u), 0x01));


      body.instructions = f1500_parent_instructions;
      body.emit(f1500);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1503 = equal(r14F5, body.constant(int(3)));
      ir_if *f1502 = new(mem_ctx) ir_if(operand(r1503).val);
      exec_list *const f1502_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1502->then_instructions;

         body.emit(assign(r14FB, body.constant(177u), 0x01));


      body.instructions = f1502_parent_instructions;
      body.emit(f1502);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1505 = equal(r14F5, body.constant(int(4)));
      ir_if *f1504 = new(mem_ctx) ir_if(operand(r1505).val);
      exec_list *const f1504_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1504->then_instructions;

         body.emit(assign(r14FB, body.constant(285u), 0x01));


      body.instructions = f1504_parent_instructions;
      body.emit(f1504);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1507 = equal(r14F5, body.constant(int(5)));
      ir_if *f1506 = new(mem_ctx) ir_if(operand(r1507).val);
      exec_list *const f1506_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1506->then_instructions;

         body.emit(assign(r14FB, body.constant(415u), 0x01));


      body.instructions = f1506_parent_instructions;
      body.emit(f1506);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1509 = equal(r14F5, body.constant(int(6)));
      ir_if *f1508 = new(mem_ctx) ir_if(operand(r1509).val);
      exec_list *const f1508_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1508->then_instructions;

         body.emit(assign(r14FB, body.constant(566u), 0x01));


      body.instructions = f1508_parent_instructions;
      body.emit(f1508);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r150B = equal(r14F5, body.constant(int(7)));
      ir_if *f150A = new(mem_ctx) ir_if(operand(r150B).val);
      exec_list *const f150A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f150A->then_instructions;

         body.emit(assign(r14FB, body.constant(736u), 0x01));


      body.instructions = f150A_parent_instructions;
      body.emit(f150A);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r150D = equal(r14F5, body.constant(int(8)));
      ir_if *f150C = new(mem_ctx) ir_if(operand(r150D).val);
      exec_list *const f150C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f150C->then_instructions;

         body.emit(assign(r14FB, body.constant(924u), 0x01));


      body.instructions = f150C_parent_instructions;
      body.emit(f150C);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r150F = equal(r14F5, body.constant(int(9)));
      ir_if *f150E = new(mem_ctx) ir_if(operand(r150F).val);
      exec_list *const f150E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f150E->then_instructions;

         body.emit(assign(r14FB, body.constant(1128u), 0x01));


      body.instructions = f150E_parent_instructions;
      body.emit(f150E);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1511 = equal(r14F5, body.constant(int(10)));
      ir_if *f1510 = new(mem_ctx) ir_if(operand(r1511).val);
      exec_list *const f1510_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1510->then_instructions;

         body.emit(assign(r14FB, body.constant(1349u), 0x01));


      body.instructions = f1510_parent_instructions;
      body.emit(f1510);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1513 = equal(r14F5, body.constant(int(11)));
      ir_if *f1512 = new(mem_ctx) ir_if(operand(r1513).val);
      exec_list *const f1512_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1512->then_instructions;

         body.emit(assign(r14FB, body.constant(1585u), 0x01));


      body.instructions = f1512_parent_instructions;
      body.emit(f1512);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1515 = equal(r14F5, body.constant(int(12)));
      ir_if *f1514 = new(mem_ctx) ir_if(operand(r1515).val);
      exec_list *const f1514_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1514->then_instructions;

         body.emit(assign(r14FB, body.constant(1835u), 0x01));


      body.instructions = f1514_parent_instructions;
      body.emit(f1514);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1517 = equal(r14F5, body.constant(int(13)));
      ir_if *f1516 = new(mem_ctx) ir_if(operand(r1517).val);
      exec_list *const f1516_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1516->then_instructions;

         body.emit(assign(r14FB, body.constant(2098u), 0x01));


      body.instructions = f1516_parent_instructions;
      body.emit(f1516);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1519 = equal(r14F5, body.constant(int(14)));
      ir_if *f1518 = new(mem_ctx) ir_if(operand(r1519).val);
      exec_list *const f1518_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1518->then_instructions;

         body.emit(assign(r14FB, body.constant(2374u), 0x01));


      body.instructions = f1518_parent_instructions;
      body.emit(f1518);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r151B = equal(r14F5, body.constant(int(15)));
      ir_if *f151A = new(mem_ctx) ir_if(operand(r151B).val);
      exec_list *const f151A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f151A->then_instructions;

         body.emit(assign(r14FB, body.constant(2663u), 0x01));


      body.instructions = f151A_parent_instructions;
      body.emit(f151A);

      /* END IF */

      ir_expression *const r151C = rshift(r14F1, body.constant(int(17)));
      ir_expression *const r151D = add(body.constant(16384u), r151C);
      body.emit(assign(r14F4, sub(r151D, r14FB), 0x01));

      ir_expression *const r151E = expr(ir_binop_div, r14F1, r14F4);
      ir_expression *const r151F = lshift(r151E, body.constant(int(14)));
      ir_expression *const r1520 = lshift(r14F4, body.constant(int(15)));
      body.emit(assign(r14F4, add(r151F, r1520), 0x01));

      body.emit(assign(r14F1, rshift(r14F1, body.constant(int(1))), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f14F8->else_instructions;

      ir_variable *const r1521 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
      body.emit(r1521);
      body.emit(assign(r1521, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1523 = equal(r14F5, body.constant(int(0)));
      ir_if *f1522 = new(mem_ctx) ir_if(operand(r1523).val);
      exec_list *const f1522_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1522->then_instructions;

         body.emit(assign(r1521, body.constant(2605u), 0x01));


      body.instructions = f1522_parent_instructions;
      body.emit(f1522);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1525 = equal(r14F5, body.constant(int(1)));
      ir_if *f1524 = new(mem_ctx) ir_if(operand(r1525).val);
      exec_list *const f1524_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1524->then_instructions;

         body.emit(assign(r1521, body.constant(2223u), 0x01));


      body.instructions = f1524_parent_instructions;
      body.emit(f1524);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1527 = equal(r14F5, body.constant(int(2)));
      ir_if *f1526 = new(mem_ctx) ir_if(operand(r1527).val);
      exec_list *const f1526_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1526->then_instructions;

         body.emit(assign(r1521, body.constant(1882u), 0x01));


      body.instructions = f1526_parent_instructions;
      body.emit(f1526);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1529 = equal(r14F5, body.constant(int(3)));
      ir_if *f1528 = new(mem_ctx) ir_if(operand(r1529).val);
      exec_list *const f1528_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1528->then_instructions;

         body.emit(assign(r1521, body.constant(1577u), 0x01));


      body.instructions = f1528_parent_instructions;
      body.emit(f1528);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r152B = equal(r14F5, body.constant(int(4)));
      ir_if *f152A = new(mem_ctx) ir_if(operand(r152B).val);
      exec_list *const f152A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f152A->then_instructions;

         body.emit(assign(r1521, body.constant(1306u), 0x01));


      body.instructions = f152A_parent_instructions;
      body.emit(f152A);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r152D = equal(r14F5, body.constant(int(5)));
      ir_if *f152C = new(mem_ctx) ir_if(operand(r152D).val);
      exec_list *const f152C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f152C->then_instructions;

         body.emit(assign(r1521, body.constant(1065u), 0x01));


      body.instructions = f152C_parent_instructions;
      body.emit(f152C);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r152F = equal(r14F5, body.constant(int(6)));
      ir_if *f152E = new(mem_ctx) ir_if(operand(r152F).val);
      exec_list *const f152E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f152E->then_instructions;

         body.emit(assign(r1521, body.constant(854u), 0x01));


      body.instructions = f152E_parent_instructions;
      body.emit(f152E);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1531 = equal(r14F5, body.constant(int(7)));
      ir_if *f1530 = new(mem_ctx) ir_if(operand(r1531).val);
      exec_list *const f1530_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1530->then_instructions;

         body.emit(assign(r1521, body.constant(670u), 0x01));


      body.instructions = f1530_parent_instructions;
      body.emit(f1530);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1533 = equal(r14F5, body.constant(int(8)));
      ir_if *f1532 = new(mem_ctx) ir_if(operand(r1533).val);
      exec_list *const f1532_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1532->then_instructions;

         body.emit(assign(r1521, body.constant(512u), 0x01));


      body.instructions = f1532_parent_instructions;
      body.emit(f1532);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1535 = equal(r14F5, body.constant(int(9)));
      ir_if *f1534 = new(mem_ctx) ir_if(operand(r1535).val);
      exec_list *const f1534_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1534->then_instructions;

         body.emit(assign(r1521, body.constant(377u), 0x01));


      body.instructions = f1534_parent_instructions;
      body.emit(f1534);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1537 = equal(r14F5, body.constant(int(10)));
      ir_if *f1536 = new(mem_ctx) ir_if(operand(r1537).val);
      exec_list *const f1536_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1536->then_instructions;

         body.emit(assign(r1521, body.constant(265u), 0x01));


      body.instructions = f1536_parent_instructions;
      body.emit(f1536);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1539 = equal(r14F5, body.constant(int(11)));
      ir_if *f1538 = new(mem_ctx) ir_if(operand(r1539).val);
      exec_list *const f1538_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1538->then_instructions;

         body.emit(assign(r1521, body.constant(175u), 0x01));


      body.instructions = f1538_parent_instructions;
      body.emit(f1538);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r153B = equal(r14F5, body.constant(int(12)));
      ir_if *f153A = new(mem_ctx) ir_if(operand(r153B).val);
      exec_list *const f153A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f153A->then_instructions;

         body.emit(assign(r1521, body.constant(104u), 0x01));


      body.instructions = f153A_parent_instructions;
      body.emit(f153A);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r153D = equal(r14F5, body.constant(int(13)));
      ir_if *f153C = new(mem_ctx) ir_if(operand(r153D).val);
      exec_list *const f153C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f153C->then_instructions;

         body.emit(assign(r1521, body.constant(52u), 0x01));


      body.instructions = f153C_parent_instructions;
      body.emit(f153C);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r153F = equal(r14F5, body.constant(int(14)));
      ir_if *f153E = new(mem_ctx) ir_if(operand(r153F).val);
      exec_list *const f153E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f153E->then_instructions;

         body.emit(assign(r1521, body.constant(18u), 0x01));


      body.instructions = f153E_parent_instructions;
      body.emit(f153E);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1541 = equal(r14F5, body.constant(int(15)));
      ir_if *f1540 = new(mem_ctx) ir_if(operand(r1541).val);
      exec_list *const f1540_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1540->then_instructions;

         body.emit(assign(r1521, body.constant(2u), 0x01));


      body.instructions = f1540_parent_instructions;
      body.emit(f1540);

      /* END IF */

      ir_expression *const r1542 = rshift(r14F1, body.constant(int(17)));
      ir_expression *const r1543 = add(body.constant(32768u), r1542);
      body.emit(assign(r14F4, sub(r1543, r1521), 0x01));

      ir_expression *const r1544 = expr(ir_binop_div, r14F1, r14F4);
      body.emit(assign(r14F4, add(r1544, r14F4), 0x01));

      ir_variable *const r1545 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1547 = lequal(body.constant(131072u), r14F4);
      ir_if *f1546 = new(mem_ctx) ir_if(operand(r1547).val);
      exec_list *const f1546_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1546->then_instructions;

         body.emit(assign(r1545, body.constant(4294934528u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1546->else_instructions;

         body.emit(assign(r1545, lshift(r14F4, body.constant(int(15))), 0x01));


      body.instructions = f1546_parent_instructions;
      body.emit(f1546);

      /* END IF */

      body.emit(assign(r14F4, r1545, 0x01));

      /* IF CONDITION */
      ir_expression *const r1549 = lequal(r1545, r14F1);
      ir_if *f1548 = new(mem_ctx) ir_if(operand(r1549).val);
      exec_list *const f1548_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1548->then_instructions;

         ir_expression *const r154A = expr(ir_unop_u2i, r14F1);
         ir_expression *const r154B = rshift(r154A, body.constant(int(1)));
         body.emit(assign(r14F3, expr(ir_unop_i2u, r154B), 0x01));

         body.emit(assign(r14F2, body.constant(false), 0x01));


      body.instructions = f1548_parent_instructions;
      body.emit(f1548);

      /* END IF */


   body.instructions = f14F8_parent_instructions;
   body.emit(f14F8);

   /* END IF */

   /* IF CONDITION */
   ir_if *f154C = new(mem_ctx) ir_if(operand(r14F2).val);
   exec_list *const f154C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f154C->then_instructions;

      ir_variable *const r154D = body.make_temp(glsl_type::uint_type, "return_value");
      ir_variable *const r154E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
      body.emit(r154E);
      ir_variable *const r154F = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
      body.emit(r154F);
      ir_variable *const r1550 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
      body.emit(r1550);
      ir_variable *const r1551 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
      body.emit(r1551);
      body.emit(assign(r1550, body.constant(0u), 0x01));

      body.emit(assign(r154F, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1553 = lequal(r14F4, r14F1);
      ir_if *f1552 = new(mem_ctx) ir_if(operand(r1553).val);
      exec_list *const f1552_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1552->then_instructions;

         body.emit(assign(r154D, body.constant(4294967295u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1552->else_instructions;

         body.emit(assign(r1551, rshift(r14F4, body.constant(int(16))), 0x01));

         ir_variable *const r1554 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1556 = lshift(r1551, body.constant(int(16)));
         ir_expression *const r1557 = lequal(r1556, r14F1);
         ir_if *f1555 = new(mem_ctx) ir_if(operand(r1557).val);
         exec_list *const f1555_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1555->then_instructions;

            body.emit(assign(r1554, body.constant(4294901760u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1555->else_instructions;

            ir_expression *const r1558 = expr(ir_binop_div, r14F1, r1551);
            body.emit(assign(r1554, lshift(r1558, body.constant(int(16))), 0x01));


         body.instructions = f1555_parent_instructions;
         body.emit(f1555);

         /* END IF */

         body.emit(assign(r154E, r1554, 0x01));

         ir_variable *const r1559 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r1559);
         ir_variable *const r155A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
         body.emit(r155A);
         ir_variable *const r155B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r155B);
         ir_variable *const r155C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r155C, bit_and(r14F4, body.constant(65535u)), 0x01));

         ir_variable *const r155D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r155D, rshift(r14F4, body.constant(int(16))), 0x01));

         ir_variable *const r155E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r155E, bit_and(r1554, body.constant(65535u)), 0x01));

         ir_variable *const r155F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r155F, rshift(r1554, body.constant(int(16))), 0x01));

         ir_variable *const r1560 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1560, mul(r155D, r155E), 0x01));

         ir_expression *const r1561 = mul(r155C, r155F);
         body.emit(assign(r155A, add(r1561, r1560), 0x01));

         ir_expression *const r1562 = mul(r155D, r155F);
         ir_expression *const r1563 = less(r155A, r1560);
         ir_expression *const r1564 = expr(ir_unop_b2i, r1563);
         ir_expression *const r1565 = expr(ir_unop_i2u, r1564);
         ir_expression *const r1566 = lshift(r1565, body.constant(int(16)));
         ir_expression *const r1567 = rshift(r155A, body.constant(int(16)));
         ir_expression *const r1568 = add(r1566, r1567);
         body.emit(assign(r1559, add(r1562, r1568), 0x01));

         body.emit(assign(r155A, lshift(r155A, body.constant(int(16))), 0x01));

         ir_expression *const r1569 = mul(r155C, r155E);
         body.emit(assign(r155B, add(r1569, r155A), 0x01));

         ir_expression *const r156A = less(r155B, r155A);
         ir_expression *const r156B = expr(ir_unop_b2i, r156A);
         ir_expression *const r156C = expr(ir_unop_i2u, r156B);
         body.emit(assign(r1559, add(r1559, r156C), 0x01));

         ir_expression *const r156D = sub(r14F1, r1559);
         ir_expression *const r156E = less(body.constant(0u), r155B);
         ir_expression *const r156F = expr(ir_unop_b2i, r156E);
         ir_expression *const r1570 = expr(ir_unop_i2u, r156F);
         body.emit(assign(r1550, sub(r156D, r1570), 0x01));

         body.emit(assign(r154F, neg(r155B), 0x01));

         /* LOOP BEGIN */
         ir_loop *f1571 = new(mem_ctx) ir_loop();
         exec_list *const f1571_parent_instructions = body.instructions;

            body.instructions = &f1571->body_instructions;

            /* IF CONDITION */
            ir_expression *const r1573 = expr(ir_unop_u2i, r1550);
            ir_expression *const r1574 = gequal(r1573, body.constant(int(0)));
            ir_if *f1572 = new(mem_ctx) ir_if(operand(r1574).val);
            exec_list *const f1572_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1572->then_instructions;

               body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


            body.instructions = f1572_parent_instructions;
            body.emit(f1572);

            /* END IF */

            body.emit(assign(r154E, add(r154E, body.constant(4294901760u)), 0x01));

            ir_variable *const r1575 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            ir_expression *const r1576 = lshift(r14F4, body.constant(int(16)));
            body.emit(assign(r1575, add(r154F, r1576), 0x01));

            ir_expression *const r1577 = add(r1550, r1551);
            ir_expression *const r1578 = less(r1575, r154F);
            ir_expression *const r1579 = expr(ir_unop_b2i, r1578);
            ir_expression *const r157A = expr(ir_unop_i2u, r1579);
            body.emit(assign(r1550, add(r1577, r157A), 0x01));

            body.emit(assign(r154F, r1575, 0x01));

         /* LOOP END */

         body.instructions = f1571_parent_instructions;
         body.emit(f1571);

         ir_expression *const r157B = lshift(r1550, body.constant(int(16)));
         ir_expression *const r157C = rshift(r154F, body.constant(int(16)));
         body.emit(assign(r1550, bit_or(r157B, r157C), 0x01));

         ir_variable *const r157D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r157F = lshift(r1551, body.constant(int(16)));
         ir_expression *const r1580 = lequal(r157F, r1550);
         ir_if *f157E = new(mem_ctx) ir_if(operand(r1580).val);
         exec_list *const f157E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f157E->then_instructions;

            body.emit(assign(r157D, body.constant(65535u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f157E->else_instructions;

            body.emit(assign(r157D, expr(ir_binop_div, r1550, r1551), 0x01));


         body.instructions = f157E_parent_instructions;
         body.emit(f157E);

         /* END IF */

         body.emit(assign(r154E, bit_or(r154E, r157D), 0x01));

         body.emit(assign(r154D, r154E, 0x01));


      body.instructions = f1552_parent_instructions;
      body.emit(f1552);

      /* END IF */

      ir_expression *const r1581 = rshift(r154D, body.constant(int(1)));
      ir_expression *const r1582 = rshift(r14F4, body.constant(int(1)));
      body.emit(assign(r14F3, add(r1581, r1582), 0x01));

      body.emit(assign(r14F2, body.constant(false), 0x01));


   body.instructions = f154C_parent_instructions;
   body.emit(f154C);

   /* END IF */

   body.emit(ret(r14F3));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fsqrt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1583 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1583);
   ir_variable *const r1584 = body.make_temp(glsl_type::float_type, "return_value");
   ir_variable *const r1585 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_auto);
   body.emit(r1585);
   body.emit(assign(r1585, body.constant(0u), 0x01));

   ir_variable *const r1586 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1586, bit_and(swizzle_y(r1583), body.constant(1048575u)), 0x01));

   ir_variable *const r1587 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1588 = rshift(swizzle_y(r1583), body.constant(int(20)));
   ir_expression *const r1589 = bit_and(r1588, body.constant(2047u));
   body.emit(assign(r1587, expr(ir_unop_u2i, r1589), 0x01));

   ir_variable *const r158A = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r158A, rshift(swizzle_y(r1583), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r158C = equal(r1587, body.constant(int(2047)));
   ir_if *f158B = new(mem_ctx) ir_if(operand(r158C).val);
   exec_list *const f158B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f158B->then_instructions;

      /* IF CONDITION */
      ir_expression *const r158E = bit_or(r1586, swizzle_x(r1583));
      ir_expression *const r158F = nequal(r158E, body.constant(0u));
      ir_if *f158D = new(mem_ctx) ir_if(operand(r158F).val);
      exec_list *const f158D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f158D->then_instructions;

         ir_variable *const r1590 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1590, lshift(swizzle_x(r1583), body.constant(int(12))), 0x01));

         ir_expression *const r1591 = lshift(r158A, body.constant(int(31)));
         ir_expression *const r1592 = bit_or(r1591, body.constant(2143289344u));
         ir_expression *const r1593 = lshift(swizzle_y(r1583), body.constant(int(12)));
         ir_expression *const r1594 = rshift(swizzle_x(r1583), body.constant(int(20)));
         ir_expression *const r1595 = bit_or(r1593, r1594);
         ir_expression *const r1596 = rshift(r1595, body.constant(int(9)));
         ir_expression *const r1597 = bit_or(r1592, r1596);
         body.emit(assign(r1584, expr(ir_unop_bitcast_u2f, r1597), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f158D->else_instructions;

         ir_expression *const r1598 = lshift(r158A, body.constant(int(31)));
         ir_expression *const r1599 = add(r1598, body.constant(2139095040u));
         body.emit(assign(r1584, expr(ir_unop_bitcast_u2f, r1599), 0x01));


      body.instructions = f158D_parent_instructions;
      body.emit(f158D);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f158B->else_instructions;

      ir_variable *const r159A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r159A);
      ir_variable *const r159B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r159B);
      ir_expression *const r159C = lshift(r1586, body.constant(int(10)));
      ir_expression *const r159D = rshift(swizzle_x(r1583), body.constant(int(22)));
      ir_expression *const r159E = bit_or(r159C, r159D);
      ir_expression *const r159F = lshift(swizzle_x(r1583), body.constant(int(10)));
      ir_expression *const r15A0 = nequal(r159F, body.constant(0u));
      ir_expression *const r15A1 = expr(ir_unop_b2i, r15A0);
      ir_expression *const r15A2 = expr(ir_unop_i2u, r15A1);
      body.emit(assign(r159A, bit_or(r159E, r15A2), 0x01));

      body.emit(assign(r159B, rshift(r1586, body.constant(int(22))), 0x01));

      body.emit(assign(r1585, r159A, 0x01));

      /* IF CONDITION */
      ir_expression *const r15A4 = nequal(r1587, body.constant(int(0)));
      ir_if *f15A3 = new(mem_ctx) ir_if(operand(r15A4).val);
      exec_list *const f15A3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f15A3->then_instructions;

         body.emit(assign(r1585, bit_or(r159A, body.constant(1073741824u)), 0x01));


      body.instructions = f15A3_parent_instructions;
      body.emit(f15A3);

      /* END IF */

      ir_variable *const r15A5 = body.make_temp(glsl_type::int_type, "zExp");
      body.emit(assign(r15A5, add(r1587, body.constant(int(-897))), 0x01));

      ir_variable *const r15A6 = body.make_temp(glsl_type::uint_type, "zFrac");
      body.emit(assign(r15A6, r1585, 0x01));

      ir_variable *const r15A7 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r15A7, body.constant(true), 0x01));

      ir_variable *const r15A8 = body.make_temp(glsl_type::float_type, "return_value");
      ir_variable *const r15A9 = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
      body.emit(r15A9);
      ir_expression *const r15AA = bit_and(r1585, body.constant(127u));
      body.emit(assign(r15A9, expr(ir_unop_u2i, r15AA), 0x01));

      /* IF CONDITION */
      ir_expression *const r15AC = expr(ir_unop_i2u, r15A5);
      ir_expression *const r15AD = lequal(body.constant(253u), r15AC);
      ir_if *f15AB = new(mem_ctx) ir_if(operand(r15AD).val);
      exec_list *const f15AB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f15AB->then_instructions;

         /* IF CONDITION */
         ir_expression *const r15AF = less(body.constant(int(253)), r15A5);
         ir_expression *const r15B0 = equal(r15A5, body.constant(int(253)));
         ir_expression *const r15B1 = expr(ir_unop_u2i, r1585);
         ir_expression *const r15B2 = less(r15B1, body.constant(int(-64)));
         ir_expression *const r15B3 = logic_and(r15B0, r15B2);
         ir_expression *const r15B4 = logic_or(r15AF, r15B3);
         ir_if *f15AE = new(mem_ctx) ir_if(operand(r15B4).val);
         exec_list *const f15AE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f15AE->then_instructions;

            ir_expression *const r15B5 = lshift(r158A, body.constant(int(31)));
            ir_expression *const r15B6 = add(r15B5, body.constant(2139095040u));
            body.emit(assign(r15A8, expr(ir_unop_bitcast_u2f, r15B6), 0x01));

            body.emit(assign(r15A7, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f15AE->else_instructions;

            /* IF CONDITION */
            ir_expression *const r15B8 = less(r15A5, body.constant(int(0)));
            ir_if *f15B7 = new(mem_ctx) ir_if(operand(r15B8).val);
            exec_list *const f15B7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f15B7->then_instructions;

               ir_variable *const r15B9 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r15B9, neg(r15A5), 0x01));

               ir_variable *const r15BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r15BA);
               /* IF CONDITION */
               ir_expression *const r15BC = equal(r15B9, body.constant(int(0)));
               ir_if *f15BB = new(mem_ctx) ir_if(operand(r15BC).val);
               exec_list *const f15BB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15BB->then_instructions;

                  body.emit(assign(r15BA, r1585, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f15BB->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r15BE = less(r15B9, body.constant(int(32)));
                  ir_if *f15BD = new(mem_ctx) ir_if(operand(r15BE).val);
                  exec_list *const f15BD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15BD->then_instructions;

                     ir_expression *const r15BF = rshift(r1585, r15B9);
                     ir_expression *const r15C0 = neg(r15B9);
                     ir_expression *const r15C1 = bit_and(r15C0, body.constant(int(31)));
                     ir_expression *const r15C2 = lshift(r1585, r15C1);
                     ir_expression *const r15C3 = nequal(r15C2, body.constant(0u));
                     ir_expression *const r15C4 = expr(ir_unop_b2i, r15C3);
                     ir_expression *const r15C5 = expr(ir_unop_i2u, r15C4);
                     body.emit(assign(r15BA, bit_or(r15BF, r15C5), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15BD->else_instructions;

                     ir_expression *const r15C6 = nequal(r1585, body.constant(0u));
                     ir_expression *const r15C7 = expr(ir_unop_b2i, r15C6);
                     body.emit(assign(r15BA, expr(ir_unop_i2u, r15C7), 0x01));


                  body.instructions = f15BD_parent_instructions;
                  body.emit(f15BD);

                  /* END IF */


               body.instructions = f15BB_parent_instructions;
               body.emit(f15BB);

               /* END IF */

               body.emit(assign(r15A6, r15BA, 0x01));

               body.emit(assign(r15A5, body.constant(int(0)), 0x01));

               ir_expression *const r15C8 = expr(ir_unop_u2i, r15BA);
               body.emit(assign(r15A9, bit_and(r15C8, body.constant(int(127))), 0x01));


            body.instructions = f15B7_parent_instructions;
            body.emit(f15B7);

            /* END IF */


         body.instructions = f15AE_parent_instructions;
         body.emit(f15AE);

         /* END IF */


      body.instructions = f15AB_parent_instructions;
      body.emit(f15AB);

      /* END IF */

      /* IF CONDITION */
      ir_if *f15C9 = new(mem_ctx) ir_if(operand(r15A7).val);
      exec_list *const f15C9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f15C9->then_instructions;

         ir_expression *const r15CA = add(r15A6, body.constant(64u));
         body.emit(assign(r15A6, rshift(r15CA, body.constant(int(7))), 0x01));

         ir_expression *const r15CB = bit_xor(r15A9, body.constant(int(64)));
         ir_expression *const r15CC = equal(r15CB, body.constant(int(0)));
         ir_expression *const r15CD = expr(ir_unop_b2i, r15CC);
         ir_expression *const r15CE = expr(ir_unop_i2u, r15CD);
         ir_expression *const r15CF = expr(ir_unop_bit_not, r15CE);
         body.emit(assign(r15A6, bit_and(r15A6, r15CF), 0x01));

         /* IF CONDITION */
         ir_expression *const r15D1 = equal(r15A6, body.constant(0u));
         ir_if *f15D0 = new(mem_ctx) ir_if(operand(r15D1).val);
         exec_list *const f15D0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f15D0->then_instructions;

            body.emit(assign(r15A5, body.constant(int(0)), 0x01));


         body.instructions = f15D0_parent_instructions;
         body.emit(f15D0);

         /* END IF */

         ir_expression *const r15D2 = lshift(r158A, body.constant(int(31)));
         ir_expression *const r15D3 = expr(ir_unop_i2u, r15A5);
         ir_expression *const r15D4 = lshift(r15D3, body.constant(int(23)));
         ir_expression *const r15D5 = add(r15D2, r15D4);
         ir_expression *const r15D6 = add(r15D5, r15A6);
         body.emit(assign(r15A8, expr(ir_unop_bitcast_u2f, r15D6), 0x01));

         body.emit(assign(r15A7, body.constant(false), 0x01));


      body.instructions = f15C9_parent_instructions;
      body.emit(f15C9);

      /* END IF */

      body.emit(assign(r1584, r15A8, 0x01));


   body.instructions = f158B_parent_instructions;
   body.emit(f158B);

   /* END IF */

   ir_variable *const r15D7 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r15D7, body.constant(true), 0x01));

   ir_variable *const r15D8 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r15D9 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r15D9);
   ir_variable *const r15DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_auto);
   body.emit(r15DA);
   ir_variable *const r15DB = body.make_temp(glsl_type::uint_type, "floatBitsToUint_retval");
   ir_expression *const r15DC = expr(ir_unop_sqrt, r1584);
   body.emit(assign(r15DB, expr(ir_unop_bitcast_f2u, r15DC), 0x01));

   ir_variable *const r15DD = body.make_temp(glsl_type::uint_type, "extractFloat32Frac_retval");
   body.emit(assign(r15DD, bit_and(r15DB, body.constant(8388607u)), 0x01));

   body.emit(assign(r15DA, r15DD, 0x01));

   ir_variable *const r15DE = body.make_temp(glsl_type::int_type, "extractFloat32Exp_retval");
   ir_expression *const r15DF = rshift(r15DB, body.constant(int(23)));
   ir_expression *const r15E0 = bit_and(r15DF, body.constant(255u));
   body.emit(assign(r15DE, expr(ir_unop_u2i, r15E0), 0x01));

   body.emit(assign(r15D9, r15DE, 0x01));

   ir_variable *const r15E1 = body.make_temp(glsl_type::uint_type, "extractFloat32Sign_retval");
   body.emit(assign(r15E1, rshift(r15DB, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r15E3 = equal(r15DE, body.constant(int(255)));
   ir_if *f15E2 = new(mem_ctx) ir_if(operand(r15E3).val);
   exec_list *const f15E2_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f15E2->then_instructions;

      /* IF CONDITION */
      ir_expression *const r15E5 = nequal(r15DD, body.constant(0u));
      ir_if *f15E4 = new(mem_ctx) ir_if(operand(r15E5).val);
      exec_list *const f15E4_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f15E4->then_instructions;

         ir_variable *const r15E6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r15E6, lshift(r15DB, body.constant(int(9))), 0x01));

         ir_variable *const r15E7 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         ir_expression *const r15E8 = lshift(r15E6, body.constant(int(20)));
         body.emit(assign(r15E7, bit_or(r15E8, body.constant(0u)), 0x01));

         ir_expression *const r15E9 = rshift(r15E6, body.constant(int(12)));
         ir_expression *const r15EA = lshift(r15E1, body.constant(int(31)));
         ir_expression *const r15EB = bit_or(r15EA, body.constant(2146959360u));
         body.emit(assign(r15E7, bit_or(r15E9, r15EB), 0x02));

         body.emit(assign(r15D8, r15E7, 0x03));

         body.emit(assign(r15D7, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f15E4->else_instructions;

         ir_variable *const r15EC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r15EC);
         ir_expression *const r15ED = lshift(r15E1, body.constant(int(31)));
         body.emit(assign(r15EC, add(r15ED, body.constant(2146435072u)), 0x02));

         body.emit(assign(r15EC, body.constant(0u), 0x01));

         body.emit(assign(r15D8, r15EC, 0x03));

         body.emit(assign(r15D7, body.constant(false), 0x01));


      body.instructions = f15E4_parent_instructions;
      body.emit(f15E4);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f15E2->else_instructions;

      /* IF CONDITION */
      ir_expression *const r15EF = equal(r15DE, body.constant(int(0)));
      ir_if *f15EE = new(mem_ctx) ir_if(operand(r15EF).val);
      exec_list *const f15EE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f15EE->then_instructions;

         /* IF CONDITION */
         ir_expression *const r15F1 = equal(r15DD, body.constant(0u));
         ir_if *f15F0 = new(mem_ctx) ir_if(operand(r15F1).val);
         exec_list *const f15F0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f15F0->then_instructions;

            ir_variable *const r15F2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r15F2);
            body.emit(assign(r15F2, lshift(r15E1, body.constant(int(31))), 0x02));

            body.emit(assign(r15F2, body.constant(0u), 0x01));

            body.emit(assign(r15D8, r15F2, 0x03));

            body.emit(assign(r15D7, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f15F0->else_instructions;

            ir_variable *const r15F3 = body.make_temp(glsl_type::int_type, "zExpPtr");
            body.emit(assign(r15F3, r15DE, 0x01));

            ir_variable *const r15F4 = body.make_temp(glsl_type::uint_type, "zFracPtr");
            body.emit(assign(r15F4, r15DD, 0x01));

            ir_variable *const r15F5 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r15F5, r15DD, 0x01));

            ir_variable *const r15F6 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r15F7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r15F7);
            /* IF CONDITION */
            ir_expression *const r15F9 = equal(r15DD, body.constant(0u));
            ir_if *f15F8 = new(mem_ctx) ir_if(operand(r15F9).val);
            exec_list *const f15F8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f15F8->then_instructions;

               body.emit(assign(r15F6, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f15F8->else_instructions;

               body.emit(assign(r15F7, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r15FB = bit_and(r15DD, body.constant(4294901760u));
               ir_expression *const r15FC = equal(r15FB, body.constant(0u));
               ir_if *f15FA = new(mem_ctx) ir_if(operand(r15FC).val);
               exec_list *const f15FA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15FA->then_instructions;

                  body.emit(assign(r15F7, body.constant(int(16)), 0x01));

                  body.emit(assign(r15F5, lshift(r15DD, body.constant(int(16))), 0x01));


               body.instructions = f15FA_parent_instructions;
               body.emit(f15FA);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r15FE = bit_and(r15F5, body.constant(4278190080u));
               ir_expression *const r15FF = equal(r15FE, body.constant(0u));
               ir_if *f15FD = new(mem_ctx) ir_if(operand(r15FF).val);
               exec_list *const f15FD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15FD->then_instructions;

                  body.emit(assign(r15F7, add(r15F7, body.constant(int(8))), 0x01));

                  body.emit(assign(r15F5, lshift(r15F5, body.constant(int(8))), 0x01));


               body.instructions = f15FD_parent_instructions;
               body.emit(f15FD);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1601 = bit_and(r15F5, body.constant(4026531840u));
               ir_expression *const r1602 = equal(r1601, body.constant(0u));
               ir_if *f1600 = new(mem_ctx) ir_if(operand(r1602).val);
               exec_list *const f1600_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1600->then_instructions;

                  body.emit(assign(r15F7, add(r15F7, body.constant(int(4))), 0x01));

                  body.emit(assign(r15F5, lshift(r15F5, body.constant(int(4))), 0x01));


               body.instructions = f1600_parent_instructions;
               body.emit(f1600);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1604 = bit_and(r15F5, body.constant(3221225472u));
               ir_expression *const r1605 = equal(r1604, body.constant(0u));
               ir_if *f1603 = new(mem_ctx) ir_if(operand(r1605).val);
               exec_list *const f1603_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1603->then_instructions;

                  body.emit(assign(r15F7, add(r15F7, body.constant(int(2))), 0x01));

                  body.emit(assign(r15F5, lshift(r15F5, body.constant(int(2))), 0x01));


               body.instructions = f1603_parent_instructions;
               body.emit(f1603);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1607 = bit_and(r15F5, body.constant(2147483648u));
               ir_expression *const r1608 = equal(r1607, body.constant(0u));
               ir_if *f1606 = new(mem_ctx) ir_if(operand(r1608).val);
               exec_list *const f1606_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1606->then_instructions;

                  body.emit(assign(r15F7, add(r15F7, body.constant(int(1))), 0x01));


               body.instructions = f1606_parent_instructions;
               body.emit(f1606);

               /* END IF */

               body.emit(assign(r15F6, r15F7, 0x01));


            body.instructions = f15F8_parent_instructions;
            body.emit(f15F8);

            /* END IF */

            ir_variable *const r1609 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            body.emit(assign(r1609, add(r15F6, body.constant(int(-8))), 0x01));

            body.emit(assign(r15F4, lshift(r15DD, r1609), 0x01));

            body.emit(assign(r15F3, sub(body.constant(int(1)), r1609), 0x01));

            body.emit(assign(r15DA, r15F4, 0x01));

            body.emit(assign(r15D9, add(r15F3, body.constant(int(-1))), 0x01));


         body.instructions = f15F0_parent_instructions;
         body.emit(f15F0);

         /* END IF */


      body.instructions = f15EE_parent_instructions;
      body.emit(f15EE);

      /* END IF */

      /* IF CONDITION */
      ir_if *f160A = new(mem_ctx) ir_if(operand(r15D7).val);
      exec_list *const f160A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f160A->then_instructions;

         ir_variable *const r160B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r160B);
         ir_expression *const r160C = lshift(r15E1, body.constant(int(31)));
         ir_expression *const r160D = add(r15D9, body.constant(int(896)));
         ir_expression *const r160E = expr(ir_unop_i2u, r160D);
         ir_expression *const r160F = lshift(r160E, body.constant(int(20)));
         ir_expression *const r1610 = add(r160C, r160F);
         ir_expression *const r1611 = rshift(r15DA, body.constant(int(3)));
         body.emit(assign(r160B, add(r1610, r1611), 0x02));

         ir_expression *const r1612 = lshift(r15DA, body.constant(int(29)));
         body.emit(assign(r160B, bit_or(r1612, body.constant(0u)), 0x01));

         body.emit(assign(r15D8, r160B, 0x03));

         body.emit(assign(r15D7, body.constant(false), 0x01));


      body.instructions = f160A_parent_instructions;
      body.emit(f160A);

      /* END IF */


   body.instructions = f15E2_parent_instructions;
   body.emit(f15E2);

   /* END IF */

   body.emit(ret(r15D8));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64Left(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1613 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1613);
   ir_variable *const r1614 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1614);
   ir_variable *const r1615 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r1615);
   ir_variable *const r1616 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1616);
   ir_variable *const r1617 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1617);
   ir_variable *const r1618 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1618);
   ir_variable *const r1619 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1619);
   ir_variable *const r161A = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r161B = neg(r1615);
   body.emit(assign(r161A, bit_and(r161B, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r161D = equal(r1615, body.constant(int(0)));
   ir_if *f161C = new(mem_ctx) ir_if(operand(r161D).val);
   exec_list *const f161C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f161C->then_instructions;

      body.emit(assign(r1619, r1613, 0x01));

      body.emit(assign(r1618, r1614, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f161C->else_instructions;

      /* IF CONDITION */
      ir_expression *const r161F = less(r1615, body.constant(int(32)));
      ir_if *f161E = new(mem_ctx) ir_if(operand(r161F).val);
      exec_list *const f161E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f161E->then_instructions;

         ir_expression *const r1620 = lshift(r1613, r1615);
         ir_expression *const r1621 = rshift(r1614, r161A);
         body.emit(assign(r1619, bit_or(r1620, r1621), 0x01));

         body.emit(assign(r1618, lshift(r1614, r1615), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f161E->else_instructions;

         ir_variable *const r1622 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1624 = less(r1615, body.constant(int(64)));
         ir_if *f1623 = new(mem_ctx) ir_if(operand(r1624).val);
         exec_list *const f1623_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1623->then_instructions;

            ir_expression *const r1625 = add(r1615, body.constant(int(-32)));
            body.emit(assign(r1622, lshift(r1614, r1625), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1623->else_instructions;

            body.emit(assign(r1622, body.constant(0u), 0x01));


         body.instructions = f1623_parent_instructions;
         body.emit(f1623);

         /* END IF */

         body.emit(assign(r1619, r1622, 0x01));

         body.emit(assign(r1618, body.constant(0u), 0x01));


      body.instructions = f161E_parent_instructions;
      body.emit(f161E);

      /* END IF */


   body.instructions = f161C_parent_instructions;
   body.emit(f161C);

   /* END IF */

   body.emit(assign(r1616, r1619, 0x01));

   body.emit(assign(r1617, r1618, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
uint_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1626 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1626);
   ir_variable *const r1627 = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r1629 = equal(r1626, body.constant(0u));
   ir_if *f1628 = new(mem_ctx) ir_if(operand(r1629).val);
   exec_list *const f1628_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1628->then_instructions;

      body.emit(assign(r1627, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1628->else_instructions;

      ir_variable *const r162A = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r162A, r1626, 0x01));

      ir_variable *const r162B = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r162C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r162C);
      /* IF CONDITION */
      ir_expression *const r162E = equal(r1626, body.constant(0u));
      ir_if *f162D = new(mem_ctx) ir_if(operand(r162E).val);
      exec_list *const f162D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f162D->then_instructions;

         body.emit(assign(r162B, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f162D->else_instructions;

         body.emit(assign(r162C, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1630 = bit_and(r1626, body.constant(4294901760u));
         ir_expression *const r1631 = equal(r1630, body.constant(0u));
         ir_if *f162F = new(mem_ctx) ir_if(operand(r1631).val);
         exec_list *const f162F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f162F->then_instructions;

            body.emit(assign(r162C, body.constant(int(16)), 0x01));

            body.emit(assign(r162A, lshift(r1626, body.constant(int(16))), 0x01));


         body.instructions = f162F_parent_instructions;
         body.emit(f162F);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1633 = bit_and(r162A, body.constant(4278190080u));
         ir_expression *const r1634 = equal(r1633, body.constant(0u));
         ir_if *f1632 = new(mem_ctx) ir_if(operand(r1634).val);
         exec_list *const f1632_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1632->then_instructions;

            body.emit(assign(r162C, add(r162C, body.constant(int(8))), 0x01));

            body.emit(assign(r162A, lshift(r162A, body.constant(int(8))), 0x01));


         body.instructions = f1632_parent_instructions;
         body.emit(f1632);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1636 = bit_and(r162A, body.constant(4026531840u));
         ir_expression *const r1637 = equal(r1636, body.constant(0u));
         ir_if *f1635 = new(mem_ctx) ir_if(operand(r1637).val);
         exec_list *const f1635_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1635->then_instructions;

            body.emit(assign(r162C, add(r162C, body.constant(int(4))), 0x01));

            body.emit(assign(r162A, lshift(r162A, body.constant(int(4))), 0x01));


         body.instructions = f1635_parent_instructions;
         body.emit(f1635);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1639 = bit_and(r162A, body.constant(3221225472u));
         ir_expression *const r163A = equal(r1639, body.constant(0u));
         ir_if *f1638 = new(mem_ctx) ir_if(operand(r163A).val);
         exec_list *const f1638_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1638->then_instructions;

            body.emit(assign(r162C, add(r162C, body.constant(int(2))), 0x01));

            body.emit(assign(r162A, lshift(r162A, body.constant(int(2))), 0x01));


         body.instructions = f1638_parent_instructions;
         body.emit(f1638);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r163C = bit_and(r162A, body.constant(2147483648u));
         ir_expression *const r163D = equal(r163C, body.constant(0u));
         ir_if *f163B = new(mem_ctx) ir_if(operand(r163D).val);
         exec_list *const f163B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f163B->then_instructions;

            body.emit(assign(r162C, add(r162C, body.constant(int(1))), 0x01));


         body.instructions = f163B_parent_instructions;
         body.emit(f163B);

         /* END IF */

         body.emit(assign(r162B, r162C, 0x01));


      body.instructions = f162D_parent_instructions;
      body.emit(f162D);

      /* END IF */

      ir_variable *const r163E = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r163E, add(r162B, body.constant(int(21))), 0x01));

      ir_variable *const r163F = body.make_temp(glsl_type::uint_type, "a0");
      body.emit(assign(r163F, body.constant(0u), 0x01));

      ir_variable *const r1640 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r1640);
      ir_variable *const r1641 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r1641);
      ir_variable *const r1642 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      ir_expression *const r1643 = neg(r163E);
      body.emit(assign(r1642, bit_and(r1643, body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1645 = equal(r163E, body.constant(int(0)));
      ir_if *f1644 = new(mem_ctx) ir_if(operand(r1645).val);
      exec_list *const f1644_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1644->then_instructions;

         body.emit(assign(r1641, body.constant(0u), 0x01));

         body.emit(assign(r1640, r1626, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1644->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1647 = less(r163E, body.constant(int(32)));
         ir_if *f1646 = new(mem_ctx) ir_if(operand(r1647).val);
         exec_list *const f1646_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1646->then_instructions;

            ir_expression *const r1648 = rshift(r1626, r1642);
            body.emit(assign(r1641, bit_or(body.constant(0u), r1648), 0x01));

            body.emit(assign(r1640, lshift(r1626, r163E), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1646->else_instructions;

            ir_variable *const r1649 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r164B = less(r163E, body.constant(int(64)));
            ir_if *f164A = new(mem_ctx) ir_if(operand(r164B).val);
            exec_list *const f164A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f164A->then_instructions;

               ir_expression *const r164C = add(r163E, body.constant(int(-32)));
               body.emit(assign(r1649, lshift(r1626, r164C), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f164A->else_instructions;

               body.emit(assign(r1649, body.constant(0u), 0x01));


            body.instructions = f164A_parent_instructions;
            body.emit(f164A);

            /* END IF */

            body.emit(assign(r1641, r1649, 0x01));

            body.emit(assign(r1640, body.constant(0u), 0x01));


         body.instructions = f1646_parent_instructions;
         body.emit(f1646);

         /* END IF */


      body.instructions = f1644_parent_instructions;
      body.emit(f1644);

      /* END IF */

      ir_variable *const r164D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r164D);
      ir_expression *const r164E = sub(body.constant(int(1074)), r163E);
      ir_expression *const r164F = expr(ir_unop_i2u, r164E);
      ir_expression *const r1650 = lshift(r164F, body.constant(int(20)));
      body.emit(assign(r164D, add(r1650, r1641), 0x02));

      body.emit(assign(r164D, r1640, 0x01));

      body.emit(assign(r1627, r164D, 0x03));


   body.instructions = f1628_parent_instructions;
   body.emit(f1628);

   /* END IF */

   body.emit(ret(r1627));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_uint(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1651 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1651);
   ir_variable *const r1652 = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1653 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r1653);
   ir_variable *const r1654 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r1654);
   ir_variable *const r1655 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r1655, swizzle_x(r1651), 0x01));

   body.emit(assign(r1654, r1655, 0x01));

   ir_variable *const r1656 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1656, bit_and(swizzle_y(r1651), body.constant(1048575u)), 0x01));

   body.emit(assign(r1653, r1656, 0x01));

   ir_variable *const r1657 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1658 = rshift(swizzle_y(r1651), body.constant(int(20)));
   ir_expression *const r1659 = bit_and(r1658, body.constant(2047u));
   body.emit(assign(r1657, expr(ir_unop_u2i, r1659), 0x01));

   ir_variable *const r165A = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r165A, rshift(swizzle_y(r1651), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r165C = nequal(r165A, body.constant(0u));
   ir_if *f165B = new(mem_ctx) ir_if(operand(r165C).val);
   exec_list *const f165B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f165B->then_instructions;

      body.emit(assign(r1652, body.constant(0u), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f165B->else_instructions;

      /* IF CONDITION */
      ir_expression *const r165E = equal(r1657, body.constant(int(2047)));
      ir_expression *const r165F = bit_or(r1656, swizzle_x(r1651));
      ir_expression *const r1660 = nequal(r165F, body.constant(0u));
      ir_expression *const r1661 = logic_and(r165E, r1660);
      ir_if *f165D = new(mem_ctx) ir_if(operand(r1661).val);
      exec_list *const f165D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f165D->then_instructions;

         body.emit(assign(r1652, body.constant(4294967295u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f165D->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1663 = nequal(r1657, body.constant(int(0)));
         ir_if *f1662 = new(mem_ctx) ir_if(operand(r1663).val);
         exec_list *const f1662_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1662->then_instructions;

            body.emit(assign(r1653, bit_or(r1656, body.constant(1048576u)), 0x01));


         body.instructions = f1662_parent_instructions;
         body.emit(f1662);

         /* END IF */

         ir_variable *const r1664 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1664, sub(body.constant(int(1063)), r1657), 0x01));

         /* IF CONDITION */
         ir_expression *const r1666 = less(body.constant(int(0)), r1664);
         ir_if *f1665 = new(mem_ctx) ir_if(operand(r1666).val);
         exec_list *const f1665_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1665->then_instructions;

            ir_variable *const r1667 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1667);
            ir_variable *const r1668 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r1668);
            ir_variable *const r1669 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r166A = neg(r1664);
            body.emit(assign(r1669, bit_and(r166A, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r166C = equal(r1664, body.constant(int(0)));
            ir_if *f166B = new(mem_ctx) ir_if(operand(r166C).val);
            exec_list *const f166B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f166B->then_instructions;

               body.emit(assign(r1667, r1655, 0x01));

               body.emit(assign(r1668, r1653, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f166B->else_instructions;

               /* IF CONDITION */
               ir_expression *const r166E = less(r1664, body.constant(int(32)));
               ir_if *f166D = new(mem_ctx) ir_if(operand(r166E).val);
               exec_list *const f166D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f166D->then_instructions;

                  ir_expression *const r166F = lshift(r1653, r1669);
                  ir_expression *const r1670 = rshift(swizzle_x(r1651), r1664);
                  ir_expression *const r1671 = bit_or(r166F, r1670);
                  ir_expression *const r1672 = lshift(swizzle_x(r1651), r1669);
                  ir_expression *const r1673 = nequal(r1672, body.constant(0u));
                  ir_expression *const r1674 = expr(ir_unop_b2i, r1673);
                  ir_expression *const r1675 = expr(ir_unop_i2u, r1674);
                  body.emit(assign(r1667, bit_or(r1671, r1675), 0x01));

                  body.emit(assign(r1668, rshift(r1653, r1664), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f166D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1677 = equal(r1664, body.constant(int(32)));
                  ir_if *f1676 = new(mem_ctx) ir_if(operand(r1677).val);
                  exec_list *const f1676_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1676->then_instructions;

                     ir_expression *const r1678 = nequal(swizzle_x(r1651), body.constant(0u));
                     ir_expression *const r1679 = expr(ir_unop_b2i, r1678);
                     ir_expression *const r167A = expr(ir_unop_i2u, r1679);
                     body.emit(assign(r1667, bit_or(r1653, r167A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1676->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r167C = less(r1664, body.constant(int(64)));
                     ir_if *f167B = new(mem_ctx) ir_if(operand(r167C).val);
                     exec_list *const f167B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f167B->then_instructions;

                        ir_expression *const r167D = bit_and(r1664, body.constant(int(31)));
                        ir_expression *const r167E = rshift(r1653, r167D);
                        ir_expression *const r167F = lshift(r1653, r1669);
                        ir_expression *const r1680 = bit_or(r167F, swizzle_x(r1651));
                        ir_expression *const r1681 = nequal(r1680, body.constant(0u));
                        ir_expression *const r1682 = expr(ir_unop_b2i, r1681);
                        ir_expression *const r1683 = expr(ir_unop_i2u, r1682);
                        body.emit(assign(r1667, bit_or(r167E, r1683), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f167B->else_instructions;

                        ir_expression *const r1684 = bit_or(r1653, swizzle_x(r1651));
                        ir_expression *const r1685 = nequal(r1684, body.constant(0u));
                        ir_expression *const r1686 = expr(ir_unop_b2i, r1685);
                        body.emit(assign(r1667, expr(ir_unop_i2u, r1686), 0x01));


                     body.instructions = f167B_parent_instructions;
                     body.emit(f167B);

                     /* END IF */


                  body.instructions = f1676_parent_instructions;
                  body.emit(f1676);

                  /* END IF */

                  body.emit(assign(r1668, body.constant(0u), 0x01));


               body.instructions = f166D_parent_instructions;
               body.emit(f166D);

               /* END IF */


            body.instructions = f166B_parent_instructions;
            body.emit(f166B);

            /* END IF */

            body.emit(assign(r1653, r1668, 0x01));

            body.emit(assign(r1654, r1667, 0x01));


         body.instructions = f1665_parent_instructions;
         body.emit(f1665);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1688 = bit_and(r1653, body.constant(4294963200u));
         ir_expression *const r1689 = nequal(r1688, body.constant(0u));
         ir_if *f1687 = new(mem_ctx) ir_if(operand(r1689).val);
         exec_list *const f1687_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1687->then_instructions;

            ir_variable *const r168A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r168C = nequal(r165A, body.constant(0u));
            ir_if *f168B = new(mem_ctx) ir_if(operand(r168C).val);
            exec_list *const f168B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f168B->then_instructions;

               body.emit(assign(r168A, body.constant(0u), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f168B->else_instructions;

               body.emit(assign(r168A, body.constant(4294967295u), 0x01));


            body.instructions = f168B_parent_instructions;
            body.emit(f168B);

            /* END IF */

            body.emit(assign(r1652, r168A, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1687->else_instructions;

            ir_variable *const r168D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r168D);
            ir_variable *const r168E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r168E);
            ir_expression *const r168F = lshift(r1653, body.constant(int(20)));
            ir_expression *const r1690 = rshift(r1654, body.constant(int(12)));
            body.emit(assign(r168D, bit_or(r168F, r1690), 0x01));

            body.emit(assign(r168E, rshift(r1653, body.constant(int(12))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1692 = nequal(r165A, body.constant(0u));
            ir_expression *const r1693 = nequal(r168D, body.constant(0u));
            ir_expression *const r1694 = logic_and(r1692, r1693);
            ir_if *f1691 = new(mem_ctx) ir_if(operand(r1694).val);
            exec_list *const f1691_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1691->then_instructions;

               ir_variable *const r1695 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1697 = nequal(r165A, body.constant(0u));
               ir_if *f1696 = new(mem_ctx) ir_if(operand(r1697).val);
               exec_list *const f1696_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1696->then_instructions;

                  body.emit(assign(r1695, body.constant(0u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1696->else_instructions;

                  body.emit(assign(r1695, body.constant(4294967295u), 0x01));


               body.instructions = f1696_parent_instructions;
               body.emit(f1696);

               /* END IF */

               body.emit(assign(r1652, r1695, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1691->else_instructions;

               body.emit(assign(r1652, r168D, 0x01));


            body.instructions = f1691_parent_instructions;
            body.emit(f1691);

            /* END IF */


         body.instructions = f1687_parent_instructions;
         body.emit(f1687);

         /* END IF */


      body.instructions = f165D_parent_instructions;
      body.emit(f165D);

      /* END IF */


   body.instructions = f165B_parent_instructions;
   body.emit(f165B);

   /* END IF */

   body.emit(ret(r1652));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ftrunc64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1698 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1698);
   ir_variable *const r1699 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r169A = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r169B = rshift(swizzle_y(r1698), body.constant(int(20)));
   ir_expression *const r169C = bit_and(r169B, body.constant(2047u));
   ir_expression *const r169D = expr(ir_unop_u2i, r169C);
   body.emit(assign(r169A, add(r169D, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r169F = less(r169A, body.constant(int(0)));
   ir_if *f169E = new(mem_ctx) ir_if(operand(r169F).val);
   exec_list *const f169E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f169E->then_instructions;

      body.emit(assign(r1699, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f169E->else_instructions;

      /* IF CONDITION */
      ir_expression *const r16A1 = greater(r169A, body.constant(int(52)));
      ir_if *f16A0 = new(mem_ctx) ir_if(operand(r16A1).val);
      exec_list *const f16A0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f16A0->then_instructions;

         body.emit(assign(r1699, r1698, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f16A0->else_instructions;

         ir_variable *const r16A2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r16A2, sub(body.constant(int(52)), r169A), 0x01));

         ir_variable *const r16A3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r16A5 = gequal(r16A2, body.constant(int(32)));
         ir_if *f16A4 = new(mem_ctx) ir_if(operand(r16A5).val);
         exec_list *const f16A4_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16A4->then_instructions;

            body.emit(assign(r16A3, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16A4->else_instructions;

            body.emit(assign(r16A3, lshift(body.constant(4294967295u), r16A2), 0x01));


         body.instructions = f16A4_parent_instructions;
         body.emit(f16A4);

         /* END IF */

         ir_variable *const r16A6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r16A8 = less(r16A2, body.constant(int(33)));
         ir_if *f16A7 = new(mem_ctx) ir_if(operand(r16A8).val);
         exec_list *const f16A7_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16A7->then_instructions;

            body.emit(assign(r16A6, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16A7->else_instructions;

            ir_expression *const r16A9 = add(r16A2, body.constant(int(-32)));
            body.emit(assign(r16A6, lshift(body.constant(4294967295u), r16A9), 0x01));


         body.instructions = f16A7_parent_instructions;
         body.emit(f16A7);

         /* END IF */

         ir_variable *const r16AA = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r16AA, bit_and(r16A3, swizzle_x(r1698)), 0x01));

         body.emit(assign(r16AA, bit_and(r16A6, swizzle_y(r1698)), 0x02));

         body.emit(assign(r1699, r16AA, 0x03));


      body.instructions = f16A0_parent_instructions;
      body.emit(f16A0);

      /* END IF */


   body.instructions = f169E_parent_instructions;
   body.emit(f169E);

   /* END IF */

   body.emit(ret(r1699));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ffloor64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r16AB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r16AB);
   ir_variable *const r16AC = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r16AD = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r16AE = rshift(swizzle_y(r16AB), body.constant(int(20)));
   ir_expression *const r16AF = bit_and(r16AE, body.constant(2047u));
   ir_expression *const r16B0 = expr(ir_unop_u2i, r16AF);
   body.emit(assign(r16AD, add(r16B0, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r16B2 = less(r16AD, body.constant(int(0)));
   ir_if *f16B1 = new(mem_ctx) ir_if(operand(r16B2).val);
   exec_list *const f16B1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f16B1->then_instructions;

      body.emit(assign(r16AC, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f16B1->else_instructions;

      /* IF CONDITION */
      ir_expression *const r16B4 = greater(r16AD, body.constant(int(52)));
      ir_if *f16B3 = new(mem_ctx) ir_if(operand(r16B4).val);
      exec_list *const f16B3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f16B3->then_instructions;

         body.emit(assign(r16AC, r16AB, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f16B3->else_instructions;

         ir_variable *const r16B5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r16B5, sub(body.constant(int(52)), r16AD), 0x01));

         ir_variable *const r16B6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r16B8 = gequal(r16B5, body.constant(int(32)));
         ir_if *f16B7 = new(mem_ctx) ir_if(operand(r16B8).val);
         exec_list *const f16B7_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16B7->then_instructions;

            body.emit(assign(r16B6, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16B7->else_instructions;

            body.emit(assign(r16B6, lshift(body.constant(4294967295u), r16B5), 0x01));


         body.instructions = f16B7_parent_instructions;
         body.emit(f16B7);

         /* END IF */

         ir_variable *const r16B9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r16BB = less(r16B5, body.constant(int(33)));
         ir_if *f16BA = new(mem_ctx) ir_if(operand(r16BB).val);
         exec_list *const f16BA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16BA->then_instructions;

            body.emit(assign(r16B9, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16BA->else_instructions;

            ir_expression *const r16BC = add(r16B5, body.constant(int(-32)));
            body.emit(assign(r16B9, lshift(body.constant(4294967295u), r16BC), 0x01));


         body.instructions = f16BA_parent_instructions;
         body.emit(f16BA);

         /* END IF */

         ir_variable *const r16BD = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r16BD, bit_and(r16B6, swizzle_x(r16AB)), 0x01));

         body.emit(assign(r16BD, bit_and(r16B9, swizzle_y(r16AB)), 0x02));

         body.emit(assign(r16AC, r16BD, 0x03));


      body.instructions = f16B3_parent_instructions;
      body.emit(f16B3);

      /* END IF */


   body.instructions = f16B1_parent_instructions;
   body.emit(f16B1);

   /* END IF */

   ir_variable *const r16BE = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r16BF = rshift(swizzle_y(r16AB), body.constant(int(31)));
   ir_expression *const r16C0 = expr(ir_unop_u2i, r16BF);
   body.emit(assign(r16BE, expr(ir_unop_i2b, r16C0), 0x01));

   ir_variable *const r16C1 = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r16C3 = expr(ir_unop_logic_not, r16BE);
   ir_if *f16C2 = new(mem_ctx) ir_if(operand(r16C3).val);
   exec_list *const f16C2_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f16C2->then_instructions;

      body.emit(assign(r16C1, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f16C2->else_instructions;

      ir_variable *const r16C4 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r16C5 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r16C5);
      ir_variable *const r16C6 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r16C6);
      ir_expression *const r16C7 = rshift(swizzle_y(r16AB), body.constant(int(20)));
      ir_expression *const r16C8 = bit_and(r16C7, body.constant(2047u));
      ir_expression *const r16C9 = expr(ir_unop_u2i, r16C8);
      ir_expression *const r16CA = equal(r16C9, body.constant(int(2047)));
      ir_expression *const r16CB = bit_and(swizzle_y(r16AB), body.constant(1048575u));
      ir_expression *const r16CC = bit_or(r16CB, swizzle_x(r16AB));
      ir_expression *const r16CD = nequal(r16CC, body.constant(0u));
      body.emit(assign(r16C6, logic_and(r16CA, r16CD), 0x01));

      ir_expression *const r16CE = rshift(swizzle_y(r16AC), body.constant(int(20)));
      ir_expression *const r16CF = bit_and(r16CE, body.constant(2047u));
      ir_expression *const r16D0 = expr(ir_unop_u2i, r16CF);
      ir_expression *const r16D1 = equal(r16D0, body.constant(int(2047)));
      ir_expression *const r16D2 = bit_and(swizzle_y(r16AC), body.constant(1048575u));
      ir_expression *const r16D3 = bit_or(r16D2, swizzle_x(r16AC));
      ir_expression *const r16D4 = nequal(r16D3, body.constant(0u));
      body.emit(assign(r16C5, logic_and(r16D1, r16D4), 0x01));

      /* IF CONDITION */
      ir_expression *const r16D6 = logic_or(r16C6, r16C5);
      ir_if *f16D5 = new(mem_ctx) ir_if(operand(r16D6).val);
      exec_list *const f16D5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f16D5->then_instructions;

         body.emit(assign(r16C4, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f16D5->else_instructions;

         ir_expression *const r16D7 = equal(swizzle_x(r16AB), swizzle_x(r16AC));
         ir_expression *const r16D8 = equal(swizzle_y(r16AB), swizzle_y(r16AC));
         ir_expression *const r16D9 = equal(swizzle_x(r16AB), body.constant(0u));
         ir_expression *const r16DA = bit_or(swizzle_y(r16AB), swizzle_y(r16AC));
         ir_expression *const r16DB = lshift(r16DA, body.constant(int(1)));
         ir_expression *const r16DC = equal(r16DB, body.constant(0u));
         ir_expression *const r16DD = logic_and(r16D9, r16DC);
         ir_expression *const r16DE = logic_or(r16D8, r16DD);
         body.emit(assign(r16C4, logic_and(r16D7, r16DE), 0x01));


      body.instructions = f16D5_parent_instructions;
      body.emit(f16D5);

      /* END IF */

      body.emit(assign(r16C1, r16C4, 0x01));


   body.instructions = f16C2_parent_instructions;
   body.emit(f16C2);

   /* END IF */

   ir_variable *const r16DF = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f16E0 = new(mem_ctx) ir_if(operand(r16C1).val);
   exec_list *const f16E0_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f16E0->then_instructions;

      body.emit(assign(r16DF, r16AC, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f16E0->else_instructions;

      ir_variable *const r16E1 = body.make_temp(glsl_type::uvec2_type, "a");
      body.emit(assign(r16E1, body.constant(0u), 0x01));

      body.emit(assign(r16E1, body.constant(3220176896u), 0x02));

      ir_variable *const r16E2 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r16E3 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r16E3, rshift(swizzle_y(r16AC), body.constant(int(31))), 0x01));

      ir_variable *const r16E4 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r16E4, body.constant(1u), 0x01));

      /* IF CONDITION */
      ir_expression *const r16E6 = equal(r16E3, body.constant(1u));
      ir_if *f16E5 = new(mem_ctx) ir_if(operand(r16E6).val);
      exec_list *const f16E5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f16E5->then_instructions;

         ir_variable *const r16E7 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r16E7, body.constant(true), 0x01));

         ir_variable *const r16E8 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r16E9 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r16E9);
         ir_variable *const r16EA = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r16EA);
         ir_variable *const r16EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r16EB);
         ir_variable *const r16EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r16EC);
         ir_variable *const r16ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r16ED);
         ir_variable *const r16EE = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r16EE);
         ir_variable *const r16EF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r16EF);
         ir_variable *const r16F0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r16F0);
         body.emit(assign(r16F0, body.constant(0u), 0x01));

         body.emit(assign(r16EF, body.constant(0u), 0x01));

         ir_variable *const r16F1 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r16F1, swizzle_x(r16AC), 0x01));

         body.emit(assign(r16ED, r16F1, 0x01));

         ir_variable *const r16F2 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r16F2, bit_and(swizzle_y(r16AC), body.constant(1048575u)), 0x01));

         body.emit(assign(r16EC, r16F2, 0x01));

         ir_variable *const r16F3 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r16F3, body.constant(0u), 0x01));

         body.emit(assign(r16EB, r16F3, 0x01));

         ir_variable *const r16F4 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r16F4, body.constant(0u), 0x01));

         body.emit(assign(r16EA, r16F4, 0x01));

         ir_variable *const r16F5 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r16F6 = rshift(swizzle_y(r16AC), body.constant(int(20)));
         ir_expression *const r16F7 = bit_and(r16F6, body.constant(2047u));
         body.emit(assign(r16F5, expr(ir_unop_u2i, r16F7), 0x01));

         ir_variable *const r16F8 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r16F8, body.constant(int(1023)), 0x01));

         ir_variable *const r16F9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r16F9, add(r16F5, body.constant(int(-1023))), 0x01));

         body.emit(assign(r16E9, r16F9, 0x01));

         /* IF CONDITION */
         ir_expression *const r16FB = less(body.constant(int(0)), r16F9);
         ir_if *f16FA = new(mem_ctx) ir_if(operand(r16FB).val);
         exec_list *const f16FA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16FA->then_instructions;

            /* IF CONDITION */
            ir_expression *const r16FD = equal(r16F5, body.constant(int(2047)));
            ir_if *f16FC = new(mem_ctx) ir_if(operand(r16FD).val);
            exec_list *const f16FC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f16FC->then_instructions;

               /* IF CONDITION */
               ir_expression *const r16FF = bit_or(r16F2, swizzle_x(r16AC));
               ir_expression *const r1700 = nequal(r16FF, body.constant(0u));
               ir_if *f16FE = new(mem_ctx) ir_if(operand(r1700).val);
               exec_list *const f16FE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f16FE->then_instructions;

                  ir_variable *const r1701 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1701, swizzle_x(r16AC), 0x01));

                  ir_variable *const r1702 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r1702, body.constant(0u), 0x01));

                  ir_variable *const r1703 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r1704 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r1705 = rshift(swizzle_y(r16AC), body.constant(int(19)));
                  ir_expression *const r1706 = bit_and(r1705, body.constant(4095u));
                  ir_expression *const r1707 = equal(r1706, body.constant(4094u));
                  ir_expression *const r1708 = nequal(swizzle_x(r16AC), body.constant(0u));
                  ir_expression *const r1709 = bit_and(swizzle_y(r16AC), body.constant(524287u));
                  ir_expression *const r170A = nequal(r1709, body.constant(0u));
                  ir_expression *const r170B = logic_or(r1708, r170A);
                  body.emit(assign(r1704, logic_and(r1707, r170B), 0x01));

                  ir_variable *const r170C = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  body.emit(assign(r170C, body.constant(false), 0x01));

                  body.emit(assign(r1701, bit_or(swizzle_y(r16AC), body.constant(524288u)), 0x02));

                  body.emit(assign(r1702, body.constant(3220701184u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r170E = lshift(swizzle_y(r16AC), body.constant(int(1)));
                  ir_expression *const r170F = lequal(body.constant(4292870144u), r170E);
                  ir_expression *const r1710 = nequal(swizzle_x(r16AC), body.constant(0u));
                  ir_expression *const r1711 = bit_and(swizzle_y(r16AC), body.constant(1048575u));
                  ir_expression *const r1712 = nequal(r1711, body.constant(0u));
                  ir_expression *const r1713 = logic_or(r1710, r1712);
                  ir_expression *const r1714 = logic_and(r170F, r1713);
                  ir_if *f170D = new(mem_ctx) ir_if(operand(r1714).val);
                  exec_list *const f170D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f170D->then_instructions;

                     ir_variable *const r1715 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_constant *const r1717 = body.constant(false);
                     ir_if *f1716 = new(mem_ctx) ir_if(operand(r1717).val);
                     exec_list *const f1716_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1716->then_instructions;

                        body.emit(assign(r1715, r1702, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1716->else_instructions;

                        body.emit(assign(r1715, r1701, 0x03));


                     body.instructions = f1716_parent_instructions;
                     body.emit(f1716);

                     /* END IF */

                     body.emit(assign(r1703, r1715, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f170D->else_instructions;

                     body.emit(assign(r1703, r1702, 0x03));


                  body.instructions = f170D_parent_instructions;
                  body.emit(f170D);

                  /* END IF */

                  body.emit(assign(r16E8, r1703, 0x03));

                  body.emit(assign(r16E7, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f16FE->else_instructions;

                  body.emit(assign(r16E8, r16AC, 0x03));

                  body.emit(assign(r16E7, body.constant(false), 0x01));


               body.instructions = f16FE_parent_instructions;
               body.emit(f16FE);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f16FC->else_instructions;

               /* IF CONDITION */
               ir_constant *const r1719 = body.constant(false);
               ir_if *f1718 = new(mem_ctx) ir_if(operand(r1719).val);
               exec_list *const f1718_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1718->then_instructions;

                  body.emit(assign(r16E9, add(r16F9, body.constant(int(-1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1718->else_instructions;

                  body.emit(assign(r16EA, body.constant(1048576u), 0x01));


               body.instructions = f1718_parent_instructions;
               body.emit(f1718);

               /* END IF */

               ir_variable *const r171A = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r171A, body.constant(0u), 0x01));

               ir_variable *const r171B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r171B);
               ir_variable *const r171C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r171C);
               ir_variable *const r171D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r171D);
               ir_variable *const r171E = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r171F = neg(r16E9);
               body.emit(assign(r171E, bit_and(r171F, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1721 = equal(r16E9, body.constant(int(0)));
               ir_if *f1720 = new(mem_ctx) ir_if(operand(r1721).val);
               exec_list *const f1720_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1720->then_instructions;

                  body.emit(assign(r171B, r171A, 0x01));

                  body.emit(assign(r171C, r16F3, 0x01));

                  body.emit(assign(r171D, r16EA, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1720->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1723 = less(r16E9, body.constant(int(32)));
                  ir_if *f1722 = new(mem_ctx) ir_if(operand(r1723).val);
                  exec_list *const f1722_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1722->then_instructions;

                     body.emit(assign(r171B, body.constant(0u), 0x01));

                     ir_expression *const r1724 = lshift(r16EA, r171E);
                     body.emit(assign(r171C, bit_or(r1724, body.constant(0u)), 0x01));

                     body.emit(assign(r171D, rshift(r16EA, r16E9), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1722->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1726 = equal(r16E9, body.constant(int(32)));
                     ir_if *f1725 = new(mem_ctx) ir_if(operand(r1726).val);
                     exec_list *const f1725_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1725->then_instructions;

                        body.emit(assign(r171B, r16F3, 0x01));

                        body.emit(assign(r171C, r16EA, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1725->else_instructions;

                        body.emit(assign(r171A, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1728 = less(r16E9, body.constant(int(64)));
                        ir_if *f1727 = new(mem_ctx) ir_if(operand(r1728).val);
                        exec_list *const f1727_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1727->then_instructions;

                           body.emit(assign(r171B, lshift(r16EA, r171E), 0x01));

                           ir_expression *const r1729 = bit_and(r16E9, body.constant(int(31)));
                           body.emit(assign(r171C, rshift(r16EA, r1729), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1727->else_instructions;

                           ir_variable *const r172A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r172C = equal(r16E9, body.constant(int(64)));
                           ir_if *f172B = new(mem_ctx) ir_if(operand(r172C).val);
                           exec_list *const f172B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f172B->then_instructions;

                              body.emit(assign(r172A, r16EA, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f172B->else_instructions;

                              ir_expression *const r172D = nequal(r16EA, body.constant(0u));
                              ir_expression *const r172E = expr(ir_unop_b2i, r172D);
                              body.emit(assign(r172A, expr(ir_unop_i2u, r172E), 0x01));


                           body.instructions = f172B_parent_instructions;
                           body.emit(f172B);

                           /* END IF */

                           body.emit(assign(r171B, r172A, 0x01));

                           body.emit(assign(r171C, body.constant(0u), 0x01));


                        body.instructions = f1727_parent_instructions;
                        body.emit(f1727);

                        /* END IF */


                     body.instructions = f1725_parent_instructions;
                     body.emit(f1725);

                     /* END IF */

                     body.emit(assign(r171D, body.constant(0u), 0x01));


                  body.instructions = f1722_parent_instructions;
                  body.emit(f1722);

                  /* END IF */

                  ir_expression *const r172F = nequal(r171A, body.constant(0u));
                  ir_expression *const r1730 = expr(ir_unop_b2i, r172F);
                  ir_expression *const r1731 = expr(ir_unop_i2u, r1730);
                  body.emit(assign(r171B, bit_or(r171B, r1731), 0x01));


               body.instructions = f1720_parent_instructions;
               body.emit(f1720);

               /* END IF */

               body.emit(assign(r16EA, r171D, 0x01));

               body.emit(assign(r16EB, r171C, 0x01));

               body.emit(assign(r16EF, r171B, 0x01));

               body.emit(assign(r16EE, r16F5, 0x01));


            body.instructions = f16FC_parent_instructions;
            body.emit(f16FC);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16FA->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1733 = less(r16E9, body.constant(int(0)));
            ir_if *f1732 = new(mem_ctx) ir_if(operand(r1733).val);
            exec_list *const f1732_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1732->then_instructions;

               /* IF CONDITION */
               ir_constant *const r1735 = body.constant(false);
               ir_if *f1734 = new(mem_ctx) ir_if(operand(r1735).val);
               exec_list *const f1734_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1734->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1737 = bit_or(r16EA, r16EB);
                  ir_expression *const r1738 = nequal(r1737, body.constant(0u));
                  ir_if *f1736 = new(mem_ctx) ir_if(operand(r1738).val);
                  exec_list *const f1736_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1736->then_instructions;

                     ir_variable *const r1739 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r1739, swizzle_x(r16AC), 0x01));

                     ir_variable *const r173A = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r173A, body.constant(0u), 0x01));

                     ir_variable *const r173B = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r173C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r173D = rshift(swizzle_y(r16AC), body.constant(int(19)));
                     ir_expression *const r173E = bit_and(r173D, body.constant(4095u));
                     ir_expression *const r173F = equal(r173E, body.constant(4094u));
                     ir_expression *const r1740 = nequal(swizzle_x(r16AC), body.constant(0u));
                     ir_expression *const r1741 = bit_and(swizzle_y(r16AC), body.constant(524287u));
                     ir_expression *const r1742 = nequal(r1741, body.constant(0u));
                     ir_expression *const r1743 = logic_or(r1740, r1742);
                     body.emit(assign(r173C, logic_and(r173F, r1743), 0x01));

                     ir_variable *const r1744 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r1744, body.constant(false), 0x01));

                     body.emit(assign(r1739, bit_or(swizzle_y(r16AC), body.constant(524288u)), 0x02));

                     body.emit(assign(r173A, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r1746 = lshift(swizzle_y(r16AC), body.constant(int(1)));
                     ir_expression *const r1747 = lequal(body.constant(4292870144u), r1746);
                     ir_expression *const r1748 = nequal(swizzle_x(r16AC), body.constant(0u));
                     ir_expression *const r1749 = bit_and(swizzle_y(r16AC), body.constant(1048575u));
                     ir_expression *const r174A = nequal(r1749, body.constant(0u));
                     ir_expression *const r174B = logic_or(r1748, r174A);
                     ir_expression *const r174C = logic_and(r1747, r174B);
                     ir_if *f1745 = new(mem_ctx) ir_if(operand(r174C).val);
                     exec_list *const f1745_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1745->then_instructions;

                        ir_variable *const r174D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r174F = body.constant(false);
                        ir_if *f174E = new(mem_ctx) ir_if(operand(r174F).val);
                        exec_list *const f174E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f174E->then_instructions;

                           body.emit(assign(r174D, r173A, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f174E->else_instructions;

                           body.emit(assign(r174D, r1739, 0x03));


                        body.instructions = f174E_parent_instructions;
                        body.emit(f174E);

                        /* END IF */

                        body.emit(assign(r173B, r174D, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1745->else_instructions;

                        body.emit(assign(r173B, r173A, 0x03));


                     body.instructions = f1745_parent_instructions;
                     body.emit(f1745);

                     /* END IF */

                     body.emit(assign(r16E8, r173B, 0x03));

                     body.emit(assign(r16E7, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1736->else_instructions;

                     ir_variable *const r1750 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1750);
                     ir_expression *const r1751 = lshift(r16E3, body.constant(int(31)));
                     body.emit(assign(r1750, add(r1751, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1750, body.constant(0u), 0x01));

                     body.emit(assign(r16E8, r1750, 0x03));

                     body.emit(assign(r16E7, body.constant(false), 0x01));


                  body.instructions = f1736_parent_instructions;
                  body.emit(f1736);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1734->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1753 = equal(r16F5, body.constant(int(0)));
                  ir_if *f1752 = new(mem_ctx) ir_if(operand(r1753).val);
                  exec_list *const f1752_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1752->then_instructions;

                     body.emit(assign(r16E9, add(r16E9, body.constant(int(1))), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1752->else_instructions;

                     body.emit(assign(r16EC, bit_or(r16F2, body.constant(1048576u)), 0x01));


                  body.instructions = f1752_parent_instructions;
                  body.emit(f1752);

                  /* END IF */

                  ir_variable *const r1754 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r1754, body.constant(0u), 0x01));

                  ir_variable *const r1755 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1755, neg(r16E9), 0x01));

                  ir_variable *const r1756 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1756);
                  ir_variable *const r1757 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1757);
                  ir_variable *const r1758 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1758);
                  ir_variable *const r1759 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r175A = neg(r1755);
                  body.emit(assign(r1759, bit_and(r175A, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r175C = equal(r1755, body.constant(int(0)));
                  ir_if *f175B = new(mem_ctx) ir_if(operand(r175C).val);
                  exec_list *const f175B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f175B->then_instructions;

                     body.emit(assign(r1756, r1754, 0x01));

                     body.emit(assign(r1757, r16F1, 0x01));

                     body.emit(assign(r1758, r16EC, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f175B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r175E = less(r1755, body.constant(int(32)));
                     ir_if *f175D = new(mem_ctx) ir_if(operand(r175E).val);
                     exec_list *const f175D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f175D->then_instructions;

                        body.emit(assign(r1756, lshift(swizzle_x(r16AC), r1759), 0x01));

                        ir_expression *const r175F = lshift(r16EC, r1759);
                        ir_expression *const r1760 = rshift(swizzle_x(r16AC), r1755);
                        body.emit(assign(r1757, bit_or(r175F, r1760), 0x01));

                        body.emit(assign(r1758, rshift(r16EC, r1755), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f175D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1762 = equal(r1755, body.constant(int(32)));
                        ir_if *f1761 = new(mem_ctx) ir_if(operand(r1762).val);
                        exec_list *const f1761_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1761->then_instructions;

                           body.emit(assign(r1756, r16F1, 0x01));

                           body.emit(assign(r1757, r16EC, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1761->else_instructions;

                           body.emit(assign(r1754, bit_or(body.constant(0u), swizzle_x(r16AC)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1764 = less(r1755, body.constant(int(64)));
                           ir_if *f1763 = new(mem_ctx) ir_if(operand(r1764).val);
                           exec_list *const f1763_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1763->then_instructions;

                              body.emit(assign(r1756, lshift(r16EC, r1759), 0x01));

                              ir_expression *const r1765 = bit_and(r1755, body.constant(int(31)));
                              body.emit(assign(r1757, rshift(r16EC, r1765), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1763->else_instructions;

                              ir_variable *const r1766 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1768 = equal(r1755, body.constant(int(64)));
                              ir_if *f1767 = new(mem_ctx) ir_if(operand(r1768).val);
                              exec_list *const f1767_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1767->then_instructions;

                                 body.emit(assign(r1766, r16EC, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1767->else_instructions;

                                 ir_expression *const r1769 = nequal(r16EC, body.constant(0u));
                                 ir_expression *const r176A = expr(ir_unop_b2i, r1769);
                                 body.emit(assign(r1766, expr(ir_unop_i2u, r176A), 0x01));


                              body.instructions = f1767_parent_instructions;
                              body.emit(f1767);

                              /* END IF */

                              body.emit(assign(r1756, r1766, 0x01));

                              body.emit(assign(r1757, body.constant(0u), 0x01));


                           body.instructions = f1763_parent_instructions;
                           body.emit(f1763);

                           /* END IF */


                        body.instructions = f1761_parent_instructions;
                        body.emit(f1761);

                        /* END IF */

                        body.emit(assign(r1758, body.constant(0u), 0x01));


                     body.instructions = f175D_parent_instructions;
                     body.emit(f175D);

                     /* END IF */

                     ir_expression *const r176B = nequal(r1754, body.constant(0u));
                     ir_expression *const r176C = expr(ir_unop_b2i, r176B);
                     ir_expression *const r176D = expr(ir_unop_i2u, r176C);
                     body.emit(assign(r1756, bit_or(r1756, r176D), 0x01));


                  body.instructions = f175B_parent_instructions;
                  body.emit(f175B);

                  /* END IF */

                  body.emit(assign(r16EC, r1758, 0x01));

                  body.emit(assign(r16ED, r1757, 0x01));

                  body.emit(assign(r16EF, r1756, 0x01));

                  body.emit(assign(r16EE, r16F8, 0x01));


               body.instructions = f1734_parent_instructions;
               body.emit(f1734);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1732->else_instructions;

               /* IF CONDITION */
               ir_expression *const r176F = equal(r16F5, body.constant(int(2047)));
               ir_if *f176E = new(mem_ctx) ir_if(operand(r176F).val);
               exec_list *const f176E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f176E->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1771 = bit_or(r16EC, r16ED);
                  ir_expression *const r1772 = bit_or(r16EA, r16EB);
                  ir_expression *const r1773 = bit_or(r1771, r1772);
                  ir_expression *const r1774 = nequal(r1773, body.constant(0u));
                  ir_if *f1770 = new(mem_ctx) ir_if(operand(r1774).val);
                  exec_list *const f1770_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1770->then_instructions;

                     ir_variable *const r1775 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r1775, swizzle_x(r16AC), 0x01));

                     ir_variable *const r1776 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r1776, body.constant(0u), 0x01));

                     ir_variable *const r1777 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1778 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r1779 = rshift(swizzle_y(r16AC), body.constant(int(19)));
                     ir_expression *const r177A = bit_and(r1779, body.constant(4095u));
                     ir_expression *const r177B = equal(r177A, body.constant(4094u));
                     ir_expression *const r177C = nequal(swizzle_x(r16AC), body.constant(0u));
                     ir_expression *const r177D = bit_and(swizzle_y(r16AC), body.constant(524287u));
                     ir_expression *const r177E = nequal(r177D, body.constant(0u));
                     ir_expression *const r177F = logic_or(r177C, r177E);
                     body.emit(assign(r1778, logic_and(r177B, r177F), 0x01));

                     ir_variable *const r1780 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r1780, body.constant(false), 0x01));

                     body.emit(assign(r1775, bit_or(swizzle_y(r16AC), body.constant(524288u)), 0x02));

                     body.emit(assign(r1776, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r1782 = lshift(swizzle_y(r16AC), body.constant(int(1)));
                     ir_expression *const r1783 = lequal(body.constant(4292870144u), r1782);
                     ir_expression *const r1784 = nequal(swizzle_x(r16AC), body.constant(0u));
                     ir_expression *const r1785 = bit_and(swizzle_y(r16AC), body.constant(1048575u));
                     ir_expression *const r1786 = nequal(r1785, body.constant(0u));
                     ir_expression *const r1787 = logic_or(r1784, r1786);
                     ir_expression *const r1788 = logic_and(r1783, r1787);
                     ir_if *f1781 = new(mem_ctx) ir_if(operand(r1788).val);
                     exec_list *const f1781_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1781->then_instructions;

                        ir_variable *const r1789 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r178B = body.constant(false);
                        ir_if *f178A = new(mem_ctx) ir_if(operand(r178B).val);
                        exec_list *const f178A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f178A->then_instructions;

                           body.emit(assign(r1789, r1776, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f178A->else_instructions;

                           body.emit(assign(r1789, r1775, 0x03));


                        body.instructions = f178A_parent_instructions;
                        body.emit(f178A);

                        /* END IF */

                        body.emit(assign(r1777, r1789, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1781->else_instructions;

                        body.emit(assign(r1777, r1776, 0x03));


                     body.instructions = f1781_parent_instructions;
                     body.emit(f1781);

                     /* END IF */

                     body.emit(assign(r16E8, r1777, 0x03));

                     body.emit(assign(r16E7, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1770->else_instructions;

                     body.emit(assign(r16E8, r16AC, 0x03));

                     body.emit(assign(r16E7, body.constant(false), 0x01));


                  body.instructions = f1770_parent_instructions;
                  body.emit(f1770);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f176E->else_instructions;

                  ir_variable *const r178C = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r178D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r178D, add(r16ED, r16EB), 0x01));

                  ir_expression *const r178E = add(r16EC, r16EA);
                  ir_expression *const r178F = less(r178D, r16ED);
                  ir_expression *const r1790 = expr(ir_unop_b2i, r178F);
                  ir_expression *const r1791 = expr(ir_unop_i2u, r1790);
                  body.emit(assign(r178C, add(r178E, r1791), 0x01));

                  body.emit(assign(r16F0, r178C, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1793 = equal(r16F5, body.constant(int(0)));
                  ir_if *f1792 = new(mem_ctx) ir_if(operand(r1793).val);
                  exec_list *const f1792_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1792->then_instructions;

                     ir_variable *const r1794 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1794);
                     ir_expression *const r1795 = lshift(r16E3, body.constant(int(31)));
                     body.emit(assign(r1794, add(r1795, r178C), 0x02));

                     body.emit(assign(r1794, r178D, 0x01));

                     body.emit(assign(r16E8, r1794, 0x03));

                     body.emit(assign(r16E7, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1792->else_instructions;

                     body.emit(assign(r16F0, bit_or(r178C, body.constant(2097152u)), 0x01));

                     body.emit(assign(r16EE, r16F5, 0x01));

                     ir_variable *const r1796 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r1796);
                     ir_variable *const r1797 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r1797);
                     ir_variable *const r1798 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r1798);
                     body.emit(assign(r1796, lshift(r178D, body.constant(int(31))), 0x01));

                     ir_expression *const r1799 = lshift(r16F0, body.constant(int(31)));
                     ir_expression *const r179A = rshift(r178D, body.constant(int(1)));
                     body.emit(assign(r1797, bit_or(r1799, r179A), 0x01));

                     body.emit(assign(r1798, rshift(r16F0, body.constant(int(1))), 0x01));

                     body.emit(assign(r1796, bit_or(r1796, body.constant(0u)), 0x01));

                     body.emit(assign(r16F0, r1798, 0x01));

                     body.emit(assign(r16EF, r1796, 0x01));

                     ir_variable *const r179B = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r179B, r16F5, 0x01));

                     ir_variable *const r179C = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r179C, r1798, 0x01));

                     ir_variable *const r179D = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r179D, r1797, 0x01));

                     ir_variable *const r179E = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r179E, r1796, 0x01));

                     ir_variable *const r179F = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r179F, body.constant(true), 0x01));

                     ir_variable *const r17A0 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r17A1 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r17A1);
                     ir_expression *const r17A2 = expr(ir_unop_u2i, r1796);
                     body.emit(assign(r17A1, less(r17A2, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r17A4 = lequal(body.constant(int(2045)), r16F5);
                     ir_if *f17A3 = new(mem_ctx) ir_if(operand(r17A4).val);
                     exec_list *const f17A3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f17A3->then_instructions;

                        ir_variable *const r17A5 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r17A7 = less(body.constant(int(2045)), r16F5);
                        ir_if *f17A6 = new(mem_ctx) ir_if(operand(r17A7).val);
                        exec_list *const f17A6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f17A6->then_instructions;

                           body.emit(assign(r17A5, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f17A6->else_instructions;

                           ir_variable *const r17A8 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r17AA = equal(r16F5, body.constant(int(2045)));
                           ir_if *f17A9 = new(mem_ctx) ir_if(operand(r17AA).val);
                           exec_list *const f17A9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f17A9->then_instructions;

                              ir_expression *const r17AB = equal(body.constant(2097151u), r1798);
                              ir_expression *const r17AC = equal(body.constant(4294967295u), r1797);
                              body.emit(assign(r17A8, logic_and(r17AB, r17AC), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f17A9->else_instructions;

                              body.emit(assign(r17A8, body.constant(false), 0x01));


                           body.instructions = f17A9_parent_instructions;
                           body.emit(f17A9);

                           /* END IF */

                           body.emit(assign(r17A5, logic_and(r17A8, r17A1), 0x01));


                        body.instructions = f17A6_parent_instructions;
                        body.emit(f17A6);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f17AD = new(mem_ctx) ir_if(operand(r17A5).val);
                        exec_list *const f17AD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f17AD->then_instructions;

                           ir_variable *const r17AE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r17AE);
                           ir_expression *const r17AF = lshift(r16E3, body.constant(int(31)));
                           body.emit(assign(r17AE, add(r17AF, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r17AE, body.constant(0u), 0x01));

                           body.emit(assign(r17A0, r17AE, 0x03));

                           body.emit(assign(r179F, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f17AD->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r17B1 = less(r16F5, body.constant(int(0)));
                           ir_if *f17B0 = new(mem_ctx) ir_if(operand(r17B1).val);
                           exec_list *const f17B0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f17B0->then_instructions;

                              ir_variable *const r17B2 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r17B2, r1796, 0x01));

                              ir_variable *const r17B3 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r17B3, neg(r16F5), 0x01));

                              ir_variable *const r17B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r17B4);
                              ir_variable *const r17B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r17B5);
                              ir_variable *const r17B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r17B6);
                              ir_variable *const r17B7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r17B8 = neg(r17B3);
                              body.emit(assign(r17B7, bit_and(r17B8, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r17BA = equal(r17B3, body.constant(int(0)));
                              ir_if *f17B9 = new(mem_ctx) ir_if(operand(r17BA).val);
                              exec_list *const f17B9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f17B9->then_instructions;

                                 body.emit(assign(r17B4, r1796, 0x01));

                                 body.emit(assign(r17B5, r1797, 0x01));

                                 body.emit(assign(r17B6, r1798, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f17B9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r17BC = less(r17B3, body.constant(int(32)));
                                 ir_if *f17BB = new(mem_ctx) ir_if(operand(r17BC).val);
                                 exec_list *const f17BB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f17BB->then_instructions;

                                    body.emit(assign(r17B4, lshift(r1797, r17B7), 0x01));

                                    ir_expression *const r17BD = lshift(r1798, r17B7);
                                    ir_expression *const r17BE = rshift(r1797, r17B3);
                                    body.emit(assign(r17B5, bit_or(r17BD, r17BE), 0x01));

                                    body.emit(assign(r17B6, rshift(r1798, r17B3), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f17BB->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r17C0 = equal(r17B3, body.constant(int(32)));
                                    ir_if *f17BF = new(mem_ctx) ir_if(operand(r17C0).val);
                                    exec_list *const f17BF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f17BF->then_instructions;

                                       body.emit(assign(r17B4, r1797, 0x01));

                                       body.emit(assign(r17B5, r1798, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f17BF->else_instructions;

                                       body.emit(assign(r17B2, bit_or(r1796, r1797), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r17C2 = less(r17B3, body.constant(int(64)));
                                       ir_if *f17C1 = new(mem_ctx) ir_if(operand(r17C2).val);
                                       exec_list *const f17C1_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f17C1->then_instructions;

                                          body.emit(assign(r17B4, lshift(r1798, r17B7), 0x01));

                                          ir_expression *const r17C3 = bit_and(r17B3, body.constant(int(31)));
                                          body.emit(assign(r17B5, rshift(r1798, r17C3), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f17C1->else_instructions;

                                          ir_variable *const r17C4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r17C6 = equal(r17B3, body.constant(int(64)));
                                          ir_if *f17C5 = new(mem_ctx) ir_if(operand(r17C6).val);
                                          exec_list *const f17C5_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f17C5->then_instructions;

                                             body.emit(assign(r17C4, r1798, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f17C5->else_instructions;

                                             ir_expression *const r17C7 = nequal(r1798, body.constant(0u));
                                             ir_expression *const r17C8 = expr(ir_unop_b2i, r17C7);
                                             body.emit(assign(r17C4, expr(ir_unop_i2u, r17C8), 0x01));


                                          body.instructions = f17C5_parent_instructions;
                                          body.emit(f17C5);

                                          /* END IF */

                                          body.emit(assign(r17B4, r17C4, 0x01));

                                          body.emit(assign(r17B5, body.constant(0u), 0x01));


                                       body.instructions = f17C1_parent_instructions;
                                       body.emit(f17C1);

                                       /* END IF */


                                    body.instructions = f17BF_parent_instructions;
                                    body.emit(f17BF);

                                    /* END IF */

                                    body.emit(assign(r17B6, body.constant(0u), 0x01));


                                 body.instructions = f17BB_parent_instructions;
                                 body.emit(f17BB);

                                 /* END IF */

                                 ir_expression *const r17C9 = nequal(r17B2, body.constant(0u));
                                 ir_expression *const r17CA = expr(ir_unop_b2i, r17C9);
                                 ir_expression *const r17CB = expr(ir_unop_i2u, r17CA);
                                 body.emit(assign(r17B4, bit_or(r17B4, r17CB), 0x01));


                              body.instructions = f17B9_parent_instructions;
                              body.emit(f17B9);

                              /* END IF */

                              body.emit(assign(r179C, r17B6, 0x01));

                              body.emit(assign(r179D, r17B5, 0x01));

                              body.emit(assign(r179E, r17B4, 0x01));

                              body.emit(assign(r179B, body.constant(int(0)), 0x01));

                              body.emit(assign(r17A1, less(r17B4, body.constant(0u)), 0x01));


                           body.instructions = f17B0_parent_instructions;
                           body.emit(f17B0);

                           /* END IF */


                        body.instructions = f17AD_parent_instructions;
                        body.emit(f17AD);

                        /* END IF */


                     body.instructions = f17A3_parent_instructions;
                     body.emit(f17A3);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f17CC = new(mem_ctx) ir_if(operand(r179F).val);
                     exec_list *const f17CC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f17CC->then_instructions;

                        /* IF CONDITION */
                        ir_if *f17CD = new(mem_ctx) ir_if(operand(r17A1).val);
                        exec_list *const f17CD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f17CD->then_instructions;

                           ir_variable *const r17CE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r17CE, add(r179D, body.constant(1u)), 0x01));

                           ir_expression *const r17CF = less(r17CE, r179D);
                           ir_expression *const r17D0 = expr(ir_unop_b2i, r17CF);
                           ir_expression *const r17D1 = expr(ir_unop_i2u, r17D0);
                           body.emit(assign(r179C, add(r179C, r17D1), 0x01));

                           ir_expression *const r17D2 = equal(r179E, body.constant(0u));
                           ir_expression *const r17D3 = expr(ir_unop_b2i, r17D2);
                           ir_expression *const r17D4 = expr(ir_unop_i2u, r17D3);
                           ir_expression *const r17D5 = add(r179E, r17D4);
                           ir_expression *const r17D6 = bit_and(r17D5, body.constant(1u));
                           ir_expression *const r17D7 = expr(ir_unop_bit_not, r17D6);
                           body.emit(assign(r179D, bit_and(r17CE, r17D7), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f17CD->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r17D9 = bit_or(r179C, r179D);
                           ir_expression *const r17DA = equal(r17D9, body.constant(0u));
                           ir_if *f17D8 = new(mem_ctx) ir_if(operand(r17DA).val);
                           exec_list *const f17D8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f17D8->then_instructions;

                              body.emit(assign(r179B, body.constant(int(0)), 0x01));


                           body.instructions = f17D8_parent_instructions;
                           body.emit(f17D8);

                           /* END IF */


                        body.instructions = f17CD_parent_instructions;
                        body.emit(f17CD);

                        /* END IF */

                        ir_variable *const r17DB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r17DB);
                        ir_expression *const r17DC = lshift(r16E3, body.constant(int(31)));
                        ir_expression *const r17DD = expr(ir_unop_i2u, r179B);
                        ir_expression *const r17DE = lshift(r17DD, body.constant(int(20)));
                        ir_expression *const r17DF = add(r17DC, r17DE);
                        body.emit(assign(r17DB, add(r17DF, r179C), 0x02));

                        body.emit(assign(r17DB, r179D, 0x01));

                        body.emit(assign(r17A0, r17DB, 0x03));

                        body.emit(assign(r179F, body.constant(false), 0x01));


                     body.instructions = f17CC_parent_instructions;
                     body.emit(f17CC);

                     /* END IF */

                     body.emit(assign(r16E8, r17A0, 0x03));

                     body.emit(assign(r16E7, body.constant(false), 0x01));


                  body.instructions = f1792_parent_instructions;
                  body.emit(f1792);

                  /* END IF */


               body.instructions = f176E_parent_instructions;
               body.emit(f176E);

               /* END IF */


            body.instructions = f1732_parent_instructions;
            body.emit(f1732);

            /* END IF */


         body.instructions = f16FA_parent_instructions;
         body.emit(f16FA);

         /* END IF */

         /* IF CONDITION */
         ir_if *f17E0 = new(mem_ctx) ir_if(operand(r16E7).val);
         exec_list *const f17E0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f17E0->then_instructions;

            body.emit(assign(r16EC, bit_or(r16EC, body.constant(1048576u)), 0x01));

            ir_variable *const r17E1 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r17E2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r17E2, add(r16ED, r16EB), 0x01));

            ir_expression *const r17E3 = add(r16EC, r16EA);
            ir_expression *const r17E4 = less(r17E2, r16ED);
            ir_expression *const r17E5 = expr(ir_unop_b2i, r17E4);
            ir_expression *const r17E6 = expr(ir_unop_i2u, r17E5);
            body.emit(assign(r17E1, add(r17E3, r17E6), 0x01));

            body.emit(assign(r16F0, r17E1, 0x01));

            body.emit(assign(r16EE, add(r16EE, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r17E8 = less(r17E1, body.constant(2097152u));
            ir_if *f17E7 = new(mem_ctx) ir_if(operand(r17E8).val);
            exec_list *const f17E7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f17E7->then_instructions;

               ir_variable *const r17E9 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r17E9, r16EE, 0x01));

               ir_variable *const r17EA = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r17EA, r17E1, 0x01));

               ir_variable *const r17EB = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r17EB, r17E2, 0x01));

               ir_variable *const r17EC = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r17EC, r16EF, 0x01));

               ir_variable *const r17ED = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r17ED, body.constant(true), 0x01));

               ir_variable *const r17EE = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r17EF = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r17EF);
               ir_expression *const r17F0 = expr(ir_unop_u2i, r16EF);
               body.emit(assign(r17EF, less(r17F0, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r17F2 = lequal(body.constant(int(2045)), r16EE);
               ir_if *f17F1 = new(mem_ctx) ir_if(operand(r17F2).val);
               exec_list *const f17F1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f17F1->then_instructions;

                  ir_variable *const r17F3 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r17F5 = less(body.constant(int(2045)), r16EE);
                  ir_if *f17F4 = new(mem_ctx) ir_if(operand(r17F5).val);
                  exec_list *const f17F4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f17F4->then_instructions;

                     body.emit(assign(r17F3, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f17F4->else_instructions;

                     ir_variable *const r17F6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r17F8 = equal(r16EE, body.constant(int(2045)));
                     ir_if *f17F7 = new(mem_ctx) ir_if(operand(r17F8).val);
                     exec_list *const f17F7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f17F7->then_instructions;

                        ir_expression *const r17F9 = equal(body.constant(2097151u), r17E1);
                        ir_expression *const r17FA = equal(body.constant(4294967295u), r17E2);
                        body.emit(assign(r17F6, logic_and(r17F9, r17FA), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f17F7->else_instructions;

                        body.emit(assign(r17F6, body.constant(false), 0x01));


                     body.instructions = f17F7_parent_instructions;
                     body.emit(f17F7);

                     /* END IF */

                     body.emit(assign(r17F3, logic_and(r17F6, r17EF), 0x01));


                  body.instructions = f17F4_parent_instructions;
                  body.emit(f17F4);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f17FB = new(mem_ctx) ir_if(operand(r17F3).val);
                  exec_list *const f17FB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f17FB->then_instructions;

                     ir_variable *const r17FC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r17FC);
                     ir_expression *const r17FD = lshift(r16E3, body.constant(int(31)));
                     body.emit(assign(r17FC, add(r17FD, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r17FC, body.constant(0u), 0x01));

                     body.emit(assign(r17EE, r17FC, 0x03));

                     body.emit(assign(r17ED, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f17FB->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r17FF = less(r16EE, body.constant(int(0)));
                     ir_if *f17FE = new(mem_ctx) ir_if(operand(r17FF).val);
                     exec_list *const f17FE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f17FE->then_instructions;

                        ir_variable *const r1800 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1800, r16EF, 0x01));

                        ir_variable *const r1801 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1801, neg(r16EE), 0x01));

                        ir_variable *const r1802 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1802);
                        ir_variable *const r1803 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1803);
                        ir_variable *const r1804 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1804);
                        ir_variable *const r1805 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1806 = neg(r1801);
                        body.emit(assign(r1805, bit_and(r1806, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1808 = equal(r1801, body.constant(int(0)));
                        ir_if *f1807 = new(mem_ctx) ir_if(operand(r1808).val);
                        exec_list *const f1807_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1807->then_instructions;

                           body.emit(assign(r1802, r16EF, 0x01));

                           body.emit(assign(r1803, r17E2, 0x01));

                           body.emit(assign(r1804, r17E1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1807->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r180A = less(r1801, body.constant(int(32)));
                           ir_if *f1809 = new(mem_ctx) ir_if(operand(r180A).val);
                           exec_list *const f1809_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1809->then_instructions;

                              body.emit(assign(r1802, lshift(r17E2, r1805), 0x01));

                              ir_expression *const r180B = lshift(r17E1, r1805);
                              ir_expression *const r180C = rshift(r17E2, r1801);
                              body.emit(assign(r1803, bit_or(r180B, r180C), 0x01));

                              body.emit(assign(r1804, rshift(r17E1, r1801), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1809->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r180E = equal(r1801, body.constant(int(32)));
                              ir_if *f180D = new(mem_ctx) ir_if(operand(r180E).val);
                              exec_list *const f180D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f180D->then_instructions;

                                 body.emit(assign(r1802, r17E2, 0x01));

                                 body.emit(assign(r1803, r17E1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f180D->else_instructions;

                                 body.emit(assign(r1800, bit_or(r16EF, r17E2), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1810 = less(r1801, body.constant(int(64)));
                                 ir_if *f180F = new(mem_ctx) ir_if(operand(r1810).val);
                                 exec_list *const f180F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f180F->then_instructions;

                                    body.emit(assign(r1802, lshift(r17E1, r1805), 0x01));

                                    ir_expression *const r1811 = bit_and(r1801, body.constant(int(31)));
                                    body.emit(assign(r1803, rshift(r17E1, r1811), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f180F->else_instructions;

                                    ir_variable *const r1812 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1814 = equal(r1801, body.constant(int(64)));
                                    ir_if *f1813 = new(mem_ctx) ir_if(operand(r1814).val);
                                    exec_list *const f1813_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1813->then_instructions;

                                       body.emit(assign(r1812, r17E1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1813->else_instructions;

                                       ir_expression *const r1815 = nequal(r17E1, body.constant(0u));
                                       ir_expression *const r1816 = expr(ir_unop_b2i, r1815);
                                       body.emit(assign(r1812, expr(ir_unop_i2u, r1816), 0x01));


                                    body.instructions = f1813_parent_instructions;
                                    body.emit(f1813);

                                    /* END IF */

                                    body.emit(assign(r1802, r1812, 0x01));

                                    body.emit(assign(r1803, body.constant(0u), 0x01));


                                 body.instructions = f180F_parent_instructions;
                                 body.emit(f180F);

                                 /* END IF */


                              body.instructions = f180D_parent_instructions;
                              body.emit(f180D);

                              /* END IF */

                              body.emit(assign(r1804, body.constant(0u), 0x01));


                           body.instructions = f1809_parent_instructions;
                           body.emit(f1809);

                           /* END IF */

                           ir_expression *const r1817 = nequal(r1800, body.constant(0u));
                           ir_expression *const r1818 = expr(ir_unop_b2i, r1817);
                           ir_expression *const r1819 = expr(ir_unop_i2u, r1818);
                           body.emit(assign(r1802, bit_or(r1802, r1819), 0x01));


                        body.instructions = f1807_parent_instructions;
                        body.emit(f1807);

                        /* END IF */

                        body.emit(assign(r17EA, r1804, 0x01));

                        body.emit(assign(r17EB, r1803, 0x01));

                        body.emit(assign(r17EC, r1802, 0x01));

                        body.emit(assign(r17E9, body.constant(int(0)), 0x01));

                        body.emit(assign(r17EF, less(r1802, body.constant(0u)), 0x01));


                     body.instructions = f17FE_parent_instructions;
                     body.emit(f17FE);

                     /* END IF */


                  body.instructions = f17FB_parent_instructions;
                  body.emit(f17FB);

                  /* END IF */


               body.instructions = f17F1_parent_instructions;
               body.emit(f17F1);

               /* END IF */

               /* IF CONDITION */
               ir_if *f181A = new(mem_ctx) ir_if(operand(r17ED).val);
               exec_list *const f181A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f181A->then_instructions;

                  /* IF CONDITION */
                  ir_if *f181B = new(mem_ctx) ir_if(operand(r17EF).val);
                  exec_list *const f181B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f181B->then_instructions;

                     ir_variable *const r181C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r181C, add(r17EB, body.constant(1u)), 0x01));

                     ir_expression *const r181D = less(r181C, r17EB);
                     ir_expression *const r181E = expr(ir_unop_b2i, r181D);
                     ir_expression *const r181F = expr(ir_unop_i2u, r181E);
                     body.emit(assign(r17EA, add(r17EA, r181F), 0x01));

                     ir_expression *const r1820 = equal(r17EC, body.constant(0u));
                     ir_expression *const r1821 = expr(ir_unop_b2i, r1820);
                     ir_expression *const r1822 = expr(ir_unop_i2u, r1821);
                     ir_expression *const r1823 = add(r17EC, r1822);
                     ir_expression *const r1824 = bit_and(r1823, body.constant(1u));
                     ir_expression *const r1825 = expr(ir_unop_bit_not, r1824);
                     body.emit(assign(r17EB, bit_and(r181C, r1825), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f181B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1827 = bit_or(r17EA, r17EB);
                     ir_expression *const r1828 = equal(r1827, body.constant(0u));
                     ir_if *f1826 = new(mem_ctx) ir_if(operand(r1828).val);
                     exec_list *const f1826_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1826->then_instructions;

                        body.emit(assign(r17E9, body.constant(int(0)), 0x01));


                     body.instructions = f1826_parent_instructions;
                     body.emit(f1826);

                     /* END IF */


                  body.instructions = f181B_parent_instructions;
                  body.emit(f181B);

                  /* END IF */

                  ir_variable *const r1829 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1829);
                  ir_expression *const r182A = lshift(r16E3, body.constant(int(31)));
                  ir_expression *const r182B = expr(ir_unop_i2u, r17E9);
                  ir_expression *const r182C = lshift(r182B, body.constant(int(20)));
                  ir_expression *const r182D = add(r182A, r182C);
                  body.emit(assign(r1829, add(r182D, r17EA), 0x02));

                  body.emit(assign(r1829, r17EB, 0x01));

                  body.emit(assign(r17EE, r1829, 0x03));

                  body.emit(assign(r17ED, body.constant(false), 0x01));


               body.instructions = f181A_parent_instructions;
               body.emit(f181A);

               /* END IF */

               body.emit(assign(r16E8, r17EE, 0x03));

               body.emit(assign(r16E7, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f17E7->else_instructions;

               body.emit(assign(r16EE, add(r16EE, body.constant(int(1))), 0x01));

               ir_variable *const r182E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r182E);
               ir_variable *const r182F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r182F);
               ir_variable *const r1830 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1830);
               body.emit(assign(r182E, lshift(r17E2, body.constant(int(31))), 0x01));

               ir_expression *const r1831 = lshift(r17E1, body.constant(int(31)));
               ir_expression *const r1832 = rshift(r17E2, body.constant(int(1)));
               body.emit(assign(r182F, bit_or(r1831, r1832), 0x01));

               body.emit(assign(r1830, rshift(r17E1, body.constant(int(1))), 0x01));

               ir_expression *const r1833 = nequal(r16EF, body.constant(0u));
               ir_expression *const r1834 = expr(ir_unop_b2i, r1833);
               ir_expression *const r1835 = expr(ir_unop_i2u, r1834);
               body.emit(assign(r182E, bit_or(r182E, r1835), 0x01));

               body.emit(assign(r16F0, r1830, 0x01));

               body.emit(assign(r16EF, r182E, 0x01));

               ir_variable *const r1836 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1836, r16EE, 0x01));

               ir_variable *const r1837 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1837, r1830, 0x01));

               ir_variable *const r1838 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1838, r182F, 0x01));

               ir_variable *const r1839 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1839, r182E, 0x01));

               ir_variable *const r183A = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r183A, body.constant(true), 0x01));

               ir_variable *const r183B = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r183C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r183C);
               ir_expression *const r183D = expr(ir_unop_u2i, r182E);
               body.emit(assign(r183C, less(r183D, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r183F = lequal(body.constant(int(2045)), r16EE);
               ir_if *f183E = new(mem_ctx) ir_if(operand(r183F).val);
               exec_list *const f183E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f183E->then_instructions;

                  ir_variable *const r1840 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1842 = less(body.constant(int(2045)), r16EE);
                  ir_if *f1841 = new(mem_ctx) ir_if(operand(r1842).val);
                  exec_list *const f1841_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1841->then_instructions;

                     body.emit(assign(r1840, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1841->else_instructions;

                     ir_variable *const r1843 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1845 = equal(r16EE, body.constant(int(2045)));
                     ir_if *f1844 = new(mem_ctx) ir_if(operand(r1845).val);
                     exec_list *const f1844_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1844->then_instructions;

                        ir_expression *const r1846 = equal(body.constant(2097151u), r1830);
                        ir_expression *const r1847 = equal(body.constant(4294967295u), r182F);
                        body.emit(assign(r1843, logic_and(r1846, r1847), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1844->else_instructions;

                        body.emit(assign(r1843, body.constant(false), 0x01));


                     body.instructions = f1844_parent_instructions;
                     body.emit(f1844);

                     /* END IF */

                     body.emit(assign(r1840, logic_and(r1843, r183C), 0x01));


                  body.instructions = f1841_parent_instructions;
                  body.emit(f1841);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1848 = new(mem_ctx) ir_if(operand(r1840).val);
                  exec_list *const f1848_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1848->then_instructions;

                     ir_variable *const r1849 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1849);
                     ir_expression *const r184A = lshift(r16E3, body.constant(int(31)));
                     body.emit(assign(r1849, add(r184A, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1849, body.constant(0u), 0x01));

                     body.emit(assign(r183B, r1849, 0x03));

                     body.emit(assign(r183A, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1848->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r184C = less(r16EE, body.constant(int(0)));
                     ir_if *f184B = new(mem_ctx) ir_if(operand(r184C).val);
                     exec_list *const f184B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f184B->then_instructions;

                        ir_variable *const r184D = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r184D, r182E, 0x01));

                        ir_variable *const r184E = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r184E, neg(r16EE), 0x01));

                        ir_variable *const r184F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r184F);
                        ir_variable *const r1850 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1850);
                        ir_variable *const r1851 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1851);
                        ir_variable *const r1852 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1853 = neg(r184E);
                        body.emit(assign(r1852, bit_and(r1853, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1855 = equal(r184E, body.constant(int(0)));
                        ir_if *f1854 = new(mem_ctx) ir_if(operand(r1855).val);
                        exec_list *const f1854_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1854->then_instructions;

                           body.emit(assign(r184F, r182E, 0x01));

                           body.emit(assign(r1850, r182F, 0x01));

                           body.emit(assign(r1851, r1830, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1854->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1857 = less(r184E, body.constant(int(32)));
                           ir_if *f1856 = new(mem_ctx) ir_if(operand(r1857).val);
                           exec_list *const f1856_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1856->then_instructions;

                              body.emit(assign(r184F, lshift(r182F, r1852), 0x01));

                              ir_expression *const r1858 = lshift(r1830, r1852);
                              ir_expression *const r1859 = rshift(r182F, r184E);
                              body.emit(assign(r1850, bit_or(r1858, r1859), 0x01));

                              body.emit(assign(r1851, rshift(r1830, r184E), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1856->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r185B = equal(r184E, body.constant(int(32)));
                              ir_if *f185A = new(mem_ctx) ir_if(operand(r185B).val);
                              exec_list *const f185A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f185A->then_instructions;

                                 body.emit(assign(r184F, r182F, 0x01));

                                 body.emit(assign(r1850, r1830, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f185A->else_instructions;

                                 body.emit(assign(r184D, bit_or(r182E, r182F), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r185D = less(r184E, body.constant(int(64)));
                                 ir_if *f185C = new(mem_ctx) ir_if(operand(r185D).val);
                                 exec_list *const f185C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f185C->then_instructions;

                                    body.emit(assign(r184F, lshift(r1830, r1852), 0x01));

                                    ir_expression *const r185E = bit_and(r184E, body.constant(int(31)));
                                    body.emit(assign(r1850, rshift(r1830, r185E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f185C->else_instructions;

                                    ir_variable *const r185F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1861 = equal(r184E, body.constant(int(64)));
                                    ir_if *f1860 = new(mem_ctx) ir_if(operand(r1861).val);
                                    exec_list *const f1860_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1860->then_instructions;

                                       body.emit(assign(r185F, r1830, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1860->else_instructions;

                                       ir_expression *const r1862 = nequal(r1830, body.constant(0u));
                                       ir_expression *const r1863 = expr(ir_unop_b2i, r1862);
                                       body.emit(assign(r185F, expr(ir_unop_i2u, r1863), 0x01));


                                    body.instructions = f1860_parent_instructions;
                                    body.emit(f1860);

                                    /* END IF */

                                    body.emit(assign(r184F, r185F, 0x01));

                                    body.emit(assign(r1850, body.constant(0u), 0x01));


                                 body.instructions = f185C_parent_instructions;
                                 body.emit(f185C);

                                 /* END IF */


                              body.instructions = f185A_parent_instructions;
                              body.emit(f185A);

                              /* END IF */

                              body.emit(assign(r1851, body.constant(0u), 0x01));


                           body.instructions = f1856_parent_instructions;
                           body.emit(f1856);

                           /* END IF */

                           ir_expression *const r1864 = nequal(r184D, body.constant(0u));
                           ir_expression *const r1865 = expr(ir_unop_b2i, r1864);
                           ir_expression *const r1866 = expr(ir_unop_i2u, r1865);
                           body.emit(assign(r184F, bit_or(r184F, r1866), 0x01));


                        body.instructions = f1854_parent_instructions;
                        body.emit(f1854);

                        /* END IF */

                        body.emit(assign(r1837, r1851, 0x01));

                        body.emit(assign(r1838, r1850, 0x01));

                        body.emit(assign(r1839, r184F, 0x01));

                        body.emit(assign(r1836, body.constant(int(0)), 0x01));

                        body.emit(assign(r183C, less(r184F, body.constant(0u)), 0x01));


                     body.instructions = f184B_parent_instructions;
                     body.emit(f184B);

                     /* END IF */


                  body.instructions = f1848_parent_instructions;
                  body.emit(f1848);

                  /* END IF */


               body.instructions = f183E_parent_instructions;
               body.emit(f183E);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1867 = new(mem_ctx) ir_if(operand(r183A).val);
               exec_list *const f1867_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1867->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1868 = new(mem_ctx) ir_if(operand(r183C).val);
                  exec_list *const f1868_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1868->then_instructions;

                     ir_variable *const r1869 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1869, add(r1838, body.constant(1u)), 0x01));

                     ir_expression *const r186A = less(r1869, r1838);
                     ir_expression *const r186B = expr(ir_unop_b2i, r186A);
                     ir_expression *const r186C = expr(ir_unop_i2u, r186B);
                     body.emit(assign(r1837, add(r1837, r186C), 0x01));

                     ir_expression *const r186D = equal(r1839, body.constant(0u));
                     ir_expression *const r186E = expr(ir_unop_b2i, r186D);
                     ir_expression *const r186F = expr(ir_unop_i2u, r186E);
                     ir_expression *const r1870 = add(r1839, r186F);
                     ir_expression *const r1871 = bit_and(r1870, body.constant(1u));
                     ir_expression *const r1872 = expr(ir_unop_bit_not, r1871);
                     body.emit(assign(r1838, bit_and(r1869, r1872), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1868->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1874 = bit_or(r1837, r1838);
                     ir_expression *const r1875 = equal(r1874, body.constant(0u));
                     ir_if *f1873 = new(mem_ctx) ir_if(operand(r1875).val);
                     exec_list *const f1873_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1873->then_instructions;

                        body.emit(assign(r1836, body.constant(int(0)), 0x01));


                     body.instructions = f1873_parent_instructions;
                     body.emit(f1873);

                     /* END IF */


                  body.instructions = f1868_parent_instructions;
                  body.emit(f1868);

                  /* END IF */

                  ir_variable *const r1876 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1876);
                  ir_expression *const r1877 = lshift(r16E3, body.constant(int(31)));
                  ir_expression *const r1878 = expr(ir_unop_i2u, r1836);
                  ir_expression *const r1879 = lshift(r1878, body.constant(int(20)));
                  ir_expression *const r187A = add(r1877, r1879);
                  body.emit(assign(r1876, add(r187A, r1837), 0x02));

                  body.emit(assign(r1876, r1838, 0x01));

                  body.emit(assign(r183B, r1876, 0x03));

                  body.emit(assign(r183A, body.constant(false), 0x01));


               body.instructions = f1867_parent_instructions;
               body.emit(f1867);

               /* END IF */

               body.emit(assign(r16E8, r183B, 0x03));

               body.emit(assign(r16E7, body.constant(false), 0x01));


            body.instructions = f17E7_parent_instructions;
            body.emit(f17E7);

            /* END IF */


         body.instructions = f17E0_parent_instructions;
         body.emit(f17E0);

         /* END IF */

         body.emit(assign(r16E2, r16E8, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f16E5->else_instructions;

         ir_variable *const r187B = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r187B, r16E3, 0x01));

         ir_variable *const r187C = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r187D = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r187D);
         ir_variable *const r187E = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r187E);
         ir_variable *const r187F = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r187F);
         ir_variable *const r1880 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r1880);
         ir_variable *const r1881 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r1881);
         ir_variable *const r1882 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r1882);
         ir_variable *const r1883 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r1883);
         ir_variable *const r1884 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r1884);
         ir_variable *const r1885 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r1886 = rshift(swizzle_y(r16AC), body.constant(int(20)));
         ir_expression *const r1887 = bit_and(r1886, body.constant(2047u));
         body.emit(assign(r1885, expr(ir_unop_u2i, r1887), 0x01));

         body.emit(assign(r187F, r1885, 0x01));

         ir_variable *const r1888 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r1888, body.constant(int(1023)), 0x01));

         body.emit(assign(r187E, r1888, 0x01));

         body.emit(assign(r187D, add(r1885, body.constant(int(-1023))), 0x01));

         ir_variable *const r1889 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1889, lshift(swizzle_x(r16AC), body.constant(int(10))), 0x01));

         ir_variable *const r188A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r188B = bit_and(swizzle_y(r16AC), body.constant(1048575u));
         ir_expression *const r188C = lshift(r188B, body.constant(int(10)));
         ir_expression *const r188D = rshift(swizzle_x(r16AC), body.constant(int(22)));
         body.emit(assign(r188A, bit_or(r188C, r188D), 0x01));

         body.emit(assign(r1882, r188A, 0x01));

         body.emit(assign(r1883, r1889, 0x01));

         ir_variable *const r188E = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r188E, body.constant(0u), 0x01));

         ir_variable *const r188F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r188F, body.constant(0u), 0x01));

         body.emit(assign(r1880, r188F, 0x01));

         body.emit(assign(r1881, r188E, 0x01));

         /* IF CONDITION */
         ir_expression *const r1891 = less(body.constant(int(0)), r187D);
         ir_if *f1890 = new(mem_ctx) ir_if(operand(r1891).val);
         exec_list *const f1890_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1890->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1893 = equal(r1885, body.constant(int(2047)));
            ir_if *f1892 = new(mem_ctx) ir_if(operand(r1893).val);
            exec_list *const f1892_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1892->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1895 = bit_or(r188A, r1889);
               ir_expression *const r1896 = nequal(r1895, body.constant(0u));
               ir_if *f1894 = new(mem_ctx) ir_if(operand(r1896).val);
               exec_list *const f1894_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1894->then_instructions;

                  ir_variable *const r1897 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1897, swizzle_x(r16AC), 0x01));

                  ir_variable *const r1898 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r1898, body.constant(0u), 0x01));

                  ir_variable *const r1899 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r189A = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r189B = rshift(swizzle_y(r16AC), body.constant(int(19)));
                  ir_expression *const r189C = bit_and(r189B, body.constant(4095u));
                  ir_expression *const r189D = equal(r189C, body.constant(4094u));
                  ir_expression *const r189E = nequal(swizzle_x(r16AC), body.constant(0u));
                  ir_expression *const r189F = bit_and(swizzle_y(r16AC), body.constant(524287u));
                  ir_expression *const r18A0 = nequal(r189F, body.constant(0u));
                  ir_expression *const r18A1 = logic_or(r189E, r18A0);
                  body.emit(assign(r189A, logic_and(r189D, r18A1), 0x01));

                  ir_variable *const r18A2 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  body.emit(assign(r18A2, body.constant(false), 0x01));

                  body.emit(assign(r1897, bit_or(swizzle_y(r16AC), body.constant(524288u)), 0x02));

                  body.emit(assign(r1898, body.constant(3220701184u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r18A4 = lshift(swizzle_y(r16AC), body.constant(int(1)));
                  ir_expression *const r18A5 = lequal(body.constant(4292870144u), r18A4);
                  ir_expression *const r18A6 = nequal(swizzle_x(r16AC), body.constant(0u));
                  ir_expression *const r18A7 = bit_and(swizzle_y(r16AC), body.constant(1048575u));
                  ir_expression *const r18A8 = nequal(r18A7, body.constant(0u));
                  ir_expression *const r18A9 = logic_or(r18A6, r18A8);
                  ir_expression *const r18AA = logic_and(r18A5, r18A9);
                  ir_if *f18A3 = new(mem_ctx) ir_if(operand(r18AA).val);
                  exec_list *const f18A3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18A3->then_instructions;

                     ir_variable *const r18AB = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_constant *const r18AD = body.constant(false);
                     ir_if *f18AC = new(mem_ctx) ir_if(operand(r18AD).val);
                     exec_list *const f18AC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18AC->then_instructions;

                        body.emit(assign(r18AB, r1898, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f18AC->else_instructions;

                        body.emit(assign(r18AB, r1897, 0x03));


                     body.instructions = f18AC_parent_instructions;
                     body.emit(f18AC);

                     /* END IF */

                     body.emit(assign(r1899, r18AB, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18A3->else_instructions;

                     body.emit(assign(r1899, r1898, 0x03));


                  body.instructions = f18A3_parent_instructions;
                  body.emit(f18A3);

                  /* END IF */

                  body.emit(assign(r187C, r1899, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1894->else_instructions;

                  body.emit(assign(r187C, r16AC, 0x03));


               body.instructions = f1894_parent_instructions;
               body.emit(f1894);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1892->else_instructions;

               /* IF CONDITION */
               ir_constant *const r18AF = body.constant(false);
               ir_if *f18AE = new(mem_ctx) ir_if(operand(r18AF).val);
               exec_list *const f18AE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f18AE->then_instructions;

                  body.emit(assign(r187D, add(r187D, body.constant(int(-1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f18AE->else_instructions;

                  body.emit(assign(r1880, body.constant(1073741824u), 0x01));


               body.instructions = f18AE_parent_instructions;
               body.emit(f18AE);

               /* END IF */

               ir_variable *const r18B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r18B0);
               ir_variable *const r18B1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r18B1);
               ir_variable *const r18B2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r18B3 = neg(r187D);
               body.emit(assign(r18B2, bit_and(r18B3, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r18B5 = equal(r187D, body.constant(int(0)));
               ir_if *f18B4 = new(mem_ctx) ir_if(operand(r18B5).val);
               exec_list *const f18B4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f18B4->then_instructions;

                  body.emit(assign(r18B0, r188E, 0x01));

                  body.emit(assign(r18B1, r1880, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f18B4->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r18B7 = less(r187D, body.constant(int(32)));
                  ir_if *f18B6 = new(mem_ctx) ir_if(operand(r18B7).val);
                  exec_list *const f18B6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18B6->then_instructions;

                     ir_expression *const r18B8 = lshift(r1880, r18B2);
                     ir_expression *const r18B9 = bit_or(r18B8, body.constant(0u));
                     ir_expression *const r18BA = nequal(body.constant(0u), body.constant(0u));
                     ir_expression *const r18BB = expr(ir_unop_b2i, r18BA);
                     ir_expression *const r18BC = expr(ir_unop_i2u, r18BB);
                     body.emit(assign(r18B0, bit_or(r18B9, r18BC), 0x01));

                     body.emit(assign(r18B1, rshift(r1880, r187D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18B6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r18BE = equal(r187D, body.constant(int(32)));
                     ir_if *f18BD = new(mem_ctx) ir_if(operand(r18BE).val);
                     exec_list *const f18BD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18BD->then_instructions;

                        body.emit(assign(r18B0, bit_or(r1880, body.constant(0u)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f18BD->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r18C0 = less(r187D, body.constant(int(64)));
                        ir_if *f18BF = new(mem_ctx) ir_if(operand(r18C0).val);
                        exec_list *const f18BF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f18BF->then_instructions;

                           ir_expression *const r18C1 = bit_and(r187D, body.constant(int(31)));
                           ir_expression *const r18C2 = rshift(r1880, r18C1);
                           ir_expression *const r18C3 = lshift(r1880, r18B2);
                           ir_expression *const r18C4 = bit_or(r18C3, body.constant(0u));
                           ir_expression *const r18C5 = nequal(r18C4, body.constant(0u));
                           ir_expression *const r18C6 = expr(ir_unop_b2i, r18C5);
                           ir_expression *const r18C7 = expr(ir_unop_i2u, r18C6);
                           body.emit(assign(r18B0, bit_or(r18C2, r18C7), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f18BF->else_instructions;

                           ir_expression *const r18C8 = bit_or(r1880, body.constant(0u));
                           ir_expression *const r18C9 = nequal(r18C8, body.constant(0u));
                           ir_expression *const r18CA = expr(ir_unop_b2i, r18C9);
                           body.emit(assign(r18B0, expr(ir_unop_i2u, r18CA), 0x01));


                        body.instructions = f18BF_parent_instructions;
                        body.emit(f18BF);

                        /* END IF */


                     body.instructions = f18BD_parent_instructions;
                     body.emit(f18BD);

                     /* END IF */

                     body.emit(assign(r18B1, body.constant(0u), 0x01));


                  body.instructions = f18B6_parent_instructions;
                  body.emit(f18B6);

                  /* END IF */


               body.instructions = f18B4_parent_instructions;
               body.emit(f18B4);

               /* END IF */

               body.emit(assign(r1880, r18B1, 0x01));

               body.emit(assign(r1881, r18B0, 0x01));

               body.emit(assign(r1882, bit_or(r188A, body.constant(1073741824u)), 0x01));

               ir_variable *const r18CB = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r18CC = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r18CC, sub(r1889, r18B0), 0x01));

               ir_expression *const r18CD = sub(r1882, r18B1);
               ir_expression *const r18CE = less(r1889, r18B0);
               ir_expression *const r18CF = expr(ir_unop_b2i, r18CE);
               ir_expression *const r18D0 = expr(ir_unop_i2u, r18CF);
               body.emit(assign(r18CB, sub(r18CD, r18D0), 0x01));

               body.emit(assign(r1884, add(r1885, body.constant(int(-1))), 0x01));

               ir_variable *const r18D1 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r18D1, add(r1884, body.constant(int(-10))), 0x01));

               ir_variable *const r18D2 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r18D2, r18CB, 0x01));

               ir_variable *const r18D3 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r18D3, r18CC, 0x01));

               ir_variable *const r18D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r18D4);
               ir_variable *const r18D5 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r18D5);
               /* IF CONDITION */
               ir_expression *const r18D7 = equal(r18CB, body.constant(0u));
               ir_if *f18D6 = new(mem_ctx) ir_if(operand(r18D7).val);
               exec_list *const f18D6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f18D6->then_instructions;

                  body.emit(assign(r18D2, r18CC, 0x01));

                  body.emit(assign(r18D3, body.constant(0u), 0x01));

                  body.emit(assign(r18D1, add(r18D1, body.constant(int(-32))), 0x01));


               body.instructions = f18D6_parent_instructions;
               body.emit(f18D6);

               /* END IF */

               ir_variable *const r18D8 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r18D8, r18D2, 0x01));

               ir_variable *const r18D9 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r18DA = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r18DA);
               /* IF CONDITION */
               ir_expression *const r18DC = equal(r18D2, body.constant(0u));
               ir_if *f18DB = new(mem_ctx) ir_if(operand(r18DC).val);
               exec_list *const f18DB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f18DB->then_instructions;

                  body.emit(assign(r18D9, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f18DB->else_instructions;

                  body.emit(assign(r18DA, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r18DE = bit_and(r18D2, body.constant(4294901760u));
                  ir_expression *const r18DF = equal(r18DE, body.constant(0u));
                  ir_if *f18DD = new(mem_ctx) ir_if(operand(r18DF).val);
                  exec_list *const f18DD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18DD->then_instructions;

                     body.emit(assign(r18DA, body.constant(int(16)), 0x01));

                     body.emit(assign(r18D8, lshift(r18D2, body.constant(int(16))), 0x01));


                  body.instructions = f18DD_parent_instructions;
                  body.emit(f18DD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r18E1 = bit_and(r18D8, body.constant(4278190080u));
                  ir_expression *const r18E2 = equal(r18E1, body.constant(0u));
                  ir_if *f18E0 = new(mem_ctx) ir_if(operand(r18E2).val);
                  exec_list *const f18E0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18E0->then_instructions;

                     body.emit(assign(r18DA, add(r18DA, body.constant(int(8))), 0x01));

                     body.emit(assign(r18D8, lshift(r18D8, body.constant(int(8))), 0x01));


                  body.instructions = f18E0_parent_instructions;
                  body.emit(f18E0);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r18E4 = bit_and(r18D8, body.constant(4026531840u));
                  ir_expression *const r18E5 = equal(r18E4, body.constant(0u));
                  ir_if *f18E3 = new(mem_ctx) ir_if(operand(r18E5).val);
                  exec_list *const f18E3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18E3->then_instructions;

                     body.emit(assign(r18DA, add(r18DA, body.constant(int(4))), 0x01));

                     body.emit(assign(r18D8, lshift(r18D8, body.constant(int(4))), 0x01));


                  body.instructions = f18E3_parent_instructions;
                  body.emit(f18E3);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r18E7 = bit_and(r18D8, body.constant(3221225472u));
                  ir_expression *const r18E8 = equal(r18E7, body.constant(0u));
                  ir_if *f18E6 = new(mem_ctx) ir_if(operand(r18E8).val);
                  exec_list *const f18E6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18E6->then_instructions;

                     body.emit(assign(r18DA, add(r18DA, body.constant(int(2))), 0x01));

                     body.emit(assign(r18D8, lshift(r18D8, body.constant(int(2))), 0x01));


                  body.instructions = f18E6_parent_instructions;
                  body.emit(f18E6);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r18EA = bit_and(r18D8, body.constant(2147483648u));
                  ir_expression *const r18EB = equal(r18EA, body.constant(0u));
                  ir_if *f18E9 = new(mem_ctx) ir_if(operand(r18EB).val);
                  exec_list *const f18E9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18E9->then_instructions;

                     body.emit(assign(r18DA, add(r18DA, body.constant(int(1))), 0x01));


                  body.instructions = f18E9_parent_instructions;
                  body.emit(f18E9);

                  /* END IF */

                  body.emit(assign(r18D9, r18DA, 0x01));


               body.instructions = f18DB_parent_instructions;
               body.emit(f18DB);

               /* END IF */

               body.emit(assign(r18D5, add(r18D9, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r18ED = lequal(body.constant(int(0)), r18D5);
               ir_if *f18EC = new(mem_ctx) ir_if(operand(r18ED).val);
               exec_list *const f18EC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f18EC->then_instructions;

                  body.emit(assign(r18D4, body.constant(0u), 0x01));

                  ir_variable *const r18EE = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r18EE, lshift(r18D3, r18D5), 0x01));

                  ir_variable *const r18EF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r18F1 = equal(r18D5, body.constant(int(0)));
                  ir_if *f18F0 = new(mem_ctx) ir_if(operand(r18F1).val);
                  exec_list *const f18F0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18F0->then_instructions;

                     body.emit(assign(r18EF, r18D2, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18F0->else_instructions;

                     ir_expression *const r18F2 = lshift(r18D2, r18D5);
                     ir_expression *const r18F3 = neg(r18D5);
                     ir_expression *const r18F4 = bit_and(r18F3, body.constant(int(31)));
                     ir_expression *const r18F5 = rshift(r18D3, r18F4);
                     body.emit(assign(r18EF, bit_or(r18F2, r18F5), 0x01));


                  body.instructions = f18F0_parent_instructions;
                  body.emit(f18F0);

                  /* END IF */

                  body.emit(assign(r18D2, r18EF, 0x01));

                  body.emit(assign(r18D3, r18EE, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f18EC->else_instructions;

                  ir_variable *const r18F6 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r18F6, body.constant(0u), 0x01));

                  ir_variable *const r18F7 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r18F7, neg(r18D5), 0x01));

                  ir_variable *const r18F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r18F8);
                  ir_variable *const r18F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r18F9);
                  ir_variable *const r18FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r18FA);
                  ir_variable *const r18FB = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r18FC = neg(r18F7);
                  body.emit(assign(r18FB, bit_and(r18FC, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r18FE = equal(r18F7, body.constant(int(0)));
                  ir_if *f18FD = new(mem_ctx) ir_if(operand(r18FE).val);
                  exec_list *const f18FD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18FD->then_instructions;

                     body.emit(assign(r18F8, r18F6, 0x01));

                     body.emit(assign(r18F9, r18D3, 0x01));

                     body.emit(assign(r18FA, r18D2, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18FD->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1900 = less(r18F7, body.constant(int(32)));
                     ir_if *f18FF = new(mem_ctx) ir_if(operand(r1900).val);
                     exec_list *const f18FF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18FF->then_instructions;

                        body.emit(assign(r18F8, lshift(r18D3, r18FB), 0x01));

                        ir_expression *const r1901 = lshift(r18D2, r18FB);
                        ir_expression *const r1902 = rshift(r18D3, r18F7);
                        body.emit(assign(r18F9, bit_or(r1901, r1902), 0x01));

                        body.emit(assign(r18FA, rshift(r18D2, r18F7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f18FF->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1904 = equal(r18F7, body.constant(int(32)));
                        ir_if *f1903 = new(mem_ctx) ir_if(operand(r1904).val);
                        exec_list *const f1903_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1903->then_instructions;

                           body.emit(assign(r18F8, r18D3, 0x01));

                           body.emit(assign(r18F9, r18D2, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1903->else_instructions;

                           body.emit(assign(r18F6, bit_or(body.constant(0u), r18D3), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1906 = less(r18F7, body.constant(int(64)));
                           ir_if *f1905 = new(mem_ctx) ir_if(operand(r1906).val);
                           exec_list *const f1905_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1905->then_instructions;

                              body.emit(assign(r18F8, lshift(r18D2, r18FB), 0x01));

                              ir_expression *const r1907 = bit_and(r18F7, body.constant(int(31)));
                              body.emit(assign(r18F9, rshift(r18D2, r1907), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1905->else_instructions;

                              ir_variable *const r1908 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r190A = equal(r18F7, body.constant(int(64)));
                              ir_if *f1909 = new(mem_ctx) ir_if(operand(r190A).val);
                              exec_list *const f1909_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1909->then_instructions;

                                 body.emit(assign(r1908, r18D2, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1909->else_instructions;

                                 ir_expression *const r190B = nequal(r18D2, body.constant(0u));
                                 ir_expression *const r190C = expr(ir_unop_b2i, r190B);
                                 body.emit(assign(r1908, expr(ir_unop_i2u, r190C), 0x01));


                              body.instructions = f1909_parent_instructions;
                              body.emit(f1909);

                              /* END IF */

                              body.emit(assign(r18F8, r1908, 0x01));

                              body.emit(assign(r18F9, body.constant(0u), 0x01));


                           body.instructions = f1905_parent_instructions;
                           body.emit(f1905);

                           /* END IF */


                        body.instructions = f1903_parent_instructions;
                        body.emit(f1903);

                        /* END IF */

                        body.emit(assign(r18FA, body.constant(0u), 0x01));


                     body.instructions = f18FF_parent_instructions;
                     body.emit(f18FF);

                     /* END IF */

                     ir_expression *const r190D = nequal(r18F6, body.constant(0u));
                     ir_expression *const r190E = expr(ir_unop_b2i, r190D);
                     ir_expression *const r190F = expr(ir_unop_i2u, r190E);
                     body.emit(assign(r18F8, bit_or(r18F8, r190F), 0x01));


                  body.instructions = f18FD_parent_instructions;
                  body.emit(f18FD);

                  /* END IF */

                  body.emit(assign(r18D2, r18FA, 0x01));

                  body.emit(assign(r18D3, r18F9, 0x01));

                  body.emit(assign(r18D4, r18F8, 0x01));


               body.instructions = f18EC_parent_instructions;
               body.emit(f18EC);

               /* END IF */

               body.emit(assign(r18D1, sub(r18D1, r18D5), 0x01));

               ir_variable *const r1910 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1910, r18D1, 0x01));

               ir_variable *const r1911 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1911, r18D2, 0x01));

               ir_variable *const r1912 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1912, r18D3, 0x01));

               ir_variable *const r1913 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1913, r18D4, 0x01));

               ir_variable *const r1914 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1914, body.constant(true), 0x01));

               ir_variable *const r1915 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1916 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1916);
               ir_expression *const r1917 = expr(ir_unop_u2i, r18D4);
               body.emit(assign(r1916, less(r1917, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1919 = lequal(body.constant(int(2045)), r18D1);
               ir_if *f1918 = new(mem_ctx) ir_if(operand(r1919).val);
               exec_list *const f1918_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1918->then_instructions;

                  ir_variable *const r191A = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r191C = less(body.constant(int(2045)), r18D1);
                  ir_if *f191B = new(mem_ctx) ir_if(operand(r191C).val);
                  exec_list *const f191B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f191B->then_instructions;

                     body.emit(assign(r191A, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f191B->else_instructions;

                     ir_variable *const r191D = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r191F = equal(r18D1, body.constant(int(2045)));
                     ir_if *f191E = new(mem_ctx) ir_if(operand(r191F).val);
                     exec_list *const f191E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f191E->then_instructions;

                        ir_expression *const r1920 = equal(body.constant(2097151u), r18D2);
                        ir_expression *const r1921 = equal(body.constant(4294967295u), r18D3);
                        body.emit(assign(r191D, logic_and(r1920, r1921), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f191E->else_instructions;

                        body.emit(assign(r191D, body.constant(false), 0x01));


                     body.instructions = f191E_parent_instructions;
                     body.emit(f191E);

                     /* END IF */

                     body.emit(assign(r191A, logic_and(r191D, r1916), 0x01));


                  body.instructions = f191B_parent_instructions;
                  body.emit(f191B);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1922 = new(mem_ctx) ir_if(operand(r191A).val);
                  exec_list *const f1922_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1922->then_instructions;

                     ir_variable *const r1923 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1923);
                     ir_expression *const r1924 = lshift(r16E3, body.constant(int(31)));
                     body.emit(assign(r1923, add(r1924, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1923, body.constant(0u), 0x01));

                     body.emit(assign(r1915, r1923, 0x03));

                     body.emit(assign(r1914, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1922->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1926 = less(r18D1, body.constant(int(0)));
                     ir_if *f1925 = new(mem_ctx) ir_if(operand(r1926).val);
                     exec_list *const f1925_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1925->then_instructions;

                        ir_variable *const r1927 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1927, r18D4, 0x01));

                        ir_variable *const r1928 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1928, neg(r18D1), 0x01));

                        ir_variable *const r1929 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1929);
                        ir_variable *const r192A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r192A);
                        ir_variable *const r192B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r192B);
                        ir_variable *const r192C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r192D = neg(r1928);
                        body.emit(assign(r192C, bit_and(r192D, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r192F = equal(r1928, body.constant(int(0)));
                        ir_if *f192E = new(mem_ctx) ir_if(operand(r192F).val);
                        exec_list *const f192E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f192E->then_instructions;

                           body.emit(assign(r1929, r18D4, 0x01));

                           body.emit(assign(r192A, r18D3, 0x01));

                           body.emit(assign(r192B, r18D2, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f192E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1931 = less(r1928, body.constant(int(32)));
                           ir_if *f1930 = new(mem_ctx) ir_if(operand(r1931).val);
                           exec_list *const f1930_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1930->then_instructions;

                              body.emit(assign(r1929, lshift(r18D3, r192C), 0x01));

                              ir_expression *const r1932 = lshift(r18D2, r192C);
                              ir_expression *const r1933 = rshift(r18D3, r1928);
                              body.emit(assign(r192A, bit_or(r1932, r1933), 0x01));

                              body.emit(assign(r192B, rshift(r18D2, r1928), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1930->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1935 = equal(r1928, body.constant(int(32)));
                              ir_if *f1934 = new(mem_ctx) ir_if(operand(r1935).val);
                              exec_list *const f1934_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1934->then_instructions;

                                 body.emit(assign(r1929, r18D3, 0x01));

                                 body.emit(assign(r192A, r18D2, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1934->else_instructions;

                                 body.emit(assign(r1927, bit_or(r18D4, r18D3), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1937 = less(r1928, body.constant(int(64)));
                                 ir_if *f1936 = new(mem_ctx) ir_if(operand(r1937).val);
                                 exec_list *const f1936_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1936->then_instructions;

                                    body.emit(assign(r1929, lshift(r18D2, r192C), 0x01));

                                    ir_expression *const r1938 = bit_and(r1928, body.constant(int(31)));
                                    body.emit(assign(r192A, rshift(r18D2, r1938), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1936->else_instructions;

                                    ir_variable *const r1939 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r193B = equal(r1928, body.constant(int(64)));
                                    ir_if *f193A = new(mem_ctx) ir_if(operand(r193B).val);
                                    exec_list *const f193A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f193A->then_instructions;

                                       body.emit(assign(r1939, r18D2, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f193A->else_instructions;

                                       ir_expression *const r193C = nequal(r18D2, body.constant(0u));
                                       ir_expression *const r193D = expr(ir_unop_b2i, r193C);
                                       body.emit(assign(r1939, expr(ir_unop_i2u, r193D), 0x01));


                                    body.instructions = f193A_parent_instructions;
                                    body.emit(f193A);

                                    /* END IF */

                                    body.emit(assign(r1929, r1939, 0x01));

                                    body.emit(assign(r192A, body.constant(0u), 0x01));


                                 body.instructions = f1936_parent_instructions;
                                 body.emit(f1936);

                                 /* END IF */


                              body.instructions = f1934_parent_instructions;
                              body.emit(f1934);

                              /* END IF */

                              body.emit(assign(r192B, body.constant(0u), 0x01));


                           body.instructions = f1930_parent_instructions;
                           body.emit(f1930);

                           /* END IF */

                           ir_expression *const r193E = nequal(r1927, body.constant(0u));
                           ir_expression *const r193F = expr(ir_unop_b2i, r193E);
                           ir_expression *const r1940 = expr(ir_unop_i2u, r193F);
                           body.emit(assign(r1929, bit_or(r1929, r1940), 0x01));


                        body.instructions = f192E_parent_instructions;
                        body.emit(f192E);

                        /* END IF */

                        body.emit(assign(r1911, r192B, 0x01));

                        body.emit(assign(r1912, r192A, 0x01));

                        body.emit(assign(r1913, r1929, 0x01));

                        body.emit(assign(r1910, body.constant(int(0)), 0x01));

                        body.emit(assign(r1916, less(r1929, body.constant(0u)), 0x01));


                     body.instructions = f1925_parent_instructions;
                     body.emit(f1925);

                     /* END IF */


                  body.instructions = f1922_parent_instructions;
                  body.emit(f1922);

                  /* END IF */


               body.instructions = f1918_parent_instructions;
               body.emit(f1918);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1941 = new(mem_ctx) ir_if(operand(r1914).val);
               exec_list *const f1941_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1941->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1942 = new(mem_ctx) ir_if(operand(r1916).val);
                  exec_list *const f1942_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1942->then_instructions;

                     ir_variable *const r1943 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1943, add(r1912, body.constant(1u)), 0x01));

                     ir_expression *const r1944 = less(r1943, r1912);
                     ir_expression *const r1945 = expr(ir_unop_b2i, r1944);
                     ir_expression *const r1946 = expr(ir_unop_i2u, r1945);
                     body.emit(assign(r1911, add(r1911, r1946), 0x01));

                     ir_expression *const r1947 = equal(r1913, body.constant(0u));
                     ir_expression *const r1948 = expr(ir_unop_b2i, r1947);
                     ir_expression *const r1949 = expr(ir_unop_i2u, r1948);
                     ir_expression *const r194A = add(r1913, r1949);
                     ir_expression *const r194B = bit_and(r194A, body.constant(1u));
                     ir_expression *const r194C = expr(ir_unop_bit_not, r194B);
                     body.emit(assign(r1912, bit_and(r1943, r194C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1942->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r194E = bit_or(r1911, r1912);
                     ir_expression *const r194F = equal(r194E, body.constant(0u));
                     ir_if *f194D = new(mem_ctx) ir_if(operand(r194F).val);
                     exec_list *const f194D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f194D->then_instructions;

                        body.emit(assign(r1910, body.constant(int(0)), 0x01));


                     body.instructions = f194D_parent_instructions;
                     body.emit(f194D);

                     /* END IF */


                  body.instructions = f1942_parent_instructions;
                  body.emit(f1942);

                  /* END IF */

                  ir_variable *const r1950 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1950);
                  ir_expression *const r1951 = lshift(r16E3, body.constant(int(31)));
                  ir_expression *const r1952 = expr(ir_unop_i2u, r1910);
                  ir_expression *const r1953 = lshift(r1952, body.constant(int(20)));
                  ir_expression *const r1954 = add(r1951, r1953);
                  body.emit(assign(r1950, add(r1954, r1911), 0x02));

                  body.emit(assign(r1950, r1912, 0x01));

                  body.emit(assign(r1915, r1950, 0x03));

                  body.emit(assign(r1914, body.constant(false), 0x01));


               body.instructions = f1941_parent_instructions;
               body.emit(f1941);

               /* END IF */

               body.emit(assign(r187C, r1915, 0x03));


            body.instructions = f1892_parent_instructions;
            body.emit(f1892);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1890->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1956 = less(r187D, body.constant(int(0)));
            ir_if *f1955 = new(mem_ctx) ir_if(operand(r1956).val);
            exec_list *const f1955_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1955->then_instructions;

               /* IF CONDITION */
               ir_constant *const r1958 = body.constant(false);
               ir_if *f1957 = new(mem_ctx) ir_if(operand(r1958).val);
               exec_list *const f1957_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1957->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r195A = bit_or(r1880, r1881);
                  ir_expression *const r195B = nequal(r195A, body.constant(0u));
                  ir_if *f1959 = new(mem_ctx) ir_if(operand(r195B).val);
                  exec_list *const f1959_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1959->then_instructions;

                     ir_variable *const r195C = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r195C, swizzle_x(r16AC), 0x01));

                     ir_variable *const r195D = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r195D, body.constant(0u), 0x01));

                     ir_variable *const r195E = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r195F = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r1960 = rshift(swizzle_y(r16AC), body.constant(int(19)));
                     ir_expression *const r1961 = bit_and(r1960, body.constant(4095u));
                     ir_expression *const r1962 = equal(r1961, body.constant(4094u));
                     ir_expression *const r1963 = nequal(swizzle_x(r16AC), body.constant(0u));
                     ir_expression *const r1964 = bit_and(swizzle_y(r16AC), body.constant(524287u));
                     ir_expression *const r1965 = nequal(r1964, body.constant(0u));
                     ir_expression *const r1966 = logic_or(r1963, r1965);
                     body.emit(assign(r195F, logic_and(r1962, r1966), 0x01));

                     ir_variable *const r1967 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r1967, body.constant(false), 0x01));

                     body.emit(assign(r195C, bit_or(swizzle_y(r16AC), body.constant(524288u)), 0x02));

                     body.emit(assign(r195D, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r1969 = lshift(swizzle_y(r16AC), body.constant(int(1)));
                     ir_expression *const r196A = lequal(body.constant(4292870144u), r1969);
                     ir_expression *const r196B = nequal(swizzle_x(r16AC), body.constant(0u));
                     ir_expression *const r196C = bit_and(swizzle_y(r16AC), body.constant(1048575u));
                     ir_expression *const r196D = nequal(r196C, body.constant(0u));
                     ir_expression *const r196E = logic_or(r196B, r196D);
                     ir_expression *const r196F = logic_and(r196A, r196E);
                     ir_if *f1968 = new(mem_ctx) ir_if(operand(r196F).val);
                     exec_list *const f1968_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1968->then_instructions;

                        ir_variable *const r1970 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r1972 = body.constant(false);
                        ir_if *f1971 = new(mem_ctx) ir_if(operand(r1972).val);
                        exec_list *const f1971_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1971->then_instructions;

                           body.emit(assign(r1970, r195D, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1971->else_instructions;

                           body.emit(assign(r1970, r195C, 0x03));


                        body.instructions = f1971_parent_instructions;
                        body.emit(f1971);

                        /* END IF */

                        body.emit(assign(r195E, r1970, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1968->else_instructions;

                        body.emit(assign(r195E, r195D, 0x03));


                     body.instructions = f1968_parent_instructions;
                     body.emit(f1968);

                     /* END IF */

                     body.emit(assign(r187C, r195E, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1959->else_instructions;

                     ir_variable *const r1973 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1973);
                     ir_expression *const r1974 = bit_xor(r16E3, body.constant(1u));
                     ir_expression *const r1975 = lshift(r1974, body.constant(int(31)));
                     body.emit(assign(r1973, add(r1975, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1973, body.constant(0u), 0x01));

                     body.emit(assign(r187C, r1973, 0x03));


                  body.instructions = f1959_parent_instructions;
                  body.emit(f1959);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1957->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1977 = equal(r1885, body.constant(int(0)));
                  ir_if *f1976 = new(mem_ctx) ir_if(operand(r1977).val);
                  exec_list *const f1976_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1976->then_instructions;

                     body.emit(assign(r187D, add(r187D, body.constant(int(1))), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1976->else_instructions;

                     body.emit(assign(r1882, bit_or(r1882, body.constant(1073741824u)), 0x01));


                  body.instructions = f1976_parent_instructions;
                  body.emit(f1976);

                  /* END IF */

                  ir_variable *const r1978 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1978, neg(r187D), 0x01));

                  ir_variable *const r1979 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1979);
                  ir_variable *const r197A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r197A);
                  ir_variable *const r197B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r197C = neg(r1978);
                  body.emit(assign(r197B, bit_and(r197C, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r197E = equal(r1978, body.constant(int(0)));
                  ir_if *f197D = new(mem_ctx) ir_if(operand(r197E).val);
                  exec_list *const f197D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f197D->then_instructions;

                     body.emit(assign(r1979, r1889, 0x01));

                     body.emit(assign(r197A, r1882, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f197D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1980 = less(r1978, body.constant(int(32)));
                     ir_if *f197F = new(mem_ctx) ir_if(operand(r1980).val);
                     exec_list *const f197F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f197F->then_instructions;

                        ir_expression *const r1981 = lshift(r1882, r197B);
                        ir_expression *const r1982 = rshift(r1889, r1978);
                        ir_expression *const r1983 = bit_or(r1981, r1982);
                        ir_expression *const r1984 = lshift(r1889, r197B);
                        ir_expression *const r1985 = nequal(r1984, body.constant(0u));
                        ir_expression *const r1986 = expr(ir_unop_b2i, r1985);
                        ir_expression *const r1987 = expr(ir_unop_i2u, r1986);
                        body.emit(assign(r1979, bit_or(r1983, r1987), 0x01));

                        body.emit(assign(r197A, rshift(r1882, r1978), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f197F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1989 = equal(r1978, body.constant(int(32)));
                        ir_if *f1988 = new(mem_ctx) ir_if(operand(r1989).val);
                        exec_list *const f1988_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1988->then_instructions;

                           ir_expression *const r198A = nequal(r1889, body.constant(0u));
                           ir_expression *const r198B = expr(ir_unop_b2i, r198A);
                           ir_expression *const r198C = expr(ir_unop_i2u, r198B);
                           body.emit(assign(r1979, bit_or(r1882, r198C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1988->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r198E = less(r1978, body.constant(int(64)));
                           ir_if *f198D = new(mem_ctx) ir_if(operand(r198E).val);
                           exec_list *const f198D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f198D->then_instructions;

                              ir_expression *const r198F = bit_and(r1978, body.constant(int(31)));
                              ir_expression *const r1990 = rshift(r1882, r198F);
                              ir_expression *const r1991 = lshift(r1882, r197B);
                              ir_expression *const r1992 = bit_or(r1991, r1889);
                              ir_expression *const r1993 = nequal(r1992, body.constant(0u));
                              ir_expression *const r1994 = expr(ir_unop_b2i, r1993);
                              ir_expression *const r1995 = expr(ir_unop_i2u, r1994);
                              body.emit(assign(r1979, bit_or(r1990, r1995), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f198D->else_instructions;

                              ir_expression *const r1996 = bit_or(r1882, r1889);
                              ir_expression *const r1997 = nequal(r1996, body.constant(0u));
                              ir_expression *const r1998 = expr(ir_unop_b2i, r1997);
                              body.emit(assign(r1979, expr(ir_unop_i2u, r1998), 0x01));


                           body.instructions = f198D_parent_instructions;
                           body.emit(f198D);

                           /* END IF */


                        body.instructions = f1988_parent_instructions;
                        body.emit(f1988);

                        /* END IF */

                        body.emit(assign(r197A, body.constant(0u), 0x01));


                     body.instructions = f197F_parent_instructions;
                     body.emit(f197F);

                     /* END IF */


                  body.instructions = f197D_parent_instructions;
                  body.emit(f197D);

                  /* END IF */

                  body.emit(assign(r1882, r197A, 0x01));

                  body.emit(assign(r1883, r1979, 0x01));

                  body.emit(assign(r1880, bit_or(r1880, body.constant(1073741824u)), 0x01));

                  ir_variable *const r1999 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r199A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r199A, sub(r1881, r1979), 0x01));

                  ir_expression *const r199B = sub(r1880, r197A);
                  ir_expression *const r199C = less(r1881, r1979);
                  ir_expression *const r199D = expr(ir_unop_b2i, r199C);
                  ir_expression *const r199E = expr(ir_unop_i2u, r199D);
                  body.emit(assign(r1999, sub(r199B, r199E), 0x01));

                  body.emit(assign(r187B, bit_xor(r16E3, body.constant(1u)), 0x01));

                  body.emit(assign(r1884, body.constant(int(1022)), 0x01));

                  ir_variable *const r199F = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r199F, body.constant(int(1012)), 0x01));

                  ir_variable *const r19A0 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r19A0, r1999, 0x01));

                  ir_variable *const r19A1 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r19A1, r199A, 0x01));

                  ir_variable *const r19A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r19A2);
                  ir_variable *const r19A3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r19A3);
                  /* IF CONDITION */
                  ir_expression *const r19A5 = equal(r1999, body.constant(0u));
                  ir_if *f19A4 = new(mem_ctx) ir_if(operand(r19A5).val);
                  exec_list *const f19A4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f19A4->then_instructions;

                     body.emit(assign(r19A0, r199A, 0x01));

                     body.emit(assign(r19A1, body.constant(0u), 0x01));

                     body.emit(assign(r199F, body.constant(int(980)), 0x01));


                  body.instructions = f19A4_parent_instructions;
                  body.emit(f19A4);

                  /* END IF */

                  ir_variable *const r19A6 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r19A6, r19A0, 0x01));

                  ir_variable *const r19A7 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r19A8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r19A8);
                  /* IF CONDITION */
                  ir_expression *const r19AA = equal(r19A0, body.constant(0u));
                  ir_if *f19A9 = new(mem_ctx) ir_if(operand(r19AA).val);
                  exec_list *const f19A9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f19A9->then_instructions;

                     body.emit(assign(r19A7, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f19A9->else_instructions;

                     body.emit(assign(r19A8, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r19AC = bit_and(r19A0, body.constant(4294901760u));
                     ir_expression *const r19AD = equal(r19AC, body.constant(0u));
                     ir_if *f19AB = new(mem_ctx) ir_if(operand(r19AD).val);
                     exec_list *const f19AB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f19AB->then_instructions;

                        body.emit(assign(r19A8, body.constant(int(16)), 0x01));

                        body.emit(assign(r19A6, lshift(r19A0, body.constant(int(16))), 0x01));


                     body.instructions = f19AB_parent_instructions;
                     body.emit(f19AB);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r19AF = bit_and(r19A6, body.constant(4278190080u));
                     ir_expression *const r19B0 = equal(r19AF, body.constant(0u));
                     ir_if *f19AE = new(mem_ctx) ir_if(operand(r19B0).val);
                     exec_list *const f19AE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f19AE->then_instructions;

                        body.emit(assign(r19A8, add(r19A8, body.constant(int(8))), 0x01));

                        body.emit(assign(r19A6, lshift(r19A6, body.constant(int(8))), 0x01));


                     body.instructions = f19AE_parent_instructions;
                     body.emit(f19AE);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r19B2 = bit_and(r19A6, body.constant(4026531840u));
                     ir_expression *const r19B3 = equal(r19B2, body.constant(0u));
                     ir_if *f19B1 = new(mem_ctx) ir_if(operand(r19B3).val);
                     exec_list *const f19B1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f19B1->then_instructions;

                        body.emit(assign(r19A8, add(r19A8, body.constant(int(4))), 0x01));

                        body.emit(assign(r19A6, lshift(r19A6, body.constant(int(4))), 0x01));


                     body.instructions = f19B1_parent_instructions;
                     body.emit(f19B1);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r19B5 = bit_and(r19A6, body.constant(3221225472u));
                     ir_expression *const r19B6 = equal(r19B5, body.constant(0u));
                     ir_if *f19B4 = new(mem_ctx) ir_if(operand(r19B6).val);
                     exec_list *const f19B4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f19B4->then_instructions;

                        body.emit(assign(r19A8, add(r19A8, body.constant(int(2))), 0x01));

                        body.emit(assign(r19A6, lshift(r19A6, body.constant(int(2))), 0x01));


                     body.instructions = f19B4_parent_instructions;
                     body.emit(f19B4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r19B8 = bit_and(r19A6, body.constant(2147483648u));
                     ir_expression *const r19B9 = equal(r19B8, body.constant(0u));
                     ir_if *f19B7 = new(mem_ctx) ir_if(operand(r19B9).val);
                     exec_list *const f19B7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f19B7->then_instructions;

                        body.emit(assign(r19A8, add(r19A8, body.constant(int(1))), 0x01));


                     body.instructions = f19B7_parent_instructions;
                     body.emit(f19B7);

                     /* END IF */

                     body.emit(assign(r19A7, r19A8, 0x01));


                  body.instructions = f19A9_parent_instructions;
                  body.emit(f19A9);

                  /* END IF */

                  body.emit(assign(r19A3, add(r19A7, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r19BB = lequal(body.constant(int(0)), r19A3);
                  ir_if *f19BA = new(mem_ctx) ir_if(operand(r19BB).val);
                  exec_list *const f19BA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f19BA->then_instructions;

                     body.emit(assign(r19A2, body.constant(0u), 0x01));

                     ir_variable *const r19BC = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r19BC, lshift(r19A1, r19A3), 0x01));

                     ir_variable *const r19BD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r19BF = equal(r19A3, body.constant(int(0)));
                     ir_if *f19BE = new(mem_ctx) ir_if(operand(r19BF).val);
                     exec_list *const f19BE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f19BE->then_instructions;

                        body.emit(assign(r19BD, r19A0, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f19BE->else_instructions;

                        ir_expression *const r19C0 = lshift(r19A0, r19A3);
                        ir_expression *const r19C1 = neg(r19A3);
                        ir_expression *const r19C2 = bit_and(r19C1, body.constant(int(31)));
                        ir_expression *const r19C3 = rshift(r19A1, r19C2);
                        body.emit(assign(r19BD, bit_or(r19C0, r19C3), 0x01));


                     body.instructions = f19BE_parent_instructions;
                     body.emit(f19BE);

                     /* END IF */

                     body.emit(assign(r19A0, r19BD, 0x01));

                     body.emit(assign(r19A1, r19BC, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f19BA->else_instructions;

                     ir_variable *const r19C4 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r19C4, body.constant(0u), 0x01));

                     ir_variable *const r19C5 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r19C5, neg(r19A3), 0x01));

                     ir_variable *const r19C6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r19C6);
                     ir_variable *const r19C7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r19C7);
                     ir_variable *const r19C8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r19C8);
                     ir_variable *const r19C9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r19CA = neg(r19C5);
                     body.emit(assign(r19C9, bit_and(r19CA, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r19CC = equal(r19C5, body.constant(int(0)));
                     ir_if *f19CB = new(mem_ctx) ir_if(operand(r19CC).val);
                     exec_list *const f19CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f19CB->then_instructions;

                        body.emit(assign(r19C6, r19C4, 0x01));

                        body.emit(assign(r19C7, r19A1, 0x01));

                        body.emit(assign(r19C8, r19A0, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f19CB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r19CE = less(r19C5, body.constant(int(32)));
                        ir_if *f19CD = new(mem_ctx) ir_if(operand(r19CE).val);
                        exec_list *const f19CD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f19CD->then_instructions;

                           body.emit(assign(r19C6, lshift(r19A1, r19C9), 0x01));

                           ir_expression *const r19CF = lshift(r19A0, r19C9);
                           ir_expression *const r19D0 = rshift(r19A1, r19C5);
                           body.emit(assign(r19C7, bit_or(r19CF, r19D0), 0x01));

                           body.emit(assign(r19C8, rshift(r19A0, r19C5), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f19CD->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r19D2 = equal(r19C5, body.constant(int(32)));
                           ir_if *f19D1 = new(mem_ctx) ir_if(operand(r19D2).val);
                           exec_list *const f19D1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f19D1->then_instructions;

                              body.emit(assign(r19C6, r19A1, 0x01));

                              body.emit(assign(r19C7, r19A0, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f19D1->else_instructions;

                              body.emit(assign(r19C4, bit_or(body.constant(0u), r19A1), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r19D4 = less(r19C5, body.constant(int(64)));
                              ir_if *f19D3 = new(mem_ctx) ir_if(operand(r19D4).val);
                              exec_list *const f19D3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f19D3->then_instructions;

                                 body.emit(assign(r19C6, lshift(r19A0, r19C9), 0x01));

                                 ir_expression *const r19D5 = bit_and(r19C5, body.constant(int(31)));
                                 body.emit(assign(r19C7, rshift(r19A0, r19D5), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f19D3->else_instructions;

                                 ir_variable *const r19D6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r19D8 = equal(r19C5, body.constant(int(64)));
                                 ir_if *f19D7 = new(mem_ctx) ir_if(operand(r19D8).val);
                                 exec_list *const f19D7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f19D7->then_instructions;

                                    body.emit(assign(r19D6, r19A0, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f19D7->else_instructions;

                                    ir_expression *const r19D9 = nequal(r19A0, body.constant(0u));
                                    ir_expression *const r19DA = expr(ir_unop_b2i, r19D9);
                                    body.emit(assign(r19D6, expr(ir_unop_i2u, r19DA), 0x01));


                                 body.instructions = f19D7_parent_instructions;
                                 body.emit(f19D7);

                                 /* END IF */

                                 body.emit(assign(r19C6, r19D6, 0x01));

                                 body.emit(assign(r19C7, body.constant(0u), 0x01));


                              body.instructions = f19D3_parent_instructions;
                              body.emit(f19D3);

                              /* END IF */


                           body.instructions = f19D1_parent_instructions;
                           body.emit(f19D1);

                           /* END IF */

                           body.emit(assign(r19C8, body.constant(0u), 0x01));


                        body.instructions = f19CD_parent_instructions;
                        body.emit(f19CD);

                        /* END IF */

                        ir_expression *const r19DB = nequal(r19C4, body.constant(0u));
                        ir_expression *const r19DC = expr(ir_unop_b2i, r19DB);
                        ir_expression *const r19DD = expr(ir_unop_i2u, r19DC);
                        body.emit(assign(r19C6, bit_or(r19C6, r19DD), 0x01));


                     body.instructions = f19CB_parent_instructions;
                     body.emit(f19CB);

                     /* END IF */

                     body.emit(assign(r19A0, r19C8, 0x01));

                     body.emit(assign(r19A1, r19C7, 0x01));

                     body.emit(assign(r19A2, r19C6, 0x01));


                  body.instructions = f19BA_parent_instructions;
                  body.emit(f19BA);

                  /* END IF */

                  body.emit(assign(r199F, sub(r199F, r19A3), 0x01));

                  ir_variable *const r19DE = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r19DE, r199F, 0x01));

                  ir_variable *const r19DF = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r19DF, r19A0, 0x01));

                  ir_variable *const r19E0 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r19E0, r19A1, 0x01));

                  ir_variable *const r19E1 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r19E1, r19A2, 0x01));

                  ir_variable *const r19E2 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r19E2, body.constant(true), 0x01));

                  ir_variable *const r19E3 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r19E4 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r19E4);
                  ir_expression *const r19E5 = expr(ir_unop_u2i, r19A2);
                  body.emit(assign(r19E4, less(r19E5, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r19E7 = lequal(body.constant(int(2045)), r199F);
                  ir_if *f19E6 = new(mem_ctx) ir_if(operand(r19E7).val);
                  exec_list *const f19E6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f19E6->then_instructions;

                     ir_variable *const r19E8 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r19EA = less(body.constant(int(2045)), r199F);
                     ir_if *f19E9 = new(mem_ctx) ir_if(operand(r19EA).val);
                     exec_list *const f19E9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f19E9->then_instructions;

                        body.emit(assign(r19E8, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f19E9->else_instructions;

                        ir_variable *const r19EB = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r19ED = equal(r199F, body.constant(int(2045)));
                        ir_if *f19EC = new(mem_ctx) ir_if(operand(r19ED).val);
                        exec_list *const f19EC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f19EC->then_instructions;

                           ir_expression *const r19EE = equal(body.constant(2097151u), r19A0);
                           ir_expression *const r19EF = equal(body.constant(4294967295u), r19A1);
                           body.emit(assign(r19EB, logic_and(r19EE, r19EF), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f19EC->else_instructions;

                           body.emit(assign(r19EB, body.constant(false), 0x01));


                        body.instructions = f19EC_parent_instructions;
                        body.emit(f19EC);

                        /* END IF */

                        body.emit(assign(r19E8, logic_and(r19EB, r19E4), 0x01));


                     body.instructions = f19E9_parent_instructions;
                     body.emit(f19E9);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f19F0 = new(mem_ctx) ir_if(operand(r19E8).val);
                     exec_list *const f19F0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f19F0->then_instructions;

                        ir_variable *const r19F1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r19F1);
                        ir_expression *const r19F2 = lshift(r187B, body.constant(int(31)));
                        body.emit(assign(r19F1, add(r19F2, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r19F1, body.constant(0u), 0x01));

                        body.emit(assign(r19E3, r19F1, 0x03));

                        body.emit(assign(r19E2, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f19F0->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r19F4 = less(r199F, body.constant(int(0)));
                        ir_if *f19F3 = new(mem_ctx) ir_if(operand(r19F4).val);
                        exec_list *const f19F3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f19F3->then_instructions;

                           ir_variable *const r19F5 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r19F5, r19A2, 0x01));

                           ir_variable *const r19F6 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r19F6, neg(r199F), 0x01));

                           ir_variable *const r19F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r19F7);
                           ir_variable *const r19F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r19F8);
                           ir_variable *const r19F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r19F9);
                           ir_variable *const r19FA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r19FB = neg(r19F6);
                           body.emit(assign(r19FA, bit_and(r19FB, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r19FD = equal(r19F6, body.constant(int(0)));
                           ir_if *f19FC = new(mem_ctx) ir_if(operand(r19FD).val);
                           exec_list *const f19FC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f19FC->then_instructions;

                              body.emit(assign(r19F7, r19A2, 0x01));

                              body.emit(assign(r19F8, r19A1, 0x01));

                              body.emit(assign(r19F9, r19A0, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f19FC->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r19FF = less(r19F6, body.constant(int(32)));
                              ir_if *f19FE = new(mem_ctx) ir_if(operand(r19FF).val);
                              exec_list *const f19FE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f19FE->then_instructions;

                                 body.emit(assign(r19F7, lshift(r19A1, r19FA), 0x01));

                                 ir_expression *const r1A00 = lshift(r19A0, r19FA);
                                 ir_expression *const r1A01 = rshift(r19A1, r19F6);
                                 body.emit(assign(r19F8, bit_or(r1A00, r1A01), 0x01));

                                 body.emit(assign(r19F9, rshift(r19A0, r19F6), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f19FE->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1A03 = equal(r19F6, body.constant(int(32)));
                                 ir_if *f1A02 = new(mem_ctx) ir_if(operand(r1A03).val);
                                 exec_list *const f1A02_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1A02->then_instructions;

                                    body.emit(assign(r19F7, r19A1, 0x01));

                                    body.emit(assign(r19F8, r19A0, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1A02->else_instructions;

                                    body.emit(assign(r19F5, bit_or(r19A2, r19A1), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r1A05 = less(r19F6, body.constant(int(64)));
                                    ir_if *f1A04 = new(mem_ctx) ir_if(operand(r1A05).val);
                                    exec_list *const f1A04_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1A04->then_instructions;

                                       body.emit(assign(r19F7, lshift(r19A0, r19FA), 0x01));

                                       ir_expression *const r1A06 = bit_and(r19F6, body.constant(int(31)));
                                       body.emit(assign(r19F8, rshift(r19A0, r1A06), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1A04->else_instructions;

                                       ir_variable *const r1A07 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r1A09 = equal(r19F6, body.constant(int(64)));
                                       ir_if *f1A08 = new(mem_ctx) ir_if(operand(r1A09).val);
                                       exec_list *const f1A08_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1A08->then_instructions;

                                          body.emit(assign(r1A07, r19A0, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1A08->else_instructions;

                                          ir_expression *const r1A0A = nequal(r19A0, body.constant(0u));
                                          ir_expression *const r1A0B = expr(ir_unop_b2i, r1A0A);
                                          body.emit(assign(r1A07, expr(ir_unop_i2u, r1A0B), 0x01));


                                       body.instructions = f1A08_parent_instructions;
                                       body.emit(f1A08);

                                       /* END IF */

                                       body.emit(assign(r19F7, r1A07, 0x01));

                                       body.emit(assign(r19F8, body.constant(0u), 0x01));


                                    body.instructions = f1A04_parent_instructions;
                                    body.emit(f1A04);

                                    /* END IF */


                                 body.instructions = f1A02_parent_instructions;
                                 body.emit(f1A02);

                                 /* END IF */

                                 body.emit(assign(r19F9, body.constant(0u), 0x01));


                              body.instructions = f19FE_parent_instructions;
                              body.emit(f19FE);

                              /* END IF */

                              ir_expression *const r1A0C = nequal(r19F5, body.constant(0u));
                              ir_expression *const r1A0D = expr(ir_unop_b2i, r1A0C);
                              ir_expression *const r1A0E = expr(ir_unop_i2u, r1A0D);
                              body.emit(assign(r19F7, bit_or(r19F7, r1A0E), 0x01));


                           body.instructions = f19FC_parent_instructions;
                           body.emit(f19FC);

                           /* END IF */

                           body.emit(assign(r19DF, r19F9, 0x01));

                           body.emit(assign(r19E0, r19F8, 0x01));

                           body.emit(assign(r19E1, r19F7, 0x01));

                           body.emit(assign(r19DE, body.constant(int(0)), 0x01));

                           body.emit(assign(r19E4, less(r19F7, body.constant(0u)), 0x01));


                        body.instructions = f19F3_parent_instructions;
                        body.emit(f19F3);

                        /* END IF */


                     body.instructions = f19F0_parent_instructions;
                     body.emit(f19F0);

                     /* END IF */


                  body.instructions = f19E6_parent_instructions;
                  body.emit(f19E6);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1A0F = new(mem_ctx) ir_if(operand(r19E2).val);
                  exec_list *const f1A0F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1A0F->then_instructions;

                     /* IF CONDITION */
                     ir_if *f1A10 = new(mem_ctx) ir_if(operand(r19E4).val);
                     exec_list *const f1A10_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1A10->then_instructions;

                        ir_variable *const r1A11 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r1A11, add(r19E0, body.constant(1u)), 0x01));

                        ir_expression *const r1A12 = less(r1A11, r19E0);
                        ir_expression *const r1A13 = expr(ir_unop_b2i, r1A12);
                        ir_expression *const r1A14 = expr(ir_unop_i2u, r1A13);
                        body.emit(assign(r19DF, add(r19DF, r1A14), 0x01));

                        ir_expression *const r1A15 = equal(r19E1, body.constant(0u));
                        ir_expression *const r1A16 = expr(ir_unop_b2i, r1A15);
                        ir_expression *const r1A17 = expr(ir_unop_i2u, r1A16);
                        ir_expression *const r1A18 = add(r19E1, r1A17);
                        ir_expression *const r1A19 = bit_and(r1A18, body.constant(1u));
                        ir_expression *const r1A1A = expr(ir_unop_bit_not, r1A19);
                        body.emit(assign(r19E0, bit_and(r1A11, r1A1A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1A10->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1A1C = bit_or(r19DF, r19E0);
                        ir_expression *const r1A1D = equal(r1A1C, body.constant(0u));
                        ir_if *f1A1B = new(mem_ctx) ir_if(operand(r1A1D).val);
                        exec_list *const f1A1B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1A1B->then_instructions;

                           body.emit(assign(r19DE, body.constant(int(0)), 0x01));


                        body.instructions = f1A1B_parent_instructions;
                        body.emit(f1A1B);

                        /* END IF */


                     body.instructions = f1A10_parent_instructions;
                     body.emit(f1A10);

                     /* END IF */

                     ir_variable *const r1A1E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1A1E);
                     ir_expression *const r1A1F = lshift(r187B, body.constant(int(31)));
                     ir_expression *const r1A20 = expr(ir_unop_i2u, r19DE);
                     ir_expression *const r1A21 = lshift(r1A20, body.constant(int(20)));
                     ir_expression *const r1A22 = add(r1A1F, r1A21);
                     body.emit(assign(r1A1E, add(r1A22, r19DF), 0x02));

                     body.emit(assign(r1A1E, r19E0, 0x01));

                     body.emit(assign(r19E3, r1A1E, 0x03));

                     body.emit(assign(r19E2, body.constant(false), 0x01));


                  body.instructions = f1A0F_parent_instructions;
                  body.emit(f1A0F);

                  /* END IF */

                  body.emit(assign(r187C, r19E3, 0x03));


               body.instructions = f1957_parent_instructions;
               body.emit(f1957);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1955->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1A24 = equal(r1885, body.constant(int(2047)));
               ir_if *f1A23 = new(mem_ctx) ir_if(operand(r1A24).val);
               exec_list *const f1A23_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1A23->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1A26 = bit_or(r1882, r1883);
                  ir_expression *const r1A27 = bit_or(r1880, r1881);
                  ir_expression *const r1A28 = bit_or(r1A26, r1A27);
                  ir_expression *const r1A29 = nequal(r1A28, body.constant(0u));
                  ir_if *f1A25 = new(mem_ctx) ir_if(operand(r1A29).val);
                  exec_list *const f1A25_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1A25->then_instructions;

                     ir_variable *const r1A2A = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r1A2A, swizzle_x(r16AC), 0x01));

                     ir_variable *const r1A2B = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r1A2B, body.constant(0u), 0x01));

                     ir_variable *const r1A2C = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1A2D = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r1A2E = rshift(swizzle_y(r16AC), body.constant(int(19)));
                     ir_expression *const r1A2F = bit_and(r1A2E, body.constant(4095u));
                     ir_expression *const r1A30 = equal(r1A2F, body.constant(4094u));
                     ir_expression *const r1A31 = nequal(swizzle_x(r16AC), body.constant(0u));
                     ir_expression *const r1A32 = bit_and(swizzle_y(r16AC), body.constant(524287u));
                     ir_expression *const r1A33 = nequal(r1A32, body.constant(0u));
                     ir_expression *const r1A34 = logic_or(r1A31, r1A33);
                     body.emit(assign(r1A2D, logic_and(r1A30, r1A34), 0x01));

                     ir_variable *const r1A35 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r1A35, body.constant(false), 0x01));

                     body.emit(assign(r1A2A, bit_or(swizzle_y(r16AC), body.constant(524288u)), 0x02));

                     body.emit(assign(r1A2B, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r1A37 = lshift(swizzle_y(r16AC), body.constant(int(1)));
                     ir_expression *const r1A38 = lequal(body.constant(4292870144u), r1A37);
                     ir_expression *const r1A39 = nequal(swizzle_x(r16AC), body.constant(0u));
                     ir_expression *const r1A3A = bit_and(swizzle_y(r16AC), body.constant(1048575u));
                     ir_expression *const r1A3B = nequal(r1A3A, body.constant(0u));
                     ir_expression *const r1A3C = logic_or(r1A39, r1A3B);
                     ir_expression *const r1A3D = logic_and(r1A38, r1A3C);
                     ir_if *f1A36 = new(mem_ctx) ir_if(operand(r1A3D).val);
                     exec_list *const f1A36_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1A36->then_instructions;

                        ir_variable *const r1A3E = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r1A40 = body.constant(false);
                        ir_if *f1A3F = new(mem_ctx) ir_if(operand(r1A40).val);
                        exec_list *const f1A3F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1A3F->then_instructions;

                           body.emit(assign(r1A3E, r1A2B, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1A3F->else_instructions;

                           body.emit(assign(r1A3E, r1A2A, 0x03));


                        body.instructions = f1A3F_parent_instructions;
                        body.emit(f1A3F);

                        /* END IF */

                        body.emit(assign(r1A2C, r1A3E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1A36->else_instructions;

                        body.emit(assign(r1A2C, r1A2B, 0x03));


                     body.instructions = f1A36_parent_instructions;
                     body.emit(f1A36);

                     /* END IF */

                     body.emit(assign(r187C, r1A2C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1A25->else_instructions;

                     ir_constant_data r1A41_data;
                     memset(&r1A41_data, 0, sizeof(ir_constant_data));
                     r1A41_data.u[0] = 4294967295;
                     r1A41_data.u[1] = 4294967295;
                     ir_constant *const r1A41 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r1A41_data);
                     body.emit(assign(r187C, r1A41, 0x03));


                  body.instructions = f1A25_parent_instructions;
                  body.emit(f1A25);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1A23->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1A43 = equal(r1885, body.constant(int(0)));
                  ir_if *f1A42 = new(mem_ctx) ir_if(operand(r1A43).val);
                  exec_list *const f1A42_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1A42->then_instructions;

                     body.emit(assign(r187F, body.constant(int(1)), 0x01));

                     body.emit(assign(r187E, body.constant(int(1)), 0x01));


                  body.instructions = f1A42_parent_instructions;
                  body.emit(f1A42);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1A45 = less(r1880, r1882);
                  ir_if *f1A44 = new(mem_ctx) ir_if(operand(r1A45).val);
                  exec_list *const f1A44_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1A44->then_instructions;

                     ir_variable *const r1A46 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r1A47 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r1A47, sub(r1883, r1881), 0x01));

                     ir_expression *const r1A48 = sub(r1882, r1880);
                     ir_expression *const r1A49 = less(r1883, r1881);
                     ir_expression *const r1A4A = expr(ir_unop_b2i, r1A49);
                     ir_expression *const r1A4B = expr(ir_unop_i2u, r1A4A);
                     body.emit(assign(r1A46, sub(r1A48, r1A4B), 0x01));

                     body.emit(assign(r1884, add(r187F, body.constant(int(-1))), 0x01));

                     ir_variable *const r1A4C = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1A4C, add(r1884, body.constant(int(-10))), 0x01));

                     ir_variable *const r1A4D = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1A4D, r1A46, 0x01));

                     ir_variable *const r1A4E = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1A4E, r1A47, 0x01));

                     ir_variable *const r1A4F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r1A4F);
                     ir_variable *const r1A50 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1A50);
                     /* IF CONDITION */
                     ir_expression *const r1A52 = equal(r1A46, body.constant(0u));
                     ir_if *f1A51 = new(mem_ctx) ir_if(operand(r1A52).val);
                     exec_list *const f1A51_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1A51->then_instructions;

                        body.emit(assign(r1A4D, r1A47, 0x01));

                        body.emit(assign(r1A4E, body.constant(0u), 0x01));

                        body.emit(assign(r1A4C, add(r1A4C, body.constant(int(-32))), 0x01));


                     body.instructions = f1A51_parent_instructions;
                     body.emit(f1A51);

                     /* END IF */

                     ir_variable *const r1A53 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1A53, r1A4D, 0x01));

                     ir_variable *const r1A54 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1A55 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1A55);
                     /* IF CONDITION */
                     ir_expression *const r1A57 = equal(r1A4D, body.constant(0u));
                     ir_if *f1A56 = new(mem_ctx) ir_if(operand(r1A57).val);
                     exec_list *const f1A56_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1A56->then_instructions;

                        body.emit(assign(r1A54, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1A56->else_instructions;

                        body.emit(assign(r1A55, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1A59 = bit_and(r1A4D, body.constant(4294901760u));
                        ir_expression *const r1A5A = equal(r1A59, body.constant(0u));
                        ir_if *f1A58 = new(mem_ctx) ir_if(operand(r1A5A).val);
                        exec_list *const f1A58_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1A58->then_instructions;

                           body.emit(assign(r1A55, body.constant(int(16)), 0x01));

                           body.emit(assign(r1A53, lshift(r1A4D, body.constant(int(16))), 0x01));


                        body.instructions = f1A58_parent_instructions;
                        body.emit(f1A58);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1A5C = bit_and(r1A53, body.constant(4278190080u));
                        ir_expression *const r1A5D = equal(r1A5C, body.constant(0u));
                        ir_if *f1A5B = new(mem_ctx) ir_if(operand(r1A5D).val);
                        exec_list *const f1A5B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1A5B->then_instructions;

                           body.emit(assign(r1A55, add(r1A55, body.constant(int(8))), 0x01));

                           body.emit(assign(r1A53, lshift(r1A53, body.constant(int(8))), 0x01));


                        body.instructions = f1A5B_parent_instructions;
                        body.emit(f1A5B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1A5F = bit_and(r1A53, body.constant(4026531840u));
                        ir_expression *const r1A60 = equal(r1A5F, body.constant(0u));
                        ir_if *f1A5E = new(mem_ctx) ir_if(operand(r1A60).val);
                        exec_list *const f1A5E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1A5E->then_instructions;

                           body.emit(assign(r1A55, add(r1A55, body.constant(int(4))), 0x01));

                           body.emit(assign(r1A53, lshift(r1A53, body.constant(int(4))), 0x01));


                        body.instructions = f1A5E_parent_instructions;
                        body.emit(f1A5E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1A62 = bit_and(r1A53, body.constant(3221225472u));
                        ir_expression *const r1A63 = equal(r1A62, body.constant(0u));
                        ir_if *f1A61 = new(mem_ctx) ir_if(operand(r1A63).val);
                        exec_list *const f1A61_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1A61->then_instructions;

                           body.emit(assign(r1A55, add(r1A55, body.constant(int(2))), 0x01));

                           body.emit(assign(r1A53, lshift(r1A53, body.constant(int(2))), 0x01));


                        body.instructions = f1A61_parent_instructions;
                        body.emit(f1A61);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1A65 = bit_and(r1A53, body.constant(2147483648u));
                        ir_expression *const r1A66 = equal(r1A65, body.constant(0u));
                        ir_if *f1A64 = new(mem_ctx) ir_if(operand(r1A66).val);
                        exec_list *const f1A64_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1A64->then_instructions;

                           body.emit(assign(r1A55, add(r1A55, body.constant(int(1))), 0x01));


                        body.instructions = f1A64_parent_instructions;
                        body.emit(f1A64);

                        /* END IF */

                        body.emit(assign(r1A54, r1A55, 0x01));


                     body.instructions = f1A56_parent_instructions;
                     body.emit(f1A56);

                     /* END IF */

                     body.emit(assign(r1A50, add(r1A54, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1A68 = lequal(body.constant(int(0)), r1A50);
                     ir_if *f1A67 = new(mem_ctx) ir_if(operand(r1A68).val);
                     exec_list *const f1A67_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1A67->then_instructions;

                        body.emit(assign(r1A4F, body.constant(0u), 0x01));

                        ir_variable *const r1A69 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r1A69, lshift(r1A4E, r1A50), 0x01));

                        ir_variable *const r1A6A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1A6C = equal(r1A50, body.constant(int(0)));
                        ir_if *f1A6B = new(mem_ctx) ir_if(operand(r1A6C).val);
                        exec_list *const f1A6B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1A6B->then_instructions;

                           body.emit(assign(r1A6A, r1A4D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1A6B->else_instructions;

                           ir_expression *const r1A6D = lshift(r1A4D, r1A50);
                           ir_expression *const r1A6E = neg(r1A50);
                           ir_expression *const r1A6F = bit_and(r1A6E, body.constant(int(31)));
                           ir_expression *const r1A70 = rshift(r1A4E, r1A6F);
                           body.emit(assign(r1A6A, bit_or(r1A6D, r1A70), 0x01));


                        body.instructions = f1A6B_parent_instructions;
                        body.emit(f1A6B);

                        /* END IF */

                        body.emit(assign(r1A4D, r1A6A, 0x01));

                        body.emit(assign(r1A4E, r1A69, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1A67->else_instructions;

                        ir_variable *const r1A71 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1A71, body.constant(0u), 0x01));

                        ir_variable *const r1A72 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1A72, neg(r1A50), 0x01));

                        ir_variable *const r1A73 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1A73);
                        ir_variable *const r1A74 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1A74);
                        ir_variable *const r1A75 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1A75);
                        ir_variable *const r1A76 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1A77 = neg(r1A72);
                        body.emit(assign(r1A76, bit_and(r1A77, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1A79 = equal(r1A72, body.constant(int(0)));
                        ir_if *f1A78 = new(mem_ctx) ir_if(operand(r1A79).val);
                        exec_list *const f1A78_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1A78->then_instructions;

                           body.emit(assign(r1A73, r1A71, 0x01));

                           body.emit(assign(r1A74, r1A4E, 0x01));

                           body.emit(assign(r1A75, r1A4D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1A78->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1A7B = less(r1A72, body.constant(int(32)));
                           ir_if *f1A7A = new(mem_ctx) ir_if(operand(r1A7B).val);
                           exec_list *const f1A7A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1A7A->then_instructions;

                              body.emit(assign(r1A73, lshift(r1A4E, r1A76), 0x01));

                              ir_expression *const r1A7C = lshift(r1A4D, r1A76);
                              ir_expression *const r1A7D = rshift(r1A4E, r1A72);
                              body.emit(assign(r1A74, bit_or(r1A7C, r1A7D), 0x01));

                              body.emit(assign(r1A75, rshift(r1A4D, r1A72), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1A7A->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1A7F = equal(r1A72, body.constant(int(32)));
                              ir_if *f1A7E = new(mem_ctx) ir_if(operand(r1A7F).val);
                              exec_list *const f1A7E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1A7E->then_instructions;

                                 body.emit(assign(r1A73, r1A4E, 0x01));

                                 body.emit(assign(r1A74, r1A4D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1A7E->else_instructions;

                                 body.emit(assign(r1A71, bit_or(body.constant(0u), r1A4E), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1A81 = less(r1A72, body.constant(int(64)));
                                 ir_if *f1A80 = new(mem_ctx) ir_if(operand(r1A81).val);
                                 exec_list *const f1A80_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1A80->then_instructions;

                                    body.emit(assign(r1A73, lshift(r1A4D, r1A76), 0x01));

                                    ir_expression *const r1A82 = bit_and(r1A72, body.constant(int(31)));
                                    body.emit(assign(r1A74, rshift(r1A4D, r1A82), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1A80->else_instructions;

                                    ir_variable *const r1A83 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1A85 = equal(r1A72, body.constant(int(64)));
                                    ir_if *f1A84 = new(mem_ctx) ir_if(operand(r1A85).val);
                                    exec_list *const f1A84_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1A84->then_instructions;

                                       body.emit(assign(r1A83, r1A4D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1A84->else_instructions;

                                       ir_expression *const r1A86 = nequal(r1A4D, body.constant(0u));
                                       ir_expression *const r1A87 = expr(ir_unop_b2i, r1A86);
                                       body.emit(assign(r1A83, expr(ir_unop_i2u, r1A87), 0x01));


                                    body.instructions = f1A84_parent_instructions;
                                    body.emit(f1A84);

                                    /* END IF */

                                    body.emit(assign(r1A73, r1A83, 0x01));

                                    body.emit(assign(r1A74, body.constant(0u), 0x01));


                                 body.instructions = f1A80_parent_instructions;
                                 body.emit(f1A80);

                                 /* END IF */


                              body.instructions = f1A7E_parent_instructions;
                              body.emit(f1A7E);

                              /* END IF */

                              body.emit(assign(r1A75, body.constant(0u), 0x01));


                           body.instructions = f1A7A_parent_instructions;
                           body.emit(f1A7A);

                           /* END IF */

                           ir_expression *const r1A88 = nequal(r1A71, body.constant(0u));
                           ir_expression *const r1A89 = expr(ir_unop_b2i, r1A88);
                           ir_expression *const r1A8A = expr(ir_unop_i2u, r1A89);
                           body.emit(assign(r1A73, bit_or(r1A73, r1A8A), 0x01));


                        body.instructions = f1A78_parent_instructions;
                        body.emit(f1A78);

                        /* END IF */

                        body.emit(assign(r1A4D, r1A75, 0x01));

                        body.emit(assign(r1A4E, r1A74, 0x01));

                        body.emit(assign(r1A4F, r1A73, 0x01));


                     body.instructions = f1A67_parent_instructions;
                     body.emit(f1A67);

                     /* END IF */

                     body.emit(assign(r1A4C, sub(r1A4C, r1A50), 0x01));

                     ir_variable *const r1A8B = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1A8B, r1A4C, 0x01));

                     ir_variable *const r1A8C = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1A8C, r1A4D, 0x01));

                     ir_variable *const r1A8D = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1A8D, r1A4E, 0x01));

                     ir_variable *const r1A8E = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r1A8E, r1A4F, 0x01));

                     ir_variable *const r1A8F = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r1A8F, body.constant(true), 0x01));

                     ir_variable *const r1A90 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1A91 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r1A91);
                     ir_expression *const r1A92 = expr(ir_unop_u2i, r1A4F);
                     body.emit(assign(r1A91, less(r1A92, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1A94 = lequal(body.constant(int(2045)), r1A4C);
                     ir_if *f1A93 = new(mem_ctx) ir_if(operand(r1A94).val);
                     exec_list *const f1A93_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1A93->then_instructions;

                        ir_variable *const r1A95 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1A97 = less(body.constant(int(2045)), r1A4C);
                        ir_if *f1A96 = new(mem_ctx) ir_if(operand(r1A97).val);
                        exec_list *const f1A96_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1A96->then_instructions;

                           body.emit(assign(r1A95, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1A96->else_instructions;

                           ir_variable *const r1A98 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1A9A = equal(r1A4C, body.constant(int(2045)));
                           ir_if *f1A99 = new(mem_ctx) ir_if(operand(r1A9A).val);
                           exec_list *const f1A99_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1A99->then_instructions;

                              ir_expression *const r1A9B = equal(body.constant(2097151u), r1A4D);
                              ir_expression *const r1A9C = equal(body.constant(4294967295u), r1A4E);
                              body.emit(assign(r1A98, logic_and(r1A9B, r1A9C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1A99->else_instructions;

                              body.emit(assign(r1A98, body.constant(false), 0x01));


                           body.instructions = f1A99_parent_instructions;
                           body.emit(f1A99);

                           /* END IF */

                           body.emit(assign(r1A95, logic_and(r1A98, r1A91), 0x01));


                        body.instructions = f1A96_parent_instructions;
                        body.emit(f1A96);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1A9D = new(mem_ctx) ir_if(operand(r1A95).val);
                        exec_list *const f1A9D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1A9D->then_instructions;

                           ir_variable *const r1A9E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1A9E);
                           ir_expression *const r1A9F = lshift(r187B, body.constant(int(31)));
                           body.emit(assign(r1A9E, add(r1A9F, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r1A9E, body.constant(0u), 0x01));

                           body.emit(assign(r1A90, r1A9E, 0x03));

                           body.emit(assign(r1A8F, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1A9D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1AA1 = less(r1A4C, body.constant(int(0)));
                           ir_if *f1AA0 = new(mem_ctx) ir_if(operand(r1AA1).val);
                           exec_list *const f1AA0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1AA0->then_instructions;

                              ir_variable *const r1AA2 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1AA2, r1A4F, 0x01));

                              ir_variable *const r1AA3 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1AA3, neg(r1A4C), 0x01));

                              ir_variable *const r1AA4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1AA4);
                              ir_variable *const r1AA5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1AA5);
                              ir_variable *const r1AA6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1AA6);
                              ir_variable *const r1AA7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1AA8 = neg(r1AA3);
                              body.emit(assign(r1AA7, bit_and(r1AA8, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1AAA = equal(r1AA3, body.constant(int(0)));
                              ir_if *f1AA9 = new(mem_ctx) ir_if(operand(r1AAA).val);
                              exec_list *const f1AA9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1AA9->then_instructions;

                                 body.emit(assign(r1AA4, r1A4F, 0x01));

                                 body.emit(assign(r1AA5, r1A4E, 0x01));

                                 body.emit(assign(r1AA6, r1A4D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1AA9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1AAC = less(r1AA3, body.constant(int(32)));
                                 ir_if *f1AAB = new(mem_ctx) ir_if(operand(r1AAC).val);
                                 exec_list *const f1AAB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1AAB->then_instructions;

                                    body.emit(assign(r1AA4, lshift(r1A4E, r1AA7), 0x01));

                                    ir_expression *const r1AAD = lshift(r1A4D, r1AA7);
                                    ir_expression *const r1AAE = rshift(r1A4E, r1AA3);
                                    body.emit(assign(r1AA5, bit_or(r1AAD, r1AAE), 0x01));

                                    body.emit(assign(r1AA6, rshift(r1A4D, r1AA3), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1AAB->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1AB0 = equal(r1AA3, body.constant(int(32)));
                                    ir_if *f1AAF = new(mem_ctx) ir_if(operand(r1AB0).val);
                                    exec_list *const f1AAF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1AAF->then_instructions;

                                       body.emit(assign(r1AA4, r1A4E, 0x01));

                                       body.emit(assign(r1AA5, r1A4D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1AAF->else_instructions;

                                       body.emit(assign(r1AA2, bit_or(r1A4F, r1A4E), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1AB2 = less(r1AA3, body.constant(int(64)));
                                       ir_if *f1AB1 = new(mem_ctx) ir_if(operand(r1AB2).val);
                                       exec_list *const f1AB1_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1AB1->then_instructions;

                                          body.emit(assign(r1AA4, lshift(r1A4D, r1AA7), 0x01));

                                          ir_expression *const r1AB3 = bit_and(r1AA3, body.constant(int(31)));
                                          body.emit(assign(r1AA5, rshift(r1A4D, r1AB3), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1AB1->else_instructions;

                                          ir_variable *const r1AB4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1AB6 = equal(r1AA3, body.constant(int(64)));
                                          ir_if *f1AB5 = new(mem_ctx) ir_if(operand(r1AB6).val);
                                          exec_list *const f1AB5_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1AB5->then_instructions;

                                             body.emit(assign(r1AB4, r1A4D, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1AB5->else_instructions;

                                             ir_expression *const r1AB7 = nequal(r1A4D, body.constant(0u));
                                             ir_expression *const r1AB8 = expr(ir_unop_b2i, r1AB7);
                                             body.emit(assign(r1AB4, expr(ir_unop_i2u, r1AB8), 0x01));


                                          body.instructions = f1AB5_parent_instructions;
                                          body.emit(f1AB5);

                                          /* END IF */

                                          body.emit(assign(r1AA4, r1AB4, 0x01));

                                          body.emit(assign(r1AA5, body.constant(0u), 0x01));


                                       body.instructions = f1AB1_parent_instructions;
                                       body.emit(f1AB1);

                                       /* END IF */


                                    body.instructions = f1AAF_parent_instructions;
                                    body.emit(f1AAF);

                                    /* END IF */

                                    body.emit(assign(r1AA6, body.constant(0u), 0x01));


                                 body.instructions = f1AAB_parent_instructions;
                                 body.emit(f1AAB);

                                 /* END IF */

                                 ir_expression *const r1AB9 = nequal(r1AA2, body.constant(0u));
                                 ir_expression *const r1ABA = expr(ir_unop_b2i, r1AB9);
                                 ir_expression *const r1ABB = expr(ir_unop_i2u, r1ABA);
                                 body.emit(assign(r1AA4, bit_or(r1AA4, r1ABB), 0x01));


                              body.instructions = f1AA9_parent_instructions;
                              body.emit(f1AA9);

                              /* END IF */

                              body.emit(assign(r1A8C, r1AA6, 0x01));

                              body.emit(assign(r1A8D, r1AA5, 0x01));

                              body.emit(assign(r1A8E, r1AA4, 0x01));

                              body.emit(assign(r1A8B, body.constant(int(0)), 0x01));

                              body.emit(assign(r1A91, less(r1AA4, body.constant(0u)), 0x01));


                           body.instructions = f1AA0_parent_instructions;
                           body.emit(f1AA0);

                           /* END IF */


                        body.instructions = f1A9D_parent_instructions;
                        body.emit(f1A9D);

                        /* END IF */


                     body.instructions = f1A93_parent_instructions;
                     body.emit(f1A93);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f1ABC = new(mem_ctx) ir_if(operand(r1A8F).val);
                     exec_list *const f1ABC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1ABC->then_instructions;

                        /* IF CONDITION */
                        ir_if *f1ABD = new(mem_ctx) ir_if(operand(r1A91).val);
                        exec_list *const f1ABD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1ABD->then_instructions;

                           ir_variable *const r1ABE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r1ABE, add(r1A8D, body.constant(1u)), 0x01));

                           ir_expression *const r1ABF = less(r1ABE, r1A8D);
                           ir_expression *const r1AC0 = expr(ir_unop_b2i, r1ABF);
                           ir_expression *const r1AC1 = expr(ir_unop_i2u, r1AC0);
                           body.emit(assign(r1A8C, add(r1A8C, r1AC1), 0x01));

                           ir_expression *const r1AC2 = equal(r1A8E, body.constant(0u));
                           ir_expression *const r1AC3 = expr(ir_unop_b2i, r1AC2);
                           ir_expression *const r1AC4 = expr(ir_unop_i2u, r1AC3);
                           ir_expression *const r1AC5 = add(r1A8E, r1AC4);
                           ir_expression *const r1AC6 = bit_and(r1AC5, body.constant(1u));
                           ir_expression *const r1AC7 = expr(ir_unop_bit_not, r1AC6);
                           body.emit(assign(r1A8D, bit_and(r1ABE, r1AC7), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1ABD->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1AC9 = bit_or(r1A8C, r1A8D);
                           ir_expression *const r1ACA = equal(r1AC9, body.constant(0u));
                           ir_if *f1AC8 = new(mem_ctx) ir_if(operand(r1ACA).val);
                           exec_list *const f1AC8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1AC8->then_instructions;

                              body.emit(assign(r1A8B, body.constant(int(0)), 0x01));


                           body.instructions = f1AC8_parent_instructions;
                           body.emit(f1AC8);

                           /* END IF */


                        body.instructions = f1ABD_parent_instructions;
                        body.emit(f1ABD);

                        /* END IF */

                        ir_variable *const r1ACB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r1ACB);
                        ir_expression *const r1ACC = lshift(r187B, body.constant(int(31)));
                        ir_expression *const r1ACD = expr(ir_unop_i2u, r1A8B);
                        ir_expression *const r1ACE = lshift(r1ACD, body.constant(int(20)));
                        ir_expression *const r1ACF = add(r1ACC, r1ACE);
                        body.emit(assign(r1ACB, add(r1ACF, r1A8C), 0x02));

                        body.emit(assign(r1ACB, r1A8D, 0x01));

                        body.emit(assign(r1A90, r1ACB, 0x03));

                        body.emit(assign(r1A8F, body.constant(false), 0x01));


                     body.instructions = f1ABC_parent_instructions;
                     body.emit(f1ABC);

                     /* END IF */

                     body.emit(assign(r187C, r1A90, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1A44->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1AD1 = less(r1882, r1880);
                     ir_if *f1AD0 = new(mem_ctx) ir_if(operand(r1AD1).val);
                     exec_list *const f1AD0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1AD0->then_instructions;

                        ir_variable *const r1AD2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r1AD3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r1AD3, sub(r1881, r1883), 0x01));

                        ir_expression *const r1AD4 = sub(r1880, r1882);
                        ir_expression *const r1AD5 = less(r1881, r1883);
                        ir_expression *const r1AD6 = expr(ir_unop_b2i, r1AD5);
                        ir_expression *const r1AD7 = expr(ir_unop_i2u, r1AD6);
                        body.emit(assign(r1AD2, sub(r1AD4, r1AD7), 0x01));

                        body.emit(assign(r187B, bit_xor(r187B, body.constant(1u)), 0x01));

                        body.emit(assign(r1884, add(r187E, body.constant(int(-1))), 0x01));

                        ir_variable *const r1AD8 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r1AD8, add(r1884, body.constant(int(-10))), 0x01));

                        ir_variable *const r1AD9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r1AD9, r1AD2, 0x01));

                        ir_variable *const r1ADA = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r1ADA, r1AD3, 0x01));

                        ir_variable *const r1ADB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r1ADB);
                        ir_variable *const r1ADC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r1ADC);
                        /* IF CONDITION */
                        ir_expression *const r1ADE = equal(r1AD2, body.constant(0u));
                        ir_if *f1ADD = new(mem_ctx) ir_if(operand(r1ADE).val);
                        exec_list *const f1ADD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1ADD->then_instructions;

                           body.emit(assign(r1AD9, r1AD3, 0x01));

                           body.emit(assign(r1ADA, body.constant(0u), 0x01));

                           body.emit(assign(r1AD8, add(r1AD8, body.constant(int(-32))), 0x01));


                        body.instructions = f1ADD_parent_instructions;
                        body.emit(f1ADD);

                        /* END IF */

                        ir_variable *const r1ADF = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r1ADF, r1AD9, 0x01));

                        ir_variable *const r1AE0 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r1AE1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r1AE1);
                        /* IF CONDITION */
                        ir_expression *const r1AE3 = equal(r1AD9, body.constant(0u));
                        ir_if *f1AE2 = new(mem_ctx) ir_if(operand(r1AE3).val);
                        exec_list *const f1AE2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1AE2->then_instructions;

                           body.emit(assign(r1AE0, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1AE2->else_instructions;

                           body.emit(assign(r1AE1, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1AE5 = bit_and(r1AD9, body.constant(4294901760u));
                           ir_expression *const r1AE6 = equal(r1AE5, body.constant(0u));
                           ir_if *f1AE4 = new(mem_ctx) ir_if(operand(r1AE6).val);
                           exec_list *const f1AE4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1AE4->then_instructions;

                              body.emit(assign(r1AE1, body.constant(int(16)), 0x01));

                              body.emit(assign(r1ADF, lshift(r1AD9, body.constant(int(16))), 0x01));


                           body.instructions = f1AE4_parent_instructions;
                           body.emit(f1AE4);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1AE8 = bit_and(r1ADF, body.constant(4278190080u));
                           ir_expression *const r1AE9 = equal(r1AE8, body.constant(0u));
                           ir_if *f1AE7 = new(mem_ctx) ir_if(operand(r1AE9).val);
                           exec_list *const f1AE7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1AE7->then_instructions;

                              body.emit(assign(r1AE1, add(r1AE1, body.constant(int(8))), 0x01));

                              body.emit(assign(r1ADF, lshift(r1ADF, body.constant(int(8))), 0x01));


                           body.instructions = f1AE7_parent_instructions;
                           body.emit(f1AE7);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1AEB = bit_and(r1ADF, body.constant(4026531840u));
                           ir_expression *const r1AEC = equal(r1AEB, body.constant(0u));
                           ir_if *f1AEA = new(mem_ctx) ir_if(operand(r1AEC).val);
                           exec_list *const f1AEA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1AEA->then_instructions;

                              body.emit(assign(r1AE1, add(r1AE1, body.constant(int(4))), 0x01));

                              body.emit(assign(r1ADF, lshift(r1ADF, body.constant(int(4))), 0x01));


                           body.instructions = f1AEA_parent_instructions;
                           body.emit(f1AEA);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1AEE = bit_and(r1ADF, body.constant(3221225472u));
                           ir_expression *const r1AEF = equal(r1AEE, body.constant(0u));
                           ir_if *f1AED = new(mem_ctx) ir_if(operand(r1AEF).val);
                           exec_list *const f1AED_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1AED->then_instructions;

                              body.emit(assign(r1AE1, add(r1AE1, body.constant(int(2))), 0x01));

                              body.emit(assign(r1ADF, lshift(r1ADF, body.constant(int(2))), 0x01));


                           body.instructions = f1AED_parent_instructions;
                           body.emit(f1AED);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1AF1 = bit_and(r1ADF, body.constant(2147483648u));
                           ir_expression *const r1AF2 = equal(r1AF1, body.constant(0u));
                           ir_if *f1AF0 = new(mem_ctx) ir_if(operand(r1AF2).val);
                           exec_list *const f1AF0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1AF0->then_instructions;

                              body.emit(assign(r1AE1, add(r1AE1, body.constant(int(1))), 0x01));


                           body.instructions = f1AF0_parent_instructions;
                           body.emit(f1AF0);

                           /* END IF */

                           body.emit(assign(r1AE0, r1AE1, 0x01));


                        body.instructions = f1AE2_parent_instructions;
                        body.emit(f1AE2);

                        /* END IF */

                        body.emit(assign(r1ADC, add(r1AE0, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1AF4 = lequal(body.constant(int(0)), r1ADC);
                        ir_if *f1AF3 = new(mem_ctx) ir_if(operand(r1AF4).val);
                        exec_list *const f1AF3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1AF3->then_instructions;

                           body.emit(assign(r1ADB, body.constant(0u), 0x01));

                           ir_variable *const r1AF5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r1AF5, lshift(r1ADA, r1ADC), 0x01));

                           ir_variable *const r1AF6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1AF8 = equal(r1ADC, body.constant(int(0)));
                           ir_if *f1AF7 = new(mem_ctx) ir_if(operand(r1AF8).val);
                           exec_list *const f1AF7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1AF7->then_instructions;

                              body.emit(assign(r1AF6, r1AD9, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1AF7->else_instructions;

                              ir_expression *const r1AF9 = lshift(r1AD9, r1ADC);
                              ir_expression *const r1AFA = neg(r1ADC);
                              ir_expression *const r1AFB = bit_and(r1AFA, body.constant(int(31)));
                              ir_expression *const r1AFC = rshift(r1ADA, r1AFB);
                              body.emit(assign(r1AF6, bit_or(r1AF9, r1AFC), 0x01));


                           body.instructions = f1AF7_parent_instructions;
                           body.emit(f1AF7);

                           /* END IF */

                           body.emit(assign(r1AD9, r1AF6, 0x01));

                           body.emit(assign(r1ADA, r1AF5, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1AF3->else_instructions;

                           ir_variable *const r1AFD = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r1AFD, body.constant(0u), 0x01));

                           ir_variable *const r1AFE = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r1AFE, neg(r1ADC), 0x01));

                           ir_variable *const r1AFF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r1AFF);
                           ir_variable *const r1B00 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r1B00);
                           ir_variable *const r1B01 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r1B01);
                           ir_variable *const r1B02 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r1B03 = neg(r1AFE);
                           body.emit(assign(r1B02, bit_and(r1B03, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1B05 = equal(r1AFE, body.constant(int(0)));
                           ir_if *f1B04 = new(mem_ctx) ir_if(operand(r1B05).val);
                           exec_list *const f1B04_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1B04->then_instructions;

                              body.emit(assign(r1AFF, r1AFD, 0x01));

                              body.emit(assign(r1B00, r1ADA, 0x01));

                              body.emit(assign(r1B01, r1AD9, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1B04->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1B07 = less(r1AFE, body.constant(int(32)));
                              ir_if *f1B06 = new(mem_ctx) ir_if(operand(r1B07).val);
                              exec_list *const f1B06_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1B06->then_instructions;

                                 body.emit(assign(r1AFF, lshift(r1ADA, r1B02), 0x01));

                                 ir_expression *const r1B08 = lshift(r1AD9, r1B02);
                                 ir_expression *const r1B09 = rshift(r1ADA, r1AFE);
                                 body.emit(assign(r1B00, bit_or(r1B08, r1B09), 0x01));

                                 body.emit(assign(r1B01, rshift(r1AD9, r1AFE), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1B06->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1B0B = equal(r1AFE, body.constant(int(32)));
                                 ir_if *f1B0A = new(mem_ctx) ir_if(operand(r1B0B).val);
                                 exec_list *const f1B0A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1B0A->then_instructions;

                                    body.emit(assign(r1AFF, r1ADA, 0x01));

                                    body.emit(assign(r1B00, r1AD9, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1B0A->else_instructions;

                                    body.emit(assign(r1AFD, bit_or(body.constant(0u), r1ADA), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r1B0D = less(r1AFE, body.constant(int(64)));
                                    ir_if *f1B0C = new(mem_ctx) ir_if(operand(r1B0D).val);
                                    exec_list *const f1B0C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1B0C->then_instructions;

                                       body.emit(assign(r1AFF, lshift(r1AD9, r1B02), 0x01));

                                       ir_expression *const r1B0E = bit_and(r1AFE, body.constant(int(31)));
                                       body.emit(assign(r1B00, rshift(r1AD9, r1B0E), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1B0C->else_instructions;

                                       ir_variable *const r1B0F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r1B11 = equal(r1AFE, body.constant(int(64)));
                                       ir_if *f1B10 = new(mem_ctx) ir_if(operand(r1B11).val);
                                       exec_list *const f1B10_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1B10->then_instructions;

                                          body.emit(assign(r1B0F, r1AD9, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1B10->else_instructions;

                                          ir_expression *const r1B12 = nequal(r1AD9, body.constant(0u));
                                          ir_expression *const r1B13 = expr(ir_unop_b2i, r1B12);
                                          body.emit(assign(r1B0F, expr(ir_unop_i2u, r1B13), 0x01));


                                       body.instructions = f1B10_parent_instructions;
                                       body.emit(f1B10);

                                       /* END IF */

                                       body.emit(assign(r1AFF, r1B0F, 0x01));

                                       body.emit(assign(r1B00, body.constant(0u), 0x01));


                                    body.instructions = f1B0C_parent_instructions;
                                    body.emit(f1B0C);

                                    /* END IF */


                                 body.instructions = f1B0A_parent_instructions;
                                 body.emit(f1B0A);

                                 /* END IF */

                                 body.emit(assign(r1B01, body.constant(0u), 0x01));


                              body.instructions = f1B06_parent_instructions;
                              body.emit(f1B06);

                              /* END IF */

                              ir_expression *const r1B14 = nequal(r1AFD, body.constant(0u));
                              ir_expression *const r1B15 = expr(ir_unop_b2i, r1B14);
                              ir_expression *const r1B16 = expr(ir_unop_i2u, r1B15);
                              body.emit(assign(r1AFF, bit_or(r1AFF, r1B16), 0x01));


                           body.instructions = f1B04_parent_instructions;
                           body.emit(f1B04);

                           /* END IF */

                           body.emit(assign(r1AD9, r1B01, 0x01));

                           body.emit(assign(r1ADA, r1B00, 0x01));

                           body.emit(assign(r1ADB, r1AFF, 0x01));


                        body.instructions = f1AF3_parent_instructions;
                        body.emit(f1AF3);

                        /* END IF */

                        body.emit(assign(r1AD8, sub(r1AD8, r1ADC), 0x01));

                        ir_variable *const r1B17 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r1B17, r1AD8, 0x01));

                        ir_variable *const r1B18 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r1B18, r1AD9, 0x01));

                        ir_variable *const r1B19 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r1B19, r1ADA, 0x01));

                        ir_variable *const r1B1A = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r1B1A, r1ADB, 0x01));

                        ir_variable *const r1B1B = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r1B1B, body.constant(true), 0x01));

                        ir_variable *const r1B1C = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r1B1D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r1B1D);
                        ir_expression *const r1B1E = expr(ir_unop_u2i, r1ADB);
                        body.emit(assign(r1B1D, less(r1B1E, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1B20 = lequal(body.constant(int(2045)), r1AD8);
                        ir_if *f1B1F = new(mem_ctx) ir_if(operand(r1B20).val);
                        exec_list *const f1B1F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1B1F->then_instructions;

                           ir_variable *const r1B21 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1B23 = less(body.constant(int(2045)), r1AD8);
                           ir_if *f1B22 = new(mem_ctx) ir_if(operand(r1B23).val);
                           exec_list *const f1B22_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1B22->then_instructions;

                              body.emit(assign(r1B21, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1B22->else_instructions;

                              ir_variable *const r1B24 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1B26 = equal(r1AD8, body.constant(int(2045)));
                              ir_if *f1B25 = new(mem_ctx) ir_if(operand(r1B26).val);
                              exec_list *const f1B25_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1B25->then_instructions;

                                 ir_expression *const r1B27 = equal(body.constant(2097151u), r1AD9);
                                 ir_expression *const r1B28 = equal(body.constant(4294967295u), r1ADA);
                                 body.emit(assign(r1B24, logic_and(r1B27, r1B28), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1B25->else_instructions;

                                 body.emit(assign(r1B24, body.constant(false), 0x01));


                              body.instructions = f1B25_parent_instructions;
                              body.emit(f1B25);

                              /* END IF */

                              body.emit(assign(r1B21, logic_and(r1B24, r1B1D), 0x01));


                           body.instructions = f1B22_parent_instructions;
                           body.emit(f1B22);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f1B29 = new(mem_ctx) ir_if(operand(r1B21).val);
                           exec_list *const f1B29_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1B29->then_instructions;

                              ir_variable *const r1B2A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r1B2A);
                              ir_expression *const r1B2B = lshift(r187B, body.constant(int(31)));
                              body.emit(assign(r1B2A, add(r1B2B, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r1B2A, body.constant(0u), 0x01));

                              body.emit(assign(r1B1C, r1B2A, 0x03));

                              body.emit(assign(r1B1B, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1B29->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1B2D = less(r1AD8, body.constant(int(0)));
                              ir_if *f1B2C = new(mem_ctx) ir_if(operand(r1B2D).val);
                              exec_list *const f1B2C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1B2C->then_instructions;

                                 ir_variable *const r1B2E = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r1B2E, r1ADB, 0x01));

                                 ir_variable *const r1B2F = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r1B2F, neg(r1AD8), 0x01));

                                 ir_variable *const r1B30 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r1B30);
                                 ir_variable *const r1B31 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r1B31);
                                 ir_variable *const r1B32 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r1B32);
                                 ir_variable *const r1B33 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r1B34 = neg(r1B2F);
                                 body.emit(assign(r1B33, bit_and(r1B34, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1B36 = equal(r1B2F, body.constant(int(0)));
                                 ir_if *f1B35 = new(mem_ctx) ir_if(operand(r1B36).val);
                                 exec_list *const f1B35_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1B35->then_instructions;

                                    body.emit(assign(r1B30, r1ADB, 0x01));

                                    body.emit(assign(r1B31, r1ADA, 0x01));

                                    body.emit(assign(r1B32, r1AD9, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1B35->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1B38 = less(r1B2F, body.constant(int(32)));
                                    ir_if *f1B37 = new(mem_ctx) ir_if(operand(r1B38).val);
                                    exec_list *const f1B37_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1B37->then_instructions;

                                       body.emit(assign(r1B30, lshift(r1ADA, r1B33), 0x01));

                                       ir_expression *const r1B39 = lshift(r1AD9, r1B33);
                                       ir_expression *const r1B3A = rshift(r1ADA, r1B2F);
                                       body.emit(assign(r1B31, bit_or(r1B39, r1B3A), 0x01));

                                       body.emit(assign(r1B32, rshift(r1AD9, r1B2F), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1B37->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r1B3C = equal(r1B2F, body.constant(int(32)));
                                       ir_if *f1B3B = new(mem_ctx) ir_if(operand(r1B3C).val);
                                       exec_list *const f1B3B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1B3B->then_instructions;

                                          body.emit(assign(r1B30, r1ADA, 0x01));

                                          body.emit(assign(r1B31, r1AD9, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1B3B->else_instructions;

                                          body.emit(assign(r1B2E, bit_or(r1ADB, r1ADA), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r1B3E = less(r1B2F, body.constant(int(64)));
                                          ir_if *f1B3D = new(mem_ctx) ir_if(operand(r1B3E).val);
                                          exec_list *const f1B3D_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1B3D->then_instructions;

                                             body.emit(assign(r1B30, lshift(r1AD9, r1B33), 0x01));

                                             ir_expression *const r1B3F = bit_and(r1B2F, body.constant(int(31)));
                                             body.emit(assign(r1B31, rshift(r1AD9, r1B3F), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1B3D->else_instructions;

                                             ir_variable *const r1B40 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r1B42 = equal(r1B2F, body.constant(int(64)));
                                             ir_if *f1B41 = new(mem_ctx) ir_if(operand(r1B42).val);
                                             exec_list *const f1B41_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1B41->then_instructions;

                                                body.emit(assign(r1B40, r1AD9, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1B41->else_instructions;

                                                ir_expression *const r1B43 = nequal(r1AD9, body.constant(0u));
                                                ir_expression *const r1B44 = expr(ir_unop_b2i, r1B43);
                                                body.emit(assign(r1B40, expr(ir_unop_i2u, r1B44), 0x01));


                                             body.instructions = f1B41_parent_instructions;
                                             body.emit(f1B41);

                                             /* END IF */

                                             body.emit(assign(r1B30, r1B40, 0x01));

                                             body.emit(assign(r1B31, body.constant(0u), 0x01));


                                          body.instructions = f1B3D_parent_instructions;
                                          body.emit(f1B3D);

                                          /* END IF */


                                       body.instructions = f1B3B_parent_instructions;
                                       body.emit(f1B3B);

                                       /* END IF */

                                       body.emit(assign(r1B32, body.constant(0u), 0x01));


                                    body.instructions = f1B37_parent_instructions;
                                    body.emit(f1B37);

                                    /* END IF */

                                    ir_expression *const r1B45 = nequal(r1B2E, body.constant(0u));
                                    ir_expression *const r1B46 = expr(ir_unop_b2i, r1B45);
                                    ir_expression *const r1B47 = expr(ir_unop_i2u, r1B46);
                                    body.emit(assign(r1B30, bit_or(r1B30, r1B47), 0x01));


                                 body.instructions = f1B35_parent_instructions;
                                 body.emit(f1B35);

                                 /* END IF */

                                 body.emit(assign(r1B18, r1B32, 0x01));

                                 body.emit(assign(r1B19, r1B31, 0x01));

                                 body.emit(assign(r1B1A, r1B30, 0x01));

                                 body.emit(assign(r1B17, body.constant(int(0)), 0x01));

                                 body.emit(assign(r1B1D, less(r1B30, body.constant(0u)), 0x01));


                              body.instructions = f1B2C_parent_instructions;
                              body.emit(f1B2C);

                              /* END IF */


                           body.instructions = f1B29_parent_instructions;
                           body.emit(f1B29);

                           /* END IF */


                        body.instructions = f1B1F_parent_instructions;
                        body.emit(f1B1F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1B48 = new(mem_ctx) ir_if(operand(r1B1B).val);
                        exec_list *const f1B48_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1B48->then_instructions;

                           /* IF CONDITION */
                           ir_if *f1B49 = new(mem_ctx) ir_if(operand(r1B1D).val);
                           exec_list *const f1B49_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1B49->then_instructions;

                              ir_variable *const r1B4A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r1B4A, add(r1B19, body.constant(1u)), 0x01));

                              ir_expression *const r1B4B = less(r1B4A, r1B19);
                              ir_expression *const r1B4C = expr(ir_unop_b2i, r1B4B);
                              ir_expression *const r1B4D = expr(ir_unop_i2u, r1B4C);
                              body.emit(assign(r1B18, add(r1B18, r1B4D), 0x01));

                              ir_expression *const r1B4E = equal(r1B1A, body.constant(0u));
                              ir_expression *const r1B4F = expr(ir_unop_b2i, r1B4E);
                              ir_expression *const r1B50 = expr(ir_unop_i2u, r1B4F);
                              ir_expression *const r1B51 = add(r1B1A, r1B50);
                              ir_expression *const r1B52 = bit_and(r1B51, body.constant(1u));
                              ir_expression *const r1B53 = expr(ir_unop_bit_not, r1B52);
                              body.emit(assign(r1B19, bit_and(r1B4A, r1B53), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1B49->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1B55 = bit_or(r1B18, r1B19);
                              ir_expression *const r1B56 = equal(r1B55, body.constant(0u));
                              ir_if *f1B54 = new(mem_ctx) ir_if(operand(r1B56).val);
                              exec_list *const f1B54_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1B54->then_instructions;

                                 body.emit(assign(r1B17, body.constant(int(0)), 0x01));


                              body.instructions = f1B54_parent_instructions;
                              body.emit(f1B54);

                              /* END IF */


                           body.instructions = f1B49_parent_instructions;
                           body.emit(f1B49);

                           /* END IF */

                           ir_variable *const r1B57 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1B57);
                           ir_expression *const r1B58 = lshift(r187B, body.constant(int(31)));
                           ir_expression *const r1B59 = expr(ir_unop_i2u, r1B17);
                           ir_expression *const r1B5A = lshift(r1B59, body.constant(int(20)));
                           ir_expression *const r1B5B = add(r1B58, r1B5A);
                           body.emit(assign(r1B57, add(r1B5B, r1B18), 0x02));

                           body.emit(assign(r1B57, r1B19, 0x01));

                           body.emit(assign(r1B1C, r1B57, 0x03));

                           body.emit(assign(r1B1B, body.constant(false), 0x01));


                        body.instructions = f1B48_parent_instructions;
                        body.emit(f1B48);

                        /* END IF */

                        body.emit(assign(r187C, r1B1C, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1AD0->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1B5D = less(r1881, r1883);
                        ir_if *f1B5C = new(mem_ctx) ir_if(operand(r1B5D).val);
                        exec_list *const f1B5C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1B5C->then_instructions;

                           ir_variable *const r1B5E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r1B5F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r1B5F, sub(r1883, r1881), 0x01));

                           ir_expression *const r1B60 = sub(r1882, r1880);
                           ir_expression *const r1B61 = less(r1883, r1881);
                           ir_expression *const r1B62 = expr(ir_unop_b2i, r1B61);
                           ir_expression *const r1B63 = expr(ir_unop_i2u, r1B62);
                           body.emit(assign(r1B5E, sub(r1B60, r1B63), 0x01));

                           body.emit(assign(r1884, add(r187F, body.constant(int(-1))), 0x01));

                           ir_variable *const r1B64 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r1B64, add(r1884, body.constant(int(-10))), 0x01));

                           ir_variable *const r1B65 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r1B65, r1B5E, 0x01));

                           ir_variable *const r1B66 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r1B66, r1B5F, 0x01));

                           ir_variable *const r1B67 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r1B67);
                           ir_variable *const r1B68 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r1B68);
                           /* IF CONDITION */
                           ir_expression *const r1B6A = equal(r1B5E, body.constant(0u));
                           ir_if *f1B69 = new(mem_ctx) ir_if(operand(r1B6A).val);
                           exec_list *const f1B69_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1B69->then_instructions;

                              body.emit(assign(r1B65, r1B5F, 0x01));

                              body.emit(assign(r1B66, body.constant(0u), 0x01));

                              body.emit(assign(r1B64, add(r1B64, body.constant(int(-32))), 0x01));


                           body.instructions = f1B69_parent_instructions;
                           body.emit(f1B69);

                           /* END IF */

                           ir_variable *const r1B6B = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r1B6B, r1B65, 0x01));

                           ir_variable *const r1B6C = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r1B6D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r1B6D);
                           /* IF CONDITION */
                           ir_expression *const r1B6F = equal(r1B65, body.constant(0u));
                           ir_if *f1B6E = new(mem_ctx) ir_if(operand(r1B6F).val);
                           exec_list *const f1B6E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1B6E->then_instructions;

                              body.emit(assign(r1B6C, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1B6E->else_instructions;

                              body.emit(assign(r1B6D, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1B71 = bit_and(r1B65, body.constant(4294901760u));
                              ir_expression *const r1B72 = equal(r1B71, body.constant(0u));
                              ir_if *f1B70 = new(mem_ctx) ir_if(operand(r1B72).val);
                              exec_list *const f1B70_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1B70->then_instructions;

                                 body.emit(assign(r1B6D, body.constant(int(16)), 0x01));

                                 body.emit(assign(r1B6B, lshift(r1B65, body.constant(int(16))), 0x01));


                              body.instructions = f1B70_parent_instructions;
                              body.emit(f1B70);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1B74 = bit_and(r1B6B, body.constant(4278190080u));
                              ir_expression *const r1B75 = equal(r1B74, body.constant(0u));
                              ir_if *f1B73 = new(mem_ctx) ir_if(operand(r1B75).val);
                              exec_list *const f1B73_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1B73->then_instructions;

                                 body.emit(assign(r1B6D, add(r1B6D, body.constant(int(8))), 0x01));

                                 body.emit(assign(r1B6B, lshift(r1B6B, body.constant(int(8))), 0x01));


                              body.instructions = f1B73_parent_instructions;
                              body.emit(f1B73);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1B77 = bit_and(r1B6B, body.constant(4026531840u));
                              ir_expression *const r1B78 = equal(r1B77, body.constant(0u));
                              ir_if *f1B76 = new(mem_ctx) ir_if(operand(r1B78).val);
                              exec_list *const f1B76_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1B76->then_instructions;

                                 body.emit(assign(r1B6D, add(r1B6D, body.constant(int(4))), 0x01));

                                 body.emit(assign(r1B6B, lshift(r1B6B, body.constant(int(4))), 0x01));


                              body.instructions = f1B76_parent_instructions;
                              body.emit(f1B76);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1B7A = bit_and(r1B6B, body.constant(3221225472u));
                              ir_expression *const r1B7B = equal(r1B7A, body.constant(0u));
                              ir_if *f1B79 = new(mem_ctx) ir_if(operand(r1B7B).val);
                              exec_list *const f1B79_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1B79->then_instructions;

                                 body.emit(assign(r1B6D, add(r1B6D, body.constant(int(2))), 0x01));

                                 body.emit(assign(r1B6B, lshift(r1B6B, body.constant(int(2))), 0x01));


                              body.instructions = f1B79_parent_instructions;
                              body.emit(f1B79);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1B7D = bit_and(r1B6B, body.constant(2147483648u));
                              ir_expression *const r1B7E = equal(r1B7D, body.constant(0u));
                              ir_if *f1B7C = new(mem_ctx) ir_if(operand(r1B7E).val);
                              exec_list *const f1B7C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1B7C->then_instructions;

                                 body.emit(assign(r1B6D, add(r1B6D, body.constant(int(1))), 0x01));


                              body.instructions = f1B7C_parent_instructions;
                              body.emit(f1B7C);

                              /* END IF */

                              body.emit(assign(r1B6C, r1B6D, 0x01));


                           body.instructions = f1B6E_parent_instructions;
                           body.emit(f1B6E);

                           /* END IF */

                           body.emit(assign(r1B68, add(r1B6C, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1B80 = lequal(body.constant(int(0)), r1B68);
                           ir_if *f1B7F = new(mem_ctx) ir_if(operand(r1B80).val);
                           exec_list *const f1B7F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1B7F->then_instructions;

                              body.emit(assign(r1B67, body.constant(0u), 0x01));

                              ir_variable *const r1B81 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r1B81, lshift(r1B66, r1B68), 0x01));

                              ir_variable *const r1B82 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1B84 = equal(r1B68, body.constant(int(0)));
                              ir_if *f1B83 = new(mem_ctx) ir_if(operand(r1B84).val);
                              exec_list *const f1B83_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1B83->then_instructions;

                                 body.emit(assign(r1B82, r1B65, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1B83->else_instructions;

                                 ir_expression *const r1B85 = lshift(r1B65, r1B68);
                                 ir_expression *const r1B86 = neg(r1B68);
                                 ir_expression *const r1B87 = bit_and(r1B86, body.constant(int(31)));
                                 ir_expression *const r1B88 = rshift(r1B66, r1B87);
                                 body.emit(assign(r1B82, bit_or(r1B85, r1B88), 0x01));


                              body.instructions = f1B83_parent_instructions;
                              body.emit(f1B83);

                              /* END IF */

                              body.emit(assign(r1B65, r1B82, 0x01));

                              body.emit(assign(r1B66, r1B81, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1B7F->else_instructions;

                              ir_variable *const r1B89 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1B89, body.constant(0u), 0x01));

                              ir_variable *const r1B8A = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1B8A, neg(r1B68), 0x01));

                              ir_variable *const r1B8B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1B8B);
                              ir_variable *const r1B8C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1B8C);
                              ir_variable *const r1B8D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1B8D);
                              ir_variable *const r1B8E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1B8F = neg(r1B8A);
                              body.emit(assign(r1B8E, bit_and(r1B8F, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1B91 = equal(r1B8A, body.constant(int(0)));
                              ir_if *f1B90 = new(mem_ctx) ir_if(operand(r1B91).val);
                              exec_list *const f1B90_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1B90->then_instructions;

                                 body.emit(assign(r1B8B, r1B89, 0x01));

                                 body.emit(assign(r1B8C, r1B66, 0x01));

                                 body.emit(assign(r1B8D, r1B65, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1B90->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1B93 = less(r1B8A, body.constant(int(32)));
                                 ir_if *f1B92 = new(mem_ctx) ir_if(operand(r1B93).val);
                                 exec_list *const f1B92_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1B92->then_instructions;

                                    body.emit(assign(r1B8B, lshift(r1B66, r1B8E), 0x01));

                                    ir_expression *const r1B94 = lshift(r1B65, r1B8E);
                                    ir_expression *const r1B95 = rshift(r1B66, r1B8A);
                                    body.emit(assign(r1B8C, bit_or(r1B94, r1B95), 0x01));

                                    body.emit(assign(r1B8D, rshift(r1B65, r1B8A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1B92->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1B97 = equal(r1B8A, body.constant(int(32)));
                                    ir_if *f1B96 = new(mem_ctx) ir_if(operand(r1B97).val);
                                    exec_list *const f1B96_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1B96->then_instructions;

                                       body.emit(assign(r1B8B, r1B66, 0x01));

                                       body.emit(assign(r1B8C, r1B65, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1B96->else_instructions;

                                       body.emit(assign(r1B89, bit_or(body.constant(0u), r1B66), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1B99 = less(r1B8A, body.constant(int(64)));
                                       ir_if *f1B98 = new(mem_ctx) ir_if(operand(r1B99).val);
                                       exec_list *const f1B98_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1B98->then_instructions;

                                          body.emit(assign(r1B8B, lshift(r1B65, r1B8E), 0x01));

                                          ir_expression *const r1B9A = bit_and(r1B8A, body.constant(int(31)));
                                          body.emit(assign(r1B8C, rshift(r1B65, r1B9A), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1B98->else_instructions;

                                          ir_variable *const r1B9B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1B9D = equal(r1B8A, body.constant(int(64)));
                                          ir_if *f1B9C = new(mem_ctx) ir_if(operand(r1B9D).val);
                                          exec_list *const f1B9C_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1B9C->then_instructions;

                                             body.emit(assign(r1B9B, r1B65, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1B9C->else_instructions;

                                             ir_expression *const r1B9E = nequal(r1B65, body.constant(0u));
                                             ir_expression *const r1B9F = expr(ir_unop_b2i, r1B9E);
                                             body.emit(assign(r1B9B, expr(ir_unop_i2u, r1B9F), 0x01));


                                          body.instructions = f1B9C_parent_instructions;
                                          body.emit(f1B9C);

                                          /* END IF */

                                          body.emit(assign(r1B8B, r1B9B, 0x01));

                                          body.emit(assign(r1B8C, body.constant(0u), 0x01));


                                       body.instructions = f1B98_parent_instructions;
                                       body.emit(f1B98);

                                       /* END IF */


                                    body.instructions = f1B96_parent_instructions;
                                    body.emit(f1B96);

                                    /* END IF */

                                    body.emit(assign(r1B8D, body.constant(0u), 0x01));


                                 body.instructions = f1B92_parent_instructions;
                                 body.emit(f1B92);

                                 /* END IF */

                                 ir_expression *const r1BA0 = nequal(r1B89, body.constant(0u));
                                 ir_expression *const r1BA1 = expr(ir_unop_b2i, r1BA0);
                                 ir_expression *const r1BA2 = expr(ir_unop_i2u, r1BA1);
                                 body.emit(assign(r1B8B, bit_or(r1B8B, r1BA2), 0x01));


                              body.instructions = f1B90_parent_instructions;
                              body.emit(f1B90);

                              /* END IF */

                              body.emit(assign(r1B65, r1B8D, 0x01));

                              body.emit(assign(r1B66, r1B8C, 0x01));

                              body.emit(assign(r1B67, r1B8B, 0x01));


                           body.instructions = f1B7F_parent_instructions;
                           body.emit(f1B7F);

                           /* END IF */

                           body.emit(assign(r1B64, sub(r1B64, r1B68), 0x01));

                           ir_variable *const r1BA3 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r1BA3, r1B64, 0x01));

                           ir_variable *const r1BA4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r1BA4, r1B65, 0x01));

                           ir_variable *const r1BA5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r1BA5, r1B66, 0x01));

                           ir_variable *const r1BA6 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r1BA6, r1B67, 0x01));

                           ir_variable *const r1BA7 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r1BA7, body.constant(true), 0x01));

                           ir_variable *const r1BA8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r1BA9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r1BA9);
                           ir_expression *const r1BAA = expr(ir_unop_u2i, r1B67);
                           body.emit(assign(r1BA9, less(r1BAA, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1BAC = lequal(body.constant(int(2045)), r1B64);
                           ir_if *f1BAB = new(mem_ctx) ir_if(operand(r1BAC).val);
                           exec_list *const f1BAB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1BAB->then_instructions;

                              ir_variable *const r1BAD = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1BAF = less(body.constant(int(2045)), r1B64);
                              ir_if *f1BAE = new(mem_ctx) ir_if(operand(r1BAF).val);
                              exec_list *const f1BAE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1BAE->then_instructions;

                                 body.emit(assign(r1BAD, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1BAE->else_instructions;

                                 ir_variable *const r1BB0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1BB2 = equal(r1B64, body.constant(int(2045)));
                                 ir_if *f1BB1 = new(mem_ctx) ir_if(operand(r1BB2).val);
                                 exec_list *const f1BB1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1BB1->then_instructions;

                                    ir_expression *const r1BB3 = equal(body.constant(2097151u), r1B65);
                                    ir_expression *const r1BB4 = equal(body.constant(4294967295u), r1B66);
                                    body.emit(assign(r1BB0, logic_and(r1BB3, r1BB4), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1BB1->else_instructions;

                                    body.emit(assign(r1BB0, body.constant(false), 0x01));


                                 body.instructions = f1BB1_parent_instructions;
                                 body.emit(f1BB1);

                                 /* END IF */

                                 body.emit(assign(r1BAD, logic_and(r1BB0, r1BA9), 0x01));


                              body.instructions = f1BAE_parent_instructions;
                              body.emit(f1BAE);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f1BB5 = new(mem_ctx) ir_if(operand(r1BAD).val);
                              exec_list *const f1BB5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1BB5->then_instructions;

                                 ir_variable *const r1BB6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r1BB6);
                                 ir_expression *const r1BB7 = lshift(r187B, body.constant(int(31)));
                                 body.emit(assign(r1BB6, add(r1BB7, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r1BB6, body.constant(0u), 0x01));

                                 body.emit(assign(r1BA8, r1BB6, 0x03));

                                 body.emit(assign(r1BA7, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1BB5->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1BB9 = less(r1B64, body.constant(int(0)));
                                 ir_if *f1BB8 = new(mem_ctx) ir_if(operand(r1BB9).val);
                                 exec_list *const f1BB8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1BB8->then_instructions;

                                    ir_variable *const r1BBA = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r1BBA, r1B67, 0x01));

                                    ir_variable *const r1BBB = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r1BBB, neg(r1B64), 0x01));

                                    ir_variable *const r1BBC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r1BBC);
                                    ir_variable *const r1BBD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r1BBD);
                                    ir_variable *const r1BBE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r1BBE);
                                    ir_variable *const r1BBF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r1BC0 = neg(r1BBB);
                                    body.emit(assign(r1BBF, bit_and(r1BC0, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r1BC2 = equal(r1BBB, body.constant(int(0)));
                                    ir_if *f1BC1 = new(mem_ctx) ir_if(operand(r1BC2).val);
                                    exec_list *const f1BC1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1BC1->then_instructions;

                                       body.emit(assign(r1BBC, r1B67, 0x01));

                                       body.emit(assign(r1BBD, r1B66, 0x01));

                                       body.emit(assign(r1BBE, r1B65, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1BC1->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r1BC4 = less(r1BBB, body.constant(int(32)));
                                       ir_if *f1BC3 = new(mem_ctx) ir_if(operand(r1BC4).val);
                                       exec_list *const f1BC3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1BC3->then_instructions;

                                          body.emit(assign(r1BBC, lshift(r1B66, r1BBF), 0x01));

                                          ir_expression *const r1BC5 = lshift(r1B65, r1BBF);
                                          ir_expression *const r1BC6 = rshift(r1B66, r1BBB);
                                          body.emit(assign(r1BBD, bit_or(r1BC5, r1BC6), 0x01));

                                          body.emit(assign(r1BBE, rshift(r1B65, r1BBB), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1BC3->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r1BC8 = equal(r1BBB, body.constant(int(32)));
                                          ir_if *f1BC7 = new(mem_ctx) ir_if(operand(r1BC8).val);
                                          exec_list *const f1BC7_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1BC7->then_instructions;

                                             body.emit(assign(r1BBC, r1B66, 0x01));

                                             body.emit(assign(r1BBD, r1B65, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1BC7->else_instructions;

                                             body.emit(assign(r1BBA, bit_or(r1B67, r1B66), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r1BCA = less(r1BBB, body.constant(int(64)));
                                             ir_if *f1BC9 = new(mem_ctx) ir_if(operand(r1BCA).val);
                                             exec_list *const f1BC9_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1BC9->then_instructions;

                                                body.emit(assign(r1BBC, lshift(r1B65, r1BBF), 0x01));

                                                ir_expression *const r1BCB = bit_and(r1BBB, body.constant(int(31)));
                                                body.emit(assign(r1BBD, rshift(r1B65, r1BCB), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1BC9->else_instructions;

                                                ir_variable *const r1BCC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r1BCE = equal(r1BBB, body.constant(int(64)));
                                                ir_if *f1BCD = new(mem_ctx) ir_if(operand(r1BCE).val);
                                                exec_list *const f1BCD_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f1BCD->then_instructions;

                                                   body.emit(assign(r1BCC, r1B65, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f1BCD->else_instructions;

                                                   ir_expression *const r1BCF = nequal(r1B65, body.constant(0u));
                                                   ir_expression *const r1BD0 = expr(ir_unop_b2i, r1BCF);
                                                   body.emit(assign(r1BCC, expr(ir_unop_i2u, r1BD0), 0x01));


                                                body.instructions = f1BCD_parent_instructions;
                                                body.emit(f1BCD);

                                                /* END IF */

                                                body.emit(assign(r1BBC, r1BCC, 0x01));

                                                body.emit(assign(r1BBD, body.constant(0u), 0x01));


                                             body.instructions = f1BC9_parent_instructions;
                                             body.emit(f1BC9);

                                             /* END IF */


                                          body.instructions = f1BC7_parent_instructions;
                                          body.emit(f1BC7);

                                          /* END IF */

                                          body.emit(assign(r1BBE, body.constant(0u), 0x01));


                                       body.instructions = f1BC3_parent_instructions;
                                       body.emit(f1BC3);

                                       /* END IF */

                                       ir_expression *const r1BD1 = nequal(r1BBA, body.constant(0u));
                                       ir_expression *const r1BD2 = expr(ir_unop_b2i, r1BD1);
                                       ir_expression *const r1BD3 = expr(ir_unop_i2u, r1BD2);
                                       body.emit(assign(r1BBC, bit_or(r1BBC, r1BD3), 0x01));


                                    body.instructions = f1BC1_parent_instructions;
                                    body.emit(f1BC1);

                                    /* END IF */

                                    body.emit(assign(r1BA4, r1BBE, 0x01));

                                    body.emit(assign(r1BA5, r1BBD, 0x01));

                                    body.emit(assign(r1BA6, r1BBC, 0x01));

                                    body.emit(assign(r1BA3, body.constant(int(0)), 0x01));

                                    body.emit(assign(r1BA9, less(r1BBC, body.constant(0u)), 0x01));


                                 body.instructions = f1BB8_parent_instructions;
                                 body.emit(f1BB8);

                                 /* END IF */


                              body.instructions = f1BB5_parent_instructions;
                              body.emit(f1BB5);

                              /* END IF */


                           body.instructions = f1BAB_parent_instructions;
                           body.emit(f1BAB);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f1BD4 = new(mem_ctx) ir_if(operand(r1BA7).val);
                           exec_list *const f1BD4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1BD4->then_instructions;

                              /* IF CONDITION */
                              ir_if *f1BD5 = new(mem_ctx) ir_if(operand(r1BA9).val);
                              exec_list *const f1BD5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1BD5->then_instructions;

                                 ir_variable *const r1BD6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r1BD6, add(r1BA5, body.constant(1u)), 0x01));

                                 ir_expression *const r1BD7 = less(r1BD6, r1BA5);
                                 ir_expression *const r1BD8 = expr(ir_unop_b2i, r1BD7);
                                 ir_expression *const r1BD9 = expr(ir_unop_i2u, r1BD8);
                                 body.emit(assign(r1BA4, add(r1BA4, r1BD9), 0x01));

                                 ir_expression *const r1BDA = equal(r1BA6, body.constant(0u));
                                 ir_expression *const r1BDB = expr(ir_unop_b2i, r1BDA);
                                 ir_expression *const r1BDC = expr(ir_unop_i2u, r1BDB);
                                 ir_expression *const r1BDD = add(r1BA6, r1BDC);
                                 ir_expression *const r1BDE = bit_and(r1BDD, body.constant(1u));
                                 ir_expression *const r1BDF = expr(ir_unop_bit_not, r1BDE);
                                 body.emit(assign(r1BA5, bit_and(r1BD6, r1BDF), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1BD5->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1BE1 = bit_or(r1BA4, r1BA5);
                                 ir_expression *const r1BE2 = equal(r1BE1, body.constant(0u));
                                 ir_if *f1BE0 = new(mem_ctx) ir_if(operand(r1BE2).val);
                                 exec_list *const f1BE0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1BE0->then_instructions;

                                    body.emit(assign(r1BA3, body.constant(int(0)), 0x01));


                                 body.instructions = f1BE0_parent_instructions;
                                 body.emit(f1BE0);

                                 /* END IF */


                              body.instructions = f1BD5_parent_instructions;
                              body.emit(f1BD5);

                              /* END IF */

                              ir_variable *const r1BE3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r1BE3);
                              ir_expression *const r1BE4 = lshift(r187B, body.constant(int(31)));
                              ir_expression *const r1BE5 = expr(ir_unop_i2u, r1BA3);
                              ir_expression *const r1BE6 = lshift(r1BE5, body.constant(int(20)));
                              ir_expression *const r1BE7 = add(r1BE4, r1BE6);
                              body.emit(assign(r1BE3, add(r1BE7, r1BA4), 0x02));

                              body.emit(assign(r1BE3, r1BA5, 0x01));

                              body.emit(assign(r1BA8, r1BE3, 0x03));

                              body.emit(assign(r1BA7, body.constant(false), 0x01));


                           body.instructions = f1BD4_parent_instructions;
                           body.emit(f1BD4);

                           /* END IF */

                           body.emit(assign(r187C, r1BA8, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1B5C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1BE9 = less(r1883, r1881);
                           ir_if *f1BE8 = new(mem_ctx) ir_if(operand(r1BE9).val);
                           exec_list *const f1BE8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1BE8->then_instructions;

                              ir_variable *const r1BEA = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r1BEB = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r1BEB, sub(r1881, r1883), 0x01));

                              ir_expression *const r1BEC = sub(r1880, r1882);
                              ir_expression *const r1BED = less(r1881, r1883);
                              ir_expression *const r1BEE = expr(ir_unop_b2i, r1BED);
                              ir_expression *const r1BEF = expr(ir_unop_i2u, r1BEE);
                              body.emit(assign(r1BEA, sub(r1BEC, r1BEF), 0x01));

                              body.emit(assign(r187B, bit_xor(r187B, body.constant(1u)), 0x01));

                              body.emit(assign(r1884, add(r187E, body.constant(int(-1))), 0x01));

                              ir_variable *const r1BF0 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r1BF0, add(r1884, body.constant(int(-10))), 0x01));

                              ir_variable *const r1BF1 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r1BF1, r1BEA, 0x01));

                              ir_variable *const r1BF2 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r1BF2, r1BEB, 0x01));

                              ir_variable *const r1BF3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r1BF3);
                              ir_variable *const r1BF4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r1BF4);
                              /* IF CONDITION */
                              ir_expression *const r1BF6 = equal(r1BEA, body.constant(0u));
                              ir_if *f1BF5 = new(mem_ctx) ir_if(operand(r1BF6).val);
                              exec_list *const f1BF5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1BF5->then_instructions;

                                 body.emit(assign(r1BF1, r1BEB, 0x01));

                                 body.emit(assign(r1BF2, body.constant(0u), 0x01));

                                 body.emit(assign(r1BF0, add(r1BF0, body.constant(int(-32))), 0x01));


                              body.instructions = f1BF5_parent_instructions;
                              body.emit(f1BF5);

                              /* END IF */

                              ir_variable *const r1BF7 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r1BF7, r1BF1, 0x01));

                              ir_variable *const r1BF8 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r1BF9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r1BF9);
                              /* IF CONDITION */
                              ir_expression *const r1BFB = equal(r1BF1, body.constant(0u));
                              ir_if *f1BFA = new(mem_ctx) ir_if(operand(r1BFB).val);
                              exec_list *const f1BFA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1BFA->then_instructions;

                                 body.emit(assign(r1BF8, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1BFA->else_instructions;

                                 body.emit(assign(r1BF9, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1BFD = bit_and(r1BF1, body.constant(4294901760u));
                                 ir_expression *const r1BFE = equal(r1BFD, body.constant(0u));
                                 ir_if *f1BFC = new(mem_ctx) ir_if(operand(r1BFE).val);
                                 exec_list *const f1BFC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1BFC->then_instructions;

                                    body.emit(assign(r1BF9, body.constant(int(16)), 0x01));

                                    body.emit(assign(r1BF7, lshift(r1BF1, body.constant(int(16))), 0x01));


                                 body.instructions = f1BFC_parent_instructions;
                                 body.emit(f1BFC);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1C00 = bit_and(r1BF7, body.constant(4278190080u));
                                 ir_expression *const r1C01 = equal(r1C00, body.constant(0u));
                                 ir_if *f1BFF = new(mem_ctx) ir_if(operand(r1C01).val);
                                 exec_list *const f1BFF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1BFF->then_instructions;

                                    body.emit(assign(r1BF9, add(r1BF9, body.constant(int(8))), 0x01));

                                    body.emit(assign(r1BF7, lshift(r1BF7, body.constant(int(8))), 0x01));


                                 body.instructions = f1BFF_parent_instructions;
                                 body.emit(f1BFF);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1C03 = bit_and(r1BF7, body.constant(4026531840u));
                                 ir_expression *const r1C04 = equal(r1C03, body.constant(0u));
                                 ir_if *f1C02 = new(mem_ctx) ir_if(operand(r1C04).val);
                                 exec_list *const f1C02_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1C02->then_instructions;

                                    body.emit(assign(r1BF9, add(r1BF9, body.constant(int(4))), 0x01));

                                    body.emit(assign(r1BF7, lshift(r1BF7, body.constant(int(4))), 0x01));


                                 body.instructions = f1C02_parent_instructions;
                                 body.emit(f1C02);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1C06 = bit_and(r1BF7, body.constant(3221225472u));
                                 ir_expression *const r1C07 = equal(r1C06, body.constant(0u));
                                 ir_if *f1C05 = new(mem_ctx) ir_if(operand(r1C07).val);
                                 exec_list *const f1C05_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1C05->then_instructions;

                                    body.emit(assign(r1BF9, add(r1BF9, body.constant(int(2))), 0x01));

                                    body.emit(assign(r1BF7, lshift(r1BF7, body.constant(int(2))), 0x01));


                                 body.instructions = f1C05_parent_instructions;
                                 body.emit(f1C05);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1C09 = bit_and(r1BF7, body.constant(2147483648u));
                                 ir_expression *const r1C0A = equal(r1C09, body.constant(0u));
                                 ir_if *f1C08 = new(mem_ctx) ir_if(operand(r1C0A).val);
                                 exec_list *const f1C08_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1C08->then_instructions;

                                    body.emit(assign(r1BF9, add(r1BF9, body.constant(int(1))), 0x01));


                                 body.instructions = f1C08_parent_instructions;
                                 body.emit(f1C08);

                                 /* END IF */

                                 body.emit(assign(r1BF8, r1BF9, 0x01));


                              body.instructions = f1BFA_parent_instructions;
                              body.emit(f1BFA);

                              /* END IF */

                              body.emit(assign(r1BF4, add(r1BF8, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1C0C = lequal(body.constant(int(0)), r1BF4);
                              ir_if *f1C0B = new(mem_ctx) ir_if(operand(r1C0C).val);
                              exec_list *const f1C0B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1C0B->then_instructions;

                                 body.emit(assign(r1BF3, body.constant(0u), 0x01));

                                 ir_variable *const r1C0D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r1C0D, lshift(r1BF2, r1BF4), 0x01));

                                 ir_variable *const r1C0E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1C10 = equal(r1BF4, body.constant(int(0)));
                                 ir_if *f1C0F = new(mem_ctx) ir_if(operand(r1C10).val);
                                 exec_list *const f1C0F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1C0F->then_instructions;

                                    body.emit(assign(r1C0E, r1BF1, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1C0F->else_instructions;

                                    ir_expression *const r1C11 = lshift(r1BF1, r1BF4);
                                    ir_expression *const r1C12 = neg(r1BF4);
                                    ir_expression *const r1C13 = bit_and(r1C12, body.constant(int(31)));
                                    ir_expression *const r1C14 = rshift(r1BF2, r1C13);
                                    body.emit(assign(r1C0E, bit_or(r1C11, r1C14), 0x01));


                                 body.instructions = f1C0F_parent_instructions;
                                 body.emit(f1C0F);

                                 /* END IF */

                                 body.emit(assign(r1BF1, r1C0E, 0x01));

                                 body.emit(assign(r1BF2, r1C0D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1C0B->else_instructions;

                                 ir_variable *const r1C15 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r1C15, body.constant(0u), 0x01));

                                 ir_variable *const r1C16 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r1C16, neg(r1BF4), 0x01));

                                 ir_variable *const r1C17 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r1C17);
                                 ir_variable *const r1C18 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r1C18);
                                 ir_variable *const r1C19 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r1C19);
                                 ir_variable *const r1C1A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r1C1B = neg(r1C16);
                                 body.emit(assign(r1C1A, bit_and(r1C1B, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1C1D = equal(r1C16, body.constant(int(0)));
                                 ir_if *f1C1C = new(mem_ctx) ir_if(operand(r1C1D).val);
                                 exec_list *const f1C1C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1C1C->then_instructions;

                                    body.emit(assign(r1C17, r1C15, 0x01));

                                    body.emit(assign(r1C18, r1BF2, 0x01));

                                    body.emit(assign(r1C19, r1BF1, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1C1C->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1C1F = less(r1C16, body.constant(int(32)));
                                    ir_if *f1C1E = new(mem_ctx) ir_if(operand(r1C1F).val);
                                    exec_list *const f1C1E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1C1E->then_instructions;

                                       body.emit(assign(r1C17, lshift(r1BF2, r1C1A), 0x01));

                                       ir_expression *const r1C20 = lshift(r1BF1, r1C1A);
                                       ir_expression *const r1C21 = rshift(r1BF2, r1C16);
                                       body.emit(assign(r1C18, bit_or(r1C20, r1C21), 0x01));

                                       body.emit(assign(r1C19, rshift(r1BF1, r1C16), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1C1E->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r1C23 = equal(r1C16, body.constant(int(32)));
                                       ir_if *f1C22 = new(mem_ctx) ir_if(operand(r1C23).val);
                                       exec_list *const f1C22_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1C22->then_instructions;

                                          body.emit(assign(r1C17, r1BF2, 0x01));

                                          body.emit(assign(r1C18, r1BF1, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1C22->else_instructions;

                                          body.emit(assign(r1C15, bit_or(body.constant(0u), r1BF2), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r1C25 = less(r1C16, body.constant(int(64)));
                                          ir_if *f1C24 = new(mem_ctx) ir_if(operand(r1C25).val);
                                          exec_list *const f1C24_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1C24->then_instructions;

                                             body.emit(assign(r1C17, lshift(r1BF1, r1C1A), 0x01));

                                             ir_expression *const r1C26 = bit_and(r1C16, body.constant(int(31)));
                                             body.emit(assign(r1C18, rshift(r1BF1, r1C26), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1C24->else_instructions;

                                             ir_variable *const r1C27 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r1C29 = equal(r1C16, body.constant(int(64)));
                                             ir_if *f1C28 = new(mem_ctx) ir_if(operand(r1C29).val);
                                             exec_list *const f1C28_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1C28->then_instructions;

                                                body.emit(assign(r1C27, r1BF1, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1C28->else_instructions;

                                                ir_expression *const r1C2A = nequal(r1BF1, body.constant(0u));
                                                ir_expression *const r1C2B = expr(ir_unop_b2i, r1C2A);
                                                body.emit(assign(r1C27, expr(ir_unop_i2u, r1C2B), 0x01));


                                             body.instructions = f1C28_parent_instructions;
                                             body.emit(f1C28);

                                             /* END IF */

                                             body.emit(assign(r1C17, r1C27, 0x01));

                                             body.emit(assign(r1C18, body.constant(0u), 0x01));


                                          body.instructions = f1C24_parent_instructions;
                                          body.emit(f1C24);

                                          /* END IF */


                                       body.instructions = f1C22_parent_instructions;
                                       body.emit(f1C22);

                                       /* END IF */

                                       body.emit(assign(r1C19, body.constant(0u), 0x01));


                                    body.instructions = f1C1E_parent_instructions;
                                    body.emit(f1C1E);

                                    /* END IF */

                                    ir_expression *const r1C2C = nequal(r1C15, body.constant(0u));
                                    ir_expression *const r1C2D = expr(ir_unop_b2i, r1C2C);
                                    ir_expression *const r1C2E = expr(ir_unop_i2u, r1C2D);
                                    body.emit(assign(r1C17, bit_or(r1C17, r1C2E), 0x01));


                                 body.instructions = f1C1C_parent_instructions;
                                 body.emit(f1C1C);

                                 /* END IF */

                                 body.emit(assign(r1BF1, r1C19, 0x01));

                                 body.emit(assign(r1BF2, r1C18, 0x01));

                                 body.emit(assign(r1BF3, r1C17, 0x01));


                              body.instructions = f1C0B_parent_instructions;
                              body.emit(f1C0B);

                              /* END IF */

                              body.emit(assign(r1BF0, sub(r1BF0, r1BF4), 0x01));

                              ir_variable *const r1C2F = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r1C2F, r1BF0, 0x01));

                              ir_variable *const r1C30 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r1C30, r1BF1, 0x01));

                              ir_variable *const r1C31 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r1C31, r1BF2, 0x01));

                              ir_variable *const r1C32 = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r1C32, r1BF3, 0x01));

                              ir_variable *const r1C33 = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r1C33, body.constant(true), 0x01));

                              ir_variable *const r1C34 = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r1C35 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r1C35);
                              ir_expression *const r1C36 = expr(ir_unop_u2i, r1BF3);
                              body.emit(assign(r1C35, less(r1C36, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1C38 = lequal(body.constant(int(2045)), r1BF0);
                              ir_if *f1C37 = new(mem_ctx) ir_if(operand(r1C38).val);
                              exec_list *const f1C37_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1C37->then_instructions;

                                 ir_variable *const r1C39 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1C3B = less(body.constant(int(2045)), r1BF0);
                                 ir_if *f1C3A = new(mem_ctx) ir_if(operand(r1C3B).val);
                                 exec_list *const f1C3A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1C3A->then_instructions;

                                    body.emit(assign(r1C39, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1C3A->else_instructions;

                                    ir_variable *const r1C3C = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1C3E = equal(r1BF0, body.constant(int(2045)));
                                    ir_if *f1C3D = new(mem_ctx) ir_if(operand(r1C3E).val);
                                    exec_list *const f1C3D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1C3D->then_instructions;

                                       ir_expression *const r1C3F = equal(body.constant(2097151u), r1BF1);
                                       ir_expression *const r1C40 = equal(body.constant(4294967295u), r1BF2);
                                       body.emit(assign(r1C3C, logic_and(r1C3F, r1C40), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1C3D->else_instructions;

                                       body.emit(assign(r1C3C, body.constant(false), 0x01));


                                    body.instructions = f1C3D_parent_instructions;
                                    body.emit(f1C3D);

                                    /* END IF */

                                    body.emit(assign(r1C39, logic_and(r1C3C, r1C35), 0x01));


                                 body.instructions = f1C3A_parent_instructions;
                                 body.emit(f1C3A);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f1C41 = new(mem_ctx) ir_if(operand(r1C39).val);
                                 exec_list *const f1C41_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1C41->then_instructions;

                                    ir_variable *const r1C42 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r1C42);
                                    ir_expression *const r1C43 = lshift(r187B, body.constant(int(31)));
                                    body.emit(assign(r1C42, add(r1C43, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r1C42, body.constant(0u), 0x01));

                                    body.emit(assign(r1C34, r1C42, 0x03));

                                    body.emit(assign(r1C33, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1C41->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1C45 = less(r1BF0, body.constant(int(0)));
                                    ir_if *f1C44 = new(mem_ctx) ir_if(operand(r1C45).val);
                                    exec_list *const f1C44_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1C44->then_instructions;

                                       ir_variable *const r1C46 = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r1C46, r1BF3, 0x01));

                                       ir_variable *const r1C47 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r1C47, neg(r1BF0), 0x01));

                                       ir_variable *const r1C48 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r1C48);
                                       ir_variable *const r1C49 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r1C49);
                                       ir_variable *const r1C4A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r1C4A);
                                       ir_variable *const r1C4B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r1C4C = neg(r1C47);
                                       body.emit(assign(r1C4B, bit_and(r1C4C, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1C4E = equal(r1C47, body.constant(int(0)));
                                       ir_if *f1C4D = new(mem_ctx) ir_if(operand(r1C4E).val);
                                       exec_list *const f1C4D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1C4D->then_instructions;

                                          body.emit(assign(r1C48, r1BF3, 0x01));

                                          body.emit(assign(r1C49, r1BF2, 0x01));

                                          body.emit(assign(r1C4A, r1BF1, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1C4D->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r1C50 = less(r1C47, body.constant(int(32)));
                                          ir_if *f1C4F = new(mem_ctx) ir_if(operand(r1C50).val);
                                          exec_list *const f1C4F_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1C4F->then_instructions;

                                             body.emit(assign(r1C48, lshift(r1BF2, r1C4B), 0x01));

                                             ir_expression *const r1C51 = lshift(r1BF1, r1C4B);
                                             ir_expression *const r1C52 = rshift(r1BF2, r1C47);
                                             body.emit(assign(r1C49, bit_or(r1C51, r1C52), 0x01));

                                             body.emit(assign(r1C4A, rshift(r1BF1, r1C47), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1C4F->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r1C54 = equal(r1C47, body.constant(int(32)));
                                             ir_if *f1C53 = new(mem_ctx) ir_if(operand(r1C54).val);
                                             exec_list *const f1C53_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1C53->then_instructions;

                                                body.emit(assign(r1C48, r1BF2, 0x01));

                                                body.emit(assign(r1C49, r1BF1, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1C53->else_instructions;

                                                body.emit(assign(r1C46, bit_or(r1BF3, r1BF2), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r1C56 = less(r1C47, body.constant(int(64)));
                                                ir_if *f1C55 = new(mem_ctx) ir_if(operand(r1C56).val);
                                                exec_list *const f1C55_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f1C55->then_instructions;

                                                   body.emit(assign(r1C48, lshift(r1BF1, r1C4B), 0x01));

                                                   ir_expression *const r1C57 = bit_and(r1C47, body.constant(int(31)));
                                                   body.emit(assign(r1C49, rshift(r1BF1, r1C57), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f1C55->else_instructions;

                                                   ir_variable *const r1C58 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r1C5A = equal(r1C47, body.constant(int(64)));
                                                   ir_if *f1C59 = new(mem_ctx) ir_if(operand(r1C5A).val);
                                                   exec_list *const f1C59_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f1C59->then_instructions;

                                                      body.emit(assign(r1C58, r1BF1, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f1C59->else_instructions;

                                                      ir_expression *const r1C5B = nequal(r1BF1, body.constant(0u));
                                                      ir_expression *const r1C5C = expr(ir_unop_b2i, r1C5B);
                                                      body.emit(assign(r1C58, expr(ir_unop_i2u, r1C5C), 0x01));


                                                   body.instructions = f1C59_parent_instructions;
                                                   body.emit(f1C59);

                                                   /* END IF */

                                                   body.emit(assign(r1C48, r1C58, 0x01));

                                                   body.emit(assign(r1C49, body.constant(0u), 0x01));


                                                body.instructions = f1C55_parent_instructions;
                                                body.emit(f1C55);

                                                /* END IF */


                                             body.instructions = f1C53_parent_instructions;
                                             body.emit(f1C53);

                                             /* END IF */

                                             body.emit(assign(r1C4A, body.constant(0u), 0x01));


                                          body.instructions = f1C4F_parent_instructions;
                                          body.emit(f1C4F);

                                          /* END IF */

                                          ir_expression *const r1C5D = nequal(r1C46, body.constant(0u));
                                          ir_expression *const r1C5E = expr(ir_unop_b2i, r1C5D);
                                          ir_expression *const r1C5F = expr(ir_unop_i2u, r1C5E);
                                          body.emit(assign(r1C48, bit_or(r1C48, r1C5F), 0x01));


                                       body.instructions = f1C4D_parent_instructions;
                                       body.emit(f1C4D);

                                       /* END IF */

                                       body.emit(assign(r1C30, r1C4A, 0x01));

                                       body.emit(assign(r1C31, r1C49, 0x01));

                                       body.emit(assign(r1C32, r1C48, 0x01));

                                       body.emit(assign(r1C2F, body.constant(int(0)), 0x01));

                                       body.emit(assign(r1C35, less(r1C48, body.constant(0u)), 0x01));


                                    body.instructions = f1C44_parent_instructions;
                                    body.emit(f1C44);

                                    /* END IF */


                                 body.instructions = f1C41_parent_instructions;
                                 body.emit(f1C41);

                                 /* END IF */


                              body.instructions = f1C37_parent_instructions;
                              body.emit(f1C37);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f1C60 = new(mem_ctx) ir_if(operand(r1C33).val);
                              exec_list *const f1C60_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1C60->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f1C61 = new(mem_ctx) ir_if(operand(r1C35).val);
                                 exec_list *const f1C61_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1C61->then_instructions;

                                    ir_variable *const r1C62 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r1C62, add(r1C31, body.constant(1u)), 0x01));

                                    ir_expression *const r1C63 = less(r1C62, r1C31);
                                    ir_expression *const r1C64 = expr(ir_unop_b2i, r1C63);
                                    ir_expression *const r1C65 = expr(ir_unop_i2u, r1C64);
                                    body.emit(assign(r1C30, add(r1C30, r1C65), 0x01));

                                    ir_expression *const r1C66 = equal(r1C32, body.constant(0u));
                                    ir_expression *const r1C67 = expr(ir_unop_b2i, r1C66);
                                    ir_expression *const r1C68 = expr(ir_unop_i2u, r1C67);
                                    ir_expression *const r1C69 = add(r1C32, r1C68);
                                    ir_expression *const r1C6A = bit_and(r1C69, body.constant(1u));
                                    ir_expression *const r1C6B = expr(ir_unop_bit_not, r1C6A);
                                    body.emit(assign(r1C31, bit_and(r1C62, r1C6B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1C61->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1C6D = bit_or(r1C30, r1C31);
                                    ir_expression *const r1C6E = equal(r1C6D, body.constant(0u));
                                    ir_if *f1C6C = new(mem_ctx) ir_if(operand(r1C6E).val);
                                    exec_list *const f1C6C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1C6C->then_instructions;

                                       body.emit(assign(r1C2F, body.constant(int(0)), 0x01));


                                    body.instructions = f1C6C_parent_instructions;
                                    body.emit(f1C6C);

                                    /* END IF */


                                 body.instructions = f1C61_parent_instructions;
                                 body.emit(f1C61);

                                 /* END IF */

                                 ir_variable *const r1C6F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r1C6F);
                                 ir_expression *const r1C70 = lshift(r187B, body.constant(int(31)));
                                 ir_expression *const r1C71 = expr(ir_unop_i2u, r1C2F);
                                 ir_expression *const r1C72 = lshift(r1C71, body.constant(int(20)));
                                 ir_expression *const r1C73 = add(r1C70, r1C72);
                                 body.emit(assign(r1C6F, add(r1C73, r1C30), 0x02));

                                 body.emit(assign(r1C6F, r1C31, 0x01));

                                 body.emit(assign(r1C34, r1C6F, 0x03));

                                 body.emit(assign(r1C33, body.constant(false), 0x01));


                              body.instructions = f1C60_parent_instructions;
                              body.emit(f1C60);

                              /* END IF */

                              body.emit(assign(r187C, r1C34, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1BE8->else_instructions;

                              ir_variable *const r1C74 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r1C74);
                              body.emit(assign(r1C74, body.constant(0u), 0x02));

                              body.emit(assign(r1C74, body.constant(0u), 0x01));

                              body.emit(assign(r187C, r1C74, 0x03));


                           body.instructions = f1BE8_parent_instructions;
                           body.emit(f1BE8);

                           /* END IF */


                        body.instructions = f1B5C_parent_instructions;
                        body.emit(f1B5C);

                        /* END IF */


                     body.instructions = f1AD0_parent_instructions;
                     body.emit(f1AD0);

                     /* END IF */


                  body.instructions = f1A44_parent_instructions;
                  body.emit(f1A44);

                  /* END IF */


               body.instructions = f1A23_parent_instructions;
               body.emit(f1A23);

               /* END IF */


            body.instructions = f1955_parent_instructions;
            body.emit(f1955);

            /* END IF */


         body.instructions = f1890_parent_instructions;
         body.emit(f1890);

         /* END IF */

         body.emit(assign(r16E2, r187C, 0x03));


      body.instructions = f16E5_parent_instructions;
      body.emit(f16E5);

      /* END IF */

      body.emit(assign(r16DF, r16E2, 0x03));


   body.instructions = f16E0_parent_instructions;
   body.emit(f16E0);

   /* END IF */

   body.emit(ret(r16DF));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fceil64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1C75 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1C75);
   ir_variable *const r1C76 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1C77 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1C78 = rshift(swizzle_y(r1C75), body.constant(int(20)));
   ir_expression *const r1C79 = bit_and(r1C78, body.constant(2047u));
   ir_expression *const r1C7A = expr(ir_unop_u2i, r1C79);
   body.emit(assign(r1C77, add(r1C7A, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1C7C = less(r1C77, body.constant(int(0)));
   ir_if *f1C7B = new(mem_ctx) ir_if(operand(r1C7C).val);
   exec_list *const f1C7B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1C7B->then_instructions;

      body.emit(assign(r1C76, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1C7B->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1C7E = greater(r1C77, body.constant(int(52)));
      ir_if *f1C7D = new(mem_ctx) ir_if(operand(r1C7E).val);
      exec_list *const f1C7D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1C7D->then_instructions;

         body.emit(assign(r1C76, r1C75, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1C7D->else_instructions;

         ir_variable *const r1C7F = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1C7F, sub(body.constant(int(52)), r1C77), 0x01));

         ir_variable *const r1C80 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1C82 = gequal(r1C7F, body.constant(int(32)));
         ir_if *f1C81 = new(mem_ctx) ir_if(operand(r1C82).val);
         exec_list *const f1C81_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C81->then_instructions;

            body.emit(assign(r1C80, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C81->else_instructions;

            body.emit(assign(r1C80, lshift(body.constant(4294967295u), r1C7F), 0x01));


         body.instructions = f1C81_parent_instructions;
         body.emit(f1C81);

         /* END IF */

         ir_variable *const r1C83 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1C85 = less(r1C7F, body.constant(int(33)));
         ir_if *f1C84 = new(mem_ctx) ir_if(operand(r1C85).val);
         exec_list *const f1C84_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C84->then_instructions;

            body.emit(assign(r1C83, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C84->else_instructions;

            ir_expression *const r1C86 = add(r1C7F, body.constant(int(-32)));
            body.emit(assign(r1C83, lshift(body.constant(4294967295u), r1C86), 0x01));


         body.instructions = f1C84_parent_instructions;
         body.emit(f1C84);

         /* END IF */

         ir_variable *const r1C87 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r1C87, bit_and(r1C80, swizzle_x(r1C75)), 0x01));

         body.emit(assign(r1C87, bit_and(r1C83, swizzle_y(r1C75)), 0x02));

         body.emit(assign(r1C76, r1C87, 0x03));


      body.instructions = f1C7D_parent_instructions;
      body.emit(f1C7D);

      /* END IF */


   body.instructions = f1C7B_parent_instructions;
   body.emit(f1C7B);

   /* END IF */

   ir_variable *const r1C88 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r1C88, rshift(swizzle_y(r1C75), body.constant(int(31))), 0x01));

   ir_variable *const r1C89 = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r1C8B = expr(ir_unop_u2i, r1C88);
   ir_expression *const r1C8C = expr(ir_unop_i2b, r1C8B);
   ir_if *f1C8A = new(mem_ctx) ir_if(operand(r1C8C).val);
   exec_list *const f1C8A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1C8A->then_instructions;

      body.emit(assign(r1C89, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1C8A->else_instructions;

      ir_variable *const r1C8D = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r1C8E = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r1C8E);
      ir_variable *const r1C8F = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r1C8F);
      ir_expression *const r1C90 = rshift(swizzle_y(r1C75), body.constant(int(20)));
      ir_expression *const r1C91 = bit_and(r1C90, body.constant(2047u));
      ir_expression *const r1C92 = expr(ir_unop_u2i, r1C91);
      ir_expression *const r1C93 = equal(r1C92, body.constant(int(2047)));
      ir_expression *const r1C94 = bit_and(swizzle_y(r1C75), body.constant(1048575u));
      ir_expression *const r1C95 = bit_or(r1C94, swizzle_x(r1C75));
      ir_expression *const r1C96 = nequal(r1C95, body.constant(0u));
      body.emit(assign(r1C8F, logic_and(r1C93, r1C96), 0x01));

      ir_expression *const r1C97 = rshift(swizzle_y(r1C76), body.constant(int(20)));
      ir_expression *const r1C98 = bit_and(r1C97, body.constant(2047u));
      ir_expression *const r1C99 = expr(ir_unop_u2i, r1C98);
      ir_expression *const r1C9A = equal(r1C99, body.constant(int(2047)));
      ir_expression *const r1C9B = bit_and(swizzle_y(r1C76), body.constant(1048575u));
      ir_expression *const r1C9C = bit_or(r1C9B, swizzle_x(r1C76));
      ir_expression *const r1C9D = nequal(r1C9C, body.constant(0u));
      body.emit(assign(r1C8E, logic_and(r1C9A, r1C9D), 0x01));

      /* IF CONDITION */
      ir_expression *const r1C9F = logic_or(r1C8F, r1C8E);
      ir_if *f1C9E = new(mem_ctx) ir_if(operand(r1C9F).val);
      exec_list *const f1C9E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1C9E->then_instructions;

         body.emit(assign(r1C8D, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1C9E->else_instructions;

         ir_expression *const r1CA0 = equal(swizzle_x(r1C75), swizzle_x(r1C76));
         ir_expression *const r1CA1 = equal(swizzle_y(r1C75), swizzle_y(r1C76));
         ir_expression *const r1CA2 = equal(swizzle_x(r1C75), body.constant(0u));
         ir_expression *const r1CA3 = bit_or(swizzle_y(r1C75), swizzle_y(r1C76));
         ir_expression *const r1CA4 = lshift(r1CA3, body.constant(int(1)));
         ir_expression *const r1CA5 = equal(r1CA4, body.constant(0u));
         ir_expression *const r1CA6 = logic_and(r1CA2, r1CA5);
         ir_expression *const r1CA7 = logic_or(r1CA1, r1CA6);
         body.emit(assign(r1C8D, logic_and(r1CA0, r1CA7), 0x01));


      body.instructions = f1C9E_parent_instructions;
      body.emit(f1C9E);

      /* END IF */

      body.emit(assign(r1C89, r1C8D, 0x01));


   body.instructions = f1C8A_parent_instructions;
   body.emit(f1C8A);

   /* END IF */

   ir_variable *const r1CA8 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f1CA9 = new(mem_ctx) ir_if(operand(r1C89).val);
   exec_list *const f1CA9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1CA9->then_instructions;

      body.emit(assign(r1CA8, r1C76, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1CA9->else_instructions;

      ir_variable *const r1CAA = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r1CAB = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1CAB, rshift(swizzle_y(r1C76), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1CAD = equal(r1CAB, body.constant(0u));
      ir_if *f1CAC = new(mem_ctx) ir_if(operand(r1CAD).val);
      exec_list *const f1CAC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1CAC->then_instructions;

         ir_variable *const r1CAE = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r1CAE, body.constant(true), 0x01));

         ir_variable *const r1CAF = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r1CB0 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r1CB0);
         ir_variable *const r1CB1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r1CB1);
         ir_variable *const r1CB2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r1CB2);
         ir_variable *const r1CB3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r1CB3);
         ir_variable *const r1CB4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r1CB4);
         ir_variable *const r1CB5 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r1CB5);
         ir_variable *const r1CB6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r1CB6);
         ir_variable *const r1CB7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r1CB7);
         body.emit(assign(r1CB7, body.constant(0u), 0x01));

         body.emit(assign(r1CB6, body.constant(0u), 0x01));

         ir_variable *const r1CB8 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r1CB8, swizzle_x(r1C76), 0x01));

         body.emit(assign(r1CB4, r1CB8, 0x01));

         ir_variable *const r1CB9 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r1CB9, bit_and(swizzle_y(r1C76), body.constant(1048575u)), 0x01));

         body.emit(assign(r1CB3, r1CB9, 0x01));

         ir_variable *const r1CBA = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r1CBA, body.constant(0u), 0x01));

         body.emit(assign(r1CB2, body.constant(0u), 0x01));

         body.emit(assign(r1CB1, body.constant(0u), 0x01));

         ir_variable *const r1CBB = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r1CBC = rshift(swizzle_y(r1C76), body.constant(int(20)));
         ir_expression *const r1CBD = bit_and(r1CBC, body.constant(2047u));
         body.emit(assign(r1CBB, expr(ir_unop_u2i, r1CBD), 0x01));

         ir_variable *const r1CBE = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r1CBE, body.constant(int(1023)), 0x01));

         ir_variable *const r1CBF = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1CBF, add(r1CBB, body.constant(int(-1023))), 0x01));

         body.emit(assign(r1CB0, r1CBF, 0x01));

         /* IF CONDITION */
         ir_expression *const r1CC1 = less(body.constant(int(0)), r1CBF);
         ir_if *f1CC0 = new(mem_ctx) ir_if(operand(r1CC1).val);
         exec_list *const f1CC0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1CC0->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1CC3 = equal(r1CBB, body.constant(int(2047)));
            ir_if *f1CC2 = new(mem_ctx) ir_if(operand(r1CC3).val);
            exec_list *const f1CC2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1CC2->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1CC5 = bit_or(r1CB9, swizzle_x(r1C76));
               ir_expression *const r1CC6 = nequal(r1CC5, body.constant(0u));
               ir_if *f1CC4 = new(mem_ctx) ir_if(operand(r1CC6).val);
               exec_list *const f1CC4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CC4->then_instructions;

                  ir_variable *const r1CC7 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1CC7, swizzle_x(r1C76), 0x01));

                  ir_variable *const r1CC8 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r1CC8, body.constant(0u), 0x01));

                  ir_variable *const r1CC9 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r1CC7, bit_or(swizzle_y(r1C76), body.constant(524288u)), 0x02));

                  body.emit(assign(r1CC8, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r1CCB = lshift(swizzle_y(r1C76), body.constant(int(1)));
                  ir_expression *const r1CCC = lequal(body.constant(4292870144u), r1CCB);
                  ir_expression *const r1CCD = nequal(swizzle_x(r1C76), body.constant(0u));
                  ir_expression *const r1CCE = bit_and(swizzle_y(r1C76), body.constant(1048575u));
                  ir_expression *const r1CCF = nequal(r1CCE, body.constant(0u));
                  ir_expression *const r1CD0 = logic_or(r1CCD, r1CCF);
                  ir_expression *const r1CD1 = logic_and(r1CCC, r1CD0);
                  ir_if *f1CCA = new(mem_ctx) ir_if(operand(r1CD1).val);
                  exec_list *const f1CCA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CCA->then_instructions;

                     body.emit(assign(r1CC9, r1CC7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1CCA->else_instructions;

                     body.emit(assign(r1CC9, r1CC8, 0x03));


                  body.instructions = f1CCA_parent_instructions;
                  body.emit(f1CCA);

                  /* END IF */

                  body.emit(assign(r1CAF, r1CC9, 0x03));

                  body.emit(assign(r1CAE, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1CC4->else_instructions;

                  body.emit(assign(r1CAF, r1C76, 0x03));

                  body.emit(assign(r1CAE, body.constant(false), 0x01));


               body.instructions = f1CC4_parent_instructions;
               body.emit(f1CC4);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1CC2->else_instructions;

               body.emit(assign(r1CB1, body.constant(1048576u), 0x01));

               ir_variable *const r1CD2 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r1CD2, body.constant(0u), 0x01));

               ir_variable *const r1CD3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r1CD3);
               ir_variable *const r1CD4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1CD4);
               ir_variable *const r1CD5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1CD5);
               ir_variable *const r1CD6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1CD7 = neg(r1CBF);
               body.emit(assign(r1CD6, bit_and(r1CD7, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1CD9 = equal(r1CBF, body.constant(int(0)));
               ir_if *f1CD8 = new(mem_ctx) ir_if(operand(r1CD9).val);
               exec_list *const f1CD8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CD8->then_instructions;

                  body.emit(assign(r1CD3, r1CD2, 0x01));

                  body.emit(assign(r1CD4, body.constant(0u), 0x01));

                  body.emit(assign(r1CD5, r1CB1, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1CD8->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1CDB = less(r1CBF, body.constant(int(32)));
                  ir_if *f1CDA = new(mem_ctx) ir_if(operand(r1CDB).val);
                  exec_list *const f1CDA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CDA->then_instructions;

                     body.emit(assign(r1CD3, body.constant(0u), 0x01));

                     ir_expression *const r1CDC = lshift(body.constant(1048576u), r1CD6);
                     body.emit(assign(r1CD4, bit_or(r1CDC, body.constant(0u)), 0x01));

                     body.emit(assign(r1CD5, rshift(body.constant(1048576u), r1CBF), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1CDA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1CDE = equal(r1CBF, body.constant(int(32)));
                     ir_if *f1CDD = new(mem_ctx) ir_if(operand(r1CDE).val);
                     exec_list *const f1CDD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1CDD->then_instructions;

                        body.emit(assign(r1CD3, body.constant(0u), 0x01));

                        body.emit(assign(r1CD4, r1CB1, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1CDD->else_instructions;

                        body.emit(assign(r1CD2, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1CE0 = less(r1CBF, body.constant(int(64)));
                        ir_if *f1CDF = new(mem_ctx) ir_if(operand(r1CE0).val);
                        exec_list *const f1CDF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1CDF->then_instructions;

                           body.emit(assign(r1CD3, lshift(body.constant(1048576u), r1CD6), 0x01));

                           ir_expression *const r1CE1 = bit_and(r1CBF, body.constant(int(31)));
                           body.emit(assign(r1CD4, rshift(body.constant(1048576u), r1CE1), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1CDF->else_instructions;

                           ir_variable *const r1CE2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1CE4 = equal(r1CBF, body.constant(int(64)));
                           ir_if *f1CE3 = new(mem_ctx) ir_if(operand(r1CE4).val);
                           exec_list *const f1CE3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1CE3->then_instructions;

                              body.emit(assign(r1CE2, r1CB1, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1CE3->else_instructions;

                              body.emit(assign(r1CE2, body.constant(1u), 0x01));


                           body.instructions = f1CE3_parent_instructions;
                           body.emit(f1CE3);

                           /* END IF */

                           body.emit(assign(r1CD3, r1CE2, 0x01));

                           body.emit(assign(r1CD4, body.constant(0u), 0x01));


                        body.instructions = f1CDF_parent_instructions;
                        body.emit(f1CDF);

                        /* END IF */


                     body.instructions = f1CDD_parent_instructions;
                     body.emit(f1CDD);

                     /* END IF */

                     body.emit(assign(r1CD5, body.constant(0u), 0x01));


                  body.instructions = f1CDA_parent_instructions;
                  body.emit(f1CDA);

                  /* END IF */

                  ir_expression *const r1CE5 = nequal(r1CD2, body.constant(0u));
                  ir_expression *const r1CE6 = expr(ir_unop_b2i, r1CE5);
                  ir_expression *const r1CE7 = expr(ir_unop_i2u, r1CE6);
                  body.emit(assign(r1CD3, bit_or(r1CD3, r1CE7), 0x01));


               body.instructions = f1CD8_parent_instructions;
               body.emit(f1CD8);

               /* END IF */

               body.emit(assign(r1CB1, r1CD5, 0x01));

               body.emit(assign(r1CB2, r1CD4, 0x01));

               body.emit(assign(r1CB6, r1CD3, 0x01));

               body.emit(assign(r1CB5, r1CBB, 0x01));


            body.instructions = f1CC2_parent_instructions;
            body.emit(f1CC2);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1CC0->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1CE9 = less(r1CBF, body.constant(int(0)));
            ir_if *f1CE8 = new(mem_ctx) ir_if(operand(r1CE9).val);
            exec_list *const f1CE8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1CE8->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1CEB = equal(r1CBB, body.constant(int(0)));
               ir_if *f1CEA = new(mem_ctx) ir_if(operand(r1CEB).val);
               exec_list *const f1CEA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CEA->then_instructions;

                  body.emit(assign(r1CB0, add(r1CBF, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1CEA->else_instructions;

                  body.emit(assign(r1CB3, bit_or(r1CB9, body.constant(1048576u)), 0x01));


               body.instructions = f1CEA_parent_instructions;
               body.emit(f1CEA);

               /* END IF */

               ir_variable *const r1CEC = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r1CEC, body.constant(0u), 0x01));

               ir_variable *const r1CED = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r1CED, neg(r1CB0), 0x01));

               ir_variable *const r1CEE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r1CEE);
               ir_variable *const r1CEF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1CEF);
               ir_variable *const r1CF0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1CF0);
               ir_variable *const r1CF1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1CF2 = neg(r1CED);
               body.emit(assign(r1CF1, bit_and(r1CF2, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1CF4 = equal(r1CED, body.constant(int(0)));
               ir_if *f1CF3 = new(mem_ctx) ir_if(operand(r1CF4).val);
               exec_list *const f1CF3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CF3->then_instructions;

                  body.emit(assign(r1CEE, r1CEC, 0x01));

                  body.emit(assign(r1CEF, r1CB8, 0x01));

                  body.emit(assign(r1CF0, r1CB3, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1CF3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1CF6 = less(r1CED, body.constant(int(32)));
                  ir_if *f1CF5 = new(mem_ctx) ir_if(operand(r1CF6).val);
                  exec_list *const f1CF5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CF5->then_instructions;

                     body.emit(assign(r1CEE, lshift(swizzle_x(r1C76), r1CF1), 0x01));

                     ir_expression *const r1CF7 = lshift(r1CB3, r1CF1);
                     ir_expression *const r1CF8 = rshift(swizzle_x(r1C76), r1CED);
                     body.emit(assign(r1CEF, bit_or(r1CF7, r1CF8), 0x01));

                     body.emit(assign(r1CF0, rshift(r1CB3, r1CED), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1CF5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1CFA = equal(r1CED, body.constant(int(32)));
                     ir_if *f1CF9 = new(mem_ctx) ir_if(operand(r1CFA).val);
                     exec_list *const f1CF9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1CF9->then_instructions;

                        body.emit(assign(r1CEE, r1CB8, 0x01));

                        body.emit(assign(r1CEF, r1CB3, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1CF9->else_instructions;

                        body.emit(assign(r1CEC, bit_or(body.constant(0u), swizzle_x(r1C76)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1CFC = less(r1CED, body.constant(int(64)));
                        ir_if *f1CFB = new(mem_ctx) ir_if(operand(r1CFC).val);
                        exec_list *const f1CFB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1CFB->then_instructions;

                           body.emit(assign(r1CEE, lshift(r1CB3, r1CF1), 0x01));

                           ir_expression *const r1CFD = bit_and(r1CED, body.constant(int(31)));
                           body.emit(assign(r1CEF, rshift(r1CB3, r1CFD), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1CFB->else_instructions;

                           ir_variable *const r1CFE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1D00 = equal(r1CED, body.constant(int(64)));
                           ir_if *f1CFF = new(mem_ctx) ir_if(operand(r1D00).val);
                           exec_list *const f1CFF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1CFF->then_instructions;

                              body.emit(assign(r1CFE, r1CB3, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1CFF->else_instructions;

                              ir_expression *const r1D01 = nequal(r1CB3, body.constant(0u));
                              ir_expression *const r1D02 = expr(ir_unop_b2i, r1D01);
                              body.emit(assign(r1CFE, expr(ir_unop_i2u, r1D02), 0x01));


                           body.instructions = f1CFF_parent_instructions;
                           body.emit(f1CFF);

                           /* END IF */

                           body.emit(assign(r1CEE, r1CFE, 0x01));

                           body.emit(assign(r1CEF, body.constant(0u), 0x01));


                        body.instructions = f1CFB_parent_instructions;
                        body.emit(f1CFB);

                        /* END IF */


                     body.instructions = f1CF9_parent_instructions;
                     body.emit(f1CF9);

                     /* END IF */

                     body.emit(assign(r1CF0, body.constant(0u), 0x01));


                  body.instructions = f1CF5_parent_instructions;
                  body.emit(f1CF5);

                  /* END IF */

                  ir_expression *const r1D03 = nequal(r1CEC, body.constant(0u));
                  ir_expression *const r1D04 = expr(ir_unop_b2i, r1D03);
                  ir_expression *const r1D05 = expr(ir_unop_i2u, r1D04);
                  body.emit(assign(r1CEE, bit_or(r1CEE, r1D05), 0x01));


               body.instructions = f1CF3_parent_instructions;
               body.emit(f1CF3);

               /* END IF */

               body.emit(assign(r1CB3, r1CF0, 0x01));

               body.emit(assign(r1CB4, r1CEF, 0x01));

               body.emit(assign(r1CB6, r1CEE, 0x01));

               body.emit(assign(r1CB5, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1CE8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1D07 = equal(r1CBB, body.constant(int(2047)));
               ir_if *f1D06 = new(mem_ctx) ir_if(operand(r1D07).val);
               exec_list *const f1D06_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D06->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1D09 = bit_or(r1CB3, r1CB4);
                  ir_expression *const r1D0A = bit_or(r1CB1, r1CB2);
                  ir_expression *const r1D0B = bit_or(r1D09, r1D0A);
                  ir_expression *const r1D0C = nequal(r1D0B, body.constant(0u));
                  ir_if *f1D08 = new(mem_ctx) ir_if(operand(r1D0C).val);
                  exec_list *const f1D08_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D08->then_instructions;

                     ir_variable *const r1D0D = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r1D0D, swizzle_x(r1C76), 0x01));

                     ir_variable *const r1D0E = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r1D0E, body.constant(0u), 0x01));

                     ir_variable *const r1D0F = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r1D0D, bit_or(swizzle_y(r1C76), body.constant(524288u)), 0x02));

                     body.emit(assign(r1D0E, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r1D11 = lshift(swizzle_y(r1C76), body.constant(int(1)));
                     ir_expression *const r1D12 = lequal(body.constant(4292870144u), r1D11);
                     ir_expression *const r1D13 = nequal(swizzle_x(r1C76), body.constant(0u));
                     ir_expression *const r1D14 = bit_and(swizzle_y(r1C76), body.constant(1048575u));
                     ir_expression *const r1D15 = nequal(r1D14, body.constant(0u));
                     ir_expression *const r1D16 = logic_or(r1D13, r1D15);
                     ir_expression *const r1D17 = logic_and(r1D12, r1D16);
                     ir_if *f1D10 = new(mem_ctx) ir_if(operand(r1D17).val);
                     exec_list *const f1D10_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D10->then_instructions;

                        body.emit(assign(r1D0F, r1D0D, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1D10->else_instructions;

                        body.emit(assign(r1D0F, r1D0E, 0x03));


                     body.instructions = f1D10_parent_instructions;
                     body.emit(f1D10);

                     /* END IF */

                     body.emit(assign(r1CAF, r1D0F, 0x03));

                     body.emit(assign(r1CAE, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D08->else_instructions;

                     body.emit(assign(r1CAF, r1C76, 0x03));

                     body.emit(assign(r1CAE, body.constant(false), 0x01));


                  body.instructions = f1D08_parent_instructions;
                  body.emit(f1D08);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1D06->else_instructions;

                  ir_variable *const r1D18 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r1D19 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1D19, add(r1CB4, r1CB2), 0x01));

                  ir_expression *const r1D1A = add(r1CB3, r1CB1);
                  ir_expression *const r1D1B = less(r1D19, r1CB4);
                  ir_expression *const r1D1C = expr(ir_unop_b2i, r1D1B);
                  ir_expression *const r1D1D = expr(ir_unop_i2u, r1D1C);
                  body.emit(assign(r1D18, add(r1D1A, r1D1D), 0x01));

                  body.emit(assign(r1CB7, r1D18, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1D1F = equal(r1CBB, body.constant(int(0)));
                  ir_if *f1D1E = new(mem_ctx) ir_if(operand(r1D1F).val);
                  exec_list *const f1D1E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D1E->then_instructions;

                     ir_variable *const r1D20 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1D20);
                     ir_expression *const r1D21 = lshift(r1CAB, body.constant(int(31)));
                     body.emit(assign(r1D20, add(r1D21, r1D18), 0x02));

                     body.emit(assign(r1D20, r1D19, 0x01));

                     body.emit(assign(r1CAF, r1D20, 0x03));

                     body.emit(assign(r1CAE, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D1E->else_instructions;

                     body.emit(assign(r1CB7, bit_or(r1D18, body.constant(2097152u)), 0x01));

                     body.emit(assign(r1CB5, r1CBB, 0x01));

                     ir_variable *const r1D22 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r1D22);
                     ir_variable *const r1D23 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r1D23);
                     ir_variable *const r1D24 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r1D24);
                     body.emit(assign(r1D22, lshift(r1D19, body.constant(int(31))), 0x01));

                     ir_expression *const r1D25 = lshift(r1CB7, body.constant(int(31)));
                     ir_expression *const r1D26 = rshift(r1D19, body.constant(int(1)));
                     body.emit(assign(r1D23, bit_or(r1D25, r1D26), 0x01));

                     body.emit(assign(r1D24, rshift(r1CB7, body.constant(int(1))), 0x01));

                     body.emit(assign(r1D22, bit_or(r1D22, body.constant(0u)), 0x01));

                     body.emit(assign(r1CB7, r1D24, 0x01));

                     body.emit(assign(r1CB6, r1D22, 0x01));

                     ir_variable *const r1D27 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1D27, r1CBB, 0x01));

                     ir_variable *const r1D28 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1D28, r1D24, 0x01));

                     ir_variable *const r1D29 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1D29, r1D23, 0x01));

                     ir_variable *const r1D2A = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r1D2A, r1D22, 0x01));

                     ir_variable *const r1D2B = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r1D2B, body.constant(true), 0x01));

                     ir_variable *const r1D2C = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1D2D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r1D2D);
                     ir_expression *const r1D2E = expr(ir_unop_u2i, r1D22);
                     body.emit(assign(r1D2D, less(r1D2E, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1D30 = lequal(body.constant(int(2045)), r1CBB);
                     ir_if *f1D2F = new(mem_ctx) ir_if(operand(r1D30).val);
                     exec_list *const f1D2F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D2F->then_instructions;

                        ir_variable *const r1D31 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1D33 = less(body.constant(int(2045)), r1CBB);
                        ir_if *f1D32 = new(mem_ctx) ir_if(operand(r1D33).val);
                        exec_list *const f1D32_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D32->then_instructions;

                           body.emit(assign(r1D31, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D32->else_instructions;

                           ir_variable *const r1D34 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1D36 = equal(r1CBB, body.constant(int(2045)));
                           ir_if *f1D35 = new(mem_ctx) ir_if(operand(r1D36).val);
                           exec_list *const f1D35_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D35->then_instructions;

                              ir_expression *const r1D37 = equal(body.constant(2097151u), r1D24);
                              ir_expression *const r1D38 = equal(body.constant(4294967295u), r1D23);
                              body.emit(assign(r1D34, logic_and(r1D37, r1D38), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1D35->else_instructions;

                              body.emit(assign(r1D34, body.constant(false), 0x01));


                           body.instructions = f1D35_parent_instructions;
                           body.emit(f1D35);

                           /* END IF */

                           body.emit(assign(r1D31, logic_and(r1D34, r1D2D), 0x01));


                        body.instructions = f1D32_parent_instructions;
                        body.emit(f1D32);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1D39 = new(mem_ctx) ir_if(operand(r1D31).val);
                        exec_list *const f1D39_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D39->then_instructions;

                           ir_variable *const r1D3A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1D3A);
                           ir_expression *const r1D3B = lshift(r1CAB, body.constant(int(31)));
                           body.emit(assign(r1D3A, add(r1D3B, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r1D3A, body.constant(0u), 0x01));

                           body.emit(assign(r1D2C, r1D3A, 0x03));

                           body.emit(assign(r1D2B, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D39->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1D3D = less(r1CBB, body.constant(int(0)));
                           ir_if *f1D3C = new(mem_ctx) ir_if(operand(r1D3D).val);
                           exec_list *const f1D3C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D3C->then_instructions;

                              ir_variable *const r1D3E = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1D3E, r1D22, 0x01));

                              ir_variable *const r1D3F = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1D3F, neg(r1CBB), 0x01));

                              ir_variable *const r1D40 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1D40);
                              ir_variable *const r1D41 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1D41);
                              ir_variable *const r1D42 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1D42);
                              ir_variable *const r1D43 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1D44 = neg(r1D3F);
                              body.emit(assign(r1D43, bit_and(r1D44, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1D46 = equal(r1D3F, body.constant(int(0)));
                              ir_if *f1D45 = new(mem_ctx) ir_if(operand(r1D46).val);
                              exec_list *const f1D45_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1D45->then_instructions;

                                 body.emit(assign(r1D40, r1D22, 0x01));

                                 body.emit(assign(r1D41, r1D23, 0x01));

                                 body.emit(assign(r1D42, r1D24, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1D45->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1D48 = less(r1D3F, body.constant(int(32)));
                                 ir_if *f1D47 = new(mem_ctx) ir_if(operand(r1D48).val);
                                 exec_list *const f1D47_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1D47->then_instructions;

                                    body.emit(assign(r1D40, lshift(r1D23, r1D43), 0x01));

                                    ir_expression *const r1D49 = lshift(r1D24, r1D43);
                                    ir_expression *const r1D4A = rshift(r1D23, r1D3F);
                                    body.emit(assign(r1D41, bit_or(r1D49, r1D4A), 0x01));

                                    body.emit(assign(r1D42, rshift(r1D24, r1D3F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1D47->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1D4C = equal(r1D3F, body.constant(int(32)));
                                    ir_if *f1D4B = new(mem_ctx) ir_if(operand(r1D4C).val);
                                    exec_list *const f1D4B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1D4B->then_instructions;

                                       body.emit(assign(r1D40, r1D23, 0x01));

                                       body.emit(assign(r1D41, r1D24, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1D4B->else_instructions;

                                       body.emit(assign(r1D3E, bit_or(r1D22, r1D23), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1D4E = less(r1D3F, body.constant(int(64)));
                                       ir_if *f1D4D = new(mem_ctx) ir_if(operand(r1D4E).val);
                                       exec_list *const f1D4D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1D4D->then_instructions;

                                          body.emit(assign(r1D40, lshift(r1D24, r1D43), 0x01));

                                          ir_expression *const r1D4F = bit_and(r1D3F, body.constant(int(31)));
                                          body.emit(assign(r1D41, rshift(r1D24, r1D4F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1D4D->else_instructions;

                                          ir_variable *const r1D50 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1D52 = equal(r1D3F, body.constant(int(64)));
                                          ir_if *f1D51 = new(mem_ctx) ir_if(operand(r1D52).val);
                                          exec_list *const f1D51_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1D51->then_instructions;

                                             body.emit(assign(r1D50, r1D24, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1D51->else_instructions;

                                             ir_expression *const r1D53 = nequal(r1D24, body.constant(0u));
                                             ir_expression *const r1D54 = expr(ir_unop_b2i, r1D53);
                                             body.emit(assign(r1D50, expr(ir_unop_i2u, r1D54), 0x01));


                                          body.instructions = f1D51_parent_instructions;
                                          body.emit(f1D51);

                                          /* END IF */

                                          body.emit(assign(r1D40, r1D50, 0x01));

                                          body.emit(assign(r1D41, body.constant(0u), 0x01));


                                       body.instructions = f1D4D_parent_instructions;
                                       body.emit(f1D4D);

                                       /* END IF */


                                    body.instructions = f1D4B_parent_instructions;
                                    body.emit(f1D4B);

                                    /* END IF */

                                    body.emit(assign(r1D42, body.constant(0u), 0x01));


                                 body.instructions = f1D47_parent_instructions;
                                 body.emit(f1D47);

                                 /* END IF */

                                 ir_expression *const r1D55 = nequal(r1D3E, body.constant(0u));
                                 ir_expression *const r1D56 = expr(ir_unop_b2i, r1D55);
                                 ir_expression *const r1D57 = expr(ir_unop_i2u, r1D56);
                                 body.emit(assign(r1D40, bit_or(r1D40, r1D57), 0x01));


                              body.instructions = f1D45_parent_instructions;
                              body.emit(f1D45);

                              /* END IF */

                              body.emit(assign(r1D28, r1D42, 0x01));

                              body.emit(assign(r1D29, r1D41, 0x01));

                              body.emit(assign(r1D2A, r1D40, 0x01));

                              body.emit(assign(r1D27, body.constant(int(0)), 0x01));

                              body.emit(assign(r1D2D, less(r1D40, body.constant(0u)), 0x01));


                           body.instructions = f1D3C_parent_instructions;
                           body.emit(f1D3C);

                           /* END IF */


                        body.instructions = f1D39_parent_instructions;
                        body.emit(f1D39);

                        /* END IF */


                     body.instructions = f1D2F_parent_instructions;
                     body.emit(f1D2F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f1D58 = new(mem_ctx) ir_if(operand(r1D2B).val);
                     exec_list *const f1D58_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D58->then_instructions;

                        /* IF CONDITION */
                        ir_if *f1D59 = new(mem_ctx) ir_if(operand(r1D2D).val);
                        exec_list *const f1D59_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D59->then_instructions;

                           ir_variable *const r1D5A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r1D5A, add(r1D29, body.constant(1u)), 0x01));

                           ir_expression *const r1D5B = less(r1D5A, r1D29);
                           ir_expression *const r1D5C = expr(ir_unop_b2i, r1D5B);
                           ir_expression *const r1D5D = expr(ir_unop_i2u, r1D5C);
                           body.emit(assign(r1D28, add(r1D28, r1D5D), 0x01));

                           ir_expression *const r1D5E = equal(r1D2A, body.constant(0u));
                           ir_expression *const r1D5F = expr(ir_unop_b2i, r1D5E);
                           ir_expression *const r1D60 = expr(ir_unop_i2u, r1D5F);
                           ir_expression *const r1D61 = add(r1D2A, r1D60);
                           ir_expression *const r1D62 = bit_and(r1D61, body.constant(1u));
                           ir_expression *const r1D63 = expr(ir_unop_bit_not, r1D62);
                           body.emit(assign(r1D29, bit_and(r1D5A, r1D63), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D59->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1D65 = bit_or(r1D28, r1D29);
                           ir_expression *const r1D66 = equal(r1D65, body.constant(0u));
                           ir_if *f1D64 = new(mem_ctx) ir_if(operand(r1D66).val);
                           exec_list *const f1D64_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D64->then_instructions;

                              body.emit(assign(r1D27, body.constant(int(0)), 0x01));


                           body.instructions = f1D64_parent_instructions;
                           body.emit(f1D64);

                           /* END IF */


                        body.instructions = f1D59_parent_instructions;
                        body.emit(f1D59);

                        /* END IF */

                        ir_variable *const r1D67 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r1D67);
                        ir_expression *const r1D68 = lshift(r1CAB, body.constant(int(31)));
                        ir_expression *const r1D69 = expr(ir_unop_i2u, r1D27);
                        ir_expression *const r1D6A = lshift(r1D69, body.constant(int(20)));
                        ir_expression *const r1D6B = add(r1D68, r1D6A);
                        body.emit(assign(r1D67, add(r1D6B, r1D28), 0x02));

                        body.emit(assign(r1D67, r1D29, 0x01));

                        body.emit(assign(r1D2C, r1D67, 0x03));

                        body.emit(assign(r1D2B, body.constant(false), 0x01));


                     body.instructions = f1D58_parent_instructions;
                     body.emit(f1D58);

                     /* END IF */

                     body.emit(assign(r1CAF, r1D2C, 0x03));

                     body.emit(assign(r1CAE, body.constant(false), 0x01));


                  body.instructions = f1D1E_parent_instructions;
                  body.emit(f1D1E);

                  /* END IF */


               body.instructions = f1D06_parent_instructions;
               body.emit(f1D06);

               /* END IF */


            body.instructions = f1CE8_parent_instructions;
            body.emit(f1CE8);

            /* END IF */


         body.instructions = f1CC0_parent_instructions;
         body.emit(f1CC0);

         /* END IF */

         /* IF CONDITION */
         ir_if *f1D6C = new(mem_ctx) ir_if(operand(r1CAE).val);
         exec_list *const f1D6C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1D6C->then_instructions;

            body.emit(assign(r1CB3, bit_or(r1CB3, body.constant(1048576u)), 0x01));

            ir_variable *const r1D6D = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r1D6E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r1D6E, add(r1CB4, r1CB2), 0x01));

            ir_expression *const r1D6F = add(r1CB3, r1CB1);
            ir_expression *const r1D70 = less(r1D6E, r1CB4);
            ir_expression *const r1D71 = expr(ir_unop_b2i, r1D70);
            ir_expression *const r1D72 = expr(ir_unop_i2u, r1D71);
            body.emit(assign(r1D6D, add(r1D6F, r1D72), 0x01));

            body.emit(assign(r1CB7, r1D6D, 0x01));

            body.emit(assign(r1CB5, add(r1CB5, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1D74 = less(r1D6D, body.constant(2097152u));
            ir_if *f1D73 = new(mem_ctx) ir_if(operand(r1D74).val);
            exec_list *const f1D73_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1D73->then_instructions;

               ir_variable *const r1D75 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1D75, r1CB5, 0x01));

               ir_variable *const r1D76 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1D76, r1D6D, 0x01));

               ir_variable *const r1D77 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1D77, r1D6E, 0x01));

               ir_variable *const r1D78 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1D78, r1CB6, 0x01));

               ir_variable *const r1D79 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1D79, body.constant(true), 0x01));

               ir_variable *const r1D7A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1D7B = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1D7B);
               ir_expression *const r1D7C = expr(ir_unop_u2i, r1CB6);
               body.emit(assign(r1D7B, less(r1D7C, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1D7E = lequal(body.constant(int(2045)), r1CB5);
               ir_if *f1D7D = new(mem_ctx) ir_if(operand(r1D7E).val);
               exec_list *const f1D7D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D7D->then_instructions;

                  ir_variable *const r1D7F = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1D81 = less(body.constant(int(2045)), r1CB5);
                  ir_if *f1D80 = new(mem_ctx) ir_if(operand(r1D81).val);
                  exec_list *const f1D80_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D80->then_instructions;

                     body.emit(assign(r1D7F, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D80->else_instructions;

                     ir_variable *const r1D82 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1D84 = equal(r1CB5, body.constant(int(2045)));
                     ir_if *f1D83 = new(mem_ctx) ir_if(operand(r1D84).val);
                     exec_list *const f1D83_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D83->then_instructions;

                        ir_expression *const r1D85 = equal(body.constant(2097151u), r1D6D);
                        ir_expression *const r1D86 = equal(body.constant(4294967295u), r1D6E);
                        body.emit(assign(r1D82, logic_and(r1D85, r1D86), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1D83->else_instructions;

                        body.emit(assign(r1D82, body.constant(false), 0x01));


                     body.instructions = f1D83_parent_instructions;
                     body.emit(f1D83);

                     /* END IF */

                     body.emit(assign(r1D7F, logic_and(r1D82, r1D7B), 0x01));


                  body.instructions = f1D80_parent_instructions;
                  body.emit(f1D80);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1D87 = new(mem_ctx) ir_if(operand(r1D7F).val);
                  exec_list *const f1D87_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D87->then_instructions;

                     ir_variable *const r1D88 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1D88);
                     ir_expression *const r1D89 = lshift(r1CAB, body.constant(int(31)));
                     body.emit(assign(r1D88, add(r1D89, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1D88, body.constant(0u), 0x01));

                     body.emit(assign(r1D7A, r1D88, 0x03));

                     body.emit(assign(r1D79, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D87->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1D8B = less(r1CB5, body.constant(int(0)));
                     ir_if *f1D8A = new(mem_ctx) ir_if(operand(r1D8B).val);
                     exec_list *const f1D8A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D8A->then_instructions;

                        ir_variable *const r1D8C = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1D8C, r1CB6, 0x01));

                        ir_variable *const r1D8D = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1D8D, neg(r1CB5), 0x01));

                        ir_variable *const r1D8E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1D8E);
                        ir_variable *const r1D8F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1D8F);
                        ir_variable *const r1D90 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1D90);
                        ir_variable *const r1D91 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1D92 = neg(r1D8D);
                        body.emit(assign(r1D91, bit_and(r1D92, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1D94 = equal(r1D8D, body.constant(int(0)));
                        ir_if *f1D93 = new(mem_ctx) ir_if(operand(r1D94).val);
                        exec_list *const f1D93_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D93->then_instructions;

                           body.emit(assign(r1D8E, r1CB6, 0x01));

                           body.emit(assign(r1D8F, r1D6E, 0x01));

                           body.emit(assign(r1D90, r1D6D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D93->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1D96 = less(r1D8D, body.constant(int(32)));
                           ir_if *f1D95 = new(mem_ctx) ir_if(operand(r1D96).val);
                           exec_list *const f1D95_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D95->then_instructions;

                              body.emit(assign(r1D8E, lshift(r1D6E, r1D91), 0x01));

                              ir_expression *const r1D97 = lshift(r1D6D, r1D91);
                              ir_expression *const r1D98 = rshift(r1D6E, r1D8D);
                              body.emit(assign(r1D8F, bit_or(r1D97, r1D98), 0x01));

                              body.emit(assign(r1D90, rshift(r1D6D, r1D8D), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1D95->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1D9A = equal(r1D8D, body.constant(int(32)));
                              ir_if *f1D99 = new(mem_ctx) ir_if(operand(r1D9A).val);
                              exec_list *const f1D99_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1D99->then_instructions;

                                 body.emit(assign(r1D8E, r1D6E, 0x01));

                                 body.emit(assign(r1D8F, r1D6D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1D99->else_instructions;

                                 body.emit(assign(r1D8C, bit_or(r1CB6, r1D6E), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1D9C = less(r1D8D, body.constant(int(64)));
                                 ir_if *f1D9B = new(mem_ctx) ir_if(operand(r1D9C).val);
                                 exec_list *const f1D9B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1D9B->then_instructions;

                                    body.emit(assign(r1D8E, lshift(r1D6D, r1D91), 0x01));

                                    ir_expression *const r1D9D = bit_and(r1D8D, body.constant(int(31)));
                                    body.emit(assign(r1D8F, rshift(r1D6D, r1D9D), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1D9B->else_instructions;

                                    ir_variable *const r1D9E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1DA0 = equal(r1D8D, body.constant(int(64)));
                                    ir_if *f1D9F = new(mem_ctx) ir_if(operand(r1DA0).val);
                                    exec_list *const f1D9F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1D9F->then_instructions;

                                       body.emit(assign(r1D9E, r1D6D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1D9F->else_instructions;

                                       ir_expression *const r1DA1 = nequal(r1D6D, body.constant(0u));
                                       ir_expression *const r1DA2 = expr(ir_unop_b2i, r1DA1);
                                       body.emit(assign(r1D9E, expr(ir_unop_i2u, r1DA2), 0x01));


                                    body.instructions = f1D9F_parent_instructions;
                                    body.emit(f1D9F);

                                    /* END IF */

                                    body.emit(assign(r1D8E, r1D9E, 0x01));

                                    body.emit(assign(r1D8F, body.constant(0u), 0x01));


                                 body.instructions = f1D9B_parent_instructions;
                                 body.emit(f1D9B);

                                 /* END IF */


                              body.instructions = f1D99_parent_instructions;
                              body.emit(f1D99);

                              /* END IF */

                              body.emit(assign(r1D90, body.constant(0u), 0x01));


                           body.instructions = f1D95_parent_instructions;
                           body.emit(f1D95);

                           /* END IF */

                           ir_expression *const r1DA3 = nequal(r1D8C, body.constant(0u));
                           ir_expression *const r1DA4 = expr(ir_unop_b2i, r1DA3);
                           ir_expression *const r1DA5 = expr(ir_unop_i2u, r1DA4);
                           body.emit(assign(r1D8E, bit_or(r1D8E, r1DA5), 0x01));


                        body.instructions = f1D93_parent_instructions;
                        body.emit(f1D93);

                        /* END IF */

                        body.emit(assign(r1D76, r1D90, 0x01));

                        body.emit(assign(r1D77, r1D8F, 0x01));

                        body.emit(assign(r1D78, r1D8E, 0x01));

                        body.emit(assign(r1D75, body.constant(int(0)), 0x01));

                        body.emit(assign(r1D7B, less(r1D8E, body.constant(0u)), 0x01));


                     body.instructions = f1D8A_parent_instructions;
                     body.emit(f1D8A);

                     /* END IF */


                  body.instructions = f1D87_parent_instructions;
                  body.emit(f1D87);

                  /* END IF */


               body.instructions = f1D7D_parent_instructions;
               body.emit(f1D7D);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1DA6 = new(mem_ctx) ir_if(operand(r1D79).val);
               exec_list *const f1DA6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1DA6->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1DA7 = new(mem_ctx) ir_if(operand(r1D7B).val);
                  exec_list *const f1DA7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DA7->then_instructions;

                     ir_variable *const r1DA8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1DA8, add(r1D77, body.constant(1u)), 0x01));

                     ir_expression *const r1DA9 = less(r1DA8, r1D77);
                     ir_expression *const r1DAA = expr(ir_unop_b2i, r1DA9);
                     ir_expression *const r1DAB = expr(ir_unop_i2u, r1DAA);
                     body.emit(assign(r1D76, add(r1D76, r1DAB), 0x01));

                     ir_expression *const r1DAC = equal(r1D78, body.constant(0u));
                     ir_expression *const r1DAD = expr(ir_unop_b2i, r1DAC);
                     ir_expression *const r1DAE = expr(ir_unop_i2u, r1DAD);
                     ir_expression *const r1DAF = add(r1D78, r1DAE);
                     ir_expression *const r1DB0 = bit_and(r1DAF, body.constant(1u));
                     ir_expression *const r1DB1 = expr(ir_unop_bit_not, r1DB0);
                     body.emit(assign(r1D77, bit_and(r1DA8, r1DB1), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1DA7->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1DB3 = bit_or(r1D76, r1D77);
                     ir_expression *const r1DB4 = equal(r1DB3, body.constant(0u));
                     ir_if *f1DB2 = new(mem_ctx) ir_if(operand(r1DB4).val);
                     exec_list *const f1DB2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1DB2->then_instructions;

                        body.emit(assign(r1D75, body.constant(int(0)), 0x01));


                     body.instructions = f1DB2_parent_instructions;
                     body.emit(f1DB2);

                     /* END IF */


                  body.instructions = f1DA7_parent_instructions;
                  body.emit(f1DA7);

                  /* END IF */

                  ir_variable *const r1DB5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1DB5);
                  ir_expression *const r1DB6 = lshift(r1CAB, body.constant(int(31)));
                  ir_expression *const r1DB7 = expr(ir_unop_i2u, r1D75);
                  ir_expression *const r1DB8 = lshift(r1DB7, body.constant(int(20)));
                  ir_expression *const r1DB9 = add(r1DB6, r1DB8);
                  body.emit(assign(r1DB5, add(r1DB9, r1D76), 0x02));

                  body.emit(assign(r1DB5, r1D77, 0x01));

                  body.emit(assign(r1D7A, r1DB5, 0x03));

                  body.emit(assign(r1D79, body.constant(false), 0x01));


               body.instructions = f1DA6_parent_instructions;
               body.emit(f1DA6);

               /* END IF */

               body.emit(assign(r1CAF, r1D7A, 0x03));

               body.emit(assign(r1CAE, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1D73->else_instructions;

               body.emit(assign(r1CB5, add(r1CB5, body.constant(int(1))), 0x01));

               ir_variable *const r1DBA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r1DBA);
               ir_variable *const r1DBB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1DBB);
               ir_variable *const r1DBC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1DBC);
               body.emit(assign(r1DBA, lshift(r1D6E, body.constant(int(31))), 0x01));

               ir_expression *const r1DBD = lshift(r1D6D, body.constant(int(31)));
               ir_expression *const r1DBE = rshift(r1D6E, body.constant(int(1)));
               body.emit(assign(r1DBB, bit_or(r1DBD, r1DBE), 0x01));

               body.emit(assign(r1DBC, rshift(r1D6D, body.constant(int(1))), 0x01));

               ir_expression *const r1DBF = nequal(r1CB6, body.constant(0u));
               ir_expression *const r1DC0 = expr(ir_unop_b2i, r1DBF);
               ir_expression *const r1DC1 = expr(ir_unop_i2u, r1DC0);
               body.emit(assign(r1DBA, bit_or(r1DBA, r1DC1), 0x01));

               body.emit(assign(r1CB7, r1DBC, 0x01));

               body.emit(assign(r1CB6, r1DBA, 0x01));

               ir_variable *const r1DC2 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1DC2, r1CB5, 0x01));

               ir_variable *const r1DC3 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1DC3, r1DBC, 0x01));

               ir_variable *const r1DC4 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1DC4, r1DBB, 0x01));

               ir_variable *const r1DC5 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1DC5, r1DBA, 0x01));

               ir_variable *const r1DC6 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1DC6, body.constant(true), 0x01));

               ir_variable *const r1DC7 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1DC8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1DC8);
               ir_expression *const r1DC9 = expr(ir_unop_u2i, r1DBA);
               body.emit(assign(r1DC8, less(r1DC9, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1DCB = lequal(body.constant(int(2045)), r1CB5);
               ir_if *f1DCA = new(mem_ctx) ir_if(operand(r1DCB).val);
               exec_list *const f1DCA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1DCA->then_instructions;

                  ir_variable *const r1DCC = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1DCE = less(body.constant(int(2045)), r1CB5);
                  ir_if *f1DCD = new(mem_ctx) ir_if(operand(r1DCE).val);
                  exec_list *const f1DCD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DCD->then_instructions;

                     body.emit(assign(r1DCC, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1DCD->else_instructions;

                     ir_variable *const r1DCF = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1DD1 = equal(r1CB5, body.constant(int(2045)));
                     ir_if *f1DD0 = new(mem_ctx) ir_if(operand(r1DD1).val);
                     exec_list *const f1DD0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1DD0->then_instructions;

                        ir_expression *const r1DD2 = equal(body.constant(2097151u), r1DBC);
                        ir_expression *const r1DD3 = equal(body.constant(4294967295u), r1DBB);
                        body.emit(assign(r1DCF, logic_and(r1DD2, r1DD3), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1DD0->else_instructions;

                        body.emit(assign(r1DCF, body.constant(false), 0x01));


                     body.instructions = f1DD0_parent_instructions;
                     body.emit(f1DD0);

                     /* END IF */

                     body.emit(assign(r1DCC, logic_and(r1DCF, r1DC8), 0x01));


                  body.instructions = f1DCD_parent_instructions;
                  body.emit(f1DCD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1DD4 = new(mem_ctx) ir_if(operand(r1DCC).val);
                  exec_list *const f1DD4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DD4->then_instructions;

                     ir_variable *const r1DD5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1DD5);
                     ir_expression *const r1DD6 = lshift(r1CAB, body.constant(int(31)));
                     body.emit(assign(r1DD5, add(r1DD6, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1DD5, body.constant(0u), 0x01));

                     body.emit(assign(r1DC7, r1DD5, 0x03));

                     body.emit(assign(r1DC6, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1DD4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1DD8 = less(r1CB5, body.constant(int(0)));
                     ir_if *f1DD7 = new(mem_ctx) ir_if(operand(r1DD8).val);
                     exec_list *const f1DD7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1DD7->then_instructions;

                        ir_variable *const r1DD9 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1DD9, r1DBA, 0x01));

                        ir_variable *const r1DDA = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1DDA, neg(r1CB5), 0x01));

                        ir_variable *const r1DDB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1DDB);
                        ir_variable *const r1DDC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1DDC);
                        ir_variable *const r1DDD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1DDD);
                        ir_variable *const r1DDE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1DDF = neg(r1DDA);
                        body.emit(assign(r1DDE, bit_and(r1DDF, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1DE1 = equal(r1DDA, body.constant(int(0)));
                        ir_if *f1DE0 = new(mem_ctx) ir_if(operand(r1DE1).val);
                        exec_list *const f1DE0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1DE0->then_instructions;

                           body.emit(assign(r1DDB, r1DBA, 0x01));

                           body.emit(assign(r1DDC, r1DBB, 0x01));

                           body.emit(assign(r1DDD, r1DBC, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1DE0->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1DE3 = less(r1DDA, body.constant(int(32)));
                           ir_if *f1DE2 = new(mem_ctx) ir_if(operand(r1DE3).val);
                           exec_list *const f1DE2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1DE2->then_instructions;

                              body.emit(assign(r1DDB, lshift(r1DBB, r1DDE), 0x01));

                              ir_expression *const r1DE4 = lshift(r1DBC, r1DDE);
                              ir_expression *const r1DE5 = rshift(r1DBB, r1DDA);
                              body.emit(assign(r1DDC, bit_or(r1DE4, r1DE5), 0x01));

                              body.emit(assign(r1DDD, rshift(r1DBC, r1DDA), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1DE2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1DE7 = equal(r1DDA, body.constant(int(32)));
                              ir_if *f1DE6 = new(mem_ctx) ir_if(operand(r1DE7).val);
                              exec_list *const f1DE6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1DE6->then_instructions;

                                 body.emit(assign(r1DDB, r1DBB, 0x01));

                                 body.emit(assign(r1DDC, r1DBC, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1DE6->else_instructions;

                                 body.emit(assign(r1DD9, bit_or(r1DBA, r1DBB), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1DE9 = less(r1DDA, body.constant(int(64)));
                                 ir_if *f1DE8 = new(mem_ctx) ir_if(operand(r1DE9).val);
                                 exec_list *const f1DE8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1DE8->then_instructions;

                                    body.emit(assign(r1DDB, lshift(r1DBC, r1DDE), 0x01));

                                    ir_expression *const r1DEA = bit_and(r1DDA, body.constant(int(31)));
                                    body.emit(assign(r1DDC, rshift(r1DBC, r1DEA), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1DE8->else_instructions;

                                    ir_variable *const r1DEB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1DED = equal(r1DDA, body.constant(int(64)));
                                    ir_if *f1DEC = new(mem_ctx) ir_if(operand(r1DED).val);
                                    exec_list *const f1DEC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1DEC->then_instructions;

                                       body.emit(assign(r1DEB, r1DBC, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1DEC->else_instructions;

                                       ir_expression *const r1DEE = nequal(r1DBC, body.constant(0u));
                                       ir_expression *const r1DEF = expr(ir_unop_b2i, r1DEE);
                                       body.emit(assign(r1DEB, expr(ir_unop_i2u, r1DEF), 0x01));


                                    body.instructions = f1DEC_parent_instructions;
                                    body.emit(f1DEC);

                                    /* END IF */

                                    body.emit(assign(r1DDB, r1DEB, 0x01));

                                    body.emit(assign(r1DDC, body.constant(0u), 0x01));


                                 body.instructions = f1DE8_parent_instructions;
                                 body.emit(f1DE8);

                                 /* END IF */


                              body.instructions = f1DE6_parent_instructions;
                              body.emit(f1DE6);

                              /* END IF */

                              body.emit(assign(r1DDD, body.constant(0u), 0x01));


                           body.instructions = f1DE2_parent_instructions;
                           body.emit(f1DE2);

                           /* END IF */

                           ir_expression *const r1DF0 = nequal(r1DD9, body.constant(0u));
                           ir_expression *const r1DF1 = expr(ir_unop_b2i, r1DF0);
                           ir_expression *const r1DF2 = expr(ir_unop_i2u, r1DF1);
                           body.emit(assign(r1DDB, bit_or(r1DDB, r1DF2), 0x01));


                        body.instructions = f1DE0_parent_instructions;
                        body.emit(f1DE0);

                        /* END IF */

                        body.emit(assign(r1DC3, r1DDD, 0x01));

                        body.emit(assign(r1DC4, r1DDC, 0x01));

                        body.emit(assign(r1DC5, r1DDB, 0x01));

                        body.emit(assign(r1DC2, body.constant(int(0)), 0x01));

                        body.emit(assign(r1DC8, less(r1DDB, body.constant(0u)), 0x01));


                     body.instructions = f1DD7_parent_instructions;
                     body.emit(f1DD7);

                     /* END IF */


                  body.instructions = f1DD4_parent_instructions;
                  body.emit(f1DD4);

                  /* END IF */


               body.instructions = f1DCA_parent_instructions;
               body.emit(f1DCA);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1DF3 = new(mem_ctx) ir_if(operand(r1DC6).val);
               exec_list *const f1DF3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1DF3->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1DF4 = new(mem_ctx) ir_if(operand(r1DC8).val);
                  exec_list *const f1DF4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DF4->then_instructions;

                     ir_variable *const r1DF5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1DF5, add(r1DC4, body.constant(1u)), 0x01));

                     ir_expression *const r1DF6 = less(r1DF5, r1DC4);
                     ir_expression *const r1DF7 = expr(ir_unop_b2i, r1DF6);
                     ir_expression *const r1DF8 = expr(ir_unop_i2u, r1DF7);
                     body.emit(assign(r1DC3, add(r1DC3, r1DF8), 0x01));

                     ir_expression *const r1DF9 = equal(r1DC5, body.constant(0u));
                     ir_expression *const r1DFA = expr(ir_unop_b2i, r1DF9);
                     ir_expression *const r1DFB = expr(ir_unop_i2u, r1DFA);
                     ir_expression *const r1DFC = add(r1DC5, r1DFB);
                     ir_expression *const r1DFD = bit_and(r1DFC, body.constant(1u));
                     ir_expression *const r1DFE = expr(ir_unop_bit_not, r1DFD);
                     body.emit(assign(r1DC4, bit_and(r1DF5, r1DFE), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1DF4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1E00 = bit_or(r1DC3, r1DC4);
                     ir_expression *const r1E01 = equal(r1E00, body.constant(0u));
                     ir_if *f1DFF = new(mem_ctx) ir_if(operand(r1E01).val);
                     exec_list *const f1DFF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1DFF->then_instructions;

                        body.emit(assign(r1DC2, body.constant(int(0)), 0x01));


                     body.instructions = f1DFF_parent_instructions;
                     body.emit(f1DFF);

                     /* END IF */


                  body.instructions = f1DF4_parent_instructions;
                  body.emit(f1DF4);

                  /* END IF */

                  ir_variable *const r1E02 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1E02);
                  ir_expression *const r1E03 = lshift(r1CAB, body.constant(int(31)));
                  ir_expression *const r1E04 = expr(ir_unop_i2u, r1DC2);
                  ir_expression *const r1E05 = lshift(r1E04, body.constant(int(20)));
                  ir_expression *const r1E06 = add(r1E03, r1E05);
                  body.emit(assign(r1E02, add(r1E06, r1DC3), 0x02));

                  body.emit(assign(r1E02, r1DC4, 0x01));

                  body.emit(assign(r1DC7, r1E02, 0x03));

                  body.emit(assign(r1DC6, body.constant(false), 0x01));


               body.instructions = f1DF3_parent_instructions;
               body.emit(f1DF3);

               /* END IF */

               body.emit(assign(r1CAF, r1DC7, 0x03));

               body.emit(assign(r1CAE, body.constant(false), 0x01));


            body.instructions = f1D73_parent_instructions;
            body.emit(f1D73);

            /* END IF */


         body.instructions = f1D6C_parent_instructions;
         body.emit(f1D6C);

         /* END IF */

         body.emit(assign(r1CAA, r1CAF, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1CAC->else_instructions;

         ir_variable *const r1E07 = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r1E07, r1CAB, 0x01));

         ir_variable *const r1E08 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r1E09 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r1E09);
         ir_variable *const r1E0A = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r1E0A);
         ir_variable *const r1E0B = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r1E0B);
         ir_variable *const r1E0C = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r1E0C);
         ir_variable *const r1E0D = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r1E0D);
         ir_variable *const r1E0E = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r1E0E);
         ir_variable *const r1E0F = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r1E0F);
         ir_variable *const r1E10 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r1E10);
         ir_variable *const r1E11 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r1E11, body.constant(0u), 0x01));

         ir_variable *const r1E12 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r1E13 = rshift(swizzle_y(r1C76), body.constant(int(20)));
         ir_expression *const r1E14 = bit_and(r1E13, body.constant(2047u));
         body.emit(assign(r1E12, expr(ir_unop_u2i, r1E14), 0x01));

         body.emit(assign(r1E0B, r1E12, 0x01));

         body.emit(assign(r1E0A, body.constant(int(1023)), 0x01));

         body.emit(assign(r1E09, add(r1E12, body.constant(int(-1023))), 0x01));

         ir_variable *const r1E15 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1E15, lshift(swizzle_x(r1C76), body.constant(int(10))), 0x01));

         ir_variable *const r1E16 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r1E17 = bit_and(swizzle_y(r1C76), body.constant(1048575u));
         ir_expression *const r1E18 = lshift(r1E17, body.constant(int(10)));
         ir_expression *const r1E19 = rshift(swizzle_x(r1C76), body.constant(int(22)));
         body.emit(assign(r1E16, bit_or(r1E18, r1E19), 0x01));

         body.emit(assign(r1E0E, r1E16, 0x01));

         body.emit(assign(r1E0F, r1E15, 0x01));

         ir_variable *const r1E1A = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1E1A, body.constant(0u), 0x01));

         ir_variable *const r1E1B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r1E1B, body.constant(0u), 0x01));

         body.emit(assign(r1E0C, r1E1B, 0x01));

         body.emit(assign(r1E0D, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r1E1D = less(body.constant(int(0)), r1E09);
         ir_if *f1E1C = new(mem_ctx) ir_if(operand(r1E1D).val);
         exec_list *const f1E1C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1E1C->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1E1F = equal(r1E12, body.constant(int(2047)));
            ir_if *f1E1E = new(mem_ctx) ir_if(operand(r1E1F).val);
            exec_list *const f1E1E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1E1E->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1E21 = bit_or(r1E16, r1E15);
               ir_expression *const r1E22 = nequal(r1E21, body.constant(0u));
               ir_if *f1E20 = new(mem_ctx) ir_if(operand(r1E22).val);
               exec_list *const f1E20_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E20->then_instructions;

                  ir_variable *const r1E23 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1E23, swizzle_x(r1C76), 0x01));

                  ir_variable *const r1E24 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r1E24, body.constant(0u), 0x01));

                  ir_variable *const r1E25 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r1E23, bit_or(swizzle_y(r1C76), body.constant(524288u)), 0x02));

                  body.emit(assign(r1E24, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r1E27 = lshift(swizzle_y(r1C76), body.constant(int(1)));
                  ir_expression *const r1E28 = lequal(body.constant(4292870144u), r1E27);
                  ir_expression *const r1E29 = nequal(swizzle_x(r1C76), body.constant(0u));
                  ir_expression *const r1E2A = bit_and(swizzle_y(r1C76), body.constant(1048575u));
                  ir_expression *const r1E2B = nequal(r1E2A, body.constant(0u));
                  ir_expression *const r1E2C = logic_or(r1E29, r1E2B);
                  ir_expression *const r1E2D = logic_and(r1E28, r1E2C);
                  ir_if *f1E26 = new(mem_ctx) ir_if(operand(r1E2D).val);
                  exec_list *const f1E26_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E26->then_instructions;

                     body.emit(assign(r1E25, r1E23, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E26->else_instructions;

                     body.emit(assign(r1E25, r1E24, 0x03));


                  body.instructions = f1E26_parent_instructions;
                  body.emit(f1E26);

                  /* END IF */

                  body.emit(assign(r1E08, r1E25, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1E20->else_instructions;

                  body.emit(assign(r1E08, r1C76, 0x03));


               body.instructions = f1E20_parent_instructions;
               body.emit(f1E20);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1E1E->else_instructions;

               body.emit(assign(r1E0C, body.constant(1073741824u), 0x01));

               ir_variable *const r1E2E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1E2E);
               ir_variable *const r1E2F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1E2F);
               ir_variable *const r1E30 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1E31 = neg(r1E09);
               body.emit(assign(r1E30, bit_and(r1E31, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1E33 = equal(r1E09, body.constant(int(0)));
               ir_if *f1E32 = new(mem_ctx) ir_if(operand(r1E33).val);
               exec_list *const f1E32_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E32->then_instructions;

                  body.emit(assign(r1E2E, body.constant(0u), 0x01));

                  body.emit(assign(r1E2F, r1E0C, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1E32->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1E35 = less(r1E09, body.constant(int(32)));
                  ir_if *f1E34 = new(mem_ctx) ir_if(operand(r1E35).val);
                  exec_list *const f1E34_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E34->then_instructions;

                     ir_expression *const r1E36 = lshift(body.constant(1073741824u), r1E30);
                     ir_expression *const r1E37 = bit_or(r1E36, body.constant(0u));
                     body.emit(assign(r1E2E, bit_or(r1E37, body.constant(0u)), 0x01));

                     body.emit(assign(r1E2F, rshift(body.constant(1073741824u), r1E09), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E34->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1E39 = equal(r1E09, body.constant(int(32)));
                     ir_if *f1E38 = new(mem_ctx) ir_if(operand(r1E39).val);
                     exec_list *const f1E38_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E38->then_instructions;

                        body.emit(assign(r1E2E, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1E38->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1E3B = less(r1E09, body.constant(int(64)));
                        ir_if *f1E3A = new(mem_ctx) ir_if(operand(r1E3B).val);
                        exec_list *const f1E3A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E3A->then_instructions;

                           ir_expression *const r1E3C = bit_and(r1E09, body.constant(int(31)));
                           ir_expression *const r1E3D = rshift(body.constant(1073741824u), r1E3C);
                           ir_expression *const r1E3E = lshift(body.constant(1073741824u), r1E30);
                           ir_expression *const r1E3F = bit_or(r1E3E, body.constant(0u));
                           ir_expression *const r1E40 = nequal(r1E3F, body.constant(0u));
                           ir_expression *const r1E41 = expr(ir_unop_b2i, r1E40);
                           ir_expression *const r1E42 = expr(ir_unop_i2u, r1E41);
                           body.emit(assign(r1E2E, bit_or(r1E3D, r1E42), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1E3A->else_instructions;

                           body.emit(assign(r1E2E, body.constant(1u), 0x01));


                        body.instructions = f1E3A_parent_instructions;
                        body.emit(f1E3A);

                        /* END IF */


                     body.instructions = f1E38_parent_instructions;
                     body.emit(f1E38);

                     /* END IF */

                     body.emit(assign(r1E2F, body.constant(0u), 0x01));


                  body.instructions = f1E34_parent_instructions;
                  body.emit(f1E34);

                  /* END IF */


               body.instructions = f1E32_parent_instructions;
               body.emit(f1E32);

               /* END IF */

               body.emit(assign(r1E0C, r1E2F, 0x01));

               body.emit(assign(r1E0D, r1E2E, 0x01));

               body.emit(assign(r1E0E, bit_or(r1E16, body.constant(1073741824u)), 0x01));

               ir_variable *const r1E43 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1E44 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r1E44, sub(r1E15, r1E2E), 0x01));

               ir_expression *const r1E45 = sub(r1E0E, r1E2F);
               ir_expression *const r1E46 = less(r1E15, r1E2E);
               ir_expression *const r1E47 = expr(ir_unop_b2i, r1E46);
               ir_expression *const r1E48 = expr(ir_unop_i2u, r1E47);
               body.emit(assign(r1E43, sub(r1E45, r1E48), 0x01));

               body.emit(assign(r1E10, add(r1E12, body.constant(int(-1))), 0x01));

               ir_variable *const r1E49 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1E49, add(r1E10, body.constant(int(-10))), 0x01));

               ir_variable *const r1E4A = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1E4A, r1E43, 0x01));

               ir_variable *const r1E4B = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1E4B, r1E44, 0x01));

               ir_variable *const r1E4C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r1E4C);
               ir_variable *const r1E4D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1E4D);
               /* IF CONDITION */
               ir_expression *const r1E4F = equal(r1E43, body.constant(0u));
               ir_if *f1E4E = new(mem_ctx) ir_if(operand(r1E4F).val);
               exec_list *const f1E4E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E4E->then_instructions;

                  body.emit(assign(r1E4A, r1E44, 0x01));

                  body.emit(assign(r1E4B, body.constant(0u), 0x01));

                  body.emit(assign(r1E49, add(r1E49, body.constant(int(-32))), 0x01));


               body.instructions = f1E4E_parent_instructions;
               body.emit(f1E4E);

               /* END IF */

               ir_variable *const r1E50 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r1E50, r1E4A, 0x01));

               ir_variable *const r1E51 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r1E52 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1E52);
               /* IF CONDITION */
               ir_expression *const r1E54 = equal(r1E4A, body.constant(0u));
               ir_if *f1E53 = new(mem_ctx) ir_if(operand(r1E54).val);
               exec_list *const f1E53_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E53->then_instructions;

                  body.emit(assign(r1E51, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1E53->else_instructions;

                  body.emit(assign(r1E52, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1E56 = bit_and(r1E4A, body.constant(4294901760u));
                  ir_expression *const r1E57 = equal(r1E56, body.constant(0u));
                  ir_if *f1E55 = new(mem_ctx) ir_if(operand(r1E57).val);
                  exec_list *const f1E55_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E55->then_instructions;

                     body.emit(assign(r1E52, body.constant(int(16)), 0x01));

                     body.emit(assign(r1E50, lshift(r1E4A, body.constant(int(16))), 0x01));


                  body.instructions = f1E55_parent_instructions;
                  body.emit(f1E55);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1E59 = bit_and(r1E50, body.constant(4278190080u));
                  ir_expression *const r1E5A = equal(r1E59, body.constant(0u));
                  ir_if *f1E58 = new(mem_ctx) ir_if(operand(r1E5A).val);
                  exec_list *const f1E58_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E58->then_instructions;

                     body.emit(assign(r1E52, add(r1E52, body.constant(int(8))), 0x01));

                     body.emit(assign(r1E50, lshift(r1E50, body.constant(int(8))), 0x01));


                  body.instructions = f1E58_parent_instructions;
                  body.emit(f1E58);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1E5C = bit_and(r1E50, body.constant(4026531840u));
                  ir_expression *const r1E5D = equal(r1E5C, body.constant(0u));
                  ir_if *f1E5B = new(mem_ctx) ir_if(operand(r1E5D).val);
                  exec_list *const f1E5B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E5B->then_instructions;

                     body.emit(assign(r1E52, add(r1E52, body.constant(int(4))), 0x01));

                     body.emit(assign(r1E50, lshift(r1E50, body.constant(int(4))), 0x01));


                  body.instructions = f1E5B_parent_instructions;
                  body.emit(f1E5B);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1E5F = bit_and(r1E50, body.constant(3221225472u));
                  ir_expression *const r1E60 = equal(r1E5F, body.constant(0u));
                  ir_if *f1E5E = new(mem_ctx) ir_if(operand(r1E60).val);
                  exec_list *const f1E5E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E5E->then_instructions;

                     body.emit(assign(r1E52, add(r1E52, body.constant(int(2))), 0x01));

                     body.emit(assign(r1E50, lshift(r1E50, body.constant(int(2))), 0x01));


                  body.instructions = f1E5E_parent_instructions;
                  body.emit(f1E5E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1E62 = bit_and(r1E50, body.constant(2147483648u));
                  ir_expression *const r1E63 = equal(r1E62, body.constant(0u));
                  ir_if *f1E61 = new(mem_ctx) ir_if(operand(r1E63).val);
                  exec_list *const f1E61_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E61->then_instructions;

                     body.emit(assign(r1E52, add(r1E52, body.constant(int(1))), 0x01));


                  body.instructions = f1E61_parent_instructions;
                  body.emit(f1E61);

                  /* END IF */

                  body.emit(assign(r1E51, r1E52, 0x01));


               body.instructions = f1E53_parent_instructions;
               body.emit(f1E53);

               /* END IF */

               body.emit(assign(r1E4D, add(r1E51, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1E65 = lequal(body.constant(int(0)), r1E4D);
               ir_if *f1E64 = new(mem_ctx) ir_if(operand(r1E65).val);
               exec_list *const f1E64_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E64->then_instructions;

                  body.emit(assign(r1E4C, body.constant(0u), 0x01));

                  ir_variable *const r1E66 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1E66, lshift(r1E4B, r1E4D), 0x01));

                  ir_variable *const r1E67 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1E69 = equal(r1E4D, body.constant(int(0)));
                  ir_if *f1E68 = new(mem_ctx) ir_if(operand(r1E69).val);
                  exec_list *const f1E68_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E68->then_instructions;

                     body.emit(assign(r1E67, r1E4A, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E68->else_instructions;

                     ir_expression *const r1E6A = lshift(r1E4A, r1E4D);
                     ir_expression *const r1E6B = neg(r1E4D);
                     ir_expression *const r1E6C = bit_and(r1E6B, body.constant(int(31)));
                     ir_expression *const r1E6D = rshift(r1E4B, r1E6C);
                     body.emit(assign(r1E67, bit_or(r1E6A, r1E6D), 0x01));


                  body.instructions = f1E68_parent_instructions;
                  body.emit(f1E68);

                  /* END IF */

                  body.emit(assign(r1E4A, r1E67, 0x01));

                  body.emit(assign(r1E4B, r1E66, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1E64->else_instructions;

                  ir_variable *const r1E6E = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r1E6E, body.constant(0u), 0x01));

                  ir_variable *const r1E6F = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1E6F, neg(r1E4D), 0x01));

                  ir_variable *const r1E70 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1E70);
                  ir_variable *const r1E71 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1E71);
                  ir_variable *const r1E72 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1E72);
                  ir_variable *const r1E73 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r1E74 = neg(r1E6F);
                  body.emit(assign(r1E73, bit_and(r1E74, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1E76 = equal(r1E6F, body.constant(int(0)));
                  ir_if *f1E75 = new(mem_ctx) ir_if(operand(r1E76).val);
                  exec_list *const f1E75_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E75->then_instructions;

                     body.emit(assign(r1E70, r1E6E, 0x01));

                     body.emit(assign(r1E71, r1E4B, 0x01));

                     body.emit(assign(r1E72, r1E4A, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E75->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1E78 = less(r1E6F, body.constant(int(32)));
                     ir_if *f1E77 = new(mem_ctx) ir_if(operand(r1E78).val);
                     exec_list *const f1E77_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E77->then_instructions;

                        body.emit(assign(r1E70, lshift(r1E4B, r1E73), 0x01));

                        ir_expression *const r1E79 = lshift(r1E4A, r1E73);
                        ir_expression *const r1E7A = rshift(r1E4B, r1E6F);
                        body.emit(assign(r1E71, bit_or(r1E79, r1E7A), 0x01));

                        body.emit(assign(r1E72, rshift(r1E4A, r1E6F), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1E77->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1E7C = equal(r1E6F, body.constant(int(32)));
                        ir_if *f1E7B = new(mem_ctx) ir_if(operand(r1E7C).val);
                        exec_list *const f1E7B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E7B->then_instructions;

                           body.emit(assign(r1E70, r1E4B, 0x01));

                           body.emit(assign(r1E71, r1E4A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1E7B->else_instructions;

                           body.emit(assign(r1E6E, bit_or(body.constant(0u), r1E4B), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1E7E = less(r1E6F, body.constant(int(64)));
                           ir_if *f1E7D = new(mem_ctx) ir_if(operand(r1E7E).val);
                           exec_list *const f1E7D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1E7D->then_instructions;

                              body.emit(assign(r1E70, lshift(r1E4A, r1E73), 0x01));

                              ir_expression *const r1E7F = bit_and(r1E6F, body.constant(int(31)));
                              body.emit(assign(r1E71, rshift(r1E4A, r1E7F), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1E7D->else_instructions;

                              ir_variable *const r1E80 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1E82 = equal(r1E6F, body.constant(int(64)));
                              ir_if *f1E81 = new(mem_ctx) ir_if(operand(r1E82).val);
                              exec_list *const f1E81_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E81->then_instructions;

                                 body.emit(assign(r1E80, r1E4A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1E81->else_instructions;

                                 ir_expression *const r1E83 = nequal(r1E4A, body.constant(0u));
                                 ir_expression *const r1E84 = expr(ir_unop_b2i, r1E83);
                                 body.emit(assign(r1E80, expr(ir_unop_i2u, r1E84), 0x01));


                              body.instructions = f1E81_parent_instructions;
                              body.emit(f1E81);

                              /* END IF */

                              body.emit(assign(r1E70, r1E80, 0x01));

                              body.emit(assign(r1E71, body.constant(0u), 0x01));


                           body.instructions = f1E7D_parent_instructions;
                           body.emit(f1E7D);

                           /* END IF */


                        body.instructions = f1E7B_parent_instructions;
                        body.emit(f1E7B);

                        /* END IF */

                        body.emit(assign(r1E72, body.constant(0u), 0x01));


                     body.instructions = f1E77_parent_instructions;
                     body.emit(f1E77);

                     /* END IF */

                     ir_expression *const r1E85 = nequal(r1E6E, body.constant(0u));
                     ir_expression *const r1E86 = expr(ir_unop_b2i, r1E85);
                     ir_expression *const r1E87 = expr(ir_unop_i2u, r1E86);
                     body.emit(assign(r1E70, bit_or(r1E70, r1E87), 0x01));


                  body.instructions = f1E75_parent_instructions;
                  body.emit(f1E75);

                  /* END IF */

                  body.emit(assign(r1E4A, r1E72, 0x01));

                  body.emit(assign(r1E4B, r1E71, 0x01));

                  body.emit(assign(r1E4C, r1E70, 0x01));


               body.instructions = f1E64_parent_instructions;
               body.emit(f1E64);

               /* END IF */

               body.emit(assign(r1E49, sub(r1E49, r1E4D), 0x01));

               ir_variable *const r1E88 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1E88, r1E49, 0x01));

               ir_variable *const r1E89 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1E89, r1E4A, 0x01));

               ir_variable *const r1E8A = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1E8A, r1E4B, 0x01));

               ir_variable *const r1E8B = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1E8B, r1E4C, 0x01));

               ir_variable *const r1E8C = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1E8C, body.constant(true), 0x01));

               ir_variable *const r1E8D = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1E8E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1E8E);
               ir_expression *const r1E8F = expr(ir_unop_u2i, r1E4C);
               body.emit(assign(r1E8E, less(r1E8F, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1E91 = lequal(body.constant(int(2045)), r1E49);
               ir_if *f1E90 = new(mem_ctx) ir_if(operand(r1E91).val);
               exec_list *const f1E90_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E90->then_instructions;

                  ir_variable *const r1E92 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1E94 = less(body.constant(int(2045)), r1E49);
                  ir_if *f1E93 = new(mem_ctx) ir_if(operand(r1E94).val);
                  exec_list *const f1E93_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E93->then_instructions;

                     body.emit(assign(r1E92, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E93->else_instructions;

                     ir_variable *const r1E95 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1E97 = equal(r1E49, body.constant(int(2045)));
                     ir_if *f1E96 = new(mem_ctx) ir_if(operand(r1E97).val);
                     exec_list *const f1E96_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E96->then_instructions;

                        ir_expression *const r1E98 = equal(body.constant(2097151u), r1E4A);
                        ir_expression *const r1E99 = equal(body.constant(4294967295u), r1E4B);
                        body.emit(assign(r1E95, logic_and(r1E98, r1E99), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1E96->else_instructions;

                        body.emit(assign(r1E95, body.constant(false), 0x01));


                     body.instructions = f1E96_parent_instructions;
                     body.emit(f1E96);

                     /* END IF */

                     body.emit(assign(r1E92, logic_and(r1E95, r1E8E), 0x01));


                  body.instructions = f1E93_parent_instructions;
                  body.emit(f1E93);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1E9A = new(mem_ctx) ir_if(operand(r1E92).val);
                  exec_list *const f1E9A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E9A->then_instructions;

                     ir_variable *const r1E9B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1E9B);
                     ir_expression *const r1E9C = lshift(r1CAB, body.constant(int(31)));
                     body.emit(assign(r1E9B, add(r1E9C, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1E9B, body.constant(0u), 0x01));

                     body.emit(assign(r1E8D, r1E9B, 0x03));

                     body.emit(assign(r1E8C, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E9A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1E9E = less(r1E49, body.constant(int(0)));
                     ir_if *f1E9D = new(mem_ctx) ir_if(operand(r1E9E).val);
                     exec_list *const f1E9D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E9D->then_instructions;

                        ir_variable *const r1E9F = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1E9F, r1E4C, 0x01));

                        ir_variable *const r1EA0 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1EA0, neg(r1E49), 0x01));

                        ir_variable *const r1EA1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1EA1);
                        ir_variable *const r1EA2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1EA2);
                        ir_variable *const r1EA3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1EA3);
                        ir_variable *const r1EA4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1EA5 = neg(r1EA0);
                        body.emit(assign(r1EA4, bit_and(r1EA5, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1EA7 = equal(r1EA0, body.constant(int(0)));
                        ir_if *f1EA6 = new(mem_ctx) ir_if(operand(r1EA7).val);
                        exec_list *const f1EA6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1EA6->then_instructions;

                           body.emit(assign(r1EA1, r1E4C, 0x01));

                           body.emit(assign(r1EA2, r1E4B, 0x01));

                           body.emit(assign(r1EA3, r1E4A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1EA6->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1EA9 = less(r1EA0, body.constant(int(32)));
                           ir_if *f1EA8 = new(mem_ctx) ir_if(operand(r1EA9).val);
                           exec_list *const f1EA8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EA8->then_instructions;

                              body.emit(assign(r1EA1, lshift(r1E4B, r1EA4), 0x01));

                              ir_expression *const r1EAA = lshift(r1E4A, r1EA4);
                              ir_expression *const r1EAB = rshift(r1E4B, r1EA0);
                              body.emit(assign(r1EA2, bit_or(r1EAA, r1EAB), 0x01));

                              body.emit(assign(r1EA3, rshift(r1E4A, r1EA0), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1EA8->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1EAD = equal(r1EA0, body.constant(int(32)));
                              ir_if *f1EAC = new(mem_ctx) ir_if(operand(r1EAD).val);
                              exec_list *const f1EAC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1EAC->then_instructions;

                                 body.emit(assign(r1EA1, r1E4B, 0x01));

                                 body.emit(assign(r1EA2, r1E4A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1EAC->else_instructions;

                                 body.emit(assign(r1E9F, bit_or(r1E4C, r1E4B), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1EAF = less(r1EA0, body.constant(int(64)));
                                 ir_if *f1EAE = new(mem_ctx) ir_if(operand(r1EAF).val);
                                 exec_list *const f1EAE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1EAE->then_instructions;

                                    body.emit(assign(r1EA1, lshift(r1E4A, r1EA4), 0x01));

                                    ir_expression *const r1EB0 = bit_and(r1EA0, body.constant(int(31)));
                                    body.emit(assign(r1EA2, rshift(r1E4A, r1EB0), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1EAE->else_instructions;

                                    ir_variable *const r1EB1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1EB3 = equal(r1EA0, body.constant(int(64)));
                                    ir_if *f1EB2 = new(mem_ctx) ir_if(operand(r1EB3).val);
                                    exec_list *const f1EB2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1EB2->then_instructions;

                                       body.emit(assign(r1EB1, r1E4A, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1EB2->else_instructions;

                                       ir_expression *const r1EB4 = nequal(r1E4A, body.constant(0u));
                                       ir_expression *const r1EB5 = expr(ir_unop_b2i, r1EB4);
                                       body.emit(assign(r1EB1, expr(ir_unop_i2u, r1EB5), 0x01));


                                    body.instructions = f1EB2_parent_instructions;
                                    body.emit(f1EB2);

                                    /* END IF */

                                    body.emit(assign(r1EA1, r1EB1, 0x01));

                                    body.emit(assign(r1EA2, body.constant(0u), 0x01));


                                 body.instructions = f1EAE_parent_instructions;
                                 body.emit(f1EAE);

                                 /* END IF */


                              body.instructions = f1EAC_parent_instructions;
                              body.emit(f1EAC);

                              /* END IF */

                              body.emit(assign(r1EA3, body.constant(0u), 0x01));


                           body.instructions = f1EA8_parent_instructions;
                           body.emit(f1EA8);

                           /* END IF */

                           ir_expression *const r1EB6 = nequal(r1E9F, body.constant(0u));
                           ir_expression *const r1EB7 = expr(ir_unop_b2i, r1EB6);
                           ir_expression *const r1EB8 = expr(ir_unop_i2u, r1EB7);
                           body.emit(assign(r1EA1, bit_or(r1EA1, r1EB8), 0x01));


                        body.instructions = f1EA6_parent_instructions;
                        body.emit(f1EA6);

                        /* END IF */

                        body.emit(assign(r1E89, r1EA3, 0x01));

                        body.emit(assign(r1E8A, r1EA2, 0x01));

                        body.emit(assign(r1E8B, r1EA1, 0x01));

                        body.emit(assign(r1E88, body.constant(int(0)), 0x01));

                        body.emit(assign(r1E8E, less(r1EA1, body.constant(0u)), 0x01));


                     body.instructions = f1E9D_parent_instructions;
                     body.emit(f1E9D);

                     /* END IF */


                  body.instructions = f1E9A_parent_instructions;
                  body.emit(f1E9A);

                  /* END IF */


               body.instructions = f1E90_parent_instructions;
               body.emit(f1E90);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1EB9 = new(mem_ctx) ir_if(operand(r1E8C).val);
               exec_list *const f1EB9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1EB9->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1EBA = new(mem_ctx) ir_if(operand(r1E8E).val);
                  exec_list *const f1EBA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1EBA->then_instructions;

                     ir_variable *const r1EBB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1EBB, add(r1E8A, body.constant(1u)), 0x01));

                     ir_expression *const r1EBC = less(r1EBB, r1E8A);
                     ir_expression *const r1EBD = expr(ir_unop_b2i, r1EBC);
                     ir_expression *const r1EBE = expr(ir_unop_i2u, r1EBD);
                     body.emit(assign(r1E89, add(r1E89, r1EBE), 0x01));

                     ir_expression *const r1EBF = equal(r1E8B, body.constant(0u));
                     ir_expression *const r1EC0 = expr(ir_unop_b2i, r1EBF);
                     ir_expression *const r1EC1 = expr(ir_unop_i2u, r1EC0);
                     ir_expression *const r1EC2 = add(r1E8B, r1EC1);
                     ir_expression *const r1EC3 = bit_and(r1EC2, body.constant(1u));
                     ir_expression *const r1EC4 = expr(ir_unop_bit_not, r1EC3);
                     body.emit(assign(r1E8A, bit_and(r1EBB, r1EC4), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1EBA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1EC6 = bit_or(r1E89, r1E8A);
                     ir_expression *const r1EC7 = equal(r1EC6, body.constant(0u));
                     ir_if *f1EC5 = new(mem_ctx) ir_if(operand(r1EC7).val);
                     exec_list *const f1EC5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1EC5->then_instructions;

                        body.emit(assign(r1E88, body.constant(int(0)), 0x01));


                     body.instructions = f1EC5_parent_instructions;
                     body.emit(f1EC5);

                     /* END IF */


                  body.instructions = f1EBA_parent_instructions;
                  body.emit(f1EBA);

                  /* END IF */

                  ir_variable *const r1EC8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1EC8);
                  ir_expression *const r1EC9 = lshift(r1CAB, body.constant(int(31)));
                  ir_expression *const r1ECA = expr(ir_unop_i2u, r1E88);
                  ir_expression *const r1ECB = lshift(r1ECA, body.constant(int(20)));
                  ir_expression *const r1ECC = add(r1EC9, r1ECB);
                  body.emit(assign(r1EC8, add(r1ECC, r1E89), 0x02));

                  body.emit(assign(r1EC8, r1E8A, 0x01));

                  body.emit(assign(r1E8D, r1EC8, 0x03));

                  body.emit(assign(r1E8C, body.constant(false), 0x01));


               body.instructions = f1EB9_parent_instructions;
               body.emit(f1EB9);

               /* END IF */

               body.emit(assign(r1E08, r1E8D, 0x03));


            body.instructions = f1E1E_parent_instructions;
            body.emit(f1E1E);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1E1C->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1ECE = less(r1E09, body.constant(int(0)));
            ir_if *f1ECD = new(mem_ctx) ir_if(operand(r1ECE).val);
            exec_list *const f1ECD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1ECD->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1ED0 = equal(r1E12, body.constant(int(0)));
               ir_if *f1ECF = new(mem_ctx) ir_if(operand(r1ED0).val);
               exec_list *const f1ECF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1ECF->then_instructions;

                  body.emit(assign(r1E09, add(r1E09, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1ECF->else_instructions;

                  body.emit(assign(r1E0E, bit_or(r1E0E, body.constant(1073741824u)), 0x01));


               body.instructions = f1ECF_parent_instructions;
               body.emit(f1ECF);

               /* END IF */

               ir_variable *const r1ED1 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r1ED1, neg(r1E09), 0x01));

               ir_variable *const r1ED2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1ED2);
               ir_variable *const r1ED3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1ED3);
               ir_variable *const r1ED4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1ED5 = neg(r1ED1);
               body.emit(assign(r1ED4, bit_and(r1ED5, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1ED7 = equal(r1ED1, body.constant(int(0)));
               ir_if *f1ED6 = new(mem_ctx) ir_if(operand(r1ED7).val);
               exec_list *const f1ED6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1ED6->then_instructions;

                  body.emit(assign(r1ED2, r1E15, 0x01));

                  body.emit(assign(r1ED3, r1E0E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1ED6->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1ED9 = less(r1ED1, body.constant(int(32)));
                  ir_if *f1ED8 = new(mem_ctx) ir_if(operand(r1ED9).val);
                  exec_list *const f1ED8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1ED8->then_instructions;

                     ir_expression *const r1EDA = lshift(r1E0E, r1ED4);
                     ir_expression *const r1EDB = rshift(r1E15, r1ED1);
                     ir_expression *const r1EDC = bit_or(r1EDA, r1EDB);
                     ir_expression *const r1EDD = lshift(r1E15, r1ED4);
                     ir_expression *const r1EDE = nequal(r1EDD, body.constant(0u));
                     ir_expression *const r1EDF = expr(ir_unop_b2i, r1EDE);
                     ir_expression *const r1EE0 = expr(ir_unop_i2u, r1EDF);
                     body.emit(assign(r1ED2, bit_or(r1EDC, r1EE0), 0x01));

                     body.emit(assign(r1ED3, rshift(r1E0E, r1ED1), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1ED8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1EE2 = equal(r1ED1, body.constant(int(32)));
                     ir_if *f1EE1 = new(mem_ctx) ir_if(operand(r1EE2).val);
                     exec_list *const f1EE1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1EE1->then_instructions;

                        ir_expression *const r1EE3 = nequal(r1E15, body.constant(0u));
                        ir_expression *const r1EE4 = expr(ir_unop_b2i, r1EE3);
                        ir_expression *const r1EE5 = expr(ir_unop_i2u, r1EE4);
                        body.emit(assign(r1ED2, bit_or(r1E0E, r1EE5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1EE1->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1EE7 = less(r1ED1, body.constant(int(64)));
                        ir_if *f1EE6 = new(mem_ctx) ir_if(operand(r1EE7).val);
                        exec_list *const f1EE6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1EE6->then_instructions;

                           ir_expression *const r1EE8 = bit_and(r1ED1, body.constant(int(31)));
                           ir_expression *const r1EE9 = rshift(r1E0E, r1EE8);
                           ir_expression *const r1EEA = lshift(r1E0E, r1ED4);
                           ir_expression *const r1EEB = bit_or(r1EEA, r1E15);
                           ir_expression *const r1EEC = nequal(r1EEB, body.constant(0u));
                           ir_expression *const r1EED = expr(ir_unop_b2i, r1EEC);
                           ir_expression *const r1EEE = expr(ir_unop_i2u, r1EED);
                           body.emit(assign(r1ED2, bit_or(r1EE9, r1EEE), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1EE6->else_instructions;

                           ir_expression *const r1EEF = bit_or(r1E0E, r1E15);
                           ir_expression *const r1EF0 = nequal(r1EEF, body.constant(0u));
                           ir_expression *const r1EF1 = expr(ir_unop_b2i, r1EF0);
                           body.emit(assign(r1ED2, expr(ir_unop_i2u, r1EF1), 0x01));


                        body.instructions = f1EE6_parent_instructions;
                        body.emit(f1EE6);

                        /* END IF */


                     body.instructions = f1EE1_parent_instructions;
                     body.emit(f1EE1);

                     /* END IF */

                     body.emit(assign(r1ED3, body.constant(0u), 0x01));


                  body.instructions = f1ED8_parent_instructions;
                  body.emit(f1ED8);

                  /* END IF */


               body.instructions = f1ED6_parent_instructions;
               body.emit(f1ED6);

               /* END IF */

               body.emit(assign(r1E0E, r1ED3, 0x01));

               body.emit(assign(r1E0F, r1ED2, 0x01));

               body.emit(assign(r1E0C, bit_or(r1E0C, body.constant(1073741824u)), 0x01));

               ir_variable *const r1EF2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1EF3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r1EF3, sub(r1E0D, r1ED2), 0x01));

               ir_expression *const r1EF4 = sub(r1E0C, r1ED3);
               ir_expression *const r1EF5 = less(r1E0D, r1ED2);
               ir_expression *const r1EF6 = expr(ir_unop_b2i, r1EF5);
               ir_expression *const r1EF7 = expr(ir_unop_i2u, r1EF6);
               body.emit(assign(r1EF2, sub(r1EF4, r1EF7), 0x01));

               body.emit(assign(r1E07, bit_xor(r1CAB, body.constant(1u)), 0x01));

               body.emit(assign(r1E10, body.constant(int(1022)), 0x01));

               ir_variable *const r1EF8 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1EF8, body.constant(int(1012)), 0x01));

               ir_variable *const r1EF9 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1EF9, r1EF2, 0x01));

               ir_variable *const r1EFA = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1EFA, r1EF3, 0x01));

               ir_variable *const r1EFB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r1EFB);
               ir_variable *const r1EFC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1EFC);
               /* IF CONDITION */
               ir_expression *const r1EFE = equal(r1EF2, body.constant(0u));
               ir_if *f1EFD = new(mem_ctx) ir_if(operand(r1EFE).val);
               exec_list *const f1EFD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1EFD->then_instructions;

                  body.emit(assign(r1EF9, r1EF3, 0x01));

                  body.emit(assign(r1EFA, body.constant(0u), 0x01));

                  body.emit(assign(r1EF8, body.constant(int(980)), 0x01));


               body.instructions = f1EFD_parent_instructions;
               body.emit(f1EFD);

               /* END IF */

               ir_variable *const r1EFF = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r1EFF, r1EF9, 0x01));

               ir_variable *const r1F00 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r1F01 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1F01);
               /* IF CONDITION */
               ir_expression *const r1F03 = equal(r1EF9, body.constant(0u));
               ir_if *f1F02 = new(mem_ctx) ir_if(operand(r1F03).val);
               exec_list *const f1F02_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F02->then_instructions;

                  body.emit(assign(r1F00, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1F02->else_instructions;

                  body.emit(assign(r1F01, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1F05 = bit_and(r1EF9, body.constant(4294901760u));
                  ir_expression *const r1F06 = equal(r1F05, body.constant(0u));
                  ir_if *f1F04 = new(mem_ctx) ir_if(operand(r1F06).val);
                  exec_list *const f1F04_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F04->then_instructions;

                     body.emit(assign(r1F01, body.constant(int(16)), 0x01));

                     body.emit(assign(r1EFF, lshift(r1EF9, body.constant(int(16))), 0x01));


                  body.instructions = f1F04_parent_instructions;
                  body.emit(f1F04);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1F08 = bit_and(r1EFF, body.constant(4278190080u));
                  ir_expression *const r1F09 = equal(r1F08, body.constant(0u));
                  ir_if *f1F07 = new(mem_ctx) ir_if(operand(r1F09).val);
                  exec_list *const f1F07_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F07->then_instructions;

                     body.emit(assign(r1F01, add(r1F01, body.constant(int(8))), 0x01));

                     body.emit(assign(r1EFF, lshift(r1EFF, body.constant(int(8))), 0x01));


                  body.instructions = f1F07_parent_instructions;
                  body.emit(f1F07);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1F0B = bit_and(r1EFF, body.constant(4026531840u));
                  ir_expression *const r1F0C = equal(r1F0B, body.constant(0u));
                  ir_if *f1F0A = new(mem_ctx) ir_if(operand(r1F0C).val);
                  exec_list *const f1F0A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F0A->then_instructions;

                     body.emit(assign(r1F01, add(r1F01, body.constant(int(4))), 0x01));

                     body.emit(assign(r1EFF, lshift(r1EFF, body.constant(int(4))), 0x01));


                  body.instructions = f1F0A_parent_instructions;
                  body.emit(f1F0A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1F0E = bit_and(r1EFF, body.constant(3221225472u));
                  ir_expression *const r1F0F = equal(r1F0E, body.constant(0u));
                  ir_if *f1F0D = new(mem_ctx) ir_if(operand(r1F0F).val);
                  exec_list *const f1F0D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F0D->then_instructions;

                     body.emit(assign(r1F01, add(r1F01, body.constant(int(2))), 0x01));

                     body.emit(assign(r1EFF, lshift(r1EFF, body.constant(int(2))), 0x01));


                  body.instructions = f1F0D_parent_instructions;
                  body.emit(f1F0D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1F11 = bit_and(r1EFF, body.constant(2147483648u));
                  ir_expression *const r1F12 = equal(r1F11, body.constant(0u));
                  ir_if *f1F10 = new(mem_ctx) ir_if(operand(r1F12).val);
                  exec_list *const f1F10_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F10->then_instructions;

                     body.emit(assign(r1F01, add(r1F01, body.constant(int(1))), 0x01));


                  body.instructions = f1F10_parent_instructions;
                  body.emit(f1F10);

                  /* END IF */

                  body.emit(assign(r1F00, r1F01, 0x01));


               body.instructions = f1F02_parent_instructions;
               body.emit(f1F02);

               /* END IF */

               body.emit(assign(r1EFC, add(r1F00, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1F14 = lequal(body.constant(int(0)), r1EFC);
               ir_if *f1F13 = new(mem_ctx) ir_if(operand(r1F14).val);
               exec_list *const f1F13_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F13->then_instructions;

                  body.emit(assign(r1EFB, body.constant(0u), 0x01));

                  ir_variable *const r1F15 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1F15, lshift(r1EFA, r1EFC), 0x01));

                  ir_variable *const r1F16 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1F18 = equal(r1EFC, body.constant(int(0)));
                  ir_if *f1F17 = new(mem_ctx) ir_if(operand(r1F18).val);
                  exec_list *const f1F17_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F17->then_instructions;

                     body.emit(assign(r1F16, r1EF9, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F17->else_instructions;

                     ir_expression *const r1F19 = lshift(r1EF9, r1EFC);
                     ir_expression *const r1F1A = neg(r1EFC);
                     ir_expression *const r1F1B = bit_and(r1F1A, body.constant(int(31)));
                     ir_expression *const r1F1C = rshift(r1EFA, r1F1B);
                     body.emit(assign(r1F16, bit_or(r1F19, r1F1C), 0x01));


                  body.instructions = f1F17_parent_instructions;
                  body.emit(f1F17);

                  /* END IF */

                  body.emit(assign(r1EF9, r1F16, 0x01));

                  body.emit(assign(r1EFA, r1F15, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1F13->else_instructions;

                  ir_variable *const r1F1D = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r1F1D, body.constant(0u), 0x01));

                  ir_variable *const r1F1E = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1F1E, neg(r1EFC), 0x01));

                  ir_variable *const r1F1F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1F1F);
                  ir_variable *const r1F20 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1F20);
                  ir_variable *const r1F21 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1F21);
                  ir_variable *const r1F22 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r1F23 = neg(r1F1E);
                  body.emit(assign(r1F22, bit_and(r1F23, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1F25 = equal(r1F1E, body.constant(int(0)));
                  ir_if *f1F24 = new(mem_ctx) ir_if(operand(r1F25).val);
                  exec_list *const f1F24_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F24->then_instructions;

                     body.emit(assign(r1F1F, r1F1D, 0x01));

                     body.emit(assign(r1F20, r1EFA, 0x01));

                     body.emit(assign(r1F21, r1EF9, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F24->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1F27 = less(r1F1E, body.constant(int(32)));
                     ir_if *f1F26 = new(mem_ctx) ir_if(operand(r1F27).val);
                     exec_list *const f1F26_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1F26->then_instructions;

                        body.emit(assign(r1F1F, lshift(r1EFA, r1F22), 0x01));

                        ir_expression *const r1F28 = lshift(r1EF9, r1F22);
                        ir_expression *const r1F29 = rshift(r1EFA, r1F1E);
                        body.emit(assign(r1F20, bit_or(r1F28, r1F29), 0x01));

                        body.emit(assign(r1F21, rshift(r1EF9, r1F1E), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1F26->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1F2B = equal(r1F1E, body.constant(int(32)));
                        ir_if *f1F2A = new(mem_ctx) ir_if(operand(r1F2B).val);
                        exec_list *const f1F2A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F2A->then_instructions;

                           body.emit(assign(r1F1F, r1EFA, 0x01));

                           body.emit(assign(r1F20, r1EF9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1F2A->else_instructions;

                           body.emit(assign(r1F1D, bit_or(body.constant(0u), r1EFA), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1F2D = less(r1F1E, body.constant(int(64)));
                           ir_if *f1F2C = new(mem_ctx) ir_if(operand(r1F2D).val);
                           exec_list *const f1F2C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F2C->then_instructions;

                              body.emit(assign(r1F1F, lshift(r1EF9, r1F22), 0x01));

                              ir_expression *const r1F2E = bit_and(r1F1E, body.constant(int(31)));
                              body.emit(assign(r1F20, rshift(r1EF9, r1F2E), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F2C->else_instructions;

                              ir_variable *const r1F2F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1F31 = equal(r1F1E, body.constant(int(64)));
                              ir_if *f1F30 = new(mem_ctx) ir_if(operand(r1F31).val);
                              exec_list *const f1F30_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F30->then_instructions;

                                 body.emit(assign(r1F2F, r1EF9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1F30->else_instructions;

                                 ir_expression *const r1F32 = nequal(r1EF9, body.constant(0u));
                                 ir_expression *const r1F33 = expr(ir_unop_b2i, r1F32);
                                 body.emit(assign(r1F2F, expr(ir_unop_i2u, r1F33), 0x01));


                              body.instructions = f1F30_parent_instructions;
                              body.emit(f1F30);

                              /* END IF */

                              body.emit(assign(r1F1F, r1F2F, 0x01));

                              body.emit(assign(r1F20, body.constant(0u), 0x01));


                           body.instructions = f1F2C_parent_instructions;
                           body.emit(f1F2C);

                           /* END IF */


                        body.instructions = f1F2A_parent_instructions;
                        body.emit(f1F2A);

                        /* END IF */

                        body.emit(assign(r1F21, body.constant(0u), 0x01));


                     body.instructions = f1F26_parent_instructions;
                     body.emit(f1F26);

                     /* END IF */

                     ir_expression *const r1F34 = nequal(r1F1D, body.constant(0u));
                     ir_expression *const r1F35 = expr(ir_unop_b2i, r1F34);
                     ir_expression *const r1F36 = expr(ir_unop_i2u, r1F35);
                     body.emit(assign(r1F1F, bit_or(r1F1F, r1F36), 0x01));


                  body.instructions = f1F24_parent_instructions;
                  body.emit(f1F24);

                  /* END IF */

                  body.emit(assign(r1EF9, r1F21, 0x01));

                  body.emit(assign(r1EFA, r1F20, 0x01));

                  body.emit(assign(r1EFB, r1F1F, 0x01));


               body.instructions = f1F13_parent_instructions;
               body.emit(f1F13);

               /* END IF */

               body.emit(assign(r1EF8, sub(r1EF8, r1EFC), 0x01));

               ir_variable *const r1F37 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1F37, r1EF8, 0x01));

               ir_variable *const r1F38 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1F38, r1EF9, 0x01));

               ir_variable *const r1F39 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1F39, r1EFA, 0x01));

               ir_variable *const r1F3A = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1F3A, r1EFB, 0x01));

               ir_variable *const r1F3B = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1F3B, body.constant(true), 0x01));

               ir_variable *const r1F3C = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1F3D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1F3D);
               ir_expression *const r1F3E = expr(ir_unop_u2i, r1EFB);
               body.emit(assign(r1F3D, less(r1F3E, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1F40 = lequal(body.constant(int(2045)), r1EF8);
               ir_if *f1F3F = new(mem_ctx) ir_if(operand(r1F40).val);
               exec_list *const f1F3F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F3F->then_instructions;

                  ir_variable *const r1F41 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1F43 = less(body.constant(int(2045)), r1EF8);
                  ir_if *f1F42 = new(mem_ctx) ir_if(operand(r1F43).val);
                  exec_list *const f1F42_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F42->then_instructions;

                     body.emit(assign(r1F41, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F42->else_instructions;

                     ir_variable *const r1F44 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1F46 = equal(r1EF8, body.constant(int(2045)));
                     ir_if *f1F45 = new(mem_ctx) ir_if(operand(r1F46).val);
                     exec_list *const f1F45_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1F45->then_instructions;

                        ir_expression *const r1F47 = equal(body.constant(2097151u), r1EF9);
                        ir_expression *const r1F48 = equal(body.constant(4294967295u), r1EFA);
                        body.emit(assign(r1F44, logic_and(r1F47, r1F48), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1F45->else_instructions;

                        body.emit(assign(r1F44, body.constant(false), 0x01));


                     body.instructions = f1F45_parent_instructions;
                     body.emit(f1F45);

                     /* END IF */

                     body.emit(assign(r1F41, logic_and(r1F44, r1F3D), 0x01));


                  body.instructions = f1F42_parent_instructions;
                  body.emit(f1F42);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1F49 = new(mem_ctx) ir_if(operand(r1F41).val);
                  exec_list *const f1F49_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F49->then_instructions;

                     ir_variable *const r1F4A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1F4A);
                     ir_expression *const r1F4B = lshift(r1E07, body.constant(int(31)));
                     body.emit(assign(r1F4A, add(r1F4B, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1F4A, body.constant(0u), 0x01));

                     body.emit(assign(r1F3C, r1F4A, 0x03));

                     body.emit(assign(r1F3B, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F49->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1F4D = less(r1EF8, body.constant(int(0)));
                     ir_if *f1F4C = new(mem_ctx) ir_if(operand(r1F4D).val);
                     exec_list *const f1F4C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1F4C->then_instructions;

                        ir_variable *const r1F4E = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1F4E, r1EFB, 0x01));

                        ir_variable *const r1F4F = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1F4F, neg(r1EF8), 0x01));

                        ir_variable *const r1F50 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1F50);
                        ir_variable *const r1F51 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1F51);
                        ir_variable *const r1F52 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1F52);
                        ir_variable *const r1F53 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1F54 = neg(r1F4F);
                        body.emit(assign(r1F53, bit_and(r1F54, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1F56 = equal(r1F4F, body.constant(int(0)));
                        ir_if *f1F55 = new(mem_ctx) ir_if(operand(r1F56).val);
                        exec_list *const f1F55_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F55->then_instructions;

                           body.emit(assign(r1F50, r1EFB, 0x01));

                           body.emit(assign(r1F51, r1EFA, 0x01));

                           body.emit(assign(r1F52, r1EF9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1F55->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1F58 = less(r1F4F, body.constant(int(32)));
                           ir_if *f1F57 = new(mem_ctx) ir_if(operand(r1F58).val);
                           exec_list *const f1F57_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F57->then_instructions;

                              body.emit(assign(r1F50, lshift(r1EFA, r1F53), 0x01));

                              ir_expression *const r1F59 = lshift(r1EF9, r1F53);
                              ir_expression *const r1F5A = rshift(r1EFA, r1F4F);
                              body.emit(assign(r1F51, bit_or(r1F59, r1F5A), 0x01));

                              body.emit(assign(r1F52, rshift(r1EF9, r1F4F), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F57->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1F5C = equal(r1F4F, body.constant(int(32)));
                              ir_if *f1F5B = new(mem_ctx) ir_if(operand(r1F5C).val);
                              exec_list *const f1F5B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F5B->then_instructions;

                                 body.emit(assign(r1F50, r1EFA, 0x01));

                                 body.emit(assign(r1F51, r1EF9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1F5B->else_instructions;

                                 body.emit(assign(r1F4E, bit_or(r1EFB, r1EFA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1F5E = less(r1F4F, body.constant(int(64)));
                                 ir_if *f1F5D = new(mem_ctx) ir_if(operand(r1F5E).val);
                                 exec_list *const f1F5D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1F5D->then_instructions;

                                    body.emit(assign(r1F50, lshift(r1EF9, r1F53), 0x01));

                                    ir_expression *const r1F5F = bit_and(r1F4F, body.constant(int(31)));
                                    body.emit(assign(r1F51, rshift(r1EF9, r1F5F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1F5D->else_instructions;

                                    ir_variable *const r1F60 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1F62 = equal(r1F4F, body.constant(int(64)));
                                    ir_if *f1F61 = new(mem_ctx) ir_if(operand(r1F62).val);
                                    exec_list *const f1F61_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1F61->then_instructions;

                                       body.emit(assign(r1F60, r1EF9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1F61->else_instructions;

                                       ir_expression *const r1F63 = nequal(r1EF9, body.constant(0u));
                                       ir_expression *const r1F64 = expr(ir_unop_b2i, r1F63);
                                       body.emit(assign(r1F60, expr(ir_unop_i2u, r1F64), 0x01));


                                    body.instructions = f1F61_parent_instructions;
                                    body.emit(f1F61);

                                    /* END IF */

                                    body.emit(assign(r1F50, r1F60, 0x01));

                                    body.emit(assign(r1F51, body.constant(0u), 0x01));


                                 body.instructions = f1F5D_parent_instructions;
                                 body.emit(f1F5D);

                                 /* END IF */


                              body.instructions = f1F5B_parent_instructions;
                              body.emit(f1F5B);

                              /* END IF */

                              body.emit(assign(r1F52, body.constant(0u), 0x01));


                           body.instructions = f1F57_parent_instructions;
                           body.emit(f1F57);

                           /* END IF */

                           ir_expression *const r1F65 = nequal(r1F4E, body.constant(0u));
                           ir_expression *const r1F66 = expr(ir_unop_b2i, r1F65);
                           ir_expression *const r1F67 = expr(ir_unop_i2u, r1F66);
                           body.emit(assign(r1F50, bit_or(r1F50, r1F67), 0x01));


                        body.instructions = f1F55_parent_instructions;
                        body.emit(f1F55);

                        /* END IF */

                        body.emit(assign(r1F38, r1F52, 0x01));

                        body.emit(assign(r1F39, r1F51, 0x01));

                        body.emit(assign(r1F3A, r1F50, 0x01));

                        body.emit(assign(r1F37, body.constant(int(0)), 0x01));

                        body.emit(assign(r1F3D, less(r1F50, body.constant(0u)), 0x01));


                     body.instructions = f1F4C_parent_instructions;
                     body.emit(f1F4C);

                     /* END IF */


                  body.instructions = f1F49_parent_instructions;
                  body.emit(f1F49);

                  /* END IF */


               body.instructions = f1F3F_parent_instructions;
               body.emit(f1F3F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1F68 = new(mem_ctx) ir_if(operand(r1F3B).val);
               exec_list *const f1F68_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F68->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1F69 = new(mem_ctx) ir_if(operand(r1F3D).val);
                  exec_list *const f1F69_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F69->then_instructions;

                     ir_variable *const r1F6A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1F6A, add(r1F39, body.constant(1u)), 0x01));

                     ir_expression *const r1F6B = less(r1F6A, r1F39);
                     ir_expression *const r1F6C = expr(ir_unop_b2i, r1F6B);
                     ir_expression *const r1F6D = expr(ir_unop_i2u, r1F6C);
                     body.emit(assign(r1F38, add(r1F38, r1F6D), 0x01));

                     ir_expression *const r1F6E = equal(r1F3A, body.constant(0u));
                     ir_expression *const r1F6F = expr(ir_unop_b2i, r1F6E);
                     ir_expression *const r1F70 = expr(ir_unop_i2u, r1F6F);
                     ir_expression *const r1F71 = add(r1F3A, r1F70);
                     ir_expression *const r1F72 = bit_and(r1F71, body.constant(1u));
                     ir_expression *const r1F73 = expr(ir_unop_bit_not, r1F72);
                     body.emit(assign(r1F39, bit_and(r1F6A, r1F73), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F69->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1F75 = bit_or(r1F38, r1F39);
                     ir_expression *const r1F76 = equal(r1F75, body.constant(0u));
                     ir_if *f1F74 = new(mem_ctx) ir_if(operand(r1F76).val);
                     exec_list *const f1F74_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1F74->then_instructions;

                        body.emit(assign(r1F37, body.constant(int(0)), 0x01));


                     body.instructions = f1F74_parent_instructions;
                     body.emit(f1F74);

                     /* END IF */


                  body.instructions = f1F69_parent_instructions;
                  body.emit(f1F69);

                  /* END IF */

                  ir_variable *const r1F77 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1F77);
                  ir_expression *const r1F78 = lshift(r1E07, body.constant(int(31)));
                  ir_expression *const r1F79 = expr(ir_unop_i2u, r1F37);
                  ir_expression *const r1F7A = lshift(r1F79, body.constant(int(20)));
                  ir_expression *const r1F7B = add(r1F78, r1F7A);
                  body.emit(assign(r1F77, add(r1F7B, r1F38), 0x02));

                  body.emit(assign(r1F77, r1F39, 0x01));

                  body.emit(assign(r1F3C, r1F77, 0x03));

                  body.emit(assign(r1F3B, body.constant(false), 0x01));


               body.instructions = f1F68_parent_instructions;
               body.emit(f1F68);

               /* END IF */

               body.emit(assign(r1E08, r1F3C, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1ECD->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1F7D = equal(r1E12, body.constant(int(2047)));
               ir_if *f1F7C = new(mem_ctx) ir_if(operand(r1F7D).val);
               exec_list *const f1F7C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F7C->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1F7F = bit_or(r1E0E, r1E0F);
                  ir_expression *const r1F80 = bit_or(r1E0C, r1E0D);
                  ir_expression *const r1F81 = bit_or(r1F7F, r1F80);
                  ir_expression *const r1F82 = nequal(r1F81, body.constant(0u));
                  ir_if *f1F7E = new(mem_ctx) ir_if(operand(r1F82).val);
                  exec_list *const f1F7E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F7E->then_instructions;

                     ir_variable *const r1F83 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r1F83, swizzle_x(r1C76), 0x01));

                     ir_variable *const r1F84 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r1F84, body.constant(0u), 0x01));

                     ir_variable *const r1F85 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r1F83, bit_or(swizzle_y(r1C76), body.constant(524288u)), 0x02));

                     body.emit(assign(r1F84, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r1F87 = lshift(swizzle_y(r1C76), body.constant(int(1)));
                     ir_expression *const r1F88 = lequal(body.constant(4292870144u), r1F87);
                     ir_expression *const r1F89 = nequal(swizzle_x(r1C76), body.constant(0u));
                     ir_expression *const r1F8A = bit_and(swizzle_y(r1C76), body.constant(1048575u));
                     ir_expression *const r1F8B = nequal(r1F8A, body.constant(0u));
                     ir_expression *const r1F8C = logic_or(r1F89, r1F8B);
                     ir_expression *const r1F8D = logic_and(r1F88, r1F8C);
                     ir_if *f1F86 = new(mem_ctx) ir_if(operand(r1F8D).val);
                     exec_list *const f1F86_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1F86->then_instructions;

                        body.emit(assign(r1F85, r1F83, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1F86->else_instructions;

                        body.emit(assign(r1F85, r1F84, 0x03));


                     body.instructions = f1F86_parent_instructions;
                     body.emit(f1F86);

                     /* END IF */

                     body.emit(assign(r1E08, r1F85, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F7E->else_instructions;

                     ir_constant_data r1F8E_data;
                     memset(&r1F8E_data, 0, sizeof(ir_constant_data));
                     r1F8E_data.u[0] = 4294967295;
                     r1F8E_data.u[1] = 4294967295;
                     ir_constant *const r1F8E = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r1F8E_data);
                     body.emit(assign(r1E08, r1F8E, 0x03));


                  body.instructions = f1F7E_parent_instructions;
                  body.emit(f1F7E);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1F7C->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1F90 = equal(r1E12, body.constant(int(0)));
                  ir_if *f1F8F = new(mem_ctx) ir_if(operand(r1F90).val);
                  exec_list *const f1F8F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F8F->then_instructions;

                     body.emit(assign(r1E0B, body.constant(int(1)), 0x01));

                     body.emit(assign(r1E0A, body.constant(int(1)), 0x01));


                  body.instructions = f1F8F_parent_instructions;
                  body.emit(f1F8F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1F92 = less(r1E0C, r1E0E);
                  ir_if *f1F91 = new(mem_ctx) ir_if(operand(r1F92).val);
                  exec_list *const f1F91_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F91->then_instructions;

                     ir_variable *const r1F93 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r1F94 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r1F94, sub(r1E0F, r1E0D), 0x01));

                     ir_expression *const r1F95 = sub(r1E0E, r1E0C);
                     ir_expression *const r1F96 = less(r1E0F, r1E0D);
                     ir_expression *const r1F97 = expr(ir_unop_b2i, r1F96);
                     ir_expression *const r1F98 = expr(ir_unop_i2u, r1F97);
                     body.emit(assign(r1F93, sub(r1F95, r1F98), 0x01));

                     body.emit(assign(r1E10, add(r1E0B, body.constant(int(-1))), 0x01));

                     ir_variable *const r1F99 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1F99, add(r1E10, body.constant(int(-10))), 0x01));

                     ir_variable *const r1F9A = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1F9A, r1F93, 0x01));

                     ir_variable *const r1F9B = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1F9B, r1F94, 0x01));

                     ir_variable *const r1F9C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r1F9C);
                     ir_variable *const r1F9D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1F9D);
                     /* IF CONDITION */
                     ir_expression *const r1F9F = equal(r1F93, body.constant(0u));
                     ir_if *f1F9E = new(mem_ctx) ir_if(operand(r1F9F).val);
                     exec_list *const f1F9E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1F9E->then_instructions;

                        body.emit(assign(r1F9A, r1F94, 0x01));

                        body.emit(assign(r1F9B, body.constant(0u), 0x01));

                        body.emit(assign(r1F99, add(r1F99, body.constant(int(-32))), 0x01));


                     body.instructions = f1F9E_parent_instructions;
                     body.emit(f1F9E);

                     /* END IF */

                     ir_variable *const r1FA0 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1FA0, r1F9A, 0x01));

                     ir_variable *const r1FA1 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1FA2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1FA2);
                     /* IF CONDITION */
                     ir_expression *const r1FA4 = equal(r1F9A, body.constant(0u));
                     ir_if *f1FA3 = new(mem_ctx) ir_if(operand(r1FA4).val);
                     exec_list *const f1FA3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1FA3->then_instructions;

                        body.emit(assign(r1FA1, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1FA3->else_instructions;

                        body.emit(assign(r1FA2, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1FA6 = bit_and(r1F9A, body.constant(4294901760u));
                        ir_expression *const r1FA7 = equal(r1FA6, body.constant(0u));
                        ir_if *f1FA5 = new(mem_ctx) ir_if(operand(r1FA7).val);
                        exec_list *const f1FA5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1FA5->then_instructions;

                           body.emit(assign(r1FA2, body.constant(int(16)), 0x01));

                           body.emit(assign(r1FA0, lshift(r1F9A, body.constant(int(16))), 0x01));


                        body.instructions = f1FA5_parent_instructions;
                        body.emit(f1FA5);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1FA9 = bit_and(r1FA0, body.constant(4278190080u));
                        ir_expression *const r1FAA = equal(r1FA9, body.constant(0u));
                        ir_if *f1FA8 = new(mem_ctx) ir_if(operand(r1FAA).val);
                        exec_list *const f1FA8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1FA8->then_instructions;

                           body.emit(assign(r1FA2, add(r1FA2, body.constant(int(8))), 0x01));

                           body.emit(assign(r1FA0, lshift(r1FA0, body.constant(int(8))), 0x01));


                        body.instructions = f1FA8_parent_instructions;
                        body.emit(f1FA8);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1FAC = bit_and(r1FA0, body.constant(4026531840u));
                        ir_expression *const r1FAD = equal(r1FAC, body.constant(0u));
                        ir_if *f1FAB = new(mem_ctx) ir_if(operand(r1FAD).val);
                        exec_list *const f1FAB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1FAB->then_instructions;

                           body.emit(assign(r1FA2, add(r1FA2, body.constant(int(4))), 0x01));

                           body.emit(assign(r1FA0, lshift(r1FA0, body.constant(int(4))), 0x01));


                        body.instructions = f1FAB_parent_instructions;
                        body.emit(f1FAB);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1FAF = bit_and(r1FA0, body.constant(3221225472u));
                        ir_expression *const r1FB0 = equal(r1FAF, body.constant(0u));
                        ir_if *f1FAE = new(mem_ctx) ir_if(operand(r1FB0).val);
                        exec_list *const f1FAE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1FAE->then_instructions;

                           body.emit(assign(r1FA2, add(r1FA2, body.constant(int(2))), 0x01));

                           body.emit(assign(r1FA0, lshift(r1FA0, body.constant(int(2))), 0x01));


                        body.instructions = f1FAE_parent_instructions;
                        body.emit(f1FAE);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1FB2 = bit_and(r1FA0, body.constant(2147483648u));
                        ir_expression *const r1FB3 = equal(r1FB2, body.constant(0u));
                        ir_if *f1FB1 = new(mem_ctx) ir_if(operand(r1FB3).val);
                        exec_list *const f1FB1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1FB1->then_instructions;

                           body.emit(assign(r1FA2, add(r1FA2, body.constant(int(1))), 0x01));


                        body.instructions = f1FB1_parent_instructions;
                        body.emit(f1FB1);

                        /* END IF */

                        body.emit(assign(r1FA1, r1FA2, 0x01));


                     body.instructions = f1FA3_parent_instructions;
                     body.emit(f1FA3);

                     /* END IF */

                     body.emit(assign(r1F9D, add(r1FA1, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1FB5 = lequal(body.constant(int(0)), r1F9D);
                     ir_if *f1FB4 = new(mem_ctx) ir_if(operand(r1FB5).val);
                     exec_list *const f1FB4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1FB4->then_instructions;

                        body.emit(assign(r1F9C, body.constant(0u), 0x01));

                        ir_variable *const r1FB6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r1FB6, lshift(r1F9B, r1F9D), 0x01));

                        ir_variable *const r1FB7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1FB9 = equal(r1F9D, body.constant(int(0)));
                        ir_if *f1FB8 = new(mem_ctx) ir_if(operand(r1FB9).val);
                        exec_list *const f1FB8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1FB8->then_instructions;

                           body.emit(assign(r1FB7, r1F9A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1FB8->else_instructions;

                           ir_expression *const r1FBA = lshift(r1F9A, r1F9D);
                           ir_expression *const r1FBB = neg(r1F9D);
                           ir_expression *const r1FBC = bit_and(r1FBB, body.constant(int(31)));
                           ir_expression *const r1FBD = rshift(r1F9B, r1FBC);
                           body.emit(assign(r1FB7, bit_or(r1FBA, r1FBD), 0x01));


                        body.instructions = f1FB8_parent_instructions;
                        body.emit(f1FB8);

                        /* END IF */

                        body.emit(assign(r1F9A, r1FB7, 0x01));

                        body.emit(assign(r1F9B, r1FB6, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1FB4->else_instructions;

                        ir_variable *const r1FBE = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1FBE, body.constant(0u), 0x01));

                        ir_variable *const r1FBF = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1FBF, neg(r1F9D), 0x01));

                        ir_variable *const r1FC0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1FC0);
                        ir_variable *const r1FC1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1FC1);
                        ir_variable *const r1FC2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1FC2);
                        ir_variable *const r1FC3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1FC4 = neg(r1FBF);
                        body.emit(assign(r1FC3, bit_and(r1FC4, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1FC6 = equal(r1FBF, body.constant(int(0)));
                        ir_if *f1FC5 = new(mem_ctx) ir_if(operand(r1FC6).val);
                        exec_list *const f1FC5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1FC5->then_instructions;

                           body.emit(assign(r1FC0, r1FBE, 0x01));

                           body.emit(assign(r1FC1, r1F9B, 0x01));

                           body.emit(assign(r1FC2, r1F9A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1FC5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1FC8 = less(r1FBF, body.constant(int(32)));
                           ir_if *f1FC7 = new(mem_ctx) ir_if(operand(r1FC8).val);
                           exec_list *const f1FC7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1FC7->then_instructions;

                              body.emit(assign(r1FC0, lshift(r1F9B, r1FC3), 0x01));

                              ir_expression *const r1FC9 = lshift(r1F9A, r1FC3);
                              ir_expression *const r1FCA = rshift(r1F9B, r1FBF);
                              body.emit(assign(r1FC1, bit_or(r1FC9, r1FCA), 0x01));

                              body.emit(assign(r1FC2, rshift(r1F9A, r1FBF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1FC7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1FCC = equal(r1FBF, body.constant(int(32)));
                              ir_if *f1FCB = new(mem_ctx) ir_if(operand(r1FCC).val);
                              exec_list *const f1FCB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FCB->then_instructions;

                                 body.emit(assign(r1FC0, r1F9B, 0x01));

                                 body.emit(assign(r1FC1, r1F9A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1FCB->else_instructions;

                                 body.emit(assign(r1FBE, bit_or(body.constant(0u), r1F9B), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1FCE = less(r1FBF, body.constant(int(64)));
                                 ir_if *f1FCD = new(mem_ctx) ir_if(operand(r1FCE).val);
                                 exec_list *const f1FCD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FCD->then_instructions;

                                    body.emit(assign(r1FC0, lshift(r1F9A, r1FC3), 0x01));

                                    ir_expression *const r1FCF = bit_and(r1FBF, body.constant(int(31)));
                                    body.emit(assign(r1FC1, rshift(r1F9A, r1FCF), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1FCD->else_instructions;

                                    ir_variable *const r1FD0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1FD2 = equal(r1FBF, body.constant(int(64)));
                                    ir_if *f1FD1 = new(mem_ctx) ir_if(operand(r1FD2).val);
                                    exec_list *const f1FD1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1FD1->then_instructions;

                                       body.emit(assign(r1FD0, r1F9A, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1FD1->else_instructions;

                                       ir_expression *const r1FD3 = nequal(r1F9A, body.constant(0u));
                                       ir_expression *const r1FD4 = expr(ir_unop_b2i, r1FD3);
                                       body.emit(assign(r1FD0, expr(ir_unop_i2u, r1FD4), 0x01));


                                    body.instructions = f1FD1_parent_instructions;
                                    body.emit(f1FD1);

                                    /* END IF */

                                    body.emit(assign(r1FC0, r1FD0, 0x01));

                                    body.emit(assign(r1FC1, body.constant(0u), 0x01));


                                 body.instructions = f1FCD_parent_instructions;
                                 body.emit(f1FCD);

                                 /* END IF */


                              body.instructions = f1FCB_parent_instructions;
                              body.emit(f1FCB);

                              /* END IF */

                              body.emit(assign(r1FC2, body.constant(0u), 0x01));


                           body.instructions = f1FC7_parent_instructions;
                           body.emit(f1FC7);

                           /* END IF */

                           ir_expression *const r1FD5 = nequal(r1FBE, body.constant(0u));
                           ir_expression *const r1FD6 = expr(ir_unop_b2i, r1FD5);
                           ir_expression *const r1FD7 = expr(ir_unop_i2u, r1FD6);
                           body.emit(assign(r1FC0, bit_or(r1FC0, r1FD7), 0x01));


                        body.instructions = f1FC5_parent_instructions;
                        body.emit(f1FC5);

                        /* END IF */

                        body.emit(assign(r1F9A, r1FC2, 0x01));

                        body.emit(assign(r1F9B, r1FC1, 0x01));

                        body.emit(assign(r1F9C, r1FC0, 0x01));


                     body.instructions = f1FB4_parent_instructions;
                     body.emit(f1FB4);

                     /* END IF */

                     body.emit(assign(r1F99, sub(r1F99, r1F9D), 0x01));

                     ir_variable *const r1FD8 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1FD8, r1F99, 0x01));

                     ir_variable *const r1FD9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1FD9, r1F9A, 0x01));

                     ir_variable *const r1FDA = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1FDA, r1F9B, 0x01));

                     ir_variable *const r1FDB = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r1FDB, r1F9C, 0x01));

                     ir_variable *const r1FDC = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r1FDC, body.constant(true), 0x01));

                     ir_variable *const r1FDD = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1FDE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r1FDE);
                     ir_expression *const r1FDF = expr(ir_unop_u2i, r1F9C);
                     body.emit(assign(r1FDE, less(r1FDF, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1FE1 = lequal(body.constant(int(2045)), r1F99);
                     ir_if *f1FE0 = new(mem_ctx) ir_if(operand(r1FE1).val);
                     exec_list *const f1FE0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1FE0->then_instructions;

                        ir_variable *const r1FE2 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1FE4 = less(body.constant(int(2045)), r1F99);
                        ir_if *f1FE3 = new(mem_ctx) ir_if(operand(r1FE4).val);
                        exec_list *const f1FE3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1FE3->then_instructions;

                           body.emit(assign(r1FE2, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1FE3->else_instructions;

                           ir_variable *const r1FE5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1FE7 = equal(r1F99, body.constant(int(2045)));
                           ir_if *f1FE6 = new(mem_ctx) ir_if(operand(r1FE7).val);
                           exec_list *const f1FE6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1FE6->then_instructions;

                              ir_expression *const r1FE8 = equal(body.constant(2097151u), r1F9A);
                              ir_expression *const r1FE9 = equal(body.constant(4294967295u), r1F9B);
                              body.emit(assign(r1FE5, logic_and(r1FE8, r1FE9), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1FE6->else_instructions;

                              body.emit(assign(r1FE5, body.constant(false), 0x01));


                           body.instructions = f1FE6_parent_instructions;
                           body.emit(f1FE6);

                           /* END IF */

                           body.emit(assign(r1FE2, logic_and(r1FE5, r1FDE), 0x01));


                        body.instructions = f1FE3_parent_instructions;
                        body.emit(f1FE3);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1FEA = new(mem_ctx) ir_if(operand(r1FE2).val);
                        exec_list *const f1FEA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1FEA->then_instructions;

                           ir_variable *const r1FEB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1FEB);
                           ir_expression *const r1FEC = lshift(r1E07, body.constant(int(31)));
                           body.emit(assign(r1FEB, add(r1FEC, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r1FEB, body.constant(0u), 0x01));

                           body.emit(assign(r1FDD, r1FEB, 0x03));

                           body.emit(assign(r1FDC, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1FEA->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1FEE = less(r1F99, body.constant(int(0)));
                           ir_if *f1FED = new(mem_ctx) ir_if(operand(r1FEE).val);
                           exec_list *const f1FED_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1FED->then_instructions;

                              ir_variable *const r1FEF = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1FEF, r1F9C, 0x01));

                              ir_variable *const r1FF0 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1FF0, neg(r1F99), 0x01));

                              ir_variable *const r1FF1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1FF1);
                              ir_variable *const r1FF2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1FF2);
                              ir_variable *const r1FF3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1FF3);
                              ir_variable *const r1FF4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1FF5 = neg(r1FF0);
                              body.emit(assign(r1FF4, bit_and(r1FF5, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1FF7 = equal(r1FF0, body.constant(int(0)));
                              ir_if *f1FF6 = new(mem_ctx) ir_if(operand(r1FF7).val);
                              exec_list *const f1FF6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FF6->then_instructions;

                                 body.emit(assign(r1FF1, r1F9C, 0x01));

                                 body.emit(assign(r1FF2, r1F9B, 0x01));

                                 body.emit(assign(r1FF3, r1F9A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1FF6->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1FF9 = less(r1FF0, body.constant(int(32)));
                                 ir_if *f1FF8 = new(mem_ctx) ir_if(operand(r1FF9).val);
                                 exec_list *const f1FF8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FF8->then_instructions;

                                    body.emit(assign(r1FF1, lshift(r1F9B, r1FF4), 0x01));

                                    ir_expression *const r1FFA = lshift(r1F9A, r1FF4);
                                    ir_expression *const r1FFB = rshift(r1F9B, r1FF0);
                                    body.emit(assign(r1FF2, bit_or(r1FFA, r1FFB), 0x01));

                                    body.emit(assign(r1FF3, rshift(r1F9A, r1FF0), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1FF8->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1FFD = equal(r1FF0, body.constant(int(32)));
                                    ir_if *f1FFC = new(mem_ctx) ir_if(operand(r1FFD).val);
                                    exec_list *const f1FFC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1FFC->then_instructions;

                                       body.emit(assign(r1FF1, r1F9B, 0x01));

                                       body.emit(assign(r1FF2, r1F9A, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1FFC->else_instructions;

                                       body.emit(assign(r1FEF, bit_or(r1F9C, r1F9B), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1FFF = less(r1FF0, body.constant(int(64)));
                                       ir_if *f1FFE = new(mem_ctx) ir_if(operand(r1FFF).val);
                                       exec_list *const f1FFE_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1FFE->then_instructions;

                                          body.emit(assign(r1FF1, lshift(r1F9A, r1FF4), 0x01));

                                          ir_expression *const r2000 = bit_and(r1FF0, body.constant(int(31)));
                                          body.emit(assign(r1FF2, rshift(r1F9A, r2000), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1FFE->else_instructions;

                                          ir_variable *const r2001 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2003 = equal(r1FF0, body.constant(int(64)));
                                          ir_if *f2002 = new(mem_ctx) ir_if(operand(r2003).val);
                                          exec_list *const f2002_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2002->then_instructions;

                                             body.emit(assign(r2001, r1F9A, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2002->else_instructions;

                                             ir_expression *const r2004 = nequal(r1F9A, body.constant(0u));
                                             ir_expression *const r2005 = expr(ir_unop_b2i, r2004);
                                             body.emit(assign(r2001, expr(ir_unop_i2u, r2005), 0x01));


                                          body.instructions = f2002_parent_instructions;
                                          body.emit(f2002);

                                          /* END IF */

                                          body.emit(assign(r1FF1, r2001, 0x01));

                                          body.emit(assign(r1FF2, body.constant(0u), 0x01));


                                       body.instructions = f1FFE_parent_instructions;
                                       body.emit(f1FFE);

                                       /* END IF */


                                    body.instructions = f1FFC_parent_instructions;
                                    body.emit(f1FFC);

                                    /* END IF */

                                    body.emit(assign(r1FF3, body.constant(0u), 0x01));


                                 body.instructions = f1FF8_parent_instructions;
                                 body.emit(f1FF8);

                                 /* END IF */

                                 ir_expression *const r2006 = nequal(r1FEF, body.constant(0u));
                                 ir_expression *const r2007 = expr(ir_unop_b2i, r2006);
                                 ir_expression *const r2008 = expr(ir_unop_i2u, r2007);
                                 body.emit(assign(r1FF1, bit_or(r1FF1, r2008), 0x01));


                              body.instructions = f1FF6_parent_instructions;
                              body.emit(f1FF6);

                              /* END IF */

                              body.emit(assign(r1FD9, r1FF3, 0x01));

                              body.emit(assign(r1FDA, r1FF2, 0x01));

                              body.emit(assign(r1FDB, r1FF1, 0x01));

                              body.emit(assign(r1FD8, body.constant(int(0)), 0x01));

                              body.emit(assign(r1FDE, less(r1FF1, body.constant(0u)), 0x01));


                           body.instructions = f1FED_parent_instructions;
                           body.emit(f1FED);

                           /* END IF */


                        body.instructions = f1FEA_parent_instructions;
                        body.emit(f1FEA);

                        /* END IF */


                     body.instructions = f1FE0_parent_instructions;
                     body.emit(f1FE0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2009 = new(mem_ctx) ir_if(operand(r1FDC).val);
                     exec_list *const f2009_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2009->then_instructions;

                        /* IF CONDITION */
                        ir_if *f200A = new(mem_ctx) ir_if(operand(r1FDE).val);
                        exec_list *const f200A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f200A->then_instructions;

                           ir_variable *const r200B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r200B, add(r1FDA, body.constant(1u)), 0x01));

                           ir_expression *const r200C = less(r200B, r1FDA);
                           ir_expression *const r200D = expr(ir_unop_b2i, r200C);
                           ir_expression *const r200E = expr(ir_unop_i2u, r200D);
                           body.emit(assign(r1FD9, add(r1FD9, r200E), 0x01));

                           ir_expression *const r200F = equal(r1FDB, body.constant(0u));
                           ir_expression *const r2010 = expr(ir_unop_b2i, r200F);
                           ir_expression *const r2011 = expr(ir_unop_i2u, r2010);
                           ir_expression *const r2012 = add(r1FDB, r2011);
                           ir_expression *const r2013 = bit_and(r2012, body.constant(1u));
                           ir_expression *const r2014 = expr(ir_unop_bit_not, r2013);
                           body.emit(assign(r1FDA, bit_and(r200B, r2014), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f200A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2016 = bit_or(r1FD9, r1FDA);
                           ir_expression *const r2017 = equal(r2016, body.constant(0u));
                           ir_if *f2015 = new(mem_ctx) ir_if(operand(r2017).val);
                           exec_list *const f2015_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2015->then_instructions;

                              body.emit(assign(r1FD8, body.constant(int(0)), 0x01));


                           body.instructions = f2015_parent_instructions;
                           body.emit(f2015);

                           /* END IF */


                        body.instructions = f200A_parent_instructions;
                        body.emit(f200A);

                        /* END IF */

                        ir_variable *const r2018 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2018);
                        ir_expression *const r2019 = lshift(r1E07, body.constant(int(31)));
                        ir_expression *const r201A = expr(ir_unop_i2u, r1FD8);
                        ir_expression *const r201B = lshift(r201A, body.constant(int(20)));
                        ir_expression *const r201C = add(r2019, r201B);
                        body.emit(assign(r2018, add(r201C, r1FD9), 0x02));

                        body.emit(assign(r2018, r1FDA, 0x01));

                        body.emit(assign(r1FDD, r2018, 0x03));

                        body.emit(assign(r1FDC, body.constant(false), 0x01));


                     body.instructions = f2009_parent_instructions;
                     body.emit(f2009);

                     /* END IF */

                     body.emit(assign(r1E08, r1FDD, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F91->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r201E = less(r1E0E, r1E0C);
                     ir_if *f201D = new(mem_ctx) ir_if(operand(r201E).val);
                     exec_list *const f201D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f201D->then_instructions;

                        ir_variable *const r201F = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r2020 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2020, sub(r1E0D, r1E0F), 0x01));

                        ir_expression *const r2021 = sub(r1E0C, r1E0E);
                        ir_expression *const r2022 = less(r1E0D, r1E0F);
                        ir_expression *const r2023 = expr(ir_unop_b2i, r2022);
                        ir_expression *const r2024 = expr(ir_unop_i2u, r2023);
                        body.emit(assign(r201F, sub(r2021, r2024), 0x01));

                        body.emit(assign(r1E07, bit_xor(r1E07, body.constant(1u)), 0x01));

                        body.emit(assign(r1E10, add(r1E0A, body.constant(int(-1))), 0x01));

                        ir_variable *const r2025 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2025, add(r1E10, body.constant(int(-10))), 0x01));

                        ir_variable *const r2026 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2026, r201F, 0x01));

                        ir_variable *const r2027 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2027, r2020, 0x01));

                        ir_variable *const r2028 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r2028);
                        ir_variable *const r2029 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2029);
                        /* IF CONDITION */
                        ir_expression *const r202B = equal(r201F, body.constant(0u));
                        ir_if *f202A = new(mem_ctx) ir_if(operand(r202B).val);
                        exec_list *const f202A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f202A->then_instructions;

                           body.emit(assign(r2026, r2020, 0x01));

                           body.emit(assign(r2027, body.constant(0u), 0x01));

                           body.emit(assign(r2025, add(r2025, body.constant(int(-32))), 0x01));


                        body.instructions = f202A_parent_instructions;
                        body.emit(f202A);

                        /* END IF */

                        ir_variable *const r202C = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r202C, r2026, 0x01));

                        ir_variable *const r202D = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r202E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r202E);
                        /* IF CONDITION */
                        ir_expression *const r2030 = equal(r2026, body.constant(0u));
                        ir_if *f202F = new(mem_ctx) ir_if(operand(r2030).val);
                        exec_list *const f202F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f202F->then_instructions;

                           body.emit(assign(r202D, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f202F->else_instructions;

                           body.emit(assign(r202E, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2032 = bit_and(r2026, body.constant(4294901760u));
                           ir_expression *const r2033 = equal(r2032, body.constant(0u));
                           ir_if *f2031 = new(mem_ctx) ir_if(operand(r2033).val);
                           exec_list *const f2031_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2031->then_instructions;

                              body.emit(assign(r202E, body.constant(int(16)), 0x01));

                              body.emit(assign(r202C, lshift(r2026, body.constant(int(16))), 0x01));


                           body.instructions = f2031_parent_instructions;
                           body.emit(f2031);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2035 = bit_and(r202C, body.constant(4278190080u));
                           ir_expression *const r2036 = equal(r2035, body.constant(0u));
                           ir_if *f2034 = new(mem_ctx) ir_if(operand(r2036).val);
                           exec_list *const f2034_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2034->then_instructions;

                              body.emit(assign(r202E, add(r202E, body.constant(int(8))), 0x01));

                              body.emit(assign(r202C, lshift(r202C, body.constant(int(8))), 0x01));


                           body.instructions = f2034_parent_instructions;
                           body.emit(f2034);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2038 = bit_and(r202C, body.constant(4026531840u));
                           ir_expression *const r2039 = equal(r2038, body.constant(0u));
                           ir_if *f2037 = new(mem_ctx) ir_if(operand(r2039).val);
                           exec_list *const f2037_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2037->then_instructions;

                              body.emit(assign(r202E, add(r202E, body.constant(int(4))), 0x01));

                              body.emit(assign(r202C, lshift(r202C, body.constant(int(4))), 0x01));


                           body.instructions = f2037_parent_instructions;
                           body.emit(f2037);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r203B = bit_and(r202C, body.constant(3221225472u));
                           ir_expression *const r203C = equal(r203B, body.constant(0u));
                           ir_if *f203A = new(mem_ctx) ir_if(operand(r203C).val);
                           exec_list *const f203A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f203A->then_instructions;

                              body.emit(assign(r202E, add(r202E, body.constant(int(2))), 0x01));

                              body.emit(assign(r202C, lshift(r202C, body.constant(int(2))), 0x01));


                           body.instructions = f203A_parent_instructions;
                           body.emit(f203A);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r203E = bit_and(r202C, body.constant(2147483648u));
                           ir_expression *const r203F = equal(r203E, body.constant(0u));
                           ir_if *f203D = new(mem_ctx) ir_if(operand(r203F).val);
                           exec_list *const f203D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f203D->then_instructions;

                              body.emit(assign(r202E, add(r202E, body.constant(int(1))), 0x01));


                           body.instructions = f203D_parent_instructions;
                           body.emit(f203D);

                           /* END IF */

                           body.emit(assign(r202D, r202E, 0x01));


                        body.instructions = f202F_parent_instructions;
                        body.emit(f202F);

                        /* END IF */

                        body.emit(assign(r2029, add(r202D, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2041 = lequal(body.constant(int(0)), r2029);
                        ir_if *f2040 = new(mem_ctx) ir_if(operand(r2041).val);
                        exec_list *const f2040_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2040->then_instructions;

                           body.emit(assign(r2028, body.constant(0u), 0x01));

                           ir_variable *const r2042 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2042, lshift(r2027, r2029), 0x01));

                           ir_variable *const r2043 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2045 = equal(r2029, body.constant(int(0)));
                           ir_if *f2044 = new(mem_ctx) ir_if(operand(r2045).val);
                           exec_list *const f2044_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2044->then_instructions;

                              body.emit(assign(r2043, r2026, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2044->else_instructions;

                              ir_expression *const r2046 = lshift(r2026, r2029);
                              ir_expression *const r2047 = neg(r2029);
                              ir_expression *const r2048 = bit_and(r2047, body.constant(int(31)));
                              ir_expression *const r2049 = rshift(r2027, r2048);
                              body.emit(assign(r2043, bit_or(r2046, r2049), 0x01));


                           body.instructions = f2044_parent_instructions;
                           body.emit(f2044);

                           /* END IF */

                           body.emit(assign(r2026, r2043, 0x01));

                           body.emit(assign(r2027, r2042, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2040->else_instructions;

                           ir_variable *const r204A = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r204A, body.constant(0u), 0x01));

                           ir_variable *const r204B = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r204B, neg(r2029), 0x01));

                           ir_variable *const r204C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r204C);
                           ir_variable *const r204D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r204D);
                           ir_variable *const r204E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r204E);
                           ir_variable *const r204F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r2050 = neg(r204B);
                           body.emit(assign(r204F, bit_and(r2050, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2052 = equal(r204B, body.constant(int(0)));
                           ir_if *f2051 = new(mem_ctx) ir_if(operand(r2052).val);
                           exec_list *const f2051_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2051->then_instructions;

                              body.emit(assign(r204C, r204A, 0x01));

                              body.emit(assign(r204D, r2027, 0x01));

                              body.emit(assign(r204E, r2026, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2051->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2054 = less(r204B, body.constant(int(32)));
                              ir_if *f2053 = new(mem_ctx) ir_if(operand(r2054).val);
                              exec_list *const f2053_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2053->then_instructions;

                                 body.emit(assign(r204C, lshift(r2027, r204F), 0x01));

                                 ir_expression *const r2055 = lshift(r2026, r204F);
                                 ir_expression *const r2056 = rshift(r2027, r204B);
                                 body.emit(assign(r204D, bit_or(r2055, r2056), 0x01));

                                 body.emit(assign(r204E, rshift(r2026, r204B), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2053->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2058 = equal(r204B, body.constant(int(32)));
                                 ir_if *f2057 = new(mem_ctx) ir_if(operand(r2058).val);
                                 exec_list *const f2057_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2057->then_instructions;

                                    body.emit(assign(r204C, r2027, 0x01));

                                    body.emit(assign(r204D, r2026, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2057->else_instructions;

                                    body.emit(assign(r204A, bit_or(body.constant(0u), r2027), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r205A = less(r204B, body.constant(int(64)));
                                    ir_if *f2059 = new(mem_ctx) ir_if(operand(r205A).val);
                                    exec_list *const f2059_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2059->then_instructions;

                                       body.emit(assign(r204C, lshift(r2026, r204F), 0x01));

                                       ir_expression *const r205B = bit_and(r204B, body.constant(int(31)));
                                       body.emit(assign(r204D, rshift(r2026, r205B), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2059->else_instructions;

                                       ir_variable *const r205C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r205E = equal(r204B, body.constant(int(64)));
                                       ir_if *f205D = new(mem_ctx) ir_if(operand(r205E).val);
                                       exec_list *const f205D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f205D->then_instructions;

                                          body.emit(assign(r205C, r2026, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f205D->else_instructions;

                                          ir_expression *const r205F = nequal(r2026, body.constant(0u));
                                          ir_expression *const r2060 = expr(ir_unop_b2i, r205F);
                                          body.emit(assign(r205C, expr(ir_unop_i2u, r2060), 0x01));


                                       body.instructions = f205D_parent_instructions;
                                       body.emit(f205D);

                                       /* END IF */

                                       body.emit(assign(r204C, r205C, 0x01));

                                       body.emit(assign(r204D, body.constant(0u), 0x01));


                                    body.instructions = f2059_parent_instructions;
                                    body.emit(f2059);

                                    /* END IF */


                                 body.instructions = f2057_parent_instructions;
                                 body.emit(f2057);

                                 /* END IF */

                                 body.emit(assign(r204E, body.constant(0u), 0x01));


                              body.instructions = f2053_parent_instructions;
                              body.emit(f2053);

                              /* END IF */

                              ir_expression *const r2061 = nequal(r204A, body.constant(0u));
                              ir_expression *const r2062 = expr(ir_unop_b2i, r2061);
                              ir_expression *const r2063 = expr(ir_unop_i2u, r2062);
                              body.emit(assign(r204C, bit_or(r204C, r2063), 0x01));


                           body.instructions = f2051_parent_instructions;
                           body.emit(f2051);

                           /* END IF */

                           body.emit(assign(r2026, r204E, 0x01));

                           body.emit(assign(r2027, r204D, 0x01));

                           body.emit(assign(r2028, r204C, 0x01));


                        body.instructions = f2040_parent_instructions;
                        body.emit(f2040);

                        /* END IF */

                        body.emit(assign(r2025, sub(r2025, r2029), 0x01));

                        ir_variable *const r2064 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2064, r2025, 0x01));

                        ir_variable *const r2065 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2065, r2026, 0x01));

                        ir_variable *const r2066 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2066, r2027, 0x01));

                        ir_variable *const r2067 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r2067, r2028, 0x01));

                        ir_variable *const r2068 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r2068, body.constant(true), 0x01));

                        ir_variable *const r2069 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r206A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r206A);
                        ir_expression *const r206B = expr(ir_unop_u2i, r2028);
                        body.emit(assign(r206A, less(r206B, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r206D = lequal(body.constant(int(2045)), r2025);
                        ir_if *f206C = new(mem_ctx) ir_if(operand(r206D).val);
                        exec_list *const f206C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f206C->then_instructions;

                           ir_variable *const r206E = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2070 = less(body.constant(int(2045)), r2025);
                           ir_if *f206F = new(mem_ctx) ir_if(operand(r2070).val);
                           exec_list *const f206F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f206F->then_instructions;

                              body.emit(assign(r206E, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f206F->else_instructions;

                              ir_variable *const r2071 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2073 = equal(r2025, body.constant(int(2045)));
                              ir_if *f2072 = new(mem_ctx) ir_if(operand(r2073).val);
                              exec_list *const f2072_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2072->then_instructions;

                                 ir_expression *const r2074 = equal(body.constant(2097151u), r2026);
                                 ir_expression *const r2075 = equal(body.constant(4294967295u), r2027);
                                 body.emit(assign(r2071, logic_and(r2074, r2075), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2072->else_instructions;

                                 body.emit(assign(r2071, body.constant(false), 0x01));


                              body.instructions = f2072_parent_instructions;
                              body.emit(f2072);

                              /* END IF */

                              body.emit(assign(r206E, logic_and(r2071, r206A), 0x01));


                           body.instructions = f206F_parent_instructions;
                           body.emit(f206F);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2076 = new(mem_ctx) ir_if(operand(r206E).val);
                           exec_list *const f2076_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2076->then_instructions;

                              ir_variable *const r2077 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2077);
                              ir_expression *const r2078 = lshift(r1E07, body.constant(int(31)));
                              body.emit(assign(r2077, add(r2078, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r2077, body.constant(0u), 0x01));

                              body.emit(assign(r2069, r2077, 0x03));

                              body.emit(assign(r2068, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2076->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r207A = less(r2025, body.constant(int(0)));
                              ir_if *f2079 = new(mem_ctx) ir_if(operand(r207A).val);
                              exec_list *const f2079_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2079->then_instructions;

                                 ir_variable *const r207B = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r207B, r2028, 0x01));

                                 ir_variable *const r207C = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r207C, neg(r2025), 0x01));

                                 ir_variable *const r207D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r207D);
                                 ir_variable *const r207E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r207E);
                                 ir_variable *const r207F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r207F);
                                 ir_variable *const r2080 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2081 = neg(r207C);
                                 body.emit(assign(r2080, bit_and(r2081, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2083 = equal(r207C, body.constant(int(0)));
                                 ir_if *f2082 = new(mem_ctx) ir_if(operand(r2083).val);
                                 exec_list *const f2082_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2082->then_instructions;

                                    body.emit(assign(r207D, r2028, 0x01));

                                    body.emit(assign(r207E, r2027, 0x01));

                                    body.emit(assign(r207F, r2026, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2082->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2085 = less(r207C, body.constant(int(32)));
                                    ir_if *f2084 = new(mem_ctx) ir_if(operand(r2085).val);
                                    exec_list *const f2084_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2084->then_instructions;

                                       body.emit(assign(r207D, lshift(r2027, r2080), 0x01));

                                       ir_expression *const r2086 = lshift(r2026, r2080);
                                       ir_expression *const r2087 = rshift(r2027, r207C);
                                       body.emit(assign(r207E, bit_or(r2086, r2087), 0x01));

                                       body.emit(assign(r207F, rshift(r2026, r207C), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2084->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2089 = equal(r207C, body.constant(int(32)));
                                       ir_if *f2088 = new(mem_ctx) ir_if(operand(r2089).val);
                                       exec_list *const f2088_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2088->then_instructions;

                                          body.emit(assign(r207D, r2027, 0x01));

                                          body.emit(assign(r207E, r2026, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2088->else_instructions;

                                          body.emit(assign(r207B, bit_or(r2028, r2027), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r208B = less(r207C, body.constant(int(64)));
                                          ir_if *f208A = new(mem_ctx) ir_if(operand(r208B).val);
                                          exec_list *const f208A_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f208A->then_instructions;

                                             body.emit(assign(r207D, lshift(r2026, r2080), 0x01));

                                             ir_expression *const r208C = bit_and(r207C, body.constant(int(31)));
                                             body.emit(assign(r207E, rshift(r2026, r208C), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f208A->else_instructions;

                                             ir_variable *const r208D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r208F = equal(r207C, body.constant(int(64)));
                                             ir_if *f208E = new(mem_ctx) ir_if(operand(r208F).val);
                                             exec_list *const f208E_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f208E->then_instructions;

                                                body.emit(assign(r208D, r2026, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f208E->else_instructions;

                                                ir_expression *const r2090 = nequal(r2026, body.constant(0u));
                                                ir_expression *const r2091 = expr(ir_unop_b2i, r2090);
                                                body.emit(assign(r208D, expr(ir_unop_i2u, r2091), 0x01));


                                             body.instructions = f208E_parent_instructions;
                                             body.emit(f208E);

                                             /* END IF */

                                             body.emit(assign(r207D, r208D, 0x01));

                                             body.emit(assign(r207E, body.constant(0u), 0x01));


                                          body.instructions = f208A_parent_instructions;
                                          body.emit(f208A);

                                          /* END IF */


                                       body.instructions = f2088_parent_instructions;
                                       body.emit(f2088);

                                       /* END IF */

                                       body.emit(assign(r207F, body.constant(0u), 0x01));


                                    body.instructions = f2084_parent_instructions;
                                    body.emit(f2084);

                                    /* END IF */

                                    ir_expression *const r2092 = nequal(r207B, body.constant(0u));
                                    ir_expression *const r2093 = expr(ir_unop_b2i, r2092);
                                    ir_expression *const r2094 = expr(ir_unop_i2u, r2093);
                                    body.emit(assign(r207D, bit_or(r207D, r2094), 0x01));


                                 body.instructions = f2082_parent_instructions;
                                 body.emit(f2082);

                                 /* END IF */

                                 body.emit(assign(r2065, r207F, 0x01));

                                 body.emit(assign(r2066, r207E, 0x01));

                                 body.emit(assign(r2067, r207D, 0x01));

                                 body.emit(assign(r2064, body.constant(int(0)), 0x01));

                                 body.emit(assign(r206A, less(r207D, body.constant(0u)), 0x01));


                              body.instructions = f2079_parent_instructions;
                              body.emit(f2079);

                              /* END IF */


                           body.instructions = f2076_parent_instructions;
                           body.emit(f2076);

                           /* END IF */


                        body.instructions = f206C_parent_instructions;
                        body.emit(f206C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2095 = new(mem_ctx) ir_if(operand(r2068).val);
                        exec_list *const f2095_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2095->then_instructions;

                           /* IF CONDITION */
                           ir_if *f2096 = new(mem_ctx) ir_if(operand(r206A).val);
                           exec_list *const f2096_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2096->then_instructions;

                              ir_variable *const r2097 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r2097, add(r2066, body.constant(1u)), 0x01));

                              ir_expression *const r2098 = less(r2097, r2066);
                              ir_expression *const r2099 = expr(ir_unop_b2i, r2098);
                              ir_expression *const r209A = expr(ir_unop_i2u, r2099);
                              body.emit(assign(r2065, add(r2065, r209A), 0x01));

                              ir_expression *const r209B = equal(r2067, body.constant(0u));
                              ir_expression *const r209C = expr(ir_unop_b2i, r209B);
                              ir_expression *const r209D = expr(ir_unop_i2u, r209C);
                              ir_expression *const r209E = add(r2067, r209D);
                              ir_expression *const r209F = bit_and(r209E, body.constant(1u));
                              ir_expression *const r20A0 = expr(ir_unop_bit_not, r209F);
                              body.emit(assign(r2066, bit_and(r2097, r20A0), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2096->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r20A2 = bit_or(r2065, r2066);
                              ir_expression *const r20A3 = equal(r20A2, body.constant(0u));
                              ir_if *f20A1 = new(mem_ctx) ir_if(operand(r20A3).val);
                              exec_list *const f20A1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20A1->then_instructions;

                                 body.emit(assign(r2064, body.constant(int(0)), 0x01));


                              body.instructions = f20A1_parent_instructions;
                              body.emit(f20A1);

                              /* END IF */


                           body.instructions = f2096_parent_instructions;
                           body.emit(f2096);

                           /* END IF */

                           ir_variable *const r20A4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r20A4);
                           ir_expression *const r20A5 = lshift(r1E07, body.constant(int(31)));
                           ir_expression *const r20A6 = expr(ir_unop_i2u, r2064);
                           ir_expression *const r20A7 = lshift(r20A6, body.constant(int(20)));
                           ir_expression *const r20A8 = add(r20A5, r20A7);
                           body.emit(assign(r20A4, add(r20A8, r2065), 0x02));

                           body.emit(assign(r20A4, r2066, 0x01));

                           body.emit(assign(r2069, r20A4, 0x03));

                           body.emit(assign(r2068, body.constant(false), 0x01));


                        body.instructions = f2095_parent_instructions;
                        body.emit(f2095);

                        /* END IF */

                        body.emit(assign(r1E08, r2069, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f201D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r20AA = less(r1E0D, r1E0F);
                        ir_if *f20A9 = new(mem_ctx) ir_if(operand(r20AA).val);
                        exec_list *const f20A9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f20A9->then_instructions;

                           ir_variable *const r20AB = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r20AC = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r20AC, sub(r1E0F, r1E0D), 0x01));

                           ir_expression *const r20AD = sub(r1E0E, r1E0C);
                           ir_expression *const r20AE = less(r1E0F, r1E0D);
                           ir_expression *const r20AF = expr(ir_unop_b2i, r20AE);
                           ir_expression *const r20B0 = expr(ir_unop_i2u, r20AF);
                           body.emit(assign(r20AB, sub(r20AD, r20B0), 0x01));

                           body.emit(assign(r1E10, add(r1E0B, body.constant(int(-1))), 0x01));

                           ir_variable *const r20B1 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r20B1, add(r1E10, body.constant(int(-10))), 0x01));

                           ir_variable *const r20B2 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r20B2, r20AB, 0x01));

                           ir_variable *const r20B3 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r20B3, r20AC, 0x01));

                           ir_variable *const r20B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r20B4);
                           ir_variable *const r20B5 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r20B5);
                           /* IF CONDITION */
                           ir_expression *const r20B7 = equal(r20AB, body.constant(0u));
                           ir_if *f20B6 = new(mem_ctx) ir_if(operand(r20B7).val);
                           exec_list *const f20B6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20B6->then_instructions;

                              body.emit(assign(r20B2, r20AC, 0x01));

                              body.emit(assign(r20B3, body.constant(0u), 0x01));

                              body.emit(assign(r20B1, add(r20B1, body.constant(int(-32))), 0x01));


                           body.instructions = f20B6_parent_instructions;
                           body.emit(f20B6);

                           /* END IF */

                           ir_variable *const r20B8 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r20B8, r20B2, 0x01));

                           ir_variable *const r20B9 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r20BA = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r20BA);
                           /* IF CONDITION */
                           ir_expression *const r20BC = equal(r20B2, body.constant(0u));
                           ir_if *f20BB = new(mem_ctx) ir_if(operand(r20BC).val);
                           exec_list *const f20BB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20BB->then_instructions;

                              body.emit(assign(r20B9, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20BB->else_instructions;

                              body.emit(assign(r20BA, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r20BE = bit_and(r20B2, body.constant(4294901760u));
                              ir_expression *const r20BF = equal(r20BE, body.constant(0u));
                              ir_if *f20BD = new(mem_ctx) ir_if(operand(r20BF).val);
                              exec_list *const f20BD_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20BD->then_instructions;

                                 body.emit(assign(r20BA, body.constant(int(16)), 0x01));

                                 body.emit(assign(r20B8, lshift(r20B2, body.constant(int(16))), 0x01));


                              body.instructions = f20BD_parent_instructions;
                              body.emit(f20BD);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r20C1 = bit_and(r20B8, body.constant(4278190080u));
                              ir_expression *const r20C2 = equal(r20C1, body.constant(0u));
                              ir_if *f20C0 = new(mem_ctx) ir_if(operand(r20C2).val);
                              exec_list *const f20C0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20C0->then_instructions;

                                 body.emit(assign(r20BA, add(r20BA, body.constant(int(8))), 0x01));

                                 body.emit(assign(r20B8, lshift(r20B8, body.constant(int(8))), 0x01));


                              body.instructions = f20C0_parent_instructions;
                              body.emit(f20C0);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r20C4 = bit_and(r20B8, body.constant(4026531840u));
                              ir_expression *const r20C5 = equal(r20C4, body.constant(0u));
                              ir_if *f20C3 = new(mem_ctx) ir_if(operand(r20C5).val);
                              exec_list *const f20C3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20C3->then_instructions;

                                 body.emit(assign(r20BA, add(r20BA, body.constant(int(4))), 0x01));

                                 body.emit(assign(r20B8, lshift(r20B8, body.constant(int(4))), 0x01));


                              body.instructions = f20C3_parent_instructions;
                              body.emit(f20C3);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r20C7 = bit_and(r20B8, body.constant(3221225472u));
                              ir_expression *const r20C8 = equal(r20C7, body.constant(0u));
                              ir_if *f20C6 = new(mem_ctx) ir_if(operand(r20C8).val);
                              exec_list *const f20C6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20C6->then_instructions;

                                 body.emit(assign(r20BA, add(r20BA, body.constant(int(2))), 0x01));

                                 body.emit(assign(r20B8, lshift(r20B8, body.constant(int(2))), 0x01));


                              body.instructions = f20C6_parent_instructions;
                              body.emit(f20C6);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r20CA = bit_and(r20B8, body.constant(2147483648u));
                              ir_expression *const r20CB = equal(r20CA, body.constant(0u));
                              ir_if *f20C9 = new(mem_ctx) ir_if(operand(r20CB).val);
                              exec_list *const f20C9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20C9->then_instructions;

                                 body.emit(assign(r20BA, add(r20BA, body.constant(int(1))), 0x01));


                              body.instructions = f20C9_parent_instructions;
                              body.emit(f20C9);

                              /* END IF */

                              body.emit(assign(r20B9, r20BA, 0x01));


                           body.instructions = f20BB_parent_instructions;
                           body.emit(f20BB);

                           /* END IF */

                           body.emit(assign(r20B5, add(r20B9, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r20CD = lequal(body.constant(int(0)), r20B5);
                           ir_if *f20CC = new(mem_ctx) ir_if(operand(r20CD).val);
                           exec_list *const f20CC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20CC->then_instructions;

                              body.emit(assign(r20B4, body.constant(0u), 0x01));

                              ir_variable *const r20CE = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r20CE, lshift(r20B3, r20B5), 0x01));

                              ir_variable *const r20CF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r20D1 = equal(r20B5, body.constant(int(0)));
                              ir_if *f20D0 = new(mem_ctx) ir_if(operand(r20D1).val);
                              exec_list *const f20D0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20D0->then_instructions;

                                 body.emit(assign(r20CF, r20B2, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f20D0->else_instructions;

                                 ir_expression *const r20D2 = lshift(r20B2, r20B5);
                                 ir_expression *const r20D3 = neg(r20B5);
                                 ir_expression *const r20D4 = bit_and(r20D3, body.constant(int(31)));
                                 ir_expression *const r20D5 = rshift(r20B3, r20D4);
                                 body.emit(assign(r20CF, bit_or(r20D2, r20D5), 0x01));


                              body.instructions = f20D0_parent_instructions;
                              body.emit(f20D0);

                              /* END IF */

                              body.emit(assign(r20B2, r20CF, 0x01));

                              body.emit(assign(r20B3, r20CE, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20CC->else_instructions;

                              ir_variable *const r20D6 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r20D6, body.constant(0u), 0x01));

                              ir_variable *const r20D7 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r20D7, neg(r20B5), 0x01));

                              ir_variable *const r20D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r20D8);
                              ir_variable *const r20D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r20D9);
                              ir_variable *const r20DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r20DA);
                              ir_variable *const r20DB = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r20DC = neg(r20D7);
                              body.emit(assign(r20DB, bit_and(r20DC, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r20DE = equal(r20D7, body.constant(int(0)));
                              ir_if *f20DD = new(mem_ctx) ir_if(operand(r20DE).val);
                              exec_list *const f20DD_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20DD->then_instructions;

                                 body.emit(assign(r20D8, r20D6, 0x01));

                                 body.emit(assign(r20D9, r20B3, 0x01));

                                 body.emit(assign(r20DA, r20B2, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f20DD->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r20E0 = less(r20D7, body.constant(int(32)));
                                 ir_if *f20DF = new(mem_ctx) ir_if(operand(r20E0).val);
                                 exec_list *const f20DF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f20DF->then_instructions;

                                    body.emit(assign(r20D8, lshift(r20B3, r20DB), 0x01));

                                    ir_expression *const r20E1 = lshift(r20B2, r20DB);
                                    ir_expression *const r20E2 = rshift(r20B3, r20D7);
                                    body.emit(assign(r20D9, bit_or(r20E1, r20E2), 0x01));

                                    body.emit(assign(r20DA, rshift(r20B2, r20D7), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f20DF->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r20E4 = equal(r20D7, body.constant(int(32)));
                                    ir_if *f20E3 = new(mem_ctx) ir_if(operand(r20E4).val);
                                    exec_list *const f20E3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f20E3->then_instructions;

                                       body.emit(assign(r20D8, r20B3, 0x01));

                                       body.emit(assign(r20D9, r20B2, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f20E3->else_instructions;

                                       body.emit(assign(r20D6, bit_or(body.constant(0u), r20B3), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r20E6 = less(r20D7, body.constant(int(64)));
                                       ir_if *f20E5 = new(mem_ctx) ir_if(operand(r20E6).val);
                                       exec_list *const f20E5_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f20E5->then_instructions;

                                          body.emit(assign(r20D8, lshift(r20B2, r20DB), 0x01));

                                          ir_expression *const r20E7 = bit_and(r20D7, body.constant(int(31)));
                                          body.emit(assign(r20D9, rshift(r20B2, r20E7), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f20E5->else_instructions;

                                          ir_variable *const r20E8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r20EA = equal(r20D7, body.constant(int(64)));
                                          ir_if *f20E9 = new(mem_ctx) ir_if(operand(r20EA).val);
                                          exec_list *const f20E9_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f20E9->then_instructions;

                                             body.emit(assign(r20E8, r20B2, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f20E9->else_instructions;

                                             ir_expression *const r20EB = nequal(r20B2, body.constant(0u));
                                             ir_expression *const r20EC = expr(ir_unop_b2i, r20EB);
                                             body.emit(assign(r20E8, expr(ir_unop_i2u, r20EC), 0x01));


                                          body.instructions = f20E9_parent_instructions;
                                          body.emit(f20E9);

                                          /* END IF */

                                          body.emit(assign(r20D8, r20E8, 0x01));

                                          body.emit(assign(r20D9, body.constant(0u), 0x01));


                                       body.instructions = f20E5_parent_instructions;
                                       body.emit(f20E5);

                                       /* END IF */


                                    body.instructions = f20E3_parent_instructions;
                                    body.emit(f20E3);

                                    /* END IF */

                                    body.emit(assign(r20DA, body.constant(0u), 0x01));


                                 body.instructions = f20DF_parent_instructions;
                                 body.emit(f20DF);

                                 /* END IF */

                                 ir_expression *const r20ED = nequal(r20D6, body.constant(0u));
                                 ir_expression *const r20EE = expr(ir_unop_b2i, r20ED);
                                 ir_expression *const r20EF = expr(ir_unop_i2u, r20EE);
                                 body.emit(assign(r20D8, bit_or(r20D8, r20EF), 0x01));


                              body.instructions = f20DD_parent_instructions;
                              body.emit(f20DD);

                              /* END IF */

                              body.emit(assign(r20B2, r20DA, 0x01));

                              body.emit(assign(r20B3, r20D9, 0x01));

                              body.emit(assign(r20B4, r20D8, 0x01));


                           body.instructions = f20CC_parent_instructions;
                           body.emit(f20CC);

                           /* END IF */

                           body.emit(assign(r20B1, sub(r20B1, r20B5), 0x01));

                           ir_variable *const r20F0 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r20F0, r20B1, 0x01));

                           ir_variable *const r20F1 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r20F1, r20B2, 0x01));

                           ir_variable *const r20F2 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r20F2, r20B3, 0x01));

                           ir_variable *const r20F3 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r20F3, r20B4, 0x01));

                           ir_variable *const r20F4 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r20F4, body.constant(true), 0x01));

                           ir_variable *const r20F5 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r20F6 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r20F6);
                           ir_expression *const r20F7 = expr(ir_unop_u2i, r20B4);
                           body.emit(assign(r20F6, less(r20F7, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r20F9 = lequal(body.constant(int(2045)), r20B1);
                           ir_if *f20F8 = new(mem_ctx) ir_if(operand(r20F9).val);
                           exec_list *const f20F8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20F8->then_instructions;

                              ir_variable *const r20FA = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r20FC = less(body.constant(int(2045)), r20B1);
                              ir_if *f20FB = new(mem_ctx) ir_if(operand(r20FC).val);
                              exec_list *const f20FB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20FB->then_instructions;

                                 body.emit(assign(r20FA, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f20FB->else_instructions;

                                 ir_variable *const r20FD = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r20FF = equal(r20B1, body.constant(int(2045)));
                                 ir_if *f20FE = new(mem_ctx) ir_if(operand(r20FF).val);
                                 exec_list *const f20FE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f20FE->then_instructions;

                                    ir_expression *const r2100 = equal(body.constant(2097151u), r20B2);
                                    ir_expression *const r2101 = equal(body.constant(4294967295u), r20B3);
                                    body.emit(assign(r20FD, logic_and(r2100, r2101), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f20FE->else_instructions;

                                    body.emit(assign(r20FD, body.constant(false), 0x01));


                                 body.instructions = f20FE_parent_instructions;
                                 body.emit(f20FE);

                                 /* END IF */

                                 body.emit(assign(r20FA, logic_and(r20FD, r20F6), 0x01));


                              body.instructions = f20FB_parent_instructions;
                              body.emit(f20FB);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2102 = new(mem_ctx) ir_if(operand(r20FA).val);
                              exec_list *const f2102_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2102->then_instructions;

                                 ir_variable *const r2103 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2103);
                                 ir_expression *const r2104 = lshift(r1E07, body.constant(int(31)));
                                 body.emit(assign(r2103, add(r2104, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r2103, body.constant(0u), 0x01));

                                 body.emit(assign(r20F5, r2103, 0x03));

                                 body.emit(assign(r20F4, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2102->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2106 = less(r20B1, body.constant(int(0)));
                                 ir_if *f2105 = new(mem_ctx) ir_if(operand(r2106).val);
                                 exec_list *const f2105_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2105->then_instructions;

                                    ir_variable *const r2107 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r2107, r20B4, 0x01));

                                    ir_variable *const r2108 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r2108, neg(r20B1), 0x01));

                                    ir_variable *const r2109 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r2109);
                                    ir_variable *const r210A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r210A);
                                    ir_variable *const r210B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r210B);
                                    ir_variable *const r210C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r210D = neg(r2108);
                                    body.emit(assign(r210C, bit_and(r210D, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r210F = equal(r2108, body.constant(int(0)));
                                    ir_if *f210E = new(mem_ctx) ir_if(operand(r210F).val);
                                    exec_list *const f210E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f210E->then_instructions;

                                       body.emit(assign(r2109, r20B4, 0x01));

                                       body.emit(assign(r210A, r20B3, 0x01));

                                       body.emit(assign(r210B, r20B2, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f210E->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2111 = less(r2108, body.constant(int(32)));
                                       ir_if *f2110 = new(mem_ctx) ir_if(operand(r2111).val);
                                       exec_list *const f2110_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2110->then_instructions;

                                          body.emit(assign(r2109, lshift(r20B3, r210C), 0x01));

                                          ir_expression *const r2112 = lshift(r20B2, r210C);
                                          ir_expression *const r2113 = rshift(r20B3, r2108);
                                          body.emit(assign(r210A, bit_or(r2112, r2113), 0x01));

                                          body.emit(assign(r210B, rshift(r20B2, r2108), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2110->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2115 = equal(r2108, body.constant(int(32)));
                                          ir_if *f2114 = new(mem_ctx) ir_if(operand(r2115).val);
                                          exec_list *const f2114_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2114->then_instructions;

                                             body.emit(assign(r2109, r20B3, 0x01));

                                             body.emit(assign(r210A, r20B2, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2114->else_instructions;

                                             body.emit(assign(r2107, bit_or(r20B4, r20B3), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r2117 = less(r2108, body.constant(int(64)));
                                             ir_if *f2116 = new(mem_ctx) ir_if(operand(r2117).val);
                                             exec_list *const f2116_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2116->then_instructions;

                                                body.emit(assign(r2109, lshift(r20B2, r210C), 0x01));

                                                ir_expression *const r2118 = bit_and(r2108, body.constant(int(31)));
                                                body.emit(assign(r210A, rshift(r20B2, r2118), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2116->else_instructions;

                                                ir_variable *const r2119 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r211B = equal(r2108, body.constant(int(64)));
                                                ir_if *f211A = new(mem_ctx) ir_if(operand(r211B).val);
                                                exec_list *const f211A_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f211A->then_instructions;

                                                   body.emit(assign(r2119, r20B2, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f211A->else_instructions;

                                                   ir_expression *const r211C = nequal(r20B2, body.constant(0u));
                                                   ir_expression *const r211D = expr(ir_unop_b2i, r211C);
                                                   body.emit(assign(r2119, expr(ir_unop_i2u, r211D), 0x01));


                                                body.instructions = f211A_parent_instructions;
                                                body.emit(f211A);

                                                /* END IF */

                                                body.emit(assign(r2109, r2119, 0x01));

                                                body.emit(assign(r210A, body.constant(0u), 0x01));


                                             body.instructions = f2116_parent_instructions;
                                             body.emit(f2116);

                                             /* END IF */


                                          body.instructions = f2114_parent_instructions;
                                          body.emit(f2114);

                                          /* END IF */

                                          body.emit(assign(r210B, body.constant(0u), 0x01));


                                       body.instructions = f2110_parent_instructions;
                                       body.emit(f2110);

                                       /* END IF */

                                       ir_expression *const r211E = nequal(r2107, body.constant(0u));
                                       ir_expression *const r211F = expr(ir_unop_b2i, r211E);
                                       ir_expression *const r2120 = expr(ir_unop_i2u, r211F);
                                       body.emit(assign(r2109, bit_or(r2109, r2120), 0x01));


                                    body.instructions = f210E_parent_instructions;
                                    body.emit(f210E);

                                    /* END IF */

                                    body.emit(assign(r20F1, r210B, 0x01));

                                    body.emit(assign(r20F2, r210A, 0x01));

                                    body.emit(assign(r20F3, r2109, 0x01));

                                    body.emit(assign(r20F0, body.constant(int(0)), 0x01));

                                    body.emit(assign(r20F6, less(r2109, body.constant(0u)), 0x01));


                                 body.instructions = f2105_parent_instructions;
                                 body.emit(f2105);

                                 /* END IF */


                              body.instructions = f2102_parent_instructions;
                              body.emit(f2102);

                              /* END IF */


                           body.instructions = f20F8_parent_instructions;
                           body.emit(f20F8);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2121 = new(mem_ctx) ir_if(operand(r20F4).val);
                           exec_list *const f2121_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2121->then_instructions;

                              /* IF CONDITION */
                              ir_if *f2122 = new(mem_ctx) ir_if(operand(r20F6).val);
                              exec_list *const f2122_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2122->then_instructions;

                                 ir_variable *const r2123 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r2123, add(r20F2, body.constant(1u)), 0x01));

                                 ir_expression *const r2124 = less(r2123, r20F2);
                                 ir_expression *const r2125 = expr(ir_unop_b2i, r2124);
                                 ir_expression *const r2126 = expr(ir_unop_i2u, r2125);
                                 body.emit(assign(r20F1, add(r20F1, r2126), 0x01));

                                 ir_expression *const r2127 = equal(r20F3, body.constant(0u));
                                 ir_expression *const r2128 = expr(ir_unop_b2i, r2127);
                                 ir_expression *const r2129 = expr(ir_unop_i2u, r2128);
                                 ir_expression *const r212A = add(r20F3, r2129);
                                 ir_expression *const r212B = bit_and(r212A, body.constant(1u));
                                 ir_expression *const r212C = expr(ir_unop_bit_not, r212B);
                                 body.emit(assign(r20F2, bit_and(r2123, r212C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2122->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r212E = bit_or(r20F1, r20F2);
                                 ir_expression *const r212F = equal(r212E, body.constant(0u));
                                 ir_if *f212D = new(mem_ctx) ir_if(operand(r212F).val);
                                 exec_list *const f212D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f212D->then_instructions;

                                    body.emit(assign(r20F0, body.constant(int(0)), 0x01));


                                 body.instructions = f212D_parent_instructions;
                                 body.emit(f212D);

                                 /* END IF */


                              body.instructions = f2122_parent_instructions;
                              body.emit(f2122);

                              /* END IF */

                              ir_variable *const r2130 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2130);
                              ir_expression *const r2131 = lshift(r1E07, body.constant(int(31)));
                              ir_expression *const r2132 = expr(ir_unop_i2u, r20F0);
                              ir_expression *const r2133 = lshift(r2132, body.constant(int(20)));
                              ir_expression *const r2134 = add(r2131, r2133);
                              body.emit(assign(r2130, add(r2134, r20F1), 0x02));

                              body.emit(assign(r2130, r20F2, 0x01));

                              body.emit(assign(r20F5, r2130, 0x03));

                              body.emit(assign(r20F4, body.constant(false), 0x01));


                           body.instructions = f2121_parent_instructions;
                           body.emit(f2121);

                           /* END IF */

                           body.emit(assign(r1E08, r20F5, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f20A9->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2136 = less(r1E0F, r1E0D);
                           ir_if *f2135 = new(mem_ctx) ir_if(operand(r2136).val);
                           exec_list *const f2135_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2135->then_instructions;

                              ir_variable *const r2137 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r2138 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2138, sub(r1E0D, r1E0F), 0x01));

                              ir_expression *const r2139 = sub(r1E0C, r1E0E);
                              ir_expression *const r213A = less(r1E0D, r1E0F);
                              ir_expression *const r213B = expr(ir_unop_b2i, r213A);
                              ir_expression *const r213C = expr(ir_unop_i2u, r213B);
                              body.emit(assign(r2137, sub(r2139, r213C), 0x01));

                              body.emit(assign(r1E07, bit_xor(r1E07, body.constant(1u)), 0x01));

                              body.emit(assign(r1E10, add(r1E0A, body.constant(int(-1))), 0x01));

                              ir_variable *const r213D = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r213D, add(r1E10, body.constant(int(-10))), 0x01));

                              ir_variable *const r213E = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r213E, r2137, 0x01));

                              ir_variable *const r213F = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r213F, r2138, 0x01));

                              ir_variable *const r2140 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r2140);
                              ir_variable *const r2141 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2141);
                              /* IF CONDITION */
                              ir_expression *const r2143 = equal(r2137, body.constant(0u));
                              ir_if *f2142 = new(mem_ctx) ir_if(operand(r2143).val);
                              exec_list *const f2142_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2142->then_instructions;

                                 body.emit(assign(r213E, r2138, 0x01));

                                 body.emit(assign(r213F, body.constant(0u), 0x01));

                                 body.emit(assign(r213D, add(r213D, body.constant(int(-32))), 0x01));


                              body.instructions = f2142_parent_instructions;
                              body.emit(f2142);

                              /* END IF */

                              ir_variable *const r2144 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r2144, r213E, 0x01));

                              ir_variable *const r2145 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r2146 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2146);
                              /* IF CONDITION */
                              ir_expression *const r2148 = equal(r213E, body.constant(0u));
                              ir_if *f2147 = new(mem_ctx) ir_if(operand(r2148).val);
                              exec_list *const f2147_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2147->then_instructions;

                                 body.emit(assign(r2145, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2147->else_instructions;

                                 body.emit(assign(r2146, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r214A = bit_and(r213E, body.constant(4294901760u));
                                 ir_expression *const r214B = equal(r214A, body.constant(0u));
                                 ir_if *f2149 = new(mem_ctx) ir_if(operand(r214B).val);
                                 exec_list *const f2149_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2149->then_instructions;

                                    body.emit(assign(r2146, body.constant(int(16)), 0x01));

                                    body.emit(assign(r2144, lshift(r213E, body.constant(int(16))), 0x01));


                                 body.instructions = f2149_parent_instructions;
                                 body.emit(f2149);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r214D = bit_and(r2144, body.constant(4278190080u));
                                 ir_expression *const r214E = equal(r214D, body.constant(0u));
                                 ir_if *f214C = new(mem_ctx) ir_if(operand(r214E).val);
                                 exec_list *const f214C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f214C->then_instructions;

                                    body.emit(assign(r2146, add(r2146, body.constant(int(8))), 0x01));

                                    body.emit(assign(r2144, lshift(r2144, body.constant(int(8))), 0x01));


                                 body.instructions = f214C_parent_instructions;
                                 body.emit(f214C);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2150 = bit_and(r2144, body.constant(4026531840u));
                                 ir_expression *const r2151 = equal(r2150, body.constant(0u));
                                 ir_if *f214F = new(mem_ctx) ir_if(operand(r2151).val);
                                 exec_list *const f214F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f214F->then_instructions;

                                    body.emit(assign(r2146, add(r2146, body.constant(int(4))), 0x01));

                                    body.emit(assign(r2144, lshift(r2144, body.constant(int(4))), 0x01));


                                 body.instructions = f214F_parent_instructions;
                                 body.emit(f214F);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2153 = bit_and(r2144, body.constant(3221225472u));
                                 ir_expression *const r2154 = equal(r2153, body.constant(0u));
                                 ir_if *f2152 = new(mem_ctx) ir_if(operand(r2154).val);
                                 exec_list *const f2152_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2152->then_instructions;

                                    body.emit(assign(r2146, add(r2146, body.constant(int(2))), 0x01));

                                    body.emit(assign(r2144, lshift(r2144, body.constant(int(2))), 0x01));


                                 body.instructions = f2152_parent_instructions;
                                 body.emit(f2152);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2156 = bit_and(r2144, body.constant(2147483648u));
                                 ir_expression *const r2157 = equal(r2156, body.constant(0u));
                                 ir_if *f2155 = new(mem_ctx) ir_if(operand(r2157).val);
                                 exec_list *const f2155_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2155->then_instructions;

                                    body.emit(assign(r2146, add(r2146, body.constant(int(1))), 0x01));


                                 body.instructions = f2155_parent_instructions;
                                 body.emit(f2155);

                                 /* END IF */

                                 body.emit(assign(r2145, r2146, 0x01));


                              body.instructions = f2147_parent_instructions;
                              body.emit(f2147);

                              /* END IF */

                              body.emit(assign(r2141, add(r2145, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2159 = lequal(body.constant(int(0)), r2141);
                              ir_if *f2158 = new(mem_ctx) ir_if(operand(r2159).val);
                              exec_list *const f2158_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2158->then_instructions;

                                 body.emit(assign(r2140, body.constant(0u), 0x01));

                                 ir_variable *const r215A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r215A, lshift(r213F, r2141), 0x01));

                                 ir_variable *const r215B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r215D = equal(r2141, body.constant(int(0)));
                                 ir_if *f215C = new(mem_ctx) ir_if(operand(r215D).val);
                                 exec_list *const f215C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f215C->then_instructions;

                                    body.emit(assign(r215B, r213E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f215C->else_instructions;

                                    ir_expression *const r215E = lshift(r213E, r2141);
                                    ir_expression *const r215F = neg(r2141);
                                    ir_expression *const r2160 = bit_and(r215F, body.constant(int(31)));
                                    ir_expression *const r2161 = rshift(r213F, r2160);
                                    body.emit(assign(r215B, bit_or(r215E, r2161), 0x01));


                                 body.instructions = f215C_parent_instructions;
                                 body.emit(f215C);

                                 /* END IF */

                                 body.emit(assign(r213E, r215B, 0x01));

                                 body.emit(assign(r213F, r215A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2158->else_instructions;

                                 ir_variable *const r2162 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2162, body.constant(0u), 0x01));

                                 ir_variable *const r2163 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2163, neg(r2141), 0x01));

                                 ir_variable *const r2164 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2164);
                                 ir_variable *const r2165 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2165);
                                 ir_variable *const r2166 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2166);
                                 ir_variable *const r2167 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2168 = neg(r2163);
                                 body.emit(assign(r2167, bit_and(r2168, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r216A = equal(r2163, body.constant(int(0)));
                                 ir_if *f2169 = new(mem_ctx) ir_if(operand(r216A).val);
                                 exec_list *const f2169_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2169->then_instructions;

                                    body.emit(assign(r2164, r2162, 0x01));

                                    body.emit(assign(r2165, r213F, 0x01));

                                    body.emit(assign(r2166, r213E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2169->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r216C = less(r2163, body.constant(int(32)));
                                    ir_if *f216B = new(mem_ctx) ir_if(operand(r216C).val);
                                    exec_list *const f216B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f216B->then_instructions;

                                       body.emit(assign(r2164, lshift(r213F, r2167), 0x01));

                                       ir_expression *const r216D = lshift(r213E, r2167);
                                       ir_expression *const r216E = rshift(r213F, r2163);
                                       body.emit(assign(r2165, bit_or(r216D, r216E), 0x01));

                                       body.emit(assign(r2166, rshift(r213E, r2163), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f216B->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2170 = equal(r2163, body.constant(int(32)));
                                       ir_if *f216F = new(mem_ctx) ir_if(operand(r2170).val);
                                       exec_list *const f216F_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f216F->then_instructions;

                                          body.emit(assign(r2164, r213F, 0x01));

                                          body.emit(assign(r2165, r213E, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f216F->else_instructions;

                                          body.emit(assign(r2162, bit_or(body.constant(0u), r213F), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2172 = less(r2163, body.constant(int(64)));
                                          ir_if *f2171 = new(mem_ctx) ir_if(operand(r2172).val);
                                          exec_list *const f2171_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2171->then_instructions;

                                             body.emit(assign(r2164, lshift(r213E, r2167), 0x01));

                                             ir_expression *const r2173 = bit_and(r2163, body.constant(int(31)));
                                             body.emit(assign(r2165, rshift(r213E, r2173), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2171->else_instructions;

                                             ir_variable *const r2174 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2176 = equal(r2163, body.constant(int(64)));
                                             ir_if *f2175 = new(mem_ctx) ir_if(operand(r2176).val);
                                             exec_list *const f2175_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2175->then_instructions;

                                                body.emit(assign(r2174, r213E, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2175->else_instructions;

                                                ir_expression *const r2177 = nequal(r213E, body.constant(0u));
                                                ir_expression *const r2178 = expr(ir_unop_b2i, r2177);
                                                body.emit(assign(r2174, expr(ir_unop_i2u, r2178), 0x01));


                                             body.instructions = f2175_parent_instructions;
                                             body.emit(f2175);

                                             /* END IF */

                                             body.emit(assign(r2164, r2174, 0x01));

                                             body.emit(assign(r2165, body.constant(0u), 0x01));


                                          body.instructions = f2171_parent_instructions;
                                          body.emit(f2171);

                                          /* END IF */


                                       body.instructions = f216F_parent_instructions;
                                       body.emit(f216F);

                                       /* END IF */

                                       body.emit(assign(r2166, body.constant(0u), 0x01));


                                    body.instructions = f216B_parent_instructions;
                                    body.emit(f216B);

                                    /* END IF */

                                    ir_expression *const r2179 = nequal(r2162, body.constant(0u));
                                    ir_expression *const r217A = expr(ir_unop_b2i, r2179);
                                    ir_expression *const r217B = expr(ir_unop_i2u, r217A);
                                    body.emit(assign(r2164, bit_or(r2164, r217B), 0x01));


                                 body.instructions = f2169_parent_instructions;
                                 body.emit(f2169);

                                 /* END IF */

                                 body.emit(assign(r213E, r2166, 0x01));

                                 body.emit(assign(r213F, r2165, 0x01));

                                 body.emit(assign(r2140, r2164, 0x01));


                              body.instructions = f2158_parent_instructions;
                              body.emit(f2158);

                              /* END IF */

                              body.emit(assign(r213D, sub(r213D, r2141), 0x01));

                              ir_variable *const r217C = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r217C, r213D, 0x01));

                              ir_variable *const r217D = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r217D, r213E, 0x01));

                              ir_variable *const r217E = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r217E, r213F, 0x01));

                              ir_variable *const r217F = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r217F, r2140, 0x01));

                              ir_variable *const r2180 = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r2180, body.constant(true), 0x01));

                              ir_variable *const r2181 = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r2182 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r2182);
                              ir_expression *const r2183 = expr(ir_unop_u2i, r2140);
                              body.emit(assign(r2182, less(r2183, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2185 = lequal(body.constant(int(2045)), r213D);
                              ir_if *f2184 = new(mem_ctx) ir_if(operand(r2185).val);
                              exec_list *const f2184_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2184->then_instructions;

                                 ir_variable *const r2186 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2188 = less(body.constant(int(2045)), r213D);
                                 ir_if *f2187 = new(mem_ctx) ir_if(operand(r2188).val);
                                 exec_list *const f2187_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2187->then_instructions;

                                    body.emit(assign(r2186, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2187->else_instructions;

                                    ir_variable *const r2189 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r218B = equal(r213D, body.constant(int(2045)));
                                    ir_if *f218A = new(mem_ctx) ir_if(operand(r218B).val);
                                    exec_list *const f218A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f218A->then_instructions;

                                       ir_expression *const r218C = equal(body.constant(2097151u), r213E);
                                       ir_expression *const r218D = equal(body.constant(4294967295u), r213F);
                                       body.emit(assign(r2189, logic_and(r218C, r218D), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f218A->else_instructions;

                                       body.emit(assign(r2189, body.constant(false), 0x01));


                                    body.instructions = f218A_parent_instructions;
                                    body.emit(f218A);

                                    /* END IF */

                                    body.emit(assign(r2186, logic_and(r2189, r2182), 0x01));


                                 body.instructions = f2187_parent_instructions;
                                 body.emit(f2187);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f218E = new(mem_ctx) ir_if(operand(r2186).val);
                                 exec_list *const f218E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f218E->then_instructions;

                                    ir_variable *const r218F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r218F);
                                    ir_expression *const r2190 = lshift(r1E07, body.constant(int(31)));
                                    body.emit(assign(r218F, add(r2190, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r218F, body.constant(0u), 0x01));

                                    body.emit(assign(r2181, r218F, 0x03));

                                    body.emit(assign(r2180, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f218E->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2192 = less(r213D, body.constant(int(0)));
                                    ir_if *f2191 = new(mem_ctx) ir_if(operand(r2192).val);
                                    exec_list *const f2191_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2191->then_instructions;

                                       ir_variable *const r2193 = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r2193, r2140, 0x01));

                                       ir_variable *const r2194 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r2194, neg(r213D), 0x01));

                                       ir_variable *const r2195 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r2195);
                                       ir_variable *const r2196 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r2196);
                                       ir_variable *const r2197 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r2197);
                                       ir_variable *const r2198 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r2199 = neg(r2194);
                                       body.emit(assign(r2198, bit_and(r2199, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r219B = equal(r2194, body.constant(int(0)));
                                       ir_if *f219A = new(mem_ctx) ir_if(operand(r219B).val);
                                       exec_list *const f219A_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f219A->then_instructions;

                                          body.emit(assign(r2195, r2140, 0x01));

                                          body.emit(assign(r2196, r213F, 0x01));

                                          body.emit(assign(r2197, r213E, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f219A->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r219D = less(r2194, body.constant(int(32)));
                                          ir_if *f219C = new(mem_ctx) ir_if(operand(r219D).val);
                                          exec_list *const f219C_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f219C->then_instructions;

                                             body.emit(assign(r2195, lshift(r213F, r2198), 0x01));

                                             ir_expression *const r219E = lshift(r213E, r2198);
                                             ir_expression *const r219F = rshift(r213F, r2194);
                                             body.emit(assign(r2196, bit_or(r219E, r219F), 0x01));

                                             body.emit(assign(r2197, rshift(r213E, r2194), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f219C->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r21A1 = equal(r2194, body.constant(int(32)));
                                             ir_if *f21A0 = new(mem_ctx) ir_if(operand(r21A1).val);
                                             exec_list *const f21A0_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f21A0->then_instructions;

                                                body.emit(assign(r2195, r213F, 0x01));

                                                body.emit(assign(r2196, r213E, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f21A0->else_instructions;

                                                body.emit(assign(r2193, bit_or(r2140, r213F), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r21A3 = less(r2194, body.constant(int(64)));
                                                ir_if *f21A2 = new(mem_ctx) ir_if(operand(r21A3).val);
                                                exec_list *const f21A2_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f21A2->then_instructions;

                                                   body.emit(assign(r2195, lshift(r213E, r2198), 0x01));

                                                   ir_expression *const r21A4 = bit_and(r2194, body.constant(int(31)));
                                                   body.emit(assign(r2196, rshift(r213E, r21A4), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f21A2->else_instructions;

                                                   ir_variable *const r21A5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r21A7 = equal(r2194, body.constant(int(64)));
                                                   ir_if *f21A6 = new(mem_ctx) ir_if(operand(r21A7).val);
                                                   exec_list *const f21A6_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f21A6->then_instructions;

                                                      body.emit(assign(r21A5, r213E, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f21A6->else_instructions;

                                                      ir_expression *const r21A8 = nequal(r213E, body.constant(0u));
                                                      ir_expression *const r21A9 = expr(ir_unop_b2i, r21A8);
                                                      body.emit(assign(r21A5, expr(ir_unop_i2u, r21A9), 0x01));


                                                   body.instructions = f21A6_parent_instructions;
                                                   body.emit(f21A6);

                                                   /* END IF */

                                                   body.emit(assign(r2195, r21A5, 0x01));

                                                   body.emit(assign(r2196, body.constant(0u), 0x01));


                                                body.instructions = f21A2_parent_instructions;
                                                body.emit(f21A2);

                                                /* END IF */


                                             body.instructions = f21A0_parent_instructions;
                                             body.emit(f21A0);

                                             /* END IF */

                                             body.emit(assign(r2197, body.constant(0u), 0x01));


                                          body.instructions = f219C_parent_instructions;
                                          body.emit(f219C);

                                          /* END IF */

                                          ir_expression *const r21AA = nequal(r2193, body.constant(0u));
                                          ir_expression *const r21AB = expr(ir_unop_b2i, r21AA);
                                          ir_expression *const r21AC = expr(ir_unop_i2u, r21AB);
                                          body.emit(assign(r2195, bit_or(r2195, r21AC), 0x01));


                                       body.instructions = f219A_parent_instructions;
                                       body.emit(f219A);

                                       /* END IF */

                                       body.emit(assign(r217D, r2197, 0x01));

                                       body.emit(assign(r217E, r2196, 0x01));

                                       body.emit(assign(r217F, r2195, 0x01));

                                       body.emit(assign(r217C, body.constant(int(0)), 0x01));

                                       body.emit(assign(r2182, less(r2195, body.constant(0u)), 0x01));


                                    body.instructions = f2191_parent_instructions;
                                    body.emit(f2191);

                                    /* END IF */


                                 body.instructions = f218E_parent_instructions;
                                 body.emit(f218E);

                                 /* END IF */


                              body.instructions = f2184_parent_instructions;
                              body.emit(f2184);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f21AD = new(mem_ctx) ir_if(operand(r2180).val);
                              exec_list *const f21AD_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f21AD->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f21AE = new(mem_ctx) ir_if(operand(r2182).val);
                                 exec_list *const f21AE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21AE->then_instructions;

                                    ir_variable *const r21AF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r21AF, add(r217E, body.constant(1u)), 0x01));

                                    ir_expression *const r21B0 = less(r21AF, r217E);
                                    ir_expression *const r21B1 = expr(ir_unop_b2i, r21B0);
                                    ir_expression *const r21B2 = expr(ir_unop_i2u, r21B1);
                                    body.emit(assign(r217D, add(r217D, r21B2), 0x01));

                                    ir_expression *const r21B3 = equal(r217F, body.constant(0u));
                                    ir_expression *const r21B4 = expr(ir_unop_b2i, r21B3);
                                    ir_expression *const r21B5 = expr(ir_unop_i2u, r21B4);
                                    ir_expression *const r21B6 = add(r217F, r21B5);
                                    ir_expression *const r21B7 = bit_and(r21B6, body.constant(1u));
                                    ir_expression *const r21B8 = expr(ir_unop_bit_not, r21B7);
                                    body.emit(assign(r217E, bit_and(r21AF, r21B8), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f21AE->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r21BA = bit_or(r217D, r217E);
                                    ir_expression *const r21BB = equal(r21BA, body.constant(0u));
                                    ir_if *f21B9 = new(mem_ctx) ir_if(operand(r21BB).val);
                                    exec_list *const f21B9_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f21B9->then_instructions;

                                       body.emit(assign(r217C, body.constant(int(0)), 0x01));


                                    body.instructions = f21B9_parent_instructions;
                                    body.emit(f21B9);

                                    /* END IF */


                                 body.instructions = f21AE_parent_instructions;
                                 body.emit(f21AE);

                                 /* END IF */

                                 ir_variable *const r21BC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r21BC);
                                 ir_expression *const r21BD = lshift(r1E07, body.constant(int(31)));
                                 ir_expression *const r21BE = expr(ir_unop_i2u, r217C);
                                 ir_expression *const r21BF = lshift(r21BE, body.constant(int(20)));
                                 ir_expression *const r21C0 = add(r21BD, r21BF);
                                 body.emit(assign(r21BC, add(r21C0, r217D), 0x02));

                                 body.emit(assign(r21BC, r217E, 0x01));

                                 body.emit(assign(r2181, r21BC, 0x03));

                                 body.emit(assign(r2180, body.constant(false), 0x01));


                              body.instructions = f21AD_parent_instructions;
                              body.emit(f21AD);

                              /* END IF */

                              body.emit(assign(r1E08, r2181, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2135->else_instructions;

                              ir_variable *const r21C1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r21C1);
                              body.emit(assign(r21C1, body.constant(0u), 0x02));

                              body.emit(assign(r21C1, body.constant(0u), 0x01));

                              body.emit(assign(r1E08, r21C1, 0x03));


                           body.instructions = f2135_parent_instructions;
                           body.emit(f2135);

                           /* END IF */


                        body.instructions = f20A9_parent_instructions;
                        body.emit(f20A9);

                        /* END IF */


                     body.instructions = f201D_parent_instructions;
                     body.emit(f201D);

                     /* END IF */


                  body.instructions = f1F91_parent_instructions;
                  body.emit(f1F91);

                  /* END IF */


               body.instructions = f1F7C_parent_instructions;
               body.emit(f1F7C);

               /* END IF */


            body.instructions = f1ECD_parent_instructions;
            body.emit(f1ECD);

            /* END IF */


         body.instructions = f1E1C_parent_instructions;
         body.emit(f1E1C);

         /* END IF */

         body.emit(assign(r1CAA, r1E08, 0x03));


      body.instructions = f1CAC_parent_instructions;
      body.emit(f1CAC);

      /* END IF */

      body.emit(assign(r1CA8, r1CAA, 0x03));


   body.instructions = f1CA9_parent_instructions;
   body.emit(f1CA9);

   /* END IF */

   body.emit(ret(r1CA8));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ffract64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r21C2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r21C2);
   ir_variable *const r21C3 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r21C4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r21C5 = rshift(swizzle_y(r21C2), body.constant(int(20)));
   ir_expression *const r21C6 = bit_and(r21C5, body.constant(2047u));
   ir_expression *const r21C7 = expr(ir_unop_u2i, r21C6);
   body.emit(assign(r21C4, add(r21C7, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r21C9 = less(r21C4, body.constant(int(0)));
   ir_if *f21C8 = new(mem_ctx) ir_if(operand(r21C9).val);
   exec_list *const f21C8_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f21C8->then_instructions;

      body.emit(assign(r21C3, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f21C8->else_instructions;

      /* IF CONDITION */
      ir_expression *const r21CB = greater(r21C4, body.constant(int(52)));
      ir_if *f21CA = new(mem_ctx) ir_if(operand(r21CB).val);
      exec_list *const f21CA_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f21CA->then_instructions;

         body.emit(assign(r21C3, r21C2, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f21CA->else_instructions;

         ir_variable *const r21CC = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r21CC, sub(body.constant(int(52)), r21C4), 0x01));

         ir_variable *const r21CD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r21CF = gequal(r21CC, body.constant(int(32)));
         ir_if *f21CE = new(mem_ctx) ir_if(operand(r21CF).val);
         exec_list *const f21CE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f21CE->then_instructions;

            body.emit(assign(r21CD, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f21CE->else_instructions;

            body.emit(assign(r21CD, lshift(body.constant(4294967295u), r21CC), 0x01));


         body.instructions = f21CE_parent_instructions;
         body.emit(f21CE);

         /* END IF */

         ir_variable *const r21D0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r21D2 = less(r21CC, body.constant(int(33)));
         ir_if *f21D1 = new(mem_ctx) ir_if(operand(r21D2).val);
         exec_list *const f21D1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f21D1->then_instructions;

            body.emit(assign(r21D0, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f21D1->else_instructions;

            ir_expression *const r21D3 = add(r21CC, body.constant(int(-32)));
            body.emit(assign(r21D0, lshift(body.constant(4294967295u), r21D3), 0x01));


         body.instructions = f21D1_parent_instructions;
         body.emit(f21D1);

         /* END IF */

         ir_variable *const r21D4 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r21D4, bit_and(r21CD, swizzle_x(r21C2)), 0x01));

         body.emit(assign(r21D4, bit_and(r21D0, swizzle_y(r21C2)), 0x02));

         body.emit(assign(r21C3, r21D4, 0x03));


      body.instructions = f21CA_parent_instructions;
      body.emit(f21CA);

      /* END IF */


   body.instructions = f21C8_parent_instructions;
   body.emit(f21C8);

   /* END IF */

   ir_variable *const r21D5 = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r21D6 = rshift(swizzle_y(r21C2), body.constant(int(31)));
   ir_expression *const r21D7 = expr(ir_unop_u2i, r21D6);
   body.emit(assign(r21D5, expr(ir_unop_i2b, r21D7), 0x01));

   ir_variable *const r21D8 = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r21DA = expr(ir_unop_logic_not, r21D5);
   ir_if *f21D9 = new(mem_ctx) ir_if(operand(r21DA).val);
   exec_list *const f21D9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f21D9->then_instructions;

      body.emit(assign(r21D8, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f21D9->else_instructions;

      ir_variable *const r21DB = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r21DC = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r21DC);
      ir_variable *const r21DD = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r21DD);
      ir_expression *const r21DE = rshift(swizzle_y(r21C2), body.constant(int(20)));
      ir_expression *const r21DF = bit_and(r21DE, body.constant(2047u));
      ir_expression *const r21E0 = expr(ir_unop_u2i, r21DF);
      ir_expression *const r21E1 = equal(r21E0, body.constant(int(2047)));
      ir_expression *const r21E2 = bit_and(swizzle_y(r21C2), body.constant(1048575u));
      ir_expression *const r21E3 = bit_or(r21E2, swizzle_x(r21C2));
      ir_expression *const r21E4 = nequal(r21E3, body.constant(0u));
      body.emit(assign(r21DD, logic_and(r21E1, r21E4), 0x01));

      ir_expression *const r21E5 = rshift(swizzle_y(r21C3), body.constant(int(20)));
      ir_expression *const r21E6 = bit_and(r21E5, body.constant(2047u));
      ir_expression *const r21E7 = expr(ir_unop_u2i, r21E6);
      ir_expression *const r21E8 = equal(r21E7, body.constant(int(2047)));
      ir_expression *const r21E9 = bit_and(swizzle_y(r21C3), body.constant(1048575u));
      ir_expression *const r21EA = bit_or(r21E9, swizzle_x(r21C3));
      ir_expression *const r21EB = nequal(r21EA, body.constant(0u));
      body.emit(assign(r21DC, logic_and(r21E8, r21EB), 0x01));

      /* IF CONDITION */
      ir_expression *const r21ED = logic_or(r21DD, r21DC);
      ir_if *f21EC = new(mem_ctx) ir_if(operand(r21ED).val);
      exec_list *const f21EC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f21EC->then_instructions;

         body.emit(assign(r21DB, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f21EC->else_instructions;

         ir_expression *const r21EE = equal(swizzle_x(r21C2), swizzle_x(r21C3));
         ir_expression *const r21EF = equal(swizzle_y(r21C2), swizzle_y(r21C3));
         ir_expression *const r21F0 = equal(swizzle_x(r21C2), body.constant(0u));
         ir_expression *const r21F1 = bit_or(swizzle_y(r21C2), swizzle_y(r21C3));
         ir_expression *const r21F2 = lshift(r21F1, body.constant(int(1)));
         ir_expression *const r21F3 = equal(r21F2, body.constant(0u));
         ir_expression *const r21F4 = logic_and(r21F0, r21F3);
         ir_expression *const r21F5 = logic_or(r21EF, r21F4);
         body.emit(assign(r21DB, logic_and(r21EE, r21F5), 0x01));


      body.instructions = f21EC_parent_instructions;
      body.emit(f21EC);

      /* END IF */

      body.emit(assign(r21D8, r21DB, 0x01));


   body.instructions = f21D9_parent_instructions;
   body.emit(f21D9);

   /* END IF */

   ir_variable *const r21F6 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f21F7 = new(mem_ctx) ir_if(operand(r21D8).val);
   exec_list *const f21F7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f21F7->then_instructions;

      body.emit(assign(r21F6, r21C3, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f21F7->else_instructions;

      ir_variable *const r21F8 = body.make_temp(glsl_type::uvec2_type, "a");
      body.emit(assign(r21F8, body.constant(0u), 0x01));

      body.emit(assign(r21F8, body.constant(3220176896u), 0x02));

      ir_variable *const r21F9 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r21FA = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r21FA, rshift(swizzle_y(r21C3), body.constant(int(31))), 0x01));

      ir_variable *const r21FB = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r21FB, body.constant(1u), 0x01));

      /* IF CONDITION */
      ir_expression *const r21FD = equal(r21FA, body.constant(1u));
      ir_if *f21FC = new(mem_ctx) ir_if(operand(r21FD).val);
      exec_list *const f21FC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f21FC->then_instructions;

         ir_variable *const r21FE = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r21FE, body.constant(true), 0x01));

         ir_variable *const r21FF = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2200 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2200);
         ir_variable *const r2201 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r2201);
         ir_variable *const r2202 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r2202);
         ir_variable *const r2203 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r2203);
         ir_variable *const r2204 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r2204);
         ir_variable *const r2205 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r2205);
         ir_variable *const r2206 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r2206);
         ir_variable *const r2207 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r2207);
         body.emit(assign(r2207, body.constant(0u), 0x01));

         body.emit(assign(r2206, body.constant(0u), 0x01));

         ir_variable *const r2208 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r2208, swizzle_x(r21C3), 0x01));

         body.emit(assign(r2204, r2208, 0x01));

         ir_variable *const r2209 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r2209, bit_and(swizzle_y(r21C3), body.constant(1048575u)), 0x01));

         body.emit(assign(r2203, r2209, 0x01));

         ir_variable *const r220A = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r220A, body.constant(0u), 0x01));

         body.emit(assign(r2202, r220A, 0x01));

         ir_variable *const r220B = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r220B, body.constant(0u), 0x01));

         body.emit(assign(r2201, r220B, 0x01));

         ir_variable *const r220C = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r220D = rshift(swizzle_y(r21C3), body.constant(int(20)));
         ir_expression *const r220E = bit_and(r220D, body.constant(2047u));
         body.emit(assign(r220C, expr(ir_unop_u2i, r220E), 0x01));

         ir_variable *const r220F = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r220F, body.constant(int(1023)), 0x01));

         ir_variable *const r2210 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r2210, add(r220C, body.constant(int(-1023))), 0x01));

         body.emit(assign(r2200, r2210, 0x01));

         /* IF CONDITION */
         ir_expression *const r2212 = less(body.constant(int(0)), r2210);
         ir_if *f2211 = new(mem_ctx) ir_if(operand(r2212).val);
         exec_list *const f2211_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2211->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2214 = equal(r220C, body.constant(int(2047)));
            ir_if *f2213 = new(mem_ctx) ir_if(operand(r2214).val);
            exec_list *const f2213_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2213->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2216 = bit_or(r2209, swizzle_x(r21C3));
               ir_expression *const r2217 = nequal(r2216, body.constant(0u));
               ir_if *f2215 = new(mem_ctx) ir_if(operand(r2217).val);
               exec_list *const f2215_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2215->then_instructions;

                  ir_variable *const r2218 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2218, swizzle_x(r21C3), 0x01));

                  ir_variable *const r2219 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2219, body.constant(0u), 0x01));

                  ir_variable *const r221A = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r221B = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r221C = rshift(swizzle_y(r21C3), body.constant(int(19)));
                  ir_expression *const r221D = bit_and(r221C, body.constant(4095u));
                  ir_expression *const r221E = equal(r221D, body.constant(4094u));
                  ir_expression *const r221F = nequal(swizzle_x(r21C3), body.constant(0u));
                  ir_expression *const r2220 = bit_and(swizzle_y(r21C3), body.constant(524287u));
                  ir_expression *const r2221 = nequal(r2220, body.constant(0u));
                  ir_expression *const r2222 = logic_or(r221F, r2221);
                  body.emit(assign(r221B, logic_and(r221E, r2222), 0x01));

                  ir_variable *const r2223 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  body.emit(assign(r2223, body.constant(false), 0x01));

                  body.emit(assign(r2218, bit_or(swizzle_y(r21C3), body.constant(524288u)), 0x02));

                  body.emit(assign(r2219, body.constant(3220701184u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2225 = lshift(swizzle_y(r21C3), body.constant(int(1)));
                  ir_expression *const r2226 = lequal(body.constant(4292870144u), r2225);
                  ir_expression *const r2227 = nequal(swizzle_x(r21C3), body.constant(0u));
                  ir_expression *const r2228 = bit_and(swizzle_y(r21C3), body.constant(1048575u));
                  ir_expression *const r2229 = nequal(r2228, body.constant(0u));
                  ir_expression *const r222A = logic_or(r2227, r2229);
                  ir_expression *const r222B = logic_and(r2226, r222A);
                  ir_if *f2224 = new(mem_ctx) ir_if(operand(r222B).val);
                  exec_list *const f2224_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2224->then_instructions;

                     ir_variable *const r222C = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_constant *const r222E = body.constant(false);
                     ir_if *f222D = new(mem_ctx) ir_if(operand(r222E).val);
                     exec_list *const f222D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f222D->then_instructions;

                        body.emit(assign(r222C, r2219, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f222D->else_instructions;

                        body.emit(assign(r222C, r2218, 0x03));


                     body.instructions = f222D_parent_instructions;
                     body.emit(f222D);

                     /* END IF */

                     body.emit(assign(r221A, r222C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2224->else_instructions;

                     body.emit(assign(r221A, r2219, 0x03));


                  body.instructions = f2224_parent_instructions;
                  body.emit(f2224);

                  /* END IF */

                  body.emit(assign(r21FF, r221A, 0x03));

                  body.emit(assign(r21FE, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2215->else_instructions;

                  body.emit(assign(r21FF, r21C3, 0x03));

                  body.emit(assign(r21FE, body.constant(false), 0x01));


               body.instructions = f2215_parent_instructions;
               body.emit(f2215);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2213->else_instructions;

               /* IF CONDITION */
               ir_constant *const r2230 = body.constant(false);
               ir_if *f222F = new(mem_ctx) ir_if(operand(r2230).val);
               exec_list *const f222F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f222F->then_instructions;

                  body.emit(assign(r2200, add(r2210, body.constant(int(-1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f222F->else_instructions;

                  body.emit(assign(r2201, body.constant(1048576u), 0x01));


               body.instructions = f222F_parent_instructions;
               body.emit(f222F);

               /* END IF */

               ir_variable *const r2231 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2231, body.constant(0u), 0x01));

               ir_variable *const r2232 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2232);
               ir_variable *const r2233 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2233);
               ir_variable *const r2234 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2234);
               ir_variable *const r2235 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2236 = neg(r2200);
               body.emit(assign(r2235, bit_and(r2236, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2238 = equal(r2200, body.constant(int(0)));
               ir_if *f2237 = new(mem_ctx) ir_if(operand(r2238).val);
               exec_list *const f2237_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2237->then_instructions;

                  body.emit(assign(r2232, r2231, 0x01));

                  body.emit(assign(r2233, r220A, 0x01));

                  body.emit(assign(r2234, r2201, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2237->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r223A = less(r2200, body.constant(int(32)));
                  ir_if *f2239 = new(mem_ctx) ir_if(operand(r223A).val);
                  exec_list *const f2239_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2239->then_instructions;

                     body.emit(assign(r2232, body.constant(0u), 0x01));

                     ir_expression *const r223B = lshift(r2201, r2235);
                     body.emit(assign(r2233, bit_or(r223B, body.constant(0u)), 0x01));

                     body.emit(assign(r2234, rshift(r2201, r2200), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2239->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r223D = equal(r2200, body.constant(int(32)));
                     ir_if *f223C = new(mem_ctx) ir_if(operand(r223D).val);
                     exec_list *const f223C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f223C->then_instructions;

                        body.emit(assign(r2232, r220A, 0x01));

                        body.emit(assign(r2233, r2201, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f223C->else_instructions;

                        body.emit(assign(r2231, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r223F = less(r2200, body.constant(int(64)));
                        ir_if *f223E = new(mem_ctx) ir_if(operand(r223F).val);
                        exec_list *const f223E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f223E->then_instructions;

                           body.emit(assign(r2232, lshift(r2201, r2235), 0x01));

                           ir_expression *const r2240 = bit_and(r2200, body.constant(int(31)));
                           body.emit(assign(r2233, rshift(r2201, r2240), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f223E->else_instructions;

                           ir_variable *const r2241 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2243 = equal(r2200, body.constant(int(64)));
                           ir_if *f2242 = new(mem_ctx) ir_if(operand(r2243).val);
                           exec_list *const f2242_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2242->then_instructions;

                              body.emit(assign(r2241, r2201, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2242->else_instructions;

                              ir_expression *const r2244 = nequal(r2201, body.constant(0u));
                              ir_expression *const r2245 = expr(ir_unop_b2i, r2244);
                              body.emit(assign(r2241, expr(ir_unop_i2u, r2245), 0x01));


                           body.instructions = f2242_parent_instructions;
                           body.emit(f2242);

                           /* END IF */

                           body.emit(assign(r2232, r2241, 0x01));

                           body.emit(assign(r2233, body.constant(0u), 0x01));


                        body.instructions = f223E_parent_instructions;
                        body.emit(f223E);

                        /* END IF */


                     body.instructions = f223C_parent_instructions;
                     body.emit(f223C);

                     /* END IF */

                     body.emit(assign(r2234, body.constant(0u), 0x01));


                  body.instructions = f2239_parent_instructions;
                  body.emit(f2239);

                  /* END IF */

                  ir_expression *const r2246 = nequal(r2231, body.constant(0u));
                  ir_expression *const r2247 = expr(ir_unop_b2i, r2246);
                  ir_expression *const r2248 = expr(ir_unop_i2u, r2247);
                  body.emit(assign(r2232, bit_or(r2232, r2248), 0x01));


               body.instructions = f2237_parent_instructions;
               body.emit(f2237);

               /* END IF */

               body.emit(assign(r2201, r2234, 0x01));

               body.emit(assign(r2202, r2233, 0x01));

               body.emit(assign(r2206, r2232, 0x01));

               body.emit(assign(r2205, r220C, 0x01));


            body.instructions = f2213_parent_instructions;
            body.emit(f2213);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2211->else_instructions;

            /* IF CONDITION */
            ir_expression *const r224A = less(r2200, body.constant(int(0)));
            ir_if *f2249 = new(mem_ctx) ir_if(operand(r224A).val);
            exec_list *const f2249_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2249->then_instructions;

               /* IF CONDITION */
               ir_constant *const r224C = body.constant(false);
               ir_if *f224B = new(mem_ctx) ir_if(operand(r224C).val);
               exec_list *const f224B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f224B->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r224E = bit_or(r2201, r2202);
                  ir_expression *const r224F = nequal(r224E, body.constant(0u));
                  ir_if *f224D = new(mem_ctx) ir_if(operand(r224F).val);
                  exec_list *const f224D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f224D->then_instructions;

                     ir_variable *const r2250 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r2250, swizzle_x(r21C3), 0x01));

                     ir_variable *const r2251 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r2251, body.constant(0u), 0x01));

                     ir_variable *const r2252 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2253 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r2254 = rshift(swizzle_y(r21C3), body.constant(int(19)));
                     ir_expression *const r2255 = bit_and(r2254, body.constant(4095u));
                     ir_expression *const r2256 = equal(r2255, body.constant(4094u));
                     ir_expression *const r2257 = nequal(swizzle_x(r21C3), body.constant(0u));
                     ir_expression *const r2258 = bit_and(swizzle_y(r21C3), body.constant(524287u));
                     ir_expression *const r2259 = nequal(r2258, body.constant(0u));
                     ir_expression *const r225A = logic_or(r2257, r2259);
                     body.emit(assign(r2253, logic_and(r2256, r225A), 0x01));

                     ir_variable *const r225B = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r225B, body.constant(false), 0x01));

                     body.emit(assign(r2250, bit_or(swizzle_y(r21C3), body.constant(524288u)), 0x02));

                     body.emit(assign(r2251, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r225D = lshift(swizzle_y(r21C3), body.constant(int(1)));
                     ir_expression *const r225E = lequal(body.constant(4292870144u), r225D);
                     ir_expression *const r225F = nequal(swizzle_x(r21C3), body.constant(0u));
                     ir_expression *const r2260 = bit_and(swizzle_y(r21C3), body.constant(1048575u));
                     ir_expression *const r2261 = nequal(r2260, body.constant(0u));
                     ir_expression *const r2262 = logic_or(r225F, r2261);
                     ir_expression *const r2263 = logic_and(r225E, r2262);
                     ir_if *f225C = new(mem_ctx) ir_if(operand(r2263).val);
                     exec_list *const f225C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f225C->then_instructions;

                        ir_variable *const r2264 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r2266 = body.constant(false);
                        ir_if *f2265 = new(mem_ctx) ir_if(operand(r2266).val);
                        exec_list *const f2265_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2265->then_instructions;

                           body.emit(assign(r2264, r2251, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2265->else_instructions;

                           body.emit(assign(r2264, r2250, 0x03));


                        body.instructions = f2265_parent_instructions;
                        body.emit(f2265);

                        /* END IF */

                        body.emit(assign(r2252, r2264, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f225C->else_instructions;

                        body.emit(assign(r2252, r2251, 0x03));


                     body.instructions = f225C_parent_instructions;
                     body.emit(f225C);

                     /* END IF */

                     body.emit(assign(r21FF, r2252, 0x03));

                     body.emit(assign(r21FE, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f224D->else_instructions;

                     ir_variable *const r2267 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2267);
                     ir_expression *const r2268 = lshift(r21FA, body.constant(int(31)));
                     body.emit(assign(r2267, add(r2268, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2267, body.constant(0u), 0x01));

                     body.emit(assign(r21FF, r2267, 0x03));

                     body.emit(assign(r21FE, body.constant(false), 0x01));


                  body.instructions = f224D_parent_instructions;
                  body.emit(f224D);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f224B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r226A = equal(r220C, body.constant(int(0)));
                  ir_if *f2269 = new(mem_ctx) ir_if(operand(r226A).val);
                  exec_list *const f2269_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2269->then_instructions;

                     body.emit(assign(r2200, add(r2200, body.constant(int(1))), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2269->else_instructions;

                     body.emit(assign(r2203, bit_or(r2209, body.constant(1048576u)), 0x01));


                  body.instructions = f2269_parent_instructions;
                  body.emit(f2269);

                  /* END IF */

                  ir_variable *const r226B = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r226B, body.constant(0u), 0x01));

                  ir_variable *const r226C = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r226C, neg(r2200), 0x01));

                  ir_variable *const r226D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r226D);
                  ir_variable *const r226E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r226E);
                  ir_variable *const r226F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r226F);
                  ir_variable *const r2270 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2271 = neg(r226C);
                  body.emit(assign(r2270, bit_and(r2271, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2273 = equal(r226C, body.constant(int(0)));
                  ir_if *f2272 = new(mem_ctx) ir_if(operand(r2273).val);
                  exec_list *const f2272_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2272->then_instructions;

                     body.emit(assign(r226D, r226B, 0x01));

                     body.emit(assign(r226E, r2208, 0x01));

                     body.emit(assign(r226F, r2203, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2272->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2275 = less(r226C, body.constant(int(32)));
                     ir_if *f2274 = new(mem_ctx) ir_if(operand(r2275).val);
                     exec_list *const f2274_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2274->then_instructions;

                        body.emit(assign(r226D, lshift(swizzle_x(r21C3), r2270), 0x01));

                        ir_expression *const r2276 = lshift(r2203, r2270);
                        ir_expression *const r2277 = rshift(swizzle_x(r21C3), r226C);
                        body.emit(assign(r226E, bit_or(r2276, r2277), 0x01));

                        body.emit(assign(r226F, rshift(r2203, r226C), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2274->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2279 = equal(r226C, body.constant(int(32)));
                        ir_if *f2278 = new(mem_ctx) ir_if(operand(r2279).val);
                        exec_list *const f2278_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2278->then_instructions;

                           body.emit(assign(r226D, r2208, 0x01));

                           body.emit(assign(r226E, r2203, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2278->else_instructions;

                           body.emit(assign(r226B, bit_or(body.constant(0u), swizzle_x(r21C3)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r227B = less(r226C, body.constant(int(64)));
                           ir_if *f227A = new(mem_ctx) ir_if(operand(r227B).val);
                           exec_list *const f227A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f227A->then_instructions;

                              body.emit(assign(r226D, lshift(r2203, r2270), 0x01));

                              ir_expression *const r227C = bit_and(r226C, body.constant(int(31)));
                              body.emit(assign(r226E, rshift(r2203, r227C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f227A->else_instructions;

                              ir_variable *const r227D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r227F = equal(r226C, body.constant(int(64)));
                              ir_if *f227E = new(mem_ctx) ir_if(operand(r227F).val);
                              exec_list *const f227E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f227E->then_instructions;

                                 body.emit(assign(r227D, r2203, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f227E->else_instructions;

                                 ir_expression *const r2280 = nequal(r2203, body.constant(0u));
                                 ir_expression *const r2281 = expr(ir_unop_b2i, r2280);
                                 body.emit(assign(r227D, expr(ir_unop_i2u, r2281), 0x01));


                              body.instructions = f227E_parent_instructions;
                              body.emit(f227E);

                              /* END IF */

                              body.emit(assign(r226D, r227D, 0x01));

                              body.emit(assign(r226E, body.constant(0u), 0x01));


                           body.instructions = f227A_parent_instructions;
                           body.emit(f227A);

                           /* END IF */


                        body.instructions = f2278_parent_instructions;
                        body.emit(f2278);

                        /* END IF */

                        body.emit(assign(r226F, body.constant(0u), 0x01));


                     body.instructions = f2274_parent_instructions;
                     body.emit(f2274);

                     /* END IF */

                     ir_expression *const r2282 = nequal(r226B, body.constant(0u));
                     ir_expression *const r2283 = expr(ir_unop_b2i, r2282);
                     ir_expression *const r2284 = expr(ir_unop_i2u, r2283);
                     body.emit(assign(r226D, bit_or(r226D, r2284), 0x01));


                  body.instructions = f2272_parent_instructions;
                  body.emit(f2272);

                  /* END IF */

                  body.emit(assign(r2203, r226F, 0x01));

                  body.emit(assign(r2204, r226E, 0x01));

                  body.emit(assign(r2206, r226D, 0x01));

                  body.emit(assign(r2205, r220F, 0x01));


               body.instructions = f224B_parent_instructions;
               body.emit(f224B);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2249->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2286 = equal(r220C, body.constant(int(2047)));
               ir_if *f2285 = new(mem_ctx) ir_if(operand(r2286).val);
               exec_list *const f2285_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2285->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2288 = bit_or(r2203, r2204);
                  ir_expression *const r2289 = bit_or(r2201, r2202);
                  ir_expression *const r228A = bit_or(r2288, r2289);
                  ir_expression *const r228B = nequal(r228A, body.constant(0u));
                  ir_if *f2287 = new(mem_ctx) ir_if(operand(r228B).val);
                  exec_list *const f2287_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2287->then_instructions;

                     ir_variable *const r228C = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r228C, swizzle_x(r21C3), 0x01));

                     ir_variable *const r228D = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r228D, body.constant(0u), 0x01));

                     ir_variable *const r228E = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r228F = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r2290 = rshift(swizzle_y(r21C3), body.constant(int(19)));
                     ir_expression *const r2291 = bit_and(r2290, body.constant(4095u));
                     ir_expression *const r2292 = equal(r2291, body.constant(4094u));
                     ir_expression *const r2293 = nequal(swizzle_x(r21C3), body.constant(0u));
                     ir_expression *const r2294 = bit_and(swizzle_y(r21C3), body.constant(524287u));
                     ir_expression *const r2295 = nequal(r2294, body.constant(0u));
                     ir_expression *const r2296 = logic_or(r2293, r2295);
                     body.emit(assign(r228F, logic_and(r2292, r2296), 0x01));

                     ir_variable *const r2297 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r2297, body.constant(false), 0x01));

                     body.emit(assign(r228C, bit_or(swizzle_y(r21C3), body.constant(524288u)), 0x02));

                     body.emit(assign(r228D, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r2299 = lshift(swizzle_y(r21C3), body.constant(int(1)));
                     ir_expression *const r229A = lequal(body.constant(4292870144u), r2299);
                     ir_expression *const r229B = nequal(swizzle_x(r21C3), body.constant(0u));
                     ir_expression *const r229C = bit_and(swizzle_y(r21C3), body.constant(1048575u));
                     ir_expression *const r229D = nequal(r229C, body.constant(0u));
                     ir_expression *const r229E = logic_or(r229B, r229D);
                     ir_expression *const r229F = logic_and(r229A, r229E);
                     ir_if *f2298 = new(mem_ctx) ir_if(operand(r229F).val);
                     exec_list *const f2298_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2298->then_instructions;

                        ir_variable *const r22A0 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r22A2 = body.constant(false);
                        ir_if *f22A1 = new(mem_ctx) ir_if(operand(r22A2).val);
                        exec_list *const f22A1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22A1->then_instructions;

                           body.emit(assign(r22A0, r228D, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22A1->else_instructions;

                           body.emit(assign(r22A0, r228C, 0x03));


                        body.instructions = f22A1_parent_instructions;
                        body.emit(f22A1);

                        /* END IF */

                        body.emit(assign(r228E, r22A0, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2298->else_instructions;

                        body.emit(assign(r228E, r228D, 0x03));


                     body.instructions = f2298_parent_instructions;
                     body.emit(f2298);

                     /* END IF */

                     body.emit(assign(r21FF, r228E, 0x03));

                     body.emit(assign(r21FE, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2287->else_instructions;

                     body.emit(assign(r21FF, r21C3, 0x03));

                     body.emit(assign(r21FE, body.constant(false), 0x01));


                  body.instructions = f2287_parent_instructions;
                  body.emit(f2287);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2285->else_instructions;

                  ir_variable *const r22A3 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r22A4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r22A4, add(r2204, r2202), 0x01));

                  ir_expression *const r22A5 = add(r2203, r2201);
                  ir_expression *const r22A6 = less(r22A4, r2204);
                  ir_expression *const r22A7 = expr(ir_unop_b2i, r22A6);
                  ir_expression *const r22A8 = expr(ir_unop_i2u, r22A7);
                  body.emit(assign(r22A3, add(r22A5, r22A8), 0x01));

                  body.emit(assign(r2207, r22A3, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r22AA = equal(r220C, body.constant(int(0)));
                  ir_if *f22A9 = new(mem_ctx) ir_if(operand(r22AA).val);
                  exec_list *const f22A9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f22A9->then_instructions;

                     ir_variable *const r22AB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r22AB);
                     ir_expression *const r22AC = lshift(r21FA, body.constant(int(31)));
                     body.emit(assign(r22AB, add(r22AC, r22A3), 0x02));

                     body.emit(assign(r22AB, r22A4, 0x01));

                     body.emit(assign(r21FF, r22AB, 0x03));

                     body.emit(assign(r21FE, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f22A9->else_instructions;

                     body.emit(assign(r2207, bit_or(r22A3, body.constant(2097152u)), 0x01));

                     body.emit(assign(r2205, r220C, 0x01));

                     ir_variable *const r22AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r22AD);
                     ir_variable *const r22AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r22AE);
                     ir_variable *const r22AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r22AF);
                     body.emit(assign(r22AD, lshift(r22A4, body.constant(int(31))), 0x01));

                     ir_expression *const r22B0 = lshift(r2207, body.constant(int(31)));
                     ir_expression *const r22B1 = rshift(r22A4, body.constant(int(1)));
                     body.emit(assign(r22AE, bit_or(r22B0, r22B1), 0x01));

                     body.emit(assign(r22AF, rshift(r2207, body.constant(int(1))), 0x01));

                     body.emit(assign(r22AD, bit_or(r22AD, body.constant(0u)), 0x01));

                     body.emit(assign(r2207, r22AF, 0x01));

                     body.emit(assign(r2206, r22AD, 0x01));

                     ir_variable *const r22B2 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r22B2, r220C, 0x01));

                     ir_variable *const r22B3 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r22B3, r22AF, 0x01));

                     ir_variable *const r22B4 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r22B4, r22AE, 0x01));

                     ir_variable *const r22B5 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r22B5, r22AD, 0x01));

                     ir_variable *const r22B6 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r22B6, body.constant(true), 0x01));

                     ir_variable *const r22B7 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r22B8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r22B8);
                     ir_expression *const r22B9 = expr(ir_unop_u2i, r22AD);
                     body.emit(assign(r22B8, less(r22B9, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r22BB = lequal(body.constant(int(2045)), r220C);
                     ir_if *f22BA = new(mem_ctx) ir_if(operand(r22BB).val);
                     exec_list *const f22BA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22BA->then_instructions;

                        ir_variable *const r22BC = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r22BE = less(body.constant(int(2045)), r220C);
                        ir_if *f22BD = new(mem_ctx) ir_if(operand(r22BE).val);
                        exec_list *const f22BD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22BD->then_instructions;

                           body.emit(assign(r22BC, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22BD->else_instructions;

                           ir_variable *const r22BF = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r22C1 = equal(r220C, body.constant(int(2045)));
                           ir_if *f22C0 = new(mem_ctx) ir_if(operand(r22C1).val);
                           exec_list *const f22C0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f22C0->then_instructions;

                              ir_expression *const r22C2 = equal(body.constant(2097151u), r22AF);
                              ir_expression *const r22C3 = equal(body.constant(4294967295u), r22AE);
                              body.emit(assign(r22BF, logic_and(r22C2, r22C3), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f22C0->else_instructions;

                              body.emit(assign(r22BF, body.constant(false), 0x01));


                           body.instructions = f22C0_parent_instructions;
                           body.emit(f22C0);

                           /* END IF */

                           body.emit(assign(r22BC, logic_and(r22BF, r22B8), 0x01));


                        body.instructions = f22BD_parent_instructions;
                        body.emit(f22BD);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f22C4 = new(mem_ctx) ir_if(operand(r22BC).val);
                        exec_list *const f22C4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22C4->then_instructions;

                           ir_variable *const r22C5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r22C5);
                           ir_expression *const r22C6 = lshift(r21FA, body.constant(int(31)));
                           body.emit(assign(r22C5, add(r22C6, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r22C5, body.constant(0u), 0x01));

                           body.emit(assign(r22B7, r22C5, 0x03));

                           body.emit(assign(r22B6, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22C4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r22C8 = less(r220C, body.constant(int(0)));
                           ir_if *f22C7 = new(mem_ctx) ir_if(operand(r22C8).val);
                           exec_list *const f22C7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f22C7->then_instructions;

                              ir_variable *const r22C9 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r22C9, r22AD, 0x01));

                              ir_variable *const r22CA = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r22CA, neg(r220C), 0x01));

                              ir_variable *const r22CB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r22CB);
                              ir_variable *const r22CC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r22CC);
                              ir_variable *const r22CD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r22CD);
                              ir_variable *const r22CE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r22CF = neg(r22CA);
                              body.emit(assign(r22CE, bit_and(r22CF, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r22D1 = equal(r22CA, body.constant(int(0)));
                              ir_if *f22D0 = new(mem_ctx) ir_if(operand(r22D1).val);
                              exec_list *const f22D0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f22D0->then_instructions;

                                 body.emit(assign(r22CB, r22AD, 0x01));

                                 body.emit(assign(r22CC, r22AE, 0x01));

                                 body.emit(assign(r22CD, r22AF, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f22D0->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r22D3 = less(r22CA, body.constant(int(32)));
                                 ir_if *f22D2 = new(mem_ctx) ir_if(operand(r22D3).val);
                                 exec_list *const f22D2_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f22D2->then_instructions;

                                    body.emit(assign(r22CB, lshift(r22AE, r22CE), 0x01));

                                    ir_expression *const r22D4 = lshift(r22AF, r22CE);
                                    ir_expression *const r22D5 = rshift(r22AE, r22CA);
                                    body.emit(assign(r22CC, bit_or(r22D4, r22D5), 0x01));

                                    body.emit(assign(r22CD, rshift(r22AF, r22CA), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f22D2->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r22D7 = equal(r22CA, body.constant(int(32)));
                                    ir_if *f22D6 = new(mem_ctx) ir_if(operand(r22D7).val);
                                    exec_list *const f22D6_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f22D6->then_instructions;

                                       body.emit(assign(r22CB, r22AE, 0x01));

                                       body.emit(assign(r22CC, r22AF, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f22D6->else_instructions;

                                       body.emit(assign(r22C9, bit_or(r22AD, r22AE), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r22D9 = less(r22CA, body.constant(int(64)));
                                       ir_if *f22D8 = new(mem_ctx) ir_if(operand(r22D9).val);
                                       exec_list *const f22D8_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f22D8->then_instructions;

                                          body.emit(assign(r22CB, lshift(r22AF, r22CE), 0x01));

                                          ir_expression *const r22DA = bit_and(r22CA, body.constant(int(31)));
                                          body.emit(assign(r22CC, rshift(r22AF, r22DA), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f22D8->else_instructions;

                                          ir_variable *const r22DB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r22DD = equal(r22CA, body.constant(int(64)));
                                          ir_if *f22DC = new(mem_ctx) ir_if(operand(r22DD).val);
                                          exec_list *const f22DC_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f22DC->then_instructions;

                                             body.emit(assign(r22DB, r22AF, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f22DC->else_instructions;

                                             ir_expression *const r22DE = nequal(r22AF, body.constant(0u));
                                             ir_expression *const r22DF = expr(ir_unop_b2i, r22DE);
                                             body.emit(assign(r22DB, expr(ir_unop_i2u, r22DF), 0x01));


                                          body.instructions = f22DC_parent_instructions;
                                          body.emit(f22DC);

                                          /* END IF */

                                          body.emit(assign(r22CB, r22DB, 0x01));

                                          body.emit(assign(r22CC, body.constant(0u), 0x01));


                                       body.instructions = f22D8_parent_instructions;
                                       body.emit(f22D8);

                                       /* END IF */


                                    body.instructions = f22D6_parent_instructions;
                                    body.emit(f22D6);

                                    /* END IF */

                                    body.emit(assign(r22CD, body.constant(0u), 0x01));


                                 body.instructions = f22D2_parent_instructions;
                                 body.emit(f22D2);

                                 /* END IF */

                                 ir_expression *const r22E0 = nequal(r22C9, body.constant(0u));
                                 ir_expression *const r22E1 = expr(ir_unop_b2i, r22E0);
                                 ir_expression *const r22E2 = expr(ir_unop_i2u, r22E1);
                                 body.emit(assign(r22CB, bit_or(r22CB, r22E2), 0x01));


                              body.instructions = f22D0_parent_instructions;
                              body.emit(f22D0);

                              /* END IF */

                              body.emit(assign(r22B3, r22CD, 0x01));

                              body.emit(assign(r22B4, r22CC, 0x01));

                              body.emit(assign(r22B5, r22CB, 0x01));

                              body.emit(assign(r22B2, body.constant(int(0)), 0x01));

                              body.emit(assign(r22B8, less(r22CB, body.constant(0u)), 0x01));


                           body.instructions = f22C7_parent_instructions;
                           body.emit(f22C7);

                           /* END IF */


                        body.instructions = f22C4_parent_instructions;
                        body.emit(f22C4);

                        /* END IF */


                     body.instructions = f22BA_parent_instructions;
                     body.emit(f22BA);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f22E3 = new(mem_ctx) ir_if(operand(r22B6).val);
                     exec_list *const f22E3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22E3->then_instructions;

                        /* IF CONDITION */
                        ir_if *f22E4 = new(mem_ctx) ir_if(operand(r22B8).val);
                        exec_list *const f22E4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22E4->then_instructions;

                           ir_variable *const r22E5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r22E5, add(r22B4, body.constant(1u)), 0x01));

                           ir_expression *const r22E6 = less(r22E5, r22B4);
                           ir_expression *const r22E7 = expr(ir_unop_b2i, r22E6);
                           ir_expression *const r22E8 = expr(ir_unop_i2u, r22E7);
                           body.emit(assign(r22B3, add(r22B3, r22E8), 0x01));

                           ir_expression *const r22E9 = equal(r22B5, body.constant(0u));
                           ir_expression *const r22EA = expr(ir_unop_b2i, r22E9);
                           ir_expression *const r22EB = expr(ir_unop_i2u, r22EA);
                           ir_expression *const r22EC = add(r22B5, r22EB);
                           ir_expression *const r22ED = bit_and(r22EC, body.constant(1u));
                           ir_expression *const r22EE = expr(ir_unop_bit_not, r22ED);
                           body.emit(assign(r22B4, bit_and(r22E5, r22EE), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22E4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r22F0 = bit_or(r22B3, r22B4);
                           ir_expression *const r22F1 = equal(r22F0, body.constant(0u));
                           ir_if *f22EF = new(mem_ctx) ir_if(operand(r22F1).val);
                           exec_list *const f22EF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f22EF->then_instructions;

                              body.emit(assign(r22B2, body.constant(int(0)), 0x01));


                           body.instructions = f22EF_parent_instructions;
                           body.emit(f22EF);

                           /* END IF */


                        body.instructions = f22E4_parent_instructions;
                        body.emit(f22E4);

                        /* END IF */

                        ir_variable *const r22F2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r22F2);
                        ir_expression *const r22F3 = lshift(r21FA, body.constant(int(31)));
                        ir_expression *const r22F4 = expr(ir_unop_i2u, r22B2);
                        ir_expression *const r22F5 = lshift(r22F4, body.constant(int(20)));
                        ir_expression *const r22F6 = add(r22F3, r22F5);
                        body.emit(assign(r22F2, add(r22F6, r22B3), 0x02));

                        body.emit(assign(r22F2, r22B4, 0x01));

                        body.emit(assign(r22B7, r22F2, 0x03));

                        body.emit(assign(r22B6, body.constant(false), 0x01));


                     body.instructions = f22E3_parent_instructions;
                     body.emit(f22E3);

                     /* END IF */

                     body.emit(assign(r21FF, r22B7, 0x03));

                     body.emit(assign(r21FE, body.constant(false), 0x01));


                  body.instructions = f22A9_parent_instructions;
                  body.emit(f22A9);

                  /* END IF */


               body.instructions = f2285_parent_instructions;
               body.emit(f2285);

               /* END IF */


            body.instructions = f2249_parent_instructions;
            body.emit(f2249);

            /* END IF */


         body.instructions = f2211_parent_instructions;
         body.emit(f2211);

         /* END IF */

         /* IF CONDITION */
         ir_if *f22F7 = new(mem_ctx) ir_if(operand(r21FE).val);
         exec_list *const f22F7_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f22F7->then_instructions;

            body.emit(assign(r2203, bit_or(r2203, body.constant(1048576u)), 0x01));

            ir_variable *const r22F8 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r22F9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r22F9, add(r2204, r2202), 0x01));

            ir_expression *const r22FA = add(r2203, r2201);
            ir_expression *const r22FB = less(r22F9, r2204);
            ir_expression *const r22FC = expr(ir_unop_b2i, r22FB);
            ir_expression *const r22FD = expr(ir_unop_i2u, r22FC);
            body.emit(assign(r22F8, add(r22FA, r22FD), 0x01));

            body.emit(assign(r2207, r22F8, 0x01));

            body.emit(assign(r2205, add(r2205, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r22FF = less(r22F8, body.constant(2097152u));
            ir_if *f22FE = new(mem_ctx) ir_if(operand(r22FF).val);
            exec_list *const f22FE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f22FE->then_instructions;

               ir_variable *const r2300 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2300, r2205, 0x01));

               ir_variable *const r2301 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2301, r22F8, 0x01));

               ir_variable *const r2302 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2302, r22F9, 0x01));

               ir_variable *const r2303 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2303, r2206, 0x01));

               ir_variable *const r2304 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2304, body.constant(true), 0x01));

               ir_variable *const r2305 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2306 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2306);
               ir_expression *const r2307 = expr(ir_unop_u2i, r2206);
               body.emit(assign(r2306, less(r2307, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2309 = lequal(body.constant(int(2045)), r2205);
               ir_if *f2308 = new(mem_ctx) ir_if(operand(r2309).val);
               exec_list *const f2308_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2308->then_instructions;

                  ir_variable *const r230A = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r230C = less(body.constant(int(2045)), r2205);
                  ir_if *f230B = new(mem_ctx) ir_if(operand(r230C).val);
                  exec_list *const f230B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f230B->then_instructions;

                     body.emit(assign(r230A, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f230B->else_instructions;

                     ir_variable *const r230D = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r230F = equal(r2205, body.constant(int(2045)));
                     ir_if *f230E = new(mem_ctx) ir_if(operand(r230F).val);
                     exec_list *const f230E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f230E->then_instructions;

                        ir_expression *const r2310 = equal(body.constant(2097151u), r22F8);
                        ir_expression *const r2311 = equal(body.constant(4294967295u), r22F9);
                        body.emit(assign(r230D, logic_and(r2310, r2311), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f230E->else_instructions;

                        body.emit(assign(r230D, body.constant(false), 0x01));


                     body.instructions = f230E_parent_instructions;
                     body.emit(f230E);

                     /* END IF */

                     body.emit(assign(r230A, logic_and(r230D, r2306), 0x01));


                  body.instructions = f230B_parent_instructions;
                  body.emit(f230B);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2312 = new(mem_ctx) ir_if(operand(r230A).val);
                  exec_list *const f2312_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2312->then_instructions;

                     ir_variable *const r2313 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2313);
                     ir_expression *const r2314 = lshift(r21FA, body.constant(int(31)));
                     body.emit(assign(r2313, add(r2314, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2313, body.constant(0u), 0x01));

                     body.emit(assign(r2305, r2313, 0x03));

                     body.emit(assign(r2304, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2312->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2316 = less(r2205, body.constant(int(0)));
                     ir_if *f2315 = new(mem_ctx) ir_if(operand(r2316).val);
                     exec_list *const f2315_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2315->then_instructions;

                        ir_variable *const r2317 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2317, r2206, 0x01));

                        ir_variable *const r2318 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2318, neg(r2205), 0x01));

                        ir_variable *const r2319 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2319);
                        ir_variable *const r231A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r231A);
                        ir_variable *const r231B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r231B);
                        ir_variable *const r231C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r231D = neg(r2318);
                        body.emit(assign(r231C, bit_and(r231D, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r231F = equal(r2318, body.constant(int(0)));
                        ir_if *f231E = new(mem_ctx) ir_if(operand(r231F).val);
                        exec_list *const f231E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f231E->then_instructions;

                           body.emit(assign(r2319, r2206, 0x01));

                           body.emit(assign(r231A, r22F9, 0x01));

                           body.emit(assign(r231B, r22F8, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f231E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2321 = less(r2318, body.constant(int(32)));
                           ir_if *f2320 = new(mem_ctx) ir_if(operand(r2321).val);
                           exec_list *const f2320_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2320->then_instructions;

                              body.emit(assign(r2319, lshift(r22F9, r231C), 0x01));

                              ir_expression *const r2322 = lshift(r22F8, r231C);
                              ir_expression *const r2323 = rshift(r22F9, r2318);
                              body.emit(assign(r231A, bit_or(r2322, r2323), 0x01));

                              body.emit(assign(r231B, rshift(r22F8, r2318), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2320->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2325 = equal(r2318, body.constant(int(32)));
                              ir_if *f2324 = new(mem_ctx) ir_if(operand(r2325).val);
                              exec_list *const f2324_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2324->then_instructions;

                                 body.emit(assign(r2319, r22F9, 0x01));

                                 body.emit(assign(r231A, r22F8, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2324->else_instructions;

                                 body.emit(assign(r2317, bit_or(r2206, r22F9), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2327 = less(r2318, body.constant(int(64)));
                                 ir_if *f2326 = new(mem_ctx) ir_if(operand(r2327).val);
                                 exec_list *const f2326_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2326->then_instructions;

                                    body.emit(assign(r2319, lshift(r22F8, r231C), 0x01));

                                    ir_expression *const r2328 = bit_and(r2318, body.constant(int(31)));
                                    body.emit(assign(r231A, rshift(r22F8, r2328), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2326->else_instructions;

                                    ir_variable *const r2329 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r232B = equal(r2318, body.constant(int(64)));
                                    ir_if *f232A = new(mem_ctx) ir_if(operand(r232B).val);
                                    exec_list *const f232A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f232A->then_instructions;

                                       body.emit(assign(r2329, r22F8, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f232A->else_instructions;

                                       ir_expression *const r232C = nequal(r22F8, body.constant(0u));
                                       ir_expression *const r232D = expr(ir_unop_b2i, r232C);
                                       body.emit(assign(r2329, expr(ir_unop_i2u, r232D), 0x01));


                                    body.instructions = f232A_parent_instructions;
                                    body.emit(f232A);

                                    /* END IF */

                                    body.emit(assign(r2319, r2329, 0x01));

                                    body.emit(assign(r231A, body.constant(0u), 0x01));


                                 body.instructions = f2326_parent_instructions;
                                 body.emit(f2326);

                                 /* END IF */


                              body.instructions = f2324_parent_instructions;
                              body.emit(f2324);

                              /* END IF */

                              body.emit(assign(r231B, body.constant(0u), 0x01));


                           body.instructions = f2320_parent_instructions;
                           body.emit(f2320);

                           /* END IF */

                           ir_expression *const r232E = nequal(r2317, body.constant(0u));
                           ir_expression *const r232F = expr(ir_unop_b2i, r232E);
                           ir_expression *const r2330 = expr(ir_unop_i2u, r232F);
                           body.emit(assign(r2319, bit_or(r2319, r2330), 0x01));


                        body.instructions = f231E_parent_instructions;
                        body.emit(f231E);

                        /* END IF */

                        body.emit(assign(r2301, r231B, 0x01));

                        body.emit(assign(r2302, r231A, 0x01));

                        body.emit(assign(r2303, r2319, 0x01));

                        body.emit(assign(r2300, body.constant(int(0)), 0x01));

                        body.emit(assign(r2306, less(r2319, body.constant(0u)), 0x01));


                     body.instructions = f2315_parent_instructions;
                     body.emit(f2315);

                     /* END IF */


                  body.instructions = f2312_parent_instructions;
                  body.emit(f2312);

                  /* END IF */


               body.instructions = f2308_parent_instructions;
               body.emit(f2308);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2331 = new(mem_ctx) ir_if(operand(r2304).val);
               exec_list *const f2331_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2331->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2332 = new(mem_ctx) ir_if(operand(r2306).val);
                  exec_list *const f2332_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2332->then_instructions;

                     ir_variable *const r2333 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2333, add(r2302, body.constant(1u)), 0x01));

                     ir_expression *const r2334 = less(r2333, r2302);
                     ir_expression *const r2335 = expr(ir_unop_b2i, r2334);
                     ir_expression *const r2336 = expr(ir_unop_i2u, r2335);
                     body.emit(assign(r2301, add(r2301, r2336), 0x01));

                     ir_expression *const r2337 = equal(r2303, body.constant(0u));
                     ir_expression *const r2338 = expr(ir_unop_b2i, r2337);
                     ir_expression *const r2339 = expr(ir_unop_i2u, r2338);
                     ir_expression *const r233A = add(r2303, r2339);
                     ir_expression *const r233B = bit_and(r233A, body.constant(1u));
                     ir_expression *const r233C = expr(ir_unop_bit_not, r233B);
                     body.emit(assign(r2302, bit_and(r2333, r233C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2332->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r233E = bit_or(r2301, r2302);
                     ir_expression *const r233F = equal(r233E, body.constant(0u));
                     ir_if *f233D = new(mem_ctx) ir_if(operand(r233F).val);
                     exec_list *const f233D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f233D->then_instructions;

                        body.emit(assign(r2300, body.constant(int(0)), 0x01));


                     body.instructions = f233D_parent_instructions;
                     body.emit(f233D);

                     /* END IF */


                  body.instructions = f2332_parent_instructions;
                  body.emit(f2332);

                  /* END IF */

                  ir_variable *const r2340 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2340);
                  ir_expression *const r2341 = lshift(r21FA, body.constant(int(31)));
                  ir_expression *const r2342 = expr(ir_unop_i2u, r2300);
                  ir_expression *const r2343 = lshift(r2342, body.constant(int(20)));
                  ir_expression *const r2344 = add(r2341, r2343);
                  body.emit(assign(r2340, add(r2344, r2301), 0x02));

                  body.emit(assign(r2340, r2302, 0x01));

                  body.emit(assign(r2305, r2340, 0x03));

                  body.emit(assign(r2304, body.constant(false), 0x01));


               body.instructions = f2331_parent_instructions;
               body.emit(f2331);

               /* END IF */

               body.emit(assign(r21FF, r2305, 0x03));

               body.emit(assign(r21FE, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f22FE->else_instructions;

               body.emit(assign(r2205, add(r2205, body.constant(int(1))), 0x01));

               ir_variable *const r2345 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2345);
               ir_variable *const r2346 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2346);
               ir_variable *const r2347 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2347);
               body.emit(assign(r2345, lshift(r22F9, body.constant(int(31))), 0x01));

               ir_expression *const r2348 = lshift(r22F8, body.constant(int(31)));
               ir_expression *const r2349 = rshift(r22F9, body.constant(int(1)));
               body.emit(assign(r2346, bit_or(r2348, r2349), 0x01));

               body.emit(assign(r2347, rshift(r22F8, body.constant(int(1))), 0x01));

               ir_expression *const r234A = nequal(r2206, body.constant(0u));
               ir_expression *const r234B = expr(ir_unop_b2i, r234A);
               ir_expression *const r234C = expr(ir_unop_i2u, r234B);
               body.emit(assign(r2345, bit_or(r2345, r234C), 0x01));

               body.emit(assign(r2207, r2347, 0x01));

               body.emit(assign(r2206, r2345, 0x01));

               ir_variable *const r234D = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r234D, r2205, 0x01));

               ir_variable *const r234E = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r234E, r2347, 0x01));

               ir_variable *const r234F = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r234F, r2346, 0x01));

               ir_variable *const r2350 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2350, r2345, 0x01));

               ir_variable *const r2351 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2351, body.constant(true), 0x01));

               ir_variable *const r2352 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2353 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2353);
               ir_expression *const r2354 = expr(ir_unop_u2i, r2345);
               body.emit(assign(r2353, less(r2354, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2356 = lequal(body.constant(int(2045)), r2205);
               ir_if *f2355 = new(mem_ctx) ir_if(operand(r2356).val);
               exec_list *const f2355_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2355->then_instructions;

                  ir_variable *const r2357 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2359 = less(body.constant(int(2045)), r2205);
                  ir_if *f2358 = new(mem_ctx) ir_if(operand(r2359).val);
                  exec_list *const f2358_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2358->then_instructions;

                     body.emit(assign(r2357, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2358->else_instructions;

                     ir_variable *const r235A = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r235C = equal(r2205, body.constant(int(2045)));
                     ir_if *f235B = new(mem_ctx) ir_if(operand(r235C).val);
                     exec_list *const f235B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f235B->then_instructions;

                        ir_expression *const r235D = equal(body.constant(2097151u), r2347);
                        ir_expression *const r235E = equal(body.constant(4294967295u), r2346);
                        body.emit(assign(r235A, logic_and(r235D, r235E), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f235B->else_instructions;

                        body.emit(assign(r235A, body.constant(false), 0x01));


                     body.instructions = f235B_parent_instructions;
                     body.emit(f235B);

                     /* END IF */

                     body.emit(assign(r2357, logic_and(r235A, r2353), 0x01));


                  body.instructions = f2358_parent_instructions;
                  body.emit(f2358);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f235F = new(mem_ctx) ir_if(operand(r2357).val);
                  exec_list *const f235F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f235F->then_instructions;

                     ir_variable *const r2360 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2360);
                     ir_expression *const r2361 = lshift(r21FA, body.constant(int(31)));
                     body.emit(assign(r2360, add(r2361, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2360, body.constant(0u), 0x01));

                     body.emit(assign(r2352, r2360, 0x03));

                     body.emit(assign(r2351, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f235F->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2363 = less(r2205, body.constant(int(0)));
                     ir_if *f2362 = new(mem_ctx) ir_if(operand(r2363).val);
                     exec_list *const f2362_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2362->then_instructions;

                        ir_variable *const r2364 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2364, r2345, 0x01));

                        ir_variable *const r2365 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2365, neg(r2205), 0x01));

                        ir_variable *const r2366 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2366);
                        ir_variable *const r2367 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2367);
                        ir_variable *const r2368 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2368);
                        ir_variable *const r2369 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r236A = neg(r2365);
                        body.emit(assign(r2369, bit_and(r236A, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r236C = equal(r2365, body.constant(int(0)));
                        ir_if *f236B = new(mem_ctx) ir_if(operand(r236C).val);
                        exec_list *const f236B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f236B->then_instructions;

                           body.emit(assign(r2366, r2345, 0x01));

                           body.emit(assign(r2367, r2346, 0x01));

                           body.emit(assign(r2368, r2347, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f236B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r236E = less(r2365, body.constant(int(32)));
                           ir_if *f236D = new(mem_ctx) ir_if(operand(r236E).val);
                           exec_list *const f236D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f236D->then_instructions;

                              body.emit(assign(r2366, lshift(r2346, r2369), 0x01));

                              ir_expression *const r236F = lshift(r2347, r2369);
                              ir_expression *const r2370 = rshift(r2346, r2365);
                              body.emit(assign(r2367, bit_or(r236F, r2370), 0x01));

                              body.emit(assign(r2368, rshift(r2347, r2365), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f236D->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2372 = equal(r2365, body.constant(int(32)));
                              ir_if *f2371 = new(mem_ctx) ir_if(operand(r2372).val);
                              exec_list *const f2371_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2371->then_instructions;

                                 body.emit(assign(r2366, r2346, 0x01));

                                 body.emit(assign(r2367, r2347, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2371->else_instructions;

                                 body.emit(assign(r2364, bit_or(r2345, r2346), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2374 = less(r2365, body.constant(int(64)));
                                 ir_if *f2373 = new(mem_ctx) ir_if(operand(r2374).val);
                                 exec_list *const f2373_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2373->then_instructions;

                                    body.emit(assign(r2366, lshift(r2347, r2369), 0x01));

                                    ir_expression *const r2375 = bit_and(r2365, body.constant(int(31)));
                                    body.emit(assign(r2367, rshift(r2347, r2375), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2373->else_instructions;

                                    ir_variable *const r2376 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2378 = equal(r2365, body.constant(int(64)));
                                    ir_if *f2377 = new(mem_ctx) ir_if(operand(r2378).val);
                                    exec_list *const f2377_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2377->then_instructions;

                                       body.emit(assign(r2376, r2347, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2377->else_instructions;

                                       ir_expression *const r2379 = nequal(r2347, body.constant(0u));
                                       ir_expression *const r237A = expr(ir_unop_b2i, r2379);
                                       body.emit(assign(r2376, expr(ir_unop_i2u, r237A), 0x01));


                                    body.instructions = f2377_parent_instructions;
                                    body.emit(f2377);

                                    /* END IF */

                                    body.emit(assign(r2366, r2376, 0x01));

                                    body.emit(assign(r2367, body.constant(0u), 0x01));


                                 body.instructions = f2373_parent_instructions;
                                 body.emit(f2373);

                                 /* END IF */


                              body.instructions = f2371_parent_instructions;
                              body.emit(f2371);

                              /* END IF */

                              body.emit(assign(r2368, body.constant(0u), 0x01));


                           body.instructions = f236D_parent_instructions;
                           body.emit(f236D);

                           /* END IF */

                           ir_expression *const r237B = nequal(r2364, body.constant(0u));
                           ir_expression *const r237C = expr(ir_unop_b2i, r237B);
                           ir_expression *const r237D = expr(ir_unop_i2u, r237C);
                           body.emit(assign(r2366, bit_or(r2366, r237D), 0x01));


                        body.instructions = f236B_parent_instructions;
                        body.emit(f236B);

                        /* END IF */

                        body.emit(assign(r234E, r2368, 0x01));

                        body.emit(assign(r234F, r2367, 0x01));

                        body.emit(assign(r2350, r2366, 0x01));

                        body.emit(assign(r234D, body.constant(int(0)), 0x01));

                        body.emit(assign(r2353, less(r2366, body.constant(0u)), 0x01));


                     body.instructions = f2362_parent_instructions;
                     body.emit(f2362);

                     /* END IF */


                  body.instructions = f235F_parent_instructions;
                  body.emit(f235F);

                  /* END IF */


               body.instructions = f2355_parent_instructions;
               body.emit(f2355);

               /* END IF */

               /* IF CONDITION */
               ir_if *f237E = new(mem_ctx) ir_if(operand(r2351).val);
               exec_list *const f237E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f237E->then_instructions;

                  /* IF CONDITION */
                  ir_if *f237F = new(mem_ctx) ir_if(operand(r2353).val);
                  exec_list *const f237F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f237F->then_instructions;

                     ir_variable *const r2380 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2380, add(r234F, body.constant(1u)), 0x01));

                     ir_expression *const r2381 = less(r2380, r234F);
                     ir_expression *const r2382 = expr(ir_unop_b2i, r2381);
                     ir_expression *const r2383 = expr(ir_unop_i2u, r2382);
                     body.emit(assign(r234E, add(r234E, r2383), 0x01));

                     ir_expression *const r2384 = equal(r2350, body.constant(0u));
                     ir_expression *const r2385 = expr(ir_unop_b2i, r2384);
                     ir_expression *const r2386 = expr(ir_unop_i2u, r2385);
                     ir_expression *const r2387 = add(r2350, r2386);
                     ir_expression *const r2388 = bit_and(r2387, body.constant(1u));
                     ir_expression *const r2389 = expr(ir_unop_bit_not, r2388);
                     body.emit(assign(r234F, bit_and(r2380, r2389), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f237F->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r238B = bit_or(r234E, r234F);
                     ir_expression *const r238C = equal(r238B, body.constant(0u));
                     ir_if *f238A = new(mem_ctx) ir_if(operand(r238C).val);
                     exec_list *const f238A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f238A->then_instructions;

                        body.emit(assign(r234D, body.constant(int(0)), 0x01));


                     body.instructions = f238A_parent_instructions;
                     body.emit(f238A);

                     /* END IF */


                  body.instructions = f237F_parent_instructions;
                  body.emit(f237F);

                  /* END IF */

                  ir_variable *const r238D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r238D);
                  ir_expression *const r238E = lshift(r21FA, body.constant(int(31)));
                  ir_expression *const r238F = expr(ir_unop_i2u, r234D);
                  ir_expression *const r2390 = lshift(r238F, body.constant(int(20)));
                  ir_expression *const r2391 = add(r238E, r2390);
                  body.emit(assign(r238D, add(r2391, r234E), 0x02));

                  body.emit(assign(r238D, r234F, 0x01));

                  body.emit(assign(r2352, r238D, 0x03));

                  body.emit(assign(r2351, body.constant(false), 0x01));


               body.instructions = f237E_parent_instructions;
               body.emit(f237E);

               /* END IF */

               body.emit(assign(r21FF, r2352, 0x03));

               body.emit(assign(r21FE, body.constant(false), 0x01));


            body.instructions = f22FE_parent_instructions;
            body.emit(f22FE);

            /* END IF */


         body.instructions = f22F7_parent_instructions;
         body.emit(f22F7);

         /* END IF */

         body.emit(assign(r21F9, r21FF, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f21FC->else_instructions;

         ir_variable *const r2392 = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r2392, r21FA, 0x01));

         ir_variable *const r2393 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2394 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2394);
         ir_variable *const r2395 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r2395);
         ir_variable *const r2396 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r2396);
         ir_variable *const r2397 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r2397);
         ir_variable *const r2398 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r2398);
         ir_variable *const r2399 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r2399);
         ir_variable *const r239A = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r239A);
         ir_variable *const r239B = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r239B);
         ir_variable *const r239C = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r239D = rshift(swizzle_y(r21C3), body.constant(int(20)));
         ir_expression *const r239E = bit_and(r239D, body.constant(2047u));
         body.emit(assign(r239C, expr(ir_unop_u2i, r239E), 0x01));

         body.emit(assign(r2396, r239C, 0x01));

         ir_variable *const r239F = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r239F, body.constant(int(1023)), 0x01));

         body.emit(assign(r2395, r239F, 0x01));

         body.emit(assign(r2394, add(r239C, body.constant(int(-1023))), 0x01));

         ir_variable *const r23A0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r23A0, lshift(swizzle_x(r21C3), body.constant(int(10))), 0x01));

         ir_variable *const r23A1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r23A2 = bit_and(swizzle_y(r21C3), body.constant(1048575u));
         ir_expression *const r23A3 = lshift(r23A2, body.constant(int(10)));
         ir_expression *const r23A4 = rshift(swizzle_x(r21C3), body.constant(int(22)));
         body.emit(assign(r23A1, bit_or(r23A3, r23A4), 0x01));

         body.emit(assign(r2399, r23A1, 0x01));

         body.emit(assign(r239A, r23A0, 0x01));

         ir_variable *const r23A5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r23A5, body.constant(0u), 0x01));

         ir_variable *const r23A6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r23A6, body.constant(0u), 0x01));

         body.emit(assign(r2397, r23A6, 0x01));

         body.emit(assign(r2398, r23A5, 0x01));

         /* IF CONDITION */
         ir_expression *const r23A8 = less(body.constant(int(0)), r2394);
         ir_if *f23A7 = new(mem_ctx) ir_if(operand(r23A8).val);
         exec_list *const f23A7_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f23A7->then_instructions;

            /* IF CONDITION */
            ir_expression *const r23AA = equal(r239C, body.constant(int(2047)));
            ir_if *f23A9 = new(mem_ctx) ir_if(operand(r23AA).val);
            exec_list *const f23A9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f23A9->then_instructions;

               /* IF CONDITION */
               ir_expression *const r23AC = bit_or(r23A1, r23A0);
               ir_expression *const r23AD = nequal(r23AC, body.constant(0u));
               ir_if *f23AB = new(mem_ctx) ir_if(operand(r23AD).val);
               exec_list *const f23AB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23AB->then_instructions;

                  ir_variable *const r23AE = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r23AE, swizzle_x(r21C3), 0x01));

                  ir_variable *const r23AF = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r23AF, body.constant(0u), 0x01));

                  ir_variable *const r23B0 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r23B1 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r23B2 = rshift(swizzle_y(r21C3), body.constant(int(19)));
                  ir_expression *const r23B3 = bit_and(r23B2, body.constant(4095u));
                  ir_expression *const r23B4 = equal(r23B3, body.constant(4094u));
                  ir_expression *const r23B5 = nequal(swizzle_x(r21C3), body.constant(0u));
                  ir_expression *const r23B6 = bit_and(swizzle_y(r21C3), body.constant(524287u));
                  ir_expression *const r23B7 = nequal(r23B6, body.constant(0u));
                  ir_expression *const r23B8 = logic_or(r23B5, r23B7);
                  body.emit(assign(r23B1, logic_and(r23B4, r23B8), 0x01));

                  ir_variable *const r23B9 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  body.emit(assign(r23B9, body.constant(false), 0x01));

                  body.emit(assign(r23AE, bit_or(swizzle_y(r21C3), body.constant(524288u)), 0x02));

                  body.emit(assign(r23AF, body.constant(3220701184u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r23BB = lshift(swizzle_y(r21C3), body.constant(int(1)));
                  ir_expression *const r23BC = lequal(body.constant(4292870144u), r23BB);
                  ir_expression *const r23BD = nequal(swizzle_x(r21C3), body.constant(0u));
                  ir_expression *const r23BE = bit_and(swizzle_y(r21C3), body.constant(1048575u));
                  ir_expression *const r23BF = nequal(r23BE, body.constant(0u));
                  ir_expression *const r23C0 = logic_or(r23BD, r23BF);
                  ir_expression *const r23C1 = logic_and(r23BC, r23C0);
                  ir_if *f23BA = new(mem_ctx) ir_if(operand(r23C1).val);
                  exec_list *const f23BA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23BA->then_instructions;

                     ir_variable *const r23C2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_constant *const r23C4 = body.constant(false);
                     ir_if *f23C3 = new(mem_ctx) ir_if(operand(r23C4).val);
                     exec_list *const f23C3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f23C3->then_instructions;

                        body.emit(assign(r23C2, r23AF, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f23C3->else_instructions;

                        body.emit(assign(r23C2, r23AE, 0x03));


                     body.instructions = f23C3_parent_instructions;
                     body.emit(f23C3);

                     /* END IF */

                     body.emit(assign(r23B0, r23C2, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23BA->else_instructions;

                     body.emit(assign(r23B0, r23AF, 0x03));


                  body.instructions = f23BA_parent_instructions;
                  body.emit(f23BA);

                  /* END IF */

                  body.emit(assign(r2393, r23B0, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f23AB->else_instructions;

                  body.emit(assign(r2393, r21C3, 0x03));


               body.instructions = f23AB_parent_instructions;
               body.emit(f23AB);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f23A9->else_instructions;

               /* IF CONDITION */
               ir_constant *const r23C6 = body.constant(false);
               ir_if *f23C5 = new(mem_ctx) ir_if(operand(r23C6).val);
               exec_list *const f23C5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23C5->then_instructions;

                  body.emit(assign(r2394, add(r2394, body.constant(int(-1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f23C5->else_instructions;

                  body.emit(assign(r2397, body.constant(1073741824u), 0x01));


               body.instructions = f23C5_parent_instructions;
               body.emit(f23C5);

               /* END IF */

               ir_variable *const r23C7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r23C7);
               ir_variable *const r23C8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r23C8);
               ir_variable *const r23C9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r23CA = neg(r2394);
               body.emit(assign(r23C9, bit_and(r23CA, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r23CC = equal(r2394, body.constant(int(0)));
               ir_if *f23CB = new(mem_ctx) ir_if(operand(r23CC).val);
               exec_list *const f23CB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23CB->then_instructions;

                  body.emit(assign(r23C7, r23A5, 0x01));

                  body.emit(assign(r23C8, r2397, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f23CB->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r23CE = less(r2394, body.constant(int(32)));
                  ir_if *f23CD = new(mem_ctx) ir_if(operand(r23CE).val);
                  exec_list *const f23CD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23CD->then_instructions;

                     ir_expression *const r23CF = lshift(r2397, r23C9);
                     ir_expression *const r23D0 = bit_or(r23CF, body.constant(0u));
                     ir_expression *const r23D1 = nequal(body.constant(0u), body.constant(0u));
                     ir_expression *const r23D2 = expr(ir_unop_b2i, r23D1);
                     ir_expression *const r23D3 = expr(ir_unop_i2u, r23D2);
                     body.emit(assign(r23C7, bit_or(r23D0, r23D3), 0x01));

                     body.emit(assign(r23C8, rshift(r2397, r2394), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23CD->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r23D5 = equal(r2394, body.constant(int(32)));
                     ir_if *f23D4 = new(mem_ctx) ir_if(operand(r23D5).val);
                     exec_list *const f23D4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f23D4->then_instructions;

                        body.emit(assign(r23C7, bit_or(r2397, body.constant(0u)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f23D4->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r23D7 = less(r2394, body.constant(int(64)));
                        ir_if *f23D6 = new(mem_ctx) ir_if(operand(r23D7).val);
                        exec_list *const f23D6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f23D6->then_instructions;

                           ir_expression *const r23D8 = bit_and(r2394, body.constant(int(31)));
                           ir_expression *const r23D9 = rshift(r2397, r23D8);
                           ir_expression *const r23DA = lshift(r2397, r23C9);
                           ir_expression *const r23DB = bit_or(r23DA, body.constant(0u));
                           ir_expression *const r23DC = nequal(r23DB, body.constant(0u));
                           ir_expression *const r23DD = expr(ir_unop_b2i, r23DC);
                           ir_expression *const r23DE = expr(ir_unop_i2u, r23DD);
                           body.emit(assign(r23C7, bit_or(r23D9, r23DE), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f23D6->else_instructions;

                           ir_expression *const r23DF = bit_or(r2397, body.constant(0u));
                           ir_expression *const r23E0 = nequal(r23DF, body.constant(0u));
                           ir_expression *const r23E1 = expr(ir_unop_b2i, r23E0);
                           body.emit(assign(r23C7, expr(ir_unop_i2u, r23E1), 0x01));


                        body.instructions = f23D6_parent_instructions;
                        body.emit(f23D6);

                        /* END IF */


                     body.instructions = f23D4_parent_instructions;
                     body.emit(f23D4);

                     /* END IF */

                     body.emit(assign(r23C8, body.constant(0u), 0x01));


                  body.instructions = f23CD_parent_instructions;
                  body.emit(f23CD);

                  /* END IF */


               body.instructions = f23CB_parent_instructions;
               body.emit(f23CB);

               /* END IF */

               body.emit(assign(r2397, r23C8, 0x01));

               body.emit(assign(r2398, r23C7, 0x01));

               body.emit(assign(r2399, bit_or(r23A1, body.constant(1073741824u)), 0x01));

               ir_variable *const r23E2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r23E3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r23E3, sub(r23A0, r23C7), 0x01));

               ir_expression *const r23E4 = sub(r2399, r23C8);
               ir_expression *const r23E5 = less(r23A0, r23C7);
               ir_expression *const r23E6 = expr(ir_unop_b2i, r23E5);
               ir_expression *const r23E7 = expr(ir_unop_i2u, r23E6);
               body.emit(assign(r23E2, sub(r23E4, r23E7), 0x01));

               body.emit(assign(r239B, add(r239C, body.constant(int(-1))), 0x01));

               ir_variable *const r23E8 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r23E8, add(r239B, body.constant(int(-10))), 0x01));

               ir_variable *const r23E9 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r23E9, r23E2, 0x01));

               ir_variable *const r23EA = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r23EA, r23E3, 0x01));

               ir_variable *const r23EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r23EB);
               ir_variable *const r23EC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r23EC);
               /* IF CONDITION */
               ir_expression *const r23EE = equal(r23E2, body.constant(0u));
               ir_if *f23ED = new(mem_ctx) ir_if(operand(r23EE).val);
               exec_list *const f23ED_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23ED->then_instructions;

                  body.emit(assign(r23E9, r23E3, 0x01));

                  body.emit(assign(r23EA, body.constant(0u), 0x01));

                  body.emit(assign(r23E8, add(r23E8, body.constant(int(-32))), 0x01));


               body.instructions = f23ED_parent_instructions;
               body.emit(f23ED);

               /* END IF */

               ir_variable *const r23EF = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r23EF, r23E9, 0x01));

               ir_variable *const r23F0 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r23F1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r23F1);
               /* IF CONDITION */
               ir_expression *const r23F3 = equal(r23E9, body.constant(0u));
               ir_if *f23F2 = new(mem_ctx) ir_if(operand(r23F3).val);
               exec_list *const f23F2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23F2->then_instructions;

                  body.emit(assign(r23F0, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f23F2->else_instructions;

                  body.emit(assign(r23F1, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r23F5 = bit_and(r23E9, body.constant(4294901760u));
                  ir_expression *const r23F6 = equal(r23F5, body.constant(0u));
                  ir_if *f23F4 = new(mem_ctx) ir_if(operand(r23F6).val);
                  exec_list *const f23F4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23F4->then_instructions;

                     body.emit(assign(r23F1, body.constant(int(16)), 0x01));

                     body.emit(assign(r23EF, lshift(r23E9, body.constant(int(16))), 0x01));


                  body.instructions = f23F4_parent_instructions;
                  body.emit(f23F4);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r23F8 = bit_and(r23EF, body.constant(4278190080u));
                  ir_expression *const r23F9 = equal(r23F8, body.constant(0u));
                  ir_if *f23F7 = new(mem_ctx) ir_if(operand(r23F9).val);
                  exec_list *const f23F7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23F7->then_instructions;

                     body.emit(assign(r23F1, add(r23F1, body.constant(int(8))), 0x01));

                     body.emit(assign(r23EF, lshift(r23EF, body.constant(int(8))), 0x01));


                  body.instructions = f23F7_parent_instructions;
                  body.emit(f23F7);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r23FB = bit_and(r23EF, body.constant(4026531840u));
                  ir_expression *const r23FC = equal(r23FB, body.constant(0u));
                  ir_if *f23FA = new(mem_ctx) ir_if(operand(r23FC).val);
                  exec_list *const f23FA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23FA->then_instructions;

                     body.emit(assign(r23F1, add(r23F1, body.constant(int(4))), 0x01));

                     body.emit(assign(r23EF, lshift(r23EF, body.constant(int(4))), 0x01));


                  body.instructions = f23FA_parent_instructions;
                  body.emit(f23FA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r23FE = bit_and(r23EF, body.constant(3221225472u));
                  ir_expression *const r23FF = equal(r23FE, body.constant(0u));
                  ir_if *f23FD = new(mem_ctx) ir_if(operand(r23FF).val);
                  exec_list *const f23FD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23FD->then_instructions;

                     body.emit(assign(r23F1, add(r23F1, body.constant(int(2))), 0x01));

                     body.emit(assign(r23EF, lshift(r23EF, body.constant(int(2))), 0x01));


                  body.instructions = f23FD_parent_instructions;
                  body.emit(f23FD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2401 = bit_and(r23EF, body.constant(2147483648u));
                  ir_expression *const r2402 = equal(r2401, body.constant(0u));
                  ir_if *f2400 = new(mem_ctx) ir_if(operand(r2402).val);
                  exec_list *const f2400_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2400->then_instructions;

                     body.emit(assign(r23F1, add(r23F1, body.constant(int(1))), 0x01));


                  body.instructions = f2400_parent_instructions;
                  body.emit(f2400);

                  /* END IF */

                  body.emit(assign(r23F0, r23F1, 0x01));


               body.instructions = f23F2_parent_instructions;
               body.emit(f23F2);

               /* END IF */

               body.emit(assign(r23EC, add(r23F0, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2404 = lequal(body.constant(int(0)), r23EC);
               ir_if *f2403 = new(mem_ctx) ir_if(operand(r2404).val);
               exec_list *const f2403_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2403->then_instructions;

                  body.emit(assign(r23EB, body.constant(0u), 0x01));

                  ir_variable *const r2405 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2405, lshift(r23EA, r23EC), 0x01));

                  ir_variable *const r2406 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2408 = equal(r23EC, body.constant(int(0)));
                  ir_if *f2407 = new(mem_ctx) ir_if(operand(r2408).val);
                  exec_list *const f2407_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2407->then_instructions;

                     body.emit(assign(r2406, r23E9, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2407->else_instructions;

                     ir_expression *const r2409 = lshift(r23E9, r23EC);
                     ir_expression *const r240A = neg(r23EC);
                     ir_expression *const r240B = bit_and(r240A, body.constant(int(31)));
                     ir_expression *const r240C = rshift(r23EA, r240B);
                     body.emit(assign(r2406, bit_or(r2409, r240C), 0x01));


                  body.instructions = f2407_parent_instructions;
                  body.emit(f2407);

                  /* END IF */

                  body.emit(assign(r23E9, r2406, 0x01));

                  body.emit(assign(r23EA, r2405, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2403->else_instructions;

                  ir_variable *const r240D = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r240D, body.constant(0u), 0x01));

                  ir_variable *const r240E = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r240E, neg(r23EC), 0x01));

                  ir_variable *const r240F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r240F);
                  ir_variable *const r2410 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2410);
                  ir_variable *const r2411 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2411);
                  ir_variable *const r2412 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2413 = neg(r240E);
                  body.emit(assign(r2412, bit_and(r2413, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2415 = equal(r240E, body.constant(int(0)));
                  ir_if *f2414 = new(mem_ctx) ir_if(operand(r2415).val);
                  exec_list *const f2414_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2414->then_instructions;

                     body.emit(assign(r240F, r240D, 0x01));

                     body.emit(assign(r2410, r23EA, 0x01));

                     body.emit(assign(r2411, r23E9, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2414->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2417 = less(r240E, body.constant(int(32)));
                     ir_if *f2416 = new(mem_ctx) ir_if(operand(r2417).val);
                     exec_list *const f2416_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2416->then_instructions;

                        body.emit(assign(r240F, lshift(r23EA, r2412), 0x01));

                        ir_expression *const r2418 = lshift(r23E9, r2412);
                        ir_expression *const r2419 = rshift(r23EA, r240E);
                        body.emit(assign(r2410, bit_or(r2418, r2419), 0x01));

                        body.emit(assign(r2411, rshift(r23E9, r240E), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2416->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r241B = equal(r240E, body.constant(int(32)));
                        ir_if *f241A = new(mem_ctx) ir_if(operand(r241B).val);
                        exec_list *const f241A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f241A->then_instructions;

                           body.emit(assign(r240F, r23EA, 0x01));

                           body.emit(assign(r2410, r23E9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f241A->else_instructions;

                           body.emit(assign(r240D, bit_or(body.constant(0u), r23EA), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r241D = less(r240E, body.constant(int(64)));
                           ir_if *f241C = new(mem_ctx) ir_if(operand(r241D).val);
                           exec_list *const f241C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f241C->then_instructions;

                              body.emit(assign(r240F, lshift(r23E9, r2412), 0x01));

                              ir_expression *const r241E = bit_and(r240E, body.constant(int(31)));
                              body.emit(assign(r2410, rshift(r23E9, r241E), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f241C->else_instructions;

                              ir_variable *const r241F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2421 = equal(r240E, body.constant(int(64)));
                              ir_if *f2420 = new(mem_ctx) ir_if(operand(r2421).val);
                              exec_list *const f2420_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2420->then_instructions;

                                 body.emit(assign(r241F, r23E9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2420->else_instructions;

                                 ir_expression *const r2422 = nequal(r23E9, body.constant(0u));
                                 ir_expression *const r2423 = expr(ir_unop_b2i, r2422);
                                 body.emit(assign(r241F, expr(ir_unop_i2u, r2423), 0x01));


                              body.instructions = f2420_parent_instructions;
                              body.emit(f2420);

                              /* END IF */

                              body.emit(assign(r240F, r241F, 0x01));

                              body.emit(assign(r2410, body.constant(0u), 0x01));


                           body.instructions = f241C_parent_instructions;
                           body.emit(f241C);

                           /* END IF */


                        body.instructions = f241A_parent_instructions;
                        body.emit(f241A);

                        /* END IF */

                        body.emit(assign(r2411, body.constant(0u), 0x01));


                     body.instructions = f2416_parent_instructions;
                     body.emit(f2416);

                     /* END IF */

                     ir_expression *const r2424 = nequal(r240D, body.constant(0u));
                     ir_expression *const r2425 = expr(ir_unop_b2i, r2424);
                     ir_expression *const r2426 = expr(ir_unop_i2u, r2425);
                     body.emit(assign(r240F, bit_or(r240F, r2426), 0x01));


                  body.instructions = f2414_parent_instructions;
                  body.emit(f2414);

                  /* END IF */

                  body.emit(assign(r23E9, r2411, 0x01));

                  body.emit(assign(r23EA, r2410, 0x01));

                  body.emit(assign(r23EB, r240F, 0x01));


               body.instructions = f2403_parent_instructions;
               body.emit(f2403);

               /* END IF */

               body.emit(assign(r23E8, sub(r23E8, r23EC), 0x01));

               ir_variable *const r2427 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2427, r23E8, 0x01));

               ir_variable *const r2428 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2428, r23E9, 0x01));

               ir_variable *const r2429 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2429, r23EA, 0x01));

               ir_variable *const r242A = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r242A, r23EB, 0x01));

               ir_variable *const r242B = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r242B, body.constant(true), 0x01));

               ir_variable *const r242C = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r242D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r242D);
               ir_expression *const r242E = expr(ir_unop_u2i, r23EB);
               body.emit(assign(r242D, less(r242E, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2430 = lequal(body.constant(int(2045)), r23E8);
               ir_if *f242F = new(mem_ctx) ir_if(operand(r2430).val);
               exec_list *const f242F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f242F->then_instructions;

                  ir_variable *const r2431 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2433 = less(body.constant(int(2045)), r23E8);
                  ir_if *f2432 = new(mem_ctx) ir_if(operand(r2433).val);
                  exec_list *const f2432_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2432->then_instructions;

                     body.emit(assign(r2431, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2432->else_instructions;

                     ir_variable *const r2434 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2436 = equal(r23E8, body.constant(int(2045)));
                     ir_if *f2435 = new(mem_ctx) ir_if(operand(r2436).val);
                     exec_list *const f2435_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2435->then_instructions;

                        ir_expression *const r2437 = equal(body.constant(2097151u), r23E9);
                        ir_expression *const r2438 = equal(body.constant(4294967295u), r23EA);
                        body.emit(assign(r2434, logic_and(r2437, r2438), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2435->else_instructions;

                        body.emit(assign(r2434, body.constant(false), 0x01));


                     body.instructions = f2435_parent_instructions;
                     body.emit(f2435);

                     /* END IF */

                     body.emit(assign(r2431, logic_and(r2434, r242D), 0x01));


                  body.instructions = f2432_parent_instructions;
                  body.emit(f2432);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2439 = new(mem_ctx) ir_if(operand(r2431).val);
                  exec_list *const f2439_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2439->then_instructions;

                     ir_variable *const r243A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r243A);
                     ir_expression *const r243B = lshift(r21FA, body.constant(int(31)));
                     body.emit(assign(r243A, add(r243B, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r243A, body.constant(0u), 0x01));

                     body.emit(assign(r242C, r243A, 0x03));

                     body.emit(assign(r242B, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2439->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r243D = less(r23E8, body.constant(int(0)));
                     ir_if *f243C = new(mem_ctx) ir_if(operand(r243D).val);
                     exec_list *const f243C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f243C->then_instructions;

                        ir_variable *const r243E = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r243E, r23EB, 0x01));

                        ir_variable *const r243F = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r243F, neg(r23E8), 0x01));

                        ir_variable *const r2440 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2440);
                        ir_variable *const r2441 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2441);
                        ir_variable *const r2442 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2442);
                        ir_variable *const r2443 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2444 = neg(r243F);
                        body.emit(assign(r2443, bit_and(r2444, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2446 = equal(r243F, body.constant(int(0)));
                        ir_if *f2445 = new(mem_ctx) ir_if(operand(r2446).val);
                        exec_list *const f2445_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2445->then_instructions;

                           body.emit(assign(r2440, r23EB, 0x01));

                           body.emit(assign(r2441, r23EA, 0x01));

                           body.emit(assign(r2442, r23E9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2445->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2448 = less(r243F, body.constant(int(32)));
                           ir_if *f2447 = new(mem_ctx) ir_if(operand(r2448).val);
                           exec_list *const f2447_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2447->then_instructions;

                              body.emit(assign(r2440, lshift(r23EA, r2443), 0x01));

                              ir_expression *const r2449 = lshift(r23E9, r2443);
                              ir_expression *const r244A = rshift(r23EA, r243F);
                              body.emit(assign(r2441, bit_or(r2449, r244A), 0x01));

                              body.emit(assign(r2442, rshift(r23E9, r243F), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2447->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r244C = equal(r243F, body.constant(int(32)));
                              ir_if *f244B = new(mem_ctx) ir_if(operand(r244C).val);
                              exec_list *const f244B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f244B->then_instructions;

                                 body.emit(assign(r2440, r23EA, 0x01));

                                 body.emit(assign(r2441, r23E9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f244B->else_instructions;

                                 body.emit(assign(r243E, bit_or(r23EB, r23EA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r244E = less(r243F, body.constant(int(64)));
                                 ir_if *f244D = new(mem_ctx) ir_if(operand(r244E).val);
                                 exec_list *const f244D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f244D->then_instructions;

                                    body.emit(assign(r2440, lshift(r23E9, r2443), 0x01));

                                    ir_expression *const r244F = bit_and(r243F, body.constant(int(31)));
                                    body.emit(assign(r2441, rshift(r23E9, r244F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f244D->else_instructions;

                                    ir_variable *const r2450 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2452 = equal(r243F, body.constant(int(64)));
                                    ir_if *f2451 = new(mem_ctx) ir_if(operand(r2452).val);
                                    exec_list *const f2451_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2451->then_instructions;

                                       body.emit(assign(r2450, r23E9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2451->else_instructions;

                                       ir_expression *const r2453 = nequal(r23E9, body.constant(0u));
                                       ir_expression *const r2454 = expr(ir_unop_b2i, r2453);
                                       body.emit(assign(r2450, expr(ir_unop_i2u, r2454), 0x01));


                                    body.instructions = f2451_parent_instructions;
                                    body.emit(f2451);

                                    /* END IF */

                                    body.emit(assign(r2440, r2450, 0x01));

                                    body.emit(assign(r2441, body.constant(0u), 0x01));


                                 body.instructions = f244D_parent_instructions;
                                 body.emit(f244D);

                                 /* END IF */


                              body.instructions = f244B_parent_instructions;
                              body.emit(f244B);

                              /* END IF */

                              body.emit(assign(r2442, body.constant(0u), 0x01));


                           body.instructions = f2447_parent_instructions;
                           body.emit(f2447);

                           /* END IF */

                           ir_expression *const r2455 = nequal(r243E, body.constant(0u));
                           ir_expression *const r2456 = expr(ir_unop_b2i, r2455);
                           ir_expression *const r2457 = expr(ir_unop_i2u, r2456);
                           body.emit(assign(r2440, bit_or(r2440, r2457), 0x01));


                        body.instructions = f2445_parent_instructions;
                        body.emit(f2445);

                        /* END IF */

                        body.emit(assign(r2428, r2442, 0x01));

                        body.emit(assign(r2429, r2441, 0x01));

                        body.emit(assign(r242A, r2440, 0x01));

                        body.emit(assign(r2427, body.constant(int(0)), 0x01));

                        body.emit(assign(r242D, less(r2440, body.constant(0u)), 0x01));


                     body.instructions = f243C_parent_instructions;
                     body.emit(f243C);

                     /* END IF */


                  body.instructions = f2439_parent_instructions;
                  body.emit(f2439);

                  /* END IF */


               body.instructions = f242F_parent_instructions;
               body.emit(f242F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2458 = new(mem_ctx) ir_if(operand(r242B).val);
               exec_list *const f2458_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2458->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2459 = new(mem_ctx) ir_if(operand(r242D).val);
                  exec_list *const f2459_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2459->then_instructions;

                     ir_variable *const r245A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r245A, add(r2429, body.constant(1u)), 0x01));

                     ir_expression *const r245B = less(r245A, r2429);
                     ir_expression *const r245C = expr(ir_unop_b2i, r245B);
                     ir_expression *const r245D = expr(ir_unop_i2u, r245C);
                     body.emit(assign(r2428, add(r2428, r245D), 0x01));

                     ir_expression *const r245E = equal(r242A, body.constant(0u));
                     ir_expression *const r245F = expr(ir_unop_b2i, r245E);
                     ir_expression *const r2460 = expr(ir_unop_i2u, r245F);
                     ir_expression *const r2461 = add(r242A, r2460);
                     ir_expression *const r2462 = bit_and(r2461, body.constant(1u));
                     ir_expression *const r2463 = expr(ir_unop_bit_not, r2462);
                     body.emit(assign(r2429, bit_and(r245A, r2463), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2459->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2465 = bit_or(r2428, r2429);
                     ir_expression *const r2466 = equal(r2465, body.constant(0u));
                     ir_if *f2464 = new(mem_ctx) ir_if(operand(r2466).val);
                     exec_list *const f2464_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2464->then_instructions;

                        body.emit(assign(r2427, body.constant(int(0)), 0x01));


                     body.instructions = f2464_parent_instructions;
                     body.emit(f2464);

                     /* END IF */


                  body.instructions = f2459_parent_instructions;
                  body.emit(f2459);

                  /* END IF */

                  ir_variable *const r2467 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2467);
                  ir_expression *const r2468 = lshift(r21FA, body.constant(int(31)));
                  ir_expression *const r2469 = expr(ir_unop_i2u, r2427);
                  ir_expression *const r246A = lshift(r2469, body.constant(int(20)));
                  ir_expression *const r246B = add(r2468, r246A);
                  body.emit(assign(r2467, add(r246B, r2428), 0x02));

                  body.emit(assign(r2467, r2429, 0x01));

                  body.emit(assign(r242C, r2467, 0x03));

                  body.emit(assign(r242B, body.constant(false), 0x01));


               body.instructions = f2458_parent_instructions;
               body.emit(f2458);

               /* END IF */

               body.emit(assign(r2393, r242C, 0x03));


            body.instructions = f23A9_parent_instructions;
            body.emit(f23A9);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f23A7->else_instructions;

            /* IF CONDITION */
            ir_expression *const r246D = less(r2394, body.constant(int(0)));
            ir_if *f246C = new(mem_ctx) ir_if(operand(r246D).val);
            exec_list *const f246C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f246C->then_instructions;

               /* IF CONDITION */
               ir_constant *const r246F = body.constant(false);
               ir_if *f246E = new(mem_ctx) ir_if(operand(r246F).val);
               exec_list *const f246E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f246E->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2471 = bit_or(r2397, r2398);
                  ir_expression *const r2472 = nequal(r2471, body.constant(0u));
                  ir_if *f2470 = new(mem_ctx) ir_if(operand(r2472).val);
                  exec_list *const f2470_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2470->then_instructions;

                     ir_variable *const r2473 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r2473, swizzle_x(r21C3), 0x01));

                     ir_variable *const r2474 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r2474, body.constant(0u), 0x01));

                     ir_variable *const r2475 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2476 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r2477 = rshift(swizzle_y(r21C3), body.constant(int(19)));
                     ir_expression *const r2478 = bit_and(r2477, body.constant(4095u));
                     ir_expression *const r2479 = equal(r2478, body.constant(4094u));
                     ir_expression *const r247A = nequal(swizzle_x(r21C3), body.constant(0u));
                     ir_expression *const r247B = bit_and(swizzle_y(r21C3), body.constant(524287u));
                     ir_expression *const r247C = nequal(r247B, body.constant(0u));
                     ir_expression *const r247D = logic_or(r247A, r247C);
                     body.emit(assign(r2476, logic_and(r2479, r247D), 0x01));

                     ir_variable *const r247E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r247E, body.constant(false), 0x01));

                     body.emit(assign(r2473, bit_or(swizzle_y(r21C3), body.constant(524288u)), 0x02));

                     body.emit(assign(r2474, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r2480 = lshift(swizzle_y(r21C3), body.constant(int(1)));
                     ir_expression *const r2481 = lequal(body.constant(4292870144u), r2480);
                     ir_expression *const r2482 = nequal(swizzle_x(r21C3), body.constant(0u));
                     ir_expression *const r2483 = bit_and(swizzle_y(r21C3), body.constant(1048575u));
                     ir_expression *const r2484 = nequal(r2483, body.constant(0u));
                     ir_expression *const r2485 = logic_or(r2482, r2484);
                     ir_expression *const r2486 = logic_and(r2481, r2485);
                     ir_if *f247F = new(mem_ctx) ir_if(operand(r2486).val);
                     exec_list *const f247F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f247F->then_instructions;

                        ir_variable *const r2487 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r2489 = body.constant(false);
                        ir_if *f2488 = new(mem_ctx) ir_if(operand(r2489).val);
                        exec_list *const f2488_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2488->then_instructions;

                           body.emit(assign(r2487, r2474, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2488->else_instructions;

                           body.emit(assign(r2487, r2473, 0x03));


                        body.instructions = f2488_parent_instructions;
                        body.emit(f2488);

                        /* END IF */

                        body.emit(assign(r2475, r2487, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f247F->else_instructions;

                        body.emit(assign(r2475, r2474, 0x03));


                     body.instructions = f247F_parent_instructions;
                     body.emit(f247F);

                     /* END IF */

                     body.emit(assign(r2393, r2475, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2470->else_instructions;

                     ir_variable *const r248A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r248A);
                     ir_expression *const r248B = bit_xor(r21FA, body.constant(1u));
                     ir_expression *const r248C = lshift(r248B, body.constant(int(31)));
                     body.emit(assign(r248A, add(r248C, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r248A, body.constant(0u), 0x01));

                     body.emit(assign(r2393, r248A, 0x03));


                  body.instructions = f2470_parent_instructions;
                  body.emit(f2470);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f246E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r248E = equal(r239C, body.constant(int(0)));
                  ir_if *f248D = new(mem_ctx) ir_if(operand(r248E).val);
                  exec_list *const f248D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f248D->then_instructions;

                     body.emit(assign(r2394, add(r2394, body.constant(int(1))), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f248D->else_instructions;

                     body.emit(assign(r2399, bit_or(r2399, body.constant(1073741824u)), 0x01));


                  body.instructions = f248D_parent_instructions;
                  body.emit(f248D);

                  /* END IF */

                  ir_variable *const r248F = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r248F, neg(r2394), 0x01));

                  ir_variable *const r2490 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2490);
                  ir_variable *const r2491 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2491);
                  ir_variable *const r2492 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2493 = neg(r248F);
                  body.emit(assign(r2492, bit_and(r2493, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2495 = equal(r248F, body.constant(int(0)));
                  ir_if *f2494 = new(mem_ctx) ir_if(operand(r2495).val);
                  exec_list *const f2494_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2494->then_instructions;

                     body.emit(assign(r2490, r23A0, 0x01));

                     body.emit(assign(r2491, r2399, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2494->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2497 = less(r248F, body.constant(int(32)));
                     ir_if *f2496 = new(mem_ctx) ir_if(operand(r2497).val);
                     exec_list *const f2496_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2496->then_instructions;

                        ir_expression *const r2498 = lshift(r2399, r2492);
                        ir_expression *const r2499 = rshift(r23A0, r248F);
                        ir_expression *const r249A = bit_or(r2498, r2499);
                        ir_expression *const r249B = lshift(r23A0, r2492);
                        ir_expression *const r249C = nequal(r249B, body.constant(0u));
                        ir_expression *const r249D = expr(ir_unop_b2i, r249C);
                        ir_expression *const r249E = expr(ir_unop_i2u, r249D);
                        body.emit(assign(r2490, bit_or(r249A, r249E), 0x01));

                        body.emit(assign(r2491, rshift(r2399, r248F), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2496->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r24A0 = equal(r248F, body.constant(int(32)));
                        ir_if *f249F = new(mem_ctx) ir_if(operand(r24A0).val);
                        exec_list *const f249F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f249F->then_instructions;

                           ir_expression *const r24A1 = nequal(r23A0, body.constant(0u));
                           ir_expression *const r24A2 = expr(ir_unop_b2i, r24A1);
                           ir_expression *const r24A3 = expr(ir_unop_i2u, r24A2);
                           body.emit(assign(r2490, bit_or(r2399, r24A3), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f249F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r24A5 = less(r248F, body.constant(int(64)));
                           ir_if *f24A4 = new(mem_ctx) ir_if(operand(r24A5).val);
                           exec_list *const f24A4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f24A4->then_instructions;

                              ir_expression *const r24A6 = bit_and(r248F, body.constant(int(31)));
                              ir_expression *const r24A7 = rshift(r2399, r24A6);
                              ir_expression *const r24A8 = lshift(r2399, r2492);
                              ir_expression *const r24A9 = bit_or(r24A8, r23A0);
                              ir_expression *const r24AA = nequal(r24A9, body.constant(0u));
                              ir_expression *const r24AB = expr(ir_unop_b2i, r24AA);
                              ir_expression *const r24AC = expr(ir_unop_i2u, r24AB);
                              body.emit(assign(r2490, bit_or(r24A7, r24AC), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f24A4->else_instructions;

                              ir_expression *const r24AD = bit_or(r2399, r23A0);
                              ir_expression *const r24AE = nequal(r24AD, body.constant(0u));
                              ir_expression *const r24AF = expr(ir_unop_b2i, r24AE);
                              body.emit(assign(r2490, expr(ir_unop_i2u, r24AF), 0x01));


                           body.instructions = f24A4_parent_instructions;
                           body.emit(f24A4);

                           /* END IF */


                        body.instructions = f249F_parent_instructions;
                        body.emit(f249F);

                        /* END IF */

                        body.emit(assign(r2491, body.constant(0u), 0x01));


                     body.instructions = f2496_parent_instructions;
                     body.emit(f2496);

                     /* END IF */


                  body.instructions = f2494_parent_instructions;
                  body.emit(f2494);

                  /* END IF */

                  body.emit(assign(r2399, r2491, 0x01));

                  body.emit(assign(r239A, r2490, 0x01));

                  body.emit(assign(r2397, bit_or(r2397, body.constant(1073741824u)), 0x01));

                  ir_variable *const r24B0 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r24B1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r24B1, sub(r2398, r2490), 0x01));

                  ir_expression *const r24B2 = sub(r2397, r2491);
                  ir_expression *const r24B3 = less(r2398, r2490);
                  ir_expression *const r24B4 = expr(ir_unop_b2i, r24B3);
                  ir_expression *const r24B5 = expr(ir_unop_i2u, r24B4);
                  body.emit(assign(r24B0, sub(r24B2, r24B5), 0x01));

                  body.emit(assign(r2392, bit_xor(r21FA, body.constant(1u)), 0x01));

                  body.emit(assign(r239B, body.constant(int(1022)), 0x01));

                  ir_variable *const r24B6 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r24B6, body.constant(int(1012)), 0x01));

                  ir_variable *const r24B7 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r24B7, r24B0, 0x01));

                  ir_variable *const r24B8 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r24B8, r24B1, 0x01));

                  ir_variable *const r24B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r24B9);
                  ir_variable *const r24BA = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r24BA);
                  /* IF CONDITION */
                  ir_expression *const r24BC = equal(r24B0, body.constant(0u));
                  ir_if *f24BB = new(mem_ctx) ir_if(operand(r24BC).val);
                  exec_list *const f24BB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24BB->then_instructions;

                     body.emit(assign(r24B7, r24B1, 0x01));

                     body.emit(assign(r24B8, body.constant(0u), 0x01));

                     body.emit(assign(r24B6, body.constant(int(980)), 0x01));


                  body.instructions = f24BB_parent_instructions;
                  body.emit(f24BB);

                  /* END IF */

                  ir_variable *const r24BD = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r24BD, r24B7, 0x01));

                  ir_variable *const r24BE = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r24BF = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r24BF);
                  /* IF CONDITION */
                  ir_expression *const r24C1 = equal(r24B7, body.constant(0u));
                  ir_if *f24C0 = new(mem_ctx) ir_if(operand(r24C1).val);
                  exec_list *const f24C0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24C0->then_instructions;

                     body.emit(assign(r24BE, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24C0->else_instructions;

                     body.emit(assign(r24BF, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r24C3 = bit_and(r24B7, body.constant(4294901760u));
                     ir_expression *const r24C4 = equal(r24C3, body.constant(0u));
                     ir_if *f24C2 = new(mem_ctx) ir_if(operand(r24C4).val);
                     exec_list *const f24C2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24C2->then_instructions;

                        body.emit(assign(r24BF, body.constant(int(16)), 0x01));

                        body.emit(assign(r24BD, lshift(r24B7, body.constant(int(16))), 0x01));


                     body.instructions = f24C2_parent_instructions;
                     body.emit(f24C2);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r24C6 = bit_and(r24BD, body.constant(4278190080u));
                     ir_expression *const r24C7 = equal(r24C6, body.constant(0u));
                     ir_if *f24C5 = new(mem_ctx) ir_if(operand(r24C7).val);
                     exec_list *const f24C5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24C5->then_instructions;

                        body.emit(assign(r24BF, add(r24BF, body.constant(int(8))), 0x01));

                        body.emit(assign(r24BD, lshift(r24BD, body.constant(int(8))), 0x01));


                     body.instructions = f24C5_parent_instructions;
                     body.emit(f24C5);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r24C9 = bit_and(r24BD, body.constant(4026531840u));
                     ir_expression *const r24CA = equal(r24C9, body.constant(0u));
                     ir_if *f24C8 = new(mem_ctx) ir_if(operand(r24CA).val);
                     exec_list *const f24C8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24C8->then_instructions;

                        body.emit(assign(r24BF, add(r24BF, body.constant(int(4))), 0x01));

                        body.emit(assign(r24BD, lshift(r24BD, body.constant(int(4))), 0x01));


                     body.instructions = f24C8_parent_instructions;
                     body.emit(f24C8);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r24CC = bit_and(r24BD, body.constant(3221225472u));
                     ir_expression *const r24CD = equal(r24CC, body.constant(0u));
                     ir_if *f24CB = new(mem_ctx) ir_if(operand(r24CD).val);
                     exec_list *const f24CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24CB->then_instructions;

                        body.emit(assign(r24BF, add(r24BF, body.constant(int(2))), 0x01));

                        body.emit(assign(r24BD, lshift(r24BD, body.constant(int(2))), 0x01));


                     body.instructions = f24CB_parent_instructions;
                     body.emit(f24CB);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r24CF = bit_and(r24BD, body.constant(2147483648u));
                     ir_expression *const r24D0 = equal(r24CF, body.constant(0u));
                     ir_if *f24CE = new(mem_ctx) ir_if(operand(r24D0).val);
                     exec_list *const f24CE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24CE->then_instructions;

                        body.emit(assign(r24BF, add(r24BF, body.constant(int(1))), 0x01));


                     body.instructions = f24CE_parent_instructions;
                     body.emit(f24CE);

                     /* END IF */

                     body.emit(assign(r24BE, r24BF, 0x01));


                  body.instructions = f24C0_parent_instructions;
                  body.emit(f24C0);

                  /* END IF */

                  body.emit(assign(r24BA, add(r24BE, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r24D2 = lequal(body.constant(int(0)), r24BA);
                  ir_if *f24D1 = new(mem_ctx) ir_if(operand(r24D2).val);
                  exec_list *const f24D1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24D1->then_instructions;

                     body.emit(assign(r24B9, body.constant(0u), 0x01));

                     ir_variable *const r24D3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r24D3, lshift(r24B8, r24BA), 0x01));

                     ir_variable *const r24D4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r24D6 = equal(r24BA, body.constant(int(0)));
                     ir_if *f24D5 = new(mem_ctx) ir_if(operand(r24D6).val);
                     exec_list *const f24D5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24D5->then_instructions;

                        body.emit(assign(r24D4, r24B7, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f24D5->else_instructions;

                        ir_expression *const r24D7 = lshift(r24B7, r24BA);
                        ir_expression *const r24D8 = neg(r24BA);
                        ir_expression *const r24D9 = bit_and(r24D8, body.constant(int(31)));
                        ir_expression *const r24DA = rshift(r24B8, r24D9);
                        body.emit(assign(r24D4, bit_or(r24D7, r24DA), 0x01));


                     body.instructions = f24D5_parent_instructions;
                     body.emit(f24D5);

                     /* END IF */

                     body.emit(assign(r24B7, r24D4, 0x01));

                     body.emit(assign(r24B8, r24D3, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24D1->else_instructions;

                     ir_variable *const r24DB = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r24DB, body.constant(0u), 0x01));

                     ir_variable *const r24DC = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r24DC, neg(r24BA), 0x01));

                     ir_variable *const r24DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r24DD);
                     ir_variable *const r24DE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r24DE);
                     ir_variable *const r24DF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r24DF);
                     ir_variable *const r24E0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r24E1 = neg(r24DC);
                     body.emit(assign(r24E0, bit_and(r24E1, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r24E3 = equal(r24DC, body.constant(int(0)));
                     ir_if *f24E2 = new(mem_ctx) ir_if(operand(r24E3).val);
                     exec_list *const f24E2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24E2->then_instructions;

                        body.emit(assign(r24DD, r24DB, 0x01));

                        body.emit(assign(r24DE, r24B8, 0x01));

                        body.emit(assign(r24DF, r24B7, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f24E2->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r24E5 = less(r24DC, body.constant(int(32)));
                        ir_if *f24E4 = new(mem_ctx) ir_if(operand(r24E5).val);
                        exec_list *const f24E4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f24E4->then_instructions;

                           body.emit(assign(r24DD, lshift(r24B8, r24E0), 0x01));

                           ir_expression *const r24E6 = lshift(r24B7, r24E0);
                           ir_expression *const r24E7 = rshift(r24B8, r24DC);
                           body.emit(assign(r24DE, bit_or(r24E6, r24E7), 0x01));

                           body.emit(assign(r24DF, rshift(r24B7, r24DC), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f24E4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r24E9 = equal(r24DC, body.constant(int(32)));
                           ir_if *f24E8 = new(mem_ctx) ir_if(operand(r24E9).val);
                           exec_list *const f24E8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f24E8->then_instructions;

                              body.emit(assign(r24DD, r24B8, 0x01));

                              body.emit(assign(r24DE, r24B7, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f24E8->else_instructions;

                              body.emit(assign(r24DB, bit_or(body.constant(0u), r24B8), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r24EB = less(r24DC, body.constant(int(64)));
                              ir_if *f24EA = new(mem_ctx) ir_if(operand(r24EB).val);
                              exec_list *const f24EA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f24EA->then_instructions;

                                 body.emit(assign(r24DD, lshift(r24B7, r24E0), 0x01));

                                 ir_expression *const r24EC = bit_and(r24DC, body.constant(int(31)));
                                 body.emit(assign(r24DE, rshift(r24B7, r24EC), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f24EA->else_instructions;

                                 ir_variable *const r24ED = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r24EF = equal(r24DC, body.constant(int(64)));
                                 ir_if *f24EE = new(mem_ctx) ir_if(operand(r24EF).val);
                                 exec_list *const f24EE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f24EE->then_instructions;

                                    body.emit(assign(r24ED, r24B7, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f24EE->else_instructions;

                                    ir_expression *const r24F0 = nequal(r24B7, body.constant(0u));
                                    ir_expression *const r24F1 = expr(ir_unop_b2i, r24F0);
                                    body.emit(assign(r24ED, expr(ir_unop_i2u, r24F1), 0x01));


                                 body.instructions = f24EE_parent_instructions;
                                 body.emit(f24EE);

                                 /* END IF */

                                 body.emit(assign(r24DD, r24ED, 0x01));

                                 body.emit(assign(r24DE, body.constant(0u), 0x01));


                              body.instructions = f24EA_parent_instructions;
                              body.emit(f24EA);

                              /* END IF */


                           body.instructions = f24E8_parent_instructions;
                           body.emit(f24E8);

                           /* END IF */

                           body.emit(assign(r24DF, body.constant(0u), 0x01));


                        body.instructions = f24E4_parent_instructions;
                        body.emit(f24E4);

                        /* END IF */

                        ir_expression *const r24F2 = nequal(r24DB, body.constant(0u));
                        ir_expression *const r24F3 = expr(ir_unop_b2i, r24F2);
                        ir_expression *const r24F4 = expr(ir_unop_i2u, r24F3);
                        body.emit(assign(r24DD, bit_or(r24DD, r24F4), 0x01));


                     body.instructions = f24E2_parent_instructions;
                     body.emit(f24E2);

                     /* END IF */

                     body.emit(assign(r24B7, r24DF, 0x01));

                     body.emit(assign(r24B8, r24DE, 0x01));

                     body.emit(assign(r24B9, r24DD, 0x01));


                  body.instructions = f24D1_parent_instructions;
                  body.emit(f24D1);

                  /* END IF */

                  body.emit(assign(r24B6, sub(r24B6, r24BA), 0x01));

                  ir_variable *const r24F5 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r24F5, r24B6, 0x01));

                  ir_variable *const r24F6 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r24F6, r24B7, 0x01));

                  ir_variable *const r24F7 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r24F7, r24B8, 0x01));

                  ir_variable *const r24F8 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r24F8, r24B9, 0x01));

                  ir_variable *const r24F9 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r24F9, body.constant(true), 0x01));

                  ir_variable *const r24FA = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r24FB = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r24FB);
                  ir_expression *const r24FC = expr(ir_unop_u2i, r24B9);
                  body.emit(assign(r24FB, less(r24FC, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r24FE = lequal(body.constant(int(2045)), r24B6);
                  ir_if *f24FD = new(mem_ctx) ir_if(operand(r24FE).val);
                  exec_list *const f24FD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24FD->then_instructions;

                     ir_variable *const r24FF = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2501 = less(body.constant(int(2045)), r24B6);
                     ir_if *f2500 = new(mem_ctx) ir_if(operand(r2501).val);
                     exec_list *const f2500_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2500->then_instructions;

                        body.emit(assign(r24FF, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2500->else_instructions;

                        ir_variable *const r2502 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2504 = equal(r24B6, body.constant(int(2045)));
                        ir_if *f2503 = new(mem_ctx) ir_if(operand(r2504).val);
                        exec_list *const f2503_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2503->then_instructions;

                           ir_expression *const r2505 = equal(body.constant(2097151u), r24B7);
                           ir_expression *const r2506 = equal(body.constant(4294967295u), r24B8);
                           body.emit(assign(r2502, logic_and(r2505, r2506), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2503->else_instructions;

                           body.emit(assign(r2502, body.constant(false), 0x01));


                        body.instructions = f2503_parent_instructions;
                        body.emit(f2503);

                        /* END IF */

                        body.emit(assign(r24FF, logic_and(r2502, r24FB), 0x01));


                     body.instructions = f2500_parent_instructions;
                     body.emit(f2500);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2507 = new(mem_ctx) ir_if(operand(r24FF).val);
                     exec_list *const f2507_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2507->then_instructions;

                        ir_variable *const r2508 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2508);
                        ir_expression *const r2509 = lshift(r2392, body.constant(int(31)));
                        body.emit(assign(r2508, add(r2509, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r2508, body.constant(0u), 0x01));

                        body.emit(assign(r24FA, r2508, 0x03));

                        body.emit(assign(r24F9, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2507->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r250B = less(r24B6, body.constant(int(0)));
                        ir_if *f250A = new(mem_ctx) ir_if(operand(r250B).val);
                        exec_list *const f250A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f250A->then_instructions;

                           ir_variable *const r250C = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r250C, r24B9, 0x01));

                           ir_variable *const r250D = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r250D, neg(r24B6), 0x01));

                           ir_variable *const r250E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r250E);
                           ir_variable *const r250F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r250F);
                           ir_variable *const r2510 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r2510);
                           ir_variable *const r2511 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r2512 = neg(r250D);
                           body.emit(assign(r2511, bit_and(r2512, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2514 = equal(r250D, body.constant(int(0)));
                           ir_if *f2513 = new(mem_ctx) ir_if(operand(r2514).val);
                           exec_list *const f2513_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2513->then_instructions;

                              body.emit(assign(r250E, r24B9, 0x01));

                              body.emit(assign(r250F, r24B8, 0x01));

                              body.emit(assign(r2510, r24B7, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2513->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2516 = less(r250D, body.constant(int(32)));
                              ir_if *f2515 = new(mem_ctx) ir_if(operand(r2516).val);
                              exec_list *const f2515_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2515->then_instructions;

                                 body.emit(assign(r250E, lshift(r24B8, r2511), 0x01));

                                 ir_expression *const r2517 = lshift(r24B7, r2511);
                                 ir_expression *const r2518 = rshift(r24B8, r250D);
                                 body.emit(assign(r250F, bit_or(r2517, r2518), 0x01));

                                 body.emit(assign(r2510, rshift(r24B7, r250D), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2515->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r251A = equal(r250D, body.constant(int(32)));
                                 ir_if *f2519 = new(mem_ctx) ir_if(operand(r251A).val);
                                 exec_list *const f2519_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2519->then_instructions;

                                    body.emit(assign(r250E, r24B8, 0x01));

                                    body.emit(assign(r250F, r24B7, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2519->else_instructions;

                                    body.emit(assign(r250C, bit_or(r24B9, r24B8), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r251C = less(r250D, body.constant(int(64)));
                                    ir_if *f251B = new(mem_ctx) ir_if(operand(r251C).val);
                                    exec_list *const f251B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f251B->then_instructions;

                                       body.emit(assign(r250E, lshift(r24B7, r2511), 0x01));

                                       ir_expression *const r251D = bit_and(r250D, body.constant(int(31)));
                                       body.emit(assign(r250F, rshift(r24B7, r251D), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f251B->else_instructions;

                                       ir_variable *const r251E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r2520 = equal(r250D, body.constant(int(64)));
                                       ir_if *f251F = new(mem_ctx) ir_if(operand(r2520).val);
                                       exec_list *const f251F_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f251F->then_instructions;

                                          body.emit(assign(r251E, r24B7, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f251F->else_instructions;

                                          ir_expression *const r2521 = nequal(r24B7, body.constant(0u));
                                          ir_expression *const r2522 = expr(ir_unop_b2i, r2521);
                                          body.emit(assign(r251E, expr(ir_unop_i2u, r2522), 0x01));


                                       body.instructions = f251F_parent_instructions;
                                       body.emit(f251F);

                                       /* END IF */

                                       body.emit(assign(r250E, r251E, 0x01));

                                       body.emit(assign(r250F, body.constant(0u), 0x01));


                                    body.instructions = f251B_parent_instructions;
                                    body.emit(f251B);

                                    /* END IF */


                                 body.instructions = f2519_parent_instructions;
                                 body.emit(f2519);

                                 /* END IF */

                                 body.emit(assign(r2510, body.constant(0u), 0x01));


                              body.instructions = f2515_parent_instructions;
                              body.emit(f2515);

                              /* END IF */

                              ir_expression *const r2523 = nequal(r250C, body.constant(0u));
                              ir_expression *const r2524 = expr(ir_unop_b2i, r2523);
                              ir_expression *const r2525 = expr(ir_unop_i2u, r2524);
                              body.emit(assign(r250E, bit_or(r250E, r2525), 0x01));


                           body.instructions = f2513_parent_instructions;
                           body.emit(f2513);

                           /* END IF */

                           body.emit(assign(r24F6, r2510, 0x01));

                           body.emit(assign(r24F7, r250F, 0x01));

                           body.emit(assign(r24F8, r250E, 0x01));

                           body.emit(assign(r24F5, body.constant(int(0)), 0x01));

                           body.emit(assign(r24FB, less(r250E, body.constant(0u)), 0x01));


                        body.instructions = f250A_parent_instructions;
                        body.emit(f250A);

                        /* END IF */


                     body.instructions = f2507_parent_instructions;
                     body.emit(f2507);

                     /* END IF */


                  body.instructions = f24FD_parent_instructions;
                  body.emit(f24FD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2526 = new(mem_ctx) ir_if(operand(r24F9).val);
                  exec_list *const f2526_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2526->then_instructions;

                     /* IF CONDITION */
                     ir_if *f2527 = new(mem_ctx) ir_if(operand(r24FB).val);
                     exec_list *const f2527_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2527->then_instructions;

                        ir_variable *const r2528 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r2528, add(r24F7, body.constant(1u)), 0x01));

                        ir_expression *const r2529 = less(r2528, r24F7);
                        ir_expression *const r252A = expr(ir_unop_b2i, r2529);
                        ir_expression *const r252B = expr(ir_unop_i2u, r252A);
                        body.emit(assign(r24F6, add(r24F6, r252B), 0x01));

                        ir_expression *const r252C = equal(r24F8, body.constant(0u));
                        ir_expression *const r252D = expr(ir_unop_b2i, r252C);
                        ir_expression *const r252E = expr(ir_unop_i2u, r252D);
                        ir_expression *const r252F = add(r24F8, r252E);
                        ir_expression *const r2530 = bit_and(r252F, body.constant(1u));
                        ir_expression *const r2531 = expr(ir_unop_bit_not, r2530);
                        body.emit(assign(r24F7, bit_and(r2528, r2531), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2527->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2533 = bit_or(r24F6, r24F7);
                        ir_expression *const r2534 = equal(r2533, body.constant(0u));
                        ir_if *f2532 = new(mem_ctx) ir_if(operand(r2534).val);
                        exec_list *const f2532_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2532->then_instructions;

                           body.emit(assign(r24F5, body.constant(int(0)), 0x01));


                        body.instructions = f2532_parent_instructions;
                        body.emit(f2532);

                        /* END IF */


                     body.instructions = f2527_parent_instructions;
                     body.emit(f2527);

                     /* END IF */

                     ir_variable *const r2535 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2535);
                     ir_expression *const r2536 = lshift(r2392, body.constant(int(31)));
                     ir_expression *const r2537 = expr(ir_unop_i2u, r24F5);
                     ir_expression *const r2538 = lshift(r2537, body.constant(int(20)));
                     ir_expression *const r2539 = add(r2536, r2538);
                     body.emit(assign(r2535, add(r2539, r24F6), 0x02));

                     body.emit(assign(r2535, r24F7, 0x01));

                     body.emit(assign(r24FA, r2535, 0x03));

                     body.emit(assign(r24F9, body.constant(false), 0x01));


                  body.instructions = f2526_parent_instructions;
                  body.emit(f2526);

                  /* END IF */

                  body.emit(assign(r2393, r24FA, 0x03));


               body.instructions = f246E_parent_instructions;
               body.emit(f246E);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f246C->else_instructions;

               /* IF CONDITION */
               ir_expression *const r253B = equal(r239C, body.constant(int(2047)));
               ir_if *f253A = new(mem_ctx) ir_if(operand(r253B).val);
               exec_list *const f253A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f253A->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r253D = bit_or(r2399, r239A);
                  ir_expression *const r253E = bit_or(r2397, r2398);
                  ir_expression *const r253F = bit_or(r253D, r253E);
                  ir_expression *const r2540 = nequal(r253F, body.constant(0u));
                  ir_if *f253C = new(mem_ctx) ir_if(operand(r2540).val);
                  exec_list *const f253C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f253C->then_instructions;

                     ir_variable *const r2541 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r2541, swizzle_x(r21C3), 0x01));

                     ir_variable *const r2542 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r2542, body.constant(0u), 0x01));

                     ir_variable *const r2543 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2544 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r2545 = rshift(swizzle_y(r21C3), body.constant(int(19)));
                     ir_expression *const r2546 = bit_and(r2545, body.constant(4095u));
                     ir_expression *const r2547 = equal(r2546, body.constant(4094u));
                     ir_expression *const r2548 = nequal(swizzle_x(r21C3), body.constant(0u));
                     ir_expression *const r2549 = bit_and(swizzle_y(r21C3), body.constant(524287u));
                     ir_expression *const r254A = nequal(r2549, body.constant(0u));
                     ir_expression *const r254B = logic_or(r2548, r254A);
                     body.emit(assign(r2544, logic_and(r2547, r254B), 0x01));

                     ir_variable *const r254C = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r254C, body.constant(false), 0x01));

                     body.emit(assign(r2541, bit_or(swizzle_y(r21C3), body.constant(524288u)), 0x02));

                     body.emit(assign(r2542, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r254E = lshift(swizzle_y(r21C3), body.constant(int(1)));
                     ir_expression *const r254F = lequal(body.constant(4292870144u), r254E);
                     ir_expression *const r2550 = nequal(swizzle_x(r21C3), body.constant(0u));
                     ir_expression *const r2551 = bit_and(swizzle_y(r21C3), body.constant(1048575u));
                     ir_expression *const r2552 = nequal(r2551, body.constant(0u));
                     ir_expression *const r2553 = logic_or(r2550, r2552);
                     ir_expression *const r2554 = logic_and(r254F, r2553);
                     ir_if *f254D = new(mem_ctx) ir_if(operand(r2554).val);
                     exec_list *const f254D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f254D->then_instructions;

                        ir_variable *const r2555 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r2557 = body.constant(false);
                        ir_if *f2556 = new(mem_ctx) ir_if(operand(r2557).val);
                        exec_list *const f2556_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2556->then_instructions;

                           body.emit(assign(r2555, r2542, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2556->else_instructions;

                           body.emit(assign(r2555, r2541, 0x03));


                        body.instructions = f2556_parent_instructions;
                        body.emit(f2556);

                        /* END IF */

                        body.emit(assign(r2543, r2555, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f254D->else_instructions;

                        body.emit(assign(r2543, r2542, 0x03));


                     body.instructions = f254D_parent_instructions;
                     body.emit(f254D);

                     /* END IF */

                     body.emit(assign(r2393, r2543, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f253C->else_instructions;

                     ir_constant_data r2558_data;
                     memset(&r2558_data, 0, sizeof(ir_constant_data));
                     r2558_data.u[0] = 4294967295;
                     r2558_data.u[1] = 4294967295;
                     ir_constant *const r2558 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r2558_data);
                     body.emit(assign(r2393, r2558, 0x03));


                  body.instructions = f253C_parent_instructions;
                  body.emit(f253C);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f253A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r255A = equal(r239C, body.constant(int(0)));
                  ir_if *f2559 = new(mem_ctx) ir_if(operand(r255A).val);
                  exec_list *const f2559_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2559->then_instructions;

                     body.emit(assign(r2396, body.constant(int(1)), 0x01));

                     body.emit(assign(r2395, body.constant(int(1)), 0x01));


                  body.instructions = f2559_parent_instructions;
                  body.emit(f2559);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r255C = less(r2397, r2399);
                  ir_if *f255B = new(mem_ctx) ir_if(operand(r255C).val);
                  exec_list *const f255B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f255B->then_instructions;

                     ir_variable *const r255D = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r255E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r255E, sub(r239A, r2398), 0x01));

                     ir_expression *const r255F = sub(r2399, r2397);
                     ir_expression *const r2560 = less(r239A, r2398);
                     ir_expression *const r2561 = expr(ir_unop_b2i, r2560);
                     ir_expression *const r2562 = expr(ir_unop_i2u, r2561);
                     body.emit(assign(r255D, sub(r255F, r2562), 0x01));

                     body.emit(assign(r239B, add(r2396, body.constant(int(-1))), 0x01));

                     ir_variable *const r2563 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2563, add(r239B, body.constant(int(-10))), 0x01));

                     ir_variable *const r2564 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2564, r255D, 0x01));

                     ir_variable *const r2565 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2565, r255E, 0x01));

                     ir_variable *const r2566 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r2566);
                     ir_variable *const r2567 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2567);
                     /* IF CONDITION */
                     ir_expression *const r2569 = equal(r255D, body.constant(0u));
                     ir_if *f2568 = new(mem_ctx) ir_if(operand(r2569).val);
                     exec_list *const f2568_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2568->then_instructions;

                        body.emit(assign(r2564, r255E, 0x01));

                        body.emit(assign(r2565, body.constant(0u), 0x01));

                        body.emit(assign(r2563, add(r2563, body.constant(int(-32))), 0x01));


                     body.instructions = f2568_parent_instructions;
                     body.emit(f2568);

                     /* END IF */

                     ir_variable *const r256A = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r256A, r2564, 0x01));

                     ir_variable *const r256B = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r256C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r256C);
                     /* IF CONDITION */
                     ir_expression *const r256E = equal(r2564, body.constant(0u));
                     ir_if *f256D = new(mem_ctx) ir_if(operand(r256E).val);
                     exec_list *const f256D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f256D->then_instructions;

                        body.emit(assign(r256B, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f256D->else_instructions;

                        body.emit(assign(r256C, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2570 = bit_and(r2564, body.constant(4294901760u));
                        ir_expression *const r2571 = equal(r2570, body.constant(0u));
                        ir_if *f256F = new(mem_ctx) ir_if(operand(r2571).val);
                        exec_list *const f256F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f256F->then_instructions;

                           body.emit(assign(r256C, body.constant(int(16)), 0x01));

                           body.emit(assign(r256A, lshift(r2564, body.constant(int(16))), 0x01));


                        body.instructions = f256F_parent_instructions;
                        body.emit(f256F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2573 = bit_and(r256A, body.constant(4278190080u));
                        ir_expression *const r2574 = equal(r2573, body.constant(0u));
                        ir_if *f2572 = new(mem_ctx) ir_if(operand(r2574).val);
                        exec_list *const f2572_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2572->then_instructions;

                           body.emit(assign(r256C, add(r256C, body.constant(int(8))), 0x01));

                           body.emit(assign(r256A, lshift(r256A, body.constant(int(8))), 0x01));


                        body.instructions = f2572_parent_instructions;
                        body.emit(f2572);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2576 = bit_and(r256A, body.constant(4026531840u));
                        ir_expression *const r2577 = equal(r2576, body.constant(0u));
                        ir_if *f2575 = new(mem_ctx) ir_if(operand(r2577).val);
                        exec_list *const f2575_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2575->then_instructions;

                           body.emit(assign(r256C, add(r256C, body.constant(int(4))), 0x01));

                           body.emit(assign(r256A, lshift(r256A, body.constant(int(4))), 0x01));


                        body.instructions = f2575_parent_instructions;
                        body.emit(f2575);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2579 = bit_and(r256A, body.constant(3221225472u));
                        ir_expression *const r257A = equal(r2579, body.constant(0u));
                        ir_if *f2578 = new(mem_ctx) ir_if(operand(r257A).val);
                        exec_list *const f2578_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2578->then_instructions;

                           body.emit(assign(r256C, add(r256C, body.constant(int(2))), 0x01));

                           body.emit(assign(r256A, lshift(r256A, body.constant(int(2))), 0x01));


                        body.instructions = f2578_parent_instructions;
                        body.emit(f2578);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r257C = bit_and(r256A, body.constant(2147483648u));
                        ir_expression *const r257D = equal(r257C, body.constant(0u));
                        ir_if *f257B = new(mem_ctx) ir_if(operand(r257D).val);
                        exec_list *const f257B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f257B->then_instructions;

                           body.emit(assign(r256C, add(r256C, body.constant(int(1))), 0x01));


                        body.instructions = f257B_parent_instructions;
                        body.emit(f257B);

                        /* END IF */

                        body.emit(assign(r256B, r256C, 0x01));


                     body.instructions = f256D_parent_instructions;
                     body.emit(f256D);

                     /* END IF */

                     body.emit(assign(r2567, add(r256B, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r257F = lequal(body.constant(int(0)), r2567);
                     ir_if *f257E = new(mem_ctx) ir_if(operand(r257F).val);
                     exec_list *const f257E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f257E->then_instructions;

                        body.emit(assign(r2566, body.constant(0u), 0x01));

                        ir_variable *const r2580 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2580, lshift(r2565, r2567), 0x01));

                        ir_variable *const r2581 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2583 = equal(r2567, body.constant(int(0)));
                        ir_if *f2582 = new(mem_ctx) ir_if(operand(r2583).val);
                        exec_list *const f2582_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2582->then_instructions;

                           body.emit(assign(r2581, r2564, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2582->else_instructions;

                           ir_expression *const r2584 = lshift(r2564, r2567);
                           ir_expression *const r2585 = neg(r2567);
                           ir_expression *const r2586 = bit_and(r2585, body.constant(int(31)));
                           ir_expression *const r2587 = rshift(r2565, r2586);
                           body.emit(assign(r2581, bit_or(r2584, r2587), 0x01));


                        body.instructions = f2582_parent_instructions;
                        body.emit(f2582);

                        /* END IF */

                        body.emit(assign(r2564, r2581, 0x01));

                        body.emit(assign(r2565, r2580, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f257E->else_instructions;

                        ir_variable *const r2588 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2588, body.constant(0u), 0x01));

                        ir_variable *const r2589 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2589, neg(r2567), 0x01));

                        ir_variable *const r258A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r258A);
                        ir_variable *const r258B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r258B);
                        ir_variable *const r258C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r258C);
                        ir_variable *const r258D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r258E = neg(r2589);
                        body.emit(assign(r258D, bit_and(r258E, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2590 = equal(r2589, body.constant(int(0)));
                        ir_if *f258F = new(mem_ctx) ir_if(operand(r2590).val);
                        exec_list *const f258F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f258F->then_instructions;

                           body.emit(assign(r258A, r2588, 0x01));

                           body.emit(assign(r258B, r2565, 0x01));

                           body.emit(assign(r258C, r2564, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f258F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2592 = less(r2589, body.constant(int(32)));
                           ir_if *f2591 = new(mem_ctx) ir_if(operand(r2592).val);
                           exec_list *const f2591_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2591->then_instructions;

                              body.emit(assign(r258A, lshift(r2565, r258D), 0x01));

                              ir_expression *const r2593 = lshift(r2564, r258D);
                              ir_expression *const r2594 = rshift(r2565, r2589);
                              body.emit(assign(r258B, bit_or(r2593, r2594), 0x01));

                              body.emit(assign(r258C, rshift(r2564, r2589), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2591->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2596 = equal(r2589, body.constant(int(32)));
                              ir_if *f2595 = new(mem_ctx) ir_if(operand(r2596).val);
                              exec_list *const f2595_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2595->then_instructions;

                                 body.emit(assign(r258A, r2565, 0x01));

                                 body.emit(assign(r258B, r2564, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2595->else_instructions;

                                 body.emit(assign(r2588, bit_or(body.constant(0u), r2565), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2598 = less(r2589, body.constant(int(64)));
                                 ir_if *f2597 = new(mem_ctx) ir_if(operand(r2598).val);
                                 exec_list *const f2597_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2597->then_instructions;

                                    body.emit(assign(r258A, lshift(r2564, r258D), 0x01));

                                    ir_expression *const r2599 = bit_and(r2589, body.constant(int(31)));
                                    body.emit(assign(r258B, rshift(r2564, r2599), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2597->else_instructions;

                                    ir_variable *const r259A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r259C = equal(r2589, body.constant(int(64)));
                                    ir_if *f259B = new(mem_ctx) ir_if(operand(r259C).val);
                                    exec_list *const f259B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f259B->then_instructions;

                                       body.emit(assign(r259A, r2564, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f259B->else_instructions;

                                       ir_expression *const r259D = nequal(r2564, body.constant(0u));
                                       ir_expression *const r259E = expr(ir_unop_b2i, r259D);
                                       body.emit(assign(r259A, expr(ir_unop_i2u, r259E), 0x01));


                                    body.instructions = f259B_parent_instructions;
                                    body.emit(f259B);

                                    /* END IF */

                                    body.emit(assign(r258A, r259A, 0x01));

                                    body.emit(assign(r258B, body.constant(0u), 0x01));


                                 body.instructions = f2597_parent_instructions;
                                 body.emit(f2597);

                                 /* END IF */


                              body.instructions = f2595_parent_instructions;
                              body.emit(f2595);

                              /* END IF */

                              body.emit(assign(r258C, body.constant(0u), 0x01));


                           body.instructions = f2591_parent_instructions;
                           body.emit(f2591);

                           /* END IF */

                           ir_expression *const r259F = nequal(r2588, body.constant(0u));
                           ir_expression *const r25A0 = expr(ir_unop_b2i, r259F);
                           ir_expression *const r25A1 = expr(ir_unop_i2u, r25A0);
                           body.emit(assign(r258A, bit_or(r258A, r25A1), 0x01));


                        body.instructions = f258F_parent_instructions;
                        body.emit(f258F);

                        /* END IF */

                        body.emit(assign(r2564, r258C, 0x01));

                        body.emit(assign(r2565, r258B, 0x01));

                        body.emit(assign(r2566, r258A, 0x01));


                     body.instructions = f257E_parent_instructions;
                     body.emit(f257E);

                     /* END IF */

                     body.emit(assign(r2563, sub(r2563, r2567), 0x01));

                     ir_variable *const r25A2 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r25A2, r2563, 0x01));

                     ir_variable *const r25A3 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r25A3, r2564, 0x01));

                     ir_variable *const r25A4 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r25A4, r2565, 0x01));

                     ir_variable *const r25A5 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r25A5, r2566, 0x01));

                     ir_variable *const r25A6 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r25A6, body.constant(true), 0x01));

                     ir_variable *const r25A7 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r25A8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r25A8);
                     ir_expression *const r25A9 = expr(ir_unop_u2i, r2566);
                     body.emit(assign(r25A8, less(r25A9, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r25AB = lequal(body.constant(int(2045)), r2563);
                     ir_if *f25AA = new(mem_ctx) ir_if(operand(r25AB).val);
                     exec_list *const f25AA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f25AA->then_instructions;

                        ir_variable *const r25AC = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r25AE = less(body.constant(int(2045)), r2563);
                        ir_if *f25AD = new(mem_ctx) ir_if(operand(r25AE).val);
                        exec_list *const f25AD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25AD->then_instructions;

                           body.emit(assign(r25AC, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f25AD->else_instructions;

                           ir_variable *const r25AF = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r25B1 = equal(r2563, body.constant(int(2045)));
                           ir_if *f25B0 = new(mem_ctx) ir_if(operand(r25B1).val);
                           exec_list *const f25B0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25B0->then_instructions;

                              ir_expression *const r25B2 = equal(body.constant(2097151u), r2564);
                              ir_expression *const r25B3 = equal(body.constant(4294967295u), r2565);
                              body.emit(assign(r25AF, logic_and(r25B2, r25B3), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f25B0->else_instructions;

                              body.emit(assign(r25AF, body.constant(false), 0x01));


                           body.instructions = f25B0_parent_instructions;
                           body.emit(f25B0);

                           /* END IF */

                           body.emit(assign(r25AC, logic_and(r25AF, r25A8), 0x01));


                        body.instructions = f25AD_parent_instructions;
                        body.emit(f25AD);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f25B4 = new(mem_ctx) ir_if(operand(r25AC).val);
                        exec_list *const f25B4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25B4->then_instructions;

                           ir_variable *const r25B5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r25B5);
                           ir_expression *const r25B6 = lshift(r2392, body.constant(int(31)));
                           body.emit(assign(r25B5, add(r25B6, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r25B5, body.constant(0u), 0x01));

                           body.emit(assign(r25A7, r25B5, 0x03));

                           body.emit(assign(r25A6, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f25B4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r25B8 = less(r2563, body.constant(int(0)));
                           ir_if *f25B7 = new(mem_ctx) ir_if(operand(r25B8).val);
                           exec_list *const f25B7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25B7->then_instructions;

                              ir_variable *const r25B9 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r25B9, r2566, 0x01));

                              ir_variable *const r25BA = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r25BA, neg(r2563), 0x01));

                              ir_variable *const r25BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r25BB);
                              ir_variable *const r25BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r25BC);
                              ir_variable *const r25BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r25BD);
                              ir_variable *const r25BE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r25BF = neg(r25BA);
                              body.emit(assign(r25BE, bit_and(r25BF, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r25C1 = equal(r25BA, body.constant(int(0)));
                              ir_if *f25C0 = new(mem_ctx) ir_if(operand(r25C1).val);
                              exec_list *const f25C0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f25C0->then_instructions;

                                 body.emit(assign(r25BB, r2566, 0x01));

                                 body.emit(assign(r25BC, r2565, 0x01));

                                 body.emit(assign(r25BD, r2564, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f25C0->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r25C3 = less(r25BA, body.constant(int(32)));
                                 ir_if *f25C2 = new(mem_ctx) ir_if(operand(r25C3).val);
                                 exec_list *const f25C2_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f25C2->then_instructions;

                                    body.emit(assign(r25BB, lshift(r2565, r25BE), 0x01));

                                    ir_expression *const r25C4 = lshift(r2564, r25BE);
                                    ir_expression *const r25C5 = rshift(r2565, r25BA);
                                    body.emit(assign(r25BC, bit_or(r25C4, r25C5), 0x01));

                                    body.emit(assign(r25BD, rshift(r2564, r25BA), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f25C2->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r25C7 = equal(r25BA, body.constant(int(32)));
                                    ir_if *f25C6 = new(mem_ctx) ir_if(operand(r25C7).val);
                                    exec_list *const f25C6_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f25C6->then_instructions;

                                       body.emit(assign(r25BB, r2565, 0x01));

                                       body.emit(assign(r25BC, r2564, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f25C6->else_instructions;

                                       body.emit(assign(r25B9, bit_or(r2566, r2565), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r25C9 = less(r25BA, body.constant(int(64)));
                                       ir_if *f25C8 = new(mem_ctx) ir_if(operand(r25C9).val);
                                       exec_list *const f25C8_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f25C8->then_instructions;

                                          body.emit(assign(r25BB, lshift(r2564, r25BE), 0x01));

                                          ir_expression *const r25CA = bit_and(r25BA, body.constant(int(31)));
                                          body.emit(assign(r25BC, rshift(r2564, r25CA), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f25C8->else_instructions;

                                          ir_variable *const r25CB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r25CD = equal(r25BA, body.constant(int(64)));
                                          ir_if *f25CC = new(mem_ctx) ir_if(operand(r25CD).val);
                                          exec_list *const f25CC_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f25CC->then_instructions;

                                             body.emit(assign(r25CB, r2564, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f25CC->else_instructions;

                                             ir_expression *const r25CE = nequal(r2564, body.constant(0u));
                                             ir_expression *const r25CF = expr(ir_unop_b2i, r25CE);
                                             body.emit(assign(r25CB, expr(ir_unop_i2u, r25CF), 0x01));


                                          body.instructions = f25CC_parent_instructions;
                                          body.emit(f25CC);

                                          /* END IF */

                                          body.emit(assign(r25BB, r25CB, 0x01));

                                          body.emit(assign(r25BC, body.constant(0u), 0x01));


                                       body.instructions = f25C8_parent_instructions;
                                       body.emit(f25C8);

                                       /* END IF */


                                    body.instructions = f25C6_parent_instructions;
                                    body.emit(f25C6);

                                    /* END IF */

                                    body.emit(assign(r25BD, body.constant(0u), 0x01));


                                 body.instructions = f25C2_parent_instructions;
                                 body.emit(f25C2);

                                 /* END IF */

                                 ir_expression *const r25D0 = nequal(r25B9, body.constant(0u));
                                 ir_expression *const r25D1 = expr(ir_unop_b2i, r25D0);
                                 ir_expression *const r25D2 = expr(ir_unop_i2u, r25D1);
                                 body.emit(assign(r25BB, bit_or(r25BB, r25D2), 0x01));


                              body.instructions = f25C0_parent_instructions;
                              body.emit(f25C0);

                              /* END IF */

                              body.emit(assign(r25A3, r25BD, 0x01));

                              body.emit(assign(r25A4, r25BC, 0x01));

                              body.emit(assign(r25A5, r25BB, 0x01));

                              body.emit(assign(r25A2, body.constant(int(0)), 0x01));

                              body.emit(assign(r25A8, less(r25BB, body.constant(0u)), 0x01));


                           body.instructions = f25B7_parent_instructions;
                           body.emit(f25B7);

                           /* END IF */


                        body.instructions = f25B4_parent_instructions;
                        body.emit(f25B4);

                        /* END IF */


                     body.instructions = f25AA_parent_instructions;
                     body.emit(f25AA);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f25D3 = new(mem_ctx) ir_if(operand(r25A6).val);
                     exec_list *const f25D3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f25D3->then_instructions;

                        /* IF CONDITION */
                        ir_if *f25D4 = new(mem_ctx) ir_if(operand(r25A8).val);
                        exec_list *const f25D4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25D4->then_instructions;

                           ir_variable *const r25D5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r25D5, add(r25A4, body.constant(1u)), 0x01));

                           ir_expression *const r25D6 = less(r25D5, r25A4);
                           ir_expression *const r25D7 = expr(ir_unop_b2i, r25D6);
                           ir_expression *const r25D8 = expr(ir_unop_i2u, r25D7);
                           body.emit(assign(r25A3, add(r25A3, r25D8), 0x01));

                           ir_expression *const r25D9 = equal(r25A5, body.constant(0u));
                           ir_expression *const r25DA = expr(ir_unop_b2i, r25D9);
                           ir_expression *const r25DB = expr(ir_unop_i2u, r25DA);
                           ir_expression *const r25DC = add(r25A5, r25DB);
                           ir_expression *const r25DD = bit_and(r25DC, body.constant(1u));
                           ir_expression *const r25DE = expr(ir_unop_bit_not, r25DD);
                           body.emit(assign(r25A4, bit_and(r25D5, r25DE), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f25D4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r25E0 = bit_or(r25A3, r25A4);
                           ir_expression *const r25E1 = equal(r25E0, body.constant(0u));
                           ir_if *f25DF = new(mem_ctx) ir_if(operand(r25E1).val);
                           exec_list *const f25DF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25DF->then_instructions;

                              body.emit(assign(r25A2, body.constant(int(0)), 0x01));


                           body.instructions = f25DF_parent_instructions;
                           body.emit(f25DF);

                           /* END IF */


                        body.instructions = f25D4_parent_instructions;
                        body.emit(f25D4);

                        /* END IF */

                        ir_variable *const r25E2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r25E2);
                        ir_expression *const r25E3 = lshift(r2392, body.constant(int(31)));
                        ir_expression *const r25E4 = expr(ir_unop_i2u, r25A2);
                        ir_expression *const r25E5 = lshift(r25E4, body.constant(int(20)));
                        ir_expression *const r25E6 = add(r25E3, r25E5);
                        body.emit(assign(r25E2, add(r25E6, r25A3), 0x02));

                        body.emit(assign(r25E2, r25A4, 0x01));

                        body.emit(assign(r25A7, r25E2, 0x03));

                        body.emit(assign(r25A6, body.constant(false), 0x01));


                     body.instructions = f25D3_parent_instructions;
                     body.emit(f25D3);

                     /* END IF */

                     body.emit(assign(r2393, r25A7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f255B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r25E8 = less(r2399, r2397);
                     ir_if *f25E7 = new(mem_ctx) ir_if(operand(r25E8).val);
                     exec_list *const f25E7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f25E7->then_instructions;

                        ir_variable *const r25E9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r25EA = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r25EA, sub(r2398, r239A), 0x01));

                        ir_expression *const r25EB = sub(r2397, r2399);
                        ir_expression *const r25EC = less(r2398, r239A);
                        ir_expression *const r25ED = expr(ir_unop_b2i, r25EC);
                        ir_expression *const r25EE = expr(ir_unop_i2u, r25ED);
                        body.emit(assign(r25E9, sub(r25EB, r25EE), 0x01));

                        body.emit(assign(r2392, bit_xor(r2392, body.constant(1u)), 0x01));

                        body.emit(assign(r239B, add(r2395, body.constant(int(-1))), 0x01));

                        ir_variable *const r25EF = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r25EF, add(r239B, body.constant(int(-10))), 0x01));

                        ir_variable *const r25F0 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r25F0, r25E9, 0x01));

                        ir_variable *const r25F1 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r25F1, r25EA, 0x01));

                        ir_variable *const r25F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r25F2);
                        ir_variable *const r25F3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r25F3);
                        /* IF CONDITION */
                        ir_expression *const r25F5 = equal(r25E9, body.constant(0u));
                        ir_if *f25F4 = new(mem_ctx) ir_if(operand(r25F5).val);
                        exec_list *const f25F4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25F4->then_instructions;

                           body.emit(assign(r25F0, r25EA, 0x01));

                           body.emit(assign(r25F1, body.constant(0u), 0x01));

                           body.emit(assign(r25EF, add(r25EF, body.constant(int(-32))), 0x01));


                        body.instructions = f25F4_parent_instructions;
                        body.emit(f25F4);

                        /* END IF */

                        ir_variable *const r25F6 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r25F6, r25F0, 0x01));

                        ir_variable *const r25F7 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r25F8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r25F8);
                        /* IF CONDITION */
                        ir_expression *const r25FA = equal(r25F0, body.constant(0u));
                        ir_if *f25F9 = new(mem_ctx) ir_if(operand(r25FA).val);
                        exec_list *const f25F9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25F9->then_instructions;

                           body.emit(assign(r25F7, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f25F9->else_instructions;

                           body.emit(assign(r25F8, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r25FC = bit_and(r25F0, body.constant(4294901760u));
                           ir_expression *const r25FD = equal(r25FC, body.constant(0u));
                           ir_if *f25FB = new(mem_ctx) ir_if(operand(r25FD).val);
                           exec_list *const f25FB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25FB->then_instructions;

                              body.emit(assign(r25F8, body.constant(int(16)), 0x01));

                              body.emit(assign(r25F6, lshift(r25F0, body.constant(int(16))), 0x01));


                           body.instructions = f25FB_parent_instructions;
                           body.emit(f25FB);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r25FF = bit_and(r25F6, body.constant(4278190080u));
                           ir_expression *const r2600 = equal(r25FF, body.constant(0u));
                           ir_if *f25FE = new(mem_ctx) ir_if(operand(r2600).val);
                           exec_list *const f25FE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25FE->then_instructions;

                              body.emit(assign(r25F8, add(r25F8, body.constant(int(8))), 0x01));

                              body.emit(assign(r25F6, lshift(r25F6, body.constant(int(8))), 0x01));


                           body.instructions = f25FE_parent_instructions;
                           body.emit(f25FE);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2602 = bit_and(r25F6, body.constant(4026531840u));
                           ir_expression *const r2603 = equal(r2602, body.constant(0u));
                           ir_if *f2601 = new(mem_ctx) ir_if(operand(r2603).val);
                           exec_list *const f2601_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2601->then_instructions;

                              body.emit(assign(r25F8, add(r25F8, body.constant(int(4))), 0x01));

                              body.emit(assign(r25F6, lshift(r25F6, body.constant(int(4))), 0x01));


                           body.instructions = f2601_parent_instructions;
                           body.emit(f2601);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2605 = bit_and(r25F6, body.constant(3221225472u));
                           ir_expression *const r2606 = equal(r2605, body.constant(0u));
                           ir_if *f2604 = new(mem_ctx) ir_if(operand(r2606).val);
                           exec_list *const f2604_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2604->then_instructions;

                              body.emit(assign(r25F8, add(r25F8, body.constant(int(2))), 0x01));

                              body.emit(assign(r25F6, lshift(r25F6, body.constant(int(2))), 0x01));


                           body.instructions = f2604_parent_instructions;
                           body.emit(f2604);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2608 = bit_and(r25F6, body.constant(2147483648u));
                           ir_expression *const r2609 = equal(r2608, body.constant(0u));
                           ir_if *f2607 = new(mem_ctx) ir_if(operand(r2609).val);
                           exec_list *const f2607_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2607->then_instructions;

                              body.emit(assign(r25F8, add(r25F8, body.constant(int(1))), 0x01));


                           body.instructions = f2607_parent_instructions;
                           body.emit(f2607);

                           /* END IF */

                           body.emit(assign(r25F7, r25F8, 0x01));


                        body.instructions = f25F9_parent_instructions;
                        body.emit(f25F9);

                        /* END IF */

                        body.emit(assign(r25F3, add(r25F7, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r260B = lequal(body.constant(int(0)), r25F3);
                        ir_if *f260A = new(mem_ctx) ir_if(operand(r260B).val);
                        exec_list *const f260A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f260A->then_instructions;

                           body.emit(assign(r25F2, body.constant(0u), 0x01));

                           ir_variable *const r260C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r260C, lshift(r25F1, r25F3), 0x01));

                           ir_variable *const r260D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r260F = equal(r25F3, body.constant(int(0)));
                           ir_if *f260E = new(mem_ctx) ir_if(operand(r260F).val);
                           exec_list *const f260E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f260E->then_instructions;

                              body.emit(assign(r260D, r25F0, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f260E->else_instructions;

                              ir_expression *const r2610 = lshift(r25F0, r25F3);
                              ir_expression *const r2611 = neg(r25F3);
                              ir_expression *const r2612 = bit_and(r2611, body.constant(int(31)));
                              ir_expression *const r2613 = rshift(r25F1, r2612);
                              body.emit(assign(r260D, bit_or(r2610, r2613), 0x01));


                           body.instructions = f260E_parent_instructions;
                           body.emit(f260E);

                           /* END IF */

                           body.emit(assign(r25F0, r260D, 0x01));

                           body.emit(assign(r25F1, r260C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f260A->else_instructions;

                           ir_variable *const r2614 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r2614, body.constant(0u), 0x01));

                           ir_variable *const r2615 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2615, neg(r25F3), 0x01));

                           ir_variable *const r2616 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r2616);
                           ir_variable *const r2617 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r2617);
                           ir_variable *const r2618 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r2618);
                           ir_variable *const r2619 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r261A = neg(r2615);
                           body.emit(assign(r2619, bit_and(r261A, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r261C = equal(r2615, body.constant(int(0)));
                           ir_if *f261B = new(mem_ctx) ir_if(operand(r261C).val);
                           exec_list *const f261B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f261B->then_instructions;

                              body.emit(assign(r2616, r2614, 0x01));

                              body.emit(assign(r2617, r25F1, 0x01));

                              body.emit(assign(r2618, r25F0, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f261B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r261E = less(r2615, body.constant(int(32)));
                              ir_if *f261D = new(mem_ctx) ir_if(operand(r261E).val);
                              exec_list *const f261D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f261D->then_instructions;

                                 body.emit(assign(r2616, lshift(r25F1, r2619), 0x01));

                                 ir_expression *const r261F = lshift(r25F0, r2619);
                                 ir_expression *const r2620 = rshift(r25F1, r2615);
                                 body.emit(assign(r2617, bit_or(r261F, r2620), 0x01));

                                 body.emit(assign(r2618, rshift(r25F0, r2615), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f261D->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2622 = equal(r2615, body.constant(int(32)));
                                 ir_if *f2621 = new(mem_ctx) ir_if(operand(r2622).val);
                                 exec_list *const f2621_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2621->then_instructions;

                                    body.emit(assign(r2616, r25F1, 0x01));

                                    body.emit(assign(r2617, r25F0, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2621->else_instructions;

                                    body.emit(assign(r2614, bit_or(body.constant(0u), r25F1), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2624 = less(r2615, body.constant(int(64)));
                                    ir_if *f2623 = new(mem_ctx) ir_if(operand(r2624).val);
                                    exec_list *const f2623_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2623->then_instructions;

                                       body.emit(assign(r2616, lshift(r25F0, r2619), 0x01));

                                       ir_expression *const r2625 = bit_and(r2615, body.constant(int(31)));
                                       body.emit(assign(r2617, rshift(r25F0, r2625), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2623->else_instructions;

                                       ir_variable *const r2626 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r2628 = equal(r2615, body.constant(int(64)));
                                       ir_if *f2627 = new(mem_ctx) ir_if(operand(r2628).val);
                                       exec_list *const f2627_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2627->then_instructions;

                                          body.emit(assign(r2626, r25F0, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2627->else_instructions;

                                          ir_expression *const r2629 = nequal(r25F0, body.constant(0u));
                                          ir_expression *const r262A = expr(ir_unop_b2i, r2629);
                                          body.emit(assign(r2626, expr(ir_unop_i2u, r262A), 0x01));


                                       body.instructions = f2627_parent_instructions;
                                       body.emit(f2627);

                                       /* END IF */

                                       body.emit(assign(r2616, r2626, 0x01));

                                       body.emit(assign(r2617, body.constant(0u), 0x01));


                                    body.instructions = f2623_parent_instructions;
                                    body.emit(f2623);

                                    /* END IF */


                                 body.instructions = f2621_parent_instructions;
                                 body.emit(f2621);

                                 /* END IF */

                                 body.emit(assign(r2618, body.constant(0u), 0x01));


                              body.instructions = f261D_parent_instructions;
                              body.emit(f261D);

                              /* END IF */

                              ir_expression *const r262B = nequal(r2614, body.constant(0u));
                              ir_expression *const r262C = expr(ir_unop_b2i, r262B);
                              ir_expression *const r262D = expr(ir_unop_i2u, r262C);
                              body.emit(assign(r2616, bit_or(r2616, r262D), 0x01));


                           body.instructions = f261B_parent_instructions;
                           body.emit(f261B);

                           /* END IF */

                           body.emit(assign(r25F0, r2618, 0x01));

                           body.emit(assign(r25F1, r2617, 0x01));

                           body.emit(assign(r25F2, r2616, 0x01));


                        body.instructions = f260A_parent_instructions;
                        body.emit(f260A);

                        /* END IF */

                        body.emit(assign(r25EF, sub(r25EF, r25F3), 0x01));

                        ir_variable *const r262E = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r262E, r25EF, 0x01));

                        ir_variable *const r262F = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r262F, r25F0, 0x01));

                        ir_variable *const r2630 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2630, r25F1, 0x01));

                        ir_variable *const r2631 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r2631, r25F2, 0x01));

                        ir_variable *const r2632 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r2632, body.constant(true), 0x01));

                        ir_variable *const r2633 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r2634 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r2634);
                        ir_expression *const r2635 = expr(ir_unop_u2i, r25F2);
                        body.emit(assign(r2634, less(r2635, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2637 = lequal(body.constant(int(2045)), r25EF);
                        ir_if *f2636 = new(mem_ctx) ir_if(operand(r2637).val);
                        exec_list *const f2636_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2636->then_instructions;

                           ir_variable *const r2638 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r263A = less(body.constant(int(2045)), r25EF);
                           ir_if *f2639 = new(mem_ctx) ir_if(operand(r263A).val);
                           exec_list *const f2639_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2639->then_instructions;

                              body.emit(assign(r2638, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2639->else_instructions;

                              ir_variable *const r263B = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r263D = equal(r25EF, body.constant(int(2045)));
                              ir_if *f263C = new(mem_ctx) ir_if(operand(r263D).val);
                              exec_list *const f263C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f263C->then_instructions;

                                 ir_expression *const r263E = equal(body.constant(2097151u), r25F0);
                                 ir_expression *const r263F = equal(body.constant(4294967295u), r25F1);
                                 body.emit(assign(r263B, logic_and(r263E, r263F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f263C->else_instructions;

                                 body.emit(assign(r263B, body.constant(false), 0x01));


                              body.instructions = f263C_parent_instructions;
                              body.emit(f263C);

                              /* END IF */

                              body.emit(assign(r2638, logic_and(r263B, r2634), 0x01));


                           body.instructions = f2639_parent_instructions;
                           body.emit(f2639);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2640 = new(mem_ctx) ir_if(operand(r2638).val);
                           exec_list *const f2640_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2640->then_instructions;

                              ir_variable *const r2641 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2641);
                              ir_expression *const r2642 = lshift(r2392, body.constant(int(31)));
                              body.emit(assign(r2641, add(r2642, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r2641, body.constant(0u), 0x01));

                              body.emit(assign(r2633, r2641, 0x03));

                              body.emit(assign(r2632, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2640->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2644 = less(r25EF, body.constant(int(0)));
                              ir_if *f2643 = new(mem_ctx) ir_if(operand(r2644).val);
                              exec_list *const f2643_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2643->then_instructions;

                                 ir_variable *const r2645 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2645, r25F2, 0x01));

                                 ir_variable *const r2646 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2646, neg(r25EF), 0x01));

                                 ir_variable *const r2647 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2647);
                                 ir_variable *const r2648 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2648);
                                 ir_variable *const r2649 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2649);
                                 ir_variable *const r264A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r264B = neg(r2646);
                                 body.emit(assign(r264A, bit_and(r264B, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r264D = equal(r2646, body.constant(int(0)));
                                 ir_if *f264C = new(mem_ctx) ir_if(operand(r264D).val);
                                 exec_list *const f264C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f264C->then_instructions;

                                    body.emit(assign(r2647, r25F2, 0x01));

                                    body.emit(assign(r2648, r25F1, 0x01));

                                    body.emit(assign(r2649, r25F0, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f264C->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r264F = less(r2646, body.constant(int(32)));
                                    ir_if *f264E = new(mem_ctx) ir_if(operand(r264F).val);
                                    exec_list *const f264E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f264E->then_instructions;

                                       body.emit(assign(r2647, lshift(r25F1, r264A), 0x01));

                                       ir_expression *const r2650 = lshift(r25F0, r264A);
                                       ir_expression *const r2651 = rshift(r25F1, r2646);
                                       body.emit(assign(r2648, bit_or(r2650, r2651), 0x01));

                                       body.emit(assign(r2649, rshift(r25F0, r2646), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f264E->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2653 = equal(r2646, body.constant(int(32)));
                                       ir_if *f2652 = new(mem_ctx) ir_if(operand(r2653).val);
                                       exec_list *const f2652_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2652->then_instructions;

                                          body.emit(assign(r2647, r25F1, 0x01));

                                          body.emit(assign(r2648, r25F0, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2652->else_instructions;

                                          body.emit(assign(r2645, bit_or(r25F2, r25F1), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2655 = less(r2646, body.constant(int(64)));
                                          ir_if *f2654 = new(mem_ctx) ir_if(operand(r2655).val);
                                          exec_list *const f2654_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2654->then_instructions;

                                             body.emit(assign(r2647, lshift(r25F0, r264A), 0x01));

                                             ir_expression *const r2656 = bit_and(r2646, body.constant(int(31)));
                                             body.emit(assign(r2648, rshift(r25F0, r2656), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2654->else_instructions;

                                             ir_variable *const r2657 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2659 = equal(r2646, body.constant(int(64)));
                                             ir_if *f2658 = new(mem_ctx) ir_if(operand(r2659).val);
                                             exec_list *const f2658_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2658->then_instructions;

                                                body.emit(assign(r2657, r25F0, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2658->else_instructions;

                                                ir_expression *const r265A = nequal(r25F0, body.constant(0u));
                                                ir_expression *const r265B = expr(ir_unop_b2i, r265A);
                                                body.emit(assign(r2657, expr(ir_unop_i2u, r265B), 0x01));


                                             body.instructions = f2658_parent_instructions;
                                             body.emit(f2658);

                                             /* END IF */

                                             body.emit(assign(r2647, r2657, 0x01));

                                             body.emit(assign(r2648, body.constant(0u), 0x01));


                                          body.instructions = f2654_parent_instructions;
                                          body.emit(f2654);

                                          /* END IF */


                                       body.instructions = f2652_parent_instructions;
                                       body.emit(f2652);

                                       /* END IF */

                                       body.emit(assign(r2649, body.constant(0u), 0x01));


                                    body.instructions = f264E_parent_instructions;
                                    body.emit(f264E);

                                    /* END IF */

                                    ir_expression *const r265C = nequal(r2645, body.constant(0u));
                                    ir_expression *const r265D = expr(ir_unop_b2i, r265C);
                                    ir_expression *const r265E = expr(ir_unop_i2u, r265D);
                                    body.emit(assign(r2647, bit_or(r2647, r265E), 0x01));


                                 body.instructions = f264C_parent_instructions;
                                 body.emit(f264C);

                                 /* END IF */

                                 body.emit(assign(r262F, r2649, 0x01));

                                 body.emit(assign(r2630, r2648, 0x01));

                                 body.emit(assign(r2631, r2647, 0x01));

                                 body.emit(assign(r262E, body.constant(int(0)), 0x01));

                                 body.emit(assign(r2634, less(r2647, body.constant(0u)), 0x01));


                              body.instructions = f2643_parent_instructions;
                              body.emit(f2643);

                              /* END IF */


                           body.instructions = f2640_parent_instructions;
                           body.emit(f2640);

                           /* END IF */


                        body.instructions = f2636_parent_instructions;
                        body.emit(f2636);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f265F = new(mem_ctx) ir_if(operand(r2632).val);
                        exec_list *const f265F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f265F->then_instructions;

                           /* IF CONDITION */
                           ir_if *f2660 = new(mem_ctx) ir_if(operand(r2634).val);
                           exec_list *const f2660_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2660->then_instructions;

                              ir_variable *const r2661 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r2661, add(r2630, body.constant(1u)), 0x01));

                              ir_expression *const r2662 = less(r2661, r2630);
                              ir_expression *const r2663 = expr(ir_unop_b2i, r2662);
                              ir_expression *const r2664 = expr(ir_unop_i2u, r2663);
                              body.emit(assign(r262F, add(r262F, r2664), 0x01));

                              ir_expression *const r2665 = equal(r2631, body.constant(0u));
                              ir_expression *const r2666 = expr(ir_unop_b2i, r2665);
                              ir_expression *const r2667 = expr(ir_unop_i2u, r2666);
                              ir_expression *const r2668 = add(r2631, r2667);
                              ir_expression *const r2669 = bit_and(r2668, body.constant(1u));
                              ir_expression *const r266A = expr(ir_unop_bit_not, r2669);
                              body.emit(assign(r2630, bit_and(r2661, r266A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2660->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r266C = bit_or(r262F, r2630);
                              ir_expression *const r266D = equal(r266C, body.constant(0u));
                              ir_if *f266B = new(mem_ctx) ir_if(operand(r266D).val);
                              exec_list *const f266B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f266B->then_instructions;

                                 body.emit(assign(r262E, body.constant(int(0)), 0x01));


                              body.instructions = f266B_parent_instructions;
                              body.emit(f266B);

                              /* END IF */


                           body.instructions = f2660_parent_instructions;
                           body.emit(f2660);

                           /* END IF */

                           ir_variable *const r266E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r266E);
                           ir_expression *const r266F = lshift(r2392, body.constant(int(31)));
                           ir_expression *const r2670 = expr(ir_unop_i2u, r262E);
                           ir_expression *const r2671 = lshift(r2670, body.constant(int(20)));
                           ir_expression *const r2672 = add(r266F, r2671);
                           body.emit(assign(r266E, add(r2672, r262F), 0x02));

                           body.emit(assign(r266E, r2630, 0x01));

                           body.emit(assign(r2633, r266E, 0x03));

                           body.emit(assign(r2632, body.constant(false), 0x01));


                        body.instructions = f265F_parent_instructions;
                        body.emit(f265F);

                        /* END IF */

                        body.emit(assign(r2393, r2633, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f25E7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2674 = less(r2398, r239A);
                        ir_if *f2673 = new(mem_ctx) ir_if(operand(r2674).val);
                        exec_list *const f2673_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2673->then_instructions;

                           ir_variable *const r2675 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r2676 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2676, sub(r239A, r2398), 0x01));

                           ir_expression *const r2677 = sub(r2399, r2397);
                           ir_expression *const r2678 = less(r239A, r2398);
                           ir_expression *const r2679 = expr(ir_unop_b2i, r2678);
                           ir_expression *const r267A = expr(ir_unop_i2u, r2679);
                           body.emit(assign(r2675, sub(r2677, r267A), 0x01));

                           body.emit(assign(r239B, add(r2396, body.constant(int(-1))), 0x01));

                           ir_variable *const r267B = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r267B, add(r239B, body.constant(int(-10))), 0x01));

                           ir_variable *const r267C = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r267C, r2675, 0x01));

                           ir_variable *const r267D = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r267D, r2676, 0x01));

                           ir_variable *const r267E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r267E);
                           ir_variable *const r267F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r267F);
                           /* IF CONDITION */
                           ir_expression *const r2681 = equal(r2675, body.constant(0u));
                           ir_if *f2680 = new(mem_ctx) ir_if(operand(r2681).val);
                           exec_list *const f2680_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2680->then_instructions;

                              body.emit(assign(r267C, r2676, 0x01));

                              body.emit(assign(r267D, body.constant(0u), 0x01));

                              body.emit(assign(r267B, add(r267B, body.constant(int(-32))), 0x01));


                           body.instructions = f2680_parent_instructions;
                           body.emit(f2680);

                           /* END IF */

                           ir_variable *const r2682 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r2682, r267C, 0x01));

                           ir_variable *const r2683 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r2684 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2684);
                           /* IF CONDITION */
                           ir_expression *const r2686 = equal(r267C, body.constant(0u));
                           ir_if *f2685 = new(mem_ctx) ir_if(operand(r2686).val);
                           exec_list *const f2685_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2685->then_instructions;

                              body.emit(assign(r2683, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2685->else_instructions;

                              body.emit(assign(r2684, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2688 = bit_and(r267C, body.constant(4294901760u));
                              ir_expression *const r2689 = equal(r2688, body.constant(0u));
                              ir_if *f2687 = new(mem_ctx) ir_if(operand(r2689).val);
                              exec_list *const f2687_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2687->then_instructions;

                                 body.emit(assign(r2684, body.constant(int(16)), 0x01));

                                 body.emit(assign(r2682, lshift(r267C, body.constant(int(16))), 0x01));


                              body.instructions = f2687_parent_instructions;
                              body.emit(f2687);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r268B = bit_and(r2682, body.constant(4278190080u));
                              ir_expression *const r268C = equal(r268B, body.constant(0u));
                              ir_if *f268A = new(mem_ctx) ir_if(operand(r268C).val);
                              exec_list *const f268A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f268A->then_instructions;

                                 body.emit(assign(r2684, add(r2684, body.constant(int(8))), 0x01));

                                 body.emit(assign(r2682, lshift(r2682, body.constant(int(8))), 0x01));


                              body.instructions = f268A_parent_instructions;
                              body.emit(f268A);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r268E = bit_and(r2682, body.constant(4026531840u));
                              ir_expression *const r268F = equal(r268E, body.constant(0u));
                              ir_if *f268D = new(mem_ctx) ir_if(operand(r268F).val);
                              exec_list *const f268D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f268D->then_instructions;

                                 body.emit(assign(r2684, add(r2684, body.constant(int(4))), 0x01));

                                 body.emit(assign(r2682, lshift(r2682, body.constant(int(4))), 0x01));


                              body.instructions = f268D_parent_instructions;
                              body.emit(f268D);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2691 = bit_and(r2682, body.constant(3221225472u));
                              ir_expression *const r2692 = equal(r2691, body.constant(0u));
                              ir_if *f2690 = new(mem_ctx) ir_if(operand(r2692).val);
                              exec_list *const f2690_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2690->then_instructions;

                                 body.emit(assign(r2684, add(r2684, body.constant(int(2))), 0x01));

                                 body.emit(assign(r2682, lshift(r2682, body.constant(int(2))), 0x01));


                              body.instructions = f2690_parent_instructions;
                              body.emit(f2690);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2694 = bit_and(r2682, body.constant(2147483648u));
                              ir_expression *const r2695 = equal(r2694, body.constant(0u));
                              ir_if *f2693 = new(mem_ctx) ir_if(operand(r2695).val);
                              exec_list *const f2693_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2693->then_instructions;

                                 body.emit(assign(r2684, add(r2684, body.constant(int(1))), 0x01));


                              body.instructions = f2693_parent_instructions;
                              body.emit(f2693);

                              /* END IF */

                              body.emit(assign(r2683, r2684, 0x01));


                           body.instructions = f2685_parent_instructions;
                           body.emit(f2685);

                           /* END IF */

                           body.emit(assign(r267F, add(r2683, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2697 = lequal(body.constant(int(0)), r267F);
                           ir_if *f2696 = new(mem_ctx) ir_if(operand(r2697).val);
                           exec_list *const f2696_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2696->then_instructions;

                              body.emit(assign(r267E, body.constant(0u), 0x01));

                              ir_variable *const r2698 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2698, lshift(r267D, r267F), 0x01));

                              ir_variable *const r2699 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r269B = equal(r267F, body.constant(int(0)));
                              ir_if *f269A = new(mem_ctx) ir_if(operand(r269B).val);
                              exec_list *const f269A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f269A->then_instructions;

                                 body.emit(assign(r2699, r267C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f269A->else_instructions;

                                 ir_expression *const r269C = lshift(r267C, r267F);
                                 ir_expression *const r269D = neg(r267F);
                                 ir_expression *const r269E = bit_and(r269D, body.constant(int(31)));
                                 ir_expression *const r269F = rshift(r267D, r269E);
                                 body.emit(assign(r2699, bit_or(r269C, r269F), 0x01));


                              body.instructions = f269A_parent_instructions;
                              body.emit(f269A);

                              /* END IF */

                              body.emit(assign(r267C, r2699, 0x01));

                              body.emit(assign(r267D, r2698, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2696->else_instructions;

                              ir_variable *const r26A0 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r26A0, body.constant(0u), 0x01));

                              ir_variable *const r26A1 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r26A1, neg(r267F), 0x01));

                              ir_variable *const r26A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r26A2);
                              ir_variable *const r26A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r26A3);
                              ir_variable *const r26A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r26A4);
                              ir_variable *const r26A5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r26A6 = neg(r26A1);
                              body.emit(assign(r26A5, bit_and(r26A6, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r26A8 = equal(r26A1, body.constant(int(0)));
                              ir_if *f26A7 = new(mem_ctx) ir_if(operand(r26A8).val);
                              exec_list *const f26A7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f26A7->then_instructions;

                                 body.emit(assign(r26A2, r26A0, 0x01));

                                 body.emit(assign(r26A3, r267D, 0x01));

                                 body.emit(assign(r26A4, r267C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f26A7->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r26AA = less(r26A1, body.constant(int(32)));
                                 ir_if *f26A9 = new(mem_ctx) ir_if(operand(r26AA).val);
                                 exec_list *const f26A9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26A9->then_instructions;

                                    body.emit(assign(r26A2, lshift(r267D, r26A5), 0x01));

                                    ir_expression *const r26AB = lshift(r267C, r26A5);
                                    ir_expression *const r26AC = rshift(r267D, r26A1);
                                    body.emit(assign(r26A3, bit_or(r26AB, r26AC), 0x01));

                                    body.emit(assign(r26A4, rshift(r267C, r26A1), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26A9->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r26AE = equal(r26A1, body.constant(int(32)));
                                    ir_if *f26AD = new(mem_ctx) ir_if(operand(r26AE).val);
                                    exec_list *const f26AD_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f26AD->then_instructions;

                                       body.emit(assign(r26A2, r267D, 0x01));

                                       body.emit(assign(r26A3, r267C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f26AD->else_instructions;

                                       body.emit(assign(r26A0, bit_or(body.constant(0u), r267D), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r26B0 = less(r26A1, body.constant(int(64)));
                                       ir_if *f26AF = new(mem_ctx) ir_if(operand(r26B0).val);
                                       exec_list *const f26AF_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f26AF->then_instructions;

                                          body.emit(assign(r26A2, lshift(r267C, r26A5), 0x01));

                                          ir_expression *const r26B1 = bit_and(r26A1, body.constant(int(31)));
                                          body.emit(assign(r26A3, rshift(r267C, r26B1), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f26AF->else_instructions;

                                          ir_variable *const r26B2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r26B4 = equal(r26A1, body.constant(int(64)));
                                          ir_if *f26B3 = new(mem_ctx) ir_if(operand(r26B4).val);
                                          exec_list *const f26B3_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f26B3->then_instructions;

                                             body.emit(assign(r26B2, r267C, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f26B3->else_instructions;

                                             ir_expression *const r26B5 = nequal(r267C, body.constant(0u));
                                             ir_expression *const r26B6 = expr(ir_unop_b2i, r26B5);
                                             body.emit(assign(r26B2, expr(ir_unop_i2u, r26B6), 0x01));


                                          body.instructions = f26B3_parent_instructions;
                                          body.emit(f26B3);

                                          /* END IF */

                                          body.emit(assign(r26A2, r26B2, 0x01));

                                          body.emit(assign(r26A3, body.constant(0u), 0x01));


                                       body.instructions = f26AF_parent_instructions;
                                       body.emit(f26AF);

                                       /* END IF */


                                    body.instructions = f26AD_parent_instructions;
                                    body.emit(f26AD);

                                    /* END IF */

                                    body.emit(assign(r26A4, body.constant(0u), 0x01));


                                 body.instructions = f26A9_parent_instructions;
                                 body.emit(f26A9);

                                 /* END IF */

                                 ir_expression *const r26B7 = nequal(r26A0, body.constant(0u));
                                 ir_expression *const r26B8 = expr(ir_unop_b2i, r26B7);
                                 ir_expression *const r26B9 = expr(ir_unop_i2u, r26B8);
                                 body.emit(assign(r26A2, bit_or(r26A2, r26B9), 0x01));


                              body.instructions = f26A7_parent_instructions;
                              body.emit(f26A7);

                              /* END IF */

                              body.emit(assign(r267C, r26A4, 0x01));

                              body.emit(assign(r267D, r26A3, 0x01));

                              body.emit(assign(r267E, r26A2, 0x01));


                           body.instructions = f2696_parent_instructions;
                           body.emit(f2696);

                           /* END IF */

                           body.emit(assign(r267B, sub(r267B, r267F), 0x01));

                           ir_variable *const r26BA = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r26BA, r267B, 0x01));

                           ir_variable *const r26BB = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r26BB, r267C, 0x01));

                           ir_variable *const r26BC = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r26BC, r267D, 0x01));

                           ir_variable *const r26BD = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r26BD, r267E, 0x01));

                           ir_variable *const r26BE = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r26BE, body.constant(true), 0x01));

                           ir_variable *const r26BF = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r26C0 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r26C0);
                           ir_expression *const r26C1 = expr(ir_unop_u2i, r267E);
                           body.emit(assign(r26C0, less(r26C1, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r26C3 = lequal(body.constant(int(2045)), r267B);
                           ir_if *f26C2 = new(mem_ctx) ir_if(operand(r26C3).val);
                           exec_list *const f26C2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f26C2->then_instructions;

                              ir_variable *const r26C4 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r26C6 = less(body.constant(int(2045)), r267B);
                              ir_if *f26C5 = new(mem_ctx) ir_if(operand(r26C6).val);
                              exec_list *const f26C5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f26C5->then_instructions;

                                 body.emit(assign(r26C4, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f26C5->else_instructions;

                                 ir_variable *const r26C7 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r26C9 = equal(r267B, body.constant(int(2045)));
                                 ir_if *f26C8 = new(mem_ctx) ir_if(operand(r26C9).val);
                                 exec_list *const f26C8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26C8->then_instructions;

                                    ir_expression *const r26CA = equal(body.constant(2097151u), r267C);
                                    ir_expression *const r26CB = equal(body.constant(4294967295u), r267D);
                                    body.emit(assign(r26C7, logic_and(r26CA, r26CB), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26C8->else_instructions;

                                    body.emit(assign(r26C7, body.constant(false), 0x01));


                                 body.instructions = f26C8_parent_instructions;
                                 body.emit(f26C8);

                                 /* END IF */

                                 body.emit(assign(r26C4, logic_and(r26C7, r26C0), 0x01));


                              body.instructions = f26C5_parent_instructions;
                              body.emit(f26C5);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f26CC = new(mem_ctx) ir_if(operand(r26C4).val);
                              exec_list *const f26CC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f26CC->then_instructions;

                                 ir_variable *const r26CD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r26CD);
                                 ir_expression *const r26CE = lshift(r2392, body.constant(int(31)));
                                 body.emit(assign(r26CD, add(r26CE, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r26CD, body.constant(0u), 0x01));

                                 body.emit(assign(r26BF, r26CD, 0x03));

                                 body.emit(assign(r26BE, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f26CC->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r26D0 = less(r267B, body.constant(int(0)));
                                 ir_if *f26CF = new(mem_ctx) ir_if(operand(r26D0).val);
                                 exec_list *const f26CF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26CF->then_instructions;

                                    ir_variable *const r26D1 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r26D1, r267E, 0x01));

                                    ir_variable *const r26D2 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r26D2, neg(r267B), 0x01));

                                    ir_variable *const r26D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r26D3);
                                    ir_variable *const r26D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r26D4);
                                    ir_variable *const r26D5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r26D5);
                                    ir_variable *const r26D6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r26D7 = neg(r26D2);
                                    body.emit(assign(r26D6, bit_and(r26D7, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r26D9 = equal(r26D2, body.constant(int(0)));
                                    ir_if *f26D8 = new(mem_ctx) ir_if(operand(r26D9).val);
                                    exec_list *const f26D8_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f26D8->then_instructions;

                                       body.emit(assign(r26D3, r267E, 0x01));

                                       body.emit(assign(r26D4, r267D, 0x01));

                                       body.emit(assign(r26D5, r267C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f26D8->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r26DB = less(r26D2, body.constant(int(32)));
                                       ir_if *f26DA = new(mem_ctx) ir_if(operand(r26DB).val);
                                       exec_list *const f26DA_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f26DA->then_instructions;

                                          body.emit(assign(r26D3, lshift(r267D, r26D6), 0x01));

                                          ir_expression *const r26DC = lshift(r267C, r26D6);
                                          ir_expression *const r26DD = rshift(r267D, r26D2);
                                          body.emit(assign(r26D4, bit_or(r26DC, r26DD), 0x01));

                                          body.emit(assign(r26D5, rshift(r267C, r26D2), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f26DA->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r26DF = equal(r26D2, body.constant(int(32)));
                                          ir_if *f26DE = new(mem_ctx) ir_if(operand(r26DF).val);
                                          exec_list *const f26DE_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f26DE->then_instructions;

                                             body.emit(assign(r26D3, r267D, 0x01));

                                             body.emit(assign(r26D4, r267C, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f26DE->else_instructions;

                                             body.emit(assign(r26D1, bit_or(r267E, r267D), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r26E1 = less(r26D2, body.constant(int(64)));
                                             ir_if *f26E0 = new(mem_ctx) ir_if(operand(r26E1).val);
                                             exec_list *const f26E0_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f26E0->then_instructions;

                                                body.emit(assign(r26D3, lshift(r267C, r26D6), 0x01));

                                                ir_expression *const r26E2 = bit_and(r26D2, body.constant(int(31)));
                                                body.emit(assign(r26D4, rshift(r267C, r26E2), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f26E0->else_instructions;

                                                ir_variable *const r26E3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r26E5 = equal(r26D2, body.constant(int(64)));
                                                ir_if *f26E4 = new(mem_ctx) ir_if(operand(r26E5).val);
                                                exec_list *const f26E4_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f26E4->then_instructions;

                                                   body.emit(assign(r26E3, r267C, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f26E4->else_instructions;

                                                   ir_expression *const r26E6 = nequal(r267C, body.constant(0u));
                                                   ir_expression *const r26E7 = expr(ir_unop_b2i, r26E6);
                                                   body.emit(assign(r26E3, expr(ir_unop_i2u, r26E7), 0x01));


                                                body.instructions = f26E4_parent_instructions;
                                                body.emit(f26E4);

                                                /* END IF */

                                                body.emit(assign(r26D3, r26E3, 0x01));

                                                body.emit(assign(r26D4, body.constant(0u), 0x01));


                                             body.instructions = f26E0_parent_instructions;
                                             body.emit(f26E0);

                                             /* END IF */


                                          body.instructions = f26DE_parent_instructions;
                                          body.emit(f26DE);

                                          /* END IF */

                                          body.emit(assign(r26D5, body.constant(0u), 0x01));


                                       body.instructions = f26DA_parent_instructions;
                                       body.emit(f26DA);

                                       /* END IF */

                                       ir_expression *const r26E8 = nequal(r26D1, body.constant(0u));
                                       ir_expression *const r26E9 = expr(ir_unop_b2i, r26E8);
                                       ir_expression *const r26EA = expr(ir_unop_i2u, r26E9);
                                       body.emit(assign(r26D3, bit_or(r26D3, r26EA), 0x01));


                                    body.instructions = f26D8_parent_instructions;
                                    body.emit(f26D8);

                                    /* END IF */

                                    body.emit(assign(r26BB, r26D5, 0x01));

                                    body.emit(assign(r26BC, r26D4, 0x01));

                                    body.emit(assign(r26BD, r26D3, 0x01));

                                    body.emit(assign(r26BA, body.constant(int(0)), 0x01));

                                    body.emit(assign(r26C0, less(r26D3, body.constant(0u)), 0x01));


                                 body.instructions = f26CF_parent_instructions;
                                 body.emit(f26CF);

                                 /* END IF */


                              body.instructions = f26CC_parent_instructions;
                              body.emit(f26CC);

                              /* END IF */


                           body.instructions = f26C2_parent_instructions;
                           body.emit(f26C2);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f26EB = new(mem_ctx) ir_if(operand(r26BE).val);
                           exec_list *const f26EB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f26EB->then_instructions;

                              /* IF CONDITION */
                              ir_if *f26EC = new(mem_ctx) ir_if(operand(r26C0).val);
                              exec_list *const f26EC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f26EC->then_instructions;

                                 ir_variable *const r26ED = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r26ED, add(r26BC, body.constant(1u)), 0x01));

                                 ir_expression *const r26EE = less(r26ED, r26BC);
                                 ir_expression *const r26EF = expr(ir_unop_b2i, r26EE);
                                 ir_expression *const r26F0 = expr(ir_unop_i2u, r26EF);
                                 body.emit(assign(r26BB, add(r26BB, r26F0), 0x01));

                                 ir_expression *const r26F1 = equal(r26BD, body.constant(0u));
                                 ir_expression *const r26F2 = expr(ir_unop_b2i, r26F1);
                                 ir_expression *const r26F3 = expr(ir_unop_i2u, r26F2);
                                 ir_expression *const r26F4 = add(r26BD, r26F3);
                                 ir_expression *const r26F5 = bit_and(r26F4, body.constant(1u));
                                 ir_expression *const r26F6 = expr(ir_unop_bit_not, r26F5);
                                 body.emit(assign(r26BC, bit_and(r26ED, r26F6), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f26EC->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r26F8 = bit_or(r26BB, r26BC);
                                 ir_expression *const r26F9 = equal(r26F8, body.constant(0u));
                                 ir_if *f26F7 = new(mem_ctx) ir_if(operand(r26F9).val);
                                 exec_list *const f26F7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26F7->then_instructions;

                                    body.emit(assign(r26BA, body.constant(int(0)), 0x01));


                                 body.instructions = f26F7_parent_instructions;
                                 body.emit(f26F7);

                                 /* END IF */


                              body.instructions = f26EC_parent_instructions;
                              body.emit(f26EC);

                              /* END IF */

                              ir_variable *const r26FA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r26FA);
                              ir_expression *const r26FB = lshift(r2392, body.constant(int(31)));
                              ir_expression *const r26FC = expr(ir_unop_i2u, r26BA);
                              ir_expression *const r26FD = lshift(r26FC, body.constant(int(20)));
                              ir_expression *const r26FE = add(r26FB, r26FD);
                              body.emit(assign(r26FA, add(r26FE, r26BB), 0x02));

                              body.emit(assign(r26FA, r26BC, 0x01));

                              body.emit(assign(r26BF, r26FA, 0x03));

                              body.emit(assign(r26BE, body.constant(false), 0x01));


                           body.instructions = f26EB_parent_instructions;
                           body.emit(f26EB);

                           /* END IF */

                           body.emit(assign(r2393, r26BF, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2673->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2700 = less(r239A, r2398);
                           ir_if *f26FF = new(mem_ctx) ir_if(operand(r2700).val);
                           exec_list *const f26FF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f26FF->then_instructions;

                              ir_variable *const r2701 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r2702 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2702, sub(r2398, r239A), 0x01));

                              ir_expression *const r2703 = sub(r2397, r2399);
                              ir_expression *const r2704 = less(r2398, r239A);
                              ir_expression *const r2705 = expr(ir_unop_b2i, r2704);
                              ir_expression *const r2706 = expr(ir_unop_i2u, r2705);
                              body.emit(assign(r2701, sub(r2703, r2706), 0x01));

                              body.emit(assign(r2392, bit_xor(r2392, body.constant(1u)), 0x01));

                              body.emit(assign(r239B, add(r2395, body.constant(int(-1))), 0x01));

                              ir_variable *const r2707 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2707, add(r239B, body.constant(int(-10))), 0x01));

                              ir_variable *const r2708 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2708, r2701, 0x01));

                              ir_variable *const r2709 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2709, r2702, 0x01));

                              ir_variable *const r270A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r270A);
                              ir_variable *const r270B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r270B);
                              /* IF CONDITION */
                              ir_expression *const r270D = equal(r2701, body.constant(0u));
                              ir_if *f270C = new(mem_ctx) ir_if(operand(r270D).val);
                              exec_list *const f270C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f270C->then_instructions;

                                 body.emit(assign(r2708, r2702, 0x01));

                                 body.emit(assign(r2709, body.constant(0u), 0x01));

                                 body.emit(assign(r2707, add(r2707, body.constant(int(-32))), 0x01));


                              body.instructions = f270C_parent_instructions;
                              body.emit(f270C);

                              /* END IF */

                              ir_variable *const r270E = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r270E, r2708, 0x01));

                              ir_variable *const r270F = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r2710 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2710);
                              /* IF CONDITION */
                              ir_expression *const r2712 = equal(r2708, body.constant(0u));
                              ir_if *f2711 = new(mem_ctx) ir_if(operand(r2712).val);
                              exec_list *const f2711_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2711->then_instructions;

                                 body.emit(assign(r270F, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2711->else_instructions;

                                 body.emit(assign(r2710, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2714 = bit_and(r2708, body.constant(4294901760u));
                                 ir_expression *const r2715 = equal(r2714, body.constant(0u));
                                 ir_if *f2713 = new(mem_ctx) ir_if(operand(r2715).val);
                                 exec_list *const f2713_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2713->then_instructions;

                                    body.emit(assign(r2710, body.constant(int(16)), 0x01));

                                    body.emit(assign(r270E, lshift(r2708, body.constant(int(16))), 0x01));


                                 body.instructions = f2713_parent_instructions;
                                 body.emit(f2713);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2717 = bit_and(r270E, body.constant(4278190080u));
                                 ir_expression *const r2718 = equal(r2717, body.constant(0u));
                                 ir_if *f2716 = new(mem_ctx) ir_if(operand(r2718).val);
                                 exec_list *const f2716_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2716->then_instructions;

                                    body.emit(assign(r2710, add(r2710, body.constant(int(8))), 0x01));

                                    body.emit(assign(r270E, lshift(r270E, body.constant(int(8))), 0x01));


                                 body.instructions = f2716_parent_instructions;
                                 body.emit(f2716);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r271A = bit_and(r270E, body.constant(4026531840u));
                                 ir_expression *const r271B = equal(r271A, body.constant(0u));
                                 ir_if *f2719 = new(mem_ctx) ir_if(operand(r271B).val);
                                 exec_list *const f2719_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2719->then_instructions;

                                    body.emit(assign(r2710, add(r2710, body.constant(int(4))), 0x01));

                                    body.emit(assign(r270E, lshift(r270E, body.constant(int(4))), 0x01));


                                 body.instructions = f2719_parent_instructions;
                                 body.emit(f2719);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r271D = bit_and(r270E, body.constant(3221225472u));
                                 ir_expression *const r271E = equal(r271D, body.constant(0u));
                                 ir_if *f271C = new(mem_ctx) ir_if(operand(r271E).val);
                                 exec_list *const f271C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f271C->then_instructions;

                                    body.emit(assign(r2710, add(r2710, body.constant(int(2))), 0x01));

                                    body.emit(assign(r270E, lshift(r270E, body.constant(int(2))), 0x01));


                                 body.instructions = f271C_parent_instructions;
                                 body.emit(f271C);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2720 = bit_and(r270E, body.constant(2147483648u));
                                 ir_expression *const r2721 = equal(r2720, body.constant(0u));
                                 ir_if *f271F = new(mem_ctx) ir_if(operand(r2721).val);
                                 exec_list *const f271F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f271F->then_instructions;

                                    body.emit(assign(r2710, add(r2710, body.constant(int(1))), 0x01));


                                 body.instructions = f271F_parent_instructions;
                                 body.emit(f271F);

                                 /* END IF */

                                 body.emit(assign(r270F, r2710, 0x01));


                              body.instructions = f2711_parent_instructions;
                              body.emit(f2711);

                              /* END IF */

                              body.emit(assign(r270B, add(r270F, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2723 = lequal(body.constant(int(0)), r270B);
                              ir_if *f2722 = new(mem_ctx) ir_if(operand(r2723).val);
                              exec_list *const f2722_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2722->then_instructions;

                                 body.emit(assign(r270A, body.constant(0u), 0x01));

                                 ir_variable *const r2724 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r2724, lshift(r2709, r270B), 0x01));

                                 ir_variable *const r2725 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2727 = equal(r270B, body.constant(int(0)));
                                 ir_if *f2726 = new(mem_ctx) ir_if(operand(r2727).val);
                                 exec_list *const f2726_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2726->then_instructions;

                                    body.emit(assign(r2725, r2708, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2726->else_instructions;

                                    ir_expression *const r2728 = lshift(r2708, r270B);
                                    ir_expression *const r2729 = neg(r270B);
                                    ir_expression *const r272A = bit_and(r2729, body.constant(int(31)));
                                    ir_expression *const r272B = rshift(r2709, r272A);
                                    body.emit(assign(r2725, bit_or(r2728, r272B), 0x01));


                                 body.instructions = f2726_parent_instructions;
                                 body.emit(f2726);

                                 /* END IF */

                                 body.emit(assign(r2708, r2725, 0x01));

                                 body.emit(assign(r2709, r2724, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2722->else_instructions;

                                 ir_variable *const r272C = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r272C, body.constant(0u), 0x01));

                                 ir_variable *const r272D = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r272D, neg(r270B), 0x01));

                                 ir_variable *const r272E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r272E);
                                 ir_variable *const r272F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r272F);
                                 ir_variable *const r2730 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2730);
                                 ir_variable *const r2731 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2732 = neg(r272D);
                                 body.emit(assign(r2731, bit_and(r2732, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2734 = equal(r272D, body.constant(int(0)));
                                 ir_if *f2733 = new(mem_ctx) ir_if(operand(r2734).val);
                                 exec_list *const f2733_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2733->then_instructions;

                                    body.emit(assign(r272E, r272C, 0x01));

                                    body.emit(assign(r272F, r2709, 0x01));

                                    body.emit(assign(r2730, r2708, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2733->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2736 = less(r272D, body.constant(int(32)));
                                    ir_if *f2735 = new(mem_ctx) ir_if(operand(r2736).val);
                                    exec_list *const f2735_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2735->then_instructions;

                                       body.emit(assign(r272E, lshift(r2709, r2731), 0x01));

                                       ir_expression *const r2737 = lshift(r2708, r2731);
                                       ir_expression *const r2738 = rshift(r2709, r272D);
                                       body.emit(assign(r272F, bit_or(r2737, r2738), 0x01));

                                       body.emit(assign(r2730, rshift(r2708, r272D), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2735->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r273A = equal(r272D, body.constant(int(32)));
                                       ir_if *f2739 = new(mem_ctx) ir_if(operand(r273A).val);
                                       exec_list *const f2739_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2739->then_instructions;

                                          body.emit(assign(r272E, r2709, 0x01));

                                          body.emit(assign(r272F, r2708, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2739->else_instructions;

                                          body.emit(assign(r272C, bit_or(body.constant(0u), r2709), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r273C = less(r272D, body.constant(int(64)));
                                          ir_if *f273B = new(mem_ctx) ir_if(operand(r273C).val);
                                          exec_list *const f273B_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f273B->then_instructions;

                                             body.emit(assign(r272E, lshift(r2708, r2731), 0x01));

                                             ir_expression *const r273D = bit_and(r272D, body.constant(int(31)));
                                             body.emit(assign(r272F, rshift(r2708, r273D), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f273B->else_instructions;

                                             ir_variable *const r273E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2740 = equal(r272D, body.constant(int(64)));
                                             ir_if *f273F = new(mem_ctx) ir_if(operand(r2740).val);
                                             exec_list *const f273F_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f273F->then_instructions;

                                                body.emit(assign(r273E, r2708, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f273F->else_instructions;

                                                ir_expression *const r2741 = nequal(r2708, body.constant(0u));
                                                ir_expression *const r2742 = expr(ir_unop_b2i, r2741);
                                                body.emit(assign(r273E, expr(ir_unop_i2u, r2742), 0x01));


                                             body.instructions = f273F_parent_instructions;
                                             body.emit(f273F);

                                             /* END IF */

                                             body.emit(assign(r272E, r273E, 0x01));

                                             body.emit(assign(r272F, body.constant(0u), 0x01));


                                          body.instructions = f273B_parent_instructions;
                                          body.emit(f273B);

                                          /* END IF */


                                       body.instructions = f2739_parent_instructions;
                                       body.emit(f2739);

                                       /* END IF */

                                       body.emit(assign(r2730, body.constant(0u), 0x01));


                                    body.instructions = f2735_parent_instructions;
                                    body.emit(f2735);

                                    /* END IF */

                                    ir_expression *const r2743 = nequal(r272C, body.constant(0u));
                                    ir_expression *const r2744 = expr(ir_unop_b2i, r2743);
                                    ir_expression *const r2745 = expr(ir_unop_i2u, r2744);
                                    body.emit(assign(r272E, bit_or(r272E, r2745), 0x01));


                                 body.instructions = f2733_parent_instructions;
                                 body.emit(f2733);

                                 /* END IF */

                                 body.emit(assign(r2708, r2730, 0x01));

                                 body.emit(assign(r2709, r272F, 0x01));

                                 body.emit(assign(r270A, r272E, 0x01));


                              body.instructions = f2722_parent_instructions;
                              body.emit(f2722);

                              /* END IF */

                              body.emit(assign(r2707, sub(r2707, r270B), 0x01));

                              ir_variable *const r2746 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2746, r2707, 0x01));

                              ir_variable *const r2747 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2747, r2708, 0x01));

                              ir_variable *const r2748 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2748, r2709, 0x01));

                              ir_variable *const r2749 = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r2749, r270A, 0x01));

                              ir_variable *const r274A = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r274A, body.constant(true), 0x01));

                              ir_variable *const r274B = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r274C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r274C);
                              ir_expression *const r274D = expr(ir_unop_u2i, r270A);
                              body.emit(assign(r274C, less(r274D, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r274F = lequal(body.constant(int(2045)), r2707);
                              ir_if *f274E = new(mem_ctx) ir_if(operand(r274F).val);
                              exec_list *const f274E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f274E->then_instructions;

                                 ir_variable *const r2750 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2752 = less(body.constant(int(2045)), r2707);
                                 ir_if *f2751 = new(mem_ctx) ir_if(operand(r2752).val);
                                 exec_list *const f2751_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2751->then_instructions;

                                    body.emit(assign(r2750, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2751->else_instructions;

                                    ir_variable *const r2753 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2755 = equal(r2707, body.constant(int(2045)));
                                    ir_if *f2754 = new(mem_ctx) ir_if(operand(r2755).val);
                                    exec_list *const f2754_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2754->then_instructions;

                                       ir_expression *const r2756 = equal(body.constant(2097151u), r2708);
                                       ir_expression *const r2757 = equal(body.constant(4294967295u), r2709);
                                       body.emit(assign(r2753, logic_and(r2756, r2757), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2754->else_instructions;

                                       body.emit(assign(r2753, body.constant(false), 0x01));


                                    body.instructions = f2754_parent_instructions;
                                    body.emit(f2754);

                                    /* END IF */

                                    body.emit(assign(r2750, logic_and(r2753, r274C), 0x01));


                                 body.instructions = f2751_parent_instructions;
                                 body.emit(f2751);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f2758 = new(mem_ctx) ir_if(operand(r2750).val);
                                 exec_list *const f2758_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2758->then_instructions;

                                    ir_variable *const r2759 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r2759);
                                    ir_expression *const r275A = lshift(r2392, body.constant(int(31)));
                                    body.emit(assign(r2759, add(r275A, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r2759, body.constant(0u), 0x01));

                                    body.emit(assign(r274B, r2759, 0x03));

                                    body.emit(assign(r274A, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2758->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r275C = less(r2707, body.constant(int(0)));
                                    ir_if *f275B = new(mem_ctx) ir_if(operand(r275C).val);
                                    exec_list *const f275B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f275B->then_instructions;

                                       ir_variable *const r275D = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r275D, r270A, 0x01));

                                       ir_variable *const r275E = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r275E, neg(r2707), 0x01));

                                       ir_variable *const r275F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r275F);
                                       ir_variable *const r2760 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r2760);
                                       ir_variable *const r2761 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r2761);
                                       ir_variable *const r2762 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r2763 = neg(r275E);
                                       body.emit(assign(r2762, bit_and(r2763, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2765 = equal(r275E, body.constant(int(0)));
                                       ir_if *f2764 = new(mem_ctx) ir_if(operand(r2765).val);
                                       exec_list *const f2764_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2764->then_instructions;

                                          body.emit(assign(r275F, r270A, 0x01));

                                          body.emit(assign(r2760, r2709, 0x01));

                                          body.emit(assign(r2761, r2708, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2764->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2767 = less(r275E, body.constant(int(32)));
                                          ir_if *f2766 = new(mem_ctx) ir_if(operand(r2767).val);
                                          exec_list *const f2766_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2766->then_instructions;

                                             body.emit(assign(r275F, lshift(r2709, r2762), 0x01));

                                             ir_expression *const r2768 = lshift(r2708, r2762);
                                             ir_expression *const r2769 = rshift(r2709, r275E);
                                             body.emit(assign(r2760, bit_or(r2768, r2769), 0x01));

                                             body.emit(assign(r2761, rshift(r2708, r275E), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2766->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r276B = equal(r275E, body.constant(int(32)));
                                             ir_if *f276A = new(mem_ctx) ir_if(operand(r276B).val);
                                             exec_list *const f276A_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f276A->then_instructions;

                                                body.emit(assign(r275F, r2709, 0x01));

                                                body.emit(assign(r2760, r2708, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f276A->else_instructions;

                                                body.emit(assign(r275D, bit_or(r270A, r2709), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r276D = less(r275E, body.constant(int(64)));
                                                ir_if *f276C = new(mem_ctx) ir_if(operand(r276D).val);
                                                exec_list *const f276C_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f276C->then_instructions;

                                                   body.emit(assign(r275F, lshift(r2708, r2762), 0x01));

                                                   ir_expression *const r276E = bit_and(r275E, body.constant(int(31)));
                                                   body.emit(assign(r2760, rshift(r2708, r276E), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f276C->else_instructions;

                                                   ir_variable *const r276F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r2771 = equal(r275E, body.constant(int(64)));
                                                   ir_if *f2770 = new(mem_ctx) ir_if(operand(r2771).val);
                                                   exec_list *const f2770_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f2770->then_instructions;

                                                      body.emit(assign(r276F, r2708, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f2770->else_instructions;

                                                      ir_expression *const r2772 = nequal(r2708, body.constant(0u));
                                                      ir_expression *const r2773 = expr(ir_unop_b2i, r2772);
                                                      body.emit(assign(r276F, expr(ir_unop_i2u, r2773), 0x01));


                                                   body.instructions = f2770_parent_instructions;
                                                   body.emit(f2770);

                                                   /* END IF */

                                                   body.emit(assign(r275F, r276F, 0x01));

                                                   body.emit(assign(r2760, body.constant(0u), 0x01));


                                                body.instructions = f276C_parent_instructions;
                                                body.emit(f276C);

                                                /* END IF */


                                             body.instructions = f276A_parent_instructions;
                                             body.emit(f276A);

                                             /* END IF */

                                             body.emit(assign(r2761, body.constant(0u), 0x01));


                                          body.instructions = f2766_parent_instructions;
                                          body.emit(f2766);

                                          /* END IF */

                                          ir_expression *const r2774 = nequal(r275D, body.constant(0u));
                                          ir_expression *const r2775 = expr(ir_unop_b2i, r2774);
                                          ir_expression *const r2776 = expr(ir_unop_i2u, r2775);
                                          body.emit(assign(r275F, bit_or(r275F, r2776), 0x01));


                                       body.instructions = f2764_parent_instructions;
                                       body.emit(f2764);

                                       /* END IF */

                                       body.emit(assign(r2747, r2761, 0x01));

                                       body.emit(assign(r2748, r2760, 0x01));

                                       body.emit(assign(r2749, r275F, 0x01));

                                       body.emit(assign(r2746, body.constant(int(0)), 0x01));

                                       body.emit(assign(r274C, less(r275F, body.constant(0u)), 0x01));


                                    body.instructions = f275B_parent_instructions;
                                    body.emit(f275B);

                                    /* END IF */


                                 body.instructions = f2758_parent_instructions;
                                 body.emit(f2758);

                                 /* END IF */


                              body.instructions = f274E_parent_instructions;
                              body.emit(f274E);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2777 = new(mem_ctx) ir_if(operand(r274A).val);
                              exec_list *const f2777_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2777->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f2778 = new(mem_ctx) ir_if(operand(r274C).val);
                                 exec_list *const f2778_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2778->then_instructions;

                                    ir_variable *const r2779 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r2779, add(r2748, body.constant(1u)), 0x01));

                                    ir_expression *const r277A = less(r2779, r2748);
                                    ir_expression *const r277B = expr(ir_unop_b2i, r277A);
                                    ir_expression *const r277C = expr(ir_unop_i2u, r277B);
                                    body.emit(assign(r2747, add(r2747, r277C), 0x01));

                                    ir_expression *const r277D = equal(r2749, body.constant(0u));
                                    ir_expression *const r277E = expr(ir_unop_b2i, r277D);
                                    ir_expression *const r277F = expr(ir_unop_i2u, r277E);
                                    ir_expression *const r2780 = add(r2749, r277F);
                                    ir_expression *const r2781 = bit_and(r2780, body.constant(1u));
                                    ir_expression *const r2782 = expr(ir_unop_bit_not, r2781);
                                    body.emit(assign(r2748, bit_and(r2779, r2782), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2778->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2784 = bit_or(r2747, r2748);
                                    ir_expression *const r2785 = equal(r2784, body.constant(0u));
                                    ir_if *f2783 = new(mem_ctx) ir_if(operand(r2785).val);
                                    exec_list *const f2783_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2783->then_instructions;

                                       body.emit(assign(r2746, body.constant(int(0)), 0x01));


                                    body.instructions = f2783_parent_instructions;
                                    body.emit(f2783);

                                    /* END IF */


                                 body.instructions = f2778_parent_instructions;
                                 body.emit(f2778);

                                 /* END IF */

                                 ir_variable *const r2786 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2786);
                                 ir_expression *const r2787 = lshift(r2392, body.constant(int(31)));
                                 ir_expression *const r2788 = expr(ir_unop_i2u, r2746);
                                 ir_expression *const r2789 = lshift(r2788, body.constant(int(20)));
                                 ir_expression *const r278A = add(r2787, r2789);
                                 body.emit(assign(r2786, add(r278A, r2747), 0x02));

                                 body.emit(assign(r2786, r2748, 0x01));

                                 body.emit(assign(r274B, r2786, 0x03));

                                 body.emit(assign(r274A, body.constant(false), 0x01));


                              body.instructions = f2777_parent_instructions;
                              body.emit(f2777);

                              /* END IF */

                              body.emit(assign(r2393, r274B, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f26FF->else_instructions;

                              ir_variable *const r278B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r278B);
                              body.emit(assign(r278B, body.constant(0u), 0x02));

                              body.emit(assign(r278B, body.constant(0u), 0x01));

                              body.emit(assign(r2393, r278B, 0x03));


                           body.instructions = f26FF_parent_instructions;
                           body.emit(f26FF);

                           /* END IF */


                        body.instructions = f2673_parent_instructions;
                        body.emit(f2673);

                        /* END IF */


                     body.instructions = f25E7_parent_instructions;
                     body.emit(f25E7);

                     /* END IF */


                  body.instructions = f255B_parent_instructions;
                  body.emit(f255B);

                  /* END IF */


               body.instructions = f253A_parent_instructions;
               body.emit(f253A);

               /* END IF */


            body.instructions = f246C_parent_instructions;
            body.emit(f246C);

            /* END IF */


         body.instructions = f23A7_parent_instructions;
         body.emit(f23A7);

         /* END IF */

         body.emit(assign(r21F9, r2393, 0x03));


      body.instructions = f21FC_parent_instructions;
      body.emit(f21FC);

      /* END IF */

      body.emit(assign(r21F6, r21F9, 0x03));


   body.instructions = f21F7_parent_instructions;
   body.emit(f21F7);

   /* END IF */

   ir_variable *const r278C = body.make_temp(glsl_type::uvec2_type, "a");
   body.emit(assign(r278C, r21F6, 0x03));

   ir_variable *const r278D = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r278F = lshift(swizzle_y(r21F6), body.constant(int(1)));
   ir_expression *const r2790 = lequal(body.constant(4292870144u), r278F);
   ir_expression *const r2791 = nequal(swizzle_x(r21F6), body.constant(0u));
   ir_expression *const r2792 = bit_and(swizzle_y(r21F6), body.constant(1048575u));
   ir_expression *const r2793 = nequal(r2792, body.constant(0u));
   ir_expression *const r2794 = logic_or(r2791, r2793);
   ir_expression *const r2795 = logic_and(r2790, r2794);
   ir_if *f278E = new(mem_ctx) ir_if(operand(r2795).val);
   exec_list *const f278E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f278E->then_instructions;

      body.emit(assign(r278D, r21F6, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f278E->else_instructions;

      body.emit(assign(r278C, bit_xor(swizzle_y(r21F6), body.constant(2147483648u)), 0x02));

      body.emit(assign(r278D, r278C, 0x03));


   body.instructions = f278E_parent_instructions;
   body.emit(f278E);

   /* END IF */

   ir_variable *const r2796 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r2797 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r2797, rshift(swizzle_y(r21C2), body.constant(int(31))), 0x01));

   ir_variable *const r2798 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r2798, rshift(swizzle_y(r278D), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r279A = equal(r2797, r2798);
   ir_if *f2799 = new(mem_ctx) ir_if(operand(r279A).val);
   exec_list *const f2799_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f2799->then_instructions;

      ir_variable *const r279B = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r279B, body.constant(true), 0x01));

      ir_variable *const r279C = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r279D = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r279D);
      ir_variable *const r279E = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r279E);
      ir_variable *const r279F = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r279F);
      ir_variable *const r27A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r27A0);
      ir_variable *const r27A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r27A1);
      ir_variable *const r27A2 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r27A2);
      ir_variable *const r27A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r27A3);
      ir_variable *const r27A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r27A4);
      body.emit(assign(r27A4, body.constant(0u), 0x01));

      body.emit(assign(r27A3, body.constant(0u), 0x01));

      ir_variable *const r27A5 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r27A5, swizzle_x(r21C2), 0x01));

      body.emit(assign(r27A1, r27A5, 0x01));

      ir_variable *const r27A6 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r27A6, bit_and(swizzle_y(r21C2), body.constant(1048575u)), 0x01));

      body.emit(assign(r27A0, r27A6, 0x01));

      ir_variable *const r27A7 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r27A7, swizzle_x(r278D), 0x01));

      body.emit(assign(r279F, r27A7, 0x01));

      ir_variable *const r27A8 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r27A8, bit_and(swizzle_y(r278D), body.constant(1048575u)), 0x01));

      body.emit(assign(r279E, r27A8, 0x01));

      ir_variable *const r27A9 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r27AA = rshift(swizzle_y(r21C2), body.constant(int(20)));
      ir_expression *const r27AB = bit_and(r27AA, body.constant(2047u));
      body.emit(assign(r27A9, expr(ir_unop_u2i, r27AB), 0x01));

      ir_variable *const r27AC = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r27AD = rshift(swizzle_y(r278D), body.constant(int(20)));
      ir_expression *const r27AE = bit_and(r27AD, body.constant(2047u));
      body.emit(assign(r27AC, expr(ir_unop_u2i, r27AE), 0x01));

      ir_variable *const r27AF = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r27AF, sub(r27A9, r27AC), 0x01));

      body.emit(assign(r279D, r27AF, 0x01));

      /* IF CONDITION */
      ir_expression *const r27B1 = less(body.constant(int(0)), r27AF);
      ir_if *f27B0 = new(mem_ctx) ir_if(operand(r27B1).val);
      exec_list *const f27B0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f27B0->then_instructions;

         /* IF CONDITION */
         ir_expression *const r27B3 = equal(r27A9, body.constant(int(2047)));
         ir_if *f27B2 = new(mem_ctx) ir_if(operand(r27B3).val);
         exec_list *const f27B2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f27B2->then_instructions;

            /* IF CONDITION */
            ir_expression *const r27B5 = bit_or(r27A6, swizzle_x(r21C2));
            ir_expression *const r27B6 = nequal(r27B5, body.constant(0u));
            ir_if *f27B4 = new(mem_ctx) ir_if(operand(r27B6).val);
            exec_list *const f27B4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f27B4->then_instructions;

               ir_variable *const r27B7 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r27B7, swizzle_x(r21C2), 0x01));

               ir_variable *const r27B8 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r27B8, swizzle_x(r278D), 0x01));

               ir_variable *const r27B9 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r27BA = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r27BB = rshift(swizzle_y(r21C2), body.constant(int(19)));
               ir_expression *const r27BC = bit_and(r27BB, body.constant(4095u));
               ir_expression *const r27BD = equal(r27BC, body.constant(4094u));
               ir_expression *const r27BE = nequal(swizzle_x(r21C2), body.constant(0u));
               ir_expression *const r27BF = bit_and(swizzle_y(r21C2), body.constant(524287u));
               ir_expression *const r27C0 = nequal(r27BF, body.constant(0u));
               ir_expression *const r27C1 = logic_or(r27BE, r27C0);
               body.emit(assign(r27BA, logic_and(r27BD, r27C1), 0x01));

               ir_variable *const r27C2 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r27C3 = lshift(swizzle_y(r278D), body.constant(int(1)));
               ir_expression *const r27C4 = lequal(body.constant(4292870144u), r27C3);
               ir_expression *const r27C5 = nequal(swizzle_x(r278D), body.constant(0u));
               ir_expression *const r27C6 = bit_and(swizzle_y(r278D), body.constant(1048575u));
               ir_expression *const r27C7 = nequal(r27C6, body.constant(0u));
               ir_expression *const r27C8 = logic_or(r27C5, r27C7);
               body.emit(assign(r27C2, logic_and(r27C4, r27C8), 0x01));

               body.emit(assign(r27B7, bit_or(swizzle_y(r21C2), body.constant(524288u)), 0x02));

               body.emit(assign(r27B8, bit_or(swizzle_y(r278D), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r27CA = lshift(swizzle_y(r21C2), body.constant(int(1)));
               ir_expression *const r27CB = lequal(body.constant(4292870144u), r27CA);
               ir_expression *const r27CC = nequal(swizzle_x(r21C2), body.constant(0u));
               ir_expression *const r27CD = bit_and(swizzle_y(r21C2), body.constant(1048575u));
               ir_expression *const r27CE = nequal(r27CD, body.constant(0u));
               ir_expression *const r27CF = logic_or(r27CC, r27CE);
               ir_expression *const r27D0 = logic_and(r27CB, r27CF);
               ir_if *f27C9 = new(mem_ctx) ir_if(operand(r27D0).val);
               exec_list *const f27C9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27C9->then_instructions;

                  ir_variable *const r27D1 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r27D3 = logic_and(r27BA, r27C2);
                  ir_if *f27D2 = new(mem_ctx) ir_if(operand(r27D3).val);
                  exec_list *const f27D2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27D2->then_instructions;

                     body.emit(assign(r27D1, r27B8, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27D2->else_instructions;

                     body.emit(assign(r27D1, r27B7, 0x03));


                  body.instructions = f27D2_parent_instructions;
                  body.emit(f27D2);

                  /* END IF */

                  body.emit(assign(r27B9, r27D1, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f27C9->else_instructions;

                  body.emit(assign(r27B9, r27B8, 0x03));


               body.instructions = f27C9_parent_instructions;
               body.emit(f27C9);

               /* END IF */

               body.emit(assign(r279C, r27B9, 0x03));

               body.emit(assign(r279B, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f27B4->else_instructions;

               body.emit(assign(r279C, r21C2, 0x03));

               body.emit(assign(r279B, body.constant(false), 0x01));


            body.instructions = f27B4_parent_instructions;
            body.emit(f27B4);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f27B2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r27D5 = equal(r27AC, body.constant(int(0)));
            ir_if *f27D4 = new(mem_ctx) ir_if(operand(r27D5).val);
            exec_list *const f27D4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f27D4->then_instructions;

               body.emit(assign(r279D, add(r27AF, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f27D4->else_instructions;

               body.emit(assign(r279E, bit_or(r27A8, body.constant(1048576u)), 0x01));


            body.instructions = f27D4_parent_instructions;
            body.emit(f27D4);

            /* END IF */

            ir_variable *const r27D6 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r27D6, body.constant(0u), 0x01));

            ir_variable *const r27D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r27D7);
            ir_variable *const r27D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r27D8);
            ir_variable *const r27D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r27D9);
            ir_variable *const r27DA = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r27DB = neg(r279D);
            body.emit(assign(r27DA, bit_and(r27DB, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r27DD = equal(r279D, body.constant(int(0)));
            ir_if *f27DC = new(mem_ctx) ir_if(operand(r27DD).val);
            exec_list *const f27DC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f27DC->then_instructions;

               body.emit(assign(r27D7, r27D6, 0x01));

               body.emit(assign(r27D8, r27A7, 0x01));

               body.emit(assign(r27D9, r279E, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f27DC->else_instructions;

               /* IF CONDITION */
               ir_expression *const r27DF = less(r279D, body.constant(int(32)));
               ir_if *f27DE = new(mem_ctx) ir_if(operand(r27DF).val);
               exec_list *const f27DE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27DE->then_instructions;

                  body.emit(assign(r27D7, lshift(swizzle_x(r278D), r27DA), 0x01));

                  ir_expression *const r27E0 = lshift(r279E, r27DA);
                  ir_expression *const r27E1 = rshift(swizzle_x(r278D), r279D);
                  body.emit(assign(r27D8, bit_or(r27E0, r27E1), 0x01));

                  body.emit(assign(r27D9, rshift(r279E, r279D), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f27DE->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r27E3 = equal(r279D, body.constant(int(32)));
                  ir_if *f27E2 = new(mem_ctx) ir_if(operand(r27E3).val);
                  exec_list *const f27E2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27E2->then_instructions;

                     body.emit(assign(r27D7, r27A7, 0x01));

                     body.emit(assign(r27D8, r279E, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27E2->else_instructions;

                     body.emit(assign(r27D6, bit_or(body.constant(0u), swizzle_x(r278D)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r27E5 = less(r279D, body.constant(int(64)));
                     ir_if *f27E4 = new(mem_ctx) ir_if(operand(r27E5).val);
                     exec_list *const f27E4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f27E4->then_instructions;

                        body.emit(assign(r27D7, lshift(r279E, r27DA), 0x01));

                        ir_expression *const r27E6 = bit_and(r279D, body.constant(int(31)));
                        body.emit(assign(r27D8, rshift(r279E, r27E6), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f27E4->else_instructions;

                        ir_variable *const r27E7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r27E9 = equal(r279D, body.constant(int(64)));
                        ir_if *f27E8 = new(mem_ctx) ir_if(operand(r27E9).val);
                        exec_list *const f27E8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f27E8->then_instructions;

                           body.emit(assign(r27E7, r279E, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f27E8->else_instructions;

                           ir_expression *const r27EA = nequal(r279E, body.constant(0u));
                           ir_expression *const r27EB = expr(ir_unop_b2i, r27EA);
                           body.emit(assign(r27E7, expr(ir_unop_i2u, r27EB), 0x01));


                        body.instructions = f27E8_parent_instructions;
                        body.emit(f27E8);

                        /* END IF */

                        body.emit(assign(r27D7, r27E7, 0x01));

                        body.emit(assign(r27D8, body.constant(0u), 0x01));


                     body.instructions = f27E4_parent_instructions;
                     body.emit(f27E4);

                     /* END IF */


                  body.instructions = f27E2_parent_instructions;
                  body.emit(f27E2);

                  /* END IF */

                  body.emit(assign(r27D9, body.constant(0u), 0x01));


               body.instructions = f27DE_parent_instructions;
               body.emit(f27DE);

               /* END IF */

               ir_expression *const r27EC = nequal(r27D6, body.constant(0u));
               ir_expression *const r27ED = expr(ir_unop_b2i, r27EC);
               ir_expression *const r27EE = expr(ir_unop_i2u, r27ED);
               body.emit(assign(r27D7, bit_or(r27D7, r27EE), 0x01));


            body.instructions = f27DC_parent_instructions;
            body.emit(f27DC);

            /* END IF */

            body.emit(assign(r279E, r27D9, 0x01));

            body.emit(assign(r279F, r27D8, 0x01));

            body.emit(assign(r27A3, r27D7, 0x01));

            body.emit(assign(r27A2, r27A9, 0x01));


         body.instructions = f27B2_parent_instructions;
         body.emit(f27B2);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f27B0->else_instructions;

         /* IF CONDITION */
         ir_expression *const r27F0 = less(r279D, body.constant(int(0)));
         ir_if *f27EF = new(mem_ctx) ir_if(operand(r27F0).val);
         exec_list *const f27EF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f27EF->then_instructions;

            /* IF CONDITION */
            ir_expression *const r27F2 = equal(r27AC, body.constant(int(2047)));
            ir_if *f27F1 = new(mem_ctx) ir_if(operand(r27F2).val);
            exec_list *const f27F1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f27F1->then_instructions;

               /* IF CONDITION */
               ir_expression *const r27F4 = bit_or(r279E, r279F);
               ir_expression *const r27F5 = nequal(r27F4, body.constant(0u));
               ir_if *f27F3 = new(mem_ctx) ir_if(operand(r27F5).val);
               exec_list *const f27F3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27F3->then_instructions;

                  ir_variable *const r27F6 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r27F6, swizzle_x(r21C2), 0x01));

                  ir_variable *const r27F7 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r27F7, swizzle_x(r278D), 0x01));

                  ir_variable *const r27F8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r27F9 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r27FA = rshift(swizzle_y(r21C2), body.constant(int(19)));
                  ir_expression *const r27FB = bit_and(r27FA, body.constant(4095u));
                  ir_expression *const r27FC = equal(r27FB, body.constant(4094u));
                  ir_expression *const r27FD = nequal(swizzle_x(r21C2), body.constant(0u));
                  ir_expression *const r27FE = bit_and(swizzle_y(r21C2), body.constant(524287u));
                  ir_expression *const r27FF = nequal(r27FE, body.constant(0u));
                  ir_expression *const r2800 = logic_or(r27FD, r27FF);
                  body.emit(assign(r27F9, logic_and(r27FC, r2800), 0x01));

                  ir_variable *const r2801 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r2802 = lshift(swizzle_y(r278D), body.constant(int(1)));
                  ir_expression *const r2803 = lequal(body.constant(4292870144u), r2802);
                  ir_expression *const r2804 = nequal(swizzle_x(r278D), body.constant(0u));
                  ir_expression *const r2805 = bit_and(swizzle_y(r278D), body.constant(1048575u));
                  ir_expression *const r2806 = nequal(r2805, body.constant(0u));
                  ir_expression *const r2807 = logic_or(r2804, r2806);
                  body.emit(assign(r2801, logic_and(r2803, r2807), 0x01));

                  body.emit(assign(r27F6, bit_or(swizzle_y(r21C2), body.constant(524288u)), 0x02));

                  body.emit(assign(r27F7, bit_or(swizzle_y(r278D), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2809 = lshift(swizzle_y(r21C2), body.constant(int(1)));
                  ir_expression *const r280A = lequal(body.constant(4292870144u), r2809);
                  ir_expression *const r280B = nequal(swizzle_x(r21C2), body.constant(0u));
                  ir_expression *const r280C = bit_and(swizzle_y(r21C2), body.constant(1048575u));
                  ir_expression *const r280D = nequal(r280C, body.constant(0u));
                  ir_expression *const r280E = logic_or(r280B, r280D);
                  ir_expression *const r280F = logic_and(r280A, r280E);
                  ir_if *f2808 = new(mem_ctx) ir_if(operand(r280F).val);
                  exec_list *const f2808_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2808->then_instructions;

                     ir_variable *const r2810 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2812 = logic_and(r27F9, r2801);
                     ir_if *f2811 = new(mem_ctx) ir_if(operand(r2812).val);
                     exec_list *const f2811_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2811->then_instructions;

                        body.emit(assign(r2810, r27F7, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2811->else_instructions;

                        body.emit(assign(r2810, r27F6, 0x03));


                     body.instructions = f2811_parent_instructions;
                     body.emit(f2811);

                     /* END IF */

                     body.emit(assign(r27F8, r2810, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2808->else_instructions;

                     body.emit(assign(r27F8, r27F7, 0x03));


                  body.instructions = f2808_parent_instructions;
                  body.emit(f2808);

                  /* END IF */

                  body.emit(assign(r279C, r27F8, 0x03));

                  body.emit(assign(r279B, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f27F3->else_instructions;

                  ir_variable *const r2813 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2813);
                  ir_expression *const r2814 = lshift(r2797, body.constant(int(31)));
                  body.emit(assign(r2813, add(r2814, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r2813, body.constant(0u), 0x01));

                  body.emit(assign(r279C, r2813, 0x03));

                  body.emit(assign(r279B, body.constant(false), 0x01));


               body.instructions = f27F3_parent_instructions;
               body.emit(f27F3);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f27F1->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2816 = equal(r27A9, body.constant(int(0)));
               ir_if *f2815 = new(mem_ctx) ir_if(operand(r2816).val);
               exec_list *const f2815_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2815->then_instructions;

                  body.emit(assign(r279D, add(r279D, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2815->else_instructions;

                  body.emit(assign(r27A0, bit_or(r27A6, body.constant(1048576u)), 0x01));


               body.instructions = f2815_parent_instructions;
               body.emit(f2815);

               /* END IF */

               ir_variable *const r2817 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2817, body.constant(0u), 0x01));

               ir_variable *const r2818 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2818, neg(r279D), 0x01));

               ir_variable *const r2819 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2819);
               ir_variable *const r281A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r281A);
               ir_variable *const r281B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r281B);
               ir_variable *const r281C = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r281D = neg(r2818);
               body.emit(assign(r281C, bit_and(r281D, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r281F = equal(r2818, body.constant(int(0)));
               ir_if *f281E = new(mem_ctx) ir_if(operand(r281F).val);
               exec_list *const f281E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f281E->then_instructions;

                  body.emit(assign(r2819, r2817, 0x01));

                  body.emit(assign(r281A, r27A5, 0x01));

                  body.emit(assign(r281B, r27A0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f281E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2821 = less(r2818, body.constant(int(32)));
                  ir_if *f2820 = new(mem_ctx) ir_if(operand(r2821).val);
                  exec_list *const f2820_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2820->then_instructions;

                     body.emit(assign(r2819, lshift(swizzle_x(r21C2), r281C), 0x01));

                     ir_expression *const r2822 = lshift(r27A0, r281C);
                     ir_expression *const r2823 = rshift(swizzle_x(r21C2), r2818);
                     body.emit(assign(r281A, bit_or(r2822, r2823), 0x01));

                     body.emit(assign(r281B, rshift(r27A0, r2818), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2820->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2825 = equal(r2818, body.constant(int(32)));
                     ir_if *f2824 = new(mem_ctx) ir_if(operand(r2825).val);
                     exec_list *const f2824_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2824->then_instructions;

                        body.emit(assign(r2819, r27A5, 0x01));

                        body.emit(assign(r281A, r27A0, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2824->else_instructions;

                        body.emit(assign(r2817, bit_or(body.constant(0u), swizzle_x(r21C2)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2827 = less(r2818, body.constant(int(64)));
                        ir_if *f2826 = new(mem_ctx) ir_if(operand(r2827).val);
                        exec_list *const f2826_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2826->then_instructions;

                           body.emit(assign(r2819, lshift(r27A0, r281C), 0x01));

                           ir_expression *const r2828 = bit_and(r2818, body.constant(int(31)));
                           body.emit(assign(r281A, rshift(r27A0, r2828), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2826->else_instructions;

                           ir_variable *const r2829 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r282B = equal(r2818, body.constant(int(64)));
                           ir_if *f282A = new(mem_ctx) ir_if(operand(r282B).val);
                           exec_list *const f282A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f282A->then_instructions;

                              body.emit(assign(r2829, r27A0, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f282A->else_instructions;

                              ir_expression *const r282C = nequal(r27A0, body.constant(0u));
                              ir_expression *const r282D = expr(ir_unop_b2i, r282C);
                              body.emit(assign(r2829, expr(ir_unop_i2u, r282D), 0x01));


                           body.instructions = f282A_parent_instructions;
                           body.emit(f282A);

                           /* END IF */

                           body.emit(assign(r2819, r2829, 0x01));

                           body.emit(assign(r281A, body.constant(0u), 0x01));


                        body.instructions = f2826_parent_instructions;
                        body.emit(f2826);

                        /* END IF */


                     body.instructions = f2824_parent_instructions;
                     body.emit(f2824);

                     /* END IF */

                     body.emit(assign(r281B, body.constant(0u), 0x01));


                  body.instructions = f2820_parent_instructions;
                  body.emit(f2820);

                  /* END IF */

                  ir_expression *const r282E = nequal(r2817, body.constant(0u));
                  ir_expression *const r282F = expr(ir_unop_b2i, r282E);
                  ir_expression *const r2830 = expr(ir_unop_i2u, r282F);
                  body.emit(assign(r2819, bit_or(r2819, r2830), 0x01));


               body.instructions = f281E_parent_instructions;
               body.emit(f281E);

               /* END IF */

               body.emit(assign(r27A0, r281B, 0x01));

               body.emit(assign(r27A1, r281A, 0x01));

               body.emit(assign(r27A3, r2819, 0x01));

               body.emit(assign(r27A2, r27AC, 0x01));


            body.instructions = f27F1_parent_instructions;
            body.emit(f27F1);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f27EF->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2832 = equal(r27A9, body.constant(int(2047)));
            ir_if *f2831 = new(mem_ctx) ir_if(operand(r2832).val);
            exec_list *const f2831_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2831->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2834 = bit_or(r27A0, r27A1);
               ir_expression *const r2835 = bit_or(r279E, r279F);
               ir_expression *const r2836 = bit_or(r2834, r2835);
               ir_expression *const r2837 = nequal(r2836, body.constant(0u));
               ir_if *f2833 = new(mem_ctx) ir_if(operand(r2837).val);
               exec_list *const f2833_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2833->then_instructions;

                  ir_variable *const r2838 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2838, swizzle_x(r21C2), 0x01));

                  ir_variable *const r2839 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2839, swizzle_x(r278D), 0x01));

                  ir_variable *const r283A = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r283B = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r283C = rshift(swizzle_y(r21C2), body.constant(int(19)));
                  ir_expression *const r283D = bit_and(r283C, body.constant(4095u));
                  ir_expression *const r283E = equal(r283D, body.constant(4094u));
                  ir_expression *const r283F = nequal(swizzle_x(r21C2), body.constant(0u));
                  ir_expression *const r2840 = bit_and(swizzle_y(r21C2), body.constant(524287u));
                  ir_expression *const r2841 = nequal(r2840, body.constant(0u));
                  ir_expression *const r2842 = logic_or(r283F, r2841);
                  body.emit(assign(r283B, logic_and(r283E, r2842), 0x01));

                  ir_variable *const r2843 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r2844 = lshift(swizzle_y(r278D), body.constant(int(1)));
                  ir_expression *const r2845 = lequal(body.constant(4292870144u), r2844);
                  ir_expression *const r2846 = nequal(swizzle_x(r278D), body.constant(0u));
                  ir_expression *const r2847 = bit_and(swizzle_y(r278D), body.constant(1048575u));
                  ir_expression *const r2848 = nequal(r2847, body.constant(0u));
                  ir_expression *const r2849 = logic_or(r2846, r2848);
                  body.emit(assign(r2843, logic_and(r2845, r2849), 0x01));

                  body.emit(assign(r2838, bit_or(swizzle_y(r21C2), body.constant(524288u)), 0x02));

                  body.emit(assign(r2839, bit_or(swizzle_y(r278D), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r284B = lshift(swizzle_y(r21C2), body.constant(int(1)));
                  ir_expression *const r284C = lequal(body.constant(4292870144u), r284B);
                  ir_expression *const r284D = nequal(swizzle_x(r21C2), body.constant(0u));
                  ir_expression *const r284E = bit_and(swizzle_y(r21C2), body.constant(1048575u));
                  ir_expression *const r284F = nequal(r284E, body.constant(0u));
                  ir_expression *const r2850 = logic_or(r284D, r284F);
                  ir_expression *const r2851 = logic_and(r284C, r2850);
                  ir_if *f284A = new(mem_ctx) ir_if(operand(r2851).val);
                  exec_list *const f284A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f284A->then_instructions;

                     ir_variable *const r2852 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2854 = logic_and(r283B, r2843);
                     ir_if *f2853 = new(mem_ctx) ir_if(operand(r2854).val);
                     exec_list *const f2853_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2853->then_instructions;

                        body.emit(assign(r2852, r2839, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2853->else_instructions;

                        body.emit(assign(r2852, r2838, 0x03));


                     body.instructions = f2853_parent_instructions;
                     body.emit(f2853);

                     /* END IF */

                     body.emit(assign(r283A, r2852, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f284A->else_instructions;

                     body.emit(assign(r283A, r2839, 0x03));


                  body.instructions = f284A_parent_instructions;
                  body.emit(f284A);

                  /* END IF */

                  body.emit(assign(r279C, r283A, 0x03));

                  body.emit(assign(r279B, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2833->else_instructions;

                  body.emit(assign(r279C, r21C2, 0x03));

                  body.emit(assign(r279B, body.constant(false), 0x01));


               body.instructions = f2833_parent_instructions;
               body.emit(f2833);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2831->else_instructions;

               ir_variable *const r2855 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r2856 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r2856, add(r27A1, r279F), 0x01));

               ir_expression *const r2857 = add(r27A0, r279E);
               ir_expression *const r2858 = less(r2856, r27A1);
               ir_expression *const r2859 = expr(ir_unop_b2i, r2858);
               ir_expression *const r285A = expr(ir_unop_i2u, r2859);
               body.emit(assign(r2855, add(r2857, r285A), 0x01));

               body.emit(assign(r27A4, r2855, 0x01));

               /* IF CONDITION */
               ir_expression *const r285C = equal(r27A9, body.constant(int(0)));
               ir_if *f285B = new(mem_ctx) ir_if(operand(r285C).val);
               exec_list *const f285B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f285B->then_instructions;

                  ir_variable *const r285D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r285D);
                  ir_expression *const r285E = lshift(r2797, body.constant(int(31)));
                  body.emit(assign(r285D, add(r285E, r2855), 0x02));

                  body.emit(assign(r285D, r2856, 0x01));

                  body.emit(assign(r279C, r285D, 0x03));

                  body.emit(assign(r279B, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f285B->else_instructions;

                  body.emit(assign(r27A4, bit_or(r2855, body.constant(2097152u)), 0x01));

                  body.emit(assign(r27A2, r27A9, 0x01));

                  ir_variable *const r285F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r285F);
                  ir_variable *const r2860 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2860);
                  ir_variable *const r2861 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2861);
                  body.emit(assign(r285F, lshift(r2856, body.constant(int(31))), 0x01));

                  ir_expression *const r2862 = lshift(r27A4, body.constant(int(31)));
                  ir_expression *const r2863 = rshift(r2856, body.constant(int(1)));
                  body.emit(assign(r2860, bit_or(r2862, r2863), 0x01));

                  body.emit(assign(r2861, rshift(r27A4, body.constant(int(1))), 0x01));

                  body.emit(assign(r285F, bit_or(r285F, body.constant(0u)), 0x01));

                  body.emit(assign(r27A4, r2861, 0x01));

                  body.emit(assign(r27A3, r285F, 0x01));

                  ir_variable *const r2864 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r2864, r27A9, 0x01));

                  ir_variable *const r2865 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r2865, r2861, 0x01));

                  ir_variable *const r2866 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r2866, r2860, 0x01));

                  ir_variable *const r2867 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r2867, r285F, 0x01));

                  ir_variable *const r2868 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r2868, body.constant(true), 0x01));

                  ir_variable *const r2869 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r286A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r286A);
                  ir_expression *const r286B = expr(ir_unop_u2i, r285F);
                  body.emit(assign(r286A, less(r286B, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r286D = lequal(body.constant(int(2045)), r27A9);
                  ir_if *f286C = new(mem_ctx) ir_if(operand(r286D).val);
                  exec_list *const f286C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f286C->then_instructions;

                     ir_variable *const r286E = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2870 = less(body.constant(int(2045)), r27A9);
                     ir_if *f286F = new(mem_ctx) ir_if(operand(r2870).val);
                     exec_list *const f286F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f286F->then_instructions;

                        body.emit(assign(r286E, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f286F->else_instructions;

                        ir_variable *const r2871 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2873 = equal(r27A9, body.constant(int(2045)));
                        ir_if *f2872 = new(mem_ctx) ir_if(operand(r2873).val);
                        exec_list *const f2872_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2872->then_instructions;

                           ir_expression *const r2874 = equal(body.constant(2097151u), r2861);
                           ir_expression *const r2875 = equal(body.constant(4294967295u), r2860);
                           body.emit(assign(r2871, logic_and(r2874, r2875), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2872->else_instructions;

                           body.emit(assign(r2871, body.constant(false), 0x01));


                        body.instructions = f2872_parent_instructions;
                        body.emit(f2872);

                        /* END IF */

                        body.emit(assign(r286E, logic_and(r2871, r286A), 0x01));


                     body.instructions = f286F_parent_instructions;
                     body.emit(f286F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2876 = new(mem_ctx) ir_if(operand(r286E).val);
                     exec_list *const f2876_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2876->then_instructions;

                        ir_variable *const r2877 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2877);
                        ir_expression *const r2878 = lshift(r2797, body.constant(int(31)));
                        body.emit(assign(r2877, add(r2878, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r2877, body.constant(0u), 0x01));

                        body.emit(assign(r2869, r2877, 0x03));

                        body.emit(assign(r2868, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2876->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r287A = less(r27A9, body.constant(int(0)));
                        ir_if *f2879 = new(mem_ctx) ir_if(operand(r287A).val);
                        exec_list *const f2879_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2879->then_instructions;

                           ir_variable *const r287B = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r287B, r285F, 0x01));

                           ir_variable *const r287C = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r287C, neg(r27A9), 0x01));

                           ir_variable *const r287D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r287D);
                           ir_variable *const r287E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r287E);
                           ir_variable *const r287F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r287F);
                           ir_variable *const r2880 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r2881 = neg(r287C);
                           body.emit(assign(r2880, bit_and(r2881, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2883 = equal(r287C, body.constant(int(0)));
                           ir_if *f2882 = new(mem_ctx) ir_if(operand(r2883).val);
                           exec_list *const f2882_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2882->then_instructions;

                              body.emit(assign(r287D, r285F, 0x01));

                              body.emit(assign(r287E, r2860, 0x01));

                              body.emit(assign(r287F, r2861, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2882->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2885 = less(r287C, body.constant(int(32)));
                              ir_if *f2884 = new(mem_ctx) ir_if(operand(r2885).val);
                              exec_list *const f2884_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2884->then_instructions;

                                 body.emit(assign(r287D, lshift(r2860, r2880), 0x01));

                                 ir_expression *const r2886 = lshift(r2861, r2880);
                                 ir_expression *const r2887 = rshift(r2860, r287C);
                                 body.emit(assign(r287E, bit_or(r2886, r2887), 0x01));

                                 body.emit(assign(r287F, rshift(r2861, r287C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2884->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2889 = equal(r287C, body.constant(int(32)));
                                 ir_if *f2888 = new(mem_ctx) ir_if(operand(r2889).val);
                                 exec_list *const f2888_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2888->then_instructions;

                                    body.emit(assign(r287D, r2860, 0x01));

                                    body.emit(assign(r287E, r2861, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2888->else_instructions;

                                    body.emit(assign(r287B, bit_or(r285F, r2860), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r288B = less(r287C, body.constant(int(64)));
                                    ir_if *f288A = new(mem_ctx) ir_if(operand(r288B).val);
                                    exec_list *const f288A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f288A->then_instructions;

                                       body.emit(assign(r287D, lshift(r2861, r2880), 0x01));

                                       ir_expression *const r288C = bit_and(r287C, body.constant(int(31)));
                                       body.emit(assign(r287E, rshift(r2861, r288C), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f288A->else_instructions;

                                       ir_variable *const r288D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r288F = equal(r287C, body.constant(int(64)));
                                       ir_if *f288E = new(mem_ctx) ir_if(operand(r288F).val);
                                       exec_list *const f288E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f288E->then_instructions;

                                          body.emit(assign(r288D, r2861, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f288E->else_instructions;

                                          ir_expression *const r2890 = nequal(r2861, body.constant(0u));
                                          ir_expression *const r2891 = expr(ir_unop_b2i, r2890);
                                          body.emit(assign(r288D, expr(ir_unop_i2u, r2891), 0x01));


                                       body.instructions = f288E_parent_instructions;
                                       body.emit(f288E);

                                       /* END IF */

                                       body.emit(assign(r287D, r288D, 0x01));

                                       body.emit(assign(r287E, body.constant(0u), 0x01));


                                    body.instructions = f288A_parent_instructions;
                                    body.emit(f288A);

                                    /* END IF */


                                 body.instructions = f2888_parent_instructions;
                                 body.emit(f2888);

                                 /* END IF */

                                 body.emit(assign(r287F, body.constant(0u), 0x01));


                              body.instructions = f2884_parent_instructions;
                              body.emit(f2884);

                              /* END IF */

                              ir_expression *const r2892 = nequal(r287B, body.constant(0u));
                              ir_expression *const r2893 = expr(ir_unop_b2i, r2892);
                              ir_expression *const r2894 = expr(ir_unop_i2u, r2893);
                              body.emit(assign(r287D, bit_or(r287D, r2894), 0x01));


                           body.instructions = f2882_parent_instructions;
                           body.emit(f2882);

                           /* END IF */

                           body.emit(assign(r2865, r287F, 0x01));

                           body.emit(assign(r2866, r287E, 0x01));

                           body.emit(assign(r2867, r287D, 0x01));

                           body.emit(assign(r2864, body.constant(int(0)), 0x01));

                           body.emit(assign(r286A, less(r287D, body.constant(0u)), 0x01));


                        body.instructions = f2879_parent_instructions;
                        body.emit(f2879);

                        /* END IF */


                     body.instructions = f2876_parent_instructions;
                     body.emit(f2876);

                     /* END IF */


                  body.instructions = f286C_parent_instructions;
                  body.emit(f286C);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2895 = new(mem_ctx) ir_if(operand(r2868).val);
                  exec_list *const f2895_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2895->then_instructions;

                     /* IF CONDITION */
                     ir_if *f2896 = new(mem_ctx) ir_if(operand(r286A).val);
                     exec_list *const f2896_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2896->then_instructions;

                        ir_variable *const r2897 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r2897, add(r2866, body.constant(1u)), 0x01));

                        ir_expression *const r2898 = less(r2897, r2866);
                        ir_expression *const r2899 = expr(ir_unop_b2i, r2898);
                        ir_expression *const r289A = expr(ir_unop_i2u, r2899);
                        body.emit(assign(r2865, add(r2865, r289A), 0x01));

                        ir_expression *const r289B = equal(r2867, body.constant(0u));
                        ir_expression *const r289C = expr(ir_unop_b2i, r289B);
                        ir_expression *const r289D = expr(ir_unop_i2u, r289C);
                        ir_expression *const r289E = add(r2867, r289D);
                        ir_expression *const r289F = bit_and(r289E, body.constant(1u));
                        ir_expression *const r28A0 = expr(ir_unop_bit_not, r289F);
                        body.emit(assign(r2866, bit_and(r2897, r28A0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2896->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r28A2 = bit_or(r2865, r2866);
                        ir_expression *const r28A3 = equal(r28A2, body.constant(0u));
                        ir_if *f28A1 = new(mem_ctx) ir_if(operand(r28A3).val);
                        exec_list *const f28A1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28A1->then_instructions;

                           body.emit(assign(r2864, body.constant(int(0)), 0x01));


                        body.instructions = f28A1_parent_instructions;
                        body.emit(f28A1);

                        /* END IF */


                     body.instructions = f2896_parent_instructions;
                     body.emit(f2896);

                     /* END IF */

                     ir_variable *const r28A4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r28A4);
                     ir_expression *const r28A5 = lshift(r2797, body.constant(int(31)));
                     ir_expression *const r28A6 = expr(ir_unop_i2u, r2864);
                     ir_expression *const r28A7 = lshift(r28A6, body.constant(int(20)));
                     ir_expression *const r28A8 = add(r28A5, r28A7);
                     body.emit(assign(r28A4, add(r28A8, r2865), 0x02));

                     body.emit(assign(r28A4, r2866, 0x01));

                     body.emit(assign(r2869, r28A4, 0x03));

                     body.emit(assign(r2868, body.constant(false), 0x01));


                  body.instructions = f2895_parent_instructions;
                  body.emit(f2895);

                  /* END IF */

                  body.emit(assign(r279C, r2869, 0x03));

                  body.emit(assign(r279B, body.constant(false), 0x01));


               body.instructions = f285B_parent_instructions;
               body.emit(f285B);

               /* END IF */


            body.instructions = f2831_parent_instructions;
            body.emit(f2831);

            /* END IF */


         body.instructions = f27EF_parent_instructions;
         body.emit(f27EF);

         /* END IF */


      body.instructions = f27B0_parent_instructions;
      body.emit(f27B0);

      /* END IF */

      /* IF CONDITION */
      ir_if *f28A9 = new(mem_ctx) ir_if(operand(r279B).val);
      exec_list *const f28A9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f28A9->then_instructions;

         body.emit(assign(r27A0, bit_or(r27A0, body.constant(1048576u)), 0x01));

         ir_variable *const r28AA = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r28AB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r28AB, add(r27A1, r279F), 0x01));

         ir_expression *const r28AC = add(r27A0, r279E);
         ir_expression *const r28AD = less(r28AB, r27A1);
         ir_expression *const r28AE = expr(ir_unop_b2i, r28AD);
         ir_expression *const r28AF = expr(ir_unop_i2u, r28AE);
         body.emit(assign(r28AA, add(r28AC, r28AF), 0x01));

         body.emit(assign(r27A4, r28AA, 0x01));

         body.emit(assign(r27A2, add(r27A2, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r28B1 = less(r28AA, body.constant(2097152u));
         ir_if *f28B0 = new(mem_ctx) ir_if(operand(r28B1).val);
         exec_list *const f28B0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f28B0->then_instructions;

            ir_variable *const r28B2 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r28B2, r27A2, 0x01));

            ir_variable *const r28B3 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r28B3, r28AA, 0x01));

            ir_variable *const r28B4 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r28B4, r28AB, 0x01));

            ir_variable *const r28B5 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r28B5, r27A3, 0x01));

            ir_variable *const r28B6 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r28B6, body.constant(true), 0x01));

            ir_variable *const r28B7 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r28B8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r28B8);
            ir_expression *const r28B9 = expr(ir_unop_u2i, r27A3);
            body.emit(assign(r28B8, less(r28B9, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r28BB = lequal(body.constant(int(2045)), r27A2);
            ir_if *f28BA = new(mem_ctx) ir_if(operand(r28BB).val);
            exec_list *const f28BA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f28BA->then_instructions;

               ir_variable *const r28BC = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r28BE = less(body.constant(int(2045)), r27A2);
               ir_if *f28BD = new(mem_ctx) ir_if(operand(r28BE).val);
               exec_list *const f28BD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f28BD->then_instructions;

                  body.emit(assign(r28BC, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f28BD->else_instructions;

                  ir_variable *const r28BF = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r28C1 = equal(r27A2, body.constant(int(2045)));
                  ir_if *f28C0 = new(mem_ctx) ir_if(operand(r28C1).val);
                  exec_list *const f28C0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28C0->then_instructions;

                     ir_expression *const r28C2 = equal(body.constant(2097151u), r28AA);
                     ir_expression *const r28C3 = equal(body.constant(4294967295u), r28AB);
                     body.emit(assign(r28BF, logic_and(r28C2, r28C3), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f28C0->else_instructions;

                     body.emit(assign(r28BF, body.constant(false), 0x01));


                  body.instructions = f28C0_parent_instructions;
                  body.emit(f28C0);

                  /* END IF */

                  body.emit(assign(r28BC, logic_and(r28BF, r28B8), 0x01));


               body.instructions = f28BD_parent_instructions;
               body.emit(f28BD);

               /* END IF */

               /* IF CONDITION */
               ir_if *f28C4 = new(mem_ctx) ir_if(operand(r28BC).val);
               exec_list *const f28C4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f28C4->then_instructions;

                  ir_variable *const r28C5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r28C5);
                  ir_expression *const r28C6 = lshift(r2797, body.constant(int(31)));
                  body.emit(assign(r28C5, add(r28C6, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r28C5, body.constant(0u), 0x01));

                  body.emit(assign(r28B7, r28C5, 0x03));

                  body.emit(assign(r28B6, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f28C4->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r28C8 = less(r27A2, body.constant(int(0)));
                  ir_if *f28C7 = new(mem_ctx) ir_if(operand(r28C8).val);
                  exec_list *const f28C7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28C7->then_instructions;

                     ir_variable *const r28C9 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r28C9, r27A3, 0x01));

                     ir_variable *const r28CA = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r28CA, neg(r27A2), 0x01));

                     ir_variable *const r28CB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r28CB);
                     ir_variable *const r28CC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r28CC);
                     ir_variable *const r28CD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r28CD);
                     ir_variable *const r28CE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r28CF = neg(r28CA);
                     body.emit(assign(r28CE, bit_and(r28CF, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r28D1 = equal(r28CA, body.constant(int(0)));
                     ir_if *f28D0 = new(mem_ctx) ir_if(operand(r28D1).val);
                     exec_list *const f28D0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28D0->then_instructions;

                        body.emit(assign(r28CB, r27A3, 0x01));

                        body.emit(assign(r28CC, r28AB, 0x01));

                        body.emit(assign(r28CD, r28AA, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f28D0->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r28D3 = less(r28CA, body.constant(int(32)));
                        ir_if *f28D2 = new(mem_ctx) ir_if(operand(r28D3).val);
                        exec_list *const f28D2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28D2->then_instructions;

                           body.emit(assign(r28CB, lshift(r28AB, r28CE), 0x01));

                           ir_expression *const r28D4 = lshift(r28AA, r28CE);
                           ir_expression *const r28D5 = rshift(r28AB, r28CA);
                           body.emit(assign(r28CC, bit_or(r28D4, r28D5), 0x01));

                           body.emit(assign(r28CD, rshift(r28AA, r28CA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f28D2->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r28D7 = equal(r28CA, body.constant(int(32)));
                           ir_if *f28D6 = new(mem_ctx) ir_if(operand(r28D7).val);
                           exec_list *const f28D6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f28D6->then_instructions;

                              body.emit(assign(r28CB, r28AB, 0x01));

                              body.emit(assign(r28CC, r28AA, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f28D6->else_instructions;

                              body.emit(assign(r28C9, bit_or(r27A3, r28AB), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r28D9 = less(r28CA, body.constant(int(64)));
                              ir_if *f28D8 = new(mem_ctx) ir_if(operand(r28D9).val);
                              exec_list *const f28D8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f28D8->then_instructions;

                                 body.emit(assign(r28CB, lshift(r28AA, r28CE), 0x01));

                                 ir_expression *const r28DA = bit_and(r28CA, body.constant(int(31)));
                                 body.emit(assign(r28CC, rshift(r28AA, r28DA), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f28D8->else_instructions;

                                 ir_variable *const r28DB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r28DD = equal(r28CA, body.constant(int(64)));
                                 ir_if *f28DC = new(mem_ctx) ir_if(operand(r28DD).val);
                                 exec_list *const f28DC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f28DC->then_instructions;

                                    body.emit(assign(r28DB, r28AA, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f28DC->else_instructions;

                                    ir_expression *const r28DE = nequal(r28AA, body.constant(0u));
                                    ir_expression *const r28DF = expr(ir_unop_b2i, r28DE);
                                    body.emit(assign(r28DB, expr(ir_unop_i2u, r28DF), 0x01));


                                 body.instructions = f28DC_parent_instructions;
                                 body.emit(f28DC);

                                 /* END IF */

                                 body.emit(assign(r28CB, r28DB, 0x01));

                                 body.emit(assign(r28CC, body.constant(0u), 0x01));


                              body.instructions = f28D8_parent_instructions;
                              body.emit(f28D8);

                              /* END IF */


                           body.instructions = f28D6_parent_instructions;
                           body.emit(f28D6);

                           /* END IF */

                           body.emit(assign(r28CD, body.constant(0u), 0x01));


                        body.instructions = f28D2_parent_instructions;
                        body.emit(f28D2);

                        /* END IF */

                        ir_expression *const r28E0 = nequal(r28C9, body.constant(0u));
                        ir_expression *const r28E1 = expr(ir_unop_b2i, r28E0);
                        ir_expression *const r28E2 = expr(ir_unop_i2u, r28E1);
                        body.emit(assign(r28CB, bit_or(r28CB, r28E2), 0x01));


                     body.instructions = f28D0_parent_instructions;
                     body.emit(f28D0);

                     /* END IF */

                     body.emit(assign(r28B3, r28CD, 0x01));

                     body.emit(assign(r28B4, r28CC, 0x01));

                     body.emit(assign(r28B5, r28CB, 0x01));

                     body.emit(assign(r28B2, body.constant(int(0)), 0x01));

                     body.emit(assign(r28B8, less(r28CB, body.constant(0u)), 0x01));


                  body.instructions = f28C7_parent_instructions;
                  body.emit(f28C7);

                  /* END IF */


               body.instructions = f28C4_parent_instructions;
               body.emit(f28C4);

               /* END IF */


            body.instructions = f28BA_parent_instructions;
            body.emit(f28BA);

            /* END IF */

            /* IF CONDITION */
            ir_if *f28E3 = new(mem_ctx) ir_if(operand(r28B6).val);
            exec_list *const f28E3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f28E3->then_instructions;

               /* IF CONDITION */
               ir_if *f28E4 = new(mem_ctx) ir_if(operand(r28B8).val);
               exec_list *const f28E4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f28E4->then_instructions;

                  ir_variable *const r28E5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r28E5, add(r28B4, body.constant(1u)), 0x01));

                  ir_expression *const r28E6 = less(r28E5, r28B4);
                  ir_expression *const r28E7 = expr(ir_unop_b2i, r28E6);
                  ir_expression *const r28E8 = expr(ir_unop_i2u, r28E7);
                  body.emit(assign(r28B3, add(r28B3, r28E8), 0x01));

                  ir_expression *const r28E9 = equal(r28B5, body.constant(0u));
                  ir_expression *const r28EA = expr(ir_unop_b2i, r28E9);
                  ir_expression *const r28EB = expr(ir_unop_i2u, r28EA);
                  ir_expression *const r28EC = add(r28B5, r28EB);
                  ir_expression *const r28ED = bit_and(r28EC, body.constant(1u));
                  ir_expression *const r28EE = expr(ir_unop_bit_not, r28ED);
                  body.emit(assign(r28B4, bit_and(r28E5, r28EE), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f28E4->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r28F0 = bit_or(r28B3, r28B4);
                  ir_expression *const r28F1 = equal(r28F0, body.constant(0u));
                  ir_if *f28EF = new(mem_ctx) ir_if(operand(r28F1).val);
                  exec_list *const f28EF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28EF->then_instructions;

                     body.emit(assign(r28B2, body.constant(int(0)), 0x01));


                  body.instructions = f28EF_parent_instructions;
                  body.emit(f28EF);

                  /* END IF */


               body.instructions = f28E4_parent_instructions;
               body.emit(f28E4);

               /* END IF */

               ir_variable *const r28F2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r28F2);
               ir_expression *const r28F3 = lshift(r2797, body.constant(int(31)));
               ir_expression *const r28F4 = expr(ir_unop_i2u, r28B2);
               ir_expression *const r28F5 = lshift(r28F4, body.constant(int(20)));
               ir_expression *const r28F6 = add(r28F3, r28F5);
               body.emit(assign(r28F2, add(r28F6, r28B3), 0x02));

               body.emit(assign(r28F2, r28B4, 0x01));

               body.emit(assign(r28B7, r28F2, 0x03));

               body.emit(assign(r28B6, body.constant(false), 0x01));


            body.instructions = f28E3_parent_instructions;
            body.emit(f28E3);

            /* END IF */

            body.emit(assign(r279C, r28B7, 0x03));

            body.emit(assign(r279B, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f28B0->else_instructions;

            body.emit(assign(r27A2, add(r27A2, body.constant(int(1))), 0x01));

            ir_variable *const r28F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r28F7);
            ir_variable *const r28F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r28F8);
            ir_variable *const r28F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r28F9);
            body.emit(assign(r28F7, lshift(r28AB, body.constant(int(31))), 0x01));

            ir_expression *const r28FA = lshift(r28AA, body.constant(int(31)));
            ir_expression *const r28FB = rshift(r28AB, body.constant(int(1)));
            body.emit(assign(r28F8, bit_or(r28FA, r28FB), 0x01));

            body.emit(assign(r28F9, rshift(r28AA, body.constant(int(1))), 0x01));

            ir_expression *const r28FC = nequal(r27A3, body.constant(0u));
            ir_expression *const r28FD = expr(ir_unop_b2i, r28FC);
            ir_expression *const r28FE = expr(ir_unop_i2u, r28FD);
            body.emit(assign(r28F7, bit_or(r28F7, r28FE), 0x01));

            body.emit(assign(r27A4, r28F9, 0x01));

            body.emit(assign(r27A3, r28F7, 0x01));

            ir_variable *const r28FF = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r28FF, r27A2, 0x01));

            ir_variable *const r2900 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r2900, r28F9, 0x01));

            ir_variable *const r2901 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r2901, r28F8, 0x01));

            ir_variable *const r2902 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r2902, r28F7, 0x01));

            ir_variable *const r2903 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r2903, body.constant(true), 0x01));

            ir_variable *const r2904 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r2905 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r2905);
            ir_expression *const r2906 = expr(ir_unop_u2i, r28F7);
            body.emit(assign(r2905, less(r2906, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2908 = lequal(body.constant(int(2045)), r27A2);
            ir_if *f2907 = new(mem_ctx) ir_if(operand(r2908).val);
            exec_list *const f2907_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2907->then_instructions;

               ir_variable *const r2909 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r290B = less(body.constant(int(2045)), r27A2);
               ir_if *f290A = new(mem_ctx) ir_if(operand(r290B).val);
               exec_list *const f290A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f290A->then_instructions;

                  body.emit(assign(r2909, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f290A->else_instructions;

                  ir_variable *const r290C = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r290E = equal(r27A2, body.constant(int(2045)));
                  ir_if *f290D = new(mem_ctx) ir_if(operand(r290E).val);
                  exec_list *const f290D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f290D->then_instructions;

                     ir_expression *const r290F = equal(body.constant(2097151u), r28F9);
                     ir_expression *const r2910 = equal(body.constant(4294967295u), r28F8);
                     body.emit(assign(r290C, logic_and(r290F, r2910), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f290D->else_instructions;

                     body.emit(assign(r290C, body.constant(false), 0x01));


                  body.instructions = f290D_parent_instructions;
                  body.emit(f290D);

                  /* END IF */

                  body.emit(assign(r2909, logic_and(r290C, r2905), 0x01));


               body.instructions = f290A_parent_instructions;
               body.emit(f290A);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2911 = new(mem_ctx) ir_if(operand(r2909).val);
               exec_list *const f2911_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2911->then_instructions;

                  ir_variable *const r2912 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2912);
                  ir_expression *const r2913 = lshift(r2797, body.constant(int(31)));
                  body.emit(assign(r2912, add(r2913, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r2912, body.constant(0u), 0x01));

                  body.emit(assign(r2904, r2912, 0x03));

                  body.emit(assign(r2903, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2911->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2915 = less(r27A2, body.constant(int(0)));
                  ir_if *f2914 = new(mem_ctx) ir_if(operand(r2915).val);
                  exec_list *const f2914_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2914->then_instructions;

                     ir_variable *const r2916 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r2916, r28F7, 0x01));

                     ir_variable *const r2917 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r2917, neg(r27A2), 0x01));

                     ir_variable *const r2918 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2918);
                     ir_variable *const r2919 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2919);
                     ir_variable *const r291A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r291A);
                     ir_variable *const r291B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r291C = neg(r2917);
                     body.emit(assign(r291B, bit_and(r291C, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r291E = equal(r2917, body.constant(int(0)));
                     ir_if *f291D = new(mem_ctx) ir_if(operand(r291E).val);
                     exec_list *const f291D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f291D->then_instructions;

                        body.emit(assign(r2918, r28F7, 0x01));

                        body.emit(assign(r2919, r28F8, 0x01));

                        body.emit(assign(r291A, r28F9, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f291D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2920 = less(r2917, body.constant(int(32)));
                        ir_if *f291F = new(mem_ctx) ir_if(operand(r2920).val);
                        exec_list *const f291F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f291F->then_instructions;

                           body.emit(assign(r2918, lshift(r28F8, r291B), 0x01));

                           ir_expression *const r2921 = lshift(r28F9, r291B);
                           ir_expression *const r2922 = rshift(r28F8, r2917);
                           body.emit(assign(r2919, bit_or(r2921, r2922), 0x01));

                           body.emit(assign(r291A, rshift(r28F9, r2917), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f291F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2924 = equal(r2917, body.constant(int(32)));
                           ir_if *f2923 = new(mem_ctx) ir_if(operand(r2924).val);
                           exec_list *const f2923_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2923->then_instructions;

                              body.emit(assign(r2918, r28F8, 0x01));

                              body.emit(assign(r2919, r28F9, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2923->else_instructions;

                              body.emit(assign(r2916, bit_or(r28F7, r28F8), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2926 = less(r2917, body.constant(int(64)));
                              ir_if *f2925 = new(mem_ctx) ir_if(operand(r2926).val);
                              exec_list *const f2925_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2925->then_instructions;

                                 body.emit(assign(r2918, lshift(r28F9, r291B), 0x01));

                                 ir_expression *const r2927 = bit_and(r2917, body.constant(int(31)));
                                 body.emit(assign(r2919, rshift(r28F9, r2927), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2925->else_instructions;

                                 ir_variable *const r2928 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r292A = equal(r2917, body.constant(int(64)));
                                 ir_if *f2929 = new(mem_ctx) ir_if(operand(r292A).val);
                                 exec_list *const f2929_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2929->then_instructions;

                                    body.emit(assign(r2928, r28F9, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2929->else_instructions;

                                    ir_expression *const r292B = nequal(r28F9, body.constant(0u));
                                    ir_expression *const r292C = expr(ir_unop_b2i, r292B);
                                    body.emit(assign(r2928, expr(ir_unop_i2u, r292C), 0x01));


                                 body.instructions = f2929_parent_instructions;
                                 body.emit(f2929);

                                 /* END IF */

                                 body.emit(assign(r2918, r2928, 0x01));

                                 body.emit(assign(r2919, body.constant(0u), 0x01));


                              body.instructions = f2925_parent_instructions;
                              body.emit(f2925);

                              /* END IF */


                           body.instructions = f2923_parent_instructions;
                           body.emit(f2923);

                           /* END IF */

                           body.emit(assign(r291A, body.constant(0u), 0x01));


                        body.instructions = f291F_parent_instructions;
                        body.emit(f291F);

                        /* END IF */

                        ir_expression *const r292D = nequal(r2916, body.constant(0u));
                        ir_expression *const r292E = expr(ir_unop_b2i, r292D);
                        ir_expression *const r292F = expr(ir_unop_i2u, r292E);
                        body.emit(assign(r2918, bit_or(r2918, r292F), 0x01));


                     body.instructions = f291D_parent_instructions;
                     body.emit(f291D);

                     /* END IF */

                     body.emit(assign(r2900, r291A, 0x01));

                     body.emit(assign(r2901, r2919, 0x01));

                     body.emit(assign(r2902, r2918, 0x01));

                     body.emit(assign(r28FF, body.constant(int(0)), 0x01));

                     body.emit(assign(r2905, less(r2918, body.constant(0u)), 0x01));


                  body.instructions = f2914_parent_instructions;
                  body.emit(f2914);

                  /* END IF */


               body.instructions = f2911_parent_instructions;
               body.emit(f2911);

               /* END IF */


            body.instructions = f2907_parent_instructions;
            body.emit(f2907);

            /* END IF */

            /* IF CONDITION */
            ir_if *f2930 = new(mem_ctx) ir_if(operand(r2903).val);
            exec_list *const f2930_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2930->then_instructions;

               /* IF CONDITION */
               ir_if *f2931 = new(mem_ctx) ir_if(operand(r2905).val);
               exec_list *const f2931_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2931->then_instructions;

                  ir_variable *const r2932 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2932, add(r2901, body.constant(1u)), 0x01));

                  ir_expression *const r2933 = less(r2932, r2901);
                  ir_expression *const r2934 = expr(ir_unop_b2i, r2933);
                  ir_expression *const r2935 = expr(ir_unop_i2u, r2934);
                  body.emit(assign(r2900, add(r2900, r2935), 0x01));

                  ir_expression *const r2936 = equal(r2902, body.constant(0u));
                  ir_expression *const r2937 = expr(ir_unop_b2i, r2936);
                  ir_expression *const r2938 = expr(ir_unop_i2u, r2937);
                  ir_expression *const r2939 = add(r2902, r2938);
                  ir_expression *const r293A = bit_and(r2939, body.constant(1u));
                  ir_expression *const r293B = expr(ir_unop_bit_not, r293A);
                  body.emit(assign(r2901, bit_and(r2932, r293B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2931->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r293D = bit_or(r2900, r2901);
                  ir_expression *const r293E = equal(r293D, body.constant(0u));
                  ir_if *f293C = new(mem_ctx) ir_if(operand(r293E).val);
                  exec_list *const f293C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f293C->then_instructions;

                     body.emit(assign(r28FF, body.constant(int(0)), 0x01));


                  body.instructions = f293C_parent_instructions;
                  body.emit(f293C);

                  /* END IF */


               body.instructions = f2931_parent_instructions;
               body.emit(f2931);

               /* END IF */

               ir_variable *const r293F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r293F);
               ir_expression *const r2940 = lshift(r2797, body.constant(int(31)));
               ir_expression *const r2941 = expr(ir_unop_i2u, r28FF);
               ir_expression *const r2942 = lshift(r2941, body.constant(int(20)));
               ir_expression *const r2943 = add(r2940, r2942);
               body.emit(assign(r293F, add(r2943, r2900), 0x02));

               body.emit(assign(r293F, r2901, 0x01));

               body.emit(assign(r2904, r293F, 0x03));

               body.emit(assign(r2903, body.constant(false), 0x01));


            body.instructions = f2930_parent_instructions;
            body.emit(f2930);

            /* END IF */

            body.emit(assign(r279C, r2904, 0x03));

            body.emit(assign(r279B, body.constant(false), 0x01));


         body.instructions = f28B0_parent_instructions;
         body.emit(f28B0);

         /* END IF */


      body.instructions = f28A9_parent_instructions;
      body.emit(f28A9);

      /* END IF */

      body.emit(assign(r2796, r279C, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f2799->else_instructions;

      ir_variable *const r2944 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r2944, r2797, 0x01));

      ir_variable *const r2945 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r2946 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r2946);
      ir_variable *const r2947 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r2947);
      ir_variable *const r2948 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r2948);
      ir_variable *const r2949 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r2949);
      ir_variable *const r294A = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r294A);
      ir_variable *const r294B = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r294B);
      ir_variable *const r294C = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r294C);
      ir_variable *const r294D = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r294D);
      ir_variable *const r294E = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r294F = rshift(swizzle_y(r21C2), body.constant(int(20)));
      ir_expression *const r2950 = bit_and(r294F, body.constant(2047u));
      body.emit(assign(r294E, expr(ir_unop_u2i, r2950), 0x01));

      body.emit(assign(r2948, r294E, 0x01));

      ir_variable *const r2951 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r2952 = rshift(swizzle_y(r278D), body.constant(int(20)));
      ir_expression *const r2953 = bit_and(r2952, body.constant(2047u));
      body.emit(assign(r2951, expr(ir_unop_u2i, r2953), 0x01));

      body.emit(assign(r2947, r2951, 0x01));

      body.emit(assign(r2946, sub(r294E, r2951), 0x01));

      ir_variable *const r2954 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r2954, lshift(swizzle_x(r21C2), body.constant(int(10))), 0x01));

      ir_variable *const r2955 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r2956 = bit_and(swizzle_y(r21C2), body.constant(1048575u));
      ir_expression *const r2957 = lshift(r2956, body.constant(int(10)));
      ir_expression *const r2958 = rshift(swizzle_x(r21C2), body.constant(int(22)));
      body.emit(assign(r2955, bit_or(r2957, r2958), 0x01));

      body.emit(assign(r294B, r2955, 0x01));

      body.emit(assign(r294C, r2954, 0x01));

      ir_variable *const r2959 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r2959, lshift(swizzle_x(r278D), body.constant(int(10))), 0x01));

      ir_variable *const r295A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r295B = bit_and(swizzle_y(r278D), body.constant(1048575u));
      ir_expression *const r295C = lshift(r295B, body.constant(int(10)));
      ir_expression *const r295D = rshift(swizzle_x(r278D), body.constant(int(22)));
      body.emit(assign(r295A, bit_or(r295C, r295D), 0x01));

      body.emit(assign(r2949, r295A, 0x01));

      body.emit(assign(r294A, r2959, 0x01));

      /* IF CONDITION */
      ir_expression *const r295F = less(body.constant(int(0)), r2946);
      ir_if *f295E = new(mem_ctx) ir_if(operand(r295F).val);
      exec_list *const f295E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f295E->then_instructions;

         /* IF CONDITION */
         ir_expression *const r2961 = equal(r294E, body.constant(int(2047)));
         ir_if *f2960 = new(mem_ctx) ir_if(operand(r2961).val);
         exec_list *const f2960_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2960->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2963 = bit_or(r2955, r2954);
            ir_expression *const r2964 = nequal(r2963, body.constant(0u));
            ir_if *f2962 = new(mem_ctx) ir_if(operand(r2964).val);
            exec_list *const f2962_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2962->then_instructions;

               ir_variable *const r2965 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r2965, swizzle_x(r21C2), 0x01));

               ir_variable *const r2966 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r2966, swizzle_x(r278D), 0x01));

               ir_variable *const r2967 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2968 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r2969 = rshift(swizzle_y(r21C2), body.constant(int(19)));
               ir_expression *const r296A = bit_and(r2969, body.constant(4095u));
               ir_expression *const r296B = equal(r296A, body.constant(4094u));
               ir_expression *const r296C = nequal(swizzle_x(r21C2), body.constant(0u));
               ir_expression *const r296D = bit_and(swizzle_y(r21C2), body.constant(524287u));
               ir_expression *const r296E = nequal(r296D, body.constant(0u));
               ir_expression *const r296F = logic_or(r296C, r296E);
               body.emit(assign(r2968, logic_and(r296B, r296F), 0x01));

               ir_variable *const r2970 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r2971 = lshift(swizzle_y(r278D), body.constant(int(1)));
               ir_expression *const r2972 = lequal(body.constant(4292870144u), r2971);
               ir_expression *const r2973 = nequal(swizzle_x(r278D), body.constant(0u));
               ir_expression *const r2974 = bit_and(swizzle_y(r278D), body.constant(1048575u));
               ir_expression *const r2975 = nequal(r2974, body.constant(0u));
               ir_expression *const r2976 = logic_or(r2973, r2975);
               body.emit(assign(r2970, logic_and(r2972, r2976), 0x01));

               body.emit(assign(r2965, bit_or(swizzle_y(r21C2), body.constant(524288u)), 0x02));

               body.emit(assign(r2966, bit_or(swizzle_y(r278D), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r2978 = lshift(swizzle_y(r21C2), body.constant(int(1)));
               ir_expression *const r2979 = lequal(body.constant(4292870144u), r2978);
               ir_expression *const r297A = nequal(swizzle_x(r21C2), body.constant(0u));
               ir_expression *const r297B = bit_and(swizzle_y(r21C2), body.constant(1048575u));
               ir_expression *const r297C = nequal(r297B, body.constant(0u));
               ir_expression *const r297D = logic_or(r297A, r297C);
               ir_expression *const r297E = logic_and(r2979, r297D);
               ir_if *f2977 = new(mem_ctx) ir_if(operand(r297E).val);
               exec_list *const f2977_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2977->then_instructions;

                  ir_variable *const r297F = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2981 = logic_and(r2968, r2970);
                  ir_if *f2980 = new(mem_ctx) ir_if(operand(r2981).val);
                  exec_list *const f2980_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2980->then_instructions;

                     body.emit(assign(r297F, r2966, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2980->else_instructions;

                     body.emit(assign(r297F, r2965, 0x03));


                  body.instructions = f2980_parent_instructions;
                  body.emit(f2980);

                  /* END IF */

                  body.emit(assign(r2967, r297F, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2977->else_instructions;

                  body.emit(assign(r2967, r2966, 0x03));


               body.instructions = f2977_parent_instructions;
               body.emit(f2977);

               /* END IF */

               body.emit(assign(r2945, r2967, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2962->else_instructions;

               body.emit(assign(r2945, r21C2, 0x03));


            body.instructions = f2962_parent_instructions;
            body.emit(f2962);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2960->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2983 = equal(r2951, body.constant(int(0)));
            ir_if *f2982 = new(mem_ctx) ir_if(operand(r2983).val);
            exec_list *const f2982_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2982->then_instructions;

               body.emit(assign(r2946, add(r2946, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2982->else_instructions;

               body.emit(assign(r2949, bit_or(r295A, body.constant(1073741824u)), 0x01));


            body.instructions = f2982_parent_instructions;
            body.emit(f2982);

            /* END IF */

            ir_variable *const r2984 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r2984);
            ir_variable *const r2985 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r2985);
            ir_variable *const r2986 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r2987 = neg(r2946);
            body.emit(assign(r2986, bit_and(r2987, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2989 = equal(r2946, body.constant(int(0)));
            ir_if *f2988 = new(mem_ctx) ir_if(operand(r2989).val);
            exec_list *const f2988_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2988->then_instructions;

               body.emit(assign(r2984, r2959, 0x01));

               body.emit(assign(r2985, r2949, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2988->else_instructions;

               /* IF CONDITION */
               ir_expression *const r298B = less(r2946, body.constant(int(32)));
               ir_if *f298A = new(mem_ctx) ir_if(operand(r298B).val);
               exec_list *const f298A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f298A->then_instructions;

                  ir_expression *const r298C = lshift(r2949, r2986);
                  ir_expression *const r298D = rshift(r2959, r2946);
                  ir_expression *const r298E = bit_or(r298C, r298D);
                  ir_expression *const r298F = lshift(r2959, r2986);
                  ir_expression *const r2990 = nequal(r298F, body.constant(0u));
                  ir_expression *const r2991 = expr(ir_unop_b2i, r2990);
                  ir_expression *const r2992 = expr(ir_unop_i2u, r2991);
                  body.emit(assign(r2984, bit_or(r298E, r2992), 0x01));

                  body.emit(assign(r2985, rshift(r2949, r2946), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f298A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2994 = equal(r2946, body.constant(int(32)));
                  ir_if *f2993 = new(mem_ctx) ir_if(operand(r2994).val);
                  exec_list *const f2993_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2993->then_instructions;

                     ir_expression *const r2995 = nequal(r2959, body.constant(0u));
                     ir_expression *const r2996 = expr(ir_unop_b2i, r2995);
                     ir_expression *const r2997 = expr(ir_unop_i2u, r2996);
                     body.emit(assign(r2984, bit_or(r2949, r2997), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2993->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2999 = less(r2946, body.constant(int(64)));
                     ir_if *f2998 = new(mem_ctx) ir_if(operand(r2999).val);
                     exec_list *const f2998_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2998->then_instructions;

                        ir_expression *const r299A = bit_and(r2946, body.constant(int(31)));
                        ir_expression *const r299B = rshift(r2949, r299A);
                        ir_expression *const r299C = lshift(r2949, r2986);
                        ir_expression *const r299D = bit_or(r299C, r2959);
                        ir_expression *const r299E = nequal(r299D, body.constant(0u));
                        ir_expression *const r299F = expr(ir_unop_b2i, r299E);
                        ir_expression *const r29A0 = expr(ir_unop_i2u, r299F);
                        body.emit(assign(r2984, bit_or(r299B, r29A0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2998->else_instructions;

                        ir_expression *const r29A1 = bit_or(r2949, r2959);
                        ir_expression *const r29A2 = nequal(r29A1, body.constant(0u));
                        ir_expression *const r29A3 = expr(ir_unop_b2i, r29A2);
                        body.emit(assign(r2984, expr(ir_unop_i2u, r29A3), 0x01));


                     body.instructions = f2998_parent_instructions;
                     body.emit(f2998);

                     /* END IF */


                  body.instructions = f2993_parent_instructions;
                  body.emit(f2993);

                  /* END IF */

                  body.emit(assign(r2985, body.constant(0u), 0x01));


               body.instructions = f298A_parent_instructions;
               body.emit(f298A);

               /* END IF */


            body.instructions = f2988_parent_instructions;
            body.emit(f2988);

            /* END IF */

            body.emit(assign(r2949, r2985, 0x01));

            body.emit(assign(r294A, r2984, 0x01));

            body.emit(assign(r294B, bit_or(r2955, body.constant(1073741824u)), 0x01));

            ir_variable *const r29A4 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r29A5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r29A5, sub(r2954, r2984), 0x01));

            ir_expression *const r29A6 = sub(r294B, r2985);
            ir_expression *const r29A7 = less(r2954, r2984);
            ir_expression *const r29A8 = expr(ir_unop_b2i, r29A7);
            ir_expression *const r29A9 = expr(ir_unop_i2u, r29A8);
            body.emit(assign(r29A4, sub(r29A6, r29A9), 0x01));

            body.emit(assign(r294D, add(r294E, body.constant(int(-1))), 0x01));

            ir_variable *const r29AA = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r29AA, add(r294D, body.constant(int(-10))), 0x01));

            ir_variable *const r29AB = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r29AB, r29A4, 0x01));

            ir_variable *const r29AC = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r29AC, r29A5, 0x01));

            ir_variable *const r29AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r29AD);
            ir_variable *const r29AE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r29AE);
            /* IF CONDITION */
            ir_expression *const r29B0 = equal(r29A4, body.constant(0u));
            ir_if *f29AF = new(mem_ctx) ir_if(operand(r29B0).val);
            exec_list *const f29AF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f29AF->then_instructions;

               body.emit(assign(r29AB, r29A5, 0x01));

               body.emit(assign(r29AC, body.constant(0u), 0x01));

               body.emit(assign(r29AA, add(r29AA, body.constant(int(-32))), 0x01));


            body.instructions = f29AF_parent_instructions;
            body.emit(f29AF);

            /* END IF */

            ir_variable *const r29B1 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r29B1, r29AB, 0x01));

            ir_variable *const r29B2 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r29B3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r29B3);
            /* IF CONDITION */
            ir_expression *const r29B5 = equal(r29AB, body.constant(0u));
            ir_if *f29B4 = new(mem_ctx) ir_if(operand(r29B5).val);
            exec_list *const f29B4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f29B4->then_instructions;

               body.emit(assign(r29B2, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f29B4->else_instructions;

               body.emit(assign(r29B3, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r29B7 = bit_and(r29AB, body.constant(4294901760u));
               ir_expression *const r29B8 = equal(r29B7, body.constant(0u));
               ir_if *f29B6 = new(mem_ctx) ir_if(operand(r29B8).val);
               exec_list *const f29B6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f29B6->then_instructions;

                  body.emit(assign(r29B3, body.constant(int(16)), 0x01));

                  body.emit(assign(r29B1, lshift(r29AB, body.constant(int(16))), 0x01));


               body.instructions = f29B6_parent_instructions;
               body.emit(f29B6);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r29BA = bit_and(r29B1, body.constant(4278190080u));
               ir_expression *const r29BB = equal(r29BA, body.constant(0u));
               ir_if *f29B9 = new(mem_ctx) ir_if(operand(r29BB).val);
               exec_list *const f29B9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f29B9->then_instructions;

                  body.emit(assign(r29B3, add(r29B3, body.constant(int(8))), 0x01));

                  body.emit(assign(r29B1, lshift(r29B1, body.constant(int(8))), 0x01));


               body.instructions = f29B9_parent_instructions;
               body.emit(f29B9);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r29BD = bit_and(r29B1, body.constant(4026531840u));
               ir_expression *const r29BE = equal(r29BD, body.constant(0u));
               ir_if *f29BC = new(mem_ctx) ir_if(operand(r29BE).val);
               exec_list *const f29BC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f29BC->then_instructions;

                  body.emit(assign(r29B3, add(r29B3, body.constant(int(4))), 0x01));

                  body.emit(assign(r29B1, lshift(r29B1, body.constant(int(4))), 0x01));


               body.instructions = f29BC_parent_instructions;
               body.emit(f29BC);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r29C0 = bit_and(r29B1, body.constant(3221225472u));
               ir_expression *const r29C1 = equal(r29C0, body.constant(0u));
               ir_if *f29BF = new(mem_ctx) ir_if(operand(r29C1).val);
               exec_list *const f29BF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f29BF->then_instructions;

                  body.emit(assign(r29B3, add(r29B3, body.constant(int(2))), 0x01));

                  body.emit(assign(r29B1, lshift(r29B1, body.constant(int(2))), 0x01));


               body.instructions = f29BF_parent_instructions;
               body.emit(f29BF);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r29C3 = bit_and(r29B1, body.constant(2147483648u));
               ir_expression *const r29C4 = equal(r29C3, body.constant(0u));
               ir_if *f29C2 = new(mem_ctx) ir_if(operand(r29C4).val);
               exec_list *const f29C2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f29C2->then_instructions;

                  body.emit(assign(r29B3, add(r29B3, body.constant(int(1))), 0x01));


               body.instructions = f29C2_parent_instructions;
               body.emit(f29C2);

               /* END IF */

               body.emit(assign(r29B2, r29B3, 0x01));


            body.instructions = f29B4_parent_instructions;
            body.emit(f29B4);

            /* END IF */

            body.emit(assign(r29AE, add(r29B2, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r29C6 = lequal(body.constant(int(0)), r29AE);
            ir_if *f29C5 = new(mem_ctx) ir_if(operand(r29C6).val);
            exec_list *const f29C5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f29C5->then_instructions;

               body.emit(assign(r29AD, body.constant(0u), 0x01));

               ir_variable *const r29C7 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r29C7, lshift(r29AC, r29AE), 0x01));

               ir_variable *const r29C8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r29CA = equal(r29AE, body.constant(int(0)));
               ir_if *f29C9 = new(mem_ctx) ir_if(operand(r29CA).val);
               exec_list *const f29C9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f29C9->then_instructions;

                  body.emit(assign(r29C8, r29AB, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f29C9->else_instructions;

                  ir_expression *const r29CB = lshift(r29AB, r29AE);
                  ir_expression *const r29CC = neg(r29AE);
                  ir_expression *const r29CD = bit_and(r29CC, body.constant(int(31)));
                  ir_expression *const r29CE = rshift(r29AC, r29CD);
                  body.emit(assign(r29C8, bit_or(r29CB, r29CE), 0x01));


               body.instructions = f29C9_parent_instructions;
               body.emit(f29C9);

               /* END IF */

               body.emit(assign(r29AB, r29C8, 0x01));

               body.emit(assign(r29AC, r29C7, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f29C5->else_instructions;

               ir_variable *const r29CF = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r29CF, body.constant(0u), 0x01));

               ir_variable *const r29D0 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r29D0, neg(r29AE), 0x01));

               ir_variable *const r29D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r29D1);
               ir_variable *const r29D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r29D2);
               ir_variable *const r29D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r29D3);
               ir_variable *const r29D4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r29D5 = neg(r29D0);
               body.emit(assign(r29D4, bit_and(r29D5, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r29D7 = equal(r29D0, body.constant(int(0)));
               ir_if *f29D6 = new(mem_ctx) ir_if(operand(r29D7).val);
               exec_list *const f29D6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f29D6->then_instructions;

                  body.emit(assign(r29D1, r29CF, 0x01));

                  body.emit(assign(r29D2, r29AC, 0x01));

                  body.emit(assign(r29D3, r29AB, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f29D6->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r29D9 = less(r29D0, body.constant(int(32)));
                  ir_if *f29D8 = new(mem_ctx) ir_if(operand(r29D9).val);
                  exec_list *const f29D8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f29D8->then_instructions;

                     body.emit(assign(r29D1, lshift(r29AC, r29D4), 0x01));

                     ir_expression *const r29DA = lshift(r29AB, r29D4);
                     ir_expression *const r29DB = rshift(r29AC, r29D0);
                     body.emit(assign(r29D2, bit_or(r29DA, r29DB), 0x01));

                     body.emit(assign(r29D3, rshift(r29AB, r29D0), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f29D8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r29DD = equal(r29D0, body.constant(int(32)));
                     ir_if *f29DC = new(mem_ctx) ir_if(operand(r29DD).val);
                     exec_list *const f29DC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f29DC->then_instructions;

                        body.emit(assign(r29D1, r29AC, 0x01));

                        body.emit(assign(r29D2, r29AB, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f29DC->else_instructions;

                        body.emit(assign(r29CF, bit_or(body.constant(0u), r29AC), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r29DF = less(r29D0, body.constant(int(64)));
                        ir_if *f29DE = new(mem_ctx) ir_if(operand(r29DF).val);
                        exec_list *const f29DE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f29DE->then_instructions;

                           body.emit(assign(r29D1, lshift(r29AB, r29D4), 0x01));

                           ir_expression *const r29E0 = bit_and(r29D0, body.constant(int(31)));
                           body.emit(assign(r29D2, rshift(r29AB, r29E0), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f29DE->else_instructions;

                           ir_variable *const r29E1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r29E3 = equal(r29D0, body.constant(int(64)));
                           ir_if *f29E2 = new(mem_ctx) ir_if(operand(r29E3).val);
                           exec_list *const f29E2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29E2->then_instructions;

                              body.emit(assign(r29E1, r29AB, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29E2->else_instructions;

                              ir_expression *const r29E4 = nequal(r29AB, body.constant(0u));
                              ir_expression *const r29E5 = expr(ir_unop_b2i, r29E4);
                              body.emit(assign(r29E1, expr(ir_unop_i2u, r29E5), 0x01));


                           body.instructions = f29E2_parent_instructions;
                           body.emit(f29E2);

                           /* END IF */

                           body.emit(assign(r29D1, r29E1, 0x01));

                           body.emit(assign(r29D2, body.constant(0u), 0x01));


                        body.instructions = f29DE_parent_instructions;
                        body.emit(f29DE);

                        /* END IF */


                     body.instructions = f29DC_parent_instructions;
                     body.emit(f29DC);

                     /* END IF */

                     body.emit(assign(r29D3, body.constant(0u), 0x01));


                  body.instructions = f29D8_parent_instructions;
                  body.emit(f29D8);

                  /* END IF */

                  ir_expression *const r29E6 = nequal(r29CF, body.constant(0u));
                  ir_expression *const r29E7 = expr(ir_unop_b2i, r29E6);
                  ir_expression *const r29E8 = expr(ir_unop_i2u, r29E7);
                  body.emit(assign(r29D1, bit_or(r29D1, r29E8), 0x01));


               body.instructions = f29D6_parent_instructions;
               body.emit(f29D6);

               /* END IF */

               body.emit(assign(r29AB, r29D3, 0x01));

               body.emit(assign(r29AC, r29D2, 0x01));

               body.emit(assign(r29AD, r29D1, 0x01));


            body.instructions = f29C5_parent_instructions;
            body.emit(f29C5);

            /* END IF */

            body.emit(assign(r29AA, sub(r29AA, r29AE), 0x01));

            ir_variable *const r29E9 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r29E9, r29AA, 0x01));

            ir_variable *const r29EA = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r29EA, r29AB, 0x01));

            ir_variable *const r29EB = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r29EB, r29AC, 0x01));

            ir_variable *const r29EC = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r29EC, r29AD, 0x01));

            ir_variable *const r29ED = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r29ED, body.constant(true), 0x01));

            ir_variable *const r29EE = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r29EF = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r29EF);
            ir_expression *const r29F0 = expr(ir_unop_u2i, r29AD);
            body.emit(assign(r29EF, less(r29F0, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r29F2 = lequal(body.constant(int(2045)), r29AA);
            ir_if *f29F1 = new(mem_ctx) ir_if(operand(r29F2).val);
            exec_list *const f29F1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f29F1->then_instructions;

               ir_variable *const r29F3 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r29F5 = less(body.constant(int(2045)), r29AA);
               ir_if *f29F4 = new(mem_ctx) ir_if(operand(r29F5).val);
               exec_list *const f29F4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f29F4->then_instructions;

                  body.emit(assign(r29F3, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f29F4->else_instructions;

                  ir_variable *const r29F6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r29F8 = equal(r29AA, body.constant(int(2045)));
                  ir_if *f29F7 = new(mem_ctx) ir_if(operand(r29F8).val);
                  exec_list *const f29F7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f29F7->then_instructions;

                     ir_expression *const r29F9 = equal(body.constant(2097151u), r29AB);
                     ir_expression *const r29FA = equal(body.constant(4294967295u), r29AC);
                     body.emit(assign(r29F6, logic_and(r29F9, r29FA), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f29F7->else_instructions;

                     body.emit(assign(r29F6, body.constant(false), 0x01));


                  body.instructions = f29F7_parent_instructions;
                  body.emit(f29F7);

                  /* END IF */

                  body.emit(assign(r29F3, logic_and(r29F6, r29EF), 0x01));


               body.instructions = f29F4_parent_instructions;
               body.emit(f29F4);

               /* END IF */

               /* IF CONDITION */
               ir_if *f29FB = new(mem_ctx) ir_if(operand(r29F3).val);
               exec_list *const f29FB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f29FB->then_instructions;

                  ir_variable *const r29FC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r29FC);
                  ir_expression *const r29FD = lshift(r2797, body.constant(int(31)));
                  body.emit(assign(r29FC, add(r29FD, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r29FC, body.constant(0u), 0x01));

                  body.emit(assign(r29EE, r29FC, 0x03));

                  body.emit(assign(r29ED, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f29FB->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r29FF = less(r29AA, body.constant(int(0)));
                  ir_if *f29FE = new(mem_ctx) ir_if(operand(r29FF).val);
                  exec_list *const f29FE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f29FE->then_instructions;

                     ir_variable *const r2A00 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r2A00, r29AD, 0x01));

                     ir_variable *const r2A01 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r2A01, neg(r29AA), 0x01));

                     ir_variable *const r2A02 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2A02);
                     ir_variable *const r2A03 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2A03);
                     ir_variable *const r2A04 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2A04);
                     ir_variable *const r2A05 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r2A06 = neg(r2A01);
                     body.emit(assign(r2A05, bit_and(r2A06, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2A08 = equal(r2A01, body.constant(int(0)));
                     ir_if *f2A07 = new(mem_ctx) ir_if(operand(r2A08).val);
                     exec_list *const f2A07_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2A07->then_instructions;

                        body.emit(assign(r2A02, r29AD, 0x01));

                        body.emit(assign(r2A03, r29AC, 0x01));

                        body.emit(assign(r2A04, r29AB, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2A07->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2A0A = less(r2A01, body.constant(int(32)));
                        ir_if *f2A09 = new(mem_ctx) ir_if(operand(r2A0A).val);
                        exec_list *const f2A09_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2A09->then_instructions;

                           body.emit(assign(r2A02, lshift(r29AC, r2A05), 0x01));

                           ir_expression *const r2A0B = lshift(r29AB, r2A05);
                           ir_expression *const r2A0C = rshift(r29AC, r2A01);
                           body.emit(assign(r2A03, bit_or(r2A0B, r2A0C), 0x01));

                           body.emit(assign(r2A04, rshift(r29AB, r2A01), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2A09->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2A0E = equal(r2A01, body.constant(int(32)));
                           ir_if *f2A0D = new(mem_ctx) ir_if(operand(r2A0E).val);
                           exec_list *const f2A0D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A0D->then_instructions;

                              body.emit(assign(r2A02, r29AC, 0x01));

                              body.emit(assign(r2A03, r29AB, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2A0D->else_instructions;

                              body.emit(assign(r2A00, bit_or(r29AD, r29AC), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2A10 = less(r2A01, body.constant(int(64)));
                              ir_if *f2A0F = new(mem_ctx) ir_if(operand(r2A10).val);
                              exec_list *const f2A0F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A0F->then_instructions;

                                 body.emit(assign(r2A02, lshift(r29AB, r2A05), 0x01));

                                 ir_expression *const r2A11 = bit_and(r2A01, body.constant(int(31)));
                                 body.emit(assign(r2A03, rshift(r29AB, r2A11), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A0F->else_instructions;

                                 ir_variable *const r2A12 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2A14 = equal(r2A01, body.constant(int(64)));
                                 ir_if *f2A13 = new(mem_ctx) ir_if(operand(r2A14).val);
                                 exec_list *const f2A13_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A13->then_instructions;

                                    body.emit(assign(r2A12, r29AB, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2A13->else_instructions;

                                    ir_expression *const r2A15 = nequal(r29AB, body.constant(0u));
                                    ir_expression *const r2A16 = expr(ir_unop_b2i, r2A15);
                                    body.emit(assign(r2A12, expr(ir_unop_i2u, r2A16), 0x01));


                                 body.instructions = f2A13_parent_instructions;
                                 body.emit(f2A13);

                                 /* END IF */

                                 body.emit(assign(r2A02, r2A12, 0x01));

                                 body.emit(assign(r2A03, body.constant(0u), 0x01));


                              body.instructions = f2A0F_parent_instructions;
                              body.emit(f2A0F);

                              /* END IF */


                           body.instructions = f2A0D_parent_instructions;
                           body.emit(f2A0D);

                           /* END IF */

                           body.emit(assign(r2A04, body.constant(0u), 0x01));


                        body.instructions = f2A09_parent_instructions;
                        body.emit(f2A09);

                        /* END IF */

                        ir_expression *const r2A17 = nequal(r2A00, body.constant(0u));
                        ir_expression *const r2A18 = expr(ir_unop_b2i, r2A17);
                        ir_expression *const r2A19 = expr(ir_unop_i2u, r2A18);
                        body.emit(assign(r2A02, bit_or(r2A02, r2A19), 0x01));


                     body.instructions = f2A07_parent_instructions;
                     body.emit(f2A07);

                     /* END IF */

                     body.emit(assign(r29EA, r2A04, 0x01));

                     body.emit(assign(r29EB, r2A03, 0x01));

                     body.emit(assign(r29EC, r2A02, 0x01));

                     body.emit(assign(r29E9, body.constant(int(0)), 0x01));

                     body.emit(assign(r29EF, less(r2A02, body.constant(0u)), 0x01));


                  body.instructions = f29FE_parent_instructions;
                  body.emit(f29FE);

                  /* END IF */


               body.instructions = f29FB_parent_instructions;
               body.emit(f29FB);

               /* END IF */


            body.instructions = f29F1_parent_instructions;
            body.emit(f29F1);

            /* END IF */

            /* IF CONDITION */
            ir_if *f2A1A = new(mem_ctx) ir_if(operand(r29ED).val);
            exec_list *const f2A1A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2A1A->then_instructions;

               /* IF CONDITION */
               ir_if *f2A1B = new(mem_ctx) ir_if(operand(r29EF).val);
               exec_list *const f2A1B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2A1B->then_instructions;

                  ir_variable *const r2A1C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2A1C, add(r29EB, body.constant(1u)), 0x01));

                  ir_expression *const r2A1D = less(r2A1C, r29EB);
                  ir_expression *const r2A1E = expr(ir_unop_b2i, r2A1D);
                  ir_expression *const r2A1F = expr(ir_unop_i2u, r2A1E);
                  body.emit(assign(r29EA, add(r29EA, r2A1F), 0x01));

                  ir_expression *const r2A20 = equal(r29EC, body.constant(0u));
                  ir_expression *const r2A21 = expr(ir_unop_b2i, r2A20);
                  ir_expression *const r2A22 = expr(ir_unop_i2u, r2A21);
                  ir_expression *const r2A23 = add(r29EC, r2A22);
                  ir_expression *const r2A24 = bit_and(r2A23, body.constant(1u));
                  ir_expression *const r2A25 = expr(ir_unop_bit_not, r2A24);
                  body.emit(assign(r29EB, bit_and(r2A1C, r2A25), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2A1B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2A27 = bit_or(r29EA, r29EB);
                  ir_expression *const r2A28 = equal(r2A27, body.constant(0u));
                  ir_if *f2A26 = new(mem_ctx) ir_if(operand(r2A28).val);
                  exec_list *const f2A26_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A26->then_instructions;

                     body.emit(assign(r29E9, body.constant(int(0)), 0x01));


                  body.instructions = f2A26_parent_instructions;
                  body.emit(f2A26);

                  /* END IF */


               body.instructions = f2A1B_parent_instructions;
               body.emit(f2A1B);

               /* END IF */

               ir_variable *const r2A29 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r2A29);
               ir_expression *const r2A2A = lshift(r2797, body.constant(int(31)));
               ir_expression *const r2A2B = expr(ir_unop_i2u, r29E9);
               ir_expression *const r2A2C = lshift(r2A2B, body.constant(int(20)));
               ir_expression *const r2A2D = add(r2A2A, r2A2C);
               body.emit(assign(r2A29, add(r2A2D, r29EA), 0x02));

               body.emit(assign(r2A29, r29EB, 0x01));

               body.emit(assign(r29EE, r2A29, 0x03));

               body.emit(assign(r29ED, body.constant(false), 0x01));


            body.instructions = f2A1A_parent_instructions;
            body.emit(f2A1A);

            /* END IF */

            body.emit(assign(r2945, r29EE, 0x03));


         body.instructions = f2960_parent_instructions;
         body.emit(f2960);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f295E->else_instructions;

         /* IF CONDITION */
         ir_expression *const r2A2F = less(r2946, body.constant(int(0)));
         ir_if *f2A2E = new(mem_ctx) ir_if(operand(r2A2F).val);
         exec_list *const f2A2E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2A2E->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2A31 = equal(r2951, body.constant(int(2047)));
            ir_if *f2A30 = new(mem_ctx) ir_if(operand(r2A31).val);
            exec_list *const f2A30_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2A30->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2A33 = bit_or(r2949, r294A);
               ir_expression *const r2A34 = nequal(r2A33, body.constant(0u));
               ir_if *f2A32 = new(mem_ctx) ir_if(operand(r2A34).val);
               exec_list *const f2A32_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2A32->then_instructions;

                  ir_variable *const r2A35 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2A35, swizzle_x(r21C2), 0x01));

                  ir_variable *const r2A36 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2A36, swizzle_x(r278D), 0x01));

                  ir_variable *const r2A37 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2A38 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r2A39 = rshift(swizzle_y(r21C2), body.constant(int(19)));
                  ir_expression *const r2A3A = bit_and(r2A39, body.constant(4095u));
                  ir_expression *const r2A3B = equal(r2A3A, body.constant(4094u));
                  ir_expression *const r2A3C = nequal(swizzle_x(r21C2), body.constant(0u));
                  ir_expression *const r2A3D = bit_and(swizzle_y(r21C2), body.constant(524287u));
                  ir_expression *const r2A3E = nequal(r2A3D, body.constant(0u));
                  ir_expression *const r2A3F = logic_or(r2A3C, r2A3E);
                  body.emit(assign(r2A38, logic_and(r2A3B, r2A3F), 0x01));

                  ir_variable *const r2A40 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r2A41 = lshift(swizzle_y(r278D), body.constant(int(1)));
                  ir_expression *const r2A42 = lequal(body.constant(4292870144u), r2A41);
                  ir_expression *const r2A43 = nequal(swizzle_x(r278D), body.constant(0u));
                  ir_expression *const r2A44 = bit_and(swizzle_y(r278D), body.constant(1048575u));
                  ir_expression *const r2A45 = nequal(r2A44, body.constant(0u));
                  ir_expression *const r2A46 = logic_or(r2A43, r2A45);
                  body.emit(assign(r2A40, logic_and(r2A42, r2A46), 0x01));

                  body.emit(assign(r2A35, bit_or(swizzle_y(r21C2), body.constant(524288u)), 0x02));

                  body.emit(assign(r2A36, bit_or(swizzle_y(r278D), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2A48 = lshift(swizzle_y(r21C2), body.constant(int(1)));
                  ir_expression *const r2A49 = lequal(body.constant(4292870144u), r2A48);
                  ir_expression *const r2A4A = nequal(swizzle_x(r21C2), body.constant(0u));
                  ir_expression *const r2A4B = bit_and(swizzle_y(r21C2), body.constant(1048575u));
                  ir_expression *const r2A4C = nequal(r2A4B, body.constant(0u));
                  ir_expression *const r2A4D = logic_or(r2A4A, r2A4C);
                  ir_expression *const r2A4E = logic_and(r2A49, r2A4D);
                  ir_if *f2A47 = new(mem_ctx) ir_if(operand(r2A4E).val);
                  exec_list *const f2A47_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A47->then_instructions;

                     ir_variable *const r2A4F = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2A51 = logic_and(r2A38, r2A40);
                     ir_if *f2A50 = new(mem_ctx) ir_if(operand(r2A51).val);
                     exec_list *const f2A50_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2A50->then_instructions;

                        body.emit(assign(r2A4F, r2A36, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2A50->else_instructions;

                        body.emit(assign(r2A4F, r2A35, 0x03));


                     body.instructions = f2A50_parent_instructions;
                     body.emit(f2A50);

                     /* END IF */

                     body.emit(assign(r2A37, r2A4F, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2A47->else_instructions;

                     body.emit(assign(r2A37, r2A36, 0x03));


                  body.instructions = f2A47_parent_instructions;
                  body.emit(f2A47);

                  /* END IF */

                  body.emit(assign(r2945, r2A37, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2A32->else_instructions;

                  ir_variable *const r2A52 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2A52);
                  ir_expression *const r2A53 = bit_xor(r2797, body.constant(1u));
                  ir_expression *const r2A54 = lshift(r2A53, body.constant(int(31)));
                  body.emit(assign(r2A52, add(r2A54, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r2A52, body.constant(0u), 0x01));

                  body.emit(assign(r2945, r2A52, 0x03));


               body.instructions = f2A32_parent_instructions;
               body.emit(f2A32);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2A30->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2A56 = equal(r294E, body.constant(int(0)));
               ir_if *f2A55 = new(mem_ctx) ir_if(operand(r2A56).val);
               exec_list *const f2A55_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2A55->then_instructions;

                  body.emit(assign(r2946, add(r2946, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2A55->else_instructions;

                  body.emit(assign(r294B, bit_or(r294B, body.constant(1073741824u)), 0x01));


               body.instructions = f2A55_parent_instructions;
               body.emit(f2A55);

               /* END IF */

               ir_variable *const r2A57 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2A57, neg(r2946), 0x01));

               ir_variable *const r2A58 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2A58);
               ir_variable *const r2A59 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2A59);
               ir_variable *const r2A5A = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2A5B = neg(r2A57);
               body.emit(assign(r2A5A, bit_and(r2A5B, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2A5D = equal(r2A57, body.constant(int(0)));
               ir_if *f2A5C = new(mem_ctx) ir_if(operand(r2A5D).val);
               exec_list *const f2A5C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2A5C->then_instructions;

                  body.emit(assign(r2A58, r2954, 0x01));

                  body.emit(assign(r2A59, r294B, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2A5C->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2A5F = less(r2A57, body.constant(int(32)));
                  ir_if *f2A5E = new(mem_ctx) ir_if(operand(r2A5F).val);
                  exec_list *const f2A5E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A5E->then_instructions;

                     ir_expression *const r2A60 = lshift(r294B, r2A5A);
                     ir_expression *const r2A61 = rshift(r2954, r2A57);
                     ir_expression *const r2A62 = bit_or(r2A60, r2A61);
                     ir_expression *const r2A63 = lshift(r2954, r2A5A);
                     ir_expression *const r2A64 = nequal(r2A63, body.constant(0u));
                     ir_expression *const r2A65 = expr(ir_unop_b2i, r2A64);
                     ir_expression *const r2A66 = expr(ir_unop_i2u, r2A65);
                     body.emit(assign(r2A58, bit_or(r2A62, r2A66), 0x01));

                     body.emit(assign(r2A59, rshift(r294B, r2A57), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2A5E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2A68 = equal(r2A57, body.constant(int(32)));
                     ir_if *f2A67 = new(mem_ctx) ir_if(operand(r2A68).val);
                     exec_list *const f2A67_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2A67->then_instructions;

                        ir_expression *const r2A69 = nequal(r2954, body.constant(0u));
                        ir_expression *const r2A6A = expr(ir_unop_b2i, r2A69);
                        ir_expression *const r2A6B = expr(ir_unop_i2u, r2A6A);
                        body.emit(assign(r2A58, bit_or(r294B, r2A6B), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2A67->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2A6D = less(r2A57, body.constant(int(64)));
                        ir_if *f2A6C = new(mem_ctx) ir_if(operand(r2A6D).val);
                        exec_list *const f2A6C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2A6C->then_instructions;

                           ir_expression *const r2A6E = bit_and(r2A57, body.constant(int(31)));
                           ir_expression *const r2A6F = rshift(r294B, r2A6E);
                           ir_expression *const r2A70 = lshift(r294B, r2A5A);
                           ir_expression *const r2A71 = bit_or(r2A70, r2954);
                           ir_expression *const r2A72 = nequal(r2A71, body.constant(0u));
                           ir_expression *const r2A73 = expr(ir_unop_b2i, r2A72);
                           ir_expression *const r2A74 = expr(ir_unop_i2u, r2A73);
                           body.emit(assign(r2A58, bit_or(r2A6F, r2A74), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2A6C->else_instructions;

                           ir_expression *const r2A75 = bit_or(r294B, r2954);
                           ir_expression *const r2A76 = nequal(r2A75, body.constant(0u));
                           ir_expression *const r2A77 = expr(ir_unop_b2i, r2A76);
                           body.emit(assign(r2A58, expr(ir_unop_i2u, r2A77), 0x01));


                        body.instructions = f2A6C_parent_instructions;
                        body.emit(f2A6C);

                        /* END IF */


                     body.instructions = f2A67_parent_instructions;
                     body.emit(f2A67);

                     /* END IF */

                     body.emit(assign(r2A59, body.constant(0u), 0x01));


                  body.instructions = f2A5E_parent_instructions;
                  body.emit(f2A5E);

                  /* END IF */


               body.instructions = f2A5C_parent_instructions;
               body.emit(f2A5C);

               /* END IF */

               body.emit(assign(r294B, r2A59, 0x01));

               body.emit(assign(r294C, r2A58, 0x01));

               body.emit(assign(r2949, bit_or(r2949, body.constant(1073741824u)), 0x01));

               ir_variable *const r2A78 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r2A79 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2A79, sub(r294A, r2A58), 0x01));

               ir_expression *const r2A7A = sub(r2949, r2A59);
               ir_expression *const r2A7B = less(r294A, r2A58);
               ir_expression *const r2A7C = expr(ir_unop_b2i, r2A7B);
               ir_expression *const r2A7D = expr(ir_unop_i2u, r2A7C);
               body.emit(assign(r2A78, sub(r2A7A, r2A7D), 0x01));

               body.emit(assign(r2944, bit_xor(r2797, body.constant(1u)), 0x01));

               body.emit(assign(r294D, add(r2951, body.constant(int(-1))), 0x01));

               ir_variable *const r2A7E = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2A7E, add(r294D, body.constant(int(-10))), 0x01));

               ir_variable *const r2A7F = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2A7F, r2A78, 0x01));

               ir_variable *const r2A80 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2A80, r2A79, 0x01));

               ir_variable *const r2A81 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2A81);
               ir_variable *const r2A82 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2A82);
               /* IF CONDITION */
               ir_expression *const r2A84 = equal(r2A78, body.constant(0u));
               ir_if *f2A83 = new(mem_ctx) ir_if(operand(r2A84).val);
               exec_list *const f2A83_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2A83->then_instructions;

                  body.emit(assign(r2A7F, r2A79, 0x01));

                  body.emit(assign(r2A80, body.constant(0u), 0x01));

                  body.emit(assign(r2A7E, add(r2A7E, body.constant(int(-32))), 0x01));


               body.instructions = f2A83_parent_instructions;
               body.emit(f2A83);

               /* END IF */

               ir_variable *const r2A85 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2A85, r2A7F, 0x01));

               ir_variable *const r2A86 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r2A87 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2A87);
               /* IF CONDITION */
               ir_expression *const r2A89 = equal(r2A7F, body.constant(0u));
               ir_if *f2A88 = new(mem_ctx) ir_if(operand(r2A89).val);
               exec_list *const f2A88_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2A88->then_instructions;

                  body.emit(assign(r2A86, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2A88->else_instructions;

                  body.emit(assign(r2A87, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2A8B = bit_and(r2A7F, body.constant(4294901760u));
                  ir_expression *const r2A8C = equal(r2A8B, body.constant(0u));
                  ir_if *f2A8A = new(mem_ctx) ir_if(operand(r2A8C).val);
                  exec_list *const f2A8A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A8A->then_instructions;

                     body.emit(assign(r2A87, body.constant(int(16)), 0x01));

                     body.emit(assign(r2A85, lshift(r2A7F, body.constant(int(16))), 0x01));


                  body.instructions = f2A8A_parent_instructions;
                  body.emit(f2A8A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2A8E = bit_and(r2A85, body.constant(4278190080u));
                  ir_expression *const r2A8F = equal(r2A8E, body.constant(0u));
                  ir_if *f2A8D = new(mem_ctx) ir_if(operand(r2A8F).val);
                  exec_list *const f2A8D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A8D->then_instructions;

                     body.emit(assign(r2A87, add(r2A87, body.constant(int(8))), 0x01));

                     body.emit(assign(r2A85, lshift(r2A85, body.constant(int(8))), 0x01));


                  body.instructions = f2A8D_parent_instructions;
                  body.emit(f2A8D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2A91 = bit_and(r2A85, body.constant(4026531840u));
                  ir_expression *const r2A92 = equal(r2A91, body.constant(0u));
                  ir_if *f2A90 = new(mem_ctx) ir_if(operand(r2A92).val);
                  exec_list *const f2A90_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A90->then_instructions;

                     body.emit(assign(r2A87, add(r2A87, body.constant(int(4))), 0x01));

                     body.emit(assign(r2A85, lshift(r2A85, body.constant(int(4))), 0x01));


                  body.instructions = f2A90_parent_instructions;
                  body.emit(f2A90);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2A94 = bit_and(r2A85, body.constant(3221225472u));
                  ir_expression *const r2A95 = equal(r2A94, body.constant(0u));
                  ir_if *f2A93 = new(mem_ctx) ir_if(operand(r2A95).val);
                  exec_list *const f2A93_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A93->then_instructions;

                     body.emit(assign(r2A87, add(r2A87, body.constant(int(2))), 0x01));

                     body.emit(assign(r2A85, lshift(r2A85, body.constant(int(2))), 0x01));


                  body.instructions = f2A93_parent_instructions;
                  body.emit(f2A93);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2A97 = bit_and(r2A85, body.constant(2147483648u));
                  ir_expression *const r2A98 = equal(r2A97, body.constant(0u));
                  ir_if *f2A96 = new(mem_ctx) ir_if(operand(r2A98).val);
                  exec_list *const f2A96_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A96->then_instructions;

                     body.emit(assign(r2A87, add(r2A87, body.constant(int(1))), 0x01));


                  body.instructions = f2A96_parent_instructions;
                  body.emit(f2A96);

                  /* END IF */

                  body.emit(assign(r2A86, r2A87, 0x01));


               body.instructions = f2A88_parent_instructions;
               body.emit(f2A88);

               /* END IF */

               body.emit(assign(r2A82, add(r2A86, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2A9A = lequal(body.constant(int(0)), r2A82);
               ir_if *f2A99 = new(mem_ctx) ir_if(operand(r2A9A).val);
               exec_list *const f2A99_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2A99->then_instructions;

                  body.emit(assign(r2A81, body.constant(0u), 0x01));

                  ir_variable *const r2A9B = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2A9B, lshift(r2A80, r2A82), 0x01));

                  ir_variable *const r2A9C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2A9E = equal(r2A82, body.constant(int(0)));
                  ir_if *f2A9D = new(mem_ctx) ir_if(operand(r2A9E).val);
                  exec_list *const f2A9D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A9D->then_instructions;

                     body.emit(assign(r2A9C, r2A7F, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2A9D->else_instructions;

                     ir_expression *const r2A9F = lshift(r2A7F, r2A82);
                     ir_expression *const r2AA0 = neg(r2A82);
                     ir_expression *const r2AA1 = bit_and(r2AA0, body.constant(int(31)));
                     ir_expression *const r2AA2 = rshift(r2A80, r2AA1);
                     body.emit(assign(r2A9C, bit_or(r2A9F, r2AA2), 0x01));


                  body.instructions = f2A9D_parent_instructions;
                  body.emit(f2A9D);

                  /* END IF */

                  body.emit(assign(r2A7F, r2A9C, 0x01));

                  body.emit(assign(r2A80, r2A9B, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2A99->else_instructions;

                  ir_variable *const r2AA3 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2AA3, body.constant(0u), 0x01));

                  ir_variable *const r2AA4 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2AA4, neg(r2A82), 0x01));

                  ir_variable *const r2AA5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2AA5);
                  ir_variable *const r2AA6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2AA6);
                  ir_variable *const r2AA7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2AA7);
                  ir_variable *const r2AA8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2AA9 = neg(r2AA4);
                  body.emit(assign(r2AA8, bit_and(r2AA9, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2AAB = equal(r2AA4, body.constant(int(0)));
                  ir_if *f2AAA = new(mem_ctx) ir_if(operand(r2AAB).val);
                  exec_list *const f2AAA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2AAA->then_instructions;

                     body.emit(assign(r2AA5, r2AA3, 0x01));

                     body.emit(assign(r2AA6, r2A80, 0x01));

                     body.emit(assign(r2AA7, r2A7F, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2AAA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2AAD = less(r2AA4, body.constant(int(32)));
                     ir_if *f2AAC = new(mem_ctx) ir_if(operand(r2AAD).val);
                     exec_list *const f2AAC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2AAC->then_instructions;

                        body.emit(assign(r2AA5, lshift(r2A80, r2AA8), 0x01));

                        ir_expression *const r2AAE = lshift(r2A7F, r2AA8);
                        ir_expression *const r2AAF = rshift(r2A80, r2AA4);
                        body.emit(assign(r2AA6, bit_or(r2AAE, r2AAF), 0x01));

                        body.emit(assign(r2AA7, rshift(r2A7F, r2AA4), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2AAC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2AB1 = equal(r2AA4, body.constant(int(32)));
                        ir_if *f2AB0 = new(mem_ctx) ir_if(operand(r2AB1).val);
                        exec_list *const f2AB0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2AB0->then_instructions;

                           body.emit(assign(r2AA5, r2A80, 0x01));

                           body.emit(assign(r2AA6, r2A7F, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2AB0->else_instructions;

                           body.emit(assign(r2AA3, bit_or(body.constant(0u), r2A80), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2AB3 = less(r2AA4, body.constant(int(64)));
                           ir_if *f2AB2 = new(mem_ctx) ir_if(operand(r2AB3).val);
                           exec_list *const f2AB2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2AB2->then_instructions;

                              body.emit(assign(r2AA5, lshift(r2A7F, r2AA8), 0x01));

                              ir_expression *const r2AB4 = bit_and(r2AA4, body.constant(int(31)));
                              body.emit(assign(r2AA6, rshift(r2A7F, r2AB4), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2AB2->else_instructions;

                              ir_variable *const r2AB5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2AB7 = equal(r2AA4, body.constant(int(64)));
                              ir_if *f2AB6 = new(mem_ctx) ir_if(operand(r2AB7).val);
                              exec_list *const f2AB6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2AB6->then_instructions;

                                 body.emit(assign(r2AB5, r2A7F, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2AB6->else_instructions;

                                 ir_expression *const r2AB8 = nequal(r2A7F, body.constant(0u));
                                 ir_expression *const r2AB9 = expr(ir_unop_b2i, r2AB8);
                                 body.emit(assign(r2AB5, expr(ir_unop_i2u, r2AB9), 0x01));


                              body.instructions = f2AB6_parent_instructions;
                              body.emit(f2AB6);

                              /* END IF */

                              body.emit(assign(r2AA5, r2AB5, 0x01));

                              body.emit(assign(r2AA6, body.constant(0u), 0x01));


                           body.instructions = f2AB2_parent_instructions;
                           body.emit(f2AB2);

                           /* END IF */


                        body.instructions = f2AB0_parent_instructions;
                        body.emit(f2AB0);

                        /* END IF */

                        body.emit(assign(r2AA7, body.constant(0u), 0x01));


                     body.instructions = f2AAC_parent_instructions;
                     body.emit(f2AAC);

                     /* END IF */

                     ir_expression *const r2ABA = nequal(r2AA3, body.constant(0u));
                     ir_expression *const r2ABB = expr(ir_unop_b2i, r2ABA);
                     ir_expression *const r2ABC = expr(ir_unop_i2u, r2ABB);
                     body.emit(assign(r2AA5, bit_or(r2AA5, r2ABC), 0x01));


                  body.instructions = f2AAA_parent_instructions;
                  body.emit(f2AAA);

                  /* END IF */

                  body.emit(assign(r2A7F, r2AA7, 0x01));

                  body.emit(assign(r2A80, r2AA6, 0x01));

                  body.emit(assign(r2A81, r2AA5, 0x01));


               body.instructions = f2A99_parent_instructions;
               body.emit(f2A99);

               /* END IF */

               body.emit(assign(r2A7E, sub(r2A7E, r2A82), 0x01));

               ir_variable *const r2ABD = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2ABD, r2A7E, 0x01));

               ir_variable *const r2ABE = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2ABE, r2A7F, 0x01));

               ir_variable *const r2ABF = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2ABF, r2A80, 0x01));

               ir_variable *const r2AC0 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2AC0, r2A81, 0x01));

               ir_variable *const r2AC1 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2AC1, body.constant(true), 0x01));

               ir_variable *const r2AC2 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2AC3 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2AC3);
               ir_expression *const r2AC4 = expr(ir_unop_u2i, r2A81);
               body.emit(assign(r2AC3, less(r2AC4, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2AC6 = lequal(body.constant(int(2045)), r2A7E);
               ir_if *f2AC5 = new(mem_ctx) ir_if(operand(r2AC6).val);
               exec_list *const f2AC5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2AC5->then_instructions;

                  ir_variable *const r2AC7 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2AC9 = less(body.constant(int(2045)), r2A7E);
                  ir_if *f2AC8 = new(mem_ctx) ir_if(operand(r2AC9).val);
                  exec_list *const f2AC8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2AC8->then_instructions;

                     body.emit(assign(r2AC7, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2AC8->else_instructions;

                     ir_variable *const r2ACA = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2ACC = equal(r2A7E, body.constant(int(2045)));
                     ir_if *f2ACB = new(mem_ctx) ir_if(operand(r2ACC).val);
                     exec_list *const f2ACB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2ACB->then_instructions;

                        ir_expression *const r2ACD = equal(body.constant(2097151u), r2A7F);
                        ir_expression *const r2ACE = equal(body.constant(4294967295u), r2A80);
                        body.emit(assign(r2ACA, logic_and(r2ACD, r2ACE), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2ACB->else_instructions;

                        body.emit(assign(r2ACA, body.constant(false), 0x01));


                     body.instructions = f2ACB_parent_instructions;
                     body.emit(f2ACB);

                     /* END IF */

                     body.emit(assign(r2AC7, logic_and(r2ACA, r2AC3), 0x01));


                  body.instructions = f2AC8_parent_instructions;
                  body.emit(f2AC8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2ACF = new(mem_ctx) ir_if(operand(r2AC7).val);
                  exec_list *const f2ACF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2ACF->then_instructions;

                     ir_variable *const r2AD0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2AD0);
                     ir_expression *const r2AD1 = lshift(r2944, body.constant(int(31)));
                     body.emit(assign(r2AD0, add(r2AD1, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2AD0, body.constant(0u), 0x01));

                     body.emit(assign(r2AC2, r2AD0, 0x03));

                     body.emit(assign(r2AC1, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2ACF->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2AD3 = less(r2A7E, body.constant(int(0)));
                     ir_if *f2AD2 = new(mem_ctx) ir_if(operand(r2AD3).val);
                     exec_list *const f2AD2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2AD2->then_instructions;

                        ir_variable *const r2AD4 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2AD4, r2A81, 0x01));

                        ir_variable *const r2AD5 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2AD5, neg(r2A7E), 0x01));

                        ir_variable *const r2AD6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2AD6);
                        ir_variable *const r2AD7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2AD7);
                        ir_variable *const r2AD8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2AD8);
                        ir_variable *const r2AD9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2ADA = neg(r2AD5);
                        body.emit(assign(r2AD9, bit_and(r2ADA, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2ADC = equal(r2AD5, body.constant(int(0)));
                        ir_if *f2ADB = new(mem_ctx) ir_if(operand(r2ADC).val);
                        exec_list *const f2ADB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2ADB->then_instructions;

                           body.emit(assign(r2AD6, r2A81, 0x01));

                           body.emit(assign(r2AD7, r2A80, 0x01));

                           body.emit(assign(r2AD8, r2A7F, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2ADB->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2ADE = less(r2AD5, body.constant(int(32)));
                           ir_if *f2ADD = new(mem_ctx) ir_if(operand(r2ADE).val);
                           exec_list *const f2ADD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2ADD->then_instructions;

                              body.emit(assign(r2AD6, lshift(r2A80, r2AD9), 0x01));

                              ir_expression *const r2ADF = lshift(r2A7F, r2AD9);
                              ir_expression *const r2AE0 = rshift(r2A80, r2AD5);
                              body.emit(assign(r2AD7, bit_or(r2ADF, r2AE0), 0x01));

                              body.emit(assign(r2AD8, rshift(r2A7F, r2AD5), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2ADD->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2AE2 = equal(r2AD5, body.constant(int(32)));
                              ir_if *f2AE1 = new(mem_ctx) ir_if(operand(r2AE2).val);
                              exec_list *const f2AE1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2AE1->then_instructions;

                                 body.emit(assign(r2AD6, r2A80, 0x01));

                                 body.emit(assign(r2AD7, r2A7F, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2AE1->else_instructions;

                                 body.emit(assign(r2AD4, bit_or(r2A81, r2A80), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2AE4 = less(r2AD5, body.constant(int(64)));
                                 ir_if *f2AE3 = new(mem_ctx) ir_if(operand(r2AE4).val);
                                 exec_list *const f2AE3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AE3->then_instructions;

                                    body.emit(assign(r2AD6, lshift(r2A7F, r2AD9), 0x01));

                                    ir_expression *const r2AE5 = bit_and(r2AD5, body.constant(int(31)));
                                    body.emit(assign(r2AD7, rshift(r2A7F, r2AE5), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2AE3->else_instructions;

                                    ir_variable *const r2AE6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2AE8 = equal(r2AD5, body.constant(int(64)));
                                    ir_if *f2AE7 = new(mem_ctx) ir_if(operand(r2AE8).val);
                                    exec_list *const f2AE7_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2AE7->then_instructions;

                                       body.emit(assign(r2AE6, r2A7F, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2AE7->else_instructions;

                                       ir_expression *const r2AE9 = nequal(r2A7F, body.constant(0u));
                                       ir_expression *const r2AEA = expr(ir_unop_b2i, r2AE9);
                                       body.emit(assign(r2AE6, expr(ir_unop_i2u, r2AEA), 0x01));


                                    body.instructions = f2AE7_parent_instructions;
                                    body.emit(f2AE7);

                                    /* END IF */

                                    body.emit(assign(r2AD6, r2AE6, 0x01));

                                    body.emit(assign(r2AD7, body.constant(0u), 0x01));


                                 body.instructions = f2AE3_parent_instructions;
                                 body.emit(f2AE3);

                                 /* END IF */


                              body.instructions = f2AE1_parent_instructions;
                              body.emit(f2AE1);

                              /* END IF */

                              body.emit(assign(r2AD8, body.constant(0u), 0x01));


                           body.instructions = f2ADD_parent_instructions;
                           body.emit(f2ADD);

                           /* END IF */

                           ir_expression *const r2AEB = nequal(r2AD4, body.constant(0u));
                           ir_expression *const r2AEC = expr(ir_unop_b2i, r2AEB);
                           ir_expression *const r2AED = expr(ir_unop_i2u, r2AEC);
                           body.emit(assign(r2AD6, bit_or(r2AD6, r2AED), 0x01));


                        body.instructions = f2ADB_parent_instructions;
                        body.emit(f2ADB);

                        /* END IF */

                        body.emit(assign(r2ABE, r2AD8, 0x01));

                        body.emit(assign(r2ABF, r2AD7, 0x01));

                        body.emit(assign(r2AC0, r2AD6, 0x01));

                        body.emit(assign(r2ABD, body.constant(int(0)), 0x01));

                        body.emit(assign(r2AC3, less(r2AD6, body.constant(0u)), 0x01));


                     body.instructions = f2AD2_parent_instructions;
                     body.emit(f2AD2);

                     /* END IF */


                  body.instructions = f2ACF_parent_instructions;
                  body.emit(f2ACF);

                  /* END IF */


               body.instructions = f2AC5_parent_instructions;
               body.emit(f2AC5);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2AEE = new(mem_ctx) ir_if(operand(r2AC1).val);
               exec_list *const f2AEE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2AEE->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2AEF = new(mem_ctx) ir_if(operand(r2AC3).val);
                  exec_list *const f2AEF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2AEF->then_instructions;

                     ir_variable *const r2AF0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2AF0, add(r2ABF, body.constant(1u)), 0x01));

                     ir_expression *const r2AF1 = less(r2AF0, r2ABF);
                     ir_expression *const r2AF2 = expr(ir_unop_b2i, r2AF1);
                     ir_expression *const r2AF3 = expr(ir_unop_i2u, r2AF2);
                     body.emit(assign(r2ABE, add(r2ABE, r2AF3), 0x01));

                     ir_expression *const r2AF4 = equal(r2AC0, body.constant(0u));
                     ir_expression *const r2AF5 = expr(ir_unop_b2i, r2AF4);
                     ir_expression *const r2AF6 = expr(ir_unop_i2u, r2AF5);
                     ir_expression *const r2AF7 = add(r2AC0, r2AF6);
                     ir_expression *const r2AF8 = bit_and(r2AF7, body.constant(1u));
                     ir_expression *const r2AF9 = expr(ir_unop_bit_not, r2AF8);
                     body.emit(assign(r2ABF, bit_and(r2AF0, r2AF9), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2AEF->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2AFB = bit_or(r2ABE, r2ABF);
                     ir_expression *const r2AFC = equal(r2AFB, body.constant(0u));
                     ir_if *f2AFA = new(mem_ctx) ir_if(operand(r2AFC).val);
                     exec_list *const f2AFA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2AFA->then_instructions;

                        body.emit(assign(r2ABD, body.constant(int(0)), 0x01));


                     body.instructions = f2AFA_parent_instructions;
                     body.emit(f2AFA);

                     /* END IF */


                  body.instructions = f2AEF_parent_instructions;
                  body.emit(f2AEF);

                  /* END IF */

                  ir_variable *const r2AFD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2AFD);
                  ir_expression *const r2AFE = lshift(r2944, body.constant(int(31)));
                  ir_expression *const r2AFF = expr(ir_unop_i2u, r2ABD);
                  ir_expression *const r2B00 = lshift(r2AFF, body.constant(int(20)));
                  ir_expression *const r2B01 = add(r2AFE, r2B00);
                  body.emit(assign(r2AFD, add(r2B01, r2ABE), 0x02));

                  body.emit(assign(r2AFD, r2ABF, 0x01));

                  body.emit(assign(r2AC2, r2AFD, 0x03));

                  body.emit(assign(r2AC1, body.constant(false), 0x01));


               body.instructions = f2AEE_parent_instructions;
               body.emit(f2AEE);

               /* END IF */

               body.emit(assign(r2945, r2AC2, 0x03));


            body.instructions = f2A30_parent_instructions;
            body.emit(f2A30);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2A2E->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2B03 = equal(r294E, body.constant(int(2047)));
            ir_if *f2B02 = new(mem_ctx) ir_if(operand(r2B03).val);
            exec_list *const f2B02_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2B02->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2B05 = bit_or(r294B, r294C);
               ir_expression *const r2B06 = bit_or(r2949, r294A);
               ir_expression *const r2B07 = bit_or(r2B05, r2B06);
               ir_expression *const r2B08 = nequal(r2B07, body.constant(0u));
               ir_if *f2B04 = new(mem_ctx) ir_if(operand(r2B08).val);
               exec_list *const f2B04_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B04->then_instructions;

                  ir_variable *const r2B09 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2B09, swizzle_x(r21C2), 0x01));

                  ir_variable *const r2B0A = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2B0A, swizzle_x(r278D), 0x01));

                  ir_variable *const r2B0B = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2B0C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r2B0D = rshift(swizzle_y(r21C2), body.constant(int(19)));
                  ir_expression *const r2B0E = bit_and(r2B0D, body.constant(4095u));
                  ir_expression *const r2B0F = equal(r2B0E, body.constant(4094u));
                  ir_expression *const r2B10 = nequal(swizzle_x(r21C2), body.constant(0u));
                  ir_expression *const r2B11 = bit_and(swizzle_y(r21C2), body.constant(524287u));
                  ir_expression *const r2B12 = nequal(r2B11, body.constant(0u));
                  ir_expression *const r2B13 = logic_or(r2B10, r2B12);
                  body.emit(assign(r2B0C, logic_and(r2B0F, r2B13), 0x01));

                  ir_variable *const r2B14 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r2B15 = lshift(swizzle_y(r278D), body.constant(int(1)));
                  ir_expression *const r2B16 = lequal(body.constant(4292870144u), r2B15);
                  ir_expression *const r2B17 = nequal(swizzle_x(r278D), body.constant(0u));
                  ir_expression *const r2B18 = bit_and(swizzle_y(r278D), body.constant(1048575u));
                  ir_expression *const r2B19 = nequal(r2B18, body.constant(0u));
                  ir_expression *const r2B1A = logic_or(r2B17, r2B19);
                  body.emit(assign(r2B14, logic_and(r2B16, r2B1A), 0x01));

                  body.emit(assign(r2B09, bit_or(swizzle_y(r21C2), body.constant(524288u)), 0x02));

                  body.emit(assign(r2B0A, bit_or(swizzle_y(r278D), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2B1C = lshift(swizzle_y(r21C2), body.constant(int(1)));
                  ir_expression *const r2B1D = lequal(body.constant(4292870144u), r2B1C);
                  ir_expression *const r2B1E = nequal(swizzle_x(r21C2), body.constant(0u));
                  ir_expression *const r2B1F = bit_and(swizzle_y(r21C2), body.constant(1048575u));
                  ir_expression *const r2B20 = nequal(r2B1F, body.constant(0u));
                  ir_expression *const r2B21 = logic_or(r2B1E, r2B20);
                  ir_expression *const r2B22 = logic_and(r2B1D, r2B21);
                  ir_if *f2B1B = new(mem_ctx) ir_if(operand(r2B22).val);
                  exec_list *const f2B1B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B1B->then_instructions;

                     ir_variable *const r2B23 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2B25 = logic_and(r2B0C, r2B14);
                     ir_if *f2B24 = new(mem_ctx) ir_if(operand(r2B25).val);
                     exec_list *const f2B24_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B24->then_instructions;

                        body.emit(assign(r2B23, r2B0A, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2B24->else_instructions;

                        body.emit(assign(r2B23, r2B09, 0x03));


                     body.instructions = f2B24_parent_instructions;
                     body.emit(f2B24);

                     /* END IF */

                     body.emit(assign(r2B0B, r2B23, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B1B->else_instructions;

                     body.emit(assign(r2B0B, r2B0A, 0x03));


                  body.instructions = f2B1B_parent_instructions;
                  body.emit(f2B1B);

                  /* END IF */

                  body.emit(assign(r2945, r2B0B, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2B04->else_instructions;

                  ir_constant_data r2B26_data;
                  memset(&r2B26_data, 0, sizeof(ir_constant_data));
                  r2B26_data.u[0] = 4294967295;
                  r2B26_data.u[1] = 4294967295;
                  ir_constant *const r2B26 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r2B26_data);
                  body.emit(assign(r2945, r2B26, 0x03));


               body.instructions = f2B04_parent_instructions;
               body.emit(f2B04);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2B02->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2B28 = equal(r294E, body.constant(int(0)));
               ir_if *f2B27 = new(mem_ctx) ir_if(operand(r2B28).val);
               exec_list *const f2B27_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B27->then_instructions;

                  body.emit(assign(r2948, body.constant(int(1)), 0x01));

                  body.emit(assign(r2947, body.constant(int(1)), 0x01));


               body.instructions = f2B27_parent_instructions;
               body.emit(f2B27);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2B2A = less(r2949, r294B);
               ir_if *f2B29 = new(mem_ctx) ir_if(operand(r2B2A).val);
               exec_list *const f2B29_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B29->then_instructions;

                  ir_variable *const r2B2B = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r2B2C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2B2C, sub(r294C, r294A), 0x01));

                  ir_expression *const r2B2D = sub(r294B, r2949);
                  ir_expression *const r2B2E = less(r294C, r294A);
                  ir_expression *const r2B2F = expr(ir_unop_b2i, r2B2E);
                  ir_expression *const r2B30 = expr(ir_unop_i2u, r2B2F);
                  body.emit(assign(r2B2B, sub(r2B2D, r2B30), 0x01));

                  body.emit(assign(r294D, add(r2948, body.constant(int(-1))), 0x01));

                  ir_variable *const r2B31 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r2B31, add(r294D, body.constant(int(-10))), 0x01));

                  ir_variable *const r2B32 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r2B32, r2B2B, 0x01));

                  ir_variable *const r2B33 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r2B33, r2B2C, 0x01));

                  ir_variable *const r2B34 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r2B34);
                  ir_variable *const r2B35 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r2B35);
                  /* IF CONDITION */
                  ir_expression *const r2B37 = equal(r2B2B, body.constant(0u));
                  ir_if *f2B36 = new(mem_ctx) ir_if(operand(r2B37).val);
                  exec_list *const f2B36_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B36->then_instructions;

                     body.emit(assign(r2B32, r2B2C, 0x01));

                     body.emit(assign(r2B33, body.constant(0u), 0x01));

                     body.emit(assign(r2B31, add(r2B31, body.constant(int(-32))), 0x01));


                  body.instructions = f2B36_parent_instructions;
                  body.emit(f2B36);

                  /* END IF */

                  ir_variable *const r2B38 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r2B38, r2B32, 0x01));

                  ir_variable *const r2B39 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r2B3A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r2B3A);
                  /* IF CONDITION */
                  ir_expression *const r2B3C = equal(r2B32, body.constant(0u));
                  ir_if *f2B3B = new(mem_ctx) ir_if(operand(r2B3C).val);
                  exec_list *const f2B3B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B3B->then_instructions;

                     body.emit(assign(r2B39, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B3B->else_instructions;

                     body.emit(assign(r2B3A, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2B3E = bit_and(r2B32, body.constant(4294901760u));
                     ir_expression *const r2B3F = equal(r2B3E, body.constant(0u));
                     ir_if *f2B3D = new(mem_ctx) ir_if(operand(r2B3F).val);
                     exec_list *const f2B3D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B3D->then_instructions;

                        body.emit(assign(r2B3A, body.constant(int(16)), 0x01));

                        body.emit(assign(r2B38, lshift(r2B32, body.constant(int(16))), 0x01));


                     body.instructions = f2B3D_parent_instructions;
                     body.emit(f2B3D);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2B41 = bit_and(r2B38, body.constant(4278190080u));
                     ir_expression *const r2B42 = equal(r2B41, body.constant(0u));
                     ir_if *f2B40 = new(mem_ctx) ir_if(operand(r2B42).val);
                     exec_list *const f2B40_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B40->then_instructions;

                        body.emit(assign(r2B3A, add(r2B3A, body.constant(int(8))), 0x01));

                        body.emit(assign(r2B38, lshift(r2B38, body.constant(int(8))), 0x01));


                     body.instructions = f2B40_parent_instructions;
                     body.emit(f2B40);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2B44 = bit_and(r2B38, body.constant(4026531840u));
                     ir_expression *const r2B45 = equal(r2B44, body.constant(0u));
                     ir_if *f2B43 = new(mem_ctx) ir_if(operand(r2B45).val);
                     exec_list *const f2B43_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B43->then_instructions;

                        body.emit(assign(r2B3A, add(r2B3A, body.constant(int(4))), 0x01));

                        body.emit(assign(r2B38, lshift(r2B38, body.constant(int(4))), 0x01));


                     body.instructions = f2B43_parent_instructions;
                     body.emit(f2B43);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2B47 = bit_and(r2B38, body.constant(3221225472u));
                     ir_expression *const r2B48 = equal(r2B47, body.constant(0u));
                     ir_if *f2B46 = new(mem_ctx) ir_if(operand(r2B48).val);
                     exec_list *const f2B46_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B46->then_instructions;

                        body.emit(assign(r2B3A, add(r2B3A, body.constant(int(2))), 0x01));

                        body.emit(assign(r2B38, lshift(r2B38, body.constant(int(2))), 0x01));


                     body.instructions = f2B46_parent_instructions;
                     body.emit(f2B46);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2B4A = bit_and(r2B38, body.constant(2147483648u));
                     ir_expression *const r2B4B = equal(r2B4A, body.constant(0u));
                     ir_if *f2B49 = new(mem_ctx) ir_if(operand(r2B4B).val);
                     exec_list *const f2B49_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B49->then_instructions;

                        body.emit(assign(r2B3A, add(r2B3A, body.constant(int(1))), 0x01));


                     body.instructions = f2B49_parent_instructions;
                     body.emit(f2B49);

                     /* END IF */

                     body.emit(assign(r2B39, r2B3A, 0x01));


                  body.instructions = f2B3B_parent_instructions;
                  body.emit(f2B3B);

                  /* END IF */

                  body.emit(assign(r2B35, add(r2B39, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2B4D = lequal(body.constant(int(0)), r2B35);
                  ir_if *f2B4C = new(mem_ctx) ir_if(operand(r2B4D).val);
                  exec_list *const f2B4C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B4C->then_instructions;

                     body.emit(assign(r2B34, body.constant(0u), 0x01));

                     ir_variable *const r2B4E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r2B4E, lshift(r2B33, r2B35), 0x01));

                     ir_variable *const r2B4F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2B51 = equal(r2B35, body.constant(int(0)));
                     ir_if *f2B50 = new(mem_ctx) ir_if(operand(r2B51).val);
                     exec_list *const f2B50_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B50->then_instructions;

                        body.emit(assign(r2B4F, r2B32, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2B50->else_instructions;

                        ir_expression *const r2B52 = lshift(r2B32, r2B35);
                        ir_expression *const r2B53 = neg(r2B35);
                        ir_expression *const r2B54 = bit_and(r2B53, body.constant(int(31)));
                        ir_expression *const r2B55 = rshift(r2B33, r2B54);
                        body.emit(assign(r2B4F, bit_or(r2B52, r2B55), 0x01));


                     body.instructions = f2B50_parent_instructions;
                     body.emit(f2B50);

                     /* END IF */

                     body.emit(assign(r2B32, r2B4F, 0x01));

                     body.emit(assign(r2B33, r2B4E, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B4C->else_instructions;

                     ir_variable *const r2B56 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r2B56, body.constant(0u), 0x01));

                     ir_variable *const r2B57 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r2B57, neg(r2B35), 0x01));

                     ir_variable *const r2B58 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2B58);
                     ir_variable *const r2B59 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2B59);
                     ir_variable *const r2B5A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2B5A);
                     ir_variable *const r2B5B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r2B5C = neg(r2B57);
                     body.emit(assign(r2B5B, bit_and(r2B5C, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2B5E = equal(r2B57, body.constant(int(0)));
                     ir_if *f2B5D = new(mem_ctx) ir_if(operand(r2B5E).val);
                     exec_list *const f2B5D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B5D->then_instructions;

                        body.emit(assign(r2B58, r2B56, 0x01));

                        body.emit(assign(r2B59, r2B33, 0x01));

                        body.emit(assign(r2B5A, r2B32, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2B5D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2B60 = less(r2B57, body.constant(int(32)));
                        ir_if *f2B5F = new(mem_ctx) ir_if(operand(r2B60).val);
                        exec_list *const f2B5F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B5F->then_instructions;

                           body.emit(assign(r2B58, lshift(r2B33, r2B5B), 0x01));

                           ir_expression *const r2B61 = lshift(r2B32, r2B5B);
                           ir_expression *const r2B62 = rshift(r2B33, r2B57);
                           body.emit(assign(r2B59, bit_or(r2B61, r2B62), 0x01));

                           body.emit(assign(r2B5A, rshift(r2B32, r2B57), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B5F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2B64 = equal(r2B57, body.constant(int(32)));
                           ir_if *f2B63 = new(mem_ctx) ir_if(operand(r2B64).val);
                           exec_list *const f2B63_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B63->then_instructions;

                              body.emit(assign(r2B58, r2B33, 0x01));

                              body.emit(assign(r2B59, r2B32, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B63->else_instructions;

                              body.emit(assign(r2B56, bit_or(body.constant(0u), r2B33), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2B66 = less(r2B57, body.constant(int(64)));
                              ir_if *f2B65 = new(mem_ctx) ir_if(operand(r2B66).val);
                              exec_list *const f2B65_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2B65->then_instructions;

                                 body.emit(assign(r2B58, lshift(r2B32, r2B5B), 0x01));

                                 ir_expression *const r2B67 = bit_and(r2B57, body.constant(int(31)));
                                 body.emit(assign(r2B59, rshift(r2B32, r2B67), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2B65->else_instructions;

                                 ir_variable *const r2B68 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2B6A = equal(r2B57, body.constant(int(64)));
                                 ir_if *f2B69 = new(mem_ctx) ir_if(operand(r2B6A).val);
                                 exec_list *const f2B69_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2B69->then_instructions;

                                    body.emit(assign(r2B68, r2B32, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2B69->else_instructions;

                                    ir_expression *const r2B6B = nequal(r2B32, body.constant(0u));
                                    ir_expression *const r2B6C = expr(ir_unop_b2i, r2B6B);
                                    body.emit(assign(r2B68, expr(ir_unop_i2u, r2B6C), 0x01));


                                 body.instructions = f2B69_parent_instructions;
                                 body.emit(f2B69);

                                 /* END IF */

                                 body.emit(assign(r2B58, r2B68, 0x01));

                                 body.emit(assign(r2B59, body.constant(0u), 0x01));


                              body.instructions = f2B65_parent_instructions;
                              body.emit(f2B65);

                              /* END IF */


                           body.instructions = f2B63_parent_instructions;
                           body.emit(f2B63);

                           /* END IF */

                           body.emit(assign(r2B5A, body.constant(0u), 0x01));


                        body.instructions = f2B5F_parent_instructions;
                        body.emit(f2B5F);

                        /* END IF */

                        ir_expression *const r2B6D = nequal(r2B56, body.constant(0u));
                        ir_expression *const r2B6E = expr(ir_unop_b2i, r2B6D);
                        ir_expression *const r2B6F = expr(ir_unop_i2u, r2B6E);
                        body.emit(assign(r2B58, bit_or(r2B58, r2B6F), 0x01));


                     body.instructions = f2B5D_parent_instructions;
                     body.emit(f2B5D);

                     /* END IF */

                     body.emit(assign(r2B32, r2B5A, 0x01));

                     body.emit(assign(r2B33, r2B59, 0x01));

                     body.emit(assign(r2B34, r2B58, 0x01));


                  body.instructions = f2B4C_parent_instructions;
                  body.emit(f2B4C);

                  /* END IF */

                  body.emit(assign(r2B31, sub(r2B31, r2B35), 0x01));

                  ir_variable *const r2B70 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r2B70, r2B31, 0x01));

                  ir_variable *const r2B71 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r2B71, r2B32, 0x01));

                  ir_variable *const r2B72 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r2B72, r2B33, 0x01));

                  ir_variable *const r2B73 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r2B73, r2B34, 0x01));

                  ir_variable *const r2B74 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r2B74, body.constant(true), 0x01));

                  ir_variable *const r2B75 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2B76 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r2B76);
                  ir_expression *const r2B77 = expr(ir_unop_u2i, r2B34);
                  body.emit(assign(r2B76, less(r2B77, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2B79 = lequal(body.constant(int(2045)), r2B31);
                  ir_if *f2B78 = new(mem_ctx) ir_if(operand(r2B79).val);
                  exec_list *const f2B78_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B78->then_instructions;

                     ir_variable *const r2B7A = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2B7C = less(body.constant(int(2045)), r2B31);
                     ir_if *f2B7B = new(mem_ctx) ir_if(operand(r2B7C).val);
                     exec_list *const f2B7B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B7B->then_instructions;

                        body.emit(assign(r2B7A, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2B7B->else_instructions;

                        ir_variable *const r2B7D = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2B7F = equal(r2B31, body.constant(int(2045)));
                        ir_if *f2B7E = new(mem_ctx) ir_if(operand(r2B7F).val);
                        exec_list *const f2B7E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B7E->then_instructions;

                           ir_expression *const r2B80 = equal(body.constant(2097151u), r2B32);
                           ir_expression *const r2B81 = equal(body.constant(4294967295u), r2B33);
                           body.emit(assign(r2B7D, logic_and(r2B80, r2B81), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B7E->else_instructions;

                           body.emit(assign(r2B7D, body.constant(false), 0x01));


                        body.instructions = f2B7E_parent_instructions;
                        body.emit(f2B7E);

                        /* END IF */

                        body.emit(assign(r2B7A, logic_and(r2B7D, r2B76), 0x01));


                     body.instructions = f2B7B_parent_instructions;
                     body.emit(f2B7B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2B82 = new(mem_ctx) ir_if(operand(r2B7A).val);
                     exec_list *const f2B82_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B82->then_instructions;

                        ir_variable *const r2B83 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2B83);
                        ir_expression *const r2B84 = lshift(r2944, body.constant(int(31)));
                        body.emit(assign(r2B83, add(r2B84, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r2B83, body.constant(0u), 0x01));

                        body.emit(assign(r2B75, r2B83, 0x03));

                        body.emit(assign(r2B74, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2B82->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2B86 = less(r2B31, body.constant(int(0)));
                        ir_if *f2B85 = new(mem_ctx) ir_if(operand(r2B86).val);
                        exec_list *const f2B85_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B85->then_instructions;

                           ir_variable *const r2B87 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r2B87, r2B34, 0x01));

                           ir_variable *const r2B88 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2B88, neg(r2B31), 0x01));

                           ir_variable *const r2B89 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r2B89);
                           ir_variable *const r2B8A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r2B8A);
                           ir_variable *const r2B8B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r2B8B);
                           ir_variable *const r2B8C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r2B8D = neg(r2B88);
                           body.emit(assign(r2B8C, bit_and(r2B8D, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2B8F = equal(r2B88, body.constant(int(0)));
                           ir_if *f2B8E = new(mem_ctx) ir_if(operand(r2B8F).val);
                           exec_list *const f2B8E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B8E->then_instructions;

                              body.emit(assign(r2B89, r2B34, 0x01));

                              body.emit(assign(r2B8A, r2B33, 0x01));

                              body.emit(assign(r2B8B, r2B32, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B8E->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2B91 = less(r2B88, body.constant(int(32)));
                              ir_if *f2B90 = new(mem_ctx) ir_if(operand(r2B91).val);
                              exec_list *const f2B90_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2B90->then_instructions;

                                 body.emit(assign(r2B89, lshift(r2B33, r2B8C), 0x01));

                                 ir_expression *const r2B92 = lshift(r2B32, r2B8C);
                                 ir_expression *const r2B93 = rshift(r2B33, r2B88);
                                 body.emit(assign(r2B8A, bit_or(r2B92, r2B93), 0x01));

                                 body.emit(assign(r2B8B, rshift(r2B32, r2B88), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2B90->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2B95 = equal(r2B88, body.constant(int(32)));
                                 ir_if *f2B94 = new(mem_ctx) ir_if(operand(r2B95).val);
                                 exec_list *const f2B94_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2B94->then_instructions;

                                    body.emit(assign(r2B89, r2B33, 0x01));

                                    body.emit(assign(r2B8A, r2B32, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2B94->else_instructions;

                                    body.emit(assign(r2B87, bit_or(r2B34, r2B33), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2B97 = less(r2B88, body.constant(int(64)));
                                    ir_if *f2B96 = new(mem_ctx) ir_if(operand(r2B97).val);
                                    exec_list *const f2B96_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2B96->then_instructions;

                                       body.emit(assign(r2B89, lshift(r2B32, r2B8C), 0x01));

                                       ir_expression *const r2B98 = bit_and(r2B88, body.constant(int(31)));
                                       body.emit(assign(r2B8A, rshift(r2B32, r2B98), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2B96->else_instructions;

                                       ir_variable *const r2B99 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r2B9B = equal(r2B88, body.constant(int(64)));
                                       ir_if *f2B9A = new(mem_ctx) ir_if(operand(r2B9B).val);
                                       exec_list *const f2B9A_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2B9A->then_instructions;

                                          body.emit(assign(r2B99, r2B32, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2B9A->else_instructions;

                                          ir_expression *const r2B9C = nequal(r2B32, body.constant(0u));
                                          ir_expression *const r2B9D = expr(ir_unop_b2i, r2B9C);
                                          body.emit(assign(r2B99, expr(ir_unop_i2u, r2B9D), 0x01));


                                       body.instructions = f2B9A_parent_instructions;
                                       body.emit(f2B9A);

                                       /* END IF */

                                       body.emit(assign(r2B89, r2B99, 0x01));

                                       body.emit(assign(r2B8A, body.constant(0u), 0x01));


                                    body.instructions = f2B96_parent_instructions;
                                    body.emit(f2B96);

                                    /* END IF */


                                 body.instructions = f2B94_parent_instructions;
                                 body.emit(f2B94);

                                 /* END IF */

                                 body.emit(assign(r2B8B, body.constant(0u), 0x01));


                              body.instructions = f2B90_parent_instructions;
                              body.emit(f2B90);

                              /* END IF */

                              ir_expression *const r2B9E = nequal(r2B87, body.constant(0u));
                              ir_expression *const r2B9F = expr(ir_unop_b2i, r2B9E);
                              ir_expression *const r2BA0 = expr(ir_unop_i2u, r2B9F);
                              body.emit(assign(r2B89, bit_or(r2B89, r2BA0), 0x01));


                           body.instructions = f2B8E_parent_instructions;
                           body.emit(f2B8E);

                           /* END IF */

                           body.emit(assign(r2B71, r2B8B, 0x01));

                           body.emit(assign(r2B72, r2B8A, 0x01));

                           body.emit(assign(r2B73, r2B89, 0x01));

                           body.emit(assign(r2B70, body.constant(int(0)), 0x01));

                           body.emit(assign(r2B76, less(r2B89, body.constant(0u)), 0x01));


                        body.instructions = f2B85_parent_instructions;
                        body.emit(f2B85);

                        /* END IF */


                     body.instructions = f2B82_parent_instructions;
                     body.emit(f2B82);

                     /* END IF */


                  body.instructions = f2B78_parent_instructions;
                  body.emit(f2B78);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2BA1 = new(mem_ctx) ir_if(operand(r2B74).val);
                  exec_list *const f2BA1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2BA1->then_instructions;

                     /* IF CONDITION */
                     ir_if *f2BA2 = new(mem_ctx) ir_if(operand(r2B76).val);
                     exec_list *const f2BA2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2BA2->then_instructions;

                        ir_variable *const r2BA3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r2BA3, add(r2B72, body.constant(1u)), 0x01));

                        ir_expression *const r2BA4 = less(r2BA3, r2B72);
                        ir_expression *const r2BA5 = expr(ir_unop_b2i, r2BA4);
                        ir_expression *const r2BA6 = expr(ir_unop_i2u, r2BA5);
                        body.emit(assign(r2B71, add(r2B71, r2BA6), 0x01));

                        ir_expression *const r2BA7 = equal(r2B73, body.constant(0u));
                        ir_expression *const r2BA8 = expr(ir_unop_b2i, r2BA7);
                        ir_expression *const r2BA9 = expr(ir_unop_i2u, r2BA8);
                        ir_expression *const r2BAA = add(r2B73, r2BA9);
                        ir_expression *const r2BAB = bit_and(r2BAA, body.constant(1u));
                        ir_expression *const r2BAC = expr(ir_unop_bit_not, r2BAB);
                        body.emit(assign(r2B72, bit_and(r2BA3, r2BAC), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2BA2->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2BAE = bit_or(r2B71, r2B72);
                        ir_expression *const r2BAF = equal(r2BAE, body.constant(0u));
                        ir_if *f2BAD = new(mem_ctx) ir_if(operand(r2BAF).val);
                        exec_list *const f2BAD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BAD->then_instructions;

                           body.emit(assign(r2B70, body.constant(int(0)), 0x01));


                        body.instructions = f2BAD_parent_instructions;
                        body.emit(f2BAD);

                        /* END IF */


                     body.instructions = f2BA2_parent_instructions;
                     body.emit(f2BA2);

                     /* END IF */

                     ir_variable *const r2BB0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2BB0);
                     ir_expression *const r2BB1 = lshift(r2944, body.constant(int(31)));
                     ir_expression *const r2BB2 = expr(ir_unop_i2u, r2B70);
                     ir_expression *const r2BB3 = lshift(r2BB2, body.constant(int(20)));
                     ir_expression *const r2BB4 = add(r2BB1, r2BB3);
                     body.emit(assign(r2BB0, add(r2BB4, r2B71), 0x02));

                     body.emit(assign(r2BB0, r2B72, 0x01));

                     body.emit(assign(r2B75, r2BB0, 0x03));

                     body.emit(assign(r2B74, body.constant(false), 0x01));


                  body.instructions = f2BA1_parent_instructions;
                  body.emit(f2BA1);

                  /* END IF */

                  body.emit(assign(r2945, r2B75, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2B29->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2BB6 = less(r294B, r2949);
                  ir_if *f2BB5 = new(mem_ctx) ir_if(operand(r2BB6).val);
                  exec_list *const f2BB5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2BB5->then_instructions;

                     ir_variable *const r2BB7 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r2BB8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r2BB8, sub(r294A, r294C), 0x01));

                     ir_expression *const r2BB9 = sub(r2949, r294B);
                     ir_expression *const r2BBA = less(r294A, r294C);
                     ir_expression *const r2BBB = expr(ir_unop_b2i, r2BBA);
                     ir_expression *const r2BBC = expr(ir_unop_i2u, r2BBB);
                     body.emit(assign(r2BB7, sub(r2BB9, r2BBC), 0x01));

                     body.emit(assign(r2944, bit_xor(r2944, body.constant(1u)), 0x01));

                     body.emit(assign(r294D, add(r2947, body.constant(int(-1))), 0x01));

                     ir_variable *const r2BBD = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2BBD, add(r294D, body.constant(int(-10))), 0x01));

                     ir_variable *const r2BBE = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2BBE, r2BB7, 0x01));

                     ir_variable *const r2BBF = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2BBF, r2BB8, 0x01));

                     ir_variable *const r2BC0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r2BC0);
                     ir_variable *const r2BC1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2BC1);
                     /* IF CONDITION */
                     ir_expression *const r2BC3 = equal(r2BB7, body.constant(0u));
                     ir_if *f2BC2 = new(mem_ctx) ir_if(operand(r2BC3).val);
                     exec_list *const f2BC2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2BC2->then_instructions;

                        body.emit(assign(r2BBE, r2BB8, 0x01));

                        body.emit(assign(r2BBF, body.constant(0u), 0x01));

                        body.emit(assign(r2BBD, add(r2BBD, body.constant(int(-32))), 0x01));


                     body.instructions = f2BC2_parent_instructions;
                     body.emit(f2BC2);

                     /* END IF */

                     ir_variable *const r2BC4 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r2BC4, r2BBE, 0x01));

                     ir_variable *const r2BC5 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r2BC6 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2BC6);
                     /* IF CONDITION */
                     ir_expression *const r2BC8 = equal(r2BBE, body.constant(0u));
                     ir_if *f2BC7 = new(mem_ctx) ir_if(operand(r2BC8).val);
                     exec_list *const f2BC7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2BC7->then_instructions;

                        body.emit(assign(r2BC5, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2BC7->else_instructions;

                        body.emit(assign(r2BC6, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2BCA = bit_and(r2BBE, body.constant(4294901760u));
                        ir_expression *const r2BCB = equal(r2BCA, body.constant(0u));
                        ir_if *f2BC9 = new(mem_ctx) ir_if(operand(r2BCB).val);
                        exec_list *const f2BC9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BC9->then_instructions;

                           body.emit(assign(r2BC6, body.constant(int(16)), 0x01));

                           body.emit(assign(r2BC4, lshift(r2BBE, body.constant(int(16))), 0x01));


                        body.instructions = f2BC9_parent_instructions;
                        body.emit(f2BC9);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2BCD = bit_and(r2BC4, body.constant(4278190080u));
                        ir_expression *const r2BCE = equal(r2BCD, body.constant(0u));
                        ir_if *f2BCC = new(mem_ctx) ir_if(operand(r2BCE).val);
                        exec_list *const f2BCC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BCC->then_instructions;

                           body.emit(assign(r2BC6, add(r2BC6, body.constant(int(8))), 0x01));

                           body.emit(assign(r2BC4, lshift(r2BC4, body.constant(int(8))), 0x01));


                        body.instructions = f2BCC_parent_instructions;
                        body.emit(f2BCC);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2BD0 = bit_and(r2BC4, body.constant(4026531840u));
                        ir_expression *const r2BD1 = equal(r2BD0, body.constant(0u));
                        ir_if *f2BCF = new(mem_ctx) ir_if(operand(r2BD1).val);
                        exec_list *const f2BCF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BCF->then_instructions;

                           body.emit(assign(r2BC6, add(r2BC6, body.constant(int(4))), 0x01));

                           body.emit(assign(r2BC4, lshift(r2BC4, body.constant(int(4))), 0x01));


                        body.instructions = f2BCF_parent_instructions;
                        body.emit(f2BCF);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2BD3 = bit_and(r2BC4, body.constant(3221225472u));
                        ir_expression *const r2BD4 = equal(r2BD3, body.constant(0u));
                        ir_if *f2BD2 = new(mem_ctx) ir_if(operand(r2BD4).val);
                        exec_list *const f2BD2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BD2->then_instructions;

                           body.emit(assign(r2BC6, add(r2BC6, body.constant(int(2))), 0x01));

                           body.emit(assign(r2BC4, lshift(r2BC4, body.constant(int(2))), 0x01));


                        body.instructions = f2BD2_parent_instructions;
                        body.emit(f2BD2);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2BD6 = bit_and(r2BC4, body.constant(2147483648u));
                        ir_expression *const r2BD7 = equal(r2BD6, body.constant(0u));
                        ir_if *f2BD5 = new(mem_ctx) ir_if(operand(r2BD7).val);
                        exec_list *const f2BD5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BD5->then_instructions;

                           body.emit(assign(r2BC6, add(r2BC6, body.constant(int(1))), 0x01));


                        body.instructions = f2BD5_parent_instructions;
                        body.emit(f2BD5);

                        /* END IF */

                        body.emit(assign(r2BC5, r2BC6, 0x01));


                     body.instructions = f2BC7_parent_instructions;
                     body.emit(f2BC7);

                     /* END IF */

                     body.emit(assign(r2BC1, add(r2BC5, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2BD9 = lequal(body.constant(int(0)), r2BC1);
                     ir_if *f2BD8 = new(mem_ctx) ir_if(operand(r2BD9).val);
                     exec_list *const f2BD8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2BD8->then_instructions;

                        body.emit(assign(r2BC0, body.constant(0u), 0x01));

                        ir_variable *const r2BDA = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2BDA, lshift(r2BBF, r2BC1), 0x01));

                        ir_variable *const r2BDB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2BDD = equal(r2BC1, body.constant(int(0)));
                        ir_if *f2BDC = new(mem_ctx) ir_if(operand(r2BDD).val);
                        exec_list *const f2BDC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BDC->then_instructions;

                           body.emit(assign(r2BDB, r2BBE, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2BDC->else_instructions;

                           ir_expression *const r2BDE = lshift(r2BBE, r2BC1);
                           ir_expression *const r2BDF = neg(r2BC1);
                           ir_expression *const r2BE0 = bit_and(r2BDF, body.constant(int(31)));
                           ir_expression *const r2BE1 = rshift(r2BBF, r2BE0);
                           body.emit(assign(r2BDB, bit_or(r2BDE, r2BE1), 0x01));


                        body.instructions = f2BDC_parent_instructions;
                        body.emit(f2BDC);

                        /* END IF */

                        body.emit(assign(r2BBE, r2BDB, 0x01));

                        body.emit(assign(r2BBF, r2BDA, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2BD8->else_instructions;

                        ir_variable *const r2BE2 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2BE2, body.constant(0u), 0x01));

                        ir_variable *const r2BE3 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2BE3, neg(r2BC1), 0x01));

                        ir_variable *const r2BE4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2BE4);
                        ir_variable *const r2BE5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2BE5);
                        ir_variable *const r2BE6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2BE6);
                        ir_variable *const r2BE7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2BE8 = neg(r2BE3);
                        body.emit(assign(r2BE7, bit_and(r2BE8, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2BEA = equal(r2BE3, body.constant(int(0)));
                        ir_if *f2BE9 = new(mem_ctx) ir_if(operand(r2BEA).val);
                        exec_list *const f2BE9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BE9->then_instructions;

                           body.emit(assign(r2BE4, r2BE2, 0x01));

                           body.emit(assign(r2BE5, r2BBF, 0x01));

                           body.emit(assign(r2BE6, r2BBE, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2BE9->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2BEC = less(r2BE3, body.constant(int(32)));
                           ir_if *f2BEB = new(mem_ctx) ir_if(operand(r2BEC).val);
                           exec_list *const f2BEB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2BEB->then_instructions;

                              body.emit(assign(r2BE4, lshift(r2BBF, r2BE7), 0x01));

                              ir_expression *const r2BED = lshift(r2BBE, r2BE7);
                              ir_expression *const r2BEE = rshift(r2BBF, r2BE3);
                              body.emit(assign(r2BE5, bit_or(r2BED, r2BEE), 0x01));

                              body.emit(assign(r2BE6, rshift(r2BBE, r2BE3), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2BEB->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2BF0 = equal(r2BE3, body.constant(int(32)));
                              ir_if *f2BEF = new(mem_ctx) ir_if(operand(r2BF0).val);
                              exec_list *const f2BEF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BEF->then_instructions;

                                 body.emit(assign(r2BE4, r2BBF, 0x01));

                                 body.emit(assign(r2BE5, r2BBE, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2BEF->else_instructions;

                                 body.emit(assign(r2BE2, bit_or(body.constant(0u), r2BBF), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2BF2 = less(r2BE3, body.constant(int(64)));
                                 ir_if *f2BF1 = new(mem_ctx) ir_if(operand(r2BF2).val);
                                 exec_list *const f2BF1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2BF1->then_instructions;

                                    body.emit(assign(r2BE4, lshift(r2BBE, r2BE7), 0x01));

                                    ir_expression *const r2BF3 = bit_and(r2BE3, body.constant(int(31)));
                                    body.emit(assign(r2BE5, rshift(r2BBE, r2BF3), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2BF1->else_instructions;

                                    ir_variable *const r2BF4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2BF6 = equal(r2BE3, body.constant(int(64)));
                                    ir_if *f2BF5 = new(mem_ctx) ir_if(operand(r2BF6).val);
                                    exec_list *const f2BF5_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2BF5->then_instructions;

                                       body.emit(assign(r2BF4, r2BBE, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2BF5->else_instructions;

                                       ir_expression *const r2BF7 = nequal(r2BBE, body.constant(0u));
                                       ir_expression *const r2BF8 = expr(ir_unop_b2i, r2BF7);
                                       body.emit(assign(r2BF4, expr(ir_unop_i2u, r2BF8), 0x01));


                                    body.instructions = f2BF5_parent_instructions;
                                    body.emit(f2BF5);

                                    /* END IF */

                                    body.emit(assign(r2BE4, r2BF4, 0x01));

                                    body.emit(assign(r2BE5, body.constant(0u), 0x01));


                                 body.instructions = f2BF1_parent_instructions;
                                 body.emit(f2BF1);

                                 /* END IF */


                              body.instructions = f2BEF_parent_instructions;
                              body.emit(f2BEF);

                              /* END IF */

                              body.emit(assign(r2BE6, body.constant(0u), 0x01));


                           body.instructions = f2BEB_parent_instructions;
                           body.emit(f2BEB);

                           /* END IF */

                           ir_expression *const r2BF9 = nequal(r2BE2, body.constant(0u));
                           ir_expression *const r2BFA = expr(ir_unop_b2i, r2BF9);
                           ir_expression *const r2BFB = expr(ir_unop_i2u, r2BFA);
                           body.emit(assign(r2BE4, bit_or(r2BE4, r2BFB), 0x01));


                        body.instructions = f2BE9_parent_instructions;
                        body.emit(f2BE9);

                        /* END IF */

                        body.emit(assign(r2BBE, r2BE6, 0x01));

                        body.emit(assign(r2BBF, r2BE5, 0x01));

                        body.emit(assign(r2BC0, r2BE4, 0x01));


                     body.instructions = f2BD8_parent_instructions;
                     body.emit(f2BD8);

                     /* END IF */

                     body.emit(assign(r2BBD, sub(r2BBD, r2BC1), 0x01));

                     ir_variable *const r2BFC = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2BFC, r2BBD, 0x01));

                     ir_variable *const r2BFD = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2BFD, r2BBE, 0x01));

                     ir_variable *const r2BFE = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2BFE, r2BBF, 0x01));

                     ir_variable *const r2BFF = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2BFF, r2BC0, 0x01));

                     ir_variable *const r2C00 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2C00, body.constant(true), 0x01));

                     ir_variable *const r2C01 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2C02 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2C02);
                     ir_expression *const r2C03 = expr(ir_unop_u2i, r2BC0);
                     body.emit(assign(r2C02, less(r2C03, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2C05 = lequal(body.constant(int(2045)), r2BBD);
                     ir_if *f2C04 = new(mem_ctx) ir_if(operand(r2C05).val);
                     exec_list *const f2C04_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2C04->then_instructions;

                        ir_variable *const r2C06 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2C08 = less(body.constant(int(2045)), r2BBD);
                        ir_if *f2C07 = new(mem_ctx) ir_if(operand(r2C08).val);
                        exec_list *const f2C07_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2C07->then_instructions;

                           body.emit(assign(r2C06, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2C07->else_instructions;

                           ir_variable *const r2C09 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2C0B = equal(r2BBD, body.constant(int(2045)));
                           ir_if *f2C0A = new(mem_ctx) ir_if(operand(r2C0B).val);
                           exec_list *const f2C0A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C0A->then_instructions;

                              ir_expression *const r2C0C = equal(body.constant(2097151u), r2BBE);
                              ir_expression *const r2C0D = equal(body.constant(4294967295u), r2BBF);
                              body.emit(assign(r2C09, logic_and(r2C0C, r2C0D), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2C0A->else_instructions;

                              body.emit(assign(r2C09, body.constant(false), 0x01));


                           body.instructions = f2C0A_parent_instructions;
                           body.emit(f2C0A);

                           /* END IF */

                           body.emit(assign(r2C06, logic_and(r2C09, r2C02), 0x01));


                        body.instructions = f2C07_parent_instructions;
                        body.emit(f2C07);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2C0E = new(mem_ctx) ir_if(operand(r2C06).val);
                        exec_list *const f2C0E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2C0E->then_instructions;

                           ir_variable *const r2C0F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2C0F);
                           ir_expression *const r2C10 = lshift(r2944, body.constant(int(31)));
                           body.emit(assign(r2C0F, add(r2C10, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2C0F, body.constant(0u), 0x01));

                           body.emit(assign(r2C01, r2C0F, 0x03));

                           body.emit(assign(r2C00, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2C0E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2C12 = less(r2BBD, body.constant(int(0)));
                           ir_if *f2C11 = new(mem_ctx) ir_if(operand(r2C12).val);
                           exec_list *const f2C11_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C11->then_instructions;

                              ir_variable *const r2C13 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2C13, r2BC0, 0x01));

                              ir_variable *const r2C14 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2C14, neg(r2BBD), 0x01));

                              ir_variable *const r2C15 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2C15);
                              ir_variable *const r2C16 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2C16);
                              ir_variable *const r2C17 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2C17);
                              ir_variable *const r2C18 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2C19 = neg(r2C14);
                              body.emit(assign(r2C18, bit_and(r2C19, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2C1B = equal(r2C14, body.constant(int(0)));
                              ir_if *f2C1A = new(mem_ctx) ir_if(operand(r2C1B).val);
                              exec_list *const f2C1A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C1A->then_instructions;

                                 body.emit(assign(r2C15, r2BC0, 0x01));

                                 body.emit(assign(r2C16, r2BBF, 0x01));

                                 body.emit(assign(r2C17, r2BBE, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2C1A->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2C1D = less(r2C14, body.constant(int(32)));
                                 ir_if *f2C1C = new(mem_ctx) ir_if(operand(r2C1D).val);
                                 exec_list *const f2C1C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C1C->then_instructions;

                                    body.emit(assign(r2C15, lshift(r2BBF, r2C18), 0x01));

                                    ir_expression *const r2C1E = lshift(r2BBE, r2C18);
                                    ir_expression *const r2C1F = rshift(r2BBF, r2C14);
                                    body.emit(assign(r2C16, bit_or(r2C1E, r2C1F), 0x01));

                                    body.emit(assign(r2C17, rshift(r2BBE, r2C14), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2C1C->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2C21 = equal(r2C14, body.constant(int(32)));
                                    ir_if *f2C20 = new(mem_ctx) ir_if(operand(r2C21).val);
                                    exec_list *const f2C20_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2C20->then_instructions;

                                       body.emit(assign(r2C15, r2BBF, 0x01));

                                       body.emit(assign(r2C16, r2BBE, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2C20->else_instructions;

                                       body.emit(assign(r2C13, bit_or(r2BC0, r2BBF), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2C23 = less(r2C14, body.constant(int(64)));
                                       ir_if *f2C22 = new(mem_ctx) ir_if(operand(r2C23).val);
                                       exec_list *const f2C22_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2C22->then_instructions;

                                          body.emit(assign(r2C15, lshift(r2BBE, r2C18), 0x01));

                                          ir_expression *const r2C24 = bit_and(r2C14, body.constant(int(31)));
                                          body.emit(assign(r2C16, rshift(r2BBE, r2C24), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2C22->else_instructions;

                                          ir_variable *const r2C25 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2C27 = equal(r2C14, body.constant(int(64)));
                                          ir_if *f2C26 = new(mem_ctx) ir_if(operand(r2C27).val);
                                          exec_list *const f2C26_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2C26->then_instructions;

                                             body.emit(assign(r2C25, r2BBE, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2C26->else_instructions;

                                             ir_expression *const r2C28 = nequal(r2BBE, body.constant(0u));
                                             ir_expression *const r2C29 = expr(ir_unop_b2i, r2C28);
                                             body.emit(assign(r2C25, expr(ir_unop_i2u, r2C29), 0x01));


                                          body.instructions = f2C26_parent_instructions;
                                          body.emit(f2C26);

                                          /* END IF */

                                          body.emit(assign(r2C15, r2C25, 0x01));

                                          body.emit(assign(r2C16, body.constant(0u), 0x01));


                                       body.instructions = f2C22_parent_instructions;
                                       body.emit(f2C22);

                                       /* END IF */


                                    body.instructions = f2C20_parent_instructions;
                                    body.emit(f2C20);

                                    /* END IF */

                                    body.emit(assign(r2C17, body.constant(0u), 0x01));


                                 body.instructions = f2C1C_parent_instructions;
                                 body.emit(f2C1C);

                                 /* END IF */

                                 ir_expression *const r2C2A = nequal(r2C13, body.constant(0u));
                                 ir_expression *const r2C2B = expr(ir_unop_b2i, r2C2A);
                                 ir_expression *const r2C2C = expr(ir_unop_i2u, r2C2B);
                                 body.emit(assign(r2C15, bit_or(r2C15, r2C2C), 0x01));


                              body.instructions = f2C1A_parent_instructions;
                              body.emit(f2C1A);

                              /* END IF */

                              body.emit(assign(r2BFD, r2C17, 0x01));

                              body.emit(assign(r2BFE, r2C16, 0x01));

                              body.emit(assign(r2BFF, r2C15, 0x01));

                              body.emit(assign(r2BFC, body.constant(int(0)), 0x01));

                              body.emit(assign(r2C02, less(r2C15, body.constant(0u)), 0x01));


                           body.instructions = f2C11_parent_instructions;
                           body.emit(f2C11);

                           /* END IF */


                        body.instructions = f2C0E_parent_instructions;
                        body.emit(f2C0E);

                        /* END IF */


                     body.instructions = f2C04_parent_instructions;
                     body.emit(f2C04);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2C2D = new(mem_ctx) ir_if(operand(r2C00).val);
                     exec_list *const f2C2D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2C2D->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2C2E = new(mem_ctx) ir_if(operand(r2C02).val);
                        exec_list *const f2C2E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2C2E->then_instructions;

                           ir_variable *const r2C2F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2C2F, add(r2BFE, body.constant(1u)), 0x01));

                           ir_expression *const r2C30 = less(r2C2F, r2BFE);
                           ir_expression *const r2C31 = expr(ir_unop_b2i, r2C30);
                           ir_expression *const r2C32 = expr(ir_unop_i2u, r2C31);
                           body.emit(assign(r2BFD, add(r2BFD, r2C32), 0x01));

                           ir_expression *const r2C33 = equal(r2BFF, body.constant(0u));
                           ir_expression *const r2C34 = expr(ir_unop_b2i, r2C33);
                           ir_expression *const r2C35 = expr(ir_unop_i2u, r2C34);
                           ir_expression *const r2C36 = add(r2BFF, r2C35);
                           ir_expression *const r2C37 = bit_and(r2C36, body.constant(1u));
                           ir_expression *const r2C38 = expr(ir_unop_bit_not, r2C37);
                           body.emit(assign(r2BFE, bit_and(r2C2F, r2C38), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2C2E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2C3A = bit_or(r2BFD, r2BFE);
                           ir_expression *const r2C3B = equal(r2C3A, body.constant(0u));
                           ir_if *f2C39 = new(mem_ctx) ir_if(operand(r2C3B).val);
                           exec_list *const f2C39_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C39->then_instructions;

                              body.emit(assign(r2BFC, body.constant(int(0)), 0x01));


                           body.instructions = f2C39_parent_instructions;
                           body.emit(f2C39);

                           /* END IF */


                        body.instructions = f2C2E_parent_instructions;
                        body.emit(f2C2E);

                        /* END IF */

                        ir_variable *const r2C3C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2C3C);
                        ir_expression *const r2C3D = lshift(r2944, body.constant(int(31)));
                        ir_expression *const r2C3E = expr(ir_unop_i2u, r2BFC);
                        ir_expression *const r2C3F = lshift(r2C3E, body.constant(int(20)));
                        ir_expression *const r2C40 = add(r2C3D, r2C3F);
                        body.emit(assign(r2C3C, add(r2C40, r2BFD), 0x02));

                        body.emit(assign(r2C3C, r2BFE, 0x01));

                        body.emit(assign(r2C01, r2C3C, 0x03));

                        body.emit(assign(r2C00, body.constant(false), 0x01));


                     body.instructions = f2C2D_parent_instructions;
                     body.emit(f2C2D);

                     /* END IF */

                     body.emit(assign(r2945, r2C01, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2BB5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2C42 = less(r294A, r294C);
                     ir_if *f2C41 = new(mem_ctx) ir_if(operand(r2C42).val);
                     exec_list *const f2C41_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2C41->then_instructions;

                        ir_variable *const r2C43 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r2C44 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2C44, sub(r294C, r294A), 0x01));

                        ir_expression *const r2C45 = sub(r294B, r2949);
                        ir_expression *const r2C46 = less(r294C, r294A);
                        ir_expression *const r2C47 = expr(ir_unop_b2i, r2C46);
                        ir_expression *const r2C48 = expr(ir_unop_i2u, r2C47);
                        body.emit(assign(r2C43, sub(r2C45, r2C48), 0x01));

                        body.emit(assign(r294D, add(r2948, body.constant(int(-1))), 0x01));

                        ir_variable *const r2C49 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2C49, add(r294D, body.constant(int(-10))), 0x01));

                        ir_variable *const r2C4A = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2C4A, r2C43, 0x01));

                        ir_variable *const r2C4B = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2C4B, r2C44, 0x01));

                        ir_variable *const r2C4C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r2C4C);
                        ir_variable *const r2C4D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2C4D);
                        /* IF CONDITION */
                        ir_expression *const r2C4F = equal(r2C43, body.constant(0u));
                        ir_if *f2C4E = new(mem_ctx) ir_if(operand(r2C4F).val);
                        exec_list *const f2C4E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2C4E->then_instructions;

                           body.emit(assign(r2C4A, r2C44, 0x01));

                           body.emit(assign(r2C4B, body.constant(0u), 0x01));

                           body.emit(assign(r2C49, add(r2C49, body.constant(int(-32))), 0x01));


                        body.instructions = f2C4E_parent_instructions;
                        body.emit(f2C4E);

                        /* END IF */

                        ir_variable *const r2C50 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r2C50, r2C4A, 0x01));

                        ir_variable *const r2C51 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r2C52 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2C52);
                        /* IF CONDITION */
                        ir_expression *const r2C54 = equal(r2C4A, body.constant(0u));
                        ir_if *f2C53 = new(mem_ctx) ir_if(operand(r2C54).val);
                        exec_list *const f2C53_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2C53->then_instructions;

                           body.emit(assign(r2C51, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2C53->else_instructions;

                           body.emit(assign(r2C52, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2C56 = bit_and(r2C4A, body.constant(4294901760u));
                           ir_expression *const r2C57 = equal(r2C56, body.constant(0u));
                           ir_if *f2C55 = new(mem_ctx) ir_if(operand(r2C57).val);
                           exec_list *const f2C55_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C55->then_instructions;

                              body.emit(assign(r2C52, body.constant(int(16)), 0x01));

                              body.emit(assign(r2C50, lshift(r2C4A, body.constant(int(16))), 0x01));


                           body.instructions = f2C55_parent_instructions;
                           body.emit(f2C55);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2C59 = bit_and(r2C50, body.constant(4278190080u));
                           ir_expression *const r2C5A = equal(r2C59, body.constant(0u));
                           ir_if *f2C58 = new(mem_ctx) ir_if(operand(r2C5A).val);
                           exec_list *const f2C58_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C58->then_instructions;

                              body.emit(assign(r2C52, add(r2C52, body.constant(int(8))), 0x01));

                              body.emit(assign(r2C50, lshift(r2C50, body.constant(int(8))), 0x01));


                           body.instructions = f2C58_parent_instructions;
                           body.emit(f2C58);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2C5C = bit_and(r2C50, body.constant(4026531840u));
                           ir_expression *const r2C5D = equal(r2C5C, body.constant(0u));
                           ir_if *f2C5B = new(mem_ctx) ir_if(operand(r2C5D).val);
                           exec_list *const f2C5B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C5B->then_instructions;

                              body.emit(assign(r2C52, add(r2C52, body.constant(int(4))), 0x01));

                              body.emit(assign(r2C50, lshift(r2C50, body.constant(int(4))), 0x01));


                           body.instructions = f2C5B_parent_instructions;
                           body.emit(f2C5B);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2C5F = bit_and(r2C50, body.constant(3221225472u));
                           ir_expression *const r2C60 = equal(r2C5F, body.constant(0u));
                           ir_if *f2C5E = new(mem_ctx) ir_if(operand(r2C60).val);
                           exec_list *const f2C5E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C5E->then_instructions;

                              body.emit(assign(r2C52, add(r2C52, body.constant(int(2))), 0x01));

                              body.emit(assign(r2C50, lshift(r2C50, body.constant(int(2))), 0x01));


                           body.instructions = f2C5E_parent_instructions;
                           body.emit(f2C5E);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2C62 = bit_and(r2C50, body.constant(2147483648u));
                           ir_expression *const r2C63 = equal(r2C62, body.constant(0u));
                           ir_if *f2C61 = new(mem_ctx) ir_if(operand(r2C63).val);
                           exec_list *const f2C61_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C61->then_instructions;

                              body.emit(assign(r2C52, add(r2C52, body.constant(int(1))), 0x01));


                           body.instructions = f2C61_parent_instructions;
                           body.emit(f2C61);

                           /* END IF */

                           body.emit(assign(r2C51, r2C52, 0x01));


                        body.instructions = f2C53_parent_instructions;
                        body.emit(f2C53);

                        /* END IF */

                        body.emit(assign(r2C4D, add(r2C51, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2C65 = lequal(body.constant(int(0)), r2C4D);
                        ir_if *f2C64 = new(mem_ctx) ir_if(operand(r2C65).val);
                        exec_list *const f2C64_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2C64->then_instructions;

                           body.emit(assign(r2C4C, body.constant(0u), 0x01));

                           ir_variable *const r2C66 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2C66, lshift(r2C4B, r2C4D), 0x01));

                           ir_variable *const r2C67 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2C69 = equal(r2C4D, body.constant(int(0)));
                           ir_if *f2C68 = new(mem_ctx) ir_if(operand(r2C69).val);
                           exec_list *const f2C68_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C68->then_instructions;

                              body.emit(assign(r2C67, r2C4A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2C68->else_instructions;

                              ir_expression *const r2C6A = lshift(r2C4A, r2C4D);
                              ir_expression *const r2C6B = neg(r2C4D);
                              ir_expression *const r2C6C = bit_and(r2C6B, body.constant(int(31)));
                              ir_expression *const r2C6D = rshift(r2C4B, r2C6C);
                              body.emit(assign(r2C67, bit_or(r2C6A, r2C6D), 0x01));


                           body.instructions = f2C68_parent_instructions;
                           body.emit(f2C68);

                           /* END IF */

                           body.emit(assign(r2C4A, r2C67, 0x01));

                           body.emit(assign(r2C4B, r2C66, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2C64->else_instructions;

                           ir_variable *const r2C6E = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r2C6E, body.constant(0u), 0x01));

                           ir_variable *const r2C6F = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2C6F, neg(r2C4D), 0x01));

                           ir_variable *const r2C70 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r2C70);
                           ir_variable *const r2C71 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r2C71);
                           ir_variable *const r2C72 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r2C72);
                           ir_variable *const r2C73 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r2C74 = neg(r2C6F);
                           body.emit(assign(r2C73, bit_and(r2C74, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2C76 = equal(r2C6F, body.constant(int(0)));
                           ir_if *f2C75 = new(mem_ctx) ir_if(operand(r2C76).val);
                           exec_list *const f2C75_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C75->then_instructions;

                              body.emit(assign(r2C70, r2C6E, 0x01));

                              body.emit(assign(r2C71, r2C4B, 0x01));

                              body.emit(assign(r2C72, r2C4A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2C75->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2C78 = less(r2C6F, body.constant(int(32)));
                              ir_if *f2C77 = new(mem_ctx) ir_if(operand(r2C78).val);
                              exec_list *const f2C77_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C77->then_instructions;

                                 body.emit(assign(r2C70, lshift(r2C4B, r2C73), 0x01));

                                 ir_expression *const r2C79 = lshift(r2C4A, r2C73);
                                 ir_expression *const r2C7A = rshift(r2C4B, r2C6F);
                                 body.emit(assign(r2C71, bit_or(r2C79, r2C7A), 0x01));

                                 body.emit(assign(r2C72, rshift(r2C4A, r2C6F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2C77->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2C7C = equal(r2C6F, body.constant(int(32)));
                                 ir_if *f2C7B = new(mem_ctx) ir_if(operand(r2C7C).val);
                                 exec_list *const f2C7B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C7B->then_instructions;

                                    body.emit(assign(r2C70, r2C4B, 0x01));

                                    body.emit(assign(r2C71, r2C4A, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2C7B->else_instructions;

                                    body.emit(assign(r2C6E, bit_or(body.constant(0u), r2C4B), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2C7E = less(r2C6F, body.constant(int(64)));
                                    ir_if *f2C7D = new(mem_ctx) ir_if(operand(r2C7E).val);
                                    exec_list *const f2C7D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2C7D->then_instructions;

                                       body.emit(assign(r2C70, lshift(r2C4A, r2C73), 0x01));

                                       ir_expression *const r2C7F = bit_and(r2C6F, body.constant(int(31)));
                                       body.emit(assign(r2C71, rshift(r2C4A, r2C7F), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2C7D->else_instructions;

                                       ir_variable *const r2C80 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r2C82 = equal(r2C6F, body.constant(int(64)));
                                       ir_if *f2C81 = new(mem_ctx) ir_if(operand(r2C82).val);
                                       exec_list *const f2C81_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2C81->then_instructions;

                                          body.emit(assign(r2C80, r2C4A, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2C81->else_instructions;

                                          ir_expression *const r2C83 = nequal(r2C4A, body.constant(0u));
                                          ir_expression *const r2C84 = expr(ir_unop_b2i, r2C83);
                                          body.emit(assign(r2C80, expr(ir_unop_i2u, r2C84), 0x01));


                                       body.instructions = f2C81_parent_instructions;
                                       body.emit(f2C81);

                                       /* END IF */

                                       body.emit(assign(r2C70, r2C80, 0x01));

                                       body.emit(assign(r2C71, body.constant(0u), 0x01));


                                    body.instructions = f2C7D_parent_instructions;
                                    body.emit(f2C7D);

                                    /* END IF */


                                 body.instructions = f2C7B_parent_instructions;
                                 body.emit(f2C7B);

                                 /* END IF */

                                 body.emit(assign(r2C72, body.constant(0u), 0x01));


                              body.instructions = f2C77_parent_instructions;
                              body.emit(f2C77);

                              /* END IF */

                              ir_expression *const r2C85 = nequal(r2C6E, body.constant(0u));
                              ir_expression *const r2C86 = expr(ir_unop_b2i, r2C85);
                              ir_expression *const r2C87 = expr(ir_unop_i2u, r2C86);
                              body.emit(assign(r2C70, bit_or(r2C70, r2C87), 0x01));


                           body.instructions = f2C75_parent_instructions;
                           body.emit(f2C75);

                           /* END IF */

                           body.emit(assign(r2C4A, r2C72, 0x01));

                           body.emit(assign(r2C4B, r2C71, 0x01));

                           body.emit(assign(r2C4C, r2C70, 0x01));


                        body.instructions = f2C64_parent_instructions;
                        body.emit(f2C64);

                        /* END IF */

                        body.emit(assign(r2C49, sub(r2C49, r2C4D), 0x01));

                        ir_variable *const r2C88 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2C88, r2C49, 0x01));

                        ir_variable *const r2C89 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2C89, r2C4A, 0x01));

                        ir_variable *const r2C8A = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2C8A, r2C4B, 0x01));

                        ir_variable *const r2C8B = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r2C8B, r2C4C, 0x01));

                        ir_variable *const r2C8C = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r2C8C, body.constant(true), 0x01));

                        ir_variable *const r2C8D = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r2C8E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r2C8E);
                        ir_expression *const r2C8F = expr(ir_unop_u2i, r2C4C);
                        body.emit(assign(r2C8E, less(r2C8F, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2C91 = lequal(body.constant(int(2045)), r2C49);
                        ir_if *f2C90 = new(mem_ctx) ir_if(operand(r2C91).val);
                        exec_list *const f2C90_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2C90->then_instructions;

                           ir_variable *const r2C92 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2C94 = less(body.constant(int(2045)), r2C49);
                           ir_if *f2C93 = new(mem_ctx) ir_if(operand(r2C94).val);
                           exec_list *const f2C93_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C93->then_instructions;

                              body.emit(assign(r2C92, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2C93->else_instructions;

                              ir_variable *const r2C95 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2C97 = equal(r2C49, body.constant(int(2045)));
                              ir_if *f2C96 = new(mem_ctx) ir_if(operand(r2C97).val);
                              exec_list *const f2C96_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C96->then_instructions;

                                 ir_expression *const r2C98 = equal(body.constant(2097151u), r2C4A);
                                 ir_expression *const r2C99 = equal(body.constant(4294967295u), r2C4B);
                                 body.emit(assign(r2C95, logic_and(r2C98, r2C99), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2C96->else_instructions;

                                 body.emit(assign(r2C95, body.constant(false), 0x01));


                              body.instructions = f2C96_parent_instructions;
                              body.emit(f2C96);

                              /* END IF */

                              body.emit(assign(r2C92, logic_and(r2C95, r2C8E), 0x01));


                           body.instructions = f2C93_parent_instructions;
                           body.emit(f2C93);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2C9A = new(mem_ctx) ir_if(operand(r2C92).val);
                           exec_list *const f2C9A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C9A->then_instructions;

                              ir_variable *const r2C9B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2C9B);
                              ir_expression *const r2C9C = lshift(r2944, body.constant(int(31)));
                              body.emit(assign(r2C9B, add(r2C9C, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r2C9B, body.constant(0u), 0x01));

                              body.emit(assign(r2C8D, r2C9B, 0x03));

                              body.emit(assign(r2C8C, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2C9A->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2C9E = less(r2C49, body.constant(int(0)));
                              ir_if *f2C9D = new(mem_ctx) ir_if(operand(r2C9E).val);
                              exec_list *const f2C9D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C9D->then_instructions;

                                 ir_variable *const r2C9F = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2C9F, r2C4C, 0x01));

                                 ir_variable *const r2CA0 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2CA0, neg(r2C49), 0x01));

                                 ir_variable *const r2CA1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2CA1);
                                 ir_variable *const r2CA2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2CA2);
                                 ir_variable *const r2CA3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2CA3);
                                 ir_variable *const r2CA4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2CA5 = neg(r2CA0);
                                 body.emit(assign(r2CA4, bit_and(r2CA5, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2CA7 = equal(r2CA0, body.constant(int(0)));
                                 ir_if *f2CA6 = new(mem_ctx) ir_if(operand(r2CA7).val);
                                 exec_list *const f2CA6_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2CA6->then_instructions;

                                    body.emit(assign(r2CA1, r2C4C, 0x01));

                                    body.emit(assign(r2CA2, r2C4B, 0x01));

                                    body.emit(assign(r2CA3, r2C4A, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2CA6->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2CA9 = less(r2CA0, body.constant(int(32)));
                                    ir_if *f2CA8 = new(mem_ctx) ir_if(operand(r2CA9).val);
                                    exec_list *const f2CA8_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2CA8->then_instructions;

                                       body.emit(assign(r2CA1, lshift(r2C4B, r2CA4), 0x01));

                                       ir_expression *const r2CAA = lshift(r2C4A, r2CA4);
                                       ir_expression *const r2CAB = rshift(r2C4B, r2CA0);
                                       body.emit(assign(r2CA2, bit_or(r2CAA, r2CAB), 0x01));

                                       body.emit(assign(r2CA3, rshift(r2C4A, r2CA0), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2CA8->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2CAD = equal(r2CA0, body.constant(int(32)));
                                       ir_if *f2CAC = new(mem_ctx) ir_if(operand(r2CAD).val);
                                       exec_list *const f2CAC_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2CAC->then_instructions;

                                          body.emit(assign(r2CA1, r2C4B, 0x01));

                                          body.emit(assign(r2CA2, r2C4A, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2CAC->else_instructions;

                                          body.emit(assign(r2C9F, bit_or(r2C4C, r2C4B), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2CAF = less(r2CA0, body.constant(int(64)));
                                          ir_if *f2CAE = new(mem_ctx) ir_if(operand(r2CAF).val);
                                          exec_list *const f2CAE_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2CAE->then_instructions;

                                             body.emit(assign(r2CA1, lshift(r2C4A, r2CA4), 0x01));

                                             ir_expression *const r2CB0 = bit_and(r2CA0, body.constant(int(31)));
                                             body.emit(assign(r2CA2, rshift(r2C4A, r2CB0), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2CAE->else_instructions;

                                             ir_variable *const r2CB1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2CB3 = equal(r2CA0, body.constant(int(64)));
                                             ir_if *f2CB2 = new(mem_ctx) ir_if(operand(r2CB3).val);
                                             exec_list *const f2CB2_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2CB2->then_instructions;

                                                body.emit(assign(r2CB1, r2C4A, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2CB2->else_instructions;

                                                ir_expression *const r2CB4 = nequal(r2C4A, body.constant(0u));
                                                ir_expression *const r2CB5 = expr(ir_unop_b2i, r2CB4);
                                                body.emit(assign(r2CB1, expr(ir_unop_i2u, r2CB5), 0x01));


                                             body.instructions = f2CB2_parent_instructions;
                                             body.emit(f2CB2);

                                             /* END IF */

                                             body.emit(assign(r2CA1, r2CB1, 0x01));

                                             body.emit(assign(r2CA2, body.constant(0u), 0x01));


                                          body.instructions = f2CAE_parent_instructions;
                                          body.emit(f2CAE);

                                          /* END IF */


                                       body.instructions = f2CAC_parent_instructions;
                                       body.emit(f2CAC);

                                       /* END IF */

                                       body.emit(assign(r2CA3, body.constant(0u), 0x01));


                                    body.instructions = f2CA8_parent_instructions;
                                    body.emit(f2CA8);

                                    /* END IF */

                                    ir_expression *const r2CB6 = nequal(r2C9F, body.constant(0u));
                                    ir_expression *const r2CB7 = expr(ir_unop_b2i, r2CB6);
                                    ir_expression *const r2CB8 = expr(ir_unop_i2u, r2CB7);
                                    body.emit(assign(r2CA1, bit_or(r2CA1, r2CB8), 0x01));


                                 body.instructions = f2CA6_parent_instructions;
                                 body.emit(f2CA6);

                                 /* END IF */

                                 body.emit(assign(r2C89, r2CA3, 0x01));

                                 body.emit(assign(r2C8A, r2CA2, 0x01));

                                 body.emit(assign(r2C8B, r2CA1, 0x01));

                                 body.emit(assign(r2C88, body.constant(int(0)), 0x01));

                                 body.emit(assign(r2C8E, less(r2CA1, body.constant(0u)), 0x01));


                              body.instructions = f2C9D_parent_instructions;
                              body.emit(f2C9D);

                              /* END IF */


                           body.instructions = f2C9A_parent_instructions;
                           body.emit(f2C9A);

                           /* END IF */


                        body.instructions = f2C90_parent_instructions;
                        body.emit(f2C90);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2CB9 = new(mem_ctx) ir_if(operand(r2C8C).val);
                        exec_list *const f2CB9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2CB9->then_instructions;

                           /* IF CONDITION */
                           ir_if *f2CBA = new(mem_ctx) ir_if(operand(r2C8E).val);
                           exec_list *const f2CBA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2CBA->then_instructions;

                              ir_variable *const r2CBB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r2CBB, add(r2C8A, body.constant(1u)), 0x01));

                              ir_expression *const r2CBC = less(r2CBB, r2C8A);
                              ir_expression *const r2CBD = expr(ir_unop_b2i, r2CBC);
                              ir_expression *const r2CBE = expr(ir_unop_i2u, r2CBD);
                              body.emit(assign(r2C89, add(r2C89, r2CBE), 0x01));

                              ir_expression *const r2CBF = equal(r2C8B, body.constant(0u));
                              ir_expression *const r2CC0 = expr(ir_unop_b2i, r2CBF);
                              ir_expression *const r2CC1 = expr(ir_unop_i2u, r2CC0);
                              ir_expression *const r2CC2 = add(r2C8B, r2CC1);
                              ir_expression *const r2CC3 = bit_and(r2CC2, body.constant(1u));
                              ir_expression *const r2CC4 = expr(ir_unop_bit_not, r2CC3);
                              body.emit(assign(r2C8A, bit_and(r2CBB, r2CC4), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2CBA->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2CC6 = bit_or(r2C89, r2C8A);
                              ir_expression *const r2CC7 = equal(r2CC6, body.constant(0u));
                              ir_if *f2CC5 = new(mem_ctx) ir_if(operand(r2CC7).val);
                              exec_list *const f2CC5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2CC5->then_instructions;

                                 body.emit(assign(r2C88, body.constant(int(0)), 0x01));


                              body.instructions = f2CC5_parent_instructions;
                              body.emit(f2CC5);

                              /* END IF */


                           body.instructions = f2CBA_parent_instructions;
                           body.emit(f2CBA);

                           /* END IF */

                           ir_variable *const r2CC8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2CC8);
                           ir_expression *const r2CC9 = lshift(r2944, body.constant(int(31)));
                           ir_expression *const r2CCA = expr(ir_unop_i2u, r2C88);
                           ir_expression *const r2CCB = lshift(r2CCA, body.constant(int(20)));
                           ir_expression *const r2CCC = add(r2CC9, r2CCB);
                           body.emit(assign(r2CC8, add(r2CCC, r2C89), 0x02));

                           body.emit(assign(r2CC8, r2C8A, 0x01));

                           body.emit(assign(r2C8D, r2CC8, 0x03));

                           body.emit(assign(r2C8C, body.constant(false), 0x01));


                        body.instructions = f2CB9_parent_instructions;
                        body.emit(f2CB9);

                        /* END IF */

                        body.emit(assign(r2945, r2C8D, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2C41->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2CCE = less(r294C, r294A);
                        ir_if *f2CCD = new(mem_ctx) ir_if(operand(r2CCE).val);
                        exec_list *const f2CCD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2CCD->then_instructions;

                           ir_variable *const r2CCF = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r2CD0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2CD0, sub(r294A, r294C), 0x01));

                           ir_expression *const r2CD1 = sub(r2949, r294B);
                           ir_expression *const r2CD2 = less(r294A, r294C);
                           ir_expression *const r2CD3 = expr(ir_unop_b2i, r2CD2);
                           ir_expression *const r2CD4 = expr(ir_unop_i2u, r2CD3);
                           body.emit(assign(r2CCF, sub(r2CD1, r2CD4), 0x01));

                           body.emit(assign(r2944, bit_xor(r2944, body.constant(1u)), 0x01));

                           body.emit(assign(r294D, add(r2947, body.constant(int(-1))), 0x01));

                           ir_variable *const r2CD5 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2CD5, add(r294D, body.constant(int(-10))), 0x01));

                           ir_variable *const r2CD6 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2CD6, r2CCF, 0x01));

                           ir_variable *const r2CD7 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2CD7, r2CD0, 0x01));

                           ir_variable *const r2CD8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r2CD8);
                           ir_variable *const r2CD9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2CD9);
                           /* IF CONDITION */
                           ir_expression *const r2CDB = equal(r2CCF, body.constant(0u));
                           ir_if *f2CDA = new(mem_ctx) ir_if(operand(r2CDB).val);
                           exec_list *const f2CDA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2CDA->then_instructions;

                              body.emit(assign(r2CD6, r2CD0, 0x01));

                              body.emit(assign(r2CD7, body.constant(0u), 0x01));

                              body.emit(assign(r2CD5, add(r2CD5, body.constant(int(-32))), 0x01));


                           body.instructions = f2CDA_parent_instructions;
                           body.emit(f2CDA);

                           /* END IF */

                           ir_variable *const r2CDC = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r2CDC, r2CD6, 0x01));

                           ir_variable *const r2CDD = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r2CDE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2CDE);
                           /* IF CONDITION */
                           ir_expression *const r2CE0 = equal(r2CD6, body.constant(0u));
                           ir_if *f2CDF = new(mem_ctx) ir_if(operand(r2CE0).val);
                           exec_list *const f2CDF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2CDF->then_instructions;

                              body.emit(assign(r2CDD, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2CDF->else_instructions;

                              body.emit(assign(r2CDE, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2CE2 = bit_and(r2CD6, body.constant(4294901760u));
                              ir_expression *const r2CE3 = equal(r2CE2, body.constant(0u));
                              ir_if *f2CE1 = new(mem_ctx) ir_if(operand(r2CE3).val);
                              exec_list *const f2CE1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2CE1->then_instructions;

                                 body.emit(assign(r2CDE, body.constant(int(16)), 0x01));

                                 body.emit(assign(r2CDC, lshift(r2CD6, body.constant(int(16))), 0x01));


                              body.instructions = f2CE1_parent_instructions;
                              body.emit(f2CE1);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2CE5 = bit_and(r2CDC, body.constant(4278190080u));
                              ir_expression *const r2CE6 = equal(r2CE5, body.constant(0u));
                              ir_if *f2CE4 = new(mem_ctx) ir_if(operand(r2CE6).val);
                              exec_list *const f2CE4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2CE4->then_instructions;

                                 body.emit(assign(r2CDE, add(r2CDE, body.constant(int(8))), 0x01));

                                 body.emit(assign(r2CDC, lshift(r2CDC, body.constant(int(8))), 0x01));


                              body.instructions = f2CE4_parent_instructions;
                              body.emit(f2CE4);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2CE8 = bit_and(r2CDC, body.constant(4026531840u));
                              ir_expression *const r2CE9 = equal(r2CE8, body.constant(0u));
                              ir_if *f2CE7 = new(mem_ctx) ir_if(operand(r2CE9).val);
                              exec_list *const f2CE7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2CE7->then_instructions;

                                 body.emit(assign(r2CDE, add(r2CDE, body.constant(int(4))), 0x01));

                                 body.emit(assign(r2CDC, lshift(r2CDC, body.constant(int(4))), 0x01));


                              body.instructions = f2CE7_parent_instructions;
                              body.emit(f2CE7);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2CEB = bit_and(r2CDC, body.constant(3221225472u));
                              ir_expression *const r2CEC = equal(r2CEB, body.constant(0u));
                              ir_if *f2CEA = new(mem_ctx) ir_if(operand(r2CEC).val);
                              exec_list *const f2CEA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2CEA->then_instructions;

                                 body.emit(assign(r2CDE, add(r2CDE, body.constant(int(2))), 0x01));

                                 body.emit(assign(r2CDC, lshift(r2CDC, body.constant(int(2))), 0x01));


                              body.instructions = f2CEA_parent_instructions;
                              body.emit(f2CEA);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2CEE = bit_and(r2CDC, body.constant(2147483648u));
                              ir_expression *const r2CEF = equal(r2CEE, body.constant(0u));
                              ir_if *f2CED = new(mem_ctx) ir_if(operand(r2CEF).val);
                              exec_list *const f2CED_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2CED->then_instructions;

                                 body.emit(assign(r2CDE, add(r2CDE, body.constant(int(1))), 0x01));


                              body.instructions = f2CED_parent_instructions;
                              body.emit(f2CED);

                              /* END IF */

                              body.emit(assign(r2CDD, r2CDE, 0x01));


                           body.instructions = f2CDF_parent_instructions;
                           body.emit(f2CDF);

                           /* END IF */

                           body.emit(assign(r2CD9, add(r2CDD, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2CF1 = lequal(body.constant(int(0)), r2CD9);
                           ir_if *f2CF0 = new(mem_ctx) ir_if(operand(r2CF1).val);
                           exec_list *const f2CF0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2CF0->then_instructions;

                              body.emit(assign(r2CD8, body.constant(0u), 0x01));

                              ir_variable *const r2CF2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2CF2, lshift(r2CD7, r2CD9), 0x01));

                              ir_variable *const r2CF3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2CF5 = equal(r2CD9, body.constant(int(0)));
                              ir_if *f2CF4 = new(mem_ctx) ir_if(operand(r2CF5).val);
                              exec_list *const f2CF4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2CF4->then_instructions;

                                 body.emit(assign(r2CF3, r2CD6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2CF4->else_instructions;

                                 ir_expression *const r2CF6 = lshift(r2CD6, r2CD9);
                                 ir_expression *const r2CF7 = neg(r2CD9);
                                 ir_expression *const r2CF8 = bit_and(r2CF7, body.constant(int(31)));
                                 ir_expression *const r2CF9 = rshift(r2CD7, r2CF8);
                                 body.emit(assign(r2CF3, bit_or(r2CF6, r2CF9), 0x01));


                              body.instructions = f2CF4_parent_instructions;
                              body.emit(f2CF4);

                              /* END IF */

                              body.emit(assign(r2CD6, r2CF3, 0x01));

                              body.emit(assign(r2CD7, r2CF2, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2CF0->else_instructions;

                              ir_variable *const r2CFA = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2CFA, body.constant(0u), 0x01));

                              ir_variable *const r2CFB = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2CFB, neg(r2CD9), 0x01));

                              ir_variable *const r2CFC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2CFC);
                              ir_variable *const r2CFD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2CFD);
                              ir_variable *const r2CFE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2CFE);
                              ir_variable *const r2CFF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2D00 = neg(r2CFB);
                              body.emit(assign(r2CFF, bit_and(r2D00, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2D02 = equal(r2CFB, body.constant(int(0)));
                              ir_if *f2D01 = new(mem_ctx) ir_if(operand(r2D02).val);
                              exec_list *const f2D01_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2D01->then_instructions;

                                 body.emit(assign(r2CFC, r2CFA, 0x01));

                                 body.emit(assign(r2CFD, r2CD7, 0x01));

                                 body.emit(assign(r2CFE, r2CD6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2D01->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2D04 = less(r2CFB, body.constant(int(32)));
                                 ir_if *f2D03 = new(mem_ctx) ir_if(operand(r2D04).val);
                                 exec_list *const f2D03_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2D03->then_instructions;

                                    body.emit(assign(r2CFC, lshift(r2CD7, r2CFF), 0x01));

                                    ir_expression *const r2D05 = lshift(r2CD6, r2CFF);
                                    ir_expression *const r2D06 = rshift(r2CD7, r2CFB);
                                    body.emit(assign(r2CFD, bit_or(r2D05, r2D06), 0x01));

                                    body.emit(assign(r2CFE, rshift(r2CD6, r2CFB), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2D03->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2D08 = equal(r2CFB, body.constant(int(32)));
                                    ir_if *f2D07 = new(mem_ctx) ir_if(operand(r2D08).val);
                                    exec_list *const f2D07_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2D07->then_instructions;

                                       body.emit(assign(r2CFC, r2CD7, 0x01));

                                       body.emit(assign(r2CFD, r2CD6, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2D07->else_instructions;

                                       body.emit(assign(r2CFA, bit_or(body.constant(0u), r2CD7), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2D0A = less(r2CFB, body.constant(int(64)));
                                       ir_if *f2D09 = new(mem_ctx) ir_if(operand(r2D0A).val);
                                       exec_list *const f2D09_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2D09->then_instructions;

                                          body.emit(assign(r2CFC, lshift(r2CD6, r2CFF), 0x01));

                                          ir_expression *const r2D0B = bit_and(r2CFB, body.constant(int(31)));
                                          body.emit(assign(r2CFD, rshift(r2CD6, r2D0B), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2D09->else_instructions;

                                          ir_variable *const r2D0C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2D0E = equal(r2CFB, body.constant(int(64)));
                                          ir_if *f2D0D = new(mem_ctx) ir_if(operand(r2D0E).val);
                                          exec_list *const f2D0D_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2D0D->then_instructions;

                                             body.emit(assign(r2D0C, r2CD6, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2D0D->else_instructions;

                                             ir_expression *const r2D0F = nequal(r2CD6, body.constant(0u));
                                             ir_expression *const r2D10 = expr(ir_unop_b2i, r2D0F);
                                             body.emit(assign(r2D0C, expr(ir_unop_i2u, r2D10), 0x01));


                                          body.instructions = f2D0D_parent_instructions;
                                          body.emit(f2D0D);

                                          /* END IF */

                                          body.emit(assign(r2CFC, r2D0C, 0x01));

                                          body.emit(assign(r2CFD, body.constant(0u), 0x01));


                                       body.instructions = f2D09_parent_instructions;
                                       body.emit(f2D09);

                                       /* END IF */


                                    body.instructions = f2D07_parent_instructions;
                                    body.emit(f2D07);

                                    /* END IF */

                                    body.emit(assign(r2CFE, body.constant(0u), 0x01));


                                 body.instructions = f2D03_parent_instructions;
                                 body.emit(f2D03);

                                 /* END IF */

                                 ir_expression *const r2D11 = nequal(r2CFA, body.constant(0u));
                                 ir_expression *const r2D12 = expr(ir_unop_b2i, r2D11);
                                 ir_expression *const r2D13 = expr(ir_unop_i2u, r2D12);
                                 body.emit(assign(r2CFC, bit_or(r2CFC, r2D13), 0x01));


                              body.instructions = f2D01_parent_instructions;
                              body.emit(f2D01);

                              /* END IF */

                              body.emit(assign(r2CD6, r2CFE, 0x01));

                              body.emit(assign(r2CD7, r2CFD, 0x01));

                              body.emit(assign(r2CD8, r2CFC, 0x01));


                           body.instructions = f2CF0_parent_instructions;
                           body.emit(f2CF0);

                           /* END IF */

                           body.emit(assign(r2CD5, sub(r2CD5, r2CD9), 0x01));

                           ir_variable *const r2D14 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2D14, r2CD5, 0x01));

                           ir_variable *const r2D15 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2D15, r2CD6, 0x01));

                           ir_variable *const r2D16 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2D16, r2CD7, 0x01));

                           ir_variable *const r2D17 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r2D17, r2CD8, 0x01));

                           ir_variable *const r2D18 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r2D18, body.constant(true), 0x01));

                           ir_variable *const r2D19 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r2D1A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r2D1A);
                           ir_expression *const r2D1B = expr(ir_unop_u2i, r2CD8);
                           body.emit(assign(r2D1A, less(r2D1B, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2D1D = lequal(body.constant(int(2045)), r2CD5);
                           ir_if *f2D1C = new(mem_ctx) ir_if(operand(r2D1D).val);
                           exec_list *const f2D1C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2D1C->then_instructions;

                              ir_variable *const r2D1E = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2D20 = less(body.constant(int(2045)), r2CD5);
                              ir_if *f2D1F = new(mem_ctx) ir_if(operand(r2D20).val);
                              exec_list *const f2D1F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2D1F->then_instructions;

                                 body.emit(assign(r2D1E, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2D1F->else_instructions;

                                 ir_variable *const r2D21 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2D23 = equal(r2CD5, body.constant(int(2045)));
                                 ir_if *f2D22 = new(mem_ctx) ir_if(operand(r2D23).val);
                                 exec_list *const f2D22_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2D22->then_instructions;

                                    ir_expression *const r2D24 = equal(body.constant(2097151u), r2CD6);
                                    ir_expression *const r2D25 = equal(body.constant(4294967295u), r2CD7);
                                    body.emit(assign(r2D21, logic_and(r2D24, r2D25), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2D22->else_instructions;

                                    body.emit(assign(r2D21, body.constant(false), 0x01));


                                 body.instructions = f2D22_parent_instructions;
                                 body.emit(f2D22);

                                 /* END IF */

                                 body.emit(assign(r2D1E, logic_and(r2D21, r2D1A), 0x01));


                              body.instructions = f2D1F_parent_instructions;
                              body.emit(f2D1F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2D26 = new(mem_ctx) ir_if(operand(r2D1E).val);
                              exec_list *const f2D26_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2D26->then_instructions;

                                 ir_variable *const r2D27 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2D27);
                                 ir_expression *const r2D28 = lshift(r2944, body.constant(int(31)));
                                 body.emit(assign(r2D27, add(r2D28, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r2D27, body.constant(0u), 0x01));

                                 body.emit(assign(r2D19, r2D27, 0x03));

                                 body.emit(assign(r2D18, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2D26->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2D2A = less(r2CD5, body.constant(int(0)));
                                 ir_if *f2D29 = new(mem_ctx) ir_if(operand(r2D2A).val);
                                 exec_list *const f2D29_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2D29->then_instructions;

                                    ir_variable *const r2D2B = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r2D2B, r2CD8, 0x01));

                                    ir_variable *const r2D2C = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r2D2C, neg(r2CD5), 0x01));

                                    ir_variable *const r2D2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r2D2D);
                                    ir_variable *const r2D2E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r2D2E);
                                    ir_variable *const r2D2F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r2D2F);
                                    ir_variable *const r2D30 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r2D31 = neg(r2D2C);
                                    body.emit(assign(r2D30, bit_and(r2D31, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2D33 = equal(r2D2C, body.constant(int(0)));
                                    ir_if *f2D32 = new(mem_ctx) ir_if(operand(r2D33).val);
                                    exec_list *const f2D32_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2D32->then_instructions;

                                       body.emit(assign(r2D2D, r2CD8, 0x01));

                                       body.emit(assign(r2D2E, r2CD7, 0x01));

                                       body.emit(assign(r2D2F, r2CD6, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2D32->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2D35 = less(r2D2C, body.constant(int(32)));
                                       ir_if *f2D34 = new(mem_ctx) ir_if(operand(r2D35).val);
                                       exec_list *const f2D34_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2D34->then_instructions;

                                          body.emit(assign(r2D2D, lshift(r2CD7, r2D30), 0x01));

                                          ir_expression *const r2D36 = lshift(r2CD6, r2D30);
                                          ir_expression *const r2D37 = rshift(r2CD7, r2D2C);
                                          body.emit(assign(r2D2E, bit_or(r2D36, r2D37), 0x01));

                                          body.emit(assign(r2D2F, rshift(r2CD6, r2D2C), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2D34->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2D39 = equal(r2D2C, body.constant(int(32)));
                                          ir_if *f2D38 = new(mem_ctx) ir_if(operand(r2D39).val);
                                          exec_list *const f2D38_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2D38->then_instructions;

                                             body.emit(assign(r2D2D, r2CD7, 0x01));

                                             body.emit(assign(r2D2E, r2CD6, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2D38->else_instructions;

                                             body.emit(assign(r2D2B, bit_or(r2CD8, r2CD7), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r2D3B = less(r2D2C, body.constant(int(64)));
                                             ir_if *f2D3A = new(mem_ctx) ir_if(operand(r2D3B).val);
                                             exec_list *const f2D3A_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2D3A->then_instructions;

                                                body.emit(assign(r2D2D, lshift(r2CD6, r2D30), 0x01));

                                                ir_expression *const r2D3C = bit_and(r2D2C, body.constant(int(31)));
                                                body.emit(assign(r2D2E, rshift(r2CD6, r2D3C), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2D3A->else_instructions;

                                                ir_variable *const r2D3D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r2D3F = equal(r2D2C, body.constant(int(64)));
                                                ir_if *f2D3E = new(mem_ctx) ir_if(operand(r2D3F).val);
                                                exec_list *const f2D3E_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2D3E->then_instructions;

                                                   body.emit(assign(r2D3D, r2CD6, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2D3E->else_instructions;

                                                   ir_expression *const r2D40 = nequal(r2CD6, body.constant(0u));
                                                   ir_expression *const r2D41 = expr(ir_unop_b2i, r2D40);
                                                   body.emit(assign(r2D3D, expr(ir_unop_i2u, r2D41), 0x01));


                                                body.instructions = f2D3E_parent_instructions;
                                                body.emit(f2D3E);

                                                /* END IF */

                                                body.emit(assign(r2D2D, r2D3D, 0x01));

                                                body.emit(assign(r2D2E, body.constant(0u), 0x01));


                                             body.instructions = f2D3A_parent_instructions;
                                             body.emit(f2D3A);

                                             /* END IF */


                                          body.instructions = f2D38_parent_instructions;
                                          body.emit(f2D38);

                                          /* END IF */

                                          body.emit(assign(r2D2F, body.constant(0u), 0x01));


                                       body.instructions = f2D34_parent_instructions;
                                       body.emit(f2D34);

                                       /* END IF */

                                       ir_expression *const r2D42 = nequal(r2D2B, body.constant(0u));
                                       ir_expression *const r2D43 = expr(ir_unop_b2i, r2D42);
                                       ir_expression *const r2D44 = expr(ir_unop_i2u, r2D43);
                                       body.emit(assign(r2D2D, bit_or(r2D2D, r2D44), 0x01));


                                    body.instructions = f2D32_parent_instructions;
                                    body.emit(f2D32);

                                    /* END IF */

                                    body.emit(assign(r2D15, r2D2F, 0x01));

                                    body.emit(assign(r2D16, r2D2E, 0x01));

                                    body.emit(assign(r2D17, r2D2D, 0x01));

                                    body.emit(assign(r2D14, body.constant(int(0)), 0x01));

                                    body.emit(assign(r2D1A, less(r2D2D, body.constant(0u)), 0x01));


                                 body.instructions = f2D29_parent_instructions;
                                 body.emit(f2D29);

                                 /* END IF */


                              body.instructions = f2D26_parent_instructions;
                              body.emit(f2D26);

                              /* END IF */


                           body.instructions = f2D1C_parent_instructions;
                           body.emit(f2D1C);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2D45 = new(mem_ctx) ir_if(operand(r2D18).val);
                           exec_list *const f2D45_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2D45->then_instructions;

                              /* IF CONDITION */
                              ir_if *f2D46 = new(mem_ctx) ir_if(operand(r2D1A).val);
                              exec_list *const f2D46_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2D46->then_instructions;

                                 ir_variable *const r2D47 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r2D47, add(r2D16, body.constant(1u)), 0x01));

                                 ir_expression *const r2D48 = less(r2D47, r2D16);
                                 ir_expression *const r2D49 = expr(ir_unop_b2i, r2D48);
                                 ir_expression *const r2D4A = expr(ir_unop_i2u, r2D49);
                                 body.emit(assign(r2D15, add(r2D15, r2D4A), 0x01));

                                 ir_expression *const r2D4B = equal(r2D17, body.constant(0u));
                                 ir_expression *const r2D4C = expr(ir_unop_b2i, r2D4B);
                                 ir_expression *const r2D4D = expr(ir_unop_i2u, r2D4C);
                                 ir_expression *const r2D4E = add(r2D17, r2D4D);
                                 ir_expression *const r2D4F = bit_and(r2D4E, body.constant(1u));
                                 ir_expression *const r2D50 = expr(ir_unop_bit_not, r2D4F);
                                 body.emit(assign(r2D16, bit_and(r2D47, r2D50), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2D46->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2D52 = bit_or(r2D15, r2D16);
                                 ir_expression *const r2D53 = equal(r2D52, body.constant(0u));
                                 ir_if *f2D51 = new(mem_ctx) ir_if(operand(r2D53).val);
                                 exec_list *const f2D51_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2D51->then_instructions;

                                    body.emit(assign(r2D14, body.constant(int(0)), 0x01));


                                 body.instructions = f2D51_parent_instructions;
                                 body.emit(f2D51);

                                 /* END IF */


                              body.instructions = f2D46_parent_instructions;
                              body.emit(f2D46);

                              /* END IF */

                              ir_variable *const r2D54 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2D54);
                              ir_expression *const r2D55 = lshift(r2944, body.constant(int(31)));
                              ir_expression *const r2D56 = expr(ir_unop_i2u, r2D14);
                              ir_expression *const r2D57 = lshift(r2D56, body.constant(int(20)));
                              ir_expression *const r2D58 = add(r2D55, r2D57);
                              body.emit(assign(r2D54, add(r2D58, r2D15), 0x02));

                              body.emit(assign(r2D54, r2D16, 0x01));

                              body.emit(assign(r2D19, r2D54, 0x03));

                              body.emit(assign(r2D18, body.constant(false), 0x01));


                           body.instructions = f2D45_parent_instructions;
                           body.emit(f2D45);

                           /* END IF */

                           body.emit(assign(r2945, r2D19, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2CCD->else_instructions;

                           ir_variable *const r2D59 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2D59);
                           body.emit(assign(r2D59, body.constant(0u), 0x02));

                           body.emit(assign(r2D59, body.constant(0u), 0x01));

                           body.emit(assign(r2945, r2D59, 0x03));


                        body.instructions = f2CCD_parent_instructions;
                        body.emit(f2CCD);

                        /* END IF */


                     body.instructions = f2C41_parent_instructions;
                     body.emit(f2C41);

                     /* END IF */


                  body.instructions = f2BB5_parent_instructions;
                  body.emit(f2BB5);

                  /* END IF */


               body.instructions = f2B29_parent_instructions;
               body.emit(f2B29);

               /* END IF */


            body.instructions = f2B02_parent_instructions;
            body.emit(f2B02);

            /* END IF */


         body.instructions = f2A2E_parent_instructions;
         body.emit(f2A2E);

         /* END IF */


      body.instructions = f295E_parent_instructions;
      body.emit(f295E);

      /* END IF */

      body.emit(assign(r2796, r2945, 0x03));


   body.instructions = f2799_parent_instructions;
   body.emit(f2799);

   /* END IF */

   body.emit(ret(r2796));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fmod64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r2D5A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "x", ir_var_function_in);
   sig_parameters.push_tail(r2D5A);
   ir_variable *const r2D5B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "y", ir_var_function_in);
   sig_parameters.push_tail(r2D5B);
   ir_variable *const r2D5C = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r2D5C, body.constant(true), 0x01));

   ir_variable *const r2D5D = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r2D5E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r2D5E);
   ir_variable *const r2D5F = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r2D5F);
   ir_variable *const r2D60 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r2D60);
   ir_variable *const r2D61 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r2D61);
   ir_variable *const r2D62 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r2D62);
   ir_variable *const r2D63 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r2D63);
   ir_variable *const r2D64 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r2D64);
   ir_variable *const r2D65 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem3", ir_var_auto);
   body.emit(r2D65);
   ir_variable *const r2D66 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem2", ir_var_auto);
   body.emit(r2D66);
   ir_variable *const r2D67 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r2D67);
   ir_variable *const r2D68 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r2D68);
   ir_variable *const r2D69 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r2D69);
   ir_variable *const r2D6A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r2D6A);
   ir_variable *const r2D6B = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r2D6B);
   body.emit(assign(r2D6A, body.constant(0u), 0x01));

   body.emit(assign(r2D69, body.constant(0u), 0x01));

   body.emit(assign(r2D68, body.constant(0u), 0x01));

   body.emit(assign(r2D67, body.constant(0u), 0x01));

   body.emit(assign(r2D66, body.constant(0u), 0x01));

   body.emit(assign(r2D65, body.constant(0u), 0x01));

   ir_variable *const r2D6C = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r2D6C, swizzle_x(r2D5A), 0x01));

   body.emit(assign(r2D64, r2D6C, 0x01));

   ir_variable *const r2D6D = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r2D6D, bit_and(swizzle_y(r2D5A), body.constant(1048575u)), 0x01));

   body.emit(assign(r2D63, r2D6D, 0x01));

   ir_variable *const r2D6E = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r2D6E, swizzle_x(r2D5B), 0x01));

   body.emit(assign(r2D62, r2D6E, 0x01));

   ir_variable *const r2D6F = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r2D6F, bit_and(swizzle_y(r2D5B), body.constant(1048575u)), 0x01));

   body.emit(assign(r2D61, r2D6F, 0x01));

   ir_variable *const r2D70 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r2D71 = rshift(swizzle_y(r2D5A), body.constant(int(20)));
   ir_expression *const r2D72 = bit_and(r2D71, body.constant(2047u));
   body.emit(assign(r2D70, expr(ir_unop_u2i, r2D72), 0x01));

   body.emit(assign(r2D60, r2D70, 0x01));

   ir_variable *const r2D73 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r2D74 = rshift(swizzle_y(r2D5B), body.constant(int(20)));
   ir_expression *const r2D75 = bit_and(r2D74, body.constant(2047u));
   body.emit(assign(r2D73, expr(ir_unop_u2i, r2D75), 0x01));

   body.emit(assign(r2D5F, r2D73, 0x01));

   ir_expression *const r2D76 = rshift(swizzle_y(r2D5A), body.constant(int(31)));
   ir_expression *const r2D77 = rshift(swizzle_y(r2D5B), body.constant(int(31)));
   body.emit(assign(r2D5E, bit_xor(r2D76, r2D77), 0x01));

   /* IF CONDITION */
   ir_expression *const r2D79 = equal(r2D70, body.constant(int(2047)));
   ir_if *f2D78 = new(mem_ctx) ir_if(operand(r2D79).val);
   exec_list *const f2D78_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f2D78->then_instructions;

      /* IF CONDITION */
      ir_expression *const r2D7B = bit_or(r2D6D, swizzle_x(r2D5A));
      ir_expression *const r2D7C = nequal(r2D7B, body.constant(0u));
      ir_if *f2D7A = new(mem_ctx) ir_if(operand(r2D7C).val);
      exec_list *const f2D7A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2D7A->then_instructions;

         ir_variable *const r2D7D = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r2D7D, swizzle_x(r2D5A), 0x01));

         ir_variable *const r2D7E = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r2D7E, swizzle_x(r2D5B), 0x01));

         ir_variable *const r2D7F = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2D80 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r2D81 = rshift(swizzle_y(r2D5A), body.constant(int(19)));
         ir_expression *const r2D82 = bit_and(r2D81, body.constant(4095u));
         ir_expression *const r2D83 = equal(r2D82, body.constant(4094u));
         ir_expression *const r2D84 = nequal(swizzle_x(r2D5A), body.constant(0u));
         ir_expression *const r2D85 = bit_and(swizzle_y(r2D5A), body.constant(524287u));
         ir_expression *const r2D86 = nequal(r2D85, body.constant(0u));
         ir_expression *const r2D87 = logic_or(r2D84, r2D86);
         body.emit(assign(r2D80, logic_and(r2D83, r2D87), 0x01));

         ir_variable *const r2D88 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r2D89 = lshift(swizzle_y(r2D5B), body.constant(int(1)));
         ir_expression *const r2D8A = lequal(body.constant(4292870144u), r2D89);
         ir_expression *const r2D8B = nequal(swizzle_x(r2D5B), body.constant(0u));
         ir_expression *const r2D8C = bit_and(swizzle_y(r2D5B), body.constant(1048575u));
         ir_expression *const r2D8D = nequal(r2D8C, body.constant(0u));
         ir_expression *const r2D8E = logic_or(r2D8B, r2D8D);
         body.emit(assign(r2D88, logic_and(r2D8A, r2D8E), 0x01));

         body.emit(assign(r2D7D, bit_or(swizzle_y(r2D5A), body.constant(524288u)), 0x02));

         body.emit(assign(r2D7E, bit_or(swizzle_y(r2D5B), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r2D90 = lshift(swizzle_y(r2D5A), body.constant(int(1)));
         ir_expression *const r2D91 = lequal(body.constant(4292870144u), r2D90);
         ir_expression *const r2D92 = nequal(swizzle_x(r2D5A), body.constant(0u));
         ir_expression *const r2D93 = bit_and(swizzle_y(r2D5A), body.constant(1048575u));
         ir_expression *const r2D94 = nequal(r2D93, body.constant(0u));
         ir_expression *const r2D95 = logic_or(r2D92, r2D94);
         ir_expression *const r2D96 = logic_and(r2D91, r2D95);
         ir_if *f2D8F = new(mem_ctx) ir_if(operand(r2D96).val);
         exec_list *const f2D8F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2D8F->then_instructions;

            ir_variable *const r2D97 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r2D99 = logic_and(r2D80, r2D88);
            ir_if *f2D98 = new(mem_ctx) ir_if(operand(r2D99).val);
            exec_list *const f2D98_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2D98->then_instructions;

               body.emit(assign(r2D97, r2D7E, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2D98->else_instructions;

               body.emit(assign(r2D97, r2D7D, 0x03));


            body.instructions = f2D98_parent_instructions;
            body.emit(f2D98);

            /* END IF */

            body.emit(assign(r2D7F, r2D97, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2D8F->else_instructions;

            body.emit(assign(r2D7F, r2D7E, 0x03));


         body.instructions = f2D8F_parent_instructions;
         body.emit(f2D8F);

         /* END IF */

         body.emit(assign(r2D5D, r2D7F, 0x03));

         body.emit(assign(r2D5C, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2D7A->else_instructions;

         /* IF CONDITION */
         ir_expression *const r2D9B = equal(r2D73, body.constant(int(2047)));
         ir_if *f2D9A = new(mem_ctx) ir_if(operand(r2D9B).val);
         exec_list *const f2D9A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2D9A->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2D9D = bit_or(r2D6F, swizzle_x(r2D5B));
            ir_expression *const r2D9E = nequal(r2D9D, body.constant(0u));
            ir_if *f2D9C = new(mem_ctx) ir_if(operand(r2D9E).val);
            exec_list *const f2D9C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2D9C->then_instructions;

               ir_variable *const r2D9F = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r2D9F, swizzle_x(r2D5A), 0x01));

               ir_variable *const r2DA0 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r2DA0, swizzle_x(r2D5B), 0x01));

               ir_variable *const r2DA1 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2DA2 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r2DA3 = rshift(swizzle_y(r2D5A), body.constant(int(19)));
               ir_expression *const r2DA4 = bit_and(r2DA3, body.constant(4095u));
               ir_expression *const r2DA5 = equal(r2DA4, body.constant(4094u));
               ir_expression *const r2DA6 = nequal(swizzle_x(r2D5A), body.constant(0u));
               ir_expression *const r2DA7 = bit_and(swizzle_y(r2D5A), body.constant(524287u));
               ir_expression *const r2DA8 = nequal(r2DA7, body.constant(0u));
               ir_expression *const r2DA9 = logic_or(r2DA6, r2DA8);
               body.emit(assign(r2DA2, logic_and(r2DA5, r2DA9), 0x01));

               ir_variable *const r2DAA = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r2DAB = lshift(swizzle_y(r2D5B), body.constant(int(1)));
               ir_expression *const r2DAC = lequal(body.constant(4292870144u), r2DAB);
               ir_expression *const r2DAD = nequal(swizzle_x(r2D5B), body.constant(0u));
               ir_expression *const r2DAE = bit_and(swizzle_y(r2D5B), body.constant(1048575u));
               ir_expression *const r2DAF = nequal(r2DAE, body.constant(0u));
               ir_expression *const r2DB0 = logic_or(r2DAD, r2DAF);
               body.emit(assign(r2DAA, logic_and(r2DAC, r2DB0), 0x01));

               body.emit(assign(r2D9F, bit_or(swizzle_y(r2D5A), body.constant(524288u)), 0x02));

               body.emit(assign(r2DA0, bit_or(swizzle_y(r2D5B), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r2DB2 = lshift(swizzle_y(r2D5A), body.constant(int(1)));
               ir_expression *const r2DB3 = lequal(body.constant(4292870144u), r2DB2);
               ir_expression *const r2DB4 = nequal(swizzle_x(r2D5A), body.constant(0u));
               ir_expression *const r2DB5 = bit_and(swizzle_y(r2D5A), body.constant(1048575u));
               ir_expression *const r2DB6 = nequal(r2DB5, body.constant(0u));
               ir_expression *const r2DB7 = logic_or(r2DB4, r2DB6);
               ir_expression *const r2DB8 = logic_and(r2DB3, r2DB7);
               ir_if *f2DB1 = new(mem_ctx) ir_if(operand(r2DB8).val);
               exec_list *const f2DB1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DB1->then_instructions;

                  ir_variable *const r2DB9 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2DBB = logic_and(r2DA2, r2DAA);
                  ir_if *f2DBA = new(mem_ctx) ir_if(operand(r2DBB).val);
                  exec_list *const f2DBA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DBA->then_instructions;

                     body.emit(assign(r2DB9, r2DA0, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DBA->else_instructions;

                     body.emit(assign(r2DB9, r2D9F, 0x03));


                  body.instructions = f2DBA_parent_instructions;
                  body.emit(f2DBA);

                  /* END IF */

                  body.emit(assign(r2DA1, r2DB9, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2DB1->else_instructions;

                  body.emit(assign(r2DA1, r2DA0, 0x03));


               body.instructions = f2DB1_parent_instructions;
               body.emit(f2DB1);

               /* END IF */

               body.emit(assign(r2D5D, r2DA1, 0x03));

               body.emit(assign(r2D5C, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2D9C->else_instructions;

               ir_constant_data r2DBC_data;
               memset(&r2DBC_data, 0, sizeof(ir_constant_data));
               r2DBC_data.u[0] = 4294967295;
               r2DBC_data.u[1] = 4294967295;
               ir_constant *const r2DBC = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r2DBC_data);
               body.emit(assign(r2D5D, r2DBC, 0x03));

               body.emit(assign(r2D5C, body.constant(false), 0x01));


            body.instructions = f2D9C_parent_instructions;
            body.emit(f2D9C);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2D9A->else_instructions;

            ir_variable *const r2DBD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r2DBD);
            ir_expression *const r2DBE = lshift(r2D5E, body.constant(int(31)));
            body.emit(assign(r2DBD, add(r2DBE, body.constant(2146435072u)), 0x02));

            body.emit(assign(r2DBD, body.constant(0u), 0x01));

            body.emit(assign(r2D5D, r2DBD, 0x03));

            body.emit(assign(r2D5C, body.constant(false), 0x01));


         body.instructions = f2D9A_parent_instructions;
         body.emit(f2D9A);

         /* END IF */


      body.instructions = f2D7A_parent_instructions;
      body.emit(f2D7A);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f2D78->else_instructions;

      /* IF CONDITION */
      ir_expression *const r2DC0 = equal(r2D73, body.constant(int(2047)));
      ir_if *f2DBF = new(mem_ctx) ir_if(operand(r2DC0).val);
      exec_list *const f2DBF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2DBF->then_instructions;

         /* IF CONDITION */
         ir_expression *const r2DC2 = bit_or(r2D6F, swizzle_x(r2D5B));
         ir_expression *const r2DC3 = nequal(r2DC2, body.constant(0u));
         ir_if *f2DC1 = new(mem_ctx) ir_if(operand(r2DC3).val);
         exec_list *const f2DC1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2DC1->then_instructions;

            ir_variable *const r2DC4 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r2DC4, swizzle_x(r2D5A), 0x01));

            ir_variable *const r2DC5 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r2DC5, swizzle_x(r2D5B), 0x01));

            ir_variable *const r2DC6 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r2DC7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r2DC8 = rshift(swizzle_y(r2D5A), body.constant(int(19)));
            ir_expression *const r2DC9 = bit_and(r2DC8, body.constant(4095u));
            ir_expression *const r2DCA = equal(r2DC9, body.constant(4094u));
            ir_expression *const r2DCB = nequal(swizzle_x(r2D5A), body.constant(0u));
            ir_expression *const r2DCC = bit_and(swizzle_y(r2D5A), body.constant(524287u));
            ir_expression *const r2DCD = nequal(r2DCC, body.constant(0u));
            ir_expression *const r2DCE = logic_or(r2DCB, r2DCD);
            body.emit(assign(r2DC7, logic_and(r2DCA, r2DCE), 0x01));

            ir_variable *const r2DCF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r2DD0 = lshift(swizzle_y(r2D5B), body.constant(int(1)));
            ir_expression *const r2DD1 = lequal(body.constant(4292870144u), r2DD0);
            ir_expression *const r2DD2 = nequal(swizzle_x(r2D5B), body.constant(0u));
            ir_expression *const r2DD3 = bit_and(swizzle_y(r2D5B), body.constant(1048575u));
            ir_expression *const r2DD4 = nequal(r2DD3, body.constant(0u));
            ir_expression *const r2DD5 = logic_or(r2DD2, r2DD4);
            body.emit(assign(r2DCF, logic_and(r2DD1, r2DD5), 0x01));

            body.emit(assign(r2DC4, bit_or(swizzle_y(r2D5A), body.constant(524288u)), 0x02));

            body.emit(assign(r2DC5, bit_or(swizzle_y(r2D5B), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r2DD7 = lshift(swizzle_y(r2D5A), body.constant(int(1)));
            ir_expression *const r2DD8 = lequal(body.constant(4292870144u), r2DD7);
            ir_expression *const r2DD9 = nequal(swizzle_x(r2D5A), body.constant(0u));
            ir_expression *const r2DDA = bit_and(swizzle_y(r2D5A), body.constant(1048575u));
            ir_expression *const r2DDB = nequal(r2DDA, body.constant(0u));
            ir_expression *const r2DDC = logic_or(r2DD9, r2DDB);
            ir_expression *const r2DDD = logic_and(r2DD8, r2DDC);
            ir_if *f2DD6 = new(mem_ctx) ir_if(operand(r2DDD).val);
            exec_list *const f2DD6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2DD6->then_instructions;

               ir_variable *const r2DDE = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r2DE0 = logic_and(r2DC7, r2DCF);
               ir_if *f2DDF = new(mem_ctx) ir_if(operand(r2DE0).val);
               exec_list *const f2DDF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DDF->then_instructions;

                  body.emit(assign(r2DDE, r2DC5, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2DDF->else_instructions;

                  body.emit(assign(r2DDE, r2DC4, 0x03));


               body.instructions = f2DDF_parent_instructions;
               body.emit(f2DDF);

               /* END IF */

               body.emit(assign(r2DC6, r2DDE, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2DD6->else_instructions;

               body.emit(assign(r2DC6, r2DC5, 0x03));


            body.instructions = f2DD6_parent_instructions;
            body.emit(f2DD6);

            /* END IF */

            body.emit(assign(r2D5D, r2DC6, 0x03));

            body.emit(assign(r2D5C, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2DC1->else_instructions;

            ir_variable *const r2DE1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r2DE1);
            body.emit(assign(r2DE1, lshift(r2D5E, body.constant(int(31))), 0x02));

            body.emit(assign(r2DE1, body.constant(0u), 0x01));

            body.emit(assign(r2D5D, r2DE1, 0x03));

            body.emit(assign(r2D5C, body.constant(false), 0x01));


         body.instructions = f2DC1_parent_instructions;
         body.emit(f2DC1);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2DBF->else_instructions;

         /* IF CONDITION */
         ir_expression *const r2DE3 = equal(r2D73, body.constant(int(0)));
         ir_if *f2DE2 = new(mem_ctx) ir_if(operand(r2DE3).val);
         exec_list *const f2DE2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2DE2->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2DE5 = bit_or(r2D6F, swizzle_x(r2D5B));
            ir_expression *const r2DE6 = equal(r2DE5, body.constant(0u));
            ir_if *f2DE4 = new(mem_ctx) ir_if(operand(r2DE6).val);
            exec_list *const f2DE4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2DE4->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2DE8 = expr(ir_unop_i2u, r2D70);
               ir_expression *const r2DE9 = bit_or(r2DE8, r2D6D);
               ir_expression *const r2DEA = bit_or(r2DE9, swizzle_x(r2D5A));
               ir_expression *const r2DEB = equal(r2DEA, body.constant(0u));
               ir_if *f2DE7 = new(mem_ctx) ir_if(operand(r2DEB).val);
               exec_list *const f2DE7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DE7->then_instructions;

                  ir_constant_data r2DEC_data;
                  memset(&r2DEC_data, 0, sizeof(ir_constant_data));
                  r2DEC_data.u[0] = 4294967295;
                  r2DEC_data.u[1] = 4294967295;
                  ir_constant *const r2DEC = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r2DEC_data);
                  body.emit(assign(r2D5D, r2DEC, 0x03));

                  body.emit(assign(r2D5C, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2DE7->else_instructions;

                  ir_variable *const r2DED = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2DED);
                  ir_expression *const r2DEE = lshift(r2D5E, body.constant(int(31)));
                  body.emit(assign(r2DED, add(r2DEE, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r2DED, body.constant(0u), 0x01));

                  body.emit(assign(r2D5D, r2DED, 0x03));

                  body.emit(assign(r2D5C, body.constant(false), 0x01));


               body.instructions = f2DE7_parent_instructions;
               body.emit(f2DE7);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2DE4->else_instructions;

               ir_variable *const r2DEF = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r2DEF, r2D73, 0x01));

               ir_variable *const r2DF0 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r2DF0, r2D6F, 0x01));

               ir_variable *const r2DF1 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r2DF1, r2D6E, 0x01));

               ir_variable *const r2DF2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2DF2);
               /* IF CONDITION */
               ir_expression *const r2DF4 = equal(r2D6F, body.constant(0u));
               ir_if *f2DF3 = new(mem_ctx) ir_if(operand(r2DF4).val);
               exec_list *const f2DF3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DF3->then_instructions;

                  ir_variable *const r2DF5 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r2DF5, r2D6E, 0x01));

                  ir_variable *const r2DF6 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r2DF7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r2DF7);
                  /* IF CONDITION */
                  ir_expression *const r2DF9 = equal(swizzle_x(r2D5B), body.constant(0u));
                  ir_if *f2DF8 = new(mem_ctx) ir_if(operand(r2DF9).val);
                  exec_list *const f2DF8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DF8->then_instructions;

                     body.emit(assign(r2DF6, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DF8->else_instructions;

                     body.emit(assign(r2DF7, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2DFB = bit_and(swizzle_x(r2D5B), body.constant(4294901760u));
                     ir_expression *const r2DFC = equal(r2DFB, body.constant(0u));
                     ir_if *f2DFA = new(mem_ctx) ir_if(operand(r2DFC).val);
                     exec_list *const f2DFA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DFA->then_instructions;

                        body.emit(assign(r2DF7, body.constant(int(16)), 0x01));

                        body.emit(assign(r2DF5, lshift(swizzle_x(r2D5B), body.constant(int(16))), 0x01));


                     body.instructions = f2DFA_parent_instructions;
                     body.emit(f2DFA);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2DFE = bit_and(r2DF5, body.constant(4278190080u));
                     ir_expression *const r2DFF = equal(r2DFE, body.constant(0u));
                     ir_if *f2DFD = new(mem_ctx) ir_if(operand(r2DFF).val);
                     exec_list *const f2DFD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DFD->then_instructions;

                        body.emit(assign(r2DF7, add(r2DF7, body.constant(int(8))), 0x01));

                        body.emit(assign(r2DF5, lshift(r2DF5, body.constant(int(8))), 0x01));


                     body.instructions = f2DFD_parent_instructions;
                     body.emit(f2DFD);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E01 = bit_and(r2DF5, body.constant(4026531840u));
                     ir_expression *const r2E02 = equal(r2E01, body.constant(0u));
                     ir_if *f2E00 = new(mem_ctx) ir_if(operand(r2E02).val);
                     exec_list *const f2E00_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E00->then_instructions;

                        body.emit(assign(r2DF7, add(r2DF7, body.constant(int(4))), 0x01));

                        body.emit(assign(r2DF5, lshift(r2DF5, body.constant(int(4))), 0x01));


                     body.instructions = f2E00_parent_instructions;
                     body.emit(f2E00);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E04 = bit_and(r2DF5, body.constant(3221225472u));
                     ir_expression *const r2E05 = equal(r2E04, body.constant(0u));
                     ir_if *f2E03 = new(mem_ctx) ir_if(operand(r2E05).val);
                     exec_list *const f2E03_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E03->then_instructions;

                        body.emit(assign(r2DF7, add(r2DF7, body.constant(int(2))), 0x01));

                        body.emit(assign(r2DF5, lshift(r2DF5, body.constant(int(2))), 0x01));


                     body.instructions = f2E03_parent_instructions;
                     body.emit(f2E03);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E07 = bit_and(r2DF5, body.constant(2147483648u));
                     ir_expression *const r2E08 = equal(r2E07, body.constant(0u));
                     ir_if *f2E06 = new(mem_ctx) ir_if(operand(r2E08).val);
                     exec_list *const f2E06_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E06->then_instructions;

                        body.emit(assign(r2DF7, add(r2DF7, body.constant(int(1))), 0x01));


                     body.instructions = f2E06_parent_instructions;
                     body.emit(f2E06);

                     /* END IF */

                     body.emit(assign(r2DF6, r2DF7, 0x01));


                  body.instructions = f2DF8_parent_instructions;
                  body.emit(f2DF8);

                  /* END IF */

                  body.emit(assign(r2DF2, add(r2DF6, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2E0A = less(r2DF2, body.constant(int(0)));
                  ir_if *f2E09 = new(mem_ctx) ir_if(operand(r2E0A).val);
                  exec_list *const f2E09_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E09->then_instructions;

                     ir_expression *const r2E0B = neg(r2DF2);
                     body.emit(assign(r2DF0, rshift(swizzle_x(r2D5B), r2E0B), 0x01));

                     ir_expression *const r2E0C = bit_and(r2DF2, body.constant(int(31)));
                     body.emit(assign(r2DF1, lshift(swizzle_x(r2D5B), r2E0C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E09->else_instructions;

                     body.emit(assign(r2DF0, lshift(swizzle_x(r2D5B), r2DF2), 0x01));

                     body.emit(assign(r2DF1, body.constant(0u), 0x01));


                  body.instructions = f2E09_parent_instructions;
                  body.emit(f2E09);

                  /* END IF */

                  body.emit(assign(r2DEF, sub(body.constant(int(-31)), r2DF2), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2DF3->else_instructions;

                  ir_variable *const r2E0D = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r2E0D, r2D6F, 0x01));

                  ir_variable *const r2E0E = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r2E0F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r2E0F);
                  /* IF CONDITION */
                  ir_expression *const r2E11 = equal(r2D6F, body.constant(0u));
                  ir_if *f2E10 = new(mem_ctx) ir_if(operand(r2E11).val);
                  exec_list *const f2E10_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E10->then_instructions;

                     body.emit(assign(r2E0E, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E10->else_instructions;

                     body.emit(assign(r2E0F, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2E13 = bit_and(r2D6F, body.constant(4294901760u));
                     ir_expression *const r2E14 = equal(r2E13, body.constant(0u));
                     ir_if *f2E12 = new(mem_ctx) ir_if(operand(r2E14).val);
                     exec_list *const f2E12_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E12->then_instructions;

                        body.emit(assign(r2E0F, body.constant(int(16)), 0x01));

                        body.emit(assign(r2E0D, lshift(r2D6F, body.constant(int(16))), 0x01));


                     body.instructions = f2E12_parent_instructions;
                     body.emit(f2E12);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E16 = bit_and(r2E0D, body.constant(4278190080u));
                     ir_expression *const r2E17 = equal(r2E16, body.constant(0u));
                     ir_if *f2E15 = new(mem_ctx) ir_if(operand(r2E17).val);
                     exec_list *const f2E15_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E15->then_instructions;

                        body.emit(assign(r2E0F, add(r2E0F, body.constant(int(8))), 0x01));

                        body.emit(assign(r2E0D, lshift(r2E0D, body.constant(int(8))), 0x01));


                     body.instructions = f2E15_parent_instructions;
                     body.emit(f2E15);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E19 = bit_and(r2E0D, body.constant(4026531840u));
                     ir_expression *const r2E1A = equal(r2E19, body.constant(0u));
                     ir_if *f2E18 = new(mem_ctx) ir_if(operand(r2E1A).val);
                     exec_list *const f2E18_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E18->then_instructions;

                        body.emit(assign(r2E0F, add(r2E0F, body.constant(int(4))), 0x01));

                        body.emit(assign(r2E0D, lshift(r2E0D, body.constant(int(4))), 0x01));


                     body.instructions = f2E18_parent_instructions;
                     body.emit(f2E18);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E1C = bit_and(r2E0D, body.constant(3221225472u));
                     ir_expression *const r2E1D = equal(r2E1C, body.constant(0u));
                     ir_if *f2E1B = new(mem_ctx) ir_if(operand(r2E1D).val);
                     exec_list *const f2E1B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E1B->then_instructions;

                        body.emit(assign(r2E0F, add(r2E0F, body.constant(int(2))), 0x01));

                        body.emit(assign(r2E0D, lshift(r2E0D, body.constant(int(2))), 0x01));


                     body.instructions = f2E1B_parent_instructions;
                     body.emit(f2E1B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E1F = bit_and(r2E0D, body.constant(2147483648u));
                     ir_expression *const r2E20 = equal(r2E1F, body.constant(0u));
                     ir_if *f2E1E = new(mem_ctx) ir_if(operand(r2E20).val);
                     exec_list *const f2E1E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E1E->then_instructions;

                        body.emit(assign(r2E0F, add(r2E0F, body.constant(int(1))), 0x01));


                     body.instructions = f2E1E_parent_instructions;
                     body.emit(f2E1E);

                     /* END IF */

                     body.emit(assign(r2E0E, r2E0F, 0x01));


                  body.instructions = f2E10_parent_instructions;
                  body.emit(f2E10);

                  /* END IF */

                  body.emit(assign(r2DF2, add(r2E0E, body.constant(int(-11))), 0x01));

                  ir_variable *const r2E21 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2E21, lshift(swizzle_x(r2D5B), r2DF2), 0x01));

                  ir_variable *const r2E22 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2E24 = equal(r2DF2, body.constant(int(0)));
                  ir_if *f2E23 = new(mem_ctx) ir_if(operand(r2E24).val);
                  exec_list *const f2E23_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E23->then_instructions;

                     body.emit(assign(r2E22, r2D6F, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E23->else_instructions;

                     ir_expression *const r2E25 = lshift(r2D6F, r2DF2);
                     ir_expression *const r2E26 = neg(r2DF2);
                     ir_expression *const r2E27 = bit_and(r2E26, body.constant(int(31)));
                     ir_expression *const r2E28 = rshift(swizzle_x(r2D5B), r2E27);
                     body.emit(assign(r2E22, bit_or(r2E25, r2E28), 0x01));


                  body.instructions = f2E23_parent_instructions;
                  body.emit(f2E23);

                  /* END IF */

                  body.emit(assign(r2DF0, r2E22, 0x01));

                  body.emit(assign(r2DF1, r2E21, 0x01));

                  body.emit(assign(r2DEF, sub(body.constant(int(1)), r2DF2), 0x01));


               body.instructions = f2DF3_parent_instructions;
               body.emit(f2DF3);

               /* END IF */

               body.emit(assign(r2D5F, r2DEF, 0x01));

               body.emit(assign(r2D61, r2DF0, 0x01));

               body.emit(assign(r2D62, r2DF1, 0x01));


            body.instructions = f2DE4_parent_instructions;
            body.emit(f2DE4);

            /* END IF */


         body.instructions = f2DE2_parent_instructions;
         body.emit(f2DE2);

         /* END IF */

         /* IF CONDITION */
         ir_if *f2E29 = new(mem_ctx) ir_if(operand(r2D5C).val);
         exec_list *const f2E29_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2E29->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2E2B = equal(r2D70, body.constant(int(0)));
            ir_if *f2E2A = new(mem_ctx) ir_if(operand(r2E2B).val);
            exec_list *const f2E2A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2E2A->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2E2D = bit_or(r2D6D, swizzle_x(r2D5A));
               ir_expression *const r2E2E = equal(r2E2D, body.constant(0u));
               ir_if *f2E2C = new(mem_ctx) ir_if(operand(r2E2E).val);
               exec_list *const f2E2C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E2C->then_instructions;

                  ir_variable *const r2E2F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2E2F);
                  body.emit(assign(r2E2F, lshift(r2D5E, body.constant(int(31))), 0x02));

                  body.emit(assign(r2E2F, body.constant(0u), 0x01));

                  body.emit(assign(r2D5D, r2E2F, 0x03));

                  body.emit(assign(r2D5C, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2E2C->else_instructions;

                  ir_variable *const r2E30 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r2E30, r2D70, 0x01));

                  ir_variable *const r2E31 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r2E31, r2D6D, 0x01));

                  ir_variable *const r2E32 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r2E32, r2D6C, 0x01));

                  ir_variable *const r2E33 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r2E33);
                  /* IF CONDITION */
                  ir_expression *const r2E35 = equal(r2D6D, body.constant(0u));
                  ir_if *f2E34 = new(mem_ctx) ir_if(operand(r2E35).val);
                  exec_list *const f2E34_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E34->then_instructions;

                     ir_variable *const r2E36 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r2E36, r2D6C, 0x01));

                     ir_variable *const r2E37 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r2E38 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2E38);
                     /* IF CONDITION */
                     ir_expression *const r2E3A = equal(swizzle_x(r2D5A), body.constant(0u));
                     ir_if *f2E39 = new(mem_ctx) ir_if(operand(r2E3A).val);
                     exec_list *const f2E39_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E39->then_instructions;

                        body.emit(assign(r2E37, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E39->else_instructions;

                        body.emit(assign(r2E38, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2E3C = bit_and(swizzle_x(r2D5A), body.constant(4294901760u));
                        ir_expression *const r2E3D = equal(r2E3C, body.constant(0u));
                        ir_if *f2E3B = new(mem_ctx) ir_if(operand(r2E3D).val);
                        exec_list *const f2E3B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2E3B->then_instructions;

                           body.emit(assign(r2E38, body.constant(int(16)), 0x01));

                           body.emit(assign(r2E36, lshift(swizzle_x(r2D5A), body.constant(int(16))), 0x01));


                        body.instructions = f2E3B_parent_instructions;
                        body.emit(f2E3B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2E3F = bit_and(r2E36, body.constant(4278190080u));
                        ir_expression *const r2E40 = equal(r2E3F, body.constant(0u));
                        ir_if *f2E3E = new(mem_ctx) ir_if(operand(r2E40).val);
                        exec_list *const f2E3E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2E3E->then_instructions;

                           body.emit(assign(r2E38, add(r2E38, body.constant(int(8))), 0x01));

                           body.emit(assign(r2E36, lshift(r2E36, body.constant(int(8))), 0x01));


                        body.instructions = f2E3E_parent_instructions;
                        body.emit(f2E3E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2E42 = bit_and(r2E36, body.constant(4026531840u));
                        ir_expression *const r2E43 = equal(r2E42, body.constant(0u));
                        ir_if *f2E41 = new(mem_ctx) ir_if(operand(r2E43).val);
                        exec_list *const f2E41_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2E41->then_instructions;

                           body.emit(assign(r2E38, add(r2E38, body.constant(int(4))), 0x01));

                           body.emit(assign(r2E36, lshift(r2E36, body.constant(int(4))), 0x01));


                        body.instructions = f2E41_parent_instructions;
                        body.emit(f2E41);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2E45 = bit_and(r2E36, body.constant(3221225472u));
                        ir_expression *const r2E46 = equal(r2E45, body.constant(0u));
                        ir_if *f2E44 = new(mem_ctx) ir_if(operand(r2E46).val);
                        exec_list *const f2E44_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2E44->then_instructions;

                           body.emit(assign(r2E38, add(r2E38, body.constant(int(2))), 0x01));

                           body.emit(assign(r2E36, lshift(r2E36, body.constant(int(2))), 0x01));


                        body.instructions = f2E44_parent_instructions;
                        body.emit(f2E44);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2E48 = bit_and(r2E36, body.constant(2147483648u));
                        ir_expression *const r2E49 = equal(r2E48, body.constant(0u));
                        ir_if *f2E47 = new(mem_ctx) ir_if(operand(r2E49).val);
                        exec_list *const f2E47_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2E47->then_instructions;

                           body.emit(assign(r2E38, add(r2E38, body.constant(int(1))), 0x01));


                        body.instructions = f2E47_parent_instructions;
                        body.emit(f2E47);

                        /* END IF */

                        body.emit(assign(r2E37, r2E38, 0x01));


                     body.instructions = f2E39_parent_instructions;
                     body.emit(f2E39);

                     /* END IF */

                     body.emit(assign(r2E33, add(r2E37, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2E4B = less(r2E33, body.constant(int(0)));
                     ir_if *f2E4A = new(mem_ctx) ir_if(operand(r2E4B).val);
                     exec_list *const f2E4A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E4A->then_instructions;

                        ir_expression *const r2E4C = neg(r2E33);
                        body.emit(assign(r2E31, rshift(swizzle_x(r2D5A), r2E4C), 0x01));

                        ir_expression *const r2E4D = bit_and(r2E33, body.constant(int(31)));
                        body.emit(assign(r2E32, lshift(swizzle_x(r2D5A), r2E4D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E4A->else_instructions;

                        body.emit(assign(r2E31, lshift(swizzle_x(r2D5A), r2E33), 0x01));

                        body.emit(assign(r2E32, body.constant(0u), 0x01));


                     body.instructions = f2E4A_parent_instructions;
                     body.emit(f2E4A);

                     /* END IF */

                     body.emit(assign(r2E30, sub(body.constant(int(-31)), r2E33), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E34->else_instructions;

                     ir_variable *const r2E4E = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r2E4E, r2D6D, 0x01));

                     ir_variable *const r2E4F = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r2E50 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2E50);
                     /* IF CONDITION */
                     ir_expression *const r2E52 = equal(r2D6D, body.constant(0u));
                     ir_if *f2E51 = new(mem_ctx) ir_if(operand(r2E52).val);
                     exec_list *const f2E51_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E51->then_instructions;

                        body.emit(assign(r2E4F, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E51->else_instructions;

                        body.emit(assign(r2E50, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2E54 = bit_and(r2D6D, body.constant(4294901760u));
                        ir_expression *const r2E55 = equal(r2E54, body.constant(0u));
                        ir_if *f2E53 = new(mem_ctx) ir_if(operand(r2E55).val);
                        exec_list *const f2E53_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2E53->then_instructions;

                           body.emit(assign(r2E50, body.constant(int(16)), 0x01));

                           body.emit(assign(r2E4E, lshift(r2D6D, body.constant(int(16))), 0x01));


                        body.instructions = f2E53_parent_instructions;
                        body.emit(f2E53);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2E57 = bit_and(r2E4E, body.constant(4278190080u));
                        ir_expression *const r2E58 = equal(r2E57, body.constant(0u));
                        ir_if *f2E56 = new(mem_ctx) ir_if(operand(r2E58).val);
                        exec_list *const f2E56_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2E56->then_instructions;

                           body.emit(assign(r2E50, add(r2E50, body.constant(int(8))), 0x01));

                           body.emit(assign(r2E4E, lshift(r2E4E, body.constant(int(8))), 0x01));


                        body.instructions = f2E56_parent_instructions;
                        body.emit(f2E56);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2E5A = bit_and(r2E4E, body.constant(4026531840u));
                        ir_expression *const r2E5B = equal(r2E5A, body.constant(0u));
                        ir_if *f2E59 = new(mem_ctx) ir_if(operand(r2E5B).val);
                        exec_list *const f2E59_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2E59->then_instructions;

                           body.emit(assign(r2E50, add(r2E50, body.constant(int(4))), 0x01));

                           body.emit(assign(r2E4E, lshift(r2E4E, body.constant(int(4))), 0x01));


                        body.instructions = f2E59_parent_instructions;
                        body.emit(f2E59);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2E5D = bit_and(r2E4E, body.constant(3221225472u));
                        ir_expression *const r2E5E = equal(r2E5D, body.constant(0u));
                        ir_if *f2E5C = new(mem_ctx) ir_if(operand(r2E5E).val);
                        exec_list *const f2E5C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2E5C->then_instructions;

                           body.emit(assign(r2E50, add(r2E50, body.constant(int(2))), 0x01));

                           body.emit(assign(r2E4E, lshift(r2E4E, body.constant(int(2))), 0x01));


                        body.instructions = f2E5C_parent_instructions;
                        body.emit(f2E5C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2E60 = bit_and(r2E4E, body.constant(2147483648u));
                        ir_expression *const r2E61 = equal(r2E60, body.constant(0u));
                        ir_if *f2E5F = new(mem_ctx) ir_if(operand(r2E61).val);
                        exec_list *const f2E5F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2E5F->then_instructions;

                           body.emit(assign(r2E50, add(r2E50, body.constant(int(1))), 0x01));


                        body.instructions = f2E5F_parent_instructions;
                        body.emit(f2E5F);

                        /* END IF */

                        body.emit(assign(r2E4F, r2E50, 0x01));


                     body.instructions = f2E51_parent_instructions;
                     body.emit(f2E51);

                     /* END IF */

                     body.emit(assign(r2E33, add(r2E4F, body.constant(int(-11))), 0x01));

                     ir_variable *const r2E62 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r2E62, lshift(swizzle_x(r2D5A), r2E33), 0x01));

                     ir_variable *const r2E63 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2E65 = equal(r2E33, body.constant(int(0)));
                     ir_if *f2E64 = new(mem_ctx) ir_if(operand(r2E65).val);
                     exec_list *const f2E64_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E64->then_instructions;

                        body.emit(assign(r2E63, r2D6D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E64->else_instructions;

                        ir_expression *const r2E66 = lshift(r2D6D, r2E33);
                        ir_expression *const r2E67 = neg(r2E33);
                        ir_expression *const r2E68 = bit_and(r2E67, body.constant(int(31)));
                        ir_expression *const r2E69 = rshift(swizzle_x(r2D5A), r2E68);
                        body.emit(assign(r2E63, bit_or(r2E66, r2E69), 0x01));


                     body.instructions = f2E64_parent_instructions;
                     body.emit(f2E64);

                     /* END IF */

                     body.emit(assign(r2E31, r2E63, 0x01));

                     body.emit(assign(r2E32, r2E62, 0x01));

                     body.emit(assign(r2E30, sub(body.constant(int(1)), r2E33), 0x01));


                  body.instructions = f2E34_parent_instructions;
                  body.emit(f2E34);

                  /* END IF */

                  body.emit(assign(r2D60, r2E30, 0x01));

                  body.emit(assign(r2D63, r2E31, 0x01));

                  body.emit(assign(r2D64, r2E32, 0x01));


               body.instructions = f2E2C_parent_instructions;
               body.emit(f2E2C);

               /* END IF */


            body.instructions = f2E2A_parent_instructions;
            body.emit(f2E2A);

            /* END IF */

            /* IF CONDITION */
            ir_if *f2E6A = new(mem_ctx) ir_if(operand(r2D5C).val);
            exec_list *const f2E6A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2E6A->then_instructions;

               ir_expression *const r2E6B = sub(r2D60, r2D5F);
               body.emit(assign(r2D6B, add(r2E6B, body.constant(int(1021))), 0x01));

               ir_variable *const r2E6C = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2E6C, lshift(r2D64, body.constant(int(11))), 0x01));

               ir_variable *const r2E6D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r2E6E = bit_or(r2D63, body.constant(1048576u));
               ir_expression *const r2E6F = lshift(r2E6E, body.constant(int(11)));
               ir_expression *const r2E70 = rshift(r2D64, body.constant(int(21)));
               body.emit(assign(r2E6D, bit_or(r2E6F, r2E70), 0x01));

               body.emit(assign(r2D63, r2E6D, 0x01));

               body.emit(assign(r2D64, r2E6C, 0x01));

               ir_variable *const r2E71 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2E71, lshift(r2D62, body.constant(int(11))), 0x01));

               ir_variable *const r2E72 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r2E73 = bit_or(r2D61, body.constant(1048576u));
               ir_expression *const r2E74 = lshift(r2E73, body.constant(int(11)));
               ir_expression *const r2E75 = rshift(r2D62, body.constant(int(21)));
               body.emit(assign(r2E72, bit_or(r2E74, r2E75), 0x01));

               body.emit(assign(r2D61, r2E72, 0x01));

               body.emit(assign(r2D62, r2E71, 0x01));

               /* IF CONDITION */
               ir_expression *const r2E77 = less(r2E72, r2E6D);
               ir_expression *const r2E78 = equal(r2E72, r2E6D);
               ir_expression *const r2E79 = lequal(r2E71, r2E6C);
               ir_expression *const r2E7A = logic_and(r2E78, r2E79);
               ir_expression *const r2E7B = logic_or(r2E77, r2E7A);
               ir_if *f2E76 = new(mem_ctx) ir_if(operand(r2E7B).val);
               exec_list *const f2E76_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E76->then_instructions;

                  body.emit(assign(r2D63, rshift(r2E6D, body.constant(int(1))), 0x01));

                  ir_expression *const r2E7C = lshift(r2E6D, body.constant(int(31)));
                  ir_expression *const r2E7D = rshift(r2E6C, body.constant(int(1)));
                  body.emit(assign(r2D64, bit_or(r2E7C, r2E7D), 0x01));

                  body.emit(assign(r2D6B, add(r2D6B, body.constant(int(1))), 0x01));


               body.instructions = f2E76_parent_instructions;
               body.emit(f2E76);

               /* END IF */

               ir_variable *const r2E7E = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r2E7F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r2E7F);
               ir_variable *const r2E80 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r2E80);
               ir_variable *const r2E81 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r2E81);
               ir_variable *const r2E82 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r2E82);
               body.emit(assign(r2E81, body.constant(0u), 0x01));

               body.emit(assign(r2E80, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r2E84 = lequal(r2E72, r2D63);
               ir_if *f2E83 = new(mem_ctx) ir_if(operand(r2E84).val);
               exec_list *const f2E83_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E83->then_instructions;

                  body.emit(assign(r2E7E, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2E83->else_instructions;

                  body.emit(assign(r2E82, rshift(r2E72, body.constant(int(16))), 0x01));

                  ir_variable *const r2E85 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2E87 = lshift(r2E82, body.constant(int(16)));
                  ir_expression *const r2E88 = lequal(r2E87, r2D63);
                  ir_if *f2E86 = new(mem_ctx) ir_if(operand(r2E88).val);
                  exec_list *const f2E86_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E86->then_instructions;

                     body.emit(assign(r2E85, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E86->else_instructions;

                     ir_expression *const r2E89 = expr(ir_binop_div, r2D63, r2E82);
                     body.emit(assign(r2E85, lshift(r2E89, body.constant(int(16))), 0x01));


                  body.instructions = f2E86_parent_instructions;
                  body.emit(f2E86);

                  /* END IF */

                  body.emit(assign(r2E7F, r2E85, 0x01));

                  ir_variable *const r2E8A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2E8A);
                  ir_variable *const r2E8B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r2E8B);
                  ir_variable *const r2E8C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2E8C);
                  ir_variable *const r2E8D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2E8D, bit_and(r2E72, body.constant(65535u)), 0x01));

                  ir_variable *const r2E8E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2E8E, rshift(r2E72, body.constant(int(16))), 0x01));

                  ir_variable *const r2E8F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2E8F, bit_and(r2E85, body.constant(65535u)), 0x01));

                  ir_variable *const r2E90 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2E90, rshift(r2E85, body.constant(int(16))), 0x01));

                  ir_variable *const r2E91 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2E91, mul(r2E8E, r2E8F), 0x01));

                  ir_expression *const r2E92 = mul(r2E8D, r2E90);
                  body.emit(assign(r2E8B, add(r2E92, r2E91), 0x01));

                  ir_expression *const r2E93 = mul(r2E8E, r2E90);
                  ir_expression *const r2E94 = less(r2E8B, r2E91);
                  ir_expression *const r2E95 = expr(ir_unop_b2i, r2E94);
                  ir_expression *const r2E96 = expr(ir_unop_i2u, r2E95);
                  ir_expression *const r2E97 = lshift(r2E96, body.constant(int(16)));
                  ir_expression *const r2E98 = rshift(r2E8B, body.constant(int(16)));
                  ir_expression *const r2E99 = add(r2E97, r2E98);
                  body.emit(assign(r2E8A, add(r2E93, r2E99), 0x01));

                  body.emit(assign(r2E8B, lshift(r2E8B, body.constant(int(16))), 0x01));

                  ir_expression *const r2E9A = mul(r2E8D, r2E8F);
                  body.emit(assign(r2E8C, add(r2E9A, r2E8B), 0x01));

                  ir_expression *const r2E9B = less(r2E8C, r2E8B);
                  ir_expression *const r2E9C = expr(ir_unop_b2i, r2E9B);
                  ir_expression *const r2E9D = expr(ir_unop_i2u, r2E9C);
                  body.emit(assign(r2E8A, add(r2E8A, r2E9D), 0x01));

                  ir_expression *const r2E9E = sub(r2D63, r2E8A);
                  ir_expression *const r2E9F = less(r2D64, r2E8C);
                  ir_expression *const r2EA0 = expr(ir_unop_b2i, r2E9F);
                  ir_expression *const r2EA1 = expr(ir_unop_i2u, r2EA0);
                  body.emit(assign(r2E81, sub(r2E9E, r2EA1), 0x01));

                  body.emit(assign(r2E80, sub(r2D64, r2E8C), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f2EA2 = new(mem_ctx) ir_loop();
                  exec_list *const f2EA2_parent_instructions = body.instructions;

                     body.instructions = &f2EA2->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2EA4 = expr(ir_unop_u2i, r2E81);
                     ir_expression *const r2EA5 = gequal(r2EA4, body.constant(int(0)));
                     ir_if *f2EA3 = new(mem_ctx) ir_if(operand(r2EA5).val);
                     exec_list *const f2EA3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2EA3->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f2EA3_parent_instructions;
                     body.emit(f2EA3);

                     /* END IF */

                     body.emit(assign(r2E7F, add(r2E7F, body.constant(4294901760u)), 0x01));

                     ir_variable *const r2EA6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r2EA7 = lshift(r2E72, body.constant(int(16)));
                     body.emit(assign(r2EA6, add(r2E80, r2EA7), 0x01));

                     ir_expression *const r2EA8 = add(r2E81, r2E82);
                     ir_expression *const r2EA9 = less(r2EA6, r2E80);
                     ir_expression *const r2EAA = expr(ir_unop_b2i, r2EA9);
                     ir_expression *const r2EAB = expr(ir_unop_i2u, r2EAA);
                     body.emit(assign(r2E81, add(r2EA8, r2EAB), 0x01));

                     body.emit(assign(r2E80, r2EA6, 0x01));

                  /* LOOP END */

                  body.instructions = f2EA2_parent_instructions;
                  body.emit(f2EA2);

                  ir_expression *const r2EAC = lshift(r2E81, body.constant(int(16)));
                  ir_expression *const r2EAD = rshift(r2E80, body.constant(int(16)));
                  body.emit(assign(r2E81, bit_or(r2EAC, r2EAD), 0x01));

                  ir_variable *const r2EAE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2EB0 = lshift(r2E82, body.constant(int(16)));
                  ir_expression *const r2EB1 = lequal(r2EB0, r2E81);
                  ir_if *f2EAF = new(mem_ctx) ir_if(operand(r2EB1).val);
                  exec_list *const f2EAF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2EAF->then_instructions;

                     body.emit(assign(r2EAE, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2EAF->else_instructions;

                     body.emit(assign(r2EAE, expr(ir_binop_div, r2E81, r2E82), 0x01));


                  body.instructions = f2EAF_parent_instructions;
                  body.emit(f2EAF);

                  /* END IF */

                  body.emit(assign(r2E7F, bit_or(r2E7F, r2EAE), 0x01));

                  body.emit(assign(r2E7E, r2E7F, 0x01));


               body.instructions = f2E83_parent_instructions;
               body.emit(f2E83);

               /* END IF */

               body.emit(assign(r2D6A, r2E7E, 0x01));

               ir_variable *const r2EB2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2EB2);
               ir_variable *const r2EB3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r2EB3);
               ir_variable *const r2EB4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2EB4);
               ir_variable *const r2EB5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r2EB5, bit_and(r2E71, body.constant(65535u)), 0x01));

               ir_variable *const r2EB6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r2EB6, rshift(r2E71, body.constant(int(16))), 0x01));

               ir_variable *const r2EB7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r2EB7, bit_and(r2E7E, body.constant(65535u)), 0x01));

               ir_variable *const r2EB8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r2EB8, rshift(r2E7E, body.constant(int(16))), 0x01));

               ir_variable *const r2EB9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r2EB9, mul(r2EB6, r2EB7), 0x01));

               ir_expression *const r2EBA = mul(r2EB5, r2EB8);
               body.emit(assign(r2EB3, add(r2EBA, r2EB9), 0x01));

               ir_expression *const r2EBB = mul(r2EB6, r2EB8);
               ir_expression *const r2EBC = less(r2EB3, r2EB9);
               ir_expression *const r2EBD = expr(ir_unop_b2i, r2EBC);
               ir_expression *const r2EBE = expr(ir_unop_i2u, r2EBD);
               ir_expression *const r2EBF = lshift(r2EBE, body.constant(int(16)));
               ir_expression *const r2EC0 = rshift(r2EB3, body.constant(int(16)));
               ir_expression *const r2EC1 = add(r2EBF, r2EC0);
               body.emit(assign(r2EB2, add(r2EBB, r2EC1), 0x01));

               body.emit(assign(r2EB3, lshift(r2EB3, body.constant(int(16))), 0x01));

               ir_expression *const r2EC2 = mul(r2EB5, r2EB7);
               body.emit(assign(r2EB4, add(r2EC2, r2EB3), 0x01));

               ir_expression *const r2EC3 = less(r2EB4, r2EB3);
               ir_expression *const r2EC4 = expr(ir_unop_b2i, r2EC3);
               ir_expression *const r2EC5 = expr(ir_unop_i2u, r2EC4);
               body.emit(assign(r2EB2, add(r2EB2, r2EC5), 0x01));

               ir_variable *const r2EC6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2EC6);
               ir_variable *const r2EC7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r2EC7);
               ir_variable *const r2EC8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2EC8);
               ir_variable *const r2EC9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r2EC9, bit_and(r2E72, body.constant(65535u)), 0x01));

               ir_variable *const r2ECA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r2ECA, rshift(r2E72, body.constant(int(16))), 0x01));

               ir_variable *const r2ECB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r2ECB, bit_and(r2E7E, body.constant(65535u)), 0x01));

               ir_variable *const r2ECC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r2ECC, rshift(r2E7E, body.constant(int(16))), 0x01));

               ir_variable *const r2ECD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r2ECD, mul(r2ECA, r2ECB), 0x01));

               ir_expression *const r2ECE = mul(r2EC9, r2ECC);
               body.emit(assign(r2EC7, add(r2ECE, r2ECD), 0x01));

               ir_expression *const r2ECF = mul(r2ECA, r2ECC);
               ir_expression *const r2ED0 = less(r2EC7, r2ECD);
               ir_expression *const r2ED1 = expr(ir_unop_b2i, r2ED0);
               ir_expression *const r2ED2 = expr(ir_unop_i2u, r2ED1);
               ir_expression *const r2ED3 = lshift(r2ED2, body.constant(int(16)));
               ir_expression *const r2ED4 = rshift(r2EC7, body.constant(int(16)));
               ir_expression *const r2ED5 = add(r2ED3, r2ED4);
               body.emit(assign(r2EC6, add(r2ECF, r2ED5), 0x01));

               body.emit(assign(r2EC7, lshift(r2EC7, body.constant(int(16))), 0x01));

               ir_expression *const r2ED6 = mul(r2EC9, r2ECB);
               body.emit(assign(r2EC8, add(r2ED6, r2EC7), 0x01));

               ir_expression *const r2ED7 = less(r2EC8, r2EC7);
               ir_expression *const r2ED8 = expr(ir_unop_b2i, r2ED7);
               ir_expression *const r2ED9 = expr(ir_unop_i2u, r2ED8);
               body.emit(assign(r2EC6, add(r2EC6, r2ED9), 0x01));

               ir_variable *const r2EDA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r2EDA, add(r2EC8, r2EB2), 0x01));

               ir_variable *const r2EDB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2EDB);
               ir_variable *const r2EDC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r2EDD = less(body.constant(0u), r2EB4);
               ir_expression *const r2EDE = expr(ir_unop_b2i, r2EDD);
               body.emit(assign(r2EDC, expr(ir_unop_i2u, r2EDE), 0x01));

               ir_variable *const r2EDF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r2EDF, sub(r2D64, r2EDA), 0x01));

               ir_expression *const r2EE0 = less(r2EDA, r2EC8);
               ir_expression *const r2EE1 = expr(ir_unop_b2i, r2EE0);
               ir_expression *const r2EE2 = expr(ir_unop_i2u, r2EE1);
               ir_expression *const r2EE3 = add(r2EC6, r2EE2);
               ir_expression *const r2EE4 = sub(r2D63, r2EE3);
               ir_expression *const r2EE5 = less(r2EDF, r2EDC);
               ir_expression *const r2EE6 = expr(ir_unop_b2i, r2EE5);
               ir_expression *const r2EE7 = expr(ir_unop_i2u, r2EE6);
               body.emit(assign(r2EDB, sub(r2EE4, r2EE7), 0x01));

               ir_expression *const r2EE8 = less(r2D64, r2EDA);
               ir_expression *const r2EE9 = expr(ir_unop_b2i, r2EE8);
               ir_expression *const r2EEA = expr(ir_unop_i2u, r2EE9);
               body.emit(assign(r2EDB, sub(r2EDB, r2EEA), 0x01));

               body.emit(assign(r2D68, r2EDB, 0x01));

               body.emit(assign(r2D67, sub(r2EDF, r2EDC), 0x01));

               body.emit(assign(r2D66, neg(r2EB4), 0x01));

               /* LOOP BEGIN */
               ir_loop *f2EEB = new(mem_ctx) ir_loop();
               exec_list *const f2EEB_parent_instructions = body.instructions;

                  body.instructions = &f2EEB->body_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2EED = expr(ir_unop_u2i, r2D68);
                  ir_expression *const r2EEE = gequal(r2EED, body.constant(int(0)));
                  ir_if *f2EEC = new(mem_ctx) ir_if(operand(r2EEE).val);
                  exec_list *const f2EEC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2EEC->then_instructions;

                     body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                  body.instructions = f2EEC_parent_instructions;
                  body.emit(f2EEC);

                  /* END IF */

                  body.emit(assign(r2D6A, add(r2D6A, body.constant(4294967295u)), 0x01));

                  ir_variable *const r2EEF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2EEF);
                  ir_variable *const r2EF0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2EF0);
                  ir_variable *const r2EF1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2EF1, add(r2D66, r2E71), 0x01));

                  ir_variable *const r2EF2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r2EF3 = less(r2EF1, r2D66);
                  ir_expression *const r2EF4 = expr(ir_unop_b2i, r2EF3);
                  body.emit(assign(r2EF2, expr(ir_unop_i2u, r2EF4), 0x01));

                  ir_variable *const r2EF5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2EF5, add(r2D67, r2E72), 0x01));

                  body.emit(assign(r2EF0, add(r2EF5, r2EF2), 0x01));

                  ir_expression *const r2EF6 = less(r2EF0, r2EF2);
                  ir_expression *const r2EF7 = expr(ir_unop_b2i, r2EF6);
                  ir_expression *const r2EF8 = expr(ir_unop_i2u, r2EF7);
                  body.emit(assign(r2EEF, add(r2D68, r2EF8), 0x01));

                  ir_expression *const r2EF9 = less(r2EF5, r2D67);
                  ir_expression *const r2EFA = expr(ir_unop_b2i, r2EF9);
                  ir_expression *const r2EFB = expr(ir_unop_i2u, r2EFA);
                  body.emit(assign(r2EEF, add(r2EEF, r2EFB), 0x01));

                  body.emit(assign(r2D68, r2EEF, 0x01));

                  body.emit(assign(r2D67, r2EF0, 0x01));

                  body.emit(assign(r2D66, r2EF1, 0x01));

               /* LOOP END */

               body.instructions = f2EEB_parent_instructions;
               body.emit(f2EEB);

               ir_variable *const r2EFC = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r2EFD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r2EFD);
               ir_variable *const r2EFE = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r2EFE);
               ir_variable *const r2EFF = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r2EFF);
               ir_variable *const r2F00 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r2F00);
               body.emit(assign(r2EFF, body.constant(0u), 0x01));

               body.emit(assign(r2EFE, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r2F02 = lequal(r2E72, r2D67);
               ir_if *f2F01 = new(mem_ctx) ir_if(operand(r2F02).val);
               exec_list *const f2F01_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2F01->then_instructions;

                  body.emit(assign(r2EFC, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2F01->else_instructions;

                  body.emit(assign(r2F00, rshift(r2E72, body.constant(int(16))), 0x01));

                  ir_variable *const r2F03 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2F05 = lshift(r2F00, body.constant(int(16)));
                  ir_expression *const r2F06 = lequal(r2F05, r2D67);
                  ir_if *f2F04 = new(mem_ctx) ir_if(operand(r2F06).val);
                  exec_list *const f2F04_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F04->then_instructions;

                     body.emit(assign(r2F03, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2F04->else_instructions;

                     ir_expression *const r2F07 = expr(ir_binop_div, r2D67, r2F00);
                     body.emit(assign(r2F03, lshift(r2F07, body.constant(int(16))), 0x01));


                  body.instructions = f2F04_parent_instructions;
                  body.emit(f2F04);

                  /* END IF */

                  body.emit(assign(r2EFD, r2F03, 0x01));

                  ir_variable *const r2F08 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2F08);
                  ir_variable *const r2F09 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r2F09);
                  ir_variable *const r2F0A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2F0A);
                  ir_variable *const r2F0B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F0B, bit_and(r2E72, body.constant(65535u)), 0x01));

                  ir_variable *const r2F0C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F0C, rshift(r2E72, body.constant(int(16))), 0x01));

                  ir_variable *const r2F0D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F0D, bit_and(r2F03, body.constant(65535u)), 0x01));

                  ir_variable *const r2F0E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F0E, rshift(r2F03, body.constant(int(16))), 0x01));

                  ir_variable *const r2F0F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F0F, mul(r2F0C, r2F0D), 0x01));

                  ir_expression *const r2F10 = mul(r2F0B, r2F0E);
                  body.emit(assign(r2F09, add(r2F10, r2F0F), 0x01));

                  ir_expression *const r2F11 = mul(r2F0C, r2F0E);
                  ir_expression *const r2F12 = less(r2F09, r2F0F);
                  ir_expression *const r2F13 = expr(ir_unop_b2i, r2F12);
                  ir_expression *const r2F14 = expr(ir_unop_i2u, r2F13);
                  ir_expression *const r2F15 = lshift(r2F14, body.constant(int(16)));
                  ir_expression *const r2F16 = rshift(r2F09, body.constant(int(16)));
                  ir_expression *const r2F17 = add(r2F15, r2F16);
                  body.emit(assign(r2F08, add(r2F11, r2F17), 0x01));

                  body.emit(assign(r2F09, lshift(r2F09, body.constant(int(16))), 0x01));

                  ir_expression *const r2F18 = mul(r2F0B, r2F0D);
                  body.emit(assign(r2F0A, add(r2F18, r2F09), 0x01));

                  ir_expression *const r2F19 = less(r2F0A, r2F09);
                  ir_expression *const r2F1A = expr(ir_unop_b2i, r2F19);
                  ir_expression *const r2F1B = expr(ir_unop_i2u, r2F1A);
                  body.emit(assign(r2F08, add(r2F08, r2F1B), 0x01));

                  ir_expression *const r2F1C = sub(r2D67, r2F08);
                  ir_expression *const r2F1D = less(r2D66, r2F0A);
                  ir_expression *const r2F1E = expr(ir_unop_b2i, r2F1D);
                  ir_expression *const r2F1F = expr(ir_unop_i2u, r2F1E);
                  body.emit(assign(r2EFF, sub(r2F1C, r2F1F), 0x01));

                  body.emit(assign(r2EFE, sub(r2D66, r2F0A), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f2F20 = new(mem_ctx) ir_loop();
                  exec_list *const f2F20_parent_instructions = body.instructions;

                     body.instructions = &f2F20->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2F22 = expr(ir_unop_u2i, r2EFF);
                     ir_expression *const r2F23 = gequal(r2F22, body.constant(int(0)));
                     ir_if *f2F21 = new(mem_ctx) ir_if(operand(r2F23).val);
                     exec_list *const f2F21_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F21->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f2F21_parent_instructions;
                     body.emit(f2F21);

                     /* END IF */

                     body.emit(assign(r2EFD, add(r2EFD, body.constant(4294901760u)), 0x01));

                     ir_variable *const r2F24 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r2F25 = lshift(r2E72, body.constant(int(16)));
                     body.emit(assign(r2F24, add(r2EFE, r2F25), 0x01));

                     ir_expression *const r2F26 = add(r2EFF, r2F00);
                     ir_expression *const r2F27 = less(r2F24, r2EFE);
                     ir_expression *const r2F28 = expr(ir_unop_b2i, r2F27);
                     ir_expression *const r2F29 = expr(ir_unop_i2u, r2F28);
                     body.emit(assign(r2EFF, add(r2F26, r2F29), 0x01));

                     body.emit(assign(r2EFE, r2F24, 0x01));

                  /* LOOP END */

                  body.instructions = f2F20_parent_instructions;
                  body.emit(f2F20);

                  ir_expression *const r2F2A = lshift(r2EFF, body.constant(int(16)));
                  ir_expression *const r2F2B = rshift(r2EFE, body.constant(int(16)));
                  body.emit(assign(r2EFF, bit_or(r2F2A, r2F2B), 0x01));

                  ir_variable *const r2F2C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2F2E = lshift(r2F00, body.constant(int(16)));
                  ir_expression *const r2F2F = lequal(r2F2E, r2EFF);
                  ir_if *f2F2D = new(mem_ctx) ir_if(operand(r2F2F).val);
                  exec_list *const f2F2D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F2D->then_instructions;

                     body.emit(assign(r2F2C, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2F2D->else_instructions;

                     body.emit(assign(r2F2C, expr(ir_binop_div, r2EFF, r2F00), 0x01));


                  body.instructions = f2F2D_parent_instructions;
                  body.emit(f2F2D);

                  /* END IF */

                  body.emit(assign(r2EFD, bit_or(r2EFD, r2F2C), 0x01));

                  body.emit(assign(r2EFC, r2EFD, 0x01));


               body.instructions = f2F01_parent_instructions;
               body.emit(f2F01);

               /* END IF */

               body.emit(assign(r2D69, r2EFC, 0x01));

               /* IF CONDITION */
               ir_expression *const r2F31 = bit_and(r2EFC, body.constant(1023u));
               ir_expression *const r2F32 = lequal(r2F31, body.constant(4u));
               ir_if *f2F30 = new(mem_ctx) ir_if(operand(r2F32).val);
               exec_list *const f2F30_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2F30->then_instructions;

                  ir_variable *const r2F33 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2F33);
                  ir_variable *const r2F34 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r2F34);
                  ir_variable *const r2F35 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2F35);
                  ir_variable *const r2F36 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F36, bit_and(r2E71, body.constant(65535u)), 0x01));

                  ir_variable *const r2F37 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F37, rshift(r2E71, body.constant(int(16))), 0x01));

                  ir_variable *const r2F38 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F38, bit_and(r2EFC, body.constant(65535u)), 0x01));

                  ir_variable *const r2F39 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F39, rshift(r2EFC, body.constant(int(16))), 0x01));

                  ir_variable *const r2F3A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F3A, mul(r2F37, r2F38), 0x01));

                  ir_expression *const r2F3B = mul(r2F36, r2F39);
                  body.emit(assign(r2F34, add(r2F3B, r2F3A), 0x01));

                  ir_expression *const r2F3C = mul(r2F37, r2F39);
                  ir_expression *const r2F3D = less(r2F34, r2F3A);
                  ir_expression *const r2F3E = expr(ir_unop_b2i, r2F3D);
                  ir_expression *const r2F3F = expr(ir_unop_i2u, r2F3E);
                  ir_expression *const r2F40 = lshift(r2F3F, body.constant(int(16)));
                  ir_expression *const r2F41 = rshift(r2F34, body.constant(int(16)));
                  ir_expression *const r2F42 = add(r2F40, r2F41);
                  body.emit(assign(r2F33, add(r2F3C, r2F42), 0x01));

                  body.emit(assign(r2F34, lshift(r2F34, body.constant(int(16))), 0x01));

                  ir_expression *const r2F43 = mul(r2F36, r2F38);
                  body.emit(assign(r2F35, add(r2F43, r2F34), 0x01));

                  ir_expression *const r2F44 = less(r2F35, r2F34);
                  ir_expression *const r2F45 = expr(ir_unop_b2i, r2F44);
                  ir_expression *const r2F46 = expr(ir_unop_i2u, r2F45);
                  body.emit(assign(r2F33, add(r2F33, r2F46), 0x01));

                  ir_variable *const r2F47 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2F47);
                  ir_variable *const r2F48 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r2F48);
                  ir_variable *const r2F49 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2F49);
                  ir_variable *const r2F4A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F4A, bit_and(r2E72, body.constant(65535u)), 0x01));

                  ir_variable *const r2F4B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F4B, rshift(r2E72, body.constant(int(16))), 0x01));

                  ir_variable *const r2F4C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F4C, bit_and(r2EFC, body.constant(65535u)), 0x01));

                  ir_variable *const r2F4D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F4D, rshift(r2EFC, body.constant(int(16))), 0x01));

                  ir_variable *const r2F4E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F4E, mul(r2F4B, r2F4C), 0x01));

                  ir_expression *const r2F4F = mul(r2F4A, r2F4D);
                  body.emit(assign(r2F48, add(r2F4F, r2F4E), 0x01));

                  ir_expression *const r2F50 = mul(r2F4B, r2F4D);
                  ir_expression *const r2F51 = less(r2F48, r2F4E);
                  ir_expression *const r2F52 = expr(ir_unop_b2i, r2F51);
                  ir_expression *const r2F53 = expr(ir_unop_i2u, r2F52);
                  ir_expression *const r2F54 = lshift(r2F53, body.constant(int(16)));
                  ir_expression *const r2F55 = rshift(r2F48, body.constant(int(16)));
                  ir_expression *const r2F56 = add(r2F54, r2F55);
                  body.emit(assign(r2F47, add(r2F50, r2F56), 0x01));

                  body.emit(assign(r2F48, lshift(r2F48, body.constant(int(16))), 0x01));

                  ir_expression *const r2F57 = mul(r2F4A, r2F4C);
                  body.emit(assign(r2F49, add(r2F57, r2F48), 0x01));

                  ir_expression *const r2F58 = less(r2F49, r2F48);
                  ir_expression *const r2F59 = expr(ir_unop_b2i, r2F58);
                  ir_expression *const r2F5A = expr(ir_unop_i2u, r2F59);
                  body.emit(assign(r2F47, add(r2F47, r2F5A), 0x01));

                  ir_variable *const r2F5B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F5B, add(r2F49, r2F33), 0x01));

                  ir_variable *const r2F5C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2F5C);
                  ir_variable *const r2F5D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r2F5E = less(body.constant(0u), r2F35);
                  ir_expression *const r2F5F = expr(ir_unop_b2i, r2F5E);
                  body.emit(assign(r2F5D, expr(ir_unop_i2u, r2F5F), 0x01));

                  ir_variable *const r2F60 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F60, sub(r2D66, r2F5B), 0x01));

                  ir_expression *const r2F61 = less(r2F5B, r2F49);
                  ir_expression *const r2F62 = expr(ir_unop_b2i, r2F61);
                  ir_expression *const r2F63 = expr(ir_unop_i2u, r2F62);
                  ir_expression *const r2F64 = add(r2F47, r2F63);
                  ir_expression *const r2F65 = sub(r2D67, r2F64);
                  ir_expression *const r2F66 = less(r2F60, r2F5D);
                  ir_expression *const r2F67 = expr(ir_unop_b2i, r2F66);
                  ir_expression *const r2F68 = expr(ir_unop_i2u, r2F67);
                  body.emit(assign(r2F5C, sub(r2F65, r2F68), 0x01));

                  ir_expression *const r2F69 = less(r2D66, r2F5B);
                  ir_expression *const r2F6A = expr(ir_unop_b2i, r2F69);
                  ir_expression *const r2F6B = expr(ir_unop_i2u, r2F6A);
                  body.emit(assign(r2F5C, sub(r2F5C, r2F6B), 0x01));

                  body.emit(assign(r2D67, r2F5C, 0x01));

                  body.emit(assign(r2D66, sub(r2F60, r2F5D), 0x01));

                  body.emit(assign(r2D65, neg(r2F35), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f2F6C = new(mem_ctx) ir_loop();
                  exec_list *const f2F6C_parent_instructions = body.instructions;

                     body.instructions = &f2F6C->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2F6E = expr(ir_unop_u2i, r2D67);
                     ir_expression *const r2F6F = gequal(r2F6E, body.constant(int(0)));
                     ir_if *f2F6D = new(mem_ctx) ir_if(operand(r2F6F).val);
                     exec_list *const f2F6D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F6D->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f2F6D_parent_instructions;
                     body.emit(f2F6D);

                     /* END IF */

                     body.emit(assign(r2D69, add(r2D69, body.constant(4294967295u)), 0x01));

                     ir_variable *const r2F70 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2F70);
                     ir_variable *const r2F71 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2F71);
                     ir_variable *const r2F72 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2F72, add(r2D65, r2E71), 0x01));

                     ir_variable *const r2F73 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r2F74 = less(r2F72, r2D65);
                     ir_expression *const r2F75 = expr(ir_unop_b2i, r2F74);
                     body.emit(assign(r2F73, expr(ir_unop_i2u, r2F75), 0x01));

                     ir_variable *const r2F76 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2F76, add(r2D66, r2E72), 0x01));

                     body.emit(assign(r2F71, add(r2F76, r2F73), 0x01));

                     ir_expression *const r2F77 = less(r2F71, r2F73);
                     ir_expression *const r2F78 = expr(ir_unop_b2i, r2F77);
                     ir_expression *const r2F79 = expr(ir_unop_i2u, r2F78);
                     body.emit(assign(r2F70, add(r2D67, r2F79), 0x01));

                     ir_expression *const r2F7A = less(r2F76, r2D66);
                     ir_expression *const r2F7B = expr(ir_unop_b2i, r2F7A);
                     ir_expression *const r2F7C = expr(ir_unop_i2u, r2F7B);
                     body.emit(assign(r2F70, add(r2F70, r2F7C), 0x01));

                     body.emit(assign(r2D67, r2F70, 0x01));

                     body.emit(assign(r2D66, r2F71, 0x01));

                     body.emit(assign(r2D65, r2F72, 0x01));

                  /* LOOP END */

                  body.instructions = f2F6C_parent_instructions;
                  body.emit(f2F6C);

                  ir_expression *const r2F7D = bit_or(r2D67, r2D66);
                  ir_expression *const r2F7E = bit_or(r2F7D, r2D65);
                  ir_expression *const r2F7F = nequal(r2F7E, body.constant(0u));
                  ir_expression *const r2F80 = expr(ir_unop_b2i, r2F7F);
                  ir_expression *const r2F81 = expr(ir_unop_i2u, r2F80);
                  body.emit(assign(r2D69, bit_or(r2D69, r2F81), 0x01));


               body.instructions = f2F30_parent_instructions;
               body.emit(f2F30);

               /* END IF */

               ir_variable *const r2F82 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2F82);
               ir_variable *const r2F83 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2F83);
               ir_variable *const r2F84 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2F84);
               body.emit(assign(r2F82, lshift(r2D69, body.constant(int(21))), 0x01));

               ir_expression *const r2F85 = lshift(r2D6A, body.constant(int(21)));
               ir_expression *const r2F86 = rshift(r2D69, body.constant(int(11)));
               body.emit(assign(r2F83, bit_or(r2F85, r2F86), 0x01));

               body.emit(assign(r2F84, rshift(r2D6A, body.constant(int(11))), 0x01));

               body.emit(assign(r2F82, bit_or(r2F82, body.constant(0u)), 0x01));

               body.emit(assign(r2D6A, r2F84, 0x01));

               body.emit(assign(r2D69, r2F83, 0x01));

               ir_variable *const r2F87 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2F87, r2D6B, 0x01));

               ir_variable *const r2F88 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2F88, r2F84, 0x01));

               ir_variable *const r2F89 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2F89, r2F83, 0x01));

               ir_variable *const r2F8A = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2F8A, r2F82, 0x01));

               ir_variable *const r2F8B = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2F8B, body.constant(true), 0x01));

               ir_variable *const r2F8C = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2F8D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2F8D);
               ir_expression *const r2F8E = expr(ir_unop_u2i, r2F82);
               body.emit(assign(r2F8D, less(r2F8E, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2F90 = lequal(body.constant(int(2045)), r2D6B);
               ir_if *f2F8F = new(mem_ctx) ir_if(operand(r2F90).val);
               exec_list *const f2F8F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2F8F->then_instructions;

                  ir_variable *const r2F91 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2F93 = less(body.constant(int(2045)), r2D6B);
                  ir_if *f2F92 = new(mem_ctx) ir_if(operand(r2F93).val);
                  exec_list *const f2F92_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F92->then_instructions;

                     body.emit(assign(r2F91, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2F92->else_instructions;

                     ir_variable *const r2F94 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2F96 = equal(r2D6B, body.constant(int(2045)));
                     ir_if *f2F95 = new(mem_ctx) ir_if(operand(r2F96).val);
                     exec_list *const f2F95_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F95->then_instructions;

                        ir_expression *const r2F97 = equal(body.constant(2097151u), r2F84);
                        ir_expression *const r2F98 = equal(body.constant(4294967295u), r2F83);
                        body.emit(assign(r2F94, logic_and(r2F97, r2F98), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2F95->else_instructions;

                        body.emit(assign(r2F94, body.constant(false), 0x01));


                     body.instructions = f2F95_parent_instructions;
                     body.emit(f2F95);

                     /* END IF */

                     body.emit(assign(r2F91, logic_and(r2F94, r2F8D), 0x01));


                  body.instructions = f2F92_parent_instructions;
                  body.emit(f2F92);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2F99 = new(mem_ctx) ir_if(operand(r2F91).val);
                  exec_list *const f2F99_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F99->then_instructions;

                     ir_variable *const r2F9A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2F9A);
                     ir_expression *const r2F9B = lshift(r2D5E, body.constant(int(31)));
                     body.emit(assign(r2F9A, add(r2F9B, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2F9A, body.constant(0u), 0x01));

                     body.emit(assign(r2F8C, r2F9A, 0x03));

                     body.emit(assign(r2F8B, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2F99->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2F9D = less(r2D6B, body.constant(int(0)));
                     ir_if *f2F9C = new(mem_ctx) ir_if(operand(r2F9D).val);
                     exec_list *const f2F9C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F9C->then_instructions;

                        ir_variable *const r2F9E = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2F9E, r2F82, 0x01));

                        ir_variable *const r2F9F = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2F9F, neg(r2D6B), 0x01));

                        ir_variable *const r2FA0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2FA0);
                        ir_variable *const r2FA1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2FA1);
                        ir_variable *const r2FA2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2FA2);
                        ir_variable *const r2FA3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2FA4 = neg(r2F9F);
                        body.emit(assign(r2FA3, bit_and(r2FA4, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2FA6 = equal(r2F9F, body.constant(int(0)));
                        ir_if *f2FA5 = new(mem_ctx) ir_if(operand(r2FA6).val);
                        exec_list *const f2FA5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2FA5->then_instructions;

                           body.emit(assign(r2FA0, r2F82, 0x01));

                           body.emit(assign(r2FA1, r2F83, 0x01));

                           body.emit(assign(r2FA2, r2F84, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2FA5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2FA8 = less(r2F9F, body.constant(int(32)));
                           ir_if *f2FA7 = new(mem_ctx) ir_if(operand(r2FA8).val);
                           exec_list *const f2FA7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FA7->then_instructions;

                              body.emit(assign(r2FA0, lshift(r2F83, r2FA3), 0x01));

                              ir_expression *const r2FA9 = lshift(r2F84, r2FA3);
                              ir_expression *const r2FAA = rshift(r2F83, r2F9F);
                              body.emit(assign(r2FA1, bit_or(r2FA9, r2FAA), 0x01));

                              body.emit(assign(r2FA2, rshift(r2F84, r2F9F), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2FA7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2FAC = equal(r2F9F, body.constant(int(32)));
                              ir_if *f2FAB = new(mem_ctx) ir_if(operand(r2FAC).val);
                              exec_list *const f2FAB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2FAB->then_instructions;

                                 body.emit(assign(r2FA0, r2F83, 0x01));

                                 body.emit(assign(r2FA1, r2F84, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2FAB->else_instructions;

                                 body.emit(assign(r2F9E, bit_or(r2F82, r2F83), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2FAE = less(r2F9F, body.constant(int(64)));
                                 ir_if *f2FAD = new(mem_ctx) ir_if(operand(r2FAE).val);
                                 exec_list *const f2FAD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2FAD->then_instructions;

                                    body.emit(assign(r2FA0, lshift(r2F84, r2FA3), 0x01));

                                    ir_expression *const r2FAF = bit_and(r2F9F, body.constant(int(31)));
                                    body.emit(assign(r2FA1, rshift(r2F84, r2FAF), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2FAD->else_instructions;

                                    ir_variable *const r2FB0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2FB2 = equal(r2F9F, body.constant(int(64)));
                                    ir_if *f2FB1 = new(mem_ctx) ir_if(operand(r2FB2).val);
                                    exec_list *const f2FB1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2FB1->then_instructions;

                                       body.emit(assign(r2FB0, r2F84, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2FB1->else_instructions;

                                       ir_expression *const r2FB3 = nequal(r2F84, body.constant(0u));
                                       ir_expression *const r2FB4 = expr(ir_unop_b2i, r2FB3);
                                       body.emit(assign(r2FB0, expr(ir_unop_i2u, r2FB4), 0x01));


                                    body.instructions = f2FB1_parent_instructions;
                                    body.emit(f2FB1);

                                    /* END IF */

                                    body.emit(assign(r2FA0, r2FB0, 0x01));

                                    body.emit(assign(r2FA1, body.constant(0u), 0x01));


                                 body.instructions = f2FAD_parent_instructions;
                                 body.emit(f2FAD);

                                 /* END IF */


                              body.instructions = f2FAB_parent_instructions;
                              body.emit(f2FAB);

                              /* END IF */

                              body.emit(assign(r2FA2, body.constant(0u), 0x01));


                           body.instructions = f2FA7_parent_instructions;
                           body.emit(f2FA7);

                           /* END IF */

                           ir_expression *const r2FB5 = nequal(r2F9E, body.constant(0u));
                           ir_expression *const r2FB6 = expr(ir_unop_b2i, r2FB5);
                           ir_expression *const r2FB7 = expr(ir_unop_i2u, r2FB6);
                           body.emit(assign(r2FA0, bit_or(r2FA0, r2FB7), 0x01));


                        body.instructions = f2FA5_parent_instructions;
                        body.emit(f2FA5);

                        /* END IF */

                        body.emit(assign(r2F88, r2FA2, 0x01));

                        body.emit(assign(r2F89, r2FA1, 0x01));

                        body.emit(assign(r2F8A, r2FA0, 0x01));

                        body.emit(assign(r2F87, body.constant(int(0)), 0x01));

                        body.emit(assign(r2F8D, less(r2FA0, body.constant(0u)), 0x01));


                     body.instructions = f2F9C_parent_instructions;
                     body.emit(f2F9C);

                     /* END IF */


                  body.instructions = f2F99_parent_instructions;
                  body.emit(f2F99);

                  /* END IF */


               body.instructions = f2F8F_parent_instructions;
               body.emit(f2F8F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2FB8 = new(mem_ctx) ir_if(operand(r2F8B).val);
               exec_list *const f2FB8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2FB8->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2FB9 = new(mem_ctx) ir_if(operand(r2F8D).val);
                  exec_list *const f2FB9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2FB9->then_instructions;

                     ir_variable *const r2FBA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2FBA, add(r2F89, body.constant(1u)), 0x01));

                     ir_expression *const r2FBB = less(r2FBA, r2F89);
                     ir_expression *const r2FBC = expr(ir_unop_b2i, r2FBB);
                     ir_expression *const r2FBD = expr(ir_unop_i2u, r2FBC);
                     body.emit(assign(r2F88, add(r2F88, r2FBD), 0x01));

                     ir_expression *const r2FBE = equal(r2F8A, body.constant(0u));
                     ir_expression *const r2FBF = expr(ir_unop_b2i, r2FBE);
                     ir_expression *const r2FC0 = expr(ir_unop_i2u, r2FBF);
                     ir_expression *const r2FC1 = add(r2F8A, r2FC0);
                     ir_expression *const r2FC2 = bit_and(r2FC1, body.constant(1u));
                     ir_expression *const r2FC3 = expr(ir_unop_bit_not, r2FC2);
                     body.emit(assign(r2F89, bit_and(r2FBA, r2FC3), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2FB9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2FC5 = bit_or(r2F88, r2F89);
                     ir_expression *const r2FC6 = equal(r2FC5, body.constant(0u));
                     ir_if *f2FC4 = new(mem_ctx) ir_if(operand(r2FC6).val);
                     exec_list *const f2FC4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2FC4->then_instructions;

                        body.emit(assign(r2F87, body.constant(int(0)), 0x01));


                     body.instructions = f2FC4_parent_instructions;
                     body.emit(f2FC4);

                     /* END IF */


                  body.instructions = f2FB9_parent_instructions;
                  body.emit(f2FB9);

                  /* END IF */

                  ir_variable *const r2FC7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2FC7);
                  ir_expression *const r2FC8 = lshift(r2D5E, body.constant(int(31)));
                  ir_expression *const r2FC9 = expr(ir_unop_i2u, r2F87);
                  ir_expression *const r2FCA = lshift(r2FC9, body.constant(int(20)));
                  ir_expression *const r2FCB = add(r2FC8, r2FCA);
                  body.emit(assign(r2FC7, add(r2FCB, r2F88), 0x02));

                  body.emit(assign(r2FC7, r2F89, 0x01));

                  body.emit(assign(r2F8C, r2FC7, 0x03));

                  body.emit(assign(r2F8B, body.constant(false), 0x01));


               body.instructions = f2FB8_parent_instructions;
               body.emit(f2FB8);

               /* END IF */

               body.emit(assign(r2D5D, r2F8C, 0x03));

               body.emit(assign(r2D5C, body.constant(false), 0x01));


            body.instructions = f2E6A_parent_instructions;
            body.emit(f2E6A);

            /* END IF */


         body.instructions = f2E29_parent_instructions;
         body.emit(f2E29);

         /* END IF */


      body.instructions = f2DBF_parent_instructions;
      body.emit(f2DBF);

      /* END IF */


   body.instructions = f2D78_parent_instructions;
   body.emit(f2D78);

   /* END IF */

   ir_variable *const r2FCC = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r2FCD = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r2FCE = rshift(swizzle_y(r2D5D), body.constant(int(20)));
   ir_expression *const r2FCF = bit_and(r2FCE, body.constant(2047u));
   ir_expression *const r2FD0 = expr(ir_unop_u2i, r2FCF);
   body.emit(assign(r2FCD, add(r2FD0, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r2FD2 = less(r2FCD, body.constant(int(0)));
   ir_if *f2FD1 = new(mem_ctx) ir_if(operand(r2FD2).val);
   exec_list *const f2FD1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f2FD1->then_instructions;

      body.emit(assign(r2FCC, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f2FD1->else_instructions;

      /* IF CONDITION */
      ir_expression *const r2FD4 = greater(r2FCD, body.constant(int(52)));
      ir_if *f2FD3 = new(mem_ctx) ir_if(operand(r2FD4).val);
      exec_list *const f2FD3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2FD3->then_instructions;

         body.emit(assign(r2FCC, r2D5D, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2FD3->else_instructions;

         ir_variable *const r2FD5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r2FD5, sub(body.constant(int(52)), r2FCD), 0x01));

         ir_variable *const r2FD6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r2FD8 = gequal(r2FD5, body.constant(int(32)));
         ir_if *f2FD7 = new(mem_ctx) ir_if(operand(r2FD8).val);
         exec_list *const f2FD7_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2FD7->then_instructions;

            body.emit(assign(r2FD6, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2FD7->else_instructions;

            body.emit(assign(r2FD6, lshift(body.constant(4294967295u), r2FD5), 0x01));


         body.instructions = f2FD7_parent_instructions;
         body.emit(f2FD7);

         /* END IF */

         ir_variable *const r2FD9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r2FDB = less(r2FD5, body.constant(int(33)));
         ir_if *f2FDA = new(mem_ctx) ir_if(operand(r2FDB).val);
         exec_list *const f2FDA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2FDA->then_instructions;

            body.emit(assign(r2FD9, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2FDA->else_instructions;

            ir_expression *const r2FDC = add(r2FD5, body.constant(int(-32)));
            body.emit(assign(r2FD9, lshift(body.constant(4294967295u), r2FDC), 0x01));


         body.instructions = f2FDA_parent_instructions;
         body.emit(f2FDA);

         /* END IF */

         ir_variable *const r2FDD = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r2FDD, bit_and(r2FD6, swizzle_x(r2D5D)), 0x01));

         body.emit(assign(r2FDD, bit_and(r2FD9, swizzle_y(r2D5D)), 0x02));

         body.emit(assign(r2FCC, r2FDD, 0x03));


      body.instructions = f2FD3_parent_instructions;
      body.emit(f2FD3);

      /* END IF */


   body.instructions = f2FD1_parent_instructions;
   body.emit(f2FD1);

   /* END IF */

   ir_variable *const r2FDE = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r2FDF = rshift(swizzle_y(r2D5D), body.constant(int(31)));
   ir_expression *const r2FE0 = expr(ir_unop_u2i, r2FDF);
   body.emit(assign(r2FDE, expr(ir_unop_i2b, r2FE0), 0x01));

   ir_variable *const r2FE1 = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r2FE3 = expr(ir_unop_logic_not, r2FDE);
   ir_if *f2FE2 = new(mem_ctx) ir_if(operand(r2FE3).val);
   exec_list *const f2FE2_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f2FE2->then_instructions;

      body.emit(assign(r2FE1, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f2FE2->else_instructions;

      ir_variable *const r2FE4 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r2FE5 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r2FE5);
      ir_variable *const r2FE6 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r2FE6);
      ir_expression *const r2FE7 = rshift(swizzle_y(r2D5D), body.constant(int(20)));
      ir_expression *const r2FE8 = bit_and(r2FE7, body.constant(2047u));
      ir_expression *const r2FE9 = expr(ir_unop_u2i, r2FE8);
      ir_expression *const r2FEA = equal(r2FE9, body.constant(int(2047)));
      ir_expression *const r2FEB = bit_and(swizzle_y(r2D5D), body.constant(1048575u));
      ir_expression *const r2FEC = bit_or(r2FEB, swizzle_x(r2D5D));
      ir_expression *const r2FED = nequal(r2FEC, body.constant(0u));
      body.emit(assign(r2FE6, logic_and(r2FEA, r2FED), 0x01));

      ir_expression *const r2FEE = rshift(swizzle_y(r2FCC), body.constant(int(20)));
      ir_expression *const r2FEF = bit_and(r2FEE, body.constant(2047u));
      ir_expression *const r2FF0 = expr(ir_unop_u2i, r2FEF);
      ir_expression *const r2FF1 = equal(r2FF0, body.constant(int(2047)));
      ir_expression *const r2FF2 = bit_and(swizzle_y(r2FCC), body.constant(1048575u));
      ir_expression *const r2FF3 = bit_or(r2FF2, swizzle_x(r2FCC));
      ir_expression *const r2FF4 = nequal(r2FF3, body.constant(0u));
      body.emit(assign(r2FE5, logic_and(r2FF1, r2FF4), 0x01));

      /* IF CONDITION */
      ir_expression *const r2FF6 = logic_or(r2FE6, r2FE5);
      ir_if *f2FF5 = new(mem_ctx) ir_if(operand(r2FF6).val);
      exec_list *const f2FF5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2FF5->then_instructions;

         body.emit(assign(r2FE4, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2FF5->else_instructions;

         ir_expression *const r2FF7 = equal(swizzle_x(r2D5D), swizzle_x(r2FCC));
         ir_expression *const r2FF8 = equal(swizzle_y(r2D5D), swizzle_y(r2FCC));
         ir_expression *const r2FF9 = equal(swizzle_x(r2D5D), body.constant(0u));
         ir_expression *const r2FFA = bit_or(swizzle_y(r2D5D), swizzle_y(r2FCC));
         ir_expression *const r2FFB = lshift(r2FFA, body.constant(int(1)));
         ir_expression *const r2FFC = equal(r2FFB, body.constant(0u));
         ir_expression *const r2FFD = logic_and(r2FF9, r2FFC);
         ir_expression *const r2FFE = logic_or(r2FF8, r2FFD);
         body.emit(assign(r2FE4, logic_and(r2FF7, r2FFE), 0x01));


      body.instructions = f2FF5_parent_instructions;
      body.emit(f2FF5);

      /* END IF */

      body.emit(assign(r2FE1, r2FE4, 0x01));


   body.instructions = f2FE2_parent_instructions;
   body.emit(f2FE2);

   /* END IF */

   ir_variable *const r2FFF = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f3000 = new(mem_ctx) ir_if(operand(r2FE1).val);
   exec_list *const f3000_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f3000->then_instructions;

      body.emit(assign(r2FFF, r2FCC, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f3000->else_instructions;

      ir_variable *const r3001 = body.make_temp(glsl_type::uvec2_type, "a");
      body.emit(assign(r3001, body.constant(0u), 0x01));

      body.emit(assign(r3001, body.constant(3220176896u), 0x02));

      ir_variable *const r3002 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r3003 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r3003, rshift(swizzle_y(r2FCC), body.constant(int(31))), 0x01));

      ir_variable *const r3004 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r3004, body.constant(1u), 0x01));

      /* IF CONDITION */
      ir_expression *const r3006 = equal(r3003, body.constant(1u));
      ir_if *f3005 = new(mem_ctx) ir_if(operand(r3006).val);
      exec_list *const f3005_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3005->then_instructions;

         ir_variable *const r3007 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r3007, body.constant(true), 0x01));

         ir_variable *const r3008 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r3009 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r3009);
         ir_variable *const r300A = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r300A);
         ir_variable *const r300B = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r300B);
         ir_variable *const r300C = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r300C);
         ir_variable *const r300D = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r300D);
         ir_variable *const r300E = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r300E);
         ir_variable *const r300F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r300F);
         ir_variable *const r3010 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r3010);
         body.emit(assign(r3010, body.constant(0u), 0x01));

         body.emit(assign(r300F, body.constant(0u), 0x01));

         ir_variable *const r3011 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r3011, swizzle_x(r2FCC), 0x01));

         body.emit(assign(r300D, r3011, 0x01));

         ir_variable *const r3012 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r3012, bit_and(swizzle_y(r2FCC), body.constant(1048575u)), 0x01));

         body.emit(assign(r300C, r3012, 0x01));

         ir_variable *const r3013 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r3013, body.constant(0u), 0x01));

         body.emit(assign(r300B, r3013, 0x01));

         ir_variable *const r3014 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r3014, body.constant(0u), 0x01));

         body.emit(assign(r300A, r3014, 0x01));

         ir_variable *const r3015 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r3016 = rshift(swizzle_y(r2FCC), body.constant(int(20)));
         ir_expression *const r3017 = bit_and(r3016, body.constant(2047u));
         body.emit(assign(r3015, expr(ir_unop_u2i, r3017), 0x01));

         ir_variable *const r3018 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r3018, body.constant(int(1023)), 0x01));

         ir_variable *const r3019 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r3019, add(r3015, body.constant(int(-1023))), 0x01));

         body.emit(assign(r3009, r3019, 0x01));

         /* IF CONDITION */
         ir_expression *const r301B = less(body.constant(int(0)), r3019);
         ir_if *f301A = new(mem_ctx) ir_if(operand(r301B).val);
         exec_list *const f301A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f301A->then_instructions;

            /* IF CONDITION */
            ir_expression *const r301D = equal(r3015, body.constant(int(2047)));
            ir_if *f301C = new(mem_ctx) ir_if(operand(r301D).val);
            exec_list *const f301C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f301C->then_instructions;

               /* IF CONDITION */
               ir_expression *const r301F = bit_or(r3012, swizzle_x(r2FCC));
               ir_expression *const r3020 = nequal(r301F, body.constant(0u));
               ir_if *f301E = new(mem_ctx) ir_if(operand(r3020).val);
               exec_list *const f301E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f301E->then_instructions;

                  ir_variable *const r3021 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r3021, swizzle_x(r2FCC), 0x01));

                  ir_variable *const r3022 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r3022, body.constant(0u), 0x01));

                  ir_variable *const r3023 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3024 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r3025 = rshift(swizzle_y(r2FCC), body.constant(int(19)));
                  ir_expression *const r3026 = bit_and(r3025, body.constant(4095u));
                  ir_expression *const r3027 = equal(r3026, body.constant(4094u));
                  ir_expression *const r3028 = nequal(swizzle_x(r2FCC), body.constant(0u));
                  ir_expression *const r3029 = bit_and(swizzle_y(r2FCC), body.constant(524287u));
                  ir_expression *const r302A = nequal(r3029, body.constant(0u));
                  ir_expression *const r302B = logic_or(r3028, r302A);
                  body.emit(assign(r3024, logic_and(r3027, r302B), 0x01));

                  ir_variable *const r302C = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  body.emit(assign(r302C, body.constant(false), 0x01));

                  body.emit(assign(r3021, bit_or(swizzle_y(r2FCC), body.constant(524288u)), 0x02));

                  body.emit(assign(r3022, body.constant(3220701184u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r302E = lshift(swizzle_y(r2FCC), body.constant(int(1)));
                  ir_expression *const r302F = lequal(body.constant(4292870144u), r302E);
                  ir_expression *const r3030 = nequal(swizzle_x(r2FCC), body.constant(0u));
                  ir_expression *const r3031 = bit_and(swizzle_y(r2FCC), body.constant(1048575u));
                  ir_expression *const r3032 = nequal(r3031, body.constant(0u));
                  ir_expression *const r3033 = logic_or(r3030, r3032);
                  ir_expression *const r3034 = logic_and(r302F, r3033);
                  ir_if *f302D = new(mem_ctx) ir_if(operand(r3034).val);
                  exec_list *const f302D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f302D->then_instructions;

                     ir_variable *const r3035 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_constant *const r3037 = body.constant(false);
                     ir_if *f3036 = new(mem_ctx) ir_if(operand(r3037).val);
                     exec_list *const f3036_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3036->then_instructions;

                        body.emit(assign(r3035, r3022, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3036->else_instructions;

                        body.emit(assign(r3035, r3021, 0x03));


                     body.instructions = f3036_parent_instructions;
                     body.emit(f3036);

                     /* END IF */

                     body.emit(assign(r3023, r3035, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f302D->else_instructions;

                     body.emit(assign(r3023, r3022, 0x03));


                  body.instructions = f302D_parent_instructions;
                  body.emit(f302D);

                  /* END IF */

                  body.emit(assign(r3008, r3023, 0x03));

                  body.emit(assign(r3007, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f301E->else_instructions;

                  body.emit(assign(r3008, r2FCC, 0x03));

                  body.emit(assign(r3007, body.constant(false), 0x01));


               body.instructions = f301E_parent_instructions;
               body.emit(f301E);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f301C->else_instructions;

               /* IF CONDITION */
               ir_constant *const r3039 = body.constant(false);
               ir_if *f3038 = new(mem_ctx) ir_if(operand(r3039).val);
               exec_list *const f3038_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3038->then_instructions;

                  body.emit(assign(r3009, add(r3019, body.constant(int(-1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3038->else_instructions;

                  body.emit(assign(r300A, body.constant(1048576u), 0x01));


               body.instructions = f3038_parent_instructions;
               body.emit(f3038);

               /* END IF */

               ir_variable *const r303A = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r303A, body.constant(0u), 0x01));

               ir_variable *const r303B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r303B);
               ir_variable *const r303C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r303C);
               ir_variable *const r303D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r303D);
               ir_variable *const r303E = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r303F = neg(r3009);
               body.emit(assign(r303E, bit_and(r303F, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3041 = equal(r3009, body.constant(int(0)));
               ir_if *f3040 = new(mem_ctx) ir_if(operand(r3041).val);
               exec_list *const f3040_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3040->then_instructions;

                  body.emit(assign(r303B, r303A, 0x01));

                  body.emit(assign(r303C, r3013, 0x01));

                  body.emit(assign(r303D, r300A, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3040->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3043 = less(r3009, body.constant(int(32)));
                  ir_if *f3042 = new(mem_ctx) ir_if(operand(r3043).val);
                  exec_list *const f3042_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3042->then_instructions;

                     body.emit(assign(r303B, body.constant(0u), 0x01));

                     ir_expression *const r3044 = lshift(r300A, r303E);
                     body.emit(assign(r303C, bit_or(r3044, body.constant(0u)), 0x01));

                     body.emit(assign(r303D, rshift(r300A, r3009), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3042->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3046 = equal(r3009, body.constant(int(32)));
                     ir_if *f3045 = new(mem_ctx) ir_if(operand(r3046).val);
                     exec_list *const f3045_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3045->then_instructions;

                        body.emit(assign(r303B, r3013, 0x01));

                        body.emit(assign(r303C, r300A, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3045->else_instructions;

                        body.emit(assign(r303A, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3048 = less(r3009, body.constant(int(64)));
                        ir_if *f3047 = new(mem_ctx) ir_if(operand(r3048).val);
                        exec_list *const f3047_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3047->then_instructions;

                           body.emit(assign(r303B, lshift(r300A, r303E), 0x01));

                           ir_expression *const r3049 = bit_and(r3009, body.constant(int(31)));
                           body.emit(assign(r303C, rshift(r300A, r3049), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3047->else_instructions;

                           ir_variable *const r304A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r304C = equal(r3009, body.constant(int(64)));
                           ir_if *f304B = new(mem_ctx) ir_if(operand(r304C).val);
                           exec_list *const f304B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f304B->then_instructions;

                              body.emit(assign(r304A, r300A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f304B->else_instructions;

                              ir_expression *const r304D = nequal(r300A, body.constant(0u));
                              ir_expression *const r304E = expr(ir_unop_b2i, r304D);
                              body.emit(assign(r304A, expr(ir_unop_i2u, r304E), 0x01));


                           body.instructions = f304B_parent_instructions;
                           body.emit(f304B);

                           /* END IF */

                           body.emit(assign(r303B, r304A, 0x01));

                           body.emit(assign(r303C, body.constant(0u), 0x01));


                        body.instructions = f3047_parent_instructions;
                        body.emit(f3047);

                        /* END IF */


                     body.instructions = f3045_parent_instructions;
                     body.emit(f3045);

                     /* END IF */

                     body.emit(assign(r303D, body.constant(0u), 0x01));


                  body.instructions = f3042_parent_instructions;
                  body.emit(f3042);

                  /* END IF */

                  ir_expression *const r304F = nequal(r303A, body.constant(0u));
                  ir_expression *const r3050 = expr(ir_unop_b2i, r304F);
                  ir_expression *const r3051 = expr(ir_unop_i2u, r3050);
                  body.emit(assign(r303B, bit_or(r303B, r3051), 0x01));


               body.instructions = f3040_parent_instructions;
               body.emit(f3040);

               /* END IF */

               body.emit(assign(r300A, r303D, 0x01));

               body.emit(assign(r300B, r303C, 0x01));

               body.emit(assign(r300F, r303B, 0x01));

               body.emit(assign(r300E, r3015, 0x01));


            body.instructions = f301C_parent_instructions;
            body.emit(f301C);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f301A->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3053 = less(r3009, body.constant(int(0)));
            ir_if *f3052 = new(mem_ctx) ir_if(operand(r3053).val);
            exec_list *const f3052_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3052->then_instructions;

               /* IF CONDITION */
               ir_constant *const r3055 = body.constant(false);
               ir_if *f3054 = new(mem_ctx) ir_if(operand(r3055).val);
               exec_list *const f3054_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3054->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3057 = bit_or(r300A, r300B);
                  ir_expression *const r3058 = nequal(r3057, body.constant(0u));
                  ir_if *f3056 = new(mem_ctx) ir_if(operand(r3058).val);
                  exec_list *const f3056_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3056->then_instructions;

                     ir_variable *const r3059 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r3059, swizzle_x(r2FCC), 0x01));

                     ir_variable *const r305A = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r305A, body.constant(0u), 0x01));

                     ir_variable *const r305B = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r305C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r305D = rshift(swizzle_y(r2FCC), body.constant(int(19)));
                     ir_expression *const r305E = bit_and(r305D, body.constant(4095u));
                     ir_expression *const r305F = equal(r305E, body.constant(4094u));
                     ir_expression *const r3060 = nequal(swizzle_x(r2FCC), body.constant(0u));
                     ir_expression *const r3061 = bit_and(swizzle_y(r2FCC), body.constant(524287u));
                     ir_expression *const r3062 = nequal(r3061, body.constant(0u));
                     ir_expression *const r3063 = logic_or(r3060, r3062);
                     body.emit(assign(r305C, logic_and(r305F, r3063), 0x01));

                     ir_variable *const r3064 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r3064, body.constant(false), 0x01));

                     body.emit(assign(r3059, bit_or(swizzle_y(r2FCC), body.constant(524288u)), 0x02));

                     body.emit(assign(r305A, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r3066 = lshift(swizzle_y(r2FCC), body.constant(int(1)));
                     ir_expression *const r3067 = lequal(body.constant(4292870144u), r3066);
                     ir_expression *const r3068 = nequal(swizzle_x(r2FCC), body.constant(0u));
                     ir_expression *const r3069 = bit_and(swizzle_y(r2FCC), body.constant(1048575u));
                     ir_expression *const r306A = nequal(r3069, body.constant(0u));
                     ir_expression *const r306B = logic_or(r3068, r306A);
                     ir_expression *const r306C = logic_and(r3067, r306B);
                     ir_if *f3065 = new(mem_ctx) ir_if(operand(r306C).val);
                     exec_list *const f3065_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3065->then_instructions;

                        ir_variable *const r306D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r306F = body.constant(false);
                        ir_if *f306E = new(mem_ctx) ir_if(operand(r306F).val);
                        exec_list *const f306E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f306E->then_instructions;

                           body.emit(assign(r306D, r305A, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f306E->else_instructions;

                           body.emit(assign(r306D, r3059, 0x03));


                        body.instructions = f306E_parent_instructions;
                        body.emit(f306E);

                        /* END IF */

                        body.emit(assign(r305B, r306D, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3065->else_instructions;

                        body.emit(assign(r305B, r305A, 0x03));


                     body.instructions = f3065_parent_instructions;
                     body.emit(f3065);

                     /* END IF */

                     body.emit(assign(r3008, r305B, 0x03));

                     body.emit(assign(r3007, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3056->else_instructions;

                     ir_variable *const r3070 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3070);
                     ir_expression *const r3071 = lshift(r3003, body.constant(int(31)));
                     body.emit(assign(r3070, add(r3071, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3070, body.constant(0u), 0x01));

                     body.emit(assign(r3008, r3070, 0x03));

                     body.emit(assign(r3007, body.constant(false), 0x01));


                  body.instructions = f3056_parent_instructions;
                  body.emit(f3056);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3054->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3073 = equal(r3015, body.constant(int(0)));
                  ir_if *f3072 = new(mem_ctx) ir_if(operand(r3073).val);
                  exec_list *const f3072_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3072->then_instructions;

                     body.emit(assign(r3009, add(r3009, body.constant(int(1))), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3072->else_instructions;

                     body.emit(assign(r300C, bit_or(r3012, body.constant(1048576u)), 0x01));


                  body.instructions = f3072_parent_instructions;
                  body.emit(f3072);

                  /* END IF */

                  ir_variable *const r3074 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r3074, body.constant(0u), 0x01));

                  ir_variable *const r3075 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r3075, neg(r3009), 0x01));

                  ir_variable *const r3076 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r3076);
                  ir_variable *const r3077 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3077);
                  ir_variable *const r3078 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r3078);
                  ir_variable *const r3079 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r307A = neg(r3075);
                  body.emit(assign(r3079, bit_and(r307A, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r307C = equal(r3075, body.constant(int(0)));
                  ir_if *f307B = new(mem_ctx) ir_if(operand(r307C).val);
                  exec_list *const f307B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f307B->then_instructions;

                     body.emit(assign(r3076, r3074, 0x01));

                     body.emit(assign(r3077, r3011, 0x01));

                     body.emit(assign(r3078, r300C, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f307B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r307E = less(r3075, body.constant(int(32)));
                     ir_if *f307D = new(mem_ctx) ir_if(operand(r307E).val);
                     exec_list *const f307D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f307D->then_instructions;

                        body.emit(assign(r3076, lshift(swizzle_x(r2FCC), r3079), 0x01));

                        ir_expression *const r307F = lshift(r300C, r3079);
                        ir_expression *const r3080 = rshift(swizzle_x(r2FCC), r3075);
                        body.emit(assign(r3077, bit_or(r307F, r3080), 0x01));

                        body.emit(assign(r3078, rshift(r300C, r3075), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f307D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3082 = equal(r3075, body.constant(int(32)));
                        ir_if *f3081 = new(mem_ctx) ir_if(operand(r3082).val);
                        exec_list *const f3081_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3081->then_instructions;

                           body.emit(assign(r3076, r3011, 0x01));

                           body.emit(assign(r3077, r300C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3081->else_instructions;

                           body.emit(assign(r3074, bit_or(body.constant(0u), swizzle_x(r2FCC)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3084 = less(r3075, body.constant(int(64)));
                           ir_if *f3083 = new(mem_ctx) ir_if(operand(r3084).val);
                           exec_list *const f3083_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3083->then_instructions;

                              body.emit(assign(r3076, lshift(r300C, r3079), 0x01));

                              ir_expression *const r3085 = bit_and(r3075, body.constant(int(31)));
                              body.emit(assign(r3077, rshift(r300C, r3085), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3083->else_instructions;

                              ir_variable *const r3086 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3088 = equal(r3075, body.constant(int(64)));
                              ir_if *f3087 = new(mem_ctx) ir_if(operand(r3088).val);
                              exec_list *const f3087_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3087->then_instructions;

                                 body.emit(assign(r3086, r300C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3087->else_instructions;

                                 ir_expression *const r3089 = nequal(r300C, body.constant(0u));
                                 ir_expression *const r308A = expr(ir_unop_b2i, r3089);
                                 body.emit(assign(r3086, expr(ir_unop_i2u, r308A), 0x01));


                              body.instructions = f3087_parent_instructions;
                              body.emit(f3087);

                              /* END IF */

                              body.emit(assign(r3076, r3086, 0x01));

                              body.emit(assign(r3077, body.constant(0u), 0x01));


                           body.instructions = f3083_parent_instructions;
                           body.emit(f3083);

                           /* END IF */


                        body.instructions = f3081_parent_instructions;
                        body.emit(f3081);

                        /* END IF */

                        body.emit(assign(r3078, body.constant(0u), 0x01));


                     body.instructions = f307D_parent_instructions;
                     body.emit(f307D);

                     /* END IF */

                     ir_expression *const r308B = nequal(r3074, body.constant(0u));
                     ir_expression *const r308C = expr(ir_unop_b2i, r308B);
                     ir_expression *const r308D = expr(ir_unop_i2u, r308C);
                     body.emit(assign(r3076, bit_or(r3076, r308D), 0x01));


                  body.instructions = f307B_parent_instructions;
                  body.emit(f307B);

                  /* END IF */

                  body.emit(assign(r300C, r3078, 0x01));

                  body.emit(assign(r300D, r3077, 0x01));

                  body.emit(assign(r300F, r3076, 0x01));

                  body.emit(assign(r300E, r3018, 0x01));


               body.instructions = f3054_parent_instructions;
               body.emit(f3054);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3052->else_instructions;

               /* IF CONDITION */
               ir_expression *const r308F = equal(r3015, body.constant(int(2047)));
               ir_if *f308E = new(mem_ctx) ir_if(operand(r308F).val);
               exec_list *const f308E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f308E->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3091 = bit_or(r300C, r300D);
                  ir_expression *const r3092 = bit_or(r300A, r300B);
                  ir_expression *const r3093 = bit_or(r3091, r3092);
                  ir_expression *const r3094 = nequal(r3093, body.constant(0u));
                  ir_if *f3090 = new(mem_ctx) ir_if(operand(r3094).val);
                  exec_list *const f3090_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3090->then_instructions;

                     ir_variable *const r3095 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r3095, swizzle_x(r2FCC), 0x01));

                     ir_variable *const r3096 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r3096, body.constant(0u), 0x01));

                     ir_variable *const r3097 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r3098 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r3099 = rshift(swizzle_y(r2FCC), body.constant(int(19)));
                     ir_expression *const r309A = bit_and(r3099, body.constant(4095u));
                     ir_expression *const r309B = equal(r309A, body.constant(4094u));
                     ir_expression *const r309C = nequal(swizzle_x(r2FCC), body.constant(0u));
                     ir_expression *const r309D = bit_and(swizzle_y(r2FCC), body.constant(524287u));
                     ir_expression *const r309E = nequal(r309D, body.constant(0u));
                     ir_expression *const r309F = logic_or(r309C, r309E);
                     body.emit(assign(r3098, logic_and(r309B, r309F), 0x01));

                     ir_variable *const r30A0 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r30A0, body.constant(false), 0x01));

                     body.emit(assign(r3095, bit_or(swizzle_y(r2FCC), body.constant(524288u)), 0x02));

                     body.emit(assign(r3096, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r30A2 = lshift(swizzle_y(r2FCC), body.constant(int(1)));
                     ir_expression *const r30A3 = lequal(body.constant(4292870144u), r30A2);
                     ir_expression *const r30A4 = nequal(swizzle_x(r2FCC), body.constant(0u));
                     ir_expression *const r30A5 = bit_and(swizzle_y(r2FCC), body.constant(1048575u));
                     ir_expression *const r30A6 = nequal(r30A5, body.constant(0u));
                     ir_expression *const r30A7 = logic_or(r30A4, r30A6);
                     ir_expression *const r30A8 = logic_and(r30A3, r30A7);
                     ir_if *f30A1 = new(mem_ctx) ir_if(operand(r30A8).val);
                     exec_list *const f30A1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f30A1->then_instructions;

                        ir_variable *const r30A9 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r30AB = body.constant(false);
                        ir_if *f30AA = new(mem_ctx) ir_if(operand(r30AB).val);
                        exec_list *const f30AA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30AA->then_instructions;

                           body.emit(assign(r30A9, r3096, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f30AA->else_instructions;

                           body.emit(assign(r30A9, r3095, 0x03));


                        body.instructions = f30AA_parent_instructions;
                        body.emit(f30AA);

                        /* END IF */

                        body.emit(assign(r3097, r30A9, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f30A1->else_instructions;

                        body.emit(assign(r3097, r3096, 0x03));


                     body.instructions = f30A1_parent_instructions;
                     body.emit(f30A1);

                     /* END IF */

                     body.emit(assign(r3008, r3097, 0x03));

                     body.emit(assign(r3007, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3090->else_instructions;

                     body.emit(assign(r3008, r2FCC, 0x03));

                     body.emit(assign(r3007, body.constant(false), 0x01));


                  body.instructions = f3090_parent_instructions;
                  body.emit(f3090);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f308E->else_instructions;

                  ir_variable *const r30AC = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r30AD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r30AD, add(r300D, r300B), 0x01));

                  ir_expression *const r30AE = add(r300C, r300A);
                  ir_expression *const r30AF = less(r30AD, r300D);
                  ir_expression *const r30B0 = expr(ir_unop_b2i, r30AF);
                  ir_expression *const r30B1 = expr(ir_unop_i2u, r30B0);
                  body.emit(assign(r30AC, add(r30AE, r30B1), 0x01));

                  body.emit(assign(r3010, r30AC, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r30B3 = equal(r3015, body.constant(int(0)));
                  ir_if *f30B2 = new(mem_ctx) ir_if(operand(r30B3).val);
                  exec_list *const f30B2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f30B2->then_instructions;

                     ir_variable *const r30B4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r30B4);
                     ir_expression *const r30B5 = lshift(r3003, body.constant(int(31)));
                     body.emit(assign(r30B4, add(r30B5, r30AC), 0x02));

                     body.emit(assign(r30B4, r30AD, 0x01));

                     body.emit(assign(r3008, r30B4, 0x03));

                     body.emit(assign(r3007, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f30B2->else_instructions;

                     body.emit(assign(r3010, bit_or(r30AC, body.constant(2097152u)), 0x01));

                     body.emit(assign(r300E, r3015, 0x01));

                     ir_variable *const r30B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r30B6);
                     ir_variable *const r30B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r30B7);
                     ir_variable *const r30B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r30B8);
                     body.emit(assign(r30B6, lshift(r30AD, body.constant(int(31))), 0x01));

                     ir_expression *const r30B9 = lshift(r3010, body.constant(int(31)));
                     ir_expression *const r30BA = rshift(r30AD, body.constant(int(1)));
                     body.emit(assign(r30B7, bit_or(r30B9, r30BA), 0x01));

                     body.emit(assign(r30B8, rshift(r3010, body.constant(int(1))), 0x01));

                     body.emit(assign(r30B6, bit_or(r30B6, body.constant(0u)), 0x01));

                     body.emit(assign(r3010, r30B8, 0x01));

                     body.emit(assign(r300F, r30B6, 0x01));

                     ir_variable *const r30BB = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r30BB, r3015, 0x01));

                     ir_variable *const r30BC = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r30BC, r30B8, 0x01));

                     ir_variable *const r30BD = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r30BD, r30B7, 0x01));

                     ir_variable *const r30BE = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r30BE, r30B6, 0x01));

                     ir_variable *const r30BF = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r30BF, body.constant(true), 0x01));

                     ir_variable *const r30C0 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r30C1 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r30C1);
                     ir_expression *const r30C2 = expr(ir_unop_u2i, r30B6);
                     body.emit(assign(r30C1, less(r30C2, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r30C4 = lequal(body.constant(int(2045)), r3015);
                     ir_if *f30C3 = new(mem_ctx) ir_if(operand(r30C4).val);
                     exec_list *const f30C3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f30C3->then_instructions;

                        ir_variable *const r30C5 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r30C7 = less(body.constant(int(2045)), r3015);
                        ir_if *f30C6 = new(mem_ctx) ir_if(operand(r30C7).val);
                        exec_list *const f30C6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30C6->then_instructions;

                           body.emit(assign(r30C5, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f30C6->else_instructions;

                           ir_variable *const r30C8 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r30CA = equal(r3015, body.constant(int(2045)));
                           ir_if *f30C9 = new(mem_ctx) ir_if(operand(r30CA).val);
                           exec_list *const f30C9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f30C9->then_instructions;

                              ir_expression *const r30CB = equal(body.constant(2097151u), r30B8);
                              ir_expression *const r30CC = equal(body.constant(4294967295u), r30B7);
                              body.emit(assign(r30C8, logic_and(r30CB, r30CC), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f30C9->else_instructions;

                              body.emit(assign(r30C8, body.constant(false), 0x01));


                           body.instructions = f30C9_parent_instructions;
                           body.emit(f30C9);

                           /* END IF */

                           body.emit(assign(r30C5, logic_and(r30C8, r30C1), 0x01));


                        body.instructions = f30C6_parent_instructions;
                        body.emit(f30C6);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f30CD = new(mem_ctx) ir_if(operand(r30C5).val);
                        exec_list *const f30CD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30CD->then_instructions;

                           ir_variable *const r30CE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r30CE);
                           ir_expression *const r30CF = lshift(r3003, body.constant(int(31)));
                           body.emit(assign(r30CE, add(r30CF, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r30CE, body.constant(0u), 0x01));

                           body.emit(assign(r30C0, r30CE, 0x03));

                           body.emit(assign(r30BF, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f30CD->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r30D1 = less(r3015, body.constant(int(0)));
                           ir_if *f30D0 = new(mem_ctx) ir_if(operand(r30D1).val);
                           exec_list *const f30D0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f30D0->then_instructions;

                              ir_variable *const r30D2 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r30D2, r30B6, 0x01));

                              ir_variable *const r30D3 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r30D3, neg(r3015), 0x01));

                              ir_variable *const r30D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r30D4);
                              ir_variable *const r30D5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r30D5);
                              ir_variable *const r30D6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r30D6);
                              ir_variable *const r30D7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r30D8 = neg(r30D3);
                              body.emit(assign(r30D7, bit_and(r30D8, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r30DA = equal(r30D3, body.constant(int(0)));
                              ir_if *f30D9 = new(mem_ctx) ir_if(operand(r30DA).val);
                              exec_list *const f30D9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f30D9->then_instructions;

                                 body.emit(assign(r30D4, r30B6, 0x01));

                                 body.emit(assign(r30D5, r30B7, 0x01));

                                 body.emit(assign(r30D6, r30B8, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f30D9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r30DC = less(r30D3, body.constant(int(32)));
                                 ir_if *f30DB = new(mem_ctx) ir_if(operand(r30DC).val);
                                 exec_list *const f30DB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f30DB->then_instructions;

                                    body.emit(assign(r30D4, lshift(r30B7, r30D7), 0x01));

                                    ir_expression *const r30DD = lshift(r30B8, r30D7);
                                    ir_expression *const r30DE = rshift(r30B7, r30D3);
                                    body.emit(assign(r30D5, bit_or(r30DD, r30DE), 0x01));

                                    body.emit(assign(r30D6, rshift(r30B8, r30D3), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f30DB->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r30E0 = equal(r30D3, body.constant(int(32)));
                                    ir_if *f30DF = new(mem_ctx) ir_if(operand(r30E0).val);
                                    exec_list *const f30DF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f30DF->then_instructions;

                                       body.emit(assign(r30D4, r30B7, 0x01));

                                       body.emit(assign(r30D5, r30B8, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f30DF->else_instructions;

                                       body.emit(assign(r30D2, bit_or(r30B6, r30B7), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r30E2 = less(r30D3, body.constant(int(64)));
                                       ir_if *f30E1 = new(mem_ctx) ir_if(operand(r30E2).val);
                                       exec_list *const f30E1_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f30E1->then_instructions;

                                          body.emit(assign(r30D4, lshift(r30B8, r30D7), 0x01));

                                          ir_expression *const r30E3 = bit_and(r30D3, body.constant(int(31)));
                                          body.emit(assign(r30D5, rshift(r30B8, r30E3), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f30E1->else_instructions;

                                          ir_variable *const r30E4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r30E6 = equal(r30D3, body.constant(int(64)));
                                          ir_if *f30E5 = new(mem_ctx) ir_if(operand(r30E6).val);
                                          exec_list *const f30E5_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f30E5->then_instructions;

                                             body.emit(assign(r30E4, r30B8, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f30E5->else_instructions;

                                             ir_expression *const r30E7 = nequal(r30B8, body.constant(0u));
                                             ir_expression *const r30E8 = expr(ir_unop_b2i, r30E7);
                                             body.emit(assign(r30E4, expr(ir_unop_i2u, r30E8), 0x01));


                                          body.instructions = f30E5_parent_instructions;
                                          body.emit(f30E5);

                                          /* END IF */

                                          body.emit(assign(r30D4, r30E4, 0x01));

                                          body.emit(assign(r30D5, body.constant(0u), 0x01));


                                       body.instructions = f30E1_parent_instructions;
                                       body.emit(f30E1);

                                       /* END IF */


                                    body.instructions = f30DF_parent_instructions;
                                    body.emit(f30DF);

                                    /* END IF */

                                    body.emit(assign(r30D6, body.constant(0u), 0x01));


                                 body.instructions = f30DB_parent_instructions;
                                 body.emit(f30DB);

                                 /* END IF */

                                 ir_expression *const r30E9 = nequal(r30D2, body.constant(0u));
                                 ir_expression *const r30EA = expr(ir_unop_b2i, r30E9);
                                 ir_expression *const r30EB = expr(ir_unop_i2u, r30EA);
                                 body.emit(assign(r30D4, bit_or(r30D4, r30EB), 0x01));


                              body.instructions = f30D9_parent_instructions;
                              body.emit(f30D9);

                              /* END IF */

                              body.emit(assign(r30BC, r30D6, 0x01));

                              body.emit(assign(r30BD, r30D5, 0x01));

                              body.emit(assign(r30BE, r30D4, 0x01));

                              body.emit(assign(r30BB, body.constant(int(0)), 0x01));

                              body.emit(assign(r30C1, less(r30D4, body.constant(0u)), 0x01));


                           body.instructions = f30D0_parent_instructions;
                           body.emit(f30D0);

                           /* END IF */


                        body.instructions = f30CD_parent_instructions;
                        body.emit(f30CD);

                        /* END IF */


                     body.instructions = f30C3_parent_instructions;
                     body.emit(f30C3);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f30EC = new(mem_ctx) ir_if(operand(r30BF).val);
                     exec_list *const f30EC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f30EC->then_instructions;

                        /* IF CONDITION */
                        ir_if *f30ED = new(mem_ctx) ir_if(operand(r30C1).val);
                        exec_list *const f30ED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30ED->then_instructions;

                           ir_variable *const r30EE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r30EE, add(r30BD, body.constant(1u)), 0x01));

                           ir_expression *const r30EF = less(r30EE, r30BD);
                           ir_expression *const r30F0 = expr(ir_unop_b2i, r30EF);
                           ir_expression *const r30F1 = expr(ir_unop_i2u, r30F0);
                           body.emit(assign(r30BC, add(r30BC, r30F1), 0x01));

                           ir_expression *const r30F2 = equal(r30BE, body.constant(0u));
                           ir_expression *const r30F3 = expr(ir_unop_b2i, r30F2);
                           ir_expression *const r30F4 = expr(ir_unop_i2u, r30F3);
                           ir_expression *const r30F5 = add(r30BE, r30F4);
                           ir_expression *const r30F6 = bit_and(r30F5, body.constant(1u));
                           ir_expression *const r30F7 = expr(ir_unop_bit_not, r30F6);
                           body.emit(assign(r30BD, bit_and(r30EE, r30F7), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f30ED->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r30F9 = bit_or(r30BC, r30BD);
                           ir_expression *const r30FA = equal(r30F9, body.constant(0u));
                           ir_if *f30F8 = new(mem_ctx) ir_if(operand(r30FA).val);
                           exec_list *const f30F8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f30F8->then_instructions;

                              body.emit(assign(r30BB, body.constant(int(0)), 0x01));


                           body.instructions = f30F8_parent_instructions;
                           body.emit(f30F8);

                           /* END IF */


                        body.instructions = f30ED_parent_instructions;
                        body.emit(f30ED);

                        /* END IF */

                        ir_variable *const r30FB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r30FB);
                        ir_expression *const r30FC = lshift(r3003, body.constant(int(31)));
                        ir_expression *const r30FD = expr(ir_unop_i2u, r30BB);
                        ir_expression *const r30FE = lshift(r30FD, body.constant(int(20)));
                        ir_expression *const r30FF = add(r30FC, r30FE);
                        body.emit(assign(r30FB, add(r30FF, r30BC), 0x02));

                        body.emit(assign(r30FB, r30BD, 0x01));

                        body.emit(assign(r30C0, r30FB, 0x03));

                        body.emit(assign(r30BF, body.constant(false), 0x01));


                     body.instructions = f30EC_parent_instructions;
                     body.emit(f30EC);

                     /* END IF */

                     body.emit(assign(r3008, r30C0, 0x03));

                     body.emit(assign(r3007, body.constant(false), 0x01));


                  body.instructions = f30B2_parent_instructions;
                  body.emit(f30B2);

                  /* END IF */


               body.instructions = f308E_parent_instructions;
               body.emit(f308E);

               /* END IF */


            body.instructions = f3052_parent_instructions;
            body.emit(f3052);

            /* END IF */


         body.instructions = f301A_parent_instructions;
         body.emit(f301A);

         /* END IF */

         /* IF CONDITION */
         ir_if *f3100 = new(mem_ctx) ir_if(operand(r3007).val);
         exec_list *const f3100_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3100->then_instructions;

            body.emit(assign(r300C, bit_or(r300C, body.constant(1048576u)), 0x01));

            ir_variable *const r3101 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r3102 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r3102, add(r300D, r300B), 0x01));

            ir_expression *const r3103 = add(r300C, r300A);
            ir_expression *const r3104 = less(r3102, r300D);
            ir_expression *const r3105 = expr(ir_unop_b2i, r3104);
            ir_expression *const r3106 = expr(ir_unop_i2u, r3105);
            body.emit(assign(r3101, add(r3103, r3106), 0x01));

            body.emit(assign(r3010, r3101, 0x01));

            body.emit(assign(r300E, add(r300E, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3108 = less(r3101, body.constant(2097152u));
            ir_if *f3107 = new(mem_ctx) ir_if(operand(r3108).val);
            exec_list *const f3107_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3107->then_instructions;

               ir_variable *const r3109 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3109, r300E, 0x01));

               ir_variable *const r310A = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r310A, r3101, 0x01));

               ir_variable *const r310B = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r310B, r3102, 0x01));

               ir_variable *const r310C = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r310C, r300F, 0x01));

               ir_variable *const r310D = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r310D, body.constant(true), 0x01));

               ir_variable *const r310E = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r310F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r310F);
               ir_expression *const r3110 = expr(ir_unop_u2i, r300F);
               body.emit(assign(r310F, less(r3110, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3112 = lequal(body.constant(int(2045)), r300E);
               ir_if *f3111 = new(mem_ctx) ir_if(operand(r3112).val);
               exec_list *const f3111_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3111->then_instructions;

                  ir_variable *const r3113 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3115 = less(body.constant(int(2045)), r300E);
                  ir_if *f3114 = new(mem_ctx) ir_if(operand(r3115).val);
                  exec_list *const f3114_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3114->then_instructions;

                     body.emit(assign(r3113, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3114->else_instructions;

                     ir_variable *const r3116 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3118 = equal(r300E, body.constant(int(2045)));
                     ir_if *f3117 = new(mem_ctx) ir_if(operand(r3118).val);
                     exec_list *const f3117_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3117->then_instructions;

                        ir_expression *const r3119 = equal(body.constant(2097151u), r3101);
                        ir_expression *const r311A = equal(body.constant(4294967295u), r3102);
                        body.emit(assign(r3116, logic_and(r3119, r311A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3117->else_instructions;

                        body.emit(assign(r3116, body.constant(false), 0x01));


                     body.instructions = f3117_parent_instructions;
                     body.emit(f3117);

                     /* END IF */

                     body.emit(assign(r3113, logic_and(r3116, r310F), 0x01));


                  body.instructions = f3114_parent_instructions;
                  body.emit(f3114);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f311B = new(mem_ctx) ir_if(operand(r3113).val);
                  exec_list *const f311B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f311B->then_instructions;

                     ir_variable *const r311C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r311C);
                     ir_expression *const r311D = lshift(r3003, body.constant(int(31)));
                     body.emit(assign(r311C, add(r311D, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r311C, body.constant(0u), 0x01));

                     body.emit(assign(r310E, r311C, 0x03));

                     body.emit(assign(r310D, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f311B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r311F = less(r300E, body.constant(int(0)));
                     ir_if *f311E = new(mem_ctx) ir_if(operand(r311F).val);
                     exec_list *const f311E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f311E->then_instructions;

                        ir_variable *const r3120 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3120, r300F, 0x01));

                        ir_variable *const r3121 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3121, neg(r300E), 0x01));

                        ir_variable *const r3122 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3122);
                        ir_variable *const r3123 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3123);
                        ir_variable *const r3124 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3124);
                        ir_variable *const r3125 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3126 = neg(r3121);
                        body.emit(assign(r3125, bit_and(r3126, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3128 = equal(r3121, body.constant(int(0)));
                        ir_if *f3127 = new(mem_ctx) ir_if(operand(r3128).val);
                        exec_list *const f3127_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3127->then_instructions;

                           body.emit(assign(r3122, r300F, 0x01));

                           body.emit(assign(r3123, r3102, 0x01));

                           body.emit(assign(r3124, r3101, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3127->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r312A = less(r3121, body.constant(int(32)));
                           ir_if *f3129 = new(mem_ctx) ir_if(operand(r312A).val);
                           exec_list *const f3129_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3129->then_instructions;

                              body.emit(assign(r3122, lshift(r3102, r3125), 0x01));

                              ir_expression *const r312B = lshift(r3101, r3125);
                              ir_expression *const r312C = rshift(r3102, r3121);
                              body.emit(assign(r3123, bit_or(r312B, r312C), 0x01));

                              body.emit(assign(r3124, rshift(r3101, r3121), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3129->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r312E = equal(r3121, body.constant(int(32)));
                              ir_if *f312D = new(mem_ctx) ir_if(operand(r312E).val);
                              exec_list *const f312D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f312D->then_instructions;

                                 body.emit(assign(r3122, r3102, 0x01));

                                 body.emit(assign(r3123, r3101, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f312D->else_instructions;

                                 body.emit(assign(r3120, bit_or(r300F, r3102), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3130 = less(r3121, body.constant(int(64)));
                                 ir_if *f312F = new(mem_ctx) ir_if(operand(r3130).val);
                                 exec_list *const f312F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f312F->then_instructions;

                                    body.emit(assign(r3122, lshift(r3101, r3125), 0x01));

                                    ir_expression *const r3131 = bit_and(r3121, body.constant(int(31)));
                                    body.emit(assign(r3123, rshift(r3101, r3131), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f312F->else_instructions;

                                    ir_variable *const r3132 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3134 = equal(r3121, body.constant(int(64)));
                                    ir_if *f3133 = new(mem_ctx) ir_if(operand(r3134).val);
                                    exec_list *const f3133_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3133->then_instructions;

                                       body.emit(assign(r3132, r3101, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3133->else_instructions;

                                       ir_expression *const r3135 = nequal(r3101, body.constant(0u));
                                       ir_expression *const r3136 = expr(ir_unop_b2i, r3135);
                                       body.emit(assign(r3132, expr(ir_unop_i2u, r3136), 0x01));


                                    body.instructions = f3133_parent_instructions;
                                    body.emit(f3133);

                                    /* END IF */

                                    body.emit(assign(r3122, r3132, 0x01));

                                    body.emit(assign(r3123, body.constant(0u), 0x01));


                                 body.instructions = f312F_parent_instructions;
                                 body.emit(f312F);

                                 /* END IF */


                              body.instructions = f312D_parent_instructions;
                              body.emit(f312D);

                              /* END IF */

                              body.emit(assign(r3124, body.constant(0u), 0x01));


                           body.instructions = f3129_parent_instructions;
                           body.emit(f3129);

                           /* END IF */

                           ir_expression *const r3137 = nequal(r3120, body.constant(0u));
                           ir_expression *const r3138 = expr(ir_unop_b2i, r3137);
                           ir_expression *const r3139 = expr(ir_unop_i2u, r3138);
                           body.emit(assign(r3122, bit_or(r3122, r3139), 0x01));


                        body.instructions = f3127_parent_instructions;
                        body.emit(f3127);

                        /* END IF */

                        body.emit(assign(r310A, r3124, 0x01));

                        body.emit(assign(r310B, r3123, 0x01));

                        body.emit(assign(r310C, r3122, 0x01));

                        body.emit(assign(r3109, body.constant(int(0)), 0x01));

                        body.emit(assign(r310F, less(r3122, body.constant(0u)), 0x01));


                     body.instructions = f311E_parent_instructions;
                     body.emit(f311E);

                     /* END IF */


                  body.instructions = f311B_parent_instructions;
                  body.emit(f311B);

                  /* END IF */


               body.instructions = f3111_parent_instructions;
               body.emit(f3111);

               /* END IF */

               /* IF CONDITION */
               ir_if *f313A = new(mem_ctx) ir_if(operand(r310D).val);
               exec_list *const f313A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f313A->then_instructions;

                  /* IF CONDITION */
                  ir_if *f313B = new(mem_ctx) ir_if(operand(r310F).val);
                  exec_list *const f313B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f313B->then_instructions;

                     ir_variable *const r313C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r313C, add(r310B, body.constant(1u)), 0x01));

                     ir_expression *const r313D = less(r313C, r310B);
                     ir_expression *const r313E = expr(ir_unop_b2i, r313D);
                     ir_expression *const r313F = expr(ir_unop_i2u, r313E);
                     body.emit(assign(r310A, add(r310A, r313F), 0x01));

                     ir_expression *const r3140 = equal(r310C, body.constant(0u));
                     ir_expression *const r3141 = expr(ir_unop_b2i, r3140);
                     ir_expression *const r3142 = expr(ir_unop_i2u, r3141);
                     ir_expression *const r3143 = add(r310C, r3142);
                     ir_expression *const r3144 = bit_and(r3143, body.constant(1u));
                     ir_expression *const r3145 = expr(ir_unop_bit_not, r3144);
                     body.emit(assign(r310B, bit_and(r313C, r3145), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f313B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3147 = bit_or(r310A, r310B);
                     ir_expression *const r3148 = equal(r3147, body.constant(0u));
                     ir_if *f3146 = new(mem_ctx) ir_if(operand(r3148).val);
                     exec_list *const f3146_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3146->then_instructions;

                        body.emit(assign(r3109, body.constant(int(0)), 0x01));


                     body.instructions = f3146_parent_instructions;
                     body.emit(f3146);

                     /* END IF */


                  body.instructions = f313B_parent_instructions;
                  body.emit(f313B);

                  /* END IF */

                  ir_variable *const r3149 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3149);
                  ir_expression *const r314A = lshift(r3003, body.constant(int(31)));
                  ir_expression *const r314B = expr(ir_unop_i2u, r3109);
                  ir_expression *const r314C = lshift(r314B, body.constant(int(20)));
                  ir_expression *const r314D = add(r314A, r314C);
                  body.emit(assign(r3149, add(r314D, r310A), 0x02));

                  body.emit(assign(r3149, r310B, 0x01));

                  body.emit(assign(r310E, r3149, 0x03));

                  body.emit(assign(r310D, body.constant(false), 0x01));


               body.instructions = f313A_parent_instructions;
               body.emit(f313A);

               /* END IF */

               body.emit(assign(r3008, r310E, 0x03));

               body.emit(assign(r3007, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3107->else_instructions;

               body.emit(assign(r300E, add(r300E, body.constant(int(1))), 0x01));

               ir_variable *const r314E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r314E);
               ir_variable *const r314F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r314F);
               ir_variable *const r3150 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3150);
               body.emit(assign(r314E, lshift(r3102, body.constant(int(31))), 0x01));

               ir_expression *const r3151 = lshift(r3101, body.constant(int(31)));
               ir_expression *const r3152 = rshift(r3102, body.constant(int(1)));
               body.emit(assign(r314F, bit_or(r3151, r3152), 0x01));

               body.emit(assign(r3150, rshift(r3101, body.constant(int(1))), 0x01));

               ir_expression *const r3153 = nequal(r300F, body.constant(0u));
               ir_expression *const r3154 = expr(ir_unop_b2i, r3153);
               ir_expression *const r3155 = expr(ir_unop_i2u, r3154);
               body.emit(assign(r314E, bit_or(r314E, r3155), 0x01));

               body.emit(assign(r3010, r3150, 0x01));

               body.emit(assign(r300F, r314E, 0x01));

               ir_variable *const r3156 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3156, r300E, 0x01));

               ir_variable *const r3157 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3157, r3150, 0x01));

               ir_variable *const r3158 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3158, r314F, 0x01));

               ir_variable *const r3159 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3159, r314E, 0x01));

               ir_variable *const r315A = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r315A, body.constant(true), 0x01));

               ir_variable *const r315B = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r315C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r315C);
               ir_expression *const r315D = expr(ir_unop_u2i, r314E);
               body.emit(assign(r315C, less(r315D, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r315F = lequal(body.constant(int(2045)), r300E);
               ir_if *f315E = new(mem_ctx) ir_if(operand(r315F).val);
               exec_list *const f315E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f315E->then_instructions;

                  ir_variable *const r3160 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3162 = less(body.constant(int(2045)), r300E);
                  ir_if *f3161 = new(mem_ctx) ir_if(operand(r3162).val);
                  exec_list *const f3161_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3161->then_instructions;

                     body.emit(assign(r3160, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3161->else_instructions;

                     ir_variable *const r3163 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3165 = equal(r300E, body.constant(int(2045)));
                     ir_if *f3164 = new(mem_ctx) ir_if(operand(r3165).val);
                     exec_list *const f3164_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3164->then_instructions;

                        ir_expression *const r3166 = equal(body.constant(2097151u), r3150);
                        ir_expression *const r3167 = equal(body.constant(4294967295u), r314F);
                        body.emit(assign(r3163, logic_and(r3166, r3167), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3164->else_instructions;

                        body.emit(assign(r3163, body.constant(false), 0x01));


                     body.instructions = f3164_parent_instructions;
                     body.emit(f3164);

                     /* END IF */

                     body.emit(assign(r3160, logic_and(r3163, r315C), 0x01));


                  body.instructions = f3161_parent_instructions;
                  body.emit(f3161);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3168 = new(mem_ctx) ir_if(operand(r3160).val);
                  exec_list *const f3168_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3168->then_instructions;

                     ir_variable *const r3169 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3169);
                     ir_expression *const r316A = lshift(r3003, body.constant(int(31)));
                     body.emit(assign(r3169, add(r316A, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3169, body.constant(0u), 0x01));

                     body.emit(assign(r315B, r3169, 0x03));

                     body.emit(assign(r315A, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3168->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r316C = less(r300E, body.constant(int(0)));
                     ir_if *f316B = new(mem_ctx) ir_if(operand(r316C).val);
                     exec_list *const f316B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f316B->then_instructions;

                        ir_variable *const r316D = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r316D, r314E, 0x01));

                        ir_variable *const r316E = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r316E, neg(r300E), 0x01));

                        ir_variable *const r316F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r316F);
                        ir_variable *const r3170 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3170);
                        ir_variable *const r3171 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3171);
                        ir_variable *const r3172 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3173 = neg(r316E);
                        body.emit(assign(r3172, bit_and(r3173, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3175 = equal(r316E, body.constant(int(0)));
                        ir_if *f3174 = new(mem_ctx) ir_if(operand(r3175).val);
                        exec_list *const f3174_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3174->then_instructions;

                           body.emit(assign(r316F, r314E, 0x01));

                           body.emit(assign(r3170, r314F, 0x01));

                           body.emit(assign(r3171, r3150, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3174->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3177 = less(r316E, body.constant(int(32)));
                           ir_if *f3176 = new(mem_ctx) ir_if(operand(r3177).val);
                           exec_list *const f3176_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3176->then_instructions;

                              body.emit(assign(r316F, lshift(r314F, r3172), 0x01));

                              ir_expression *const r3178 = lshift(r3150, r3172);
                              ir_expression *const r3179 = rshift(r314F, r316E);
                              body.emit(assign(r3170, bit_or(r3178, r3179), 0x01));

                              body.emit(assign(r3171, rshift(r3150, r316E), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3176->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r317B = equal(r316E, body.constant(int(32)));
                              ir_if *f317A = new(mem_ctx) ir_if(operand(r317B).val);
                              exec_list *const f317A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f317A->then_instructions;

                                 body.emit(assign(r316F, r314F, 0x01));

                                 body.emit(assign(r3170, r3150, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f317A->else_instructions;

                                 body.emit(assign(r316D, bit_or(r314E, r314F), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r317D = less(r316E, body.constant(int(64)));
                                 ir_if *f317C = new(mem_ctx) ir_if(operand(r317D).val);
                                 exec_list *const f317C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f317C->then_instructions;

                                    body.emit(assign(r316F, lshift(r3150, r3172), 0x01));

                                    ir_expression *const r317E = bit_and(r316E, body.constant(int(31)));
                                    body.emit(assign(r3170, rshift(r3150, r317E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f317C->else_instructions;

                                    ir_variable *const r317F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3181 = equal(r316E, body.constant(int(64)));
                                    ir_if *f3180 = new(mem_ctx) ir_if(operand(r3181).val);
                                    exec_list *const f3180_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3180->then_instructions;

                                       body.emit(assign(r317F, r3150, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3180->else_instructions;

                                       ir_expression *const r3182 = nequal(r3150, body.constant(0u));
                                       ir_expression *const r3183 = expr(ir_unop_b2i, r3182);
                                       body.emit(assign(r317F, expr(ir_unop_i2u, r3183), 0x01));


                                    body.instructions = f3180_parent_instructions;
                                    body.emit(f3180);

                                    /* END IF */

                                    body.emit(assign(r316F, r317F, 0x01));

                                    body.emit(assign(r3170, body.constant(0u), 0x01));


                                 body.instructions = f317C_parent_instructions;
                                 body.emit(f317C);

                                 /* END IF */


                              body.instructions = f317A_parent_instructions;
                              body.emit(f317A);

                              /* END IF */

                              body.emit(assign(r3171, body.constant(0u), 0x01));


                           body.instructions = f3176_parent_instructions;
                           body.emit(f3176);

                           /* END IF */

                           ir_expression *const r3184 = nequal(r316D, body.constant(0u));
                           ir_expression *const r3185 = expr(ir_unop_b2i, r3184);
                           ir_expression *const r3186 = expr(ir_unop_i2u, r3185);
                           body.emit(assign(r316F, bit_or(r316F, r3186), 0x01));


                        body.instructions = f3174_parent_instructions;
                        body.emit(f3174);

                        /* END IF */

                        body.emit(assign(r3157, r3171, 0x01));

                        body.emit(assign(r3158, r3170, 0x01));

                        body.emit(assign(r3159, r316F, 0x01));

                        body.emit(assign(r3156, body.constant(int(0)), 0x01));

                        body.emit(assign(r315C, less(r316F, body.constant(0u)), 0x01));


                     body.instructions = f316B_parent_instructions;
                     body.emit(f316B);

                     /* END IF */


                  body.instructions = f3168_parent_instructions;
                  body.emit(f3168);

                  /* END IF */


               body.instructions = f315E_parent_instructions;
               body.emit(f315E);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3187 = new(mem_ctx) ir_if(operand(r315A).val);
               exec_list *const f3187_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3187->then_instructions;

                  /* IF CONDITION */
                  ir_if *f3188 = new(mem_ctx) ir_if(operand(r315C).val);
                  exec_list *const f3188_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3188->then_instructions;

                     ir_variable *const r3189 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3189, add(r3158, body.constant(1u)), 0x01));

                     ir_expression *const r318A = less(r3189, r3158);
                     ir_expression *const r318B = expr(ir_unop_b2i, r318A);
                     ir_expression *const r318C = expr(ir_unop_i2u, r318B);
                     body.emit(assign(r3157, add(r3157, r318C), 0x01));

                     ir_expression *const r318D = equal(r3159, body.constant(0u));
                     ir_expression *const r318E = expr(ir_unop_b2i, r318D);
                     ir_expression *const r318F = expr(ir_unop_i2u, r318E);
                     ir_expression *const r3190 = add(r3159, r318F);
                     ir_expression *const r3191 = bit_and(r3190, body.constant(1u));
                     ir_expression *const r3192 = expr(ir_unop_bit_not, r3191);
                     body.emit(assign(r3158, bit_and(r3189, r3192), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3188->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3194 = bit_or(r3157, r3158);
                     ir_expression *const r3195 = equal(r3194, body.constant(0u));
                     ir_if *f3193 = new(mem_ctx) ir_if(operand(r3195).val);
                     exec_list *const f3193_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3193->then_instructions;

                        body.emit(assign(r3156, body.constant(int(0)), 0x01));


                     body.instructions = f3193_parent_instructions;
                     body.emit(f3193);

                     /* END IF */


                  body.instructions = f3188_parent_instructions;
                  body.emit(f3188);

                  /* END IF */

                  ir_variable *const r3196 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3196);
                  ir_expression *const r3197 = lshift(r3003, body.constant(int(31)));
                  ir_expression *const r3198 = expr(ir_unop_i2u, r3156);
                  ir_expression *const r3199 = lshift(r3198, body.constant(int(20)));
                  ir_expression *const r319A = add(r3197, r3199);
                  body.emit(assign(r3196, add(r319A, r3157), 0x02));

                  body.emit(assign(r3196, r3158, 0x01));

                  body.emit(assign(r315B, r3196, 0x03));

                  body.emit(assign(r315A, body.constant(false), 0x01));


               body.instructions = f3187_parent_instructions;
               body.emit(f3187);

               /* END IF */

               body.emit(assign(r3008, r315B, 0x03));

               body.emit(assign(r3007, body.constant(false), 0x01));


            body.instructions = f3107_parent_instructions;
            body.emit(f3107);

            /* END IF */


         body.instructions = f3100_parent_instructions;
         body.emit(f3100);

         /* END IF */

         body.emit(assign(r3002, r3008, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3005->else_instructions;

         ir_variable *const r319B = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r319B, r3003, 0x01));

         ir_variable *const r319C = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r319D = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r319D);
         ir_variable *const r319E = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r319E);
         ir_variable *const r319F = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r319F);
         ir_variable *const r31A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r31A0);
         ir_variable *const r31A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r31A1);
         ir_variable *const r31A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r31A2);
         ir_variable *const r31A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r31A3);
         ir_variable *const r31A4 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r31A4);
         ir_variable *const r31A5 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r31A6 = rshift(swizzle_y(r2FCC), body.constant(int(20)));
         ir_expression *const r31A7 = bit_and(r31A6, body.constant(2047u));
         body.emit(assign(r31A5, expr(ir_unop_u2i, r31A7), 0x01));

         body.emit(assign(r319F, r31A5, 0x01));

         ir_variable *const r31A8 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r31A8, body.constant(int(1023)), 0x01));

         body.emit(assign(r319E, r31A8, 0x01));

         body.emit(assign(r319D, add(r31A5, body.constant(int(-1023))), 0x01));

         ir_variable *const r31A9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r31A9, lshift(swizzle_x(r2FCC), body.constant(int(10))), 0x01));

         ir_variable *const r31AA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r31AB = bit_and(swizzle_y(r2FCC), body.constant(1048575u));
         ir_expression *const r31AC = lshift(r31AB, body.constant(int(10)));
         ir_expression *const r31AD = rshift(swizzle_x(r2FCC), body.constant(int(22)));
         body.emit(assign(r31AA, bit_or(r31AC, r31AD), 0x01));

         body.emit(assign(r31A2, r31AA, 0x01));

         body.emit(assign(r31A3, r31A9, 0x01));

         ir_variable *const r31AE = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r31AE, body.constant(0u), 0x01));

         ir_variable *const r31AF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r31AF, body.constant(0u), 0x01));

         body.emit(assign(r31A0, r31AF, 0x01));

         body.emit(assign(r31A1, r31AE, 0x01));

         /* IF CONDITION */
         ir_expression *const r31B1 = less(body.constant(int(0)), r319D);
         ir_if *f31B0 = new(mem_ctx) ir_if(operand(r31B1).val);
         exec_list *const f31B0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f31B0->then_instructions;

            /* IF CONDITION */
            ir_expression *const r31B3 = equal(r31A5, body.constant(int(2047)));
            ir_if *f31B2 = new(mem_ctx) ir_if(operand(r31B3).val);
            exec_list *const f31B2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f31B2->then_instructions;

               /* IF CONDITION */
               ir_expression *const r31B5 = bit_or(r31AA, r31A9);
               ir_expression *const r31B6 = nequal(r31B5, body.constant(0u));
               ir_if *f31B4 = new(mem_ctx) ir_if(operand(r31B6).val);
               exec_list *const f31B4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f31B4->then_instructions;

                  ir_variable *const r31B7 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r31B7, swizzle_x(r2FCC), 0x01));

                  ir_variable *const r31B8 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r31B8, body.constant(0u), 0x01));

                  ir_variable *const r31B9 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r31BA = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r31BB = rshift(swizzle_y(r2FCC), body.constant(int(19)));
                  ir_expression *const r31BC = bit_and(r31BB, body.constant(4095u));
                  ir_expression *const r31BD = equal(r31BC, body.constant(4094u));
                  ir_expression *const r31BE = nequal(swizzle_x(r2FCC), body.constant(0u));
                  ir_expression *const r31BF = bit_and(swizzle_y(r2FCC), body.constant(524287u));
                  ir_expression *const r31C0 = nequal(r31BF, body.constant(0u));
                  ir_expression *const r31C1 = logic_or(r31BE, r31C0);
                  body.emit(assign(r31BA, logic_and(r31BD, r31C1), 0x01));

                  ir_variable *const r31C2 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  body.emit(assign(r31C2, body.constant(false), 0x01));

                  body.emit(assign(r31B7, bit_or(swizzle_y(r2FCC), body.constant(524288u)), 0x02));

                  body.emit(assign(r31B8, body.constant(3220701184u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r31C4 = lshift(swizzle_y(r2FCC), body.constant(int(1)));
                  ir_expression *const r31C5 = lequal(body.constant(4292870144u), r31C4);
                  ir_expression *const r31C6 = nequal(swizzle_x(r2FCC), body.constant(0u));
                  ir_expression *const r31C7 = bit_and(swizzle_y(r2FCC), body.constant(1048575u));
                  ir_expression *const r31C8 = nequal(r31C7, body.constant(0u));
                  ir_expression *const r31C9 = logic_or(r31C6, r31C8);
                  ir_expression *const r31CA = logic_and(r31C5, r31C9);
                  ir_if *f31C3 = new(mem_ctx) ir_if(operand(r31CA).val);
                  exec_list *const f31C3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f31C3->then_instructions;

                     ir_variable *const r31CB = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_constant *const r31CD = body.constant(false);
                     ir_if *f31CC = new(mem_ctx) ir_if(operand(r31CD).val);
                     exec_list *const f31CC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f31CC->then_instructions;

                        body.emit(assign(r31CB, r31B8, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f31CC->else_instructions;

                        body.emit(assign(r31CB, r31B7, 0x03));


                     body.instructions = f31CC_parent_instructions;
                     body.emit(f31CC);

                     /* END IF */

                     body.emit(assign(r31B9, r31CB, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f31C3->else_instructions;

                     body.emit(assign(r31B9, r31B8, 0x03));


                  body.instructions = f31C3_parent_instructions;
                  body.emit(f31C3);

                  /* END IF */

                  body.emit(assign(r319C, r31B9, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f31B4->else_instructions;

                  body.emit(assign(r319C, r2FCC, 0x03));


               body.instructions = f31B4_parent_instructions;
               body.emit(f31B4);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f31B2->else_instructions;

               /* IF CONDITION */
               ir_constant *const r31CF = body.constant(false);
               ir_if *f31CE = new(mem_ctx) ir_if(operand(r31CF).val);
               exec_list *const f31CE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f31CE->then_instructions;

                  body.emit(assign(r319D, add(r319D, body.constant(int(-1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f31CE->else_instructions;

                  body.emit(assign(r31A0, body.constant(1073741824u), 0x01));


               body.instructions = f31CE_parent_instructions;
               body.emit(f31CE);

               /* END IF */

               ir_variable *const r31D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r31D0);
               ir_variable *const r31D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r31D1);
               ir_variable *const r31D2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r31D3 = neg(r319D);
               body.emit(assign(r31D2, bit_and(r31D3, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r31D5 = equal(r319D, body.constant(int(0)));
               ir_if *f31D4 = new(mem_ctx) ir_if(operand(r31D5).val);
               exec_list *const f31D4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f31D4->then_instructions;

                  body.emit(assign(r31D0, r31AE, 0x01));

                  body.emit(assign(r31D1, r31A0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f31D4->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r31D7 = less(r319D, body.constant(int(32)));
                  ir_if *f31D6 = new(mem_ctx) ir_if(operand(r31D7).val);
                  exec_list *const f31D6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f31D6->then_instructions;

                     ir_expression *const r31D8 = lshift(r31A0, r31D2);
                     ir_expression *const r31D9 = bit_or(r31D8, body.constant(0u));
                     ir_expression *const r31DA = nequal(body.constant(0u), body.constant(0u));
                     ir_expression *const r31DB = expr(ir_unop_b2i, r31DA);
                     ir_expression *const r31DC = expr(ir_unop_i2u, r31DB);
                     body.emit(assign(r31D0, bit_or(r31D9, r31DC), 0x01));

                     body.emit(assign(r31D1, rshift(r31A0, r319D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f31D6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r31DE = equal(r319D, body.constant(int(32)));
                     ir_if *f31DD = new(mem_ctx) ir_if(operand(r31DE).val);
                     exec_list *const f31DD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f31DD->then_instructions;

                        body.emit(assign(r31D0, bit_or(r31A0, body.constant(0u)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f31DD->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r31E0 = less(r319D, body.constant(int(64)));
                        ir_if *f31DF = new(mem_ctx) ir_if(operand(r31E0).val);
                        exec_list *const f31DF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f31DF->then_instructions;

                           ir_expression *const r31E1 = bit_and(r319D, body.constant(int(31)));
                           ir_expression *const r31E2 = rshift(r31A0, r31E1);
                           ir_expression *const r31E3 = lshift(r31A0, r31D2);
                           ir_expression *const r31E4 = bit_or(r31E3, body.constant(0u));
                           ir_expression *const r31E5 = nequal(r31E4, body.constant(0u));
                           ir_expression *const r31E6 = expr(ir_unop_b2i, r31E5);
                           ir_expression *const r31E7 = expr(ir_unop_i2u, r31E6);
                           body.emit(assign(r31D0, bit_or(r31E2, r31E7), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f31DF->else_instructions;

                           ir_expression *const r31E8 = bit_or(r31A0, body.constant(0u));
                           ir_expression *const r31E9 = nequal(r31E8, body.constant(0u));
                           ir_expression *const r31EA = expr(ir_unop_b2i, r31E9);
                           body.emit(assign(r31D0, expr(ir_unop_i2u, r31EA), 0x01));


                        body.instructions = f31DF_parent_instructions;
                        body.emit(f31DF);

                        /* END IF */


                     body.instructions = f31DD_parent_instructions;
                     body.emit(f31DD);

                     /* END IF */

                     body.emit(assign(r31D1, body.constant(0u), 0x01));


                  body.instructions = f31D6_parent_instructions;
                  body.emit(f31D6);

                  /* END IF */


               body.instructions = f31D4_parent_instructions;
               body.emit(f31D4);

               /* END IF */

               body.emit(assign(r31A0, r31D1, 0x01));

               body.emit(assign(r31A1, r31D0, 0x01));

               body.emit(assign(r31A2, bit_or(r31AA, body.constant(1073741824u)), 0x01));

               ir_variable *const r31EB = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r31EC = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r31EC, sub(r31A9, r31D0), 0x01));

               ir_expression *const r31ED = sub(r31A2, r31D1);
               ir_expression *const r31EE = less(r31A9, r31D0);
               ir_expression *const r31EF = expr(ir_unop_b2i, r31EE);
               ir_expression *const r31F0 = expr(ir_unop_i2u, r31EF);
               body.emit(assign(r31EB, sub(r31ED, r31F0), 0x01));

               body.emit(assign(r31A4, add(r31A5, body.constant(int(-1))), 0x01));

               ir_variable *const r31F1 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r31F1, add(r31A4, body.constant(int(-10))), 0x01));

               ir_variable *const r31F2 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r31F2, r31EB, 0x01));

               ir_variable *const r31F3 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r31F3, r31EC, 0x01));

               ir_variable *const r31F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r31F4);
               ir_variable *const r31F5 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r31F5);
               /* IF CONDITION */
               ir_expression *const r31F7 = equal(r31EB, body.constant(0u));
               ir_if *f31F6 = new(mem_ctx) ir_if(operand(r31F7).val);
               exec_list *const f31F6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f31F6->then_instructions;

                  body.emit(assign(r31F2, r31EC, 0x01));

                  body.emit(assign(r31F3, body.constant(0u), 0x01));

                  body.emit(assign(r31F1, add(r31F1, body.constant(int(-32))), 0x01));


               body.instructions = f31F6_parent_instructions;
               body.emit(f31F6);

               /* END IF */

               ir_variable *const r31F8 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r31F8, r31F2, 0x01));

               ir_variable *const r31F9 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r31FA = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r31FA);
               /* IF CONDITION */
               ir_expression *const r31FC = equal(r31F2, body.constant(0u));
               ir_if *f31FB = new(mem_ctx) ir_if(operand(r31FC).val);
               exec_list *const f31FB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f31FB->then_instructions;

                  body.emit(assign(r31F9, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f31FB->else_instructions;

                  body.emit(assign(r31FA, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r31FE = bit_and(r31F2, body.constant(4294901760u));
                  ir_expression *const r31FF = equal(r31FE, body.constant(0u));
                  ir_if *f31FD = new(mem_ctx) ir_if(operand(r31FF).val);
                  exec_list *const f31FD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f31FD->then_instructions;

                     body.emit(assign(r31FA, body.constant(int(16)), 0x01));

                     body.emit(assign(r31F8, lshift(r31F2, body.constant(int(16))), 0x01));


                  body.instructions = f31FD_parent_instructions;
                  body.emit(f31FD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3201 = bit_and(r31F8, body.constant(4278190080u));
                  ir_expression *const r3202 = equal(r3201, body.constant(0u));
                  ir_if *f3200 = new(mem_ctx) ir_if(operand(r3202).val);
                  exec_list *const f3200_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3200->then_instructions;

                     body.emit(assign(r31FA, add(r31FA, body.constant(int(8))), 0x01));

                     body.emit(assign(r31F8, lshift(r31F8, body.constant(int(8))), 0x01));


                  body.instructions = f3200_parent_instructions;
                  body.emit(f3200);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3204 = bit_and(r31F8, body.constant(4026531840u));
                  ir_expression *const r3205 = equal(r3204, body.constant(0u));
                  ir_if *f3203 = new(mem_ctx) ir_if(operand(r3205).val);
                  exec_list *const f3203_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3203->then_instructions;

                     body.emit(assign(r31FA, add(r31FA, body.constant(int(4))), 0x01));

                     body.emit(assign(r31F8, lshift(r31F8, body.constant(int(4))), 0x01));


                  body.instructions = f3203_parent_instructions;
                  body.emit(f3203);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3207 = bit_and(r31F8, body.constant(3221225472u));
                  ir_expression *const r3208 = equal(r3207, body.constant(0u));
                  ir_if *f3206 = new(mem_ctx) ir_if(operand(r3208).val);
                  exec_list *const f3206_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3206->then_instructions;

                     body.emit(assign(r31FA, add(r31FA, body.constant(int(2))), 0x01));

                     body.emit(assign(r31F8, lshift(r31F8, body.constant(int(2))), 0x01));


                  body.instructions = f3206_parent_instructions;
                  body.emit(f3206);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r320A = bit_and(r31F8, body.constant(2147483648u));
                  ir_expression *const r320B = equal(r320A, body.constant(0u));
                  ir_if *f3209 = new(mem_ctx) ir_if(operand(r320B).val);
                  exec_list *const f3209_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3209->then_instructions;

                     body.emit(assign(r31FA, add(r31FA, body.constant(int(1))), 0x01));


                  body.instructions = f3209_parent_instructions;
                  body.emit(f3209);

                  /* END IF */

                  body.emit(assign(r31F9, r31FA, 0x01));


               body.instructions = f31FB_parent_instructions;
               body.emit(f31FB);

               /* END IF */

               body.emit(assign(r31F5, add(r31F9, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r320D = lequal(body.constant(int(0)), r31F5);
               ir_if *f320C = new(mem_ctx) ir_if(operand(r320D).val);
               exec_list *const f320C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f320C->then_instructions;

                  body.emit(assign(r31F4, body.constant(0u), 0x01));

                  ir_variable *const r320E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r320E, lshift(r31F3, r31F5), 0x01));

                  ir_variable *const r320F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3211 = equal(r31F5, body.constant(int(0)));
                  ir_if *f3210 = new(mem_ctx) ir_if(operand(r3211).val);
                  exec_list *const f3210_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3210->then_instructions;

                     body.emit(assign(r320F, r31F2, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3210->else_instructions;

                     ir_expression *const r3212 = lshift(r31F2, r31F5);
                     ir_expression *const r3213 = neg(r31F5);
                     ir_expression *const r3214 = bit_and(r3213, body.constant(int(31)));
                     ir_expression *const r3215 = rshift(r31F3, r3214);
                     body.emit(assign(r320F, bit_or(r3212, r3215), 0x01));


                  body.instructions = f3210_parent_instructions;
                  body.emit(f3210);

                  /* END IF */

                  body.emit(assign(r31F2, r320F, 0x01));

                  body.emit(assign(r31F3, r320E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f320C->else_instructions;

                  ir_variable *const r3216 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r3216, body.constant(0u), 0x01));

                  ir_variable *const r3217 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r3217, neg(r31F5), 0x01));

                  ir_variable *const r3218 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r3218);
                  ir_variable *const r3219 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3219);
                  ir_variable *const r321A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r321A);
                  ir_variable *const r321B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r321C = neg(r3217);
                  body.emit(assign(r321B, bit_and(r321C, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r321E = equal(r3217, body.constant(int(0)));
                  ir_if *f321D = new(mem_ctx) ir_if(operand(r321E).val);
                  exec_list *const f321D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f321D->then_instructions;

                     body.emit(assign(r3218, r3216, 0x01));

                     body.emit(assign(r3219, r31F3, 0x01));

                     body.emit(assign(r321A, r31F2, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f321D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3220 = less(r3217, body.constant(int(32)));
                     ir_if *f321F = new(mem_ctx) ir_if(operand(r3220).val);
                     exec_list *const f321F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f321F->then_instructions;

                        body.emit(assign(r3218, lshift(r31F3, r321B), 0x01));

                        ir_expression *const r3221 = lshift(r31F2, r321B);
                        ir_expression *const r3222 = rshift(r31F3, r3217);
                        body.emit(assign(r3219, bit_or(r3221, r3222), 0x01));

                        body.emit(assign(r321A, rshift(r31F2, r3217), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f321F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3224 = equal(r3217, body.constant(int(32)));
                        ir_if *f3223 = new(mem_ctx) ir_if(operand(r3224).val);
                        exec_list *const f3223_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3223->then_instructions;

                           body.emit(assign(r3218, r31F3, 0x01));

                           body.emit(assign(r3219, r31F2, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3223->else_instructions;

                           body.emit(assign(r3216, bit_or(body.constant(0u), r31F3), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3226 = less(r3217, body.constant(int(64)));
                           ir_if *f3225 = new(mem_ctx) ir_if(operand(r3226).val);
                           exec_list *const f3225_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3225->then_instructions;

                              body.emit(assign(r3218, lshift(r31F2, r321B), 0x01));

                              ir_expression *const r3227 = bit_and(r3217, body.constant(int(31)));
                              body.emit(assign(r3219, rshift(r31F2, r3227), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3225->else_instructions;

                              ir_variable *const r3228 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r322A = equal(r3217, body.constant(int(64)));
                              ir_if *f3229 = new(mem_ctx) ir_if(operand(r322A).val);
                              exec_list *const f3229_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3229->then_instructions;

                                 body.emit(assign(r3228, r31F2, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3229->else_instructions;

                                 ir_expression *const r322B = nequal(r31F2, body.constant(0u));
                                 ir_expression *const r322C = expr(ir_unop_b2i, r322B);
                                 body.emit(assign(r3228, expr(ir_unop_i2u, r322C), 0x01));


                              body.instructions = f3229_parent_instructions;
                              body.emit(f3229);

                              /* END IF */

                              body.emit(assign(r3218, r3228, 0x01));

                              body.emit(assign(r3219, body.constant(0u), 0x01));


                           body.instructions = f3225_parent_instructions;
                           body.emit(f3225);

                           /* END IF */


                        body.instructions = f3223_parent_instructions;
                        body.emit(f3223);

                        /* END IF */

                        body.emit(assign(r321A, body.constant(0u), 0x01));


                     body.instructions = f321F_parent_instructions;
                     body.emit(f321F);

                     /* END IF */

                     ir_expression *const r322D = nequal(r3216, body.constant(0u));
                     ir_expression *const r322E = expr(ir_unop_b2i, r322D);
                     ir_expression *const r322F = expr(ir_unop_i2u, r322E);
                     body.emit(assign(r3218, bit_or(r3218, r322F), 0x01));


                  body.instructions = f321D_parent_instructions;
                  body.emit(f321D);

                  /* END IF */

                  body.emit(assign(r31F2, r321A, 0x01));

                  body.emit(assign(r31F3, r3219, 0x01));

                  body.emit(assign(r31F4, r3218, 0x01));


               body.instructions = f320C_parent_instructions;
               body.emit(f320C);

               /* END IF */

               body.emit(assign(r31F1, sub(r31F1, r31F5), 0x01));

               ir_variable *const r3230 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3230, r31F1, 0x01));

               ir_variable *const r3231 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3231, r31F2, 0x01));

               ir_variable *const r3232 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3232, r31F3, 0x01));

               ir_variable *const r3233 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3233, r31F4, 0x01));

               ir_variable *const r3234 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r3234, body.constant(true), 0x01));

               ir_variable *const r3235 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3236 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3236);
               ir_expression *const r3237 = expr(ir_unop_u2i, r31F4);
               body.emit(assign(r3236, less(r3237, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3239 = lequal(body.constant(int(2045)), r31F1);
               ir_if *f3238 = new(mem_ctx) ir_if(operand(r3239).val);
               exec_list *const f3238_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3238->then_instructions;

                  ir_variable *const r323A = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r323C = less(body.constant(int(2045)), r31F1);
                  ir_if *f323B = new(mem_ctx) ir_if(operand(r323C).val);
                  exec_list *const f323B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f323B->then_instructions;

                     body.emit(assign(r323A, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f323B->else_instructions;

                     ir_variable *const r323D = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r323F = equal(r31F1, body.constant(int(2045)));
                     ir_if *f323E = new(mem_ctx) ir_if(operand(r323F).val);
                     exec_list *const f323E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f323E->then_instructions;

                        ir_expression *const r3240 = equal(body.constant(2097151u), r31F2);
                        ir_expression *const r3241 = equal(body.constant(4294967295u), r31F3);
                        body.emit(assign(r323D, logic_and(r3240, r3241), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f323E->else_instructions;

                        body.emit(assign(r323D, body.constant(false), 0x01));


                     body.instructions = f323E_parent_instructions;
                     body.emit(f323E);

                     /* END IF */

                     body.emit(assign(r323A, logic_and(r323D, r3236), 0x01));


                  body.instructions = f323B_parent_instructions;
                  body.emit(f323B);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3242 = new(mem_ctx) ir_if(operand(r323A).val);
                  exec_list *const f3242_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3242->then_instructions;

                     ir_variable *const r3243 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3243);
                     ir_expression *const r3244 = lshift(r3003, body.constant(int(31)));
                     body.emit(assign(r3243, add(r3244, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3243, body.constant(0u), 0x01));

                     body.emit(assign(r3235, r3243, 0x03));

                     body.emit(assign(r3234, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3242->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3246 = less(r31F1, body.constant(int(0)));
                     ir_if *f3245 = new(mem_ctx) ir_if(operand(r3246).val);
                     exec_list *const f3245_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3245->then_instructions;

                        ir_variable *const r3247 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3247, r31F4, 0x01));

                        ir_variable *const r3248 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3248, neg(r31F1), 0x01));

                        ir_variable *const r3249 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3249);
                        ir_variable *const r324A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r324A);
                        ir_variable *const r324B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r324B);
                        ir_variable *const r324C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r324D = neg(r3248);
                        body.emit(assign(r324C, bit_and(r324D, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r324F = equal(r3248, body.constant(int(0)));
                        ir_if *f324E = new(mem_ctx) ir_if(operand(r324F).val);
                        exec_list *const f324E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f324E->then_instructions;

                           body.emit(assign(r3249, r31F4, 0x01));

                           body.emit(assign(r324A, r31F3, 0x01));

                           body.emit(assign(r324B, r31F2, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f324E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3251 = less(r3248, body.constant(int(32)));
                           ir_if *f3250 = new(mem_ctx) ir_if(operand(r3251).val);
                           exec_list *const f3250_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3250->then_instructions;

                              body.emit(assign(r3249, lshift(r31F3, r324C), 0x01));

                              ir_expression *const r3252 = lshift(r31F2, r324C);
                              ir_expression *const r3253 = rshift(r31F3, r3248);
                              body.emit(assign(r324A, bit_or(r3252, r3253), 0x01));

                              body.emit(assign(r324B, rshift(r31F2, r3248), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3250->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3255 = equal(r3248, body.constant(int(32)));
                              ir_if *f3254 = new(mem_ctx) ir_if(operand(r3255).val);
                              exec_list *const f3254_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3254->then_instructions;

                                 body.emit(assign(r3249, r31F3, 0x01));

                                 body.emit(assign(r324A, r31F2, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3254->else_instructions;

                                 body.emit(assign(r3247, bit_or(r31F4, r31F3), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3257 = less(r3248, body.constant(int(64)));
                                 ir_if *f3256 = new(mem_ctx) ir_if(operand(r3257).val);
                                 exec_list *const f3256_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3256->then_instructions;

                                    body.emit(assign(r3249, lshift(r31F2, r324C), 0x01));

                                    ir_expression *const r3258 = bit_and(r3248, body.constant(int(31)));
                                    body.emit(assign(r324A, rshift(r31F2, r3258), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3256->else_instructions;

                                    ir_variable *const r3259 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r325B = equal(r3248, body.constant(int(64)));
                                    ir_if *f325A = new(mem_ctx) ir_if(operand(r325B).val);
                                    exec_list *const f325A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f325A->then_instructions;

                                       body.emit(assign(r3259, r31F2, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f325A->else_instructions;

                                       ir_expression *const r325C = nequal(r31F2, body.constant(0u));
                                       ir_expression *const r325D = expr(ir_unop_b2i, r325C);
                                       body.emit(assign(r3259, expr(ir_unop_i2u, r325D), 0x01));


                                    body.instructions = f325A_parent_instructions;
                                    body.emit(f325A);

                                    /* END IF */

                                    body.emit(assign(r3249, r3259, 0x01));

                                    body.emit(assign(r324A, body.constant(0u), 0x01));


                                 body.instructions = f3256_parent_instructions;
                                 body.emit(f3256);

                                 /* END IF */


                              body.instructions = f3254_parent_instructions;
                              body.emit(f3254);

                              /* END IF */

                              body.emit(assign(r324B, body.constant(0u), 0x01));


                           body.instructions = f3250_parent_instructions;
                           body.emit(f3250);

                           /* END IF */

                           ir_expression *const r325E = nequal(r3247, body.constant(0u));
                           ir_expression *const r325F = expr(ir_unop_b2i, r325E);
                           ir_expression *const r3260 = expr(ir_unop_i2u, r325F);
                           body.emit(assign(r3249, bit_or(r3249, r3260), 0x01));


                        body.instructions = f324E_parent_instructions;
                        body.emit(f324E);

                        /* END IF */

                        body.emit(assign(r3231, r324B, 0x01));

                        body.emit(assign(r3232, r324A, 0x01));

                        body.emit(assign(r3233, r3249, 0x01));

                        body.emit(assign(r3230, body.constant(int(0)), 0x01));

                        body.emit(assign(r3236, less(r3249, body.constant(0u)), 0x01));


                     body.instructions = f3245_parent_instructions;
                     body.emit(f3245);

                     /* END IF */


                  body.instructions = f3242_parent_instructions;
                  body.emit(f3242);

                  /* END IF */


               body.instructions = f3238_parent_instructions;
               body.emit(f3238);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3261 = new(mem_ctx) ir_if(operand(r3234).val);
               exec_list *const f3261_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3261->then_instructions;

                  /* IF CONDITION */
                  ir_if *f3262 = new(mem_ctx) ir_if(operand(r3236).val);
                  exec_list *const f3262_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3262->then_instructions;

                     ir_variable *const r3263 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3263, add(r3232, body.constant(1u)), 0x01));

                     ir_expression *const r3264 = less(r3263, r3232);
                     ir_expression *const r3265 = expr(ir_unop_b2i, r3264);
                     ir_expression *const r3266 = expr(ir_unop_i2u, r3265);
                     body.emit(assign(r3231, add(r3231, r3266), 0x01));

                     ir_expression *const r3267 = equal(r3233, body.constant(0u));
                     ir_expression *const r3268 = expr(ir_unop_b2i, r3267);
                     ir_expression *const r3269 = expr(ir_unop_i2u, r3268);
                     ir_expression *const r326A = add(r3233, r3269);
                     ir_expression *const r326B = bit_and(r326A, body.constant(1u));
                     ir_expression *const r326C = expr(ir_unop_bit_not, r326B);
                     body.emit(assign(r3232, bit_and(r3263, r326C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3262->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r326E = bit_or(r3231, r3232);
                     ir_expression *const r326F = equal(r326E, body.constant(0u));
                     ir_if *f326D = new(mem_ctx) ir_if(operand(r326F).val);
                     exec_list *const f326D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f326D->then_instructions;

                        body.emit(assign(r3230, body.constant(int(0)), 0x01));


                     body.instructions = f326D_parent_instructions;
                     body.emit(f326D);

                     /* END IF */


                  body.instructions = f3262_parent_instructions;
                  body.emit(f3262);

                  /* END IF */

                  ir_variable *const r3270 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3270);
                  ir_expression *const r3271 = lshift(r3003, body.constant(int(31)));
                  ir_expression *const r3272 = expr(ir_unop_i2u, r3230);
                  ir_expression *const r3273 = lshift(r3272, body.constant(int(20)));
                  ir_expression *const r3274 = add(r3271, r3273);
                  body.emit(assign(r3270, add(r3274, r3231), 0x02));

                  body.emit(assign(r3270, r3232, 0x01));

                  body.emit(assign(r3235, r3270, 0x03));

                  body.emit(assign(r3234, body.constant(false), 0x01));


               body.instructions = f3261_parent_instructions;
               body.emit(f3261);

               /* END IF */

               body.emit(assign(r319C, r3235, 0x03));


            body.instructions = f31B2_parent_instructions;
            body.emit(f31B2);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f31B0->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3276 = less(r319D, body.constant(int(0)));
            ir_if *f3275 = new(mem_ctx) ir_if(operand(r3276).val);
            exec_list *const f3275_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3275->then_instructions;

               /* IF CONDITION */
               ir_constant *const r3278 = body.constant(false);
               ir_if *f3277 = new(mem_ctx) ir_if(operand(r3278).val);
               exec_list *const f3277_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3277->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r327A = bit_or(r31A0, r31A1);
                  ir_expression *const r327B = nequal(r327A, body.constant(0u));
                  ir_if *f3279 = new(mem_ctx) ir_if(operand(r327B).val);
                  exec_list *const f3279_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3279->then_instructions;

                     ir_variable *const r327C = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r327C, swizzle_x(r2FCC), 0x01));

                     ir_variable *const r327D = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r327D, body.constant(0u), 0x01));

                     ir_variable *const r327E = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r327F = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r3280 = rshift(swizzle_y(r2FCC), body.constant(int(19)));
                     ir_expression *const r3281 = bit_and(r3280, body.constant(4095u));
                     ir_expression *const r3282 = equal(r3281, body.constant(4094u));
                     ir_expression *const r3283 = nequal(swizzle_x(r2FCC), body.constant(0u));
                     ir_expression *const r3284 = bit_and(swizzle_y(r2FCC), body.constant(524287u));
                     ir_expression *const r3285 = nequal(r3284, body.constant(0u));
                     ir_expression *const r3286 = logic_or(r3283, r3285);
                     body.emit(assign(r327F, logic_and(r3282, r3286), 0x01));

                     ir_variable *const r3287 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r3287, body.constant(false), 0x01));

                     body.emit(assign(r327C, bit_or(swizzle_y(r2FCC), body.constant(524288u)), 0x02));

                     body.emit(assign(r327D, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r3289 = lshift(swizzle_y(r2FCC), body.constant(int(1)));
                     ir_expression *const r328A = lequal(body.constant(4292870144u), r3289);
                     ir_expression *const r328B = nequal(swizzle_x(r2FCC), body.constant(0u));
                     ir_expression *const r328C = bit_and(swizzle_y(r2FCC), body.constant(1048575u));
                     ir_expression *const r328D = nequal(r328C, body.constant(0u));
                     ir_expression *const r328E = logic_or(r328B, r328D);
                     ir_expression *const r328F = logic_and(r328A, r328E);
                     ir_if *f3288 = new(mem_ctx) ir_if(operand(r328F).val);
                     exec_list *const f3288_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3288->then_instructions;

                        ir_variable *const r3290 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r3292 = body.constant(false);
                        ir_if *f3291 = new(mem_ctx) ir_if(operand(r3292).val);
                        exec_list *const f3291_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3291->then_instructions;

                           body.emit(assign(r3290, r327D, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3291->else_instructions;

                           body.emit(assign(r3290, r327C, 0x03));


                        body.instructions = f3291_parent_instructions;
                        body.emit(f3291);

                        /* END IF */

                        body.emit(assign(r327E, r3290, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3288->else_instructions;

                        body.emit(assign(r327E, r327D, 0x03));


                     body.instructions = f3288_parent_instructions;
                     body.emit(f3288);

                     /* END IF */

                     body.emit(assign(r319C, r327E, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3279->else_instructions;

                     ir_variable *const r3293 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3293);
                     ir_expression *const r3294 = bit_xor(r3003, body.constant(1u));
                     ir_expression *const r3295 = lshift(r3294, body.constant(int(31)));
                     body.emit(assign(r3293, add(r3295, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3293, body.constant(0u), 0x01));

                     body.emit(assign(r319C, r3293, 0x03));


                  body.instructions = f3279_parent_instructions;
                  body.emit(f3279);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3277->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3297 = equal(r31A5, body.constant(int(0)));
                  ir_if *f3296 = new(mem_ctx) ir_if(operand(r3297).val);
                  exec_list *const f3296_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3296->then_instructions;

                     body.emit(assign(r319D, add(r319D, body.constant(int(1))), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3296->else_instructions;

                     body.emit(assign(r31A2, bit_or(r31A2, body.constant(1073741824u)), 0x01));


                  body.instructions = f3296_parent_instructions;
                  body.emit(f3296);

                  /* END IF */

                  ir_variable *const r3298 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r3298, neg(r319D), 0x01));

                  ir_variable *const r3299 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3299);
                  ir_variable *const r329A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r329A);
                  ir_variable *const r329B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r329C = neg(r3298);
                  body.emit(assign(r329B, bit_and(r329C, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r329E = equal(r3298, body.constant(int(0)));
                  ir_if *f329D = new(mem_ctx) ir_if(operand(r329E).val);
                  exec_list *const f329D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f329D->then_instructions;

                     body.emit(assign(r3299, r31A9, 0x01));

                     body.emit(assign(r329A, r31A2, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f329D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r32A0 = less(r3298, body.constant(int(32)));
                     ir_if *f329F = new(mem_ctx) ir_if(operand(r32A0).val);
                     exec_list *const f329F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f329F->then_instructions;

                        ir_expression *const r32A1 = lshift(r31A2, r329B);
                        ir_expression *const r32A2 = rshift(r31A9, r3298);
                        ir_expression *const r32A3 = bit_or(r32A1, r32A2);
                        ir_expression *const r32A4 = lshift(r31A9, r329B);
                        ir_expression *const r32A5 = nequal(r32A4, body.constant(0u));
                        ir_expression *const r32A6 = expr(ir_unop_b2i, r32A5);
                        ir_expression *const r32A7 = expr(ir_unop_i2u, r32A6);
                        body.emit(assign(r3299, bit_or(r32A3, r32A7), 0x01));

                        body.emit(assign(r329A, rshift(r31A2, r3298), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f329F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r32A9 = equal(r3298, body.constant(int(32)));
                        ir_if *f32A8 = new(mem_ctx) ir_if(operand(r32A9).val);
                        exec_list *const f32A8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f32A8->then_instructions;

                           ir_expression *const r32AA = nequal(r31A9, body.constant(0u));
                           ir_expression *const r32AB = expr(ir_unop_b2i, r32AA);
                           ir_expression *const r32AC = expr(ir_unop_i2u, r32AB);
                           body.emit(assign(r3299, bit_or(r31A2, r32AC), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f32A8->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r32AE = less(r3298, body.constant(int(64)));
                           ir_if *f32AD = new(mem_ctx) ir_if(operand(r32AE).val);
                           exec_list *const f32AD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f32AD->then_instructions;

                              ir_expression *const r32AF = bit_and(r3298, body.constant(int(31)));
                              ir_expression *const r32B0 = rshift(r31A2, r32AF);
                              ir_expression *const r32B1 = lshift(r31A2, r329B);
                              ir_expression *const r32B2 = bit_or(r32B1, r31A9);
                              ir_expression *const r32B3 = nequal(r32B2, body.constant(0u));
                              ir_expression *const r32B4 = expr(ir_unop_b2i, r32B3);
                              ir_expression *const r32B5 = expr(ir_unop_i2u, r32B4);
                              body.emit(assign(r3299, bit_or(r32B0, r32B5), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f32AD->else_instructions;

                              ir_expression *const r32B6 = bit_or(r31A2, r31A9);
                              ir_expression *const r32B7 = nequal(r32B6, body.constant(0u));
                              ir_expression *const r32B8 = expr(ir_unop_b2i, r32B7);
                              body.emit(assign(r3299, expr(ir_unop_i2u, r32B8), 0x01));


                           body.instructions = f32AD_parent_instructions;
                           body.emit(f32AD);

                           /* END IF */


                        body.instructions = f32A8_parent_instructions;
                        body.emit(f32A8);

                        /* END IF */

                        body.emit(assign(r329A, body.constant(0u), 0x01));


                     body.instructions = f329F_parent_instructions;
                     body.emit(f329F);

                     /* END IF */


                  body.instructions = f329D_parent_instructions;
                  body.emit(f329D);

                  /* END IF */

                  body.emit(assign(r31A2, r329A, 0x01));

                  body.emit(assign(r31A3, r3299, 0x01));

                  body.emit(assign(r31A0, bit_or(r31A0, body.constant(1073741824u)), 0x01));

                  ir_variable *const r32B9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r32BA = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r32BA, sub(r31A1, r3299), 0x01));

                  ir_expression *const r32BB = sub(r31A0, r329A);
                  ir_expression *const r32BC = less(r31A1, r3299);
                  ir_expression *const r32BD = expr(ir_unop_b2i, r32BC);
                  ir_expression *const r32BE = expr(ir_unop_i2u, r32BD);
                  body.emit(assign(r32B9, sub(r32BB, r32BE), 0x01));

                  body.emit(assign(r319B, bit_xor(r3003, body.constant(1u)), 0x01));

                  body.emit(assign(r31A4, body.constant(int(1022)), 0x01));

                  ir_variable *const r32BF = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r32BF, body.constant(int(1012)), 0x01));

                  ir_variable *const r32C0 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r32C0, r32B9, 0x01));

                  ir_variable *const r32C1 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r32C1, r32BA, 0x01));

                  ir_variable *const r32C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r32C2);
                  ir_variable *const r32C3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r32C3);
                  /* IF CONDITION */
                  ir_expression *const r32C5 = equal(r32B9, body.constant(0u));
                  ir_if *f32C4 = new(mem_ctx) ir_if(operand(r32C5).val);
                  exec_list *const f32C4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32C4->then_instructions;

                     body.emit(assign(r32C0, r32BA, 0x01));

                     body.emit(assign(r32C1, body.constant(0u), 0x01));

                     body.emit(assign(r32BF, body.constant(int(980)), 0x01));


                  body.instructions = f32C4_parent_instructions;
                  body.emit(f32C4);

                  /* END IF */

                  ir_variable *const r32C6 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r32C6, r32C0, 0x01));

                  ir_variable *const r32C7 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r32C8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r32C8);
                  /* IF CONDITION */
                  ir_expression *const r32CA = equal(r32C0, body.constant(0u));
                  ir_if *f32C9 = new(mem_ctx) ir_if(operand(r32CA).val);
                  exec_list *const f32C9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32C9->then_instructions;

                     body.emit(assign(r32C7, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32C9->else_instructions;

                     body.emit(assign(r32C8, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r32CC = bit_and(r32C0, body.constant(4294901760u));
                     ir_expression *const r32CD = equal(r32CC, body.constant(0u));
                     ir_if *f32CB = new(mem_ctx) ir_if(operand(r32CD).val);
                     exec_list *const f32CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32CB->then_instructions;

                        body.emit(assign(r32C8, body.constant(int(16)), 0x01));

                        body.emit(assign(r32C6, lshift(r32C0, body.constant(int(16))), 0x01));


                     body.instructions = f32CB_parent_instructions;
                     body.emit(f32CB);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32CF = bit_and(r32C6, body.constant(4278190080u));
                     ir_expression *const r32D0 = equal(r32CF, body.constant(0u));
                     ir_if *f32CE = new(mem_ctx) ir_if(operand(r32D0).val);
                     exec_list *const f32CE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32CE->then_instructions;

                        body.emit(assign(r32C8, add(r32C8, body.constant(int(8))), 0x01));

                        body.emit(assign(r32C6, lshift(r32C6, body.constant(int(8))), 0x01));


                     body.instructions = f32CE_parent_instructions;
                     body.emit(f32CE);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32D2 = bit_and(r32C6, body.constant(4026531840u));
                     ir_expression *const r32D3 = equal(r32D2, body.constant(0u));
                     ir_if *f32D1 = new(mem_ctx) ir_if(operand(r32D3).val);
                     exec_list *const f32D1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32D1->then_instructions;

                        body.emit(assign(r32C8, add(r32C8, body.constant(int(4))), 0x01));

                        body.emit(assign(r32C6, lshift(r32C6, body.constant(int(4))), 0x01));


                     body.instructions = f32D1_parent_instructions;
                     body.emit(f32D1);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32D5 = bit_and(r32C6, body.constant(3221225472u));
                     ir_expression *const r32D6 = equal(r32D5, body.constant(0u));
                     ir_if *f32D4 = new(mem_ctx) ir_if(operand(r32D6).val);
                     exec_list *const f32D4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32D4->then_instructions;

                        body.emit(assign(r32C8, add(r32C8, body.constant(int(2))), 0x01));

                        body.emit(assign(r32C6, lshift(r32C6, body.constant(int(2))), 0x01));


                     body.instructions = f32D4_parent_instructions;
                     body.emit(f32D4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32D8 = bit_and(r32C6, body.constant(2147483648u));
                     ir_expression *const r32D9 = equal(r32D8, body.constant(0u));
                     ir_if *f32D7 = new(mem_ctx) ir_if(operand(r32D9).val);
                     exec_list *const f32D7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32D7->then_instructions;

                        body.emit(assign(r32C8, add(r32C8, body.constant(int(1))), 0x01));


                     body.instructions = f32D7_parent_instructions;
                     body.emit(f32D7);

                     /* END IF */

                     body.emit(assign(r32C7, r32C8, 0x01));


                  body.instructions = f32C9_parent_instructions;
                  body.emit(f32C9);

                  /* END IF */

                  body.emit(assign(r32C3, add(r32C7, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r32DB = lequal(body.constant(int(0)), r32C3);
                  ir_if *f32DA = new(mem_ctx) ir_if(operand(r32DB).val);
                  exec_list *const f32DA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32DA->then_instructions;

                     body.emit(assign(r32C2, body.constant(0u), 0x01));

                     ir_variable *const r32DC = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r32DC, lshift(r32C1, r32C3), 0x01));

                     ir_variable *const r32DD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r32DF = equal(r32C3, body.constant(int(0)));
                     ir_if *f32DE = new(mem_ctx) ir_if(operand(r32DF).val);
                     exec_list *const f32DE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32DE->then_instructions;

                        body.emit(assign(r32DD, r32C0, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f32DE->else_instructions;

                        ir_expression *const r32E0 = lshift(r32C0, r32C3);
                        ir_expression *const r32E1 = neg(r32C3);
                        ir_expression *const r32E2 = bit_and(r32E1, body.constant(int(31)));
                        ir_expression *const r32E3 = rshift(r32C1, r32E2);
                        body.emit(assign(r32DD, bit_or(r32E0, r32E3), 0x01));


                     body.instructions = f32DE_parent_instructions;
                     body.emit(f32DE);

                     /* END IF */

                     body.emit(assign(r32C0, r32DD, 0x01));

                     body.emit(assign(r32C1, r32DC, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32DA->else_instructions;

                     ir_variable *const r32E4 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r32E4, body.constant(0u), 0x01));

                     ir_variable *const r32E5 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r32E5, neg(r32C3), 0x01));

                     ir_variable *const r32E6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r32E6);
                     ir_variable *const r32E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r32E7);
                     ir_variable *const r32E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r32E8);
                     ir_variable *const r32E9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r32EA = neg(r32E5);
                     body.emit(assign(r32E9, bit_and(r32EA, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r32EC = equal(r32E5, body.constant(int(0)));
                     ir_if *f32EB = new(mem_ctx) ir_if(operand(r32EC).val);
                     exec_list *const f32EB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32EB->then_instructions;

                        body.emit(assign(r32E6, r32E4, 0x01));

                        body.emit(assign(r32E7, r32C1, 0x01));

                        body.emit(assign(r32E8, r32C0, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f32EB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r32EE = less(r32E5, body.constant(int(32)));
                        ir_if *f32ED = new(mem_ctx) ir_if(operand(r32EE).val);
                        exec_list *const f32ED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f32ED->then_instructions;

                           body.emit(assign(r32E6, lshift(r32C1, r32E9), 0x01));

                           ir_expression *const r32EF = lshift(r32C0, r32E9);
                           ir_expression *const r32F0 = rshift(r32C1, r32E5);
                           body.emit(assign(r32E7, bit_or(r32EF, r32F0), 0x01));

                           body.emit(assign(r32E8, rshift(r32C0, r32E5), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f32ED->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r32F2 = equal(r32E5, body.constant(int(32)));
                           ir_if *f32F1 = new(mem_ctx) ir_if(operand(r32F2).val);
                           exec_list *const f32F1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f32F1->then_instructions;

                              body.emit(assign(r32E6, r32C1, 0x01));

                              body.emit(assign(r32E7, r32C0, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f32F1->else_instructions;

                              body.emit(assign(r32E4, bit_or(body.constant(0u), r32C1), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r32F4 = less(r32E5, body.constant(int(64)));
                              ir_if *f32F3 = new(mem_ctx) ir_if(operand(r32F4).val);
                              exec_list *const f32F3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f32F3->then_instructions;

                                 body.emit(assign(r32E6, lshift(r32C0, r32E9), 0x01));

                                 ir_expression *const r32F5 = bit_and(r32E5, body.constant(int(31)));
                                 body.emit(assign(r32E7, rshift(r32C0, r32F5), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f32F3->else_instructions;

                                 ir_variable *const r32F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r32F8 = equal(r32E5, body.constant(int(64)));
                                 ir_if *f32F7 = new(mem_ctx) ir_if(operand(r32F8).val);
                                 exec_list *const f32F7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f32F7->then_instructions;

                                    body.emit(assign(r32F6, r32C0, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f32F7->else_instructions;

                                    ir_expression *const r32F9 = nequal(r32C0, body.constant(0u));
                                    ir_expression *const r32FA = expr(ir_unop_b2i, r32F9);
                                    body.emit(assign(r32F6, expr(ir_unop_i2u, r32FA), 0x01));


                                 body.instructions = f32F7_parent_instructions;
                                 body.emit(f32F7);

                                 /* END IF */

                                 body.emit(assign(r32E6, r32F6, 0x01));

                                 body.emit(assign(r32E7, body.constant(0u), 0x01));


                              body.instructions = f32F3_parent_instructions;
                              body.emit(f32F3);

                              /* END IF */


                           body.instructions = f32F1_parent_instructions;
                           body.emit(f32F1);

                           /* END IF */

                           body.emit(assign(r32E8, body.constant(0u), 0x01));


                        body.instructions = f32ED_parent_instructions;
                        body.emit(f32ED);

                        /* END IF */

                        ir_expression *const r32FB = nequal(r32E4, body.constant(0u));
                        ir_expression *const r32FC = expr(ir_unop_b2i, r32FB);
                        ir_expression *const r32FD = expr(ir_unop_i2u, r32FC);
                        body.emit(assign(r32E6, bit_or(r32E6, r32FD), 0x01));


                     body.instructions = f32EB_parent_instructions;
                     body.emit(f32EB);

                     /* END IF */

                     body.emit(assign(r32C0, r32E8, 0x01));

                     body.emit(assign(r32C1, r32E7, 0x01));

                     body.emit(assign(r32C2, r32E6, 0x01));


                  body.instructions = f32DA_parent_instructions;
                  body.emit(f32DA);

                  /* END IF */

                  body.emit(assign(r32BF, sub(r32BF, r32C3), 0x01));

                  ir_variable *const r32FE = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r32FE, r32BF, 0x01));

                  ir_variable *const r32FF = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r32FF, r32C0, 0x01));

                  ir_variable *const r3300 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r3300, r32C1, 0x01));

                  ir_variable *const r3301 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r3301, r32C2, 0x01));

                  ir_variable *const r3302 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r3302, body.constant(true), 0x01));

                  ir_variable *const r3303 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3304 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r3304);
                  ir_expression *const r3305 = expr(ir_unop_u2i, r32C2);
                  body.emit(assign(r3304, less(r3305, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3307 = lequal(body.constant(int(2045)), r32BF);
                  ir_if *f3306 = new(mem_ctx) ir_if(operand(r3307).val);
                  exec_list *const f3306_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3306->then_instructions;

                     ir_variable *const r3308 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r330A = less(body.constant(int(2045)), r32BF);
                     ir_if *f3309 = new(mem_ctx) ir_if(operand(r330A).val);
                     exec_list *const f3309_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3309->then_instructions;

                        body.emit(assign(r3308, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3309->else_instructions;

                        ir_variable *const r330B = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r330D = equal(r32BF, body.constant(int(2045)));
                        ir_if *f330C = new(mem_ctx) ir_if(operand(r330D).val);
                        exec_list *const f330C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f330C->then_instructions;

                           ir_expression *const r330E = equal(body.constant(2097151u), r32C0);
                           ir_expression *const r330F = equal(body.constant(4294967295u), r32C1);
                           body.emit(assign(r330B, logic_and(r330E, r330F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f330C->else_instructions;

                           body.emit(assign(r330B, body.constant(false), 0x01));


                        body.instructions = f330C_parent_instructions;
                        body.emit(f330C);

                        /* END IF */

                        body.emit(assign(r3308, logic_and(r330B, r3304), 0x01));


                     body.instructions = f3309_parent_instructions;
                     body.emit(f3309);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f3310 = new(mem_ctx) ir_if(operand(r3308).val);
                     exec_list *const f3310_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3310->then_instructions;

                        ir_variable *const r3311 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3311);
                        ir_expression *const r3312 = lshift(r319B, body.constant(int(31)));
                        body.emit(assign(r3311, add(r3312, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r3311, body.constant(0u), 0x01));

                        body.emit(assign(r3303, r3311, 0x03));

                        body.emit(assign(r3302, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3310->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3314 = less(r32BF, body.constant(int(0)));
                        ir_if *f3313 = new(mem_ctx) ir_if(operand(r3314).val);
                        exec_list *const f3313_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3313->then_instructions;

                           ir_variable *const r3315 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3315, r32C2, 0x01));

                           ir_variable *const r3316 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3316, neg(r32BF), 0x01));

                           ir_variable *const r3317 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3317);
                           ir_variable *const r3318 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3318);
                           ir_variable *const r3319 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3319);
                           ir_variable *const r331A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r331B = neg(r3316);
                           body.emit(assign(r331A, bit_and(r331B, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r331D = equal(r3316, body.constant(int(0)));
                           ir_if *f331C = new(mem_ctx) ir_if(operand(r331D).val);
                           exec_list *const f331C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f331C->then_instructions;

                              body.emit(assign(r3317, r32C2, 0x01));

                              body.emit(assign(r3318, r32C1, 0x01));

                              body.emit(assign(r3319, r32C0, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f331C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r331F = less(r3316, body.constant(int(32)));
                              ir_if *f331E = new(mem_ctx) ir_if(operand(r331F).val);
                              exec_list *const f331E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f331E->then_instructions;

                                 body.emit(assign(r3317, lshift(r32C1, r331A), 0x01));

                                 ir_expression *const r3320 = lshift(r32C0, r331A);
                                 ir_expression *const r3321 = rshift(r32C1, r3316);
                                 body.emit(assign(r3318, bit_or(r3320, r3321), 0x01));

                                 body.emit(assign(r3319, rshift(r32C0, r3316), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f331E->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3323 = equal(r3316, body.constant(int(32)));
                                 ir_if *f3322 = new(mem_ctx) ir_if(operand(r3323).val);
                                 exec_list *const f3322_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3322->then_instructions;

                                    body.emit(assign(r3317, r32C1, 0x01));

                                    body.emit(assign(r3318, r32C0, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3322->else_instructions;

                                    body.emit(assign(r3315, bit_or(r32C2, r32C1), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3325 = less(r3316, body.constant(int(64)));
                                    ir_if *f3324 = new(mem_ctx) ir_if(operand(r3325).val);
                                    exec_list *const f3324_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3324->then_instructions;

                                       body.emit(assign(r3317, lshift(r32C0, r331A), 0x01));

                                       ir_expression *const r3326 = bit_and(r3316, body.constant(int(31)));
                                       body.emit(assign(r3318, rshift(r32C0, r3326), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3324->else_instructions;

                                       ir_variable *const r3327 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3329 = equal(r3316, body.constant(int(64)));
                                       ir_if *f3328 = new(mem_ctx) ir_if(operand(r3329).val);
                                       exec_list *const f3328_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3328->then_instructions;

                                          body.emit(assign(r3327, r32C0, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3328->else_instructions;

                                          ir_expression *const r332A = nequal(r32C0, body.constant(0u));
                                          ir_expression *const r332B = expr(ir_unop_b2i, r332A);
                                          body.emit(assign(r3327, expr(ir_unop_i2u, r332B), 0x01));


                                       body.instructions = f3328_parent_instructions;
                                       body.emit(f3328);

                                       /* END IF */

                                       body.emit(assign(r3317, r3327, 0x01));

                                       body.emit(assign(r3318, body.constant(0u), 0x01));


                                    body.instructions = f3324_parent_instructions;
                                    body.emit(f3324);

                                    /* END IF */


                                 body.instructions = f3322_parent_instructions;
                                 body.emit(f3322);

                                 /* END IF */

                                 body.emit(assign(r3319, body.constant(0u), 0x01));


                              body.instructions = f331E_parent_instructions;
                              body.emit(f331E);

                              /* END IF */

                              ir_expression *const r332C = nequal(r3315, body.constant(0u));
                              ir_expression *const r332D = expr(ir_unop_b2i, r332C);
                              ir_expression *const r332E = expr(ir_unop_i2u, r332D);
                              body.emit(assign(r3317, bit_or(r3317, r332E), 0x01));


                           body.instructions = f331C_parent_instructions;
                           body.emit(f331C);

                           /* END IF */

                           body.emit(assign(r32FF, r3319, 0x01));

                           body.emit(assign(r3300, r3318, 0x01));

                           body.emit(assign(r3301, r3317, 0x01));

                           body.emit(assign(r32FE, body.constant(int(0)), 0x01));

                           body.emit(assign(r3304, less(r3317, body.constant(0u)), 0x01));


                        body.instructions = f3313_parent_instructions;
                        body.emit(f3313);

                        /* END IF */


                     body.instructions = f3310_parent_instructions;
                     body.emit(f3310);

                     /* END IF */


                  body.instructions = f3306_parent_instructions;
                  body.emit(f3306);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f332F = new(mem_ctx) ir_if(operand(r3302).val);
                  exec_list *const f332F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f332F->then_instructions;

                     /* IF CONDITION */
                     ir_if *f3330 = new(mem_ctx) ir_if(operand(r3304).val);
                     exec_list *const f3330_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3330->then_instructions;

                        ir_variable *const r3331 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r3331, add(r3300, body.constant(1u)), 0x01));

                        ir_expression *const r3332 = less(r3331, r3300);
                        ir_expression *const r3333 = expr(ir_unop_b2i, r3332);
                        ir_expression *const r3334 = expr(ir_unop_i2u, r3333);
                        body.emit(assign(r32FF, add(r32FF, r3334), 0x01));

                        ir_expression *const r3335 = equal(r3301, body.constant(0u));
                        ir_expression *const r3336 = expr(ir_unop_b2i, r3335);
                        ir_expression *const r3337 = expr(ir_unop_i2u, r3336);
                        ir_expression *const r3338 = add(r3301, r3337);
                        ir_expression *const r3339 = bit_and(r3338, body.constant(1u));
                        ir_expression *const r333A = expr(ir_unop_bit_not, r3339);
                        body.emit(assign(r3300, bit_and(r3331, r333A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3330->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r333C = bit_or(r32FF, r3300);
                        ir_expression *const r333D = equal(r333C, body.constant(0u));
                        ir_if *f333B = new(mem_ctx) ir_if(operand(r333D).val);
                        exec_list *const f333B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f333B->then_instructions;

                           body.emit(assign(r32FE, body.constant(int(0)), 0x01));


                        body.instructions = f333B_parent_instructions;
                        body.emit(f333B);

                        /* END IF */


                     body.instructions = f3330_parent_instructions;
                     body.emit(f3330);

                     /* END IF */

                     ir_variable *const r333E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r333E);
                     ir_expression *const r333F = lshift(r319B, body.constant(int(31)));
                     ir_expression *const r3340 = expr(ir_unop_i2u, r32FE);
                     ir_expression *const r3341 = lshift(r3340, body.constant(int(20)));
                     ir_expression *const r3342 = add(r333F, r3341);
                     body.emit(assign(r333E, add(r3342, r32FF), 0x02));

                     body.emit(assign(r333E, r3300, 0x01));

                     body.emit(assign(r3303, r333E, 0x03));

                     body.emit(assign(r3302, body.constant(false), 0x01));


                  body.instructions = f332F_parent_instructions;
                  body.emit(f332F);

                  /* END IF */

                  body.emit(assign(r319C, r3303, 0x03));


               body.instructions = f3277_parent_instructions;
               body.emit(f3277);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3275->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3344 = equal(r31A5, body.constant(int(2047)));
               ir_if *f3343 = new(mem_ctx) ir_if(operand(r3344).val);
               exec_list *const f3343_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3343->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3346 = bit_or(r31A2, r31A3);
                  ir_expression *const r3347 = bit_or(r31A0, r31A1);
                  ir_expression *const r3348 = bit_or(r3346, r3347);
                  ir_expression *const r3349 = nequal(r3348, body.constant(0u));
                  ir_if *f3345 = new(mem_ctx) ir_if(operand(r3349).val);
                  exec_list *const f3345_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3345->then_instructions;

                     ir_variable *const r334A = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r334A, swizzle_x(r2FCC), 0x01));

                     ir_variable *const r334B = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r334B, body.constant(0u), 0x01));

                     ir_variable *const r334C = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r334D = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                     ir_expression *const r334E = rshift(swizzle_y(r2FCC), body.constant(int(19)));
                     ir_expression *const r334F = bit_and(r334E, body.constant(4095u));
                     ir_expression *const r3350 = equal(r334F, body.constant(4094u));
                     ir_expression *const r3351 = nequal(swizzle_x(r2FCC), body.constant(0u));
                     ir_expression *const r3352 = bit_and(swizzle_y(r2FCC), body.constant(524287u));
                     ir_expression *const r3353 = nequal(r3352, body.constant(0u));
                     ir_expression *const r3354 = logic_or(r3351, r3353);
                     body.emit(assign(r334D, logic_and(r3350, r3354), 0x01));

                     ir_variable *const r3355 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                     body.emit(assign(r3355, body.constant(false), 0x01));

                     body.emit(assign(r334A, bit_or(swizzle_y(r2FCC), body.constant(524288u)), 0x02));

                     body.emit(assign(r334B, body.constant(3220701184u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r3357 = lshift(swizzle_y(r2FCC), body.constant(int(1)));
                     ir_expression *const r3358 = lequal(body.constant(4292870144u), r3357);
                     ir_expression *const r3359 = nequal(swizzle_x(r2FCC), body.constant(0u));
                     ir_expression *const r335A = bit_and(swizzle_y(r2FCC), body.constant(1048575u));
                     ir_expression *const r335B = nequal(r335A, body.constant(0u));
                     ir_expression *const r335C = logic_or(r3359, r335B);
                     ir_expression *const r335D = logic_and(r3358, r335C);
                     ir_if *f3356 = new(mem_ctx) ir_if(operand(r335D).val);
                     exec_list *const f3356_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3356->then_instructions;

                        ir_variable *const r335E = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_constant *const r3360 = body.constant(false);
                        ir_if *f335F = new(mem_ctx) ir_if(operand(r3360).val);
                        exec_list *const f335F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f335F->then_instructions;

                           body.emit(assign(r335E, r334B, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f335F->else_instructions;

                           body.emit(assign(r335E, r334A, 0x03));


                        body.instructions = f335F_parent_instructions;
                        body.emit(f335F);

                        /* END IF */

                        body.emit(assign(r334C, r335E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3356->else_instructions;

                        body.emit(assign(r334C, r334B, 0x03));


                     body.instructions = f3356_parent_instructions;
                     body.emit(f3356);

                     /* END IF */

                     body.emit(assign(r319C, r334C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3345->else_instructions;

                     ir_constant_data r3361_data;
                     memset(&r3361_data, 0, sizeof(ir_constant_data));
                     r3361_data.u[0] = 4294967295;
                     r3361_data.u[1] = 4294967295;
                     ir_constant *const r3361 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3361_data);
                     body.emit(assign(r319C, r3361, 0x03));


                  body.instructions = f3345_parent_instructions;
                  body.emit(f3345);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3343->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3363 = equal(r31A5, body.constant(int(0)));
                  ir_if *f3362 = new(mem_ctx) ir_if(operand(r3363).val);
                  exec_list *const f3362_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3362->then_instructions;

                     body.emit(assign(r319F, body.constant(int(1)), 0x01));

                     body.emit(assign(r319E, body.constant(int(1)), 0x01));


                  body.instructions = f3362_parent_instructions;
                  body.emit(f3362);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3365 = less(r31A0, r31A2);
                  ir_if *f3364 = new(mem_ctx) ir_if(operand(r3365).val);
                  exec_list *const f3364_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3364->then_instructions;

                     ir_variable *const r3366 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r3367 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3367, sub(r31A3, r31A1), 0x01));

                     ir_expression *const r3368 = sub(r31A2, r31A0);
                     ir_expression *const r3369 = less(r31A3, r31A1);
                     ir_expression *const r336A = expr(ir_unop_b2i, r3369);
                     ir_expression *const r336B = expr(ir_unop_i2u, r336A);
                     body.emit(assign(r3366, sub(r3368, r336B), 0x01));

                     body.emit(assign(r31A4, add(r319F, body.constant(int(-1))), 0x01));

                     ir_variable *const r336C = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r336C, add(r31A4, body.constant(int(-10))), 0x01));

                     ir_variable *const r336D = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r336D, r3366, 0x01));

                     ir_variable *const r336E = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r336E, r3367, 0x01));

                     ir_variable *const r336F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r336F);
                     ir_variable *const r3370 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3370);
                     /* IF CONDITION */
                     ir_expression *const r3372 = equal(r3366, body.constant(0u));
                     ir_if *f3371 = new(mem_ctx) ir_if(operand(r3372).val);
                     exec_list *const f3371_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3371->then_instructions;

                        body.emit(assign(r336D, r3367, 0x01));

                        body.emit(assign(r336E, body.constant(0u), 0x01));

                        body.emit(assign(r336C, add(r336C, body.constant(int(-32))), 0x01));


                     body.instructions = f3371_parent_instructions;
                     body.emit(f3371);

                     /* END IF */

                     ir_variable *const r3373 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3373, r336D, 0x01));

                     ir_variable *const r3374 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3375 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3375);
                     /* IF CONDITION */
                     ir_expression *const r3377 = equal(r336D, body.constant(0u));
                     ir_if *f3376 = new(mem_ctx) ir_if(operand(r3377).val);
                     exec_list *const f3376_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3376->then_instructions;

                        body.emit(assign(r3374, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3376->else_instructions;

                        body.emit(assign(r3375, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3379 = bit_and(r336D, body.constant(4294901760u));
                        ir_expression *const r337A = equal(r3379, body.constant(0u));
                        ir_if *f3378 = new(mem_ctx) ir_if(operand(r337A).val);
                        exec_list *const f3378_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3378->then_instructions;

                           body.emit(assign(r3375, body.constant(int(16)), 0x01));

                           body.emit(assign(r3373, lshift(r336D, body.constant(int(16))), 0x01));


                        body.instructions = f3378_parent_instructions;
                        body.emit(f3378);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r337C = bit_and(r3373, body.constant(4278190080u));
                        ir_expression *const r337D = equal(r337C, body.constant(0u));
                        ir_if *f337B = new(mem_ctx) ir_if(operand(r337D).val);
                        exec_list *const f337B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f337B->then_instructions;

                           body.emit(assign(r3375, add(r3375, body.constant(int(8))), 0x01));

                           body.emit(assign(r3373, lshift(r3373, body.constant(int(8))), 0x01));


                        body.instructions = f337B_parent_instructions;
                        body.emit(f337B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r337F = bit_and(r3373, body.constant(4026531840u));
                        ir_expression *const r3380 = equal(r337F, body.constant(0u));
                        ir_if *f337E = new(mem_ctx) ir_if(operand(r3380).val);
                        exec_list *const f337E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f337E->then_instructions;

                           body.emit(assign(r3375, add(r3375, body.constant(int(4))), 0x01));

                           body.emit(assign(r3373, lshift(r3373, body.constant(int(4))), 0x01));


                        body.instructions = f337E_parent_instructions;
                        body.emit(f337E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3382 = bit_and(r3373, body.constant(3221225472u));
                        ir_expression *const r3383 = equal(r3382, body.constant(0u));
                        ir_if *f3381 = new(mem_ctx) ir_if(operand(r3383).val);
                        exec_list *const f3381_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3381->then_instructions;

                           body.emit(assign(r3375, add(r3375, body.constant(int(2))), 0x01));

                           body.emit(assign(r3373, lshift(r3373, body.constant(int(2))), 0x01));


                        body.instructions = f3381_parent_instructions;
                        body.emit(f3381);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3385 = bit_and(r3373, body.constant(2147483648u));
                        ir_expression *const r3386 = equal(r3385, body.constant(0u));
                        ir_if *f3384 = new(mem_ctx) ir_if(operand(r3386).val);
                        exec_list *const f3384_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3384->then_instructions;

                           body.emit(assign(r3375, add(r3375, body.constant(int(1))), 0x01));


                        body.instructions = f3384_parent_instructions;
                        body.emit(f3384);

                        /* END IF */

                        body.emit(assign(r3374, r3375, 0x01));


                     body.instructions = f3376_parent_instructions;
                     body.emit(f3376);

                     /* END IF */

                     body.emit(assign(r3370, add(r3374, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3388 = lequal(body.constant(int(0)), r3370);
                     ir_if *f3387 = new(mem_ctx) ir_if(operand(r3388).val);
                     exec_list *const f3387_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3387->then_instructions;

                        body.emit(assign(r336F, body.constant(0u), 0x01));

                        ir_variable *const r3389 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r3389, lshift(r336E, r3370), 0x01));

                        ir_variable *const r338A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r338C = equal(r3370, body.constant(int(0)));
                        ir_if *f338B = new(mem_ctx) ir_if(operand(r338C).val);
                        exec_list *const f338B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f338B->then_instructions;

                           body.emit(assign(r338A, r336D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f338B->else_instructions;

                           ir_expression *const r338D = lshift(r336D, r3370);
                           ir_expression *const r338E = neg(r3370);
                           ir_expression *const r338F = bit_and(r338E, body.constant(int(31)));
                           ir_expression *const r3390 = rshift(r336E, r338F);
                           body.emit(assign(r338A, bit_or(r338D, r3390), 0x01));


                        body.instructions = f338B_parent_instructions;
                        body.emit(f338B);

                        /* END IF */

                        body.emit(assign(r336D, r338A, 0x01));

                        body.emit(assign(r336E, r3389, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3387->else_instructions;

                        ir_variable *const r3391 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3391, body.constant(0u), 0x01));

                        ir_variable *const r3392 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3392, neg(r3370), 0x01));

                        ir_variable *const r3393 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3393);
                        ir_variable *const r3394 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3394);
                        ir_variable *const r3395 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3395);
                        ir_variable *const r3396 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3397 = neg(r3392);
                        body.emit(assign(r3396, bit_and(r3397, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3399 = equal(r3392, body.constant(int(0)));
                        ir_if *f3398 = new(mem_ctx) ir_if(operand(r3399).val);
                        exec_list *const f3398_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3398->then_instructions;

                           body.emit(assign(r3393, r3391, 0x01));

                           body.emit(assign(r3394, r336E, 0x01));

                           body.emit(assign(r3395, r336D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3398->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r339B = less(r3392, body.constant(int(32)));
                           ir_if *f339A = new(mem_ctx) ir_if(operand(r339B).val);
                           exec_list *const f339A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f339A->then_instructions;

                              body.emit(assign(r3393, lshift(r336E, r3396), 0x01));

                              ir_expression *const r339C = lshift(r336D, r3396);
                              ir_expression *const r339D = rshift(r336E, r3392);
                              body.emit(assign(r3394, bit_or(r339C, r339D), 0x01));

                              body.emit(assign(r3395, rshift(r336D, r3392), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f339A->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r339F = equal(r3392, body.constant(int(32)));
                              ir_if *f339E = new(mem_ctx) ir_if(operand(r339F).val);
                              exec_list *const f339E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f339E->then_instructions;

                                 body.emit(assign(r3393, r336E, 0x01));

                                 body.emit(assign(r3394, r336D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f339E->else_instructions;

                                 body.emit(assign(r3391, bit_or(body.constant(0u), r336E), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r33A1 = less(r3392, body.constant(int(64)));
                                 ir_if *f33A0 = new(mem_ctx) ir_if(operand(r33A1).val);
                                 exec_list *const f33A0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f33A0->then_instructions;

                                    body.emit(assign(r3393, lshift(r336D, r3396), 0x01));

                                    ir_expression *const r33A2 = bit_and(r3392, body.constant(int(31)));
                                    body.emit(assign(r3394, rshift(r336D, r33A2), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f33A0->else_instructions;

                                    ir_variable *const r33A3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r33A5 = equal(r3392, body.constant(int(64)));
                                    ir_if *f33A4 = new(mem_ctx) ir_if(operand(r33A5).val);
                                    exec_list *const f33A4_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f33A4->then_instructions;

                                       body.emit(assign(r33A3, r336D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f33A4->else_instructions;

                                       ir_expression *const r33A6 = nequal(r336D, body.constant(0u));
                                       ir_expression *const r33A7 = expr(ir_unop_b2i, r33A6);
                                       body.emit(assign(r33A3, expr(ir_unop_i2u, r33A7), 0x01));


                                    body.instructions = f33A4_parent_instructions;
                                    body.emit(f33A4);

                                    /* END IF */

                                    body.emit(assign(r3393, r33A3, 0x01));

                                    body.emit(assign(r3394, body.constant(0u), 0x01));


                                 body.instructions = f33A0_parent_instructions;
                                 body.emit(f33A0);

                                 /* END IF */


                              body.instructions = f339E_parent_instructions;
                              body.emit(f339E);

                              /* END IF */

                              body.emit(assign(r3395, body.constant(0u), 0x01));


                           body.instructions = f339A_parent_instructions;
                           body.emit(f339A);

                           /* END IF */

                           ir_expression *const r33A8 = nequal(r3391, body.constant(0u));
                           ir_expression *const r33A9 = expr(ir_unop_b2i, r33A8);
                           ir_expression *const r33AA = expr(ir_unop_i2u, r33A9);
                           body.emit(assign(r3393, bit_or(r3393, r33AA), 0x01));


                        body.instructions = f3398_parent_instructions;
                        body.emit(f3398);

                        /* END IF */

                        body.emit(assign(r336D, r3395, 0x01));

                        body.emit(assign(r336E, r3394, 0x01));

                        body.emit(assign(r336F, r3393, 0x01));


                     body.instructions = f3387_parent_instructions;
                     body.emit(f3387);

                     /* END IF */

                     body.emit(assign(r336C, sub(r336C, r3370), 0x01));

                     ir_variable *const r33AB = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r33AB, r336C, 0x01));

                     ir_variable *const r33AC = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r33AC, r336D, 0x01));

                     ir_variable *const r33AD = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r33AD, r336E, 0x01));

                     ir_variable *const r33AE = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r33AE, r336F, 0x01));

                     ir_variable *const r33AF = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r33AF, body.constant(true), 0x01));

                     ir_variable *const r33B0 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r33B1 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r33B1);
                     ir_expression *const r33B2 = expr(ir_unop_u2i, r336F);
                     body.emit(assign(r33B1, less(r33B2, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r33B4 = lequal(body.constant(int(2045)), r336C);
                     ir_if *f33B3 = new(mem_ctx) ir_if(operand(r33B4).val);
                     exec_list *const f33B3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f33B3->then_instructions;

                        ir_variable *const r33B5 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r33B7 = less(body.constant(int(2045)), r336C);
                        ir_if *f33B6 = new(mem_ctx) ir_if(operand(r33B7).val);
                        exec_list *const f33B6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f33B6->then_instructions;

                           body.emit(assign(r33B5, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f33B6->else_instructions;

                           ir_variable *const r33B8 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r33BA = equal(r336C, body.constant(int(2045)));
                           ir_if *f33B9 = new(mem_ctx) ir_if(operand(r33BA).val);
                           exec_list *const f33B9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f33B9->then_instructions;

                              ir_expression *const r33BB = equal(body.constant(2097151u), r336D);
                              ir_expression *const r33BC = equal(body.constant(4294967295u), r336E);
                              body.emit(assign(r33B8, logic_and(r33BB, r33BC), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f33B9->else_instructions;

                              body.emit(assign(r33B8, body.constant(false), 0x01));


                           body.instructions = f33B9_parent_instructions;
                           body.emit(f33B9);

                           /* END IF */

                           body.emit(assign(r33B5, logic_and(r33B8, r33B1), 0x01));


                        body.instructions = f33B6_parent_instructions;
                        body.emit(f33B6);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f33BD = new(mem_ctx) ir_if(operand(r33B5).val);
                        exec_list *const f33BD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f33BD->then_instructions;

                           ir_variable *const r33BE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r33BE);
                           ir_expression *const r33BF = lshift(r319B, body.constant(int(31)));
                           body.emit(assign(r33BE, add(r33BF, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r33BE, body.constant(0u), 0x01));

                           body.emit(assign(r33B0, r33BE, 0x03));

                           body.emit(assign(r33AF, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f33BD->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r33C1 = less(r336C, body.constant(int(0)));
                           ir_if *f33C0 = new(mem_ctx) ir_if(operand(r33C1).val);
                           exec_list *const f33C0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f33C0->then_instructions;

                              ir_variable *const r33C2 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r33C2, r336F, 0x01));

                              ir_variable *const r33C3 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r33C3, neg(r336C), 0x01));

                              ir_variable *const r33C4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r33C4);
                              ir_variable *const r33C5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r33C5);
                              ir_variable *const r33C6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r33C6);
                              ir_variable *const r33C7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r33C8 = neg(r33C3);
                              body.emit(assign(r33C7, bit_and(r33C8, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r33CA = equal(r33C3, body.constant(int(0)));
                              ir_if *f33C9 = new(mem_ctx) ir_if(operand(r33CA).val);
                              exec_list *const f33C9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f33C9->then_instructions;

                                 body.emit(assign(r33C4, r336F, 0x01));

                                 body.emit(assign(r33C5, r336E, 0x01));

                                 body.emit(assign(r33C6, r336D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f33C9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r33CC = less(r33C3, body.constant(int(32)));
                                 ir_if *f33CB = new(mem_ctx) ir_if(operand(r33CC).val);
                                 exec_list *const f33CB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f33CB->then_instructions;

                                    body.emit(assign(r33C4, lshift(r336E, r33C7), 0x01));

                                    ir_expression *const r33CD = lshift(r336D, r33C7);
                                    ir_expression *const r33CE = rshift(r336E, r33C3);
                                    body.emit(assign(r33C5, bit_or(r33CD, r33CE), 0x01));

                                    body.emit(assign(r33C6, rshift(r336D, r33C3), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f33CB->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r33D0 = equal(r33C3, body.constant(int(32)));
                                    ir_if *f33CF = new(mem_ctx) ir_if(operand(r33D0).val);
                                    exec_list *const f33CF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f33CF->then_instructions;

                                       body.emit(assign(r33C4, r336E, 0x01));

                                       body.emit(assign(r33C5, r336D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f33CF->else_instructions;

                                       body.emit(assign(r33C2, bit_or(r336F, r336E), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r33D2 = less(r33C3, body.constant(int(64)));
                                       ir_if *f33D1 = new(mem_ctx) ir_if(operand(r33D2).val);
                                       exec_list *const f33D1_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f33D1->then_instructions;

                                          body.emit(assign(r33C4, lshift(r336D, r33C7), 0x01));

                                          ir_expression *const r33D3 = bit_and(r33C3, body.constant(int(31)));
                                          body.emit(assign(r33C5, rshift(r336D, r33D3), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f33D1->else_instructions;

                                          ir_variable *const r33D4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r33D6 = equal(r33C3, body.constant(int(64)));
                                          ir_if *f33D5 = new(mem_ctx) ir_if(operand(r33D6).val);
                                          exec_list *const f33D5_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f33D5->then_instructions;

                                             body.emit(assign(r33D4, r336D, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f33D5->else_instructions;

                                             ir_expression *const r33D7 = nequal(r336D, body.constant(0u));
                                             ir_expression *const r33D8 = expr(ir_unop_b2i, r33D7);
                                             body.emit(assign(r33D4, expr(ir_unop_i2u, r33D8), 0x01));


                                          body.instructions = f33D5_parent_instructions;
                                          body.emit(f33D5);

                                          /* END IF */

                                          body.emit(assign(r33C4, r33D4, 0x01));

                                          body.emit(assign(r33C5, body.constant(0u), 0x01));


                                       body.instructions = f33D1_parent_instructions;
                                       body.emit(f33D1);

                                       /* END IF */


                                    body.instructions = f33CF_parent_instructions;
                                    body.emit(f33CF);

                                    /* END IF */

                                    body.emit(assign(r33C6, body.constant(0u), 0x01));


                                 body.instructions = f33CB_parent_instructions;
                                 body.emit(f33CB);

                                 /* END IF */

                                 ir_expression *const r33D9 = nequal(r33C2, body.constant(0u));
                                 ir_expression *const r33DA = expr(ir_unop_b2i, r33D9);
                                 ir_expression *const r33DB = expr(ir_unop_i2u, r33DA);
                                 body.emit(assign(r33C4, bit_or(r33C4, r33DB), 0x01));


                              body.instructions = f33C9_parent_instructions;
                              body.emit(f33C9);

                              /* END IF */

                              body.emit(assign(r33AC, r33C6, 0x01));

                              body.emit(assign(r33AD, r33C5, 0x01));

                              body.emit(assign(r33AE, r33C4, 0x01));

                              body.emit(assign(r33AB, body.constant(int(0)), 0x01));

                              body.emit(assign(r33B1, less(r33C4, body.constant(0u)), 0x01));


                           body.instructions = f33C0_parent_instructions;
                           body.emit(f33C0);

                           /* END IF */


                        body.instructions = f33BD_parent_instructions;
                        body.emit(f33BD);

                        /* END IF */


                     body.instructions = f33B3_parent_instructions;
                     body.emit(f33B3);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f33DC = new(mem_ctx) ir_if(operand(r33AF).val);
                     exec_list *const f33DC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f33DC->then_instructions;

                        /* IF CONDITION */
                        ir_if *f33DD = new(mem_ctx) ir_if(operand(r33B1).val);
                        exec_list *const f33DD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f33DD->then_instructions;

                           ir_variable *const r33DE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r33DE, add(r33AD, body.constant(1u)), 0x01));

                           ir_expression *const r33DF = less(r33DE, r33AD);
                           ir_expression *const r33E0 = expr(ir_unop_b2i, r33DF);
                           ir_expression *const r33E1 = expr(ir_unop_i2u, r33E0);
                           body.emit(assign(r33AC, add(r33AC, r33E1), 0x01));

                           ir_expression *const r33E2 = equal(r33AE, body.constant(0u));
                           ir_expression *const r33E3 = expr(ir_unop_b2i, r33E2);
                           ir_expression *const r33E4 = expr(ir_unop_i2u, r33E3);
                           ir_expression *const r33E5 = add(r33AE, r33E4);
                           ir_expression *const r33E6 = bit_and(r33E5, body.constant(1u));
                           ir_expression *const r33E7 = expr(ir_unop_bit_not, r33E6);
                           body.emit(assign(r33AD, bit_and(r33DE, r33E7), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f33DD->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r33E9 = bit_or(r33AC, r33AD);
                           ir_expression *const r33EA = equal(r33E9, body.constant(0u));
                           ir_if *f33E8 = new(mem_ctx) ir_if(operand(r33EA).val);
                           exec_list *const f33E8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f33E8->then_instructions;

                              body.emit(assign(r33AB, body.constant(int(0)), 0x01));


                           body.instructions = f33E8_parent_instructions;
                           body.emit(f33E8);

                           /* END IF */


                        body.instructions = f33DD_parent_instructions;
                        body.emit(f33DD);

                        /* END IF */

                        ir_variable *const r33EB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r33EB);
                        ir_expression *const r33EC = lshift(r319B, body.constant(int(31)));
                        ir_expression *const r33ED = expr(ir_unop_i2u, r33AB);
                        ir_expression *const r33EE = lshift(r33ED, body.constant(int(20)));
                        ir_expression *const r33EF = add(r33EC, r33EE);
                        body.emit(assign(r33EB, add(r33EF, r33AC), 0x02));

                        body.emit(assign(r33EB, r33AD, 0x01));

                        body.emit(assign(r33B0, r33EB, 0x03));

                        body.emit(assign(r33AF, body.constant(false), 0x01));


                     body.instructions = f33DC_parent_instructions;
                     body.emit(f33DC);

                     /* END IF */

                     body.emit(assign(r319C, r33B0, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3364->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r33F1 = less(r31A2, r31A0);
                     ir_if *f33F0 = new(mem_ctx) ir_if(operand(r33F1).val);
                     exec_list *const f33F0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f33F0->then_instructions;

                        ir_variable *const r33F2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r33F3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r33F3, sub(r31A1, r31A3), 0x01));

                        ir_expression *const r33F4 = sub(r31A0, r31A2);
                        ir_expression *const r33F5 = less(r31A1, r31A3);
                        ir_expression *const r33F6 = expr(ir_unop_b2i, r33F5);
                        ir_expression *const r33F7 = expr(ir_unop_i2u, r33F6);
                        body.emit(assign(r33F2, sub(r33F4, r33F7), 0x01));

                        body.emit(assign(r319B, bit_xor(r319B, body.constant(1u)), 0x01));

                        body.emit(assign(r31A4, add(r319E, body.constant(int(-1))), 0x01));

                        ir_variable *const r33F8 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r33F8, add(r31A4, body.constant(int(-10))), 0x01));

                        ir_variable *const r33F9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r33F9, r33F2, 0x01));

                        ir_variable *const r33FA = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r33FA, r33F3, 0x01));

                        ir_variable *const r33FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r33FB);
                        ir_variable *const r33FC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r33FC);
                        /* IF CONDITION */
                        ir_expression *const r33FE = equal(r33F2, body.constant(0u));
                        ir_if *f33FD = new(mem_ctx) ir_if(operand(r33FE).val);
                        exec_list *const f33FD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f33FD->then_instructions;

                           body.emit(assign(r33F9, r33F3, 0x01));

                           body.emit(assign(r33FA, body.constant(0u), 0x01));

                           body.emit(assign(r33F8, add(r33F8, body.constant(int(-32))), 0x01));


                        body.instructions = f33FD_parent_instructions;
                        body.emit(f33FD);

                        /* END IF */

                        ir_variable *const r33FF = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r33FF, r33F9, 0x01));

                        ir_variable *const r3400 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r3401 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r3401);
                        /* IF CONDITION */
                        ir_expression *const r3403 = equal(r33F9, body.constant(0u));
                        ir_if *f3402 = new(mem_ctx) ir_if(operand(r3403).val);
                        exec_list *const f3402_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3402->then_instructions;

                           body.emit(assign(r3400, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3402->else_instructions;

                           body.emit(assign(r3401, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3405 = bit_and(r33F9, body.constant(4294901760u));
                           ir_expression *const r3406 = equal(r3405, body.constant(0u));
                           ir_if *f3404 = new(mem_ctx) ir_if(operand(r3406).val);
                           exec_list *const f3404_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3404->then_instructions;

                              body.emit(assign(r3401, body.constant(int(16)), 0x01));

                              body.emit(assign(r33FF, lshift(r33F9, body.constant(int(16))), 0x01));


                           body.instructions = f3404_parent_instructions;
                           body.emit(f3404);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3408 = bit_and(r33FF, body.constant(4278190080u));
                           ir_expression *const r3409 = equal(r3408, body.constant(0u));
                           ir_if *f3407 = new(mem_ctx) ir_if(operand(r3409).val);
                           exec_list *const f3407_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3407->then_instructions;

                              body.emit(assign(r3401, add(r3401, body.constant(int(8))), 0x01));

                              body.emit(assign(r33FF, lshift(r33FF, body.constant(int(8))), 0x01));


                           body.instructions = f3407_parent_instructions;
                           body.emit(f3407);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r340B = bit_and(r33FF, body.constant(4026531840u));
                           ir_expression *const r340C = equal(r340B, body.constant(0u));
                           ir_if *f340A = new(mem_ctx) ir_if(operand(r340C).val);
                           exec_list *const f340A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f340A->then_instructions;

                              body.emit(assign(r3401, add(r3401, body.constant(int(4))), 0x01));

                              body.emit(assign(r33FF, lshift(r33FF, body.constant(int(4))), 0x01));


                           body.instructions = f340A_parent_instructions;
                           body.emit(f340A);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r340E = bit_and(r33FF, body.constant(3221225472u));
                           ir_expression *const r340F = equal(r340E, body.constant(0u));
                           ir_if *f340D = new(mem_ctx) ir_if(operand(r340F).val);
                           exec_list *const f340D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f340D->then_instructions;

                              body.emit(assign(r3401, add(r3401, body.constant(int(2))), 0x01));

                              body.emit(assign(r33FF, lshift(r33FF, body.constant(int(2))), 0x01));


                           body.instructions = f340D_parent_instructions;
                           body.emit(f340D);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3411 = bit_and(r33FF, body.constant(2147483648u));
                           ir_expression *const r3412 = equal(r3411, body.constant(0u));
                           ir_if *f3410 = new(mem_ctx) ir_if(operand(r3412).val);
                           exec_list *const f3410_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3410->then_instructions;

                              body.emit(assign(r3401, add(r3401, body.constant(int(1))), 0x01));


                           body.instructions = f3410_parent_instructions;
                           body.emit(f3410);

                           /* END IF */

                           body.emit(assign(r3400, r3401, 0x01));


                        body.instructions = f3402_parent_instructions;
                        body.emit(f3402);

                        /* END IF */

                        body.emit(assign(r33FC, add(r3400, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3414 = lequal(body.constant(int(0)), r33FC);
                        ir_if *f3413 = new(mem_ctx) ir_if(operand(r3414).val);
                        exec_list *const f3413_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3413->then_instructions;

                           body.emit(assign(r33FB, body.constant(0u), 0x01));

                           ir_variable *const r3415 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r3415, lshift(r33FA, r33FC), 0x01));

                           ir_variable *const r3416 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3418 = equal(r33FC, body.constant(int(0)));
                           ir_if *f3417 = new(mem_ctx) ir_if(operand(r3418).val);
                           exec_list *const f3417_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3417->then_instructions;

                              body.emit(assign(r3416, r33F9, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3417->else_instructions;

                              ir_expression *const r3419 = lshift(r33F9, r33FC);
                              ir_expression *const r341A = neg(r33FC);
                              ir_expression *const r341B = bit_and(r341A, body.constant(int(31)));
                              ir_expression *const r341C = rshift(r33FA, r341B);
                              body.emit(assign(r3416, bit_or(r3419, r341C), 0x01));


                           body.instructions = f3417_parent_instructions;
                           body.emit(f3417);

                           /* END IF */

                           body.emit(assign(r33F9, r3416, 0x01));

                           body.emit(assign(r33FA, r3415, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3413->else_instructions;

                           ir_variable *const r341D = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r341D, body.constant(0u), 0x01));

                           ir_variable *const r341E = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r341E, neg(r33FC), 0x01));

                           ir_variable *const r341F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r341F);
                           ir_variable *const r3420 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3420);
                           ir_variable *const r3421 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3421);
                           ir_variable *const r3422 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r3423 = neg(r341E);
                           body.emit(assign(r3422, bit_and(r3423, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3425 = equal(r341E, body.constant(int(0)));
                           ir_if *f3424 = new(mem_ctx) ir_if(operand(r3425).val);
                           exec_list *const f3424_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3424->then_instructions;

                              body.emit(assign(r341F, r341D, 0x01));

                              body.emit(assign(r3420, r33FA, 0x01));

                              body.emit(assign(r3421, r33F9, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3424->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3427 = less(r341E, body.constant(int(32)));
                              ir_if *f3426 = new(mem_ctx) ir_if(operand(r3427).val);
                              exec_list *const f3426_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3426->then_instructions;

                                 body.emit(assign(r341F, lshift(r33FA, r3422), 0x01));

                                 ir_expression *const r3428 = lshift(r33F9, r3422);
                                 ir_expression *const r3429 = rshift(r33FA, r341E);
                                 body.emit(assign(r3420, bit_or(r3428, r3429), 0x01));

                                 body.emit(assign(r3421, rshift(r33F9, r341E), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3426->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r342B = equal(r341E, body.constant(int(32)));
                                 ir_if *f342A = new(mem_ctx) ir_if(operand(r342B).val);
                                 exec_list *const f342A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f342A->then_instructions;

                                    body.emit(assign(r341F, r33FA, 0x01));

                                    body.emit(assign(r3420, r33F9, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f342A->else_instructions;

                                    body.emit(assign(r341D, bit_or(body.constant(0u), r33FA), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r342D = less(r341E, body.constant(int(64)));
                                    ir_if *f342C = new(mem_ctx) ir_if(operand(r342D).val);
                                    exec_list *const f342C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f342C->then_instructions;

                                       body.emit(assign(r341F, lshift(r33F9, r3422), 0x01));

                                       ir_expression *const r342E = bit_and(r341E, body.constant(int(31)));
                                       body.emit(assign(r3420, rshift(r33F9, r342E), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f342C->else_instructions;

                                       ir_variable *const r342F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3431 = equal(r341E, body.constant(int(64)));
                                       ir_if *f3430 = new(mem_ctx) ir_if(operand(r3431).val);
                                       exec_list *const f3430_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3430->then_instructions;

                                          body.emit(assign(r342F, r33F9, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3430->else_instructions;

                                          ir_expression *const r3432 = nequal(r33F9, body.constant(0u));
                                          ir_expression *const r3433 = expr(ir_unop_b2i, r3432);
                                          body.emit(assign(r342F, expr(ir_unop_i2u, r3433), 0x01));


                                       body.instructions = f3430_parent_instructions;
                                       body.emit(f3430);

                                       /* END IF */

                                       body.emit(assign(r341F, r342F, 0x01));

                                       body.emit(assign(r3420, body.constant(0u), 0x01));


                                    body.instructions = f342C_parent_instructions;
                                    body.emit(f342C);

                                    /* END IF */


                                 body.instructions = f342A_parent_instructions;
                                 body.emit(f342A);

                                 /* END IF */

                                 body.emit(assign(r3421, body.constant(0u), 0x01));


                              body.instructions = f3426_parent_instructions;
                              body.emit(f3426);

                              /* END IF */

                              ir_expression *const r3434 = nequal(r341D, body.constant(0u));
                              ir_expression *const r3435 = expr(ir_unop_b2i, r3434);
                              ir_expression *const r3436 = expr(ir_unop_i2u, r3435);
                              body.emit(assign(r341F, bit_or(r341F, r3436), 0x01));


                           body.instructions = f3424_parent_instructions;
                           body.emit(f3424);

                           /* END IF */

                           body.emit(assign(r33F9, r3421, 0x01));

                           body.emit(assign(r33FA, r3420, 0x01));

                           body.emit(assign(r33FB, r341F, 0x01));


                        body.instructions = f3413_parent_instructions;
                        body.emit(f3413);

                        /* END IF */

                        body.emit(assign(r33F8, sub(r33F8, r33FC), 0x01));

                        ir_variable *const r3437 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r3437, r33F8, 0x01));

                        ir_variable *const r3438 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r3438, r33F9, 0x01));

                        ir_variable *const r3439 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r3439, r33FA, 0x01));

                        ir_variable *const r343A = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r343A, r33FB, 0x01));

                        ir_variable *const r343B = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r343B, body.constant(true), 0x01));

                        ir_variable *const r343C = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r343D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r343D);
                        ir_expression *const r343E = expr(ir_unop_u2i, r33FB);
                        body.emit(assign(r343D, less(r343E, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3440 = lequal(body.constant(int(2045)), r33F8);
                        ir_if *f343F = new(mem_ctx) ir_if(operand(r3440).val);
                        exec_list *const f343F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f343F->then_instructions;

                           ir_variable *const r3441 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3443 = less(body.constant(int(2045)), r33F8);
                           ir_if *f3442 = new(mem_ctx) ir_if(operand(r3443).val);
                           exec_list *const f3442_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3442->then_instructions;

                              body.emit(assign(r3441, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3442->else_instructions;

                              ir_variable *const r3444 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3446 = equal(r33F8, body.constant(int(2045)));
                              ir_if *f3445 = new(mem_ctx) ir_if(operand(r3446).val);
                              exec_list *const f3445_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3445->then_instructions;

                                 ir_expression *const r3447 = equal(body.constant(2097151u), r33F9);
                                 ir_expression *const r3448 = equal(body.constant(4294967295u), r33FA);
                                 body.emit(assign(r3444, logic_and(r3447, r3448), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3445->else_instructions;

                                 body.emit(assign(r3444, body.constant(false), 0x01));


                              body.instructions = f3445_parent_instructions;
                              body.emit(f3445);

                              /* END IF */

                              body.emit(assign(r3441, logic_and(r3444, r343D), 0x01));


                           body.instructions = f3442_parent_instructions;
                           body.emit(f3442);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f3449 = new(mem_ctx) ir_if(operand(r3441).val);
                           exec_list *const f3449_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3449->then_instructions;

                              ir_variable *const r344A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r344A);
                              ir_expression *const r344B = lshift(r319B, body.constant(int(31)));
                              body.emit(assign(r344A, add(r344B, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r344A, body.constant(0u), 0x01));

                              body.emit(assign(r343C, r344A, 0x03));

                              body.emit(assign(r343B, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3449->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r344D = less(r33F8, body.constant(int(0)));
                              ir_if *f344C = new(mem_ctx) ir_if(operand(r344D).val);
                              exec_list *const f344C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f344C->then_instructions;

                                 ir_variable *const r344E = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r344E, r33FB, 0x01));

                                 ir_variable *const r344F = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r344F, neg(r33F8), 0x01));

                                 ir_variable *const r3450 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r3450);
                                 ir_variable *const r3451 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r3451);
                                 ir_variable *const r3452 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r3452);
                                 ir_variable *const r3453 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r3454 = neg(r344F);
                                 body.emit(assign(r3453, bit_and(r3454, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3456 = equal(r344F, body.constant(int(0)));
                                 ir_if *f3455 = new(mem_ctx) ir_if(operand(r3456).val);
                                 exec_list *const f3455_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3455->then_instructions;

                                    body.emit(assign(r3450, r33FB, 0x01));

                                    body.emit(assign(r3451, r33FA, 0x01));

                                    body.emit(assign(r3452, r33F9, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3455->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3458 = less(r344F, body.constant(int(32)));
                                    ir_if *f3457 = new(mem_ctx) ir_if(operand(r3458).val);
                                    exec_list *const f3457_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3457->then_instructions;

                                       body.emit(assign(r3450, lshift(r33FA, r3453), 0x01));

                                       ir_expression *const r3459 = lshift(r33F9, r3453);
                                       ir_expression *const r345A = rshift(r33FA, r344F);
                                       body.emit(assign(r3451, bit_or(r3459, r345A), 0x01));

                                       body.emit(assign(r3452, rshift(r33F9, r344F), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3457->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r345C = equal(r344F, body.constant(int(32)));
                                       ir_if *f345B = new(mem_ctx) ir_if(operand(r345C).val);
                                       exec_list *const f345B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f345B->then_instructions;

                                          body.emit(assign(r3450, r33FA, 0x01));

                                          body.emit(assign(r3451, r33F9, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f345B->else_instructions;

                                          body.emit(assign(r344E, bit_or(r33FB, r33FA), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r345E = less(r344F, body.constant(int(64)));
                                          ir_if *f345D = new(mem_ctx) ir_if(operand(r345E).val);
                                          exec_list *const f345D_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f345D->then_instructions;

                                             body.emit(assign(r3450, lshift(r33F9, r3453), 0x01));

                                             ir_expression *const r345F = bit_and(r344F, body.constant(int(31)));
                                             body.emit(assign(r3451, rshift(r33F9, r345F), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f345D->else_instructions;

                                             ir_variable *const r3460 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r3462 = equal(r344F, body.constant(int(64)));
                                             ir_if *f3461 = new(mem_ctx) ir_if(operand(r3462).val);
                                             exec_list *const f3461_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3461->then_instructions;

                                                body.emit(assign(r3460, r33F9, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3461->else_instructions;

                                                ir_expression *const r3463 = nequal(r33F9, body.constant(0u));
                                                ir_expression *const r3464 = expr(ir_unop_b2i, r3463);
                                                body.emit(assign(r3460, expr(ir_unop_i2u, r3464), 0x01));


                                             body.instructions = f3461_parent_instructions;
                                             body.emit(f3461);

                                             /* END IF */

                                             body.emit(assign(r3450, r3460, 0x01));

                                             body.emit(assign(r3451, body.constant(0u), 0x01));


                                          body.instructions = f345D_parent_instructions;
                                          body.emit(f345D);

                                          /* END IF */


                                       body.instructions = f345B_parent_instructions;
                                       body.emit(f345B);

                                       /* END IF */

                                       body.emit(assign(r3452, body.constant(0u), 0x01));


                                    body.instructions = f3457_parent_instructions;
                                    body.emit(f3457);

                                    /* END IF */

                                    ir_expression *const r3465 = nequal(r344E, body.constant(0u));
                                    ir_expression *const r3466 = expr(ir_unop_b2i, r3465);
                                    ir_expression *const r3467 = expr(ir_unop_i2u, r3466);
                                    body.emit(assign(r3450, bit_or(r3450, r3467), 0x01));


                                 body.instructions = f3455_parent_instructions;
                                 body.emit(f3455);

                                 /* END IF */

                                 body.emit(assign(r3438, r3452, 0x01));

                                 body.emit(assign(r3439, r3451, 0x01));

                                 body.emit(assign(r343A, r3450, 0x01));

                                 body.emit(assign(r3437, body.constant(int(0)), 0x01));

                                 body.emit(assign(r343D, less(r3450, body.constant(0u)), 0x01));


                              body.instructions = f344C_parent_instructions;
                              body.emit(f344C);

                              /* END IF */


                           body.instructions = f3449_parent_instructions;
                           body.emit(f3449);

                           /* END IF */


                        body.instructions = f343F_parent_instructions;
                        body.emit(f343F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f3468 = new(mem_ctx) ir_if(operand(r343B).val);
                        exec_list *const f3468_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3468->then_instructions;

                           /* IF CONDITION */
                           ir_if *f3469 = new(mem_ctx) ir_if(operand(r343D).val);
                           exec_list *const f3469_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3469->then_instructions;

                              ir_variable *const r346A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r346A, add(r3439, body.constant(1u)), 0x01));

                              ir_expression *const r346B = less(r346A, r3439);
                              ir_expression *const r346C = expr(ir_unop_b2i, r346B);
                              ir_expression *const r346D = expr(ir_unop_i2u, r346C);
                              body.emit(assign(r3438, add(r3438, r346D), 0x01));

                              ir_expression *const r346E = equal(r343A, body.constant(0u));
                              ir_expression *const r346F = expr(ir_unop_b2i, r346E);
                              ir_expression *const r3470 = expr(ir_unop_i2u, r346F);
                              ir_expression *const r3471 = add(r343A, r3470);
                              ir_expression *const r3472 = bit_and(r3471, body.constant(1u));
                              ir_expression *const r3473 = expr(ir_unop_bit_not, r3472);
                              body.emit(assign(r3439, bit_and(r346A, r3473), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3469->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3475 = bit_or(r3438, r3439);
                              ir_expression *const r3476 = equal(r3475, body.constant(0u));
                              ir_if *f3474 = new(mem_ctx) ir_if(operand(r3476).val);
                              exec_list *const f3474_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3474->then_instructions;

                                 body.emit(assign(r3437, body.constant(int(0)), 0x01));


                              body.instructions = f3474_parent_instructions;
                              body.emit(f3474);

                              /* END IF */


                           body.instructions = f3469_parent_instructions;
                           body.emit(f3469);

                           /* END IF */

                           ir_variable *const r3477 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3477);
                           ir_expression *const r3478 = lshift(r319B, body.constant(int(31)));
                           ir_expression *const r3479 = expr(ir_unop_i2u, r3437);
                           ir_expression *const r347A = lshift(r3479, body.constant(int(20)));
                           ir_expression *const r347B = add(r3478, r347A);
                           body.emit(assign(r3477, add(r347B, r3438), 0x02));

                           body.emit(assign(r3477, r3439, 0x01));

                           body.emit(assign(r343C, r3477, 0x03));

                           body.emit(assign(r343B, body.constant(false), 0x01));


                        body.instructions = f3468_parent_instructions;
                        body.emit(f3468);

                        /* END IF */

                        body.emit(assign(r319C, r343C, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f33F0->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r347D = less(r31A1, r31A3);
                        ir_if *f347C = new(mem_ctx) ir_if(operand(r347D).val);
                        exec_list *const f347C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f347C->then_instructions;

                           ir_variable *const r347E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r347F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r347F, sub(r31A3, r31A1), 0x01));

                           ir_expression *const r3480 = sub(r31A2, r31A0);
                           ir_expression *const r3481 = less(r31A3, r31A1);
                           ir_expression *const r3482 = expr(ir_unop_b2i, r3481);
                           ir_expression *const r3483 = expr(ir_unop_i2u, r3482);
                           body.emit(assign(r347E, sub(r3480, r3483), 0x01));

                           body.emit(assign(r31A4, add(r319F, body.constant(int(-1))), 0x01));

                           ir_variable *const r3484 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r3484, add(r31A4, body.constant(int(-10))), 0x01));

                           ir_variable *const r3485 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r3485, r347E, 0x01));

                           ir_variable *const r3486 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r3486, r347F, 0x01));

                           ir_variable *const r3487 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r3487);
                           ir_variable *const r3488 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r3488);
                           /* IF CONDITION */
                           ir_expression *const r348A = equal(r347E, body.constant(0u));
                           ir_if *f3489 = new(mem_ctx) ir_if(operand(r348A).val);
                           exec_list *const f3489_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3489->then_instructions;

                              body.emit(assign(r3485, r347F, 0x01));

                              body.emit(assign(r3486, body.constant(0u), 0x01));

                              body.emit(assign(r3484, add(r3484, body.constant(int(-32))), 0x01));


                           body.instructions = f3489_parent_instructions;
                           body.emit(f3489);

                           /* END IF */

                           ir_variable *const r348B = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r348B, r3485, 0x01));

                           ir_variable *const r348C = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r348D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r348D);
                           /* IF CONDITION */
                           ir_expression *const r348F = equal(r3485, body.constant(0u));
                           ir_if *f348E = new(mem_ctx) ir_if(operand(r348F).val);
                           exec_list *const f348E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f348E->then_instructions;

                              body.emit(assign(r348C, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f348E->else_instructions;

                              body.emit(assign(r348D, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3491 = bit_and(r3485, body.constant(4294901760u));
                              ir_expression *const r3492 = equal(r3491, body.constant(0u));
                              ir_if *f3490 = new(mem_ctx) ir_if(operand(r3492).val);
                              exec_list *const f3490_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3490->then_instructions;

                                 body.emit(assign(r348D, body.constant(int(16)), 0x01));

                                 body.emit(assign(r348B, lshift(r3485, body.constant(int(16))), 0x01));


                              body.instructions = f3490_parent_instructions;
                              body.emit(f3490);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3494 = bit_and(r348B, body.constant(4278190080u));
                              ir_expression *const r3495 = equal(r3494, body.constant(0u));
                              ir_if *f3493 = new(mem_ctx) ir_if(operand(r3495).val);
                              exec_list *const f3493_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3493->then_instructions;

                                 body.emit(assign(r348D, add(r348D, body.constant(int(8))), 0x01));

                                 body.emit(assign(r348B, lshift(r348B, body.constant(int(8))), 0x01));


                              body.instructions = f3493_parent_instructions;
                              body.emit(f3493);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3497 = bit_and(r348B, body.constant(4026531840u));
                              ir_expression *const r3498 = equal(r3497, body.constant(0u));
                              ir_if *f3496 = new(mem_ctx) ir_if(operand(r3498).val);
                              exec_list *const f3496_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3496->then_instructions;

                                 body.emit(assign(r348D, add(r348D, body.constant(int(4))), 0x01));

                                 body.emit(assign(r348B, lshift(r348B, body.constant(int(4))), 0x01));


                              body.instructions = f3496_parent_instructions;
                              body.emit(f3496);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r349A = bit_and(r348B, body.constant(3221225472u));
                              ir_expression *const r349B = equal(r349A, body.constant(0u));
                              ir_if *f3499 = new(mem_ctx) ir_if(operand(r349B).val);
                              exec_list *const f3499_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3499->then_instructions;

                                 body.emit(assign(r348D, add(r348D, body.constant(int(2))), 0x01));

                                 body.emit(assign(r348B, lshift(r348B, body.constant(int(2))), 0x01));


                              body.instructions = f3499_parent_instructions;
                              body.emit(f3499);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r349D = bit_and(r348B, body.constant(2147483648u));
                              ir_expression *const r349E = equal(r349D, body.constant(0u));
                              ir_if *f349C = new(mem_ctx) ir_if(operand(r349E).val);
                              exec_list *const f349C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f349C->then_instructions;

                                 body.emit(assign(r348D, add(r348D, body.constant(int(1))), 0x01));


                              body.instructions = f349C_parent_instructions;
                              body.emit(f349C);

                              /* END IF */

                              body.emit(assign(r348C, r348D, 0x01));


                           body.instructions = f348E_parent_instructions;
                           body.emit(f348E);

                           /* END IF */

                           body.emit(assign(r3488, add(r348C, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r34A0 = lequal(body.constant(int(0)), r3488);
                           ir_if *f349F = new(mem_ctx) ir_if(operand(r34A0).val);
                           exec_list *const f349F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f349F->then_instructions;

                              body.emit(assign(r3487, body.constant(0u), 0x01));

                              ir_variable *const r34A1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r34A1, lshift(r3486, r3488), 0x01));

                              ir_variable *const r34A2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r34A4 = equal(r3488, body.constant(int(0)));
                              ir_if *f34A3 = new(mem_ctx) ir_if(operand(r34A4).val);
                              exec_list *const f34A3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f34A3->then_instructions;

                                 body.emit(assign(r34A2, r3485, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f34A3->else_instructions;

                                 ir_expression *const r34A5 = lshift(r3485, r3488);
                                 ir_expression *const r34A6 = neg(r3488);
                                 ir_expression *const r34A7 = bit_and(r34A6, body.constant(int(31)));
                                 ir_expression *const r34A8 = rshift(r3486, r34A7);
                                 body.emit(assign(r34A2, bit_or(r34A5, r34A8), 0x01));


                              body.instructions = f34A3_parent_instructions;
                              body.emit(f34A3);

                              /* END IF */

                              body.emit(assign(r3485, r34A2, 0x01));

                              body.emit(assign(r3486, r34A1, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f349F->else_instructions;

                              ir_variable *const r34A9 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r34A9, body.constant(0u), 0x01));

                              ir_variable *const r34AA = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r34AA, neg(r3488), 0x01));

                              ir_variable *const r34AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r34AB);
                              ir_variable *const r34AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r34AC);
                              ir_variable *const r34AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r34AD);
                              ir_variable *const r34AE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r34AF = neg(r34AA);
                              body.emit(assign(r34AE, bit_and(r34AF, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r34B1 = equal(r34AA, body.constant(int(0)));
                              ir_if *f34B0 = new(mem_ctx) ir_if(operand(r34B1).val);
                              exec_list *const f34B0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f34B0->then_instructions;

                                 body.emit(assign(r34AB, r34A9, 0x01));

                                 body.emit(assign(r34AC, r3486, 0x01));

                                 body.emit(assign(r34AD, r3485, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f34B0->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r34B3 = less(r34AA, body.constant(int(32)));
                                 ir_if *f34B2 = new(mem_ctx) ir_if(operand(r34B3).val);
                                 exec_list *const f34B2_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f34B2->then_instructions;

                                    body.emit(assign(r34AB, lshift(r3486, r34AE), 0x01));

                                    ir_expression *const r34B4 = lshift(r3485, r34AE);
                                    ir_expression *const r34B5 = rshift(r3486, r34AA);
                                    body.emit(assign(r34AC, bit_or(r34B4, r34B5), 0x01));

                                    body.emit(assign(r34AD, rshift(r3485, r34AA), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f34B2->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r34B7 = equal(r34AA, body.constant(int(32)));
                                    ir_if *f34B6 = new(mem_ctx) ir_if(operand(r34B7).val);
                                    exec_list *const f34B6_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f34B6->then_instructions;

                                       body.emit(assign(r34AB, r3486, 0x01));

                                       body.emit(assign(r34AC, r3485, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f34B6->else_instructions;

                                       body.emit(assign(r34A9, bit_or(body.constant(0u), r3486), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r34B9 = less(r34AA, body.constant(int(64)));
                                       ir_if *f34B8 = new(mem_ctx) ir_if(operand(r34B9).val);
                                       exec_list *const f34B8_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f34B8->then_instructions;

                                          body.emit(assign(r34AB, lshift(r3485, r34AE), 0x01));

                                          ir_expression *const r34BA = bit_and(r34AA, body.constant(int(31)));
                                          body.emit(assign(r34AC, rshift(r3485, r34BA), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f34B8->else_instructions;

                                          ir_variable *const r34BB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r34BD = equal(r34AA, body.constant(int(64)));
                                          ir_if *f34BC = new(mem_ctx) ir_if(operand(r34BD).val);
                                          exec_list *const f34BC_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f34BC->then_instructions;

                                             body.emit(assign(r34BB, r3485, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f34BC->else_instructions;

                                             ir_expression *const r34BE = nequal(r3485, body.constant(0u));
                                             ir_expression *const r34BF = expr(ir_unop_b2i, r34BE);
                                             body.emit(assign(r34BB, expr(ir_unop_i2u, r34BF), 0x01));


                                          body.instructions = f34BC_parent_instructions;
                                          body.emit(f34BC);

                                          /* END IF */

                                          body.emit(assign(r34AB, r34BB, 0x01));

                                          body.emit(assign(r34AC, body.constant(0u), 0x01));


                                       body.instructions = f34B8_parent_instructions;
                                       body.emit(f34B8);

                                       /* END IF */


                                    body.instructions = f34B6_parent_instructions;
                                    body.emit(f34B6);

                                    /* END IF */

                                    body.emit(assign(r34AD, body.constant(0u), 0x01));


                                 body.instructions = f34B2_parent_instructions;
                                 body.emit(f34B2);

                                 /* END IF */

                                 ir_expression *const r34C0 = nequal(r34A9, body.constant(0u));
                                 ir_expression *const r34C1 = expr(ir_unop_b2i, r34C0);
                                 ir_expression *const r34C2 = expr(ir_unop_i2u, r34C1);
                                 body.emit(assign(r34AB, bit_or(r34AB, r34C2), 0x01));


                              body.instructions = f34B0_parent_instructions;
                              body.emit(f34B0);

                              /* END IF */

                              body.emit(assign(r3485, r34AD, 0x01));

                              body.emit(assign(r3486, r34AC, 0x01));

                              body.emit(assign(r3487, r34AB, 0x01));


                           body.instructions = f349F_parent_instructions;
                           body.emit(f349F);

                           /* END IF */

                           body.emit(assign(r3484, sub(r3484, r3488), 0x01));

                           ir_variable *const r34C3 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r34C3, r3484, 0x01));

                           ir_variable *const r34C4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r34C4, r3485, 0x01));

                           ir_variable *const r34C5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r34C5, r3486, 0x01));

                           ir_variable *const r34C6 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r34C6, r3487, 0x01));

                           ir_variable *const r34C7 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r34C7, body.constant(true), 0x01));

                           ir_variable *const r34C8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r34C9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r34C9);
                           ir_expression *const r34CA = expr(ir_unop_u2i, r3487);
                           body.emit(assign(r34C9, less(r34CA, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r34CC = lequal(body.constant(int(2045)), r3484);
                           ir_if *f34CB = new(mem_ctx) ir_if(operand(r34CC).val);
                           exec_list *const f34CB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f34CB->then_instructions;

                              ir_variable *const r34CD = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r34CF = less(body.constant(int(2045)), r3484);
                              ir_if *f34CE = new(mem_ctx) ir_if(operand(r34CF).val);
                              exec_list *const f34CE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f34CE->then_instructions;

                                 body.emit(assign(r34CD, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f34CE->else_instructions;

                                 ir_variable *const r34D0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r34D2 = equal(r3484, body.constant(int(2045)));
                                 ir_if *f34D1 = new(mem_ctx) ir_if(operand(r34D2).val);
                                 exec_list *const f34D1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f34D1->then_instructions;

                                    ir_expression *const r34D3 = equal(body.constant(2097151u), r3485);
                                    ir_expression *const r34D4 = equal(body.constant(4294967295u), r3486);
                                    body.emit(assign(r34D0, logic_and(r34D3, r34D4), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f34D1->else_instructions;

                                    body.emit(assign(r34D0, body.constant(false), 0x01));


                                 body.instructions = f34D1_parent_instructions;
                                 body.emit(f34D1);

                                 /* END IF */

                                 body.emit(assign(r34CD, logic_and(r34D0, r34C9), 0x01));


                              body.instructions = f34CE_parent_instructions;
                              body.emit(f34CE);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f34D5 = new(mem_ctx) ir_if(operand(r34CD).val);
                              exec_list *const f34D5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f34D5->then_instructions;

                                 ir_variable *const r34D6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r34D6);
                                 ir_expression *const r34D7 = lshift(r319B, body.constant(int(31)));
                                 body.emit(assign(r34D6, add(r34D7, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r34D6, body.constant(0u), 0x01));

                                 body.emit(assign(r34C8, r34D6, 0x03));

                                 body.emit(assign(r34C7, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f34D5->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r34D9 = less(r3484, body.constant(int(0)));
                                 ir_if *f34D8 = new(mem_ctx) ir_if(operand(r34D9).val);
                                 exec_list *const f34D8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f34D8->then_instructions;

                                    ir_variable *const r34DA = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r34DA, r3487, 0x01));

                                    ir_variable *const r34DB = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r34DB, neg(r3484), 0x01));

                                    ir_variable *const r34DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r34DC);
                                    ir_variable *const r34DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r34DD);
                                    ir_variable *const r34DE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r34DE);
                                    ir_variable *const r34DF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r34E0 = neg(r34DB);
                                    body.emit(assign(r34DF, bit_and(r34E0, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r34E2 = equal(r34DB, body.constant(int(0)));
                                    ir_if *f34E1 = new(mem_ctx) ir_if(operand(r34E2).val);
                                    exec_list *const f34E1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f34E1->then_instructions;

                                       body.emit(assign(r34DC, r3487, 0x01));

                                       body.emit(assign(r34DD, r3486, 0x01));

                                       body.emit(assign(r34DE, r3485, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f34E1->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r34E4 = less(r34DB, body.constant(int(32)));
                                       ir_if *f34E3 = new(mem_ctx) ir_if(operand(r34E4).val);
                                       exec_list *const f34E3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f34E3->then_instructions;

                                          body.emit(assign(r34DC, lshift(r3486, r34DF), 0x01));

                                          ir_expression *const r34E5 = lshift(r3485, r34DF);
                                          ir_expression *const r34E6 = rshift(r3486, r34DB);
                                          body.emit(assign(r34DD, bit_or(r34E5, r34E6), 0x01));

                                          body.emit(assign(r34DE, rshift(r3485, r34DB), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f34E3->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r34E8 = equal(r34DB, body.constant(int(32)));
                                          ir_if *f34E7 = new(mem_ctx) ir_if(operand(r34E8).val);
                                          exec_list *const f34E7_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f34E7->then_instructions;

                                             body.emit(assign(r34DC, r3486, 0x01));

                                             body.emit(assign(r34DD, r3485, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f34E7->else_instructions;

                                             body.emit(assign(r34DA, bit_or(r3487, r3486), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r34EA = less(r34DB, body.constant(int(64)));
                                             ir_if *f34E9 = new(mem_ctx) ir_if(operand(r34EA).val);
                                             exec_list *const f34E9_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f34E9->then_instructions;

                                                body.emit(assign(r34DC, lshift(r3485, r34DF), 0x01));

                                                ir_expression *const r34EB = bit_and(r34DB, body.constant(int(31)));
                                                body.emit(assign(r34DD, rshift(r3485, r34EB), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f34E9->else_instructions;

                                                ir_variable *const r34EC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r34EE = equal(r34DB, body.constant(int(64)));
                                                ir_if *f34ED = new(mem_ctx) ir_if(operand(r34EE).val);
                                                exec_list *const f34ED_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f34ED->then_instructions;

                                                   body.emit(assign(r34EC, r3485, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f34ED->else_instructions;

                                                   ir_expression *const r34EF = nequal(r3485, body.constant(0u));
                                                   ir_expression *const r34F0 = expr(ir_unop_b2i, r34EF);
                                                   body.emit(assign(r34EC, expr(ir_unop_i2u, r34F0), 0x01));


                                                body.instructions = f34ED_parent_instructions;
                                                body.emit(f34ED);

                                                /* END IF */

                                                body.emit(assign(r34DC, r34EC, 0x01));

                                                body.emit(assign(r34DD, body.constant(0u), 0x01));


                                             body.instructions = f34E9_parent_instructions;
                                             body.emit(f34E9);

                                             /* END IF */


                                          body.instructions = f34E7_parent_instructions;
                                          body.emit(f34E7);

                                          /* END IF */

                                          body.emit(assign(r34DE, body.constant(0u), 0x01));


                                       body.instructions = f34E3_parent_instructions;
                                       body.emit(f34E3);

                                       /* END IF */

                                       ir_expression *const r34F1 = nequal(r34DA, body.constant(0u));
                                       ir_expression *const r34F2 = expr(ir_unop_b2i, r34F1);
                                       ir_expression *const r34F3 = expr(ir_unop_i2u, r34F2);
                                       body.emit(assign(r34DC, bit_or(r34DC, r34F3), 0x01));


                                    body.instructions = f34E1_parent_instructions;
                                    body.emit(f34E1);

                                    /* END IF */

                                    body.emit(assign(r34C4, r34DE, 0x01));

                                    body.emit(assign(r34C5, r34DD, 0x01));

                                    body.emit(assign(r34C6, r34DC, 0x01));

                                    body.emit(assign(r34C3, body.constant(int(0)), 0x01));

                                    body.emit(assign(r34C9, less(r34DC, body.constant(0u)), 0x01));


                                 body.instructions = f34D8_parent_instructions;
                                 body.emit(f34D8);

                                 /* END IF */


                              body.instructions = f34D5_parent_instructions;
                              body.emit(f34D5);

                              /* END IF */


                           body.instructions = f34CB_parent_instructions;
                           body.emit(f34CB);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f34F4 = new(mem_ctx) ir_if(operand(r34C7).val);
                           exec_list *const f34F4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f34F4->then_instructions;

                              /* IF CONDITION */
                              ir_if *f34F5 = new(mem_ctx) ir_if(operand(r34C9).val);
                              exec_list *const f34F5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f34F5->then_instructions;

                                 ir_variable *const r34F6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r34F6, add(r34C5, body.constant(1u)), 0x01));

                                 ir_expression *const r34F7 = less(r34F6, r34C5);
                                 ir_expression *const r34F8 = expr(ir_unop_b2i, r34F7);
                                 ir_expression *const r34F9 = expr(ir_unop_i2u, r34F8);
                                 body.emit(assign(r34C4, add(r34C4, r34F9), 0x01));

                                 ir_expression *const r34FA = equal(r34C6, body.constant(0u));
                                 ir_expression *const r34FB = expr(ir_unop_b2i, r34FA);
                                 ir_expression *const r34FC = expr(ir_unop_i2u, r34FB);
                                 ir_expression *const r34FD = add(r34C6, r34FC);
                                 ir_expression *const r34FE = bit_and(r34FD, body.constant(1u));
                                 ir_expression *const r34FF = expr(ir_unop_bit_not, r34FE);
                                 body.emit(assign(r34C5, bit_and(r34F6, r34FF), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f34F5->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3501 = bit_or(r34C4, r34C5);
                                 ir_expression *const r3502 = equal(r3501, body.constant(0u));
                                 ir_if *f3500 = new(mem_ctx) ir_if(operand(r3502).val);
                                 exec_list *const f3500_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3500->then_instructions;

                                    body.emit(assign(r34C3, body.constant(int(0)), 0x01));


                                 body.instructions = f3500_parent_instructions;
                                 body.emit(f3500);

                                 /* END IF */


                              body.instructions = f34F5_parent_instructions;
                              body.emit(f34F5);

                              /* END IF */

                              ir_variable *const r3503 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3503);
                              ir_expression *const r3504 = lshift(r319B, body.constant(int(31)));
                              ir_expression *const r3505 = expr(ir_unop_i2u, r34C3);
                              ir_expression *const r3506 = lshift(r3505, body.constant(int(20)));
                              ir_expression *const r3507 = add(r3504, r3506);
                              body.emit(assign(r3503, add(r3507, r34C4), 0x02));

                              body.emit(assign(r3503, r34C5, 0x01));

                              body.emit(assign(r34C8, r3503, 0x03));

                              body.emit(assign(r34C7, body.constant(false), 0x01));


                           body.instructions = f34F4_parent_instructions;
                           body.emit(f34F4);

                           /* END IF */

                           body.emit(assign(r319C, r34C8, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f347C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3509 = less(r31A3, r31A1);
                           ir_if *f3508 = new(mem_ctx) ir_if(operand(r3509).val);
                           exec_list *const f3508_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3508->then_instructions;

                              ir_variable *const r350A = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r350B = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r350B, sub(r31A1, r31A3), 0x01));

                              ir_expression *const r350C = sub(r31A0, r31A2);
                              ir_expression *const r350D = less(r31A1, r31A3);
                              ir_expression *const r350E = expr(ir_unop_b2i, r350D);
                              ir_expression *const r350F = expr(ir_unop_i2u, r350E);
                              body.emit(assign(r350A, sub(r350C, r350F), 0x01));

                              body.emit(assign(r319B, bit_xor(r319B, body.constant(1u)), 0x01));

                              body.emit(assign(r31A4, add(r319E, body.constant(int(-1))), 0x01));

                              ir_variable *const r3510 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r3510, add(r31A4, body.constant(int(-10))), 0x01));

                              ir_variable *const r3511 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r3511, r350A, 0x01));

                              ir_variable *const r3512 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r3512, r350B, 0x01));

                              ir_variable *const r3513 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r3513);
                              ir_variable *const r3514 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r3514);
                              /* IF CONDITION */
                              ir_expression *const r3516 = equal(r350A, body.constant(0u));
                              ir_if *f3515 = new(mem_ctx) ir_if(operand(r3516).val);
                              exec_list *const f3515_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3515->then_instructions;

                                 body.emit(assign(r3511, r350B, 0x01));

                                 body.emit(assign(r3512, body.constant(0u), 0x01));

                                 body.emit(assign(r3510, add(r3510, body.constant(int(-32))), 0x01));


                              body.instructions = f3515_parent_instructions;
                              body.emit(f3515);

                              /* END IF */

                              ir_variable *const r3517 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r3517, r3511, 0x01));

                              ir_variable *const r3518 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r3519 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r3519);
                              /* IF CONDITION */
                              ir_expression *const r351B = equal(r3511, body.constant(0u));
                              ir_if *f351A = new(mem_ctx) ir_if(operand(r351B).val);
                              exec_list *const f351A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f351A->then_instructions;

                                 body.emit(assign(r3518, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f351A->else_instructions;

                                 body.emit(assign(r3519, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r351D = bit_and(r3511, body.constant(4294901760u));
                                 ir_expression *const r351E = equal(r351D, body.constant(0u));
                                 ir_if *f351C = new(mem_ctx) ir_if(operand(r351E).val);
                                 exec_list *const f351C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f351C->then_instructions;

                                    body.emit(assign(r3519, body.constant(int(16)), 0x01));

                                    body.emit(assign(r3517, lshift(r3511, body.constant(int(16))), 0x01));


                                 body.instructions = f351C_parent_instructions;
                                 body.emit(f351C);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r3520 = bit_and(r3517, body.constant(4278190080u));
                                 ir_expression *const r3521 = equal(r3520, body.constant(0u));
                                 ir_if *f351F = new(mem_ctx) ir_if(operand(r3521).val);
                                 exec_list *const f351F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f351F->then_instructions;

                                    body.emit(assign(r3519, add(r3519, body.constant(int(8))), 0x01));

                                    body.emit(assign(r3517, lshift(r3517, body.constant(int(8))), 0x01));


                                 body.instructions = f351F_parent_instructions;
                                 body.emit(f351F);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r3523 = bit_and(r3517, body.constant(4026531840u));
                                 ir_expression *const r3524 = equal(r3523, body.constant(0u));
                                 ir_if *f3522 = new(mem_ctx) ir_if(operand(r3524).val);
                                 exec_list *const f3522_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3522->then_instructions;

                                    body.emit(assign(r3519, add(r3519, body.constant(int(4))), 0x01));

                                    body.emit(assign(r3517, lshift(r3517, body.constant(int(4))), 0x01));


                                 body.instructions = f3522_parent_instructions;
                                 body.emit(f3522);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r3526 = bit_and(r3517, body.constant(3221225472u));
                                 ir_expression *const r3527 = equal(r3526, body.constant(0u));
                                 ir_if *f3525 = new(mem_ctx) ir_if(operand(r3527).val);
                                 exec_list *const f3525_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3525->then_instructions;

                                    body.emit(assign(r3519, add(r3519, body.constant(int(2))), 0x01));

                                    body.emit(assign(r3517, lshift(r3517, body.constant(int(2))), 0x01));


                                 body.instructions = f3525_parent_instructions;
                                 body.emit(f3525);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r3529 = bit_and(r3517, body.constant(2147483648u));
                                 ir_expression *const r352A = equal(r3529, body.constant(0u));
                                 ir_if *f3528 = new(mem_ctx) ir_if(operand(r352A).val);
                                 exec_list *const f3528_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3528->then_instructions;

                                    body.emit(assign(r3519, add(r3519, body.constant(int(1))), 0x01));


                                 body.instructions = f3528_parent_instructions;
                                 body.emit(f3528);

                                 /* END IF */

                                 body.emit(assign(r3518, r3519, 0x01));


                              body.instructions = f351A_parent_instructions;
                              body.emit(f351A);

                              /* END IF */

                              body.emit(assign(r3514, add(r3518, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r352C = lequal(body.constant(int(0)), r3514);
                              ir_if *f352B = new(mem_ctx) ir_if(operand(r352C).val);
                              exec_list *const f352B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f352B->then_instructions;

                                 body.emit(assign(r3513, body.constant(0u), 0x01));

                                 ir_variable *const r352D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r352D, lshift(r3512, r3514), 0x01));

                                 ir_variable *const r352E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3530 = equal(r3514, body.constant(int(0)));
                                 ir_if *f352F = new(mem_ctx) ir_if(operand(r3530).val);
                                 exec_list *const f352F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f352F->then_instructions;

                                    body.emit(assign(r352E, r3511, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f352F->else_instructions;

                                    ir_expression *const r3531 = lshift(r3511, r3514);
                                    ir_expression *const r3532 = neg(r3514);
                                    ir_expression *const r3533 = bit_and(r3532, body.constant(int(31)));
                                    ir_expression *const r3534 = rshift(r3512, r3533);
                                    body.emit(assign(r352E, bit_or(r3531, r3534), 0x01));


                                 body.instructions = f352F_parent_instructions;
                                 body.emit(f352F);

                                 /* END IF */

                                 body.emit(assign(r3511, r352E, 0x01));

                                 body.emit(assign(r3512, r352D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f352B->else_instructions;

                                 ir_variable *const r3535 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r3535, body.constant(0u), 0x01));

                                 ir_variable *const r3536 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r3536, neg(r3514), 0x01));

                                 ir_variable *const r3537 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r3537);
                                 ir_variable *const r3538 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r3538);
                                 ir_variable *const r3539 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r3539);
                                 ir_variable *const r353A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r353B = neg(r3536);
                                 body.emit(assign(r353A, bit_and(r353B, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r353D = equal(r3536, body.constant(int(0)));
                                 ir_if *f353C = new(mem_ctx) ir_if(operand(r353D).val);
                                 exec_list *const f353C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f353C->then_instructions;

                                    body.emit(assign(r3537, r3535, 0x01));

                                    body.emit(assign(r3538, r3512, 0x01));

                                    body.emit(assign(r3539, r3511, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f353C->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r353F = less(r3536, body.constant(int(32)));
                                    ir_if *f353E = new(mem_ctx) ir_if(operand(r353F).val);
                                    exec_list *const f353E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f353E->then_instructions;

                                       body.emit(assign(r3537, lshift(r3512, r353A), 0x01));

                                       ir_expression *const r3540 = lshift(r3511, r353A);
                                       ir_expression *const r3541 = rshift(r3512, r3536);
                                       body.emit(assign(r3538, bit_or(r3540, r3541), 0x01));

                                       body.emit(assign(r3539, rshift(r3511, r3536), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f353E->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r3543 = equal(r3536, body.constant(int(32)));
                                       ir_if *f3542 = new(mem_ctx) ir_if(operand(r3543).val);
                                       exec_list *const f3542_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3542->then_instructions;

                                          body.emit(assign(r3537, r3512, 0x01));

                                          body.emit(assign(r3538, r3511, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3542->else_instructions;

                                          body.emit(assign(r3535, bit_or(body.constant(0u), r3512), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r3545 = less(r3536, body.constant(int(64)));
                                          ir_if *f3544 = new(mem_ctx) ir_if(operand(r3545).val);
                                          exec_list *const f3544_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3544->then_instructions;

                                             body.emit(assign(r3537, lshift(r3511, r353A), 0x01));

                                             ir_expression *const r3546 = bit_and(r3536, body.constant(int(31)));
                                             body.emit(assign(r3538, rshift(r3511, r3546), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3544->else_instructions;

                                             ir_variable *const r3547 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r3549 = equal(r3536, body.constant(int(64)));
                                             ir_if *f3548 = new(mem_ctx) ir_if(operand(r3549).val);
                                             exec_list *const f3548_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3548->then_instructions;

                                                body.emit(assign(r3547, r3511, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3548->else_instructions;

                                                ir_expression *const r354A = nequal(r3511, body.constant(0u));
                                                ir_expression *const r354B = expr(ir_unop_b2i, r354A);
                                                body.emit(assign(r3547, expr(ir_unop_i2u, r354B), 0x01));


                                             body.instructions = f3548_parent_instructions;
                                             body.emit(f3548);

                                             /* END IF */

                                             body.emit(assign(r3537, r3547, 0x01));

                                             body.emit(assign(r3538, body.constant(0u), 0x01));


                                          body.instructions = f3544_parent_instructions;
                                          body.emit(f3544);

                                          /* END IF */


                                       body.instructions = f3542_parent_instructions;
                                       body.emit(f3542);

                                       /* END IF */

                                       body.emit(assign(r3539, body.constant(0u), 0x01));


                                    body.instructions = f353E_parent_instructions;
                                    body.emit(f353E);

                                    /* END IF */

                                    ir_expression *const r354C = nequal(r3535, body.constant(0u));
                                    ir_expression *const r354D = expr(ir_unop_b2i, r354C);
                                    ir_expression *const r354E = expr(ir_unop_i2u, r354D);
                                    body.emit(assign(r3537, bit_or(r3537, r354E), 0x01));


                                 body.instructions = f353C_parent_instructions;
                                 body.emit(f353C);

                                 /* END IF */

                                 body.emit(assign(r3511, r3539, 0x01));

                                 body.emit(assign(r3512, r3538, 0x01));

                                 body.emit(assign(r3513, r3537, 0x01));


                              body.instructions = f352B_parent_instructions;
                              body.emit(f352B);

                              /* END IF */

                              body.emit(assign(r3510, sub(r3510, r3514), 0x01));

                              ir_variable *const r354F = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r354F, r3510, 0x01));

                              ir_variable *const r3550 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r3550, r3511, 0x01));

                              ir_variable *const r3551 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r3551, r3512, 0x01));

                              ir_variable *const r3552 = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r3552, r3513, 0x01));

                              ir_variable *const r3553 = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r3553, body.constant(true), 0x01));

                              ir_variable *const r3554 = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r3555 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r3555);
                              ir_expression *const r3556 = expr(ir_unop_u2i, r3513);
                              body.emit(assign(r3555, less(r3556, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3558 = lequal(body.constant(int(2045)), r3510);
                              ir_if *f3557 = new(mem_ctx) ir_if(operand(r3558).val);
                              exec_list *const f3557_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3557->then_instructions;

                                 ir_variable *const r3559 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r355B = less(body.constant(int(2045)), r3510);
                                 ir_if *f355A = new(mem_ctx) ir_if(operand(r355B).val);
                                 exec_list *const f355A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f355A->then_instructions;

                                    body.emit(assign(r3559, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f355A->else_instructions;

                                    ir_variable *const r355C = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r355E = equal(r3510, body.constant(int(2045)));
                                    ir_if *f355D = new(mem_ctx) ir_if(operand(r355E).val);
                                    exec_list *const f355D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f355D->then_instructions;

                                       ir_expression *const r355F = equal(body.constant(2097151u), r3511);
                                       ir_expression *const r3560 = equal(body.constant(4294967295u), r3512);
                                       body.emit(assign(r355C, logic_and(r355F, r3560), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f355D->else_instructions;

                                       body.emit(assign(r355C, body.constant(false), 0x01));


                                    body.instructions = f355D_parent_instructions;
                                    body.emit(f355D);

                                    /* END IF */

                                    body.emit(assign(r3559, logic_and(r355C, r3555), 0x01));


                                 body.instructions = f355A_parent_instructions;
                                 body.emit(f355A);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f3561 = new(mem_ctx) ir_if(operand(r3559).val);
                                 exec_list *const f3561_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3561->then_instructions;

                                    ir_variable *const r3562 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r3562);
                                    ir_expression *const r3563 = lshift(r319B, body.constant(int(31)));
                                    body.emit(assign(r3562, add(r3563, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r3562, body.constant(0u), 0x01));

                                    body.emit(assign(r3554, r3562, 0x03));

                                    body.emit(assign(r3553, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3561->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3565 = less(r3510, body.constant(int(0)));
                                    ir_if *f3564 = new(mem_ctx) ir_if(operand(r3565).val);
                                    exec_list *const f3564_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3564->then_instructions;

                                       ir_variable *const r3566 = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r3566, r3513, 0x01));

                                       ir_variable *const r3567 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r3567, neg(r3510), 0x01));

                                       ir_variable *const r3568 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r3568);
                                       ir_variable *const r3569 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r3569);
                                       ir_variable *const r356A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r356A);
                                       ir_variable *const r356B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r356C = neg(r3567);
                                       body.emit(assign(r356B, bit_and(r356C, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r356E = equal(r3567, body.constant(int(0)));
                                       ir_if *f356D = new(mem_ctx) ir_if(operand(r356E).val);
                                       exec_list *const f356D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f356D->then_instructions;

                                          body.emit(assign(r3568, r3513, 0x01));

                                          body.emit(assign(r3569, r3512, 0x01));

                                          body.emit(assign(r356A, r3511, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f356D->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r3570 = less(r3567, body.constant(int(32)));
                                          ir_if *f356F = new(mem_ctx) ir_if(operand(r3570).val);
                                          exec_list *const f356F_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f356F->then_instructions;

                                             body.emit(assign(r3568, lshift(r3512, r356B), 0x01));

                                             ir_expression *const r3571 = lshift(r3511, r356B);
                                             ir_expression *const r3572 = rshift(r3512, r3567);
                                             body.emit(assign(r3569, bit_or(r3571, r3572), 0x01));

                                             body.emit(assign(r356A, rshift(r3511, r3567), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f356F->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r3574 = equal(r3567, body.constant(int(32)));
                                             ir_if *f3573 = new(mem_ctx) ir_if(operand(r3574).val);
                                             exec_list *const f3573_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3573->then_instructions;

                                                body.emit(assign(r3568, r3512, 0x01));

                                                body.emit(assign(r3569, r3511, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3573->else_instructions;

                                                body.emit(assign(r3566, bit_or(r3513, r3512), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r3576 = less(r3567, body.constant(int(64)));
                                                ir_if *f3575 = new(mem_ctx) ir_if(operand(r3576).val);
                                                exec_list *const f3575_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f3575->then_instructions;

                                                   body.emit(assign(r3568, lshift(r3511, r356B), 0x01));

                                                   ir_expression *const r3577 = bit_and(r3567, body.constant(int(31)));
                                                   body.emit(assign(r3569, rshift(r3511, r3577), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f3575->else_instructions;

                                                   ir_variable *const r3578 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r357A = equal(r3567, body.constant(int(64)));
                                                   ir_if *f3579 = new(mem_ctx) ir_if(operand(r357A).val);
                                                   exec_list *const f3579_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f3579->then_instructions;

                                                      body.emit(assign(r3578, r3511, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f3579->else_instructions;

                                                      ir_expression *const r357B = nequal(r3511, body.constant(0u));
                                                      ir_expression *const r357C = expr(ir_unop_b2i, r357B);
                                                      body.emit(assign(r3578, expr(ir_unop_i2u, r357C), 0x01));


                                                   body.instructions = f3579_parent_instructions;
                                                   body.emit(f3579);

                                                   /* END IF */

                                                   body.emit(assign(r3568, r3578, 0x01));

                                                   body.emit(assign(r3569, body.constant(0u), 0x01));


                                                body.instructions = f3575_parent_instructions;
                                                body.emit(f3575);

                                                /* END IF */


                                             body.instructions = f3573_parent_instructions;
                                             body.emit(f3573);

                                             /* END IF */

                                             body.emit(assign(r356A, body.constant(0u), 0x01));


                                          body.instructions = f356F_parent_instructions;
                                          body.emit(f356F);

                                          /* END IF */

                                          ir_expression *const r357D = nequal(r3566, body.constant(0u));
                                          ir_expression *const r357E = expr(ir_unop_b2i, r357D);
                                          ir_expression *const r357F = expr(ir_unop_i2u, r357E);
                                          body.emit(assign(r3568, bit_or(r3568, r357F), 0x01));


                                       body.instructions = f356D_parent_instructions;
                                       body.emit(f356D);

                                       /* END IF */

                                       body.emit(assign(r3550, r356A, 0x01));

                                       body.emit(assign(r3551, r3569, 0x01));

                                       body.emit(assign(r3552, r3568, 0x01));

                                       body.emit(assign(r354F, body.constant(int(0)), 0x01));

                                       body.emit(assign(r3555, less(r3568, body.constant(0u)), 0x01));


                                    body.instructions = f3564_parent_instructions;
                                    body.emit(f3564);

                                    /* END IF */


                                 body.instructions = f3561_parent_instructions;
                                 body.emit(f3561);

                                 /* END IF */


                              body.instructions = f3557_parent_instructions;
                              body.emit(f3557);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f3580 = new(mem_ctx) ir_if(operand(r3553).val);
                              exec_list *const f3580_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3580->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f3581 = new(mem_ctx) ir_if(operand(r3555).val);
                                 exec_list *const f3581_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3581->then_instructions;

                                    ir_variable *const r3582 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r3582, add(r3551, body.constant(1u)), 0x01));

                                    ir_expression *const r3583 = less(r3582, r3551);
                                    ir_expression *const r3584 = expr(ir_unop_b2i, r3583);
                                    ir_expression *const r3585 = expr(ir_unop_i2u, r3584);
                                    body.emit(assign(r3550, add(r3550, r3585), 0x01));

                                    ir_expression *const r3586 = equal(r3552, body.constant(0u));
                                    ir_expression *const r3587 = expr(ir_unop_b2i, r3586);
                                    ir_expression *const r3588 = expr(ir_unop_i2u, r3587);
                                    ir_expression *const r3589 = add(r3552, r3588);
                                    ir_expression *const r358A = bit_and(r3589, body.constant(1u));
                                    ir_expression *const r358B = expr(ir_unop_bit_not, r358A);
                                    body.emit(assign(r3551, bit_and(r3582, r358B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3581->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r358D = bit_or(r3550, r3551);
                                    ir_expression *const r358E = equal(r358D, body.constant(0u));
                                    ir_if *f358C = new(mem_ctx) ir_if(operand(r358E).val);
                                    exec_list *const f358C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f358C->then_instructions;

                                       body.emit(assign(r354F, body.constant(int(0)), 0x01));


                                    body.instructions = f358C_parent_instructions;
                                    body.emit(f358C);

                                    /* END IF */


                                 body.instructions = f3581_parent_instructions;
                                 body.emit(f3581);

                                 /* END IF */

                                 ir_variable *const r358F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r358F);
                                 ir_expression *const r3590 = lshift(r319B, body.constant(int(31)));
                                 ir_expression *const r3591 = expr(ir_unop_i2u, r354F);
                                 ir_expression *const r3592 = lshift(r3591, body.constant(int(20)));
                                 ir_expression *const r3593 = add(r3590, r3592);
                                 body.emit(assign(r358F, add(r3593, r3550), 0x02));

                                 body.emit(assign(r358F, r3551, 0x01));

                                 body.emit(assign(r3554, r358F, 0x03));

                                 body.emit(assign(r3553, body.constant(false), 0x01));


                              body.instructions = f3580_parent_instructions;
                              body.emit(f3580);

                              /* END IF */

                              body.emit(assign(r319C, r3554, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3508->else_instructions;

                              ir_variable *const r3594 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3594);
                              body.emit(assign(r3594, body.constant(0u), 0x02));

                              body.emit(assign(r3594, body.constant(0u), 0x01));

                              body.emit(assign(r319C, r3594, 0x03));


                           body.instructions = f3508_parent_instructions;
                           body.emit(f3508);

                           /* END IF */


                        body.instructions = f347C_parent_instructions;
                        body.emit(f347C);

                        /* END IF */


                     body.instructions = f33F0_parent_instructions;
                     body.emit(f33F0);

                     /* END IF */


                  body.instructions = f3364_parent_instructions;
                  body.emit(f3364);

                  /* END IF */


               body.instructions = f3343_parent_instructions;
               body.emit(f3343);

               /* END IF */


            body.instructions = f3275_parent_instructions;
            body.emit(f3275);

            /* END IF */


         body.instructions = f31B0_parent_instructions;
         body.emit(f31B0);

         /* END IF */

         body.emit(assign(r3002, r319C, 0x03));


      body.instructions = f3005_parent_instructions;
      body.emit(f3005);

      /* END IF */

      body.emit(assign(r2FFF, r3002, 0x03));


   body.instructions = f3000_parent_instructions;
   body.emit(f3000);

   /* END IF */

   ir_variable *const r3595 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r3595, body.constant(true), 0x01));

   ir_variable *const r3596 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r3597 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r3597);
   ir_variable *const r3598 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r3598);
   ir_variable *const r3599 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r3599);
   ir_variable *const r359A = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r359A);
   ir_variable *const r359B = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r359B);
   ir_variable *const r359C = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r359C);
   ir_variable *const r359D = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r359D);
   ir_variable *const r359E = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r359E);
   ir_variable *const r359F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r359F);
   ir_variable *const r35A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r35A0);
   ir_variable *const r35A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r35A1);
   body.emit(assign(r35A1, body.constant(0u), 0x01));

   body.emit(assign(r35A0, body.constant(0u), 0x01));

   body.emit(assign(r359F, body.constant(0u), 0x01));

   ir_variable *const r35A2 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r35A2, swizzle_x(r2D5B), 0x01));

   body.emit(assign(r359D, r35A2, 0x01));

   ir_variable *const r35A3 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r35A3, bit_and(swizzle_y(r2D5B), body.constant(1048575u)), 0x01));

   body.emit(assign(r359C, r35A3, 0x01));

   ir_variable *const r35A4 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r35A4, swizzle_x(r2FFF), 0x01));

   body.emit(assign(r359B, r35A4, 0x01));

   ir_variable *const r35A5 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r35A5, bit_and(swizzle_y(r2FFF), body.constant(1048575u)), 0x01));

   body.emit(assign(r359A, r35A5, 0x01));

   ir_variable *const r35A6 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r35A7 = rshift(swizzle_y(r2D5B), body.constant(int(20)));
   ir_expression *const r35A8 = bit_and(r35A7, body.constant(2047u));
   body.emit(assign(r35A6, expr(ir_unop_u2i, r35A8), 0x01));

   body.emit(assign(r3599, r35A6, 0x01));

   ir_variable *const r35A9 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r35AA = rshift(swizzle_y(r2FFF), body.constant(int(20)));
   ir_expression *const r35AB = bit_and(r35AA, body.constant(2047u));
   body.emit(assign(r35A9, expr(ir_unop_u2i, r35AB), 0x01));

   body.emit(assign(r3598, r35A9, 0x01));

   ir_expression *const r35AC = rshift(swizzle_y(r2D5B), body.constant(int(31)));
   ir_expression *const r35AD = rshift(swizzle_y(r2FFF), body.constant(int(31)));
   body.emit(assign(r3597, bit_xor(r35AC, r35AD), 0x01));

   /* IF CONDITION */
   ir_expression *const r35AF = equal(r35A6, body.constant(int(2047)));
   ir_if *f35AE = new(mem_ctx) ir_if(operand(r35AF).val);
   exec_list *const f35AE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f35AE->then_instructions;

      /* IF CONDITION */
      ir_expression *const r35B1 = bit_or(r35A3, swizzle_x(r2D5B));
      ir_expression *const r35B2 = nequal(r35B1, body.constant(0u));
      ir_expression *const r35B3 = equal(r35A9, body.constant(int(2047)));
      ir_expression *const r35B4 = bit_or(r35A5, swizzle_x(r2FFF));
      ir_expression *const r35B5 = nequal(r35B4, body.constant(0u));
      ir_expression *const r35B6 = logic_and(r35B3, r35B5);
      ir_expression *const r35B7 = logic_or(r35B2, r35B6);
      ir_if *f35B0 = new(mem_ctx) ir_if(operand(r35B7).val);
      exec_list *const f35B0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f35B0->then_instructions;

         ir_variable *const r35B8 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r35B8, swizzle_x(r2D5B), 0x01));

         ir_variable *const r35B9 = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r35B9, swizzle_x(r2FFF), 0x01));

         ir_variable *const r35BA = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r35BB = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r35BC = rshift(swizzle_y(r2D5B), body.constant(int(19)));
         ir_expression *const r35BD = bit_and(r35BC, body.constant(4095u));
         ir_expression *const r35BE = equal(r35BD, body.constant(4094u));
         ir_expression *const r35BF = nequal(swizzle_x(r2D5B), body.constant(0u));
         ir_expression *const r35C0 = bit_and(swizzle_y(r2D5B), body.constant(524287u));
         ir_expression *const r35C1 = nequal(r35C0, body.constant(0u));
         ir_expression *const r35C2 = logic_or(r35BF, r35C1);
         body.emit(assign(r35BB, logic_and(r35BE, r35C2), 0x01));

         ir_variable *const r35C3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r35C4 = lshift(swizzle_y(r2FFF), body.constant(int(1)));
         ir_expression *const r35C5 = lequal(body.constant(4292870144u), r35C4);
         ir_expression *const r35C6 = nequal(swizzle_x(r2FFF), body.constant(0u));
         ir_expression *const r35C7 = bit_and(swizzle_y(r2FFF), body.constant(1048575u));
         ir_expression *const r35C8 = nequal(r35C7, body.constant(0u));
         ir_expression *const r35C9 = logic_or(r35C6, r35C8);
         body.emit(assign(r35C3, logic_and(r35C5, r35C9), 0x01));

         body.emit(assign(r35B8, bit_or(swizzle_y(r2D5B), body.constant(524288u)), 0x02));

         body.emit(assign(r35B9, bit_or(swizzle_y(r2FFF), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r35CB = lshift(swizzle_y(r2D5B), body.constant(int(1)));
         ir_expression *const r35CC = lequal(body.constant(4292870144u), r35CB);
         ir_expression *const r35CD = nequal(swizzle_x(r2D5B), body.constant(0u));
         ir_expression *const r35CE = bit_and(swizzle_y(r2D5B), body.constant(1048575u));
         ir_expression *const r35CF = nequal(r35CE, body.constant(0u));
         ir_expression *const r35D0 = logic_or(r35CD, r35CF);
         ir_expression *const r35D1 = logic_and(r35CC, r35D0);
         ir_if *f35CA = new(mem_ctx) ir_if(operand(r35D1).val);
         exec_list *const f35CA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f35CA->then_instructions;

            ir_variable *const r35D2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r35D4 = logic_and(r35BB, r35C3);
            ir_if *f35D3 = new(mem_ctx) ir_if(operand(r35D4).val);
            exec_list *const f35D3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f35D3->then_instructions;

               body.emit(assign(r35D2, r35B9, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f35D3->else_instructions;

               body.emit(assign(r35D2, r35B8, 0x03));


            body.instructions = f35D3_parent_instructions;
            body.emit(f35D3);

            /* END IF */

            body.emit(assign(r35BA, r35D2, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f35CA->else_instructions;

            body.emit(assign(r35BA, r35B9, 0x03));


         body.instructions = f35CA_parent_instructions;
         body.emit(f35CA);

         /* END IF */

         body.emit(assign(r3596, r35BA, 0x03));

         body.emit(assign(r3595, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f35B0->else_instructions;

         /* IF CONDITION */
         ir_expression *const r35D6 = expr(ir_unop_i2u, r35A9);
         ir_expression *const r35D7 = bit_or(r35D6, r35A5);
         ir_expression *const r35D8 = bit_or(r35D7, swizzle_x(r2FFF));
         ir_expression *const r35D9 = equal(r35D8, body.constant(0u));
         ir_if *f35D5 = new(mem_ctx) ir_if(operand(r35D9).val);
         exec_list *const f35D5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f35D5->then_instructions;

            ir_constant_data r35DA_data;
            memset(&r35DA_data, 0, sizeof(ir_constant_data));
            r35DA_data.u[0] = 4294967295;
            r35DA_data.u[1] = 4294967295;
            ir_constant *const r35DA = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r35DA_data);
            body.emit(assign(r3596, r35DA, 0x03));

            body.emit(assign(r3595, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f35D5->else_instructions;

            ir_variable *const r35DB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r35DB);
            ir_expression *const r35DC = lshift(r3597, body.constant(int(31)));
            body.emit(assign(r35DB, add(r35DC, body.constant(2146435072u)), 0x02));

            body.emit(assign(r35DB, body.constant(0u), 0x01));

            body.emit(assign(r3596, r35DB, 0x03));

            body.emit(assign(r3595, body.constant(false), 0x01));


         body.instructions = f35D5_parent_instructions;
         body.emit(f35D5);

         /* END IF */


      body.instructions = f35B0_parent_instructions;
      body.emit(f35B0);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f35AE->else_instructions;

      /* IF CONDITION */
      ir_expression *const r35DE = equal(r35A9, body.constant(int(2047)));
      ir_if *f35DD = new(mem_ctx) ir_if(operand(r35DE).val);
      exec_list *const f35DD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f35DD->then_instructions;

         /* IF CONDITION */
         ir_expression *const r35E0 = bit_or(r35A5, swizzle_x(r2FFF));
         ir_expression *const r35E1 = nequal(r35E0, body.constant(0u));
         ir_if *f35DF = new(mem_ctx) ir_if(operand(r35E1).val);
         exec_list *const f35DF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f35DF->then_instructions;

            ir_variable *const r35E2 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r35E2, swizzle_x(r2D5B), 0x01));

            ir_variable *const r35E3 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r35E3, swizzle_x(r2FFF), 0x01));

            ir_variable *const r35E4 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r35E5 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r35E6 = rshift(swizzle_y(r2D5B), body.constant(int(19)));
            ir_expression *const r35E7 = bit_and(r35E6, body.constant(4095u));
            ir_expression *const r35E8 = equal(r35E7, body.constant(4094u));
            ir_expression *const r35E9 = nequal(swizzle_x(r2D5B), body.constant(0u));
            ir_expression *const r35EA = bit_and(swizzle_y(r2D5B), body.constant(524287u));
            ir_expression *const r35EB = nequal(r35EA, body.constant(0u));
            ir_expression *const r35EC = logic_or(r35E9, r35EB);
            body.emit(assign(r35E5, logic_and(r35E8, r35EC), 0x01));

            ir_variable *const r35ED = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r35EE = lshift(swizzle_y(r2FFF), body.constant(int(1)));
            ir_expression *const r35EF = lequal(body.constant(4292870144u), r35EE);
            ir_expression *const r35F0 = nequal(swizzle_x(r2FFF), body.constant(0u));
            ir_expression *const r35F1 = bit_and(swizzle_y(r2FFF), body.constant(1048575u));
            ir_expression *const r35F2 = nequal(r35F1, body.constant(0u));
            ir_expression *const r35F3 = logic_or(r35F0, r35F2);
            body.emit(assign(r35ED, logic_and(r35EF, r35F3), 0x01));

            body.emit(assign(r35E2, bit_or(swizzle_y(r2D5B), body.constant(524288u)), 0x02));

            body.emit(assign(r35E3, bit_or(swizzle_y(r2FFF), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r35F5 = lshift(swizzle_y(r2D5B), body.constant(int(1)));
            ir_expression *const r35F6 = lequal(body.constant(4292870144u), r35F5);
            ir_expression *const r35F7 = nequal(swizzle_x(r2D5B), body.constant(0u));
            ir_expression *const r35F8 = bit_and(swizzle_y(r2D5B), body.constant(1048575u));
            ir_expression *const r35F9 = nequal(r35F8, body.constant(0u));
            ir_expression *const r35FA = logic_or(r35F7, r35F9);
            ir_expression *const r35FB = logic_and(r35F6, r35FA);
            ir_if *f35F4 = new(mem_ctx) ir_if(operand(r35FB).val);
            exec_list *const f35F4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f35F4->then_instructions;

               ir_variable *const r35FC = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r35FE = logic_and(r35E5, r35ED);
               ir_if *f35FD = new(mem_ctx) ir_if(operand(r35FE).val);
               exec_list *const f35FD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f35FD->then_instructions;

                  body.emit(assign(r35FC, r35E3, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f35FD->else_instructions;

                  body.emit(assign(r35FC, r35E2, 0x03));


               body.instructions = f35FD_parent_instructions;
               body.emit(f35FD);

               /* END IF */

               body.emit(assign(r35E4, r35FC, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f35F4->else_instructions;

               body.emit(assign(r35E4, r35E3, 0x03));


            body.instructions = f35F4_parent_instructions;
            body.emit(f35F4);

            /* END IF */

            body.emit(assign(r3596, r35E4, 0x03));

            body.emit(assign(r3595, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f35DF->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3600 = expr(ir_unop_i2u, r35A6);
            ir_expression *const r3601 = bit_or(r3600, r35A3);
            ir_expression *const r3602 = bit_or(r3601, swizzle_x(r2D5B));
            ir_expression *const r3603 = equal(r3602, body.constant(0u));
            ir_if *f35FF = new(mem_ctx) ir_if(operand(r3603).val);
            exec_list *const f35FF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f35FF->then_instructions;

               ir_constant_data r3604_data;
               memset(&r3604_data, 0, sizeof(ir_constant_data));
               r3604_data.u[0] = 4294967295;
               r3604_data.u[1] = 4294967295;
               ir_constant *const r3604 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3604_data);
               body.emit(assign(r3596, r3604, 0x03));

               body.emit(assign(r3595, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f35FF->else_instructions;

               ir_variable *const r3605 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r3605);
               ir_expression *const r3606 = lshift(r3597, body.constant(int(31)));
               body.emit(assign(r3605, add(r3606, body.constant(2146435072u)), 0x02));

               body.emit(assign(r3605, body.constant(0u), 0x01));

               body.emit(assign(r3596, r3605, 0x03));

               body.emit(assign(r3595, body.constant(false), 0x01));


            body.instructions = f35FF_parent_instructions;
            body.emit(f35FF);

            /* END IF */


         body.instructions = f35DF_parent_instructions;
         body.emit(f35DF);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f35DD->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3608 = equal(r35A6, body.constant(int(0)));
         ir_if *f3607 = new(mem_ctx) ir_if(operand(r3608).val);
         exec_list *const f3607_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3607->then_instructions;

            /* IF CONDITION */
            ir_expression *const r360A = bit_or(r35A3, swizzle_x(r2D5B));
            ir_expression *const r360B = equal(r360A, body.constant(0u));
            ir_if *f3609 = new(mem_ctx) ir_if(operand(r360B).val);
            exec_list *const f3609_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3609->then_instructions;

               ir_variable *const r360C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r360C);
               body.emit(assign(r360C, lshift(r3597, body.constant(int(31))), 0x02));

               body.emit(assign(r360C, body.constant(0u), 0x01));

               body.emit(assign(r3596, r360C, 0x03));

               body.emit(assign(r3595, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3609->else_instructions;

               ir_variable *const r360D = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r360D, r35A6, 0x01));

               ir_variable *const r360E = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r360E, r35A3, 0x01));

               ir_variable *const r360F = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r360F, r35A2, 0x01));

               ir_variable *const r3610 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3610);
               /* IF CONDITION */
               ir_expression *const r3612 = equal(r35A3, body.constant(0u));
               ir_if *f3611 = new(mem_ctx) ir_if(operand(r3612).val);
               exec_list *const f3611_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3611->then_instructions;

                  ir_variable *const r3613 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r3613, r35A2, 0x01));

                  ir_variable *const r3614 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3615 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3615);
                  /* IF CONDITION */
                  ir_expression *const r3617 = equal(swizzle_x(r2D5B), body.constant(0u));
                  ir_if *f3616 = new(mem_ctx) ir_if(operand(r3617).val);
                  exec_list *const f3616_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3616->then_instructions;

                     body.emit(assign(r3614, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3616->else_instructions;

                     body.emit(assign(r3615, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3619 = bit_and(swizzle_x(r2D5B), body.constant(4294901760u));
                     ir_expression *const r361A = equal(r3619, body.constant(0u));
                     ir_if *f3618 = new(mem_ctx) ir_if(operand(r361A).val);
                     exec_list *const f3618_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3618->then_instructions;

                        body.emit(assign(r3615, body.constant(int(16)), 0x01));

                        body.emit(assign(r3613, lshift(swizzle_x(r2D5B), body.constant(int(16))), 0x01));


                     body.instructions = f3618_parent_instructions;
                     body.emit(f3618);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r361C = bit_and(r3613, body.constant(4278190080u));
                     ir_expression *const r361D = equal(r361C, body.constant(0u));
                     ir_if *f361B = new(mem_ctx) ir_if(operand(r361D).val);
                     exec_list *const f361B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f361B->then_instructions;

                        body.emit(assign(r3615, add(r3615, body.constant(int(8))), 0x01));

                        body.emit(assign(r3613, lshift(r3613, body.constant(int(8))), 0x01));


                     body.instructions = f361B_parent_instructions;
                     body.emit(f361B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r361F = bit_and(r3613, body.constant(4026531840u));
                     ir_expression *const r3620 = equal(r361F, body.constant(0u));
                     ir_if *f361E = new(mem_ctx) ir_if(operand(r3620).val);
                     exec_list *const f361E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f361E->then_instructions;

                        body.emit(assign(r3615, add(r3615, body.constant(int(4))), 0x01));

                        body.emit(assign(r3613, lshift(r3613, body.constant(int(4))), 0x01));


                     body.instructions = f361E_parent_instructions;
                     body.emit(f361E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3622 = bit_and(r3613, body.constant(3221225472u));
                     ir_expression *const r3623 = equal(r3622, body.constant(0u));
                     ir_if *f3621 = new(mem_ctx) ir_if(operand(r3623).val);
                     exec_list *const f3621_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3621->then_instructions;

                        body.emit(assign(r3615, add(r3615, body.constant(int(2))), 0x01));

                        body.emit(assign(r3613, lshift(r3613, body.constant(int(2))), 0x01));


                     body.instructions = f3621_parent_instructions;
                     body.emit(f3621);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3625 = bit_and(r3613, body.constant(2147483648u));
                     ir_expression *const r3626 = equal(r3625, body.constant(0u));
                     ir_if *f3624 = new(mem_ctx) ir_if(operand(r3626).val);
                     exec_list *const f3624_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3624->then_instructions;

                        body.emit(assign(r3615, add(r3615, body.constant(int(1))), 0x01));


                     body.instructions = f3624_parent_instructions;
                     body.emit(f3624);

                     /* END IF */

                     body.emit(assign(r3614, r3615, 0x01));


                  body.instructions = f3616_parent_instructions;
                  body.emit(f3616);

                  /* END IF */

                  body.emit(assign(r3610, add(r3614, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3628 = less(r3610, body.constant(int(0)));
                  ir_if *f3627 = new(mem_ctx) ir_if(operand(r3628).val);
                  exec_list *const f3627_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3627->then_instructions;

                     ir_expression *const r3629 = neg(r3610);
                     body.emit(assign(r360E, rshift(swizzle_x(r2D5B), r3629), 0x01));

                     ir_expression *const r362A = bit_and(r3610, body.constant(int(31)));
                     body.emit(assign(r360F, lshift(swizzle_x(r2D5B), r362A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3627->else_instructions;

                     body.emit(assign(r360E, lshift(swizzle_x(r2D5B), r3610), 0x01));

                     body.emit(assign(r360F, body.constant(0u), 0x01));


                  body.instructions = f3627_parent_instructions;
                  body.emit(f3627);

                  /* END IF */

                  body.emit(assign(r360D, sub(body.constant(int(-31)), r3610), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3611->else_instructions;

                  ir_variable *const r362B = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r362B, r35A3, 0x01));

                  ir_variable *const r362C = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r362D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r362D);
                  /* IF CONDITION */
                  ir_expression *const r362F = equal(r35A3, body.constant(0u));
                  ir_if *f362E = new(mem_ctx) ir_if(operand(r362F).val);
                  exec_list *const f362E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f362E->then_instructions;

                     body.emit(assign(r362C, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f362E->else_instructions;

                     body.emit(assign(r362D, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3631 = bit_and(r35A3, body.constant(4294901760u));
                     ir_expression *const r3632 = equal(r3631, body.constant(0u));
                     ir_if *f3630 = new(mem_ctx) ir_if(operand(r3632).val);
                     exec_list *const f3630_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3630->then_instructions;

                        body.emit(assign(r362D, body.constant(int(16)), 0x01));

                        body.emit(assign(r362B, lshift(r35A3, body.constant(int(16))), 0x01));


                     body.instructions = f3630_parent_instructions;
                     body.emit(f3630);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3634 = bit_and(r362B, body.constant(4278190080u));
                     ir_expression *const r3635 = equal(r3634, body.constant(0u));
                     ir_if *f3633 = new(mem_ctx) ir_if(operand(r3635).val);
                     exec_list *const f3633_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3633->then_instructions;

                        body.emit(assign(r362D, add(r362D, body.constant(int(8))), 0x01));

                        body.emit(assign(r362B, lshift(r362B, body.constant(int(8))), 0x01));


                     body.instructions = f3633_parent_instructions;
                     body.emit(f3633);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3637 = bit_and(r362B, body.constant(4026531840u));
                     ir_expression *const r3638 = equal(r3637, body.constant(0u));
                     ir_if *f3636 = new(mem_ctx) ir_if(operand(r3638).val);
                     exec_list *const f3636_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3636->then_instructions;

                        body.emit(assign(r362D, add(r362D, body.constant(int(4))), 0x01));

                        body.emit(assign(r362B, lshift(r362B, body.constant(int(4))), 0x01));


                     body.instructions = f3636_parent_instructions;
                     body.emit(f3636);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r363A = bit_and(r362B, body.constant(3221225472u));
                     ir_expression *const r363B = equal(r363A, body.constant(0u));
                     ir_if *f3639 = new(mem_ctx) ir_if(operand(r363B).val);
                     exec_list *const f3639_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3639->then_instructions;

                        body.emit(assign(r362D, add(r362D, body.constant(int(2))), 0x01));

                        body.emit(assign(r362B, lshift(r362B, body.constant(int(2))), 0x01));


                     body.instructions = f3639_parent_instructions;
                     body.emit(f3639);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r363D = bit_and(r362B, body.constant(2147483648u));
                     ir_expression *const r363E = equal(r363D, body.constant(0u));
                     ir_if *f363C = new(mem_ctx) ir_if(operand(r363E).val);
                     exec_list *const f363C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f363C->then_instructions;

                        body.emit(assign(r362D, add(r362D, body.constant(int(1))), 0x01));


                     body.instructions = f363C_parent_instructions;
                     body.emit(f363C);

                     /* END IF */

                     body.emit(assign(r362C, r362D, 0x01));


                  body.instructions = f362E_parent_instructions;
                  body.emit(f362E);

                  /* END IF */

                  body.emit(assign(r3610, add(r362C, body.constant(int(-11))), 0x01));

                  ir_variable *const r363F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r363F, lshift(swizzle_x(r2D5B), r3610), 0x01));

                  ir_variable *const r3640 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3642 = equal(r3610, body.constant(int(0)));
                  ir_if *f3641 = new(mem_ctx) ir_if(operand(r3642).val);
                  exec_list *const f3641_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3641->then_instructions;

                     body.emit(assign(r3640, r35A3, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3641->else_instructions;

                     ir_expression *const r3643 = lshift(r35A3, r3610);
                     ir_expression *const r3644 = neg(r3610);
                     ir_expression *const r3645 = bit_and(r3644, body.constant(int(31)));
                     ir_expression *const r3646 = rshift(swizzle_x(r2D5B), r3645);
                     body.emit(assign(r3640, bit_or(r3643, r3646), 0x01));


                  body.instructions = f3641_parent_instructions;
                  body.emit(f3641);

                  /* END IF */

                  body.emit(assign(r360E, r3640, 0x01));

                  body.emit(assign(r360F, r363F, 0x01));

                  body.emit(assign(r360D, sub(body.constant(int(1)), r3610), 0x01));


               body.instructions = f3611_parent_instructions;
               body.emit(f3611);

               /* END IF */

               body.emit(assign(r3599, r360D, 0x01));

               body.emit(assign(r359C, r360E, 0x01));

               body.emit(assign(r359D, r360F, 0x01));


            body.instructions = f3609_parent_instructions;
            body.emit(f3609);

            /* END IF */


         body.instructions = f3607_parent_instructions;
         body.emit(f3607);

         /* END IF */

         /* IF CONDITION */
         ir_if *f3647 = new(mem_ctx) ir_if(operand(r3595).val);
         exec_list *const f3647_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3647->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3649 = equal(r35A9, body.constant(int(0)));
            ir_if *f3648 = new(mem_ctx) ir_if(operand(r3649).val);
            exec_list *const f3648_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3648->then_instructions;

               /* IF CONDITION */
               ir_expression *const r364B = bit_or(r35A5, swizzle_x(r2FFF));
               ir_expression *const r364C = equal(r364B, body.constant(0u));
               ir_if *f364A = new(mem_ctx) ir_if(operand(r364C).val);
               exec_list *const f364A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f364A->then_instructions;

                  ir_variable *const r364D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r364D);
                  body.emit(assign(r364D, lshift(r3597, body.constant(int(31))), 0x02));

                  body.emit(assign(r364D, body.constant(0u), 0x01));

                  body.emit(assign(r3596, r364D, 0x03));

                  body.emit(assign(r3595, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f364A->else_instructions;

                  ir_variable *const r364E = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r364E, r35A9, 0x01));

                  ir_variable *const r364F = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r364F, r35A5, 0x01));

                  ir_variable *const r3650 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r3650, r35A4, 0x01));

                  ir_variable *const r3651 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3651);
                  /* IF CONDITION */
                  ir_expression *const r3653 = equal(r35A5, body.constant(0u));
                  ir_if *f3652 = new(mem_ctx) ir_if(operand(r3653).val);
                  exec_list *const f3652_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3652->then_instructions;

                     ir_variable *const r3654 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3654, r35A4, 0x01));

                     ir_variable *const r3655 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3656 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3656);
                     /* IF CONDITION */
                     ir_expression *const r3658 = equal(swizzle_x(r2FFF), body.constant(0u));
                     ir_if *f3657 = new(mem_ctx) ir_if(operand(r3658).val);
                     exec_list *const f3657_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3657->then_instructions;

                        body.emit(assign(r3655, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3657->else_instructions;

                        body.emit(assign(r3656, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r365A = bit_and(swizzle_x(r2FFF), body.constant(4294901760u));
                        ir_expression *const r365B = equal(r365A, body.constant(0u));
                        ir_if *f3659 = new(mem_ctx) ir_if(operand(r365B).val);
                        exec_list *const f3659_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3659->then_instructions;

                           body.emit(assign(r3656, body.constant(int(16)), 0x01));

                           body.emit(assign(r3654, lshift(swizzle_x(r2FFF), body.constant(int(16))), 0x01));


                        body.instructions = f3659_parent_instructions;
                        body.emit(f3659);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r365D = bit_and(r3654, body.constant(4278190080u));
                        ir_expression *const r365E = equal(r365D, body.constant(0u));
                        ir_if *f365C = new(mem_ctx) ir_if(operand(r365E).val);
                        exec_list *const f365C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f365C->then_instructions;

                           body.emit(assign(r3656, add(r3656, body.constant(int(8))), 0x01));

                           body.emit(assign(r3654, lshift(r3654, body.constant(int(8))), 0x01));


                        body.instructions = f365C_parent_instructions;
                        body.emit(f365C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3660 = bit_and(r3654, body.constant(4026531840u));
                        ir_expression *const r3661 = equal(r3660, body.constant(0u));
                        ir_if *f365F = new(mem_ctx) ir_if(operand(r3661).val);
                        exec_list *const f365F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f365F->then_instructions;

                           body.emit(assign(r3656, add(r3656, body.constant(int(4))), 0x01));

                           body.emit(assign(r3654, lshift(r3654, body.constant(int(4))), 0x01));


                        body.instructions = f365F_parent_instructions;
                        body.emit(f365F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3663 = bit_and(r3654, body.constant(3221225472u));
                        ir_expression *const r3664 = equal(r3663, body.constant(0u));
                        ir_if *f3662 = new(mem_ctx) ir_if(operand(r3664).val);
                        exec_list *const f3662_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3662->then_instructions;

                           body.emit(assign(r3656, add(r3656, body.constant(int(2))), 0x01));

                           body.emit(assign(r3654, lshift(r3654, body.constant(int(2))), 0x01));


                        body.instructions = f3662_parent_instructions;
                        body.emit(f3662);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3666 = bit_and(r3654, body.constant(2147483648u));
                        ir_expression *const r3667 = equal(r3666, body.constant(0u));
                        ir_if *f3665 = new(mem_ctx) ir_if(operand(r3667).val);
                        exec_list *const f3665_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3665->then_instructions;

                           body.emit(assign(r3656, add(r3656, body.constant(int(1))), 0x01));


                        body.instructions = f3665_parent_instructions;
                        body.emit(f3665);

                        /* END IF */

                        body.emit(assign(r3655, r3656, 0x01));


                     body.instructions = f3657_parent_instructions;
                     body.emit(f3657);

                     /* END IF */

                     body.emit(assign(r3651, add(r3655, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3669 = less(r3651, body.constant(int(0)));
                     ir_if *f3668 = new(mem_ctx) ir_if(operand(r3669).val);
                     exec_list *const f3668_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3668->then_instructions;

                        ir_expression *const r366A = neg(r3651);
                        body.emit(assign(r364F, rshift(swizzle_x(r2FFF), r366A), 0x01));

                        ir_expression *const r366B = bit_and(r3651, body.constant(int(31)));
                        body.emit(assign(r3650, lshift(swizzle_x(r2FFF), r366B), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3668->else_instructions;

                        body.emit(assign(r364F, lshift(swizzle_x(r2FFF), r3651), 0x01));

                        body.emit(assign(r3650, body.constant(0u), 0x01));


                     body.instructions = f3668_parent_instructions;
                     body.emit(f3668);

                     /* END IF */

                     body.emit(assign(r364E, sub(body.constant(int(-31)), r3651), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3652->else_instructions;

                     ir_variable *const r366C = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r366C, r35A5, 0x01));

                     ir_variable *const r366D = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r366E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r366E);
                     /* IF CONDITION */
                     ir_expression *const r3670 = equal(r35A5, body.constant(0u));
                     ir_if *f366F = new(mem_ctx) ir_if(operand(r3670).val);
                     exec_list *const f366F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f366F->then_instructions;

                        body.emit(assign(r366D, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f366F->else_instructions;

                        body.emit(assign(r366E, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3672 = bit_and(r35A5, body.constant(4294901760u));
                        ir_expression *const r3673 = equal(r3672, body.constant(0u));
                        ir_if *f3671 = new(mem_ctx) ir_if(operand(r3673).val);
                        exec_list *const f3671_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3671->then_instructions;

                           body.emit(assign(r366E, body.constant(int(16)), 0x01));

                           body.emit(assign(r366C, lshift(r35A5, body.constant(int(16))), 0x01));


                        body.instructions = f3671_parent_instructions;
                        body.emit(f3671);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3675 = bit_and(r366C, body.constant(4278190080u));
                        ir_expression *const r3676 = equal(r3675, body.constant(0u));
                        ir_if *f3674 = new(mem_ctx) ir_if(operand(r3676).val);
                        exec_list *const f3674_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3674->then_instructions;

                           body.emit(assign(r366E, add(r366E, body.constant(int(8))), 0x01));

                           body.emit(assign(r366C, lshift(r366C, body.constant(int(8))), 0x01));


                        body.instructions = f3674_parent_instructions;
                        body.emit(f3674);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3678 = bit_and(r366C, body.constant(4026531840u));
                        ir_expression *const r3679 = equal(r3678, body.constant(0u));
                        ir_if *f3677 = new(mem_ctx) ir_if(operand(r3679).val);
                        exec_list *const f3677_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3677->then_instructions;

                           body.emit(assign(r366E, add(r366E, body.constant(int(4))), 0x01));

                           body.emit(assign(r366C, lshift(r366C, body.constant(int(4))), 0x01));


                        body.instructions = f3677_parent_instructions;
                        body.emit(f3677);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r367B = bit_and(r366C, body.constant(3221225472u));
                        ir_expression *const r367C = equal(r367B, body.constant(0u));
                        ir_if *f367A = new(mem_ctx) ir_if(operand(r367C).val);
                        exec_list *const f367A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f367A->then_instructions;

                           body.emit(assign(r366E, add(r366E, body.constant(int(2))), 0x01));

                           body.emit(assign(r366C, lshift(r366C, body.constant(int(2))), 0x01));


                        body.instructions = f367A_parent_instructions;
                        body.emit(f367A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r367E = bit_and(r366C, body.constant(2147483648u));
                        ir_expression *const r367F = equal(r367E, body.constant(0u));
                        ir_if *f367D = new(mem_ctx) ir_if(operand(r367F).val);
                        exec_list *const f367D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f367D->then_instructions;

                           body.emit(assign(r366E, add(r366E, body.constant(int(1))), 0x01));


                        body.instructions = f367D_parent_instructions;
                        body.emit(f367D);

                        /* END IF */

                        body.emit(assign(r366D, r366E, 0x01));


                     body.instructions = f366F_parent_instructions;
                     body.emit(f366F);

                     /* END IF */

                     body.emit(assign(r3651, add(r366D, body.constant(int(-11))), 0x01));

                     ir_variable *const r3680 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3680, lshift(swizzle_x(r2FFF), r3651), 0x01));

                     ir_variable *const r3681 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3683 = equal(r3651, body.constant(int(0)));
                     ir_if *f3682 = new(mem_ctx) ir_if(operand(r3683).val);
                     exec_list *const f3682_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3682->then_instructions;

                        body.emit(assign(r3681, r35A5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3682->else_instructions;

                        ir_expression *const r3684 = lshift(r35A5, r3651);
                        ir_expression *const r3685 = neg(r3651);
                        ir_expression *const r3686 = bit_and(r3685, body.constant(int(31)));
                        ir_expression *const r3687 = rshift(swizzle_x(r2FFF), r3686);
                        body.emit(assign(r3681, bit_or(r3684, r3687), 0x01));


                     body.instructions = f3682_parent_instructions;
                     body.emit(f3682);

                     /* END IF */

                     body.emit(assign(r364F, r3681, 0x01));

                     body.emit(assign(r3650, r3680, 0x01));

                     body.emit(assign(r364E, sub(body.constant(int(1)), r3651), 0x01));


                  body.instructions = f3652_parent_instructions;
                  body.emit(f3652);

                  /* END IF */

                  body.emit(assign(r3598, r364E, 0x01));

                  body.emit(assign(r359A, r364F, 0x01));

                  body.emit(assign(r359B, r3650, 0x01));


               body.instructions = f364A_parent_instructions;
               body.emit(f364A);

               /* END IF */


            body.instructions = f3648_parent_instructions;
            body.emit(f3648);

            /* END IF */

            /* IF CONDITION */
            ir_if *f3688 = new(mem_ctx) ir_if(operand(r3595).val);
            exec_list *const f3688_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3688->then_instructions;

               ir_expression *const r3689 = add(r3599, r3598);
               body.emit(assign(r359E, add(r3689, body.constant(int(-1024))), 0x01));

               body.emit(assign(r359C, bit_or(r359C, body.constant(1048576u)), 0x01));

               ir_variable *const r368A = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r368A, lshift(r359B, body.constant(int(12))), 0x01));

               ir_variable *const r368B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r368C = lshift(r359A, body.constant(int(12)));
               ir_expression *const r368D = rshift(r359B, body.constant(int(20)));
               body.emit(assign(r368B, bit_or(r368C, r368D), 0x01));

               body.emit(assign(r359A, r368B, 0x01));

               body.emit(assign(r359B, r368A, 0x01));

               ir_variable *const r368E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r368E);
               ir_variable *const r368F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r368F);
               ir_variable *const r3690 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3690);
               ir_variable *const r3691 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3691, bit_and(r359D, body.constant(65535u)), 0x01));

               ir_variable *const r3692 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3692, rshift(r359D, body.constant(int(16))), 0x01));

               ir_variable *const r3693 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3693, bit_and(r368A, body.constant(65535u)), 0x01));

               ir_variable *const r3694 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3694, rshift(r368A, body.constant(int(16))), 0x01));

               ir_variable *const r3695 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3695, mul(r3692, r3693), 0x01));

               ir_expression *const r3696 = mul(r3691, r3694);
               body.emit(assign(r368F, add(r3696, r3695), 0x01));

               ir_expression *const r3697 = mul(r3692, r3694);
               ir_expression *const r3698 = less(r368F, r3695);
               ir_expression *const r3699 = expr(ir_unop_b2i, r3698);
               ir_expression *const r369A = expr(ir_unop_i2u, r3699);
               ir_expression *const r369B = lshift(r369A, body.constant(int(16)));
               ir_expression *const r369C = rshift(r368F, body.constant(int(16)));
               ir_expression *const r369D = add(r369B, r369C);
               body.emit(assign(r368E, add(r3697, r369D), 0x01));

               body.emit(assign(r368F, lshift(r368F, body.constant(int(16))), 0x01));

               ir_expression *const r369E = mul(r3691, r3693);
               body.emit(assign(r3690, add(r369E, r368F), 0x01));

               ir_expression *const r369F = less(r3690, r368F);
               ir_expression *const r36A0 = expr(ir_unop_b2i, r369F);
               ir_expression *const r36A1 = expr(ir_unop_i2u, r36A0);
               body.emit(assign(r368E, add(r368E, r36A1), 0x01));

               ir_variable *const r36A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r36A2);
               ir_variable *const r36A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r36A3);
               ir_variable *const r36A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r36A4);
               ir_variable *const r36A5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36A5, bit_and(r359D, body.constant(65535u)), 0x01));

               ir_variable *const r36A6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36A6, rshift(r359D, body.constant(int(16))), 0x01));

               ir_variable *const r36A7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36A7, bit_and(r368B, body.constant(65535u)), 0x01));

               ir_variable *const r36A8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36A8, rshift(r368B, body.constant(int(16))), 0x01));

               ir_variable *const r36A9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36A9, mul(r36A6, r36A7), 0x01));

               ir_expression *const r36AA = mul(r36A5, r36A8);
               body.emit(assign(r36A3, add(r36AA, r36A9), 0x01));

               ir_expression *const r36AB = mul(r36A6, r36A8);
               ir_expression *const r36AC = less(r36A3, r36A9);
               ir_expression *const r36AD = expr(ir_unop_b2i, r36AC);
               ir_expression *const r36AE = expr(ir_unop_i2u, r36AD);
               ir_expression *const r36AF = lshift(r36AE, body.constant(int(16)));
               ir_expression *const r36B0 = rshift(r36A3, body.constant(int(16)));
               ir_expression *const r36B1 = add(r36AF, r36B0);
               body.emit(assign(r36A2, add(r36AB, r36B1), 0x01));

               body.emit(assign(r36A3, lshift(r36A3, body.constant(int(16))), 0x01));

               ir_expression *const r36B2 = mul(r36A5, r36A7);
               body.emit(assign(r36A4, add(r36B2, r36A3), 0x01));

               ir_expression *const r36B3 = less(r36A4, r36A3);
               ir_expression *const r36B4 = expr(ir_unop_b2i, r36B3);
               ir_expression *const r36B5 = expr(ir_unop_i2u, r36B4);
               body.emit(assign(r36A2, add(r36A2, r36B5), 0x01));

               ir_variable *const r36B6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36B6, add(r36A4, r368E), 0x01));

               ir_variable *const r36B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r36B7);
               ir_variable *const r36B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r36B8);
               ir_variable *const r36B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r36B9);
               ir_variable *const r36BA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36BA, bit_and(r359C, body.constant(65535u)), 0x01));

               ir_variable *const r36BB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36BB, rshift(r359C, body.constant(int(16))), 0x01));

               ir_variable *const r36BC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36BC, bit_and(r368B, body.constant(65535u)), 0x01));

               ir_variable *const r36BD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36BD, rshift(r368B, body.constant(int(16))), 0x01));

               ir_variable *const r36BE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36BE, mul(r36BB, r36BC), 0x01));

               ir_expression *const r36BF = mul(r36BA, r36BD);
               body.emit(assign(r36B8, add(r36BF, r36BE), 0x01));

               ir_expression *const r36C0 = mul(r36BB, r36BD);
               ir_expression *const r36C1 = less(r36B8, r36BE);
               ir_expression *const r36C2 = expr(ir_unop_b2i, r36C1);
               ir_expression *const r36C3 = expr(ir_unop_i2u, r36C2);
               ir_expression *const r36C4 = lshift(r36C3, body.constant(int(16)));
               ir_expression *const r36C5 = rshift(r36B8, body.constant(int(16)));
               ir_expression *const r36C6 = add(r36C4, r36C5);
               body.emit(assign(r36B7, add(r36C0, r36C6), 0x01));

               body.emit(assign(r36B8, lshift(r36B8, body.constant(int(16))), 0x01));

               ir_expression *const r36C7 = mul(r36BA, r36BC);
               body.emit(assign(r36B9, add(r36C7, r36B8), 0x01));

               ir_expression *const r36C8 = less(r36B9, r36B8);
               ir_expression *const r36C9 = expr(ir_unop_b2i, r36C8);
               ir_expression *const r36CA = expr(ir_unop_i2u, r36C9);
               body.emit(assign(r36B7, add(r36B7, r36CA), 0x01));

               ir_variable *const r36CB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r36CC = less(r36B6, r36A4);
               ir_expression *const r36CD = expr(ir_unop_b2i, r36CC);
               ir_expression *const r36CE = expr(ir_unop_i2u, r36CD);
               ir_expression *const r36CF = add(r36A2, r36CE);
               body.emit(assign(r36CB, add(r36B9, r36CF), 0x01));

               ir_variable *const r36D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r36D0);
               ir_variable *const r36D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r36D1);
               ir_variable *const r36D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r36D2);
               ir_variable *const r36D3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36D3, bit_and(r359C, body.constant(65535u)), 0x01));

               ir_variable *const r36D4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36D4, rshift(r359C, body.constant(int(16))), 0x01));

               ir_variable *const r36D5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36D5, bit_and(r368A, body.constant(65535u)), 0x01));

               ir_variable *const r36D6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36D6, rshift(r368A, body.constant(int(16))), 0x01));

               ir_variable *const r36D7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36D7, mul(r36D4, r36D5), 0x01));

               ir_expression *const r36D8 = mul(r36D3, r36D6);
               body.emit(assign(r36D1, add(r36D8, r36D7), 0x01));

               ir_expression *const r36D9 = mul(r36D4, r36D6);
               ir_expression *const r36DA = less(r36D1, r36D7);
               ir_expression *const r36DB = expr(ir_unop_b2i, r36DA);
               ir_expression *const r36DC = expr(ir_unop_i2u, r36DB);
               ir_expression *const r36DD = lshift(r36DC, body.constant(int(16)));
               ir_expression *const r36DE = rshift(r36D1, body.constant(int(16)));
               ir_expression *const r36DF = add(r36DD, r36DE);
               body.emit(assign(r36D0, add(r36D9, r36DF), 0x01));

               body.emit(assign(r36D1, lshift(r36D1, body.constant(int(16))), 0x01));

               ir_expression *const r36E0 = mul(r36D3, r36D5);
               body.emit(assign(r36D2, add(r36E0, r36D1), 0x01));

               ir_expression *const r36E1 = less(r36D2, r36D1);
               ir_expression *const r36E2 = expr(ir_unop_b2i, r36E1);
               ir_expression *const r36E3 = expr(ir_unop_i2u, r36E2);
               body.emit(assign(r36D0, add(r36D0, r36E3), 0x01));

               ir_variable *const r36E4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36E4, add(r36D2, r36B6), 0x01));

               ir_variable *const r36E5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r36E6 = less(r36E4, r36D2);
               ir_expression *const r36E7 = expr(ir_unop_b2i, r36E6);
               ir_expression *const r36E8 = expr(ir_unop_i2u, r36E7);
               ir_expression *const r36E9 = add(r36D0, r36E8);
               body.emit(assign(r36E5, add(r36CB, r36E9), 0x01));

               ir_variable *const r36EA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r36EB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r36EB, add(r36E5, r359D), 0x01));

               ir_expression *const r36EC = less(r36CB, r36B9);
               ir_expression *const r36ED = expr(ir_unop_b2i, r36EC);
               ir_expression *const r36EE = expr(ir_unop_i2u, r36ED);
               ir_expression *const r36EF = add(r36B7, r36EE);
               ir_expression *const r36F0 = less(r36E5, r36CB);
               ir_expression *const r36F1 = expr(ir_unop_b2i, r36F0);
               ir_expression *const r36F2 = expr(ir_unop_i2u, r36F1);
               ir_expression *const r36F3 = add(r36EF, r36F2);
               ir_expression *const r36F4 = add(r36F3, r359C);
               ir_expression *const r36F5 = less(r36EB, r36E5);
               ir_expression *const r36F6 = expr(ir_unop_b2i, r36F5);
               ir_expression *const r36F7 = expr(ir_unop_i2u, r36F6);
               body.emit(assign(r36EA, add(r36F4, r36F7), 0x01));

               body.emit(assign(r35A1, r36EA, 0x01));

               body.emit(assign(r35A0, r36EB, 0x01));

               ir_expression *const r36F8 = nequal(r3690, body.constant(0u));
               ir_expression *const r36F9 = expr(ir_unop_b2i, r36F8);
               ir_expression *const r36FA = expr(ir_unop_i2u, r36F9);
               body.emit(assign(r359F, bit_or(r36E4, r36FA), 0x01));

               /* IF CONDITION */
               ir_expression *const r36FC = lequal(body.constant(2097152u), r36EA);
               ir_if *f36FB = new(mem_ctx) ir_if(operand(r36FC).val);
               exec_list *const f36FB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f36FB->then_instructions;

                  ir_variable *const r36FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r36FD);
                  body.emit(assign(r36FD, lshift(r36EB, body.constant(int(31))), 0x01));

                  ir_expression *const r36FE = nequal(r359F, body.constant(0u));
                  ir_expression *const r36FF = expr(ir_unop_b2i, r36FE);
                  ir_expression *const r3700 = expr(ir_unop_i2u, r36FF);
                  body.emit(assign(r36FD, bit_or(r36FD, r3700), 0x01));

                  body.emit(assign(r35A1, rshift(r36EA, body.constant(int(1))), 0x01));

                  ir_expression *const r3701 = lshift(r36EA, body.constant(int(31)));
                  ir_expression *const r3702 = rshift(r36EB, body.constant(int(1)));
                  body.emit(assign(r35A0, bit_or(r3701, r3702), 0x01));

                  body.emit(assign(r359F, r36FD, 0x01));

                  body.emit(assign(r359E, add(r359E, body.constant(int(1))), 0x01));


               body.instructions = f36FB_parent_instructions;
               body.emit(f36FB);

               /* END IF */

               ir_variable *const r3703 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3703, r359E, 0x01));

               ir_variable *const r3704 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3704, r35A1, 0x01));

               ir_variable *const r3705 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3705, r35A0, 0x01));

               ir_variable *const r3706 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3706, r359F, 0x01));

               ir_variable *const r3707 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r3707, body.constant(true), 0x01));

               ir_variable *const r3708 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3709 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3709);
               ir_expression *const r370A = expr(ir_unop_u2i, r359F);
               body.emit(assign(r3709, less(r370A, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r370C = lequal(body.constant(int(2045)), r359E);
               ir_if *f370B = new(mem_ctx) ir_if(operand(r370C).val);
               exec_list *const f370B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f370B->then_instructions;

                  ir_variable *const r370D = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r370F = less(body.constant(int(2045)), r359E);
                  ir_if *f370E = new(mem_ctx) ir_if(operand(r370F).val);
                  exec_list *const f370E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f370E->then_instructions;

                     body.emit(assign(r370D, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f370E->else_instructions;

                     ir_variable *const r3710 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3712 = equal(r359E, body.constant(int(2045)));
                     ir_if *f3711 = new(mem_ctx) ir_if(operand(r3712).val);
                     exec_list *const f3711_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3711->then_instructions;

                        ir_expression *const r3713 = equal(body.constant(2097151u), r35A1);
                        ir_expression *const r3714 = equal(body.constant(4294967295u), r35A0);
                        body.emit(assign(r3710, logic_and(r3713, r3714), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3711->else_instructions;

                        body.emit(assign(r3710, body.constant(false), 0x01));


                     body.instructions = f3711_parent_instructions;
                     body.emit(f3711);

                     /* END IF */

                     body.emit(assign(r370D, logic_and(r3710, r3709), 0x01));


                  body.instructions = f370E_parent_instructions;
                  body.emit(f370E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3715 = new(mem_ctx) ir_if(operand(r370D).val);
                  exec_list *const f3715_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3715->then_instructions;

                     ir_variable *const r3716 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3716);
                     ir_expression *const r3717 = lshift(r3597, body.constant(int(31)));
                     body.emit(assign(r3716, add(r3717, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3716, body.constant(0u), 0x01));

                     body.emit(assign(r3708, r3716, 0x03));

                     body.emit(assign(r3707, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3715->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3719 = less(r359E, body.constant(int(0)));
                     ir_if *f3718 = new(mem_ctx) ir_if(operand(r3719).val);
                     exec_list *const f3718_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3718->then_instructions;

                        ir_variable *const r371A = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r371A, r359F, 0x01));

                        ir_variable *const r371B = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r371B, neg(r359E), 0x01));

                        ir_variable *const r371C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r371C);
                        ir_variable *const r371D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r371D);
                        ir_variable *const r371E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r371E);
                        ir_variable *const r371F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3720 = neg(r371B);
                        body.emit(assign(r371F, bit_and(r3720, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3722 = equal(r371B, body.constant(int(0)));
                        ir_if *f3721 = new(mem_ctx) ir_if(operand(r3722).val);
                        exec_list *const f3721_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3721->then_instructions;

                           body.emit(assign(r371C, r359F, 0x01));

                           body.emit(assign(r371D, r35A0, 0x01));

                           body.emit(assign(r371E, r35A1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3721->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3724 = less(r371B, body.constant(int(32)));
                           ir_if *f3723 = new(mem_ctx) ir_if(operand(r3724).val);
                           exec_list *const f3723_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3723->then_instructions;

                              body.emit(assign(r371C, lshift(r35A0, r371F), 0x01));

                              ir_expression *const r3725 = lshift(r35A1, r371F);
                              ir_expression *const r3726 = rshift(r35A0, r371B);
                              body.emit(assign(r371D, bit_or(r3725, r3726), 0x01));

                              body.emit(assign(r371E, rshift(r35A1, r371B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3723->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3728 = equal(r371B, body.constant(int(32)));
                              ir_if *f3727 = new(mem_ctx) ir_if(operand(r3728).val);
                              exec_list *const f3727_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3727->then_instructions;

                                 body.emit(assign(r371C, r35A0, 0x01));

                                 body.emit(assign(r371D, r35A1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3727->else_instructions;

                                 body.emit(assign(r371A, bit_or(r359F, r35A0), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r372A = less(r371B, body.constant(int(64)));
                                 ir_if *f3729 = new(mem_ctx) ir_if(operand(r372A).val);
                                 exec_list *const f3729_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3729->then_instructions;

                                    body.emit(assign(r371C, lshift(r35A1, r371F), 0x01));

                                    ir_expression *const r372B = bit_and(r371B, body.constant(int(31)));
                                    body.emit(assign(r371D, rshift(r35A1, r372B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3729->else_instructions;

                                    ir_variable *const r372C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r372E = equal(r371B, body.constant(int(64)));
                                    ir_if *f372D = new(mem_ctx) ir_if(operand(r372E).val);
                                    exec_list *const f372D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f372D->then_instructions;

                                       body.emit(assign(r372C, r35A1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f372D->else_instructions;

                                       ir_expression *const r372F = nequal(r35A1, body.constant(0u));
                                       ir_expression *const r3730 = expr(ir_unop_b2i, r372F);
                                       body.emit(assign(r372C, expr(ir_unop_i2u, r3730), 0x01));


                                    body.instructions = f372D_parent_instructions;
                                    body.emit(f372D);

                                    /* END IF */

                                    body.emit(assign(r371C, r372C, 0x01));

                                    body.emit(assign(r371D, body.constant(0u), 0x01));


                                 body.instructions = f3729_parent_instructions;
                                 body.emit(f3729);

                                 /* END IF */


                              body.instructions = f3727_parent_instructions;
                              body.emit(f3727);

                              /* END IF */

                              body.emit(assign(r371E, body.constant(0u), 0x01));


                           body.instructions = f3723_parent_instructions;
                           body.emit(f3723);

                           /* END IF */

                           ir_expression *const r3731 = nequal(r371A, body.constant(0u));
                           ir_expression *const r3732 = expr(ir_unop_b2i, r3731);
                           ir_expression *const r3733 = expr(ir_unop_i2u, r3732);
                           body.emit(assign(r371C, bit_or(r371C, r3733), 0x01));


                        body.instructions = f3721_parent_instructions;
                        body.emit(f3721);

                        /* END IF */

                        body.emit(assign(r3704, r371E, 0x01));

                        body.emit(assign(r3705, r371D, 0x01));

                        body.emit(assign(r3706, r371C, 0x01));

                        body.emit(assign(r3703, body.constant(int(0)), 0x01));

                        body.emit(assign(r3709, less(r371C, body.constant(0u)), 0x01));


                     body.instructions = f3718_parent_instructions;
                     body.emit(f3718);

                     /* END IF */


                  body.instructions = f3715_parent_instructions;
                  body.emit(f3715);

                  /* END IF */


               body.instructions = f370B_parent_instructions;
               body.emit(f370B);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3734 = new(mem_ctx) ir_if(operand(r3707).val);
               exec_list *const f3734_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3734->then_instructions;

                  /* IF CONDITION */
                  ir_if *f3735 = new(mem_ctx) ir_if(operand(r3709).val);
                  exec_list *const f3735_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3735->then_instructions;

                     ir_variable *const r3736 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3736, add(r3705, body.constant(1u)), 0x01));

                     ir_expression *const r3737 = less(r3736, r3705);
                     ir_expression *const r3738 = expr(ir_unop_b2i, r3737);
                     ir_expression *const r3739 = expr(ir_unop_i2u, r3738);
                     body.emit(assign(r3704, add(r3704, r3739), 0x01));

                     ir_expression *const r373A = equal(r3706, body.constant(0u));
                     ir_expression *const r373B = expr(ir_unop_b2i, r373A);
                     ir_expression *const r373C = expr(ir_unop_i2u, r373B);
                     ir_expression *const r373D = add(r3706, r373C);
                     ir_expression *const r373E = bit_and(r373D, body.constant(1u));
                     ir_expression *const r373F = expr(ir_unop_bit_not, r373E);
                     body.emit(assign(r3705, bit_and(r3736, r373F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3735->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3741 = bit_or(r3704, r3705);
                     ir_expression *const r3742 = equal(r3741, body.constant(0u));
                     ir_if *f3740 = new(mem_ctx) ir_if(operand(r3742).val);
                     exec_list *const f3740_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3740->then_instructions;

                        body.emit(assign(r3703, body.constant(int(0)), 0x01));


                     body.instructions = f3740_parent_instructions;
                     body.emit(f3740);

                     /* END IF */


                  body.instructions = f3735_parent_instructions;
                  body.emit(f3735);

                  /* END IF */

                  ir_variable *const r3743 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3743);
                  ir_expression *const r3744 = lshift(r3597, body.constant(int(31)));
                  ir_expression *const r3745 = expr(ir_unop_i2u, r3703);
                  ir_expression *const r3746 = lshift(r3745, body.constant(int(20)));
                  ir_expression *const r3747 = add(r3744, r3746);
                  body.emit(assign(r3743, add(r3747, r3704), 0x02));

                  body.emit(assign(r3743, r3705, 0x01));

                  body.emit(assign(r3708, r3743, 0x03));

                  body.emit(assign(r3707, body.constant(false), 0x01));


               body.instructions = f3734_parent_instructions;
               body.emit(f3734);

               /* END IF */

               body.emit(assign(r3596, r3708, 0x03));

               body.emit(assign(r3595, body.constant(false), 0x01));


            body.instructions = f3688_parent_instructions;
            body.emit(f3688);

            /* END IF */


         body.instructions = f3647_parent_instructions;
         body.emit(f3647);

         /* END IF */


      body.instructions = f35DD_parent_instructions;
      body.emit(f35DD);

      /* END IF */


   body.instructions = f35AE_parent_instructions;
   body.emit(f35AE);

   /* END IF */

   ir_variable *const r3748 = body.make_temp(glsl_type::uvec2_type, "a");
   body.emit(assign(r3748, r3596, 0x03));

   ir_variable *const r3749 = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r374B = lshift(swizzle_y(r3596), body.constant(int(1)));
   ir_expression *const r374C = lequal(body.constant(4292870144u), r374B);
   ir_expression *const r374D = nequal(swizzle_x(r3596), body.constant(0u));
   ir_expression *const r374E = bit_and(swizzle_y(r3596), body.constant(1048575u));
   ir_expression *const r374F = nequal(r374E, body.constant(0u));
   ir_expression *const r3750 = logic_or(r374D, r374F);
   ir_expression *const r3751 = logic_and(r374C, r3750);
   ir_if *f374A = new(mem_ctx) ir_if(operand(r3751).val);
   exec_list *const f374A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f374A->then_instructions;

      body.emit(assign(r3749, r3596, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f374A->else_instructions;

      body.emit(assign(r3748, bit_xor(swizzle_y(r3596), body.constant(2147483648u)), 0x02));

      body.emit(assign(r3749, r3748, 0x03));


   body.instructions = f374A_parent_instructions;
   body.emit(f374A);

   /* END IF */

   ir_variable *const r3752 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r3753 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r3753, rshift(swizzle_y(r2D5A), body.constant(int(31))), 0x01));

   ir_variable *const r3754 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r3754, rshift(swizzle_y(r3749), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r3756 = equal(r3753, r3754);
   ir_if *f3755 = new(mem_ctx) ir_if(operand(r3756).val);
   exec_list *const f3755_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f3755->then_instructions;

      ir_variable *const r3757 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r3757, body.constant(true), 0x01));

      ir_variable *const r3758 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r3759 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r3759);
      ir_variable *const r375A = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r375A);
      ir_variable *const r375B = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r375B);
      ir_variable *const r375C = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r375C);
      ir_variable *const r375D = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r375D);
      ir_variable *const r375E = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r375E);
      ir_variable *const r375F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r375F);
      ir_variable *const r3760 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r3760);
      body.emit(assign(r3760, body.constant(0u), 0x01));

      body.emit(assign(r375F, body.constant(0u), 0x01));

      ir_variable *const r3761 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r3761, swizzle_x(r2D5A), 0x01));

      body.emit(assign(r375D, r3761, 0x01));

      ir_variable *const r3762 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r3762, bit_and(swizzle_y(r2D5A), body.constant(1048575u)), 0x01));

      body.emit(assign(r375C, r3762, 0x01));

      ir_variable *const r3763 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r3763, swizzle_x(r3749), 0x01));

      body.emit(assign(r375B, r3763, 0x01));

      ir_variable *const r3764 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r3764, bit_and(swizzle_y(r3749), body.constant(1048575u)), 0x01));

      body.emit(assign(r375A, r3764, 0x01));

      ir_variable *const r3765 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3766 = rshift(swizzle_y(r2D5A), body.constant(int(20)));
      ir_expression *const r3767 = bit_and(r3766, body.constant(2047u));
      body.emit(assign(r3765, expr(ir_unop_u2i, r3767), 0x01));

      ir_variable *const r3768 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3769 = rshift(swizzle_y(r3749), body.constant(int(20)));
      ir_expression *const r376A = bit_and(r3769, body.constant(2047u));
      body.emit(assign(r3768, expr(ir_unop_u2i, r376A), 0x01));

      ir_variable *const r376B = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r376B, sub(r3765, r3768), 0x01));

      body.emit(assign(r3759, r376B, 0x01));

      /* IF CONDITION */
      ir_expression *const r376D = less(body.constant(int(0)), r376B);
      ir_if *f376C = new(mem_ctx) ir_if(operand(r376D).val);
      exec_list *const f376C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f376C->then_instructions;

         /* IF CONDITION */
         ir_expression *const r376F = equal(r3765, body.constant(int(2047)));
         ir_if *f376E = new(mem_ctx) ir_if(operand(r376F).val);
         exec_list *const f376E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f376E->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3771 = bit_or(r3762, swizzle_x(r2D5A));
            ir_expression *const r3772 = nequal(r3771, body.constant(0u));
            ir_if *f3770 = new(mem_ctx) ir_if(operand(r3772).val);
            exec_list *const f3770_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3770->then_instructions;

               ir_variable *const r3773 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r3773, swizzle_x(r2D5A), 0x01));

               ir_variable *const r3774 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r3774, swizzle_x(r3749), 0x01));

               ir_variable *const r3775 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3776 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r3777 = rshift(swizzle_y(r2D5A), body.constant(int(19)));
               ir_expression *const r3778 = bit_and(r3777, body.constant(4095u));
               ir_expression *const r3779 = equal(r3778, body.constant(4094u));
               ir_expression *const r377A = nequal(swizzle_x(r2D5A), body.constant(0u));
               ir_expression *const r377B = bit_and(swizzle_y(r2D5A), body.constant(524287u));
               ir_expression *const r377C = nequal(r377B, body.constant(0u));
               ir_expression *const r377D = logic_or(r377A, r377C);
               body.emit(assign(r3776, logic_and(r3779, r377D), 0x01));

               ir_variable *const r377E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r377F = lshift(swizzle_y(r3749), body.constant(int(1)));
               ir_expression *const r3780 = lequal(body.constant(4292870144u), r377F);
               ir_expression *const r3781 = nequal(swizzle_x(r3749), body.constant(0u));
               ir_expression *const r3782 = bit_and(swizzle_y(r3749), body.constant(1048575u));
               ir_expression *const r3783 = nequal(r3782, body.constant(0u));
               ir_expression *const r3784 = logic_or(r3781, r3783);
               body.emit(assign(r377E, logic_and(r3780, r3784), 0x01));

               body.emit(assign(r3773, bit_or(swizzle_y(r2D5A), body.constant(524288u)), 0x02));

               body.emit(assign(r3774, bit_or(swizzle_y(r3749), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r3786 = lshift(swizzle_y(r2D5A), body.constant(int(1)));
               ir_expression *const r3787 = lequal(body.constant(4292870144u), r3786);
               ir_expression *const r3788 = nequal(swizzle_x(r2D5A), body.constant(0u));
               ir_expression *const r3789 = bit_and(swizzle_y(r2D5A), body.constant(1048575u));
               ir_expression *const r378A = nequal(r3789, body.constant(0u));
               ir_expression *const r378B = logic_or(r3788, r378A);
               ir_expression *const r378C = logic_and(r3787, r378B);
               ir_if *f3785 = new(mem_ctx) ir_if(operand(r378C).val);
               exec_list *const f3785_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3785->then_instructions;

                  ir_variable *const r378D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r378F = logic_and(r3776, r377E);
                  ir_if *f378E = new(mem_ctx) ir_if(operand(r378F).val);
                  exec_list *const f378E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f378E->then_instructions;

                     body.emit(assign(r378D, r3774, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f378E->else_instructions;

                     body.emit(assign(r378D, r3773, 0x03));


                  body.instructions = f378E_parent_instructions;
                  body.emit(f378E);

                  /* END IF */

                  body.emit(assign(r3775, r378D, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3785->else_instructions;

                  body.emit(assign(r3775, r3774, 0x03));


               body.instructions = f3785_parent_instructions;
               body.emit(f3785);

               /* END IF */

               body.emit(assign(r3758, r3775, 0x03));

               body.emit(assign(r3757, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3770->else_instructions;

               body.emit(assign(r3758, r2D5A, 0x03));

               body.emit(assign(r3757, body.constant(false), 0x01));


            body.instructions = f3770_parent_instructions;
            body.emit(f3770);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f376E->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3791 = equal(r3768, body.constant(int(0)));
            ir_if *f3790 = new(mem_ctx) ir_if(operand(r3791).val);
            exec_list *const f3790_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3790->then_instructions;

               body.emit(assign(r3759, add(r376B, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3790->else_instructions;

               body.emit(assign(r375A, bit_or(r3764, body.constant(1048576u)), 0x01));


            body.instructions = f3790_parent_instructions;
            body.emit(f3790);

            /* END IF */

            ir_variable *const r3792 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r3792, body.constant(0u), 0x01));

            ir_variable *const r3793 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r3793);
            ir_variable *const r3794 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r3794);
            ir_variable *const r3795 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r3795);
            ir_variable *const r3796 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r3797 = neg(r3759);
            body.emit(assign(r3796, bit_and(r3797, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3799 = equal(r3759, body.constant(int(0)));
            ir_if *f3798 = new(mem_ctx) ir_if(operand(r3799).val);
            exec_list *const f3798_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3798->then_instructions;

               body.emit(assign(r3793, r3792, 0x01));

               body.emit(assign(r3794, r3763, 0x01));

               body.emit(assign(r3795, r375A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3798->else_instructions;

               /* IF CONDITION */
               ir_expression *const r379B = less(r3759, body.constant(int(32)));
               ir_if *f379A = new(mem_ctx) ir_if(operand(r379B).val);
               exec_list *const f379A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f379A->then_instructions;

                  body.emit(assign(r3793, lshift(swizzle_x(r3749), r3796), 0x01));

                  ir_expression *const r379C = lshift(r375A, r3796);
                  ir_expression *const r379D = rshift(swizzle_x(r3749), r3759);
                  body.emit(assign(r3794, bit_or(r379C, r379D), 0x01));

                  body.emit(assign(r3795, rshift(r375A, r3759), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f379A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r379F = equal(r3759, body.constant(int(32)));
                  ir_if *f379E = new(mem_ctx) ir_if(operand(r379F).val);
                  exec_list *const f379E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f379E->then_instructions;

                     body.emit(assign(r3793, r3763, 0x01));

                     body.emit(assign(r3794, r375A, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f379E->else_instructions;

                     body.emit(assign(r3792, bit_or(body.constant(0u), swizzle_x(r3749)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r37A1 = less(r3759, body.constant(int(64)));
                     ir_if *f37A0 = new(mem_ctx) ir_if(operand(r37A1).val);
                     exec_list *const f37A0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f37A0->then_instructions;

                        body.emit(assign(r3793, lshift(r375A, r3796), 0x01));

                        ir_expression *const r37A2 = bit_and(r3759, body.constant(int(31)));
                        body.emit(assign(r3794, rshift(r375A, r37A2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f37A0->else_instructions;

                        ir_variable *const r37A3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r37A5 = equal(r3759, body.constant(int(64)));
                        ir_if *f37A4 = new(mem_ctx) ir_if(operand(r37A5).val);
                        exec_list *const f37A4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f37A4->then_instructions;

                           body.emit(assign(r37A3, r375A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f37A4->else_instructions;

                           ir_expression *const r37A6 = nequal(r375A, body.constant(0u));
                           ir_expression *const r37A7 = expr(ir_unop_b2i, r37A6);
                           body.emit(assign(r37A3, expr(ir_unop_i2u, r37A7), 0x01));


                        body.instructions = f37A4_parent_instructions;
                        body.emit(f37A4);

                        /* END IF */

                        body.emit(assign(r3793, r37A3, 0x01));

                        body.emit(assign(r3794, body.constant(0u), 0x01));


                     body.instructions = f37A0_parent_instructions;
                     body.emit(f37A0);

                     /* END IF */


                  body.instructions = f379E_parent_instructions;
                  body.emit(f379E);

                  /* END IF */

                  body.emit(assign(r3795, body.constant(0u), 0x01));


               body.instructions = f379A_parent_instructions;
               body.emit(f379A);

               /* END IF */

               ir_expression *const r37A8 = nequal(r3792, body.constant(0u));
               ir_expression *const r37A9 = expr(ir_unop_b2i, r37A8);
               ir_expression *const r37AA = expr(ir_unop_i2u, r37A9);
               body.emit(assign(r3793, bit_or(r3793, r37AA), 0x01));


            body.instructions = f3798_parent_instructions;
            body.emit(f3798);

            /* END IF */

            body.emit(assign(r375A, r3795, 0x01));

            body.emit(assign(r375B, r3794, 0x01));

            body.emit(assign(r375F, r3793, 0x01));

            body.emit(assign(r375E, r3765, 0x01));


         body.instructions = f376E_parent_instructions;
         body.emit(f376E);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f376C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r37AC = less(r3759, body.constant(int(0)));
         ir_if *f37AB = new(mem_ctx) ir_if(operand(r37AC).val);
         exec_list *const f37AB_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f37AB->then_instructions;

            /* IF CONDITION */
            ir_expression *const r37AE = equal(r3768, body.constant(int(2047)));
            ir_if *f37AD = new(mem_ctx) ir_if(operand(r37AE).val);
            exec_list *const f37AD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f37AD->then_instructions;

               /* IF CONDITION */
               ir_expression *const r37B0 = bit_or(r375A, r375B);
               ir_expression *const r37B1 = nequal(r37B0, body.constant(0u));
               ir_if *f37AF = new(mem_ctx) ir_if(operand(r37B1).val);
               exec_list *const f37AF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f37AF->then_instructions;

                  ir_variable *const r37B2 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r37B2, swizzle_x(r2D5A), 0x01));

                  ir_variable *const r37B3 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r37B3, swizzle_x(r3749), 0x01));

                  ir_variable *const r37B4 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r37B5 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r37B6 = rshift(swizzle_y(r2D5A), body.constant(int(19)));
                  ir_expression *const r37B7 = bit_and(r37B6, body.constant(4095u));
                  ir_expression *const r37B8 = equal(r37B7, body.constant(4094u));
                  ir_expression *const r37B9 = nequal(swizzle_x(r2D5A), body.constant(0u));
                  ir_expression *const r37BA = bit_and(swizzle_y(r2D5A), body.constant(524287u));
                  ir_expression *const r37BB = nequal(r37BA, body.constant(0u));
                  ir_expression *const r37BC = logic_or(r37B9, r37BB);
                  body.emit(assign(r37B5, logic_and(r37B8, r37BC), 0x01));

                  ir_variable *const r37BD = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r37BE = lshift(swizzle_y(r3749), body.constant(int(1)));
                  ir_expression *const r37BF = lequal(body.constant(4292870144u), r37BE);
                  ir_expression *const r37C0 = nequal(swizzle_x(r3749), body.constant(0u));
                  ir_expression *const r37C1 = bit_and(swizzle_y(r3749), body.constant(1048575u));
                  ir_expression *const r37C2 = nequal(r37C1, body.constant(0u));
                  ir_expression *const r37C3 = logic_or(r37C0, r37C2);
                  body.emit(assign(r37BD, logic_and(r37BF, r37C3), 0x01));

                  body.emit(assign(r37B2, bit_or(swizzle_y(r2D5A), body.constant(524288u)), 0x02));

                  body.emit(assign(r37B3, bit_or(swizzle_y(r3749), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r37C5 = lshift(swizzle_y(r2D5A), body.constant(int(1)));
                  ir_expression *const r37C6 = lequal(body.constant(4292870144u), r37C5);
                  ir_expression *const r37C7 = nequal(swizzle_x(r2D5A), body.constant(0u));
                  ir_expression *const r37C8 = bit_and(swizzle_y(r2D5A), body.constant(1048575u));
                  ir_expression *const r37C9 = nequal(r37C8, body.constant(0u));
                  ir_expression *const r37CA = logic_or(r37C7, r37C9);
                  ir_expression *const r37CB = logic_and(r37C6, r37CA);
                  ir_if *f37C4 = new(mem_ctx) ir_if(operand(r37CB).val);
                  exec_list *const f37C4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f37C4->then_instructions;

                     ir_variable *const r37CC = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r37CE = logic_and(r37B5, r37BD);
                     ir_if *f37CD = new(mem_ctx) ir_if(operand(r37CE).val);
                     exec_list *const f37CD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f37CD->then_instructions;

                        body.emit(assign(r37CC, r37B3, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f37CD->else_instructions;

                        body.emit(assign(r37CC, r37B2, 0x03));


                     body.instructions = f37CD_parent_instructions;
                     body.emit(f37CD);

                     /* END IF */

                     body.emit(assign(r37B4, r37CC, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f37C4->else_instructions;

                     body.emit(assign(r37B4, r37B3, 0x03));


                  body.instructions = f37C4_parent_instructions;
                  body.emit(f37C4);

                  /* END IF */

                  body.emit(assign(r3758, r37B4, 0x03));

                  body.emit(assign(r3757, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f37AF->else_instructions;

                  ir_variable *const r37CF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r37CF);
                  ir_expression *const r37D0 = lshift(r3753, body.constant(int(31)));
                  body.emit(assign(r37CF, add(r37D0, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r37CF, body.constant(0u), 0x01));

                  body.emit(assign(r3758, r37CF, 0x03));

                  body.emit(assign(r3757, body.constant(false), 0x01));


               body.instructions = f37AF_parent_instructions;
               body.emit(f37AF);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f37AD->else_instructions;

               /* IF CONDITION */
               ir_expression *const r37D2 = equal(r3765, body.constant(int(0)));
               ir_if *f37D1 = new(mem_ctx) ir_if(operand(r37D2).val);
               exec_list *const f37D1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f37D1->then_instructions;

                  body.emit(assign(r3759, add(r3759, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f37D1->else_instructions;

                  body.emit(assign(r375C, bit_or(r3762, body.constant(1048576u)), 0x01));


               body.instructions = f37D1_parent_instructions;
               body.emit(f37D1);

               /* END IF */

               ir_variable *const r37D3 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r37D3, body.constant(0u), 0x01));

               ir_variable *const r37D4 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r37D4, neg(r3759), 0x01));

               ir_variable *const r37D5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r37D5);
               ir_variable *const r37D6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r37D6);
               ir_variable *const r37D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r37D7);
               ir_variable *const r37D8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r37D9 = neg(r37D4);
               body.emit(assign(r37D8, bit_and(r37D9, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r37DB = equal(r37D4, body.constant(int(0)));
               ir_if *f37DA = new(mem_ctx) ir_if(operand(r37DB).val);
               exec_list *const f37DA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f37DA->then_instructions;

                  body.emit(assign(r37D5, r37D3, 0x01));

                  body.emit(assign(r37D6, r3761, 0x01));

                  body.emit(assign(r37D7, r375C, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f37DA->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r37DD = less(r37D4, body.constant(int(32)));
                  ir_if *f37DC = new(mem_ctx) ir_if(operand(r37DD).val);
                  exec_list *const f37DC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f37DC->then_instructions;

                     body.emit(assign(r37D5, lshift(swizzle_x(r2D5A), r37D8), 0x01));

                     ir_expression *const r37DE = lshift(r375C, r37D8);
                     ir_expression *const r37DF = rshift(swizzle_x(r2D5A), r37D4);
                     body.emit(assign(r37D6, bit_or(r37DE, r37DF), 0x01));

                     body.emit(assign(r37D7, rshift(r375C, r37D4), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f37DC->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r37E1 = equal(r37D4, body.constant(int(32)));
                     ir_if *f37E0 = new(mem_ctx) ir_if(operand(r37E1).val);
                     exec_list *const f37E0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f37E0->then_instructions;

                        body.emit(assign(r37D5, r3761, 0x01));

                        body.emit(assign(r37D6, r375C, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f37E0->else_instructions;

                        body.emit(assign(r37D3, bit_or(body.constant(0u), swizzle_x(r2D5A)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r37E3 = less(r37D4, body.constant(int(64)));
                        ir_if *f37E2 = new(mem_ctx) ir_if(operand(r37E3).val);
                        exec_list *const f37E2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f37E2->then_instructions;

                           body.emit(assign(r37D5, lshift(r375C, r37D8), 0x01));

                           ir_expression *const r37E4 = bit_and(r37D4, body.constant(int(31)));
                           body.emit(assign(r37D6, rshift(r375C, r37E4), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f37E2->else_instructions;

                           ir_variable *const r37E5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r37E7 = equal(r37D4, body.constant(int(64)));
                           ir_if *f37E6 = new(mem_ctx) ir_if(operand(r37E7).val);
                           exec_list *const f37E6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f37E6->then_instructions;

                              body.emit(assign(r37E5, r375C, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f37E6->else_instructions;

                              ir_expression *const r37E8 = nequal(r375C, body.constant(0u));
                              ir_expression *const r37E9 = expr(ir_unop_b2i, r37E8);
                              body.emit(assign(r37E5, expr(ir_unop_i2u, r37E9), 0x01));


                           body.instructions = f37E6_parent_instructions;
                           body.emit(f37E6);

                           /* END IF */

                           body.emit(assign(r37D5, r37E5, 0x01));

                           body.emit(assign(r37D6, body.constant(0u), 0x01));


                        body.instructions = f37E2_parent_instructions;
                        body.emit(f37E2);

                        /* END IF */


                     body.instructions = f37E0_parent_instructions;
                     body.emit(f37E0);

                     /* END IF */

                     body.emit(assign(r37D7, body.constant(0u), 0x01));


                  body.instructions = f37DC_parent_instructions;
                  body.emit(f37DC);

                  /* END IF */

                  ir_expression *const r37EA = nequal(r37D3, body.constant(0u));
                  ir_expression *const r37EB = expr(ir_unop_b2i, r37EA);
                  ir_expression *const r37EC = expr(ir_unop_i2u, r37EB);
                  body.emit(assign(r37D5, bit_or(r37D5, r37EC), 0x01));


               body.instructions = f37DA_parent_instructions;
               body.emit(f37DA);

               /* END IF */

               body.emit(assign(r375C, r37D7, 0x01));

               body.emit(assign(r375D, r37D6, 0x01));

               body.emit(assign(r375F, r37D5, 0x01));

               body.emit(assign(r375E, r3768, 0x01));


            body.instructions = f37AD_parent_instructions;
            body.emit(f37AD);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f37AB->else_instructions;

            /* IF CONDITION */
            ir_expression *const r37EE = equal(r3765, body.constant(int(2047)));
            ir_if *f37ED = new(mem_ctx) ir_if(operand(r37EE).val);
            exec_list *const f37ED_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f37ED->then_instructions;

               /* IF CONDITION */
               ir_expression *const r37F0 = bit_or(r375C, r375D);
               ir_expression *const r37F1 = bit_or(r375A, r375B);
               ir_expression *const r37F2 = bit_or(r37F0, r37F1);
               ir_expression *const r37F3 = nequal(r37F2, body.constant(0u));
               ir_if *f37EF = new(mem_ctx) ir_if(operand(r37F3).val);
               exec_list *const f37EF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f37EF->then_instructions;

                  ir_variable *const r37F4 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r37F4, swizzle_x(r2D5A), 0x01));

                  ir_variable *const r37F5 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r37F5, swizzle_x(r3749), 0x01));

                  ir_variable *const r37F6 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r37F7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r37F8 = rshift(swizzle_y(r2D5A), body.constant(int(19)));
                  ir_expression *const r37F9 = bit_and(r37F8, body.constant(4095u));
                  ir_expression *const r37FA = equal(r37F9, body.constant(4094u));
                  ir_expression *const r37FB = nequal(swizzle_x(r2D5A), body.constant(0u));
                  ir_expression *const r37FC = bit_and(swizzle_y(r2D5A), body.constant(524287u));
                  ir_expression *const r37FD = nequal(r37FC, body.constant(0u));
                  ir_expression *const r37FE = logic_or(r37FB, r37FD);
                  body.emit(assign(r37F7, logic_and(r37FA, r37FE), 0x01));

                  ir_variable *const r37FF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r3800 = lshift(swizzle_y(r3749), body.constant(int(1)));
                  ir_expression *const r3801 = lequal(body.constant(4292870144u), r3800);
                  ir_expression *const r3802 = nequal(swizzle_x(r3749), body.constant(0u));
                  ir_expression *const r3803 = bit_and(swizzle_y(r3749), body.constant(1048575u));
                  ir_expression *const r3804 = nequal(r3803, body.constant(0u));
                  ir_expression *const r3805 = logic_or(r3802, r3804);
                  body.emit(assign(r37FF, logic_and(r3801, r3805), 0x01));

                  body.emit(assign(r37F4, bit_or(swizzle_y(r2D5A), body.constant(524288u)), 0x02));

                  body.emit(assign(r37F5, bit_or(swizzle_y(r3749), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r3807 = lshift(swizzle_y(r2D5A), body.constant(int(1)));
                  ir_expression *const r3808 = lequal(body.constant(4292870144u), r3807);
                  ir_expression *const r3809 = nequal(swizzle_x(r2D5A), body.constant(0u));
                  ir_expression *const r380A = bit_and(swizzle_y(r2D5A), body.constant(1048575u));
                  ir_expression *const r380B = nequal(r380A, body.constant(0u));
                  ir_expression *const r380C = logic_or(r3809, r380B);
                  ir_expression *const r380D = logic_and(r3808, r380C);
                  ir_if *f3806 = new(mem_ctx) ir_if(operand(r380D).val);
                  exec_list *const f3806_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3806->then_instructions;

                     ir_variable *const r380E = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3810 = logic_and(r37F7, r37FF);
                     ir_if *f380F = new(mem_ctx) ir_if(operand(r3810).val);
                     exec_list *const f380F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f380F->then_instructions;

                        body.emit(assign(r380E, r37F5, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f380F->else_instructions;

                        body.emit(assign(r380E, r37F4, 0x03));


                     body.instructions = f380F_parent_instructions;
                     body.emit(f380F);

                     /* END IF */

                     body.emit(assign(r37F6, r380E, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3806->else_instructions;

                     body.emit(assign(r37F6, r37F5, 0x03));


                  body.instructions = f3806_parent_instructions;
                  body.emit(f3806);

                  /* END IF */

                  body.emit(assign(r3758, r37F6, 0x03));

                  body.emit(assign(r3757, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f37EF->else_instructions;

                  body.emit(assign(r3758, r2D5A, 0x03));

                  body.emit(assign(r3757, body.constant(false), 0x01));


               body.instructions = f37EF_parent_instructions;
               body.emit(f37EF);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f37ED->else_instructions;

               ir_variable *const r3811 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r3812 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3812, add(r375D, r375B), 0x01));

               ir_expression *const r3813 = add(r375C, r375A);
               ir_expression *const r3814 = less(r3812, r375D);
               ir_expression *const r3815 = expr(ir_unop_b2i, r3814);
               ir_expression *const r3816 = expr(ir_unop_i2u, r3815);
               body.emit(assign(r3811, add(r3813, r3816), 0x01));

               body.emit(assign(r3760, r3811, 0x01));

               /* IF CONDITION */
               ir_expression *const r3818 = equal(r3765, body.constant(int(0)));
               ir_if *f3817 = new(mem_ctx) ir_if(operand(r3818).val);
               exec_list *const f3817_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3817->then_instructions;

                  ir_variable *const r3819 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3819);
                  ir_expression *const r381A = lshift(r3753, body.constant(int(31)));
                  body.emit(assign(r3819, add(r381A, r3811), 0x02));

                  body.emit(assign(r3819, r3812, 0x01));

                  body.emit(assign(r3758, r3819, 0x03));

                  body.emit(assign(r3757, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3817->else_instructions;

                  body.emit(assign(r3760, bit_or(r3811, body.constant(2097152u)), 0x01));

                  body.emit(assign(r375E, r3765, 0x01));

                  ir_variable *const r381B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r381B);
                  ir_variable *const r381C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r381C);
                  ir_variable *const r381D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r381D);
                  body.emit(assign(r381B, lshift(r3812, body.constant(int(31))), 0x01));

                  ir_expression *const r381E = lshift(r3760, body.constant(int(31)));
                  ir_expression *const r381F = rshift(r3812, body.constant(int(1)));
                  body.emit(assign(r381C, bit_or(r381E, r381F), 0x01));

                  body.emit(assign(r381D, rshift(r3760, body.constant(int(1))), 0x01));

                  body.emit(assign(r381B, bit_or(r381B, body.constant(0u)), 0x01));

                  body.emit(assign(r3760, r381D, 0x01));

                  body.emit(assign(r375F, r381B, 0x01));

                  ir_variable *const r3820 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r3820, r3765, 0x01));

                  ir_variable *const r3821 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r3821, r381D, 0x01));

                  ir_variable *const r3822 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r3822, r381C, 0x01));

                  ir_variable *const r3823 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r3823, r381B, 0x01));

                  ir_variable *const r3824 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r3824, body.constant(true), 0x01));

                  ir_variable *const r3825 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3826 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r3826);
                  ir_expression *const r3827 = expr(ir_unop_u2i, r381B);
                  body.emit(assign(r3826, less(r3827, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3829 = lequal(body.constant(int(2045)), r3765);
                  ir_if *f3828 = new(mem_ctx) ir_if(operand(r3829).val);
                  exec_list *const f3828_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3828->then_instructions;

                     ir_variable *const r382A = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r382C = less(body.constant(int(2045)), r3765);
                     ir_if *f382B = new(mem_ctx) ir_if(operand(r382C).val);
                     exec_list *const f382B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f382B->then_instructions;

                        body.emit(assign(r382A, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f382B->else_instructions;

                        ir_variable *const r382D = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r382F = equal(r3765, body.constant(int(2045)));
                        ir_if *f382E = new(mem_ctx) ir_if(operand(r382F).val);
                        exec_list *const f382E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f382E->then_instructions;

                           ir_expression *const r3830 = equal(body.constant(2097151u), r381D);
                           ir_expression *const r3831 = equal(body.constant(4294967295u), r381C);
                           body.emit(assign(r382D, logic_and(r3830, r3831), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f382E->else_instructions;

                           body.emit(assign(r382D, body.constant(false), 0x01));


                        body.instructions = f382E_parent_instructions;
                        body.emit(f382E);

                        /* END IF */

                        body.emit(assign(r382A, logic_and(r382D, r3826), 0x01));


                     body.instructions = f382B_parent_instructions;
                     body.emit(f382B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f3832 = new(mem_ctx) ir_if(operand(r382A).val);
                     exec_list *const f3832_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3832->then_instructions;

                        ir_variable *const r3833 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3833);
                        ir_expression *const r3834 = lshift(r3753, body.constant(int(31)));
                        body.emit(assign(r3833, add(r3834, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r3833, body.constant(0u), 0x01));

                        body.emit(assign(r3825, r3833, 0x03));

                        body.emit(assign(r3824, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3832->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3836 = less(r3765, body.constant(int(0)));
                        ir_if *f3835 = new(mem_ctx) ir_if(operand(r3836).val);
                        exec_list *const f3835_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3835->then_instructions;

                           ir_variable *const r3837 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3837, r381B, 0x01));

                           ir_variable *const r3838 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3838, neg(r3765), 0x01));

                           ir_variable *const r3839 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3839);
                           ir_variable *const r383A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r383A);
                           ir_variable *const r383B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r383B);
                           ir_variable *const r383C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r383D = neg(r3838);
                           body.emit(assign(r383C, bit_and(r383D, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r383F = equal(r3838, body.constant(int(0)));
                           ir_if *f383E = new(mem_ctx) ir_if(operand(r383F).val);
                           exec_list *const f383E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f383E->then_instructions;

                              body.emit(assign(r3839, r381B, 0x01));

                              body.emit(assign(r383A, r381C, 0x01));

                              body.emit(assign(r383B, r381D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f383E->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3841 = less(r3838, body.constant(int(32)));
                              ir_if *f3840 = new(mem_ctx) ir_if(operand(r3841).val);
                              exec_list *const f3840_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3840->then_instructions;

                                 body.emit(assign(r3839, lshift(r381C, r383C), 0x01));

                                 ir_expression *const r3842 = lshift(r381D, r383C);
                                 ir_expression *const r3843 = rshift(r381C, r3838);
                                 body.emit(assign(r383A, bit_or(r3842, r3843), 0x01));

                                 body.emit(assign(r383B, rshift(r381D, r3838), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3840->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3845 = equal(r3838, body.constant(int(32)));
                                 ir_if *f3844 = new(mem_ctx) ir_if(operand(r3845).val);
                                 exec_list *const f3844_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3844->then_instructions;

                                    body.emit(assign(r3839, r381C, 0x01));

                                    body.emit(assign(r383A, r381D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3844->else_instructions;

                                    body.emit(assign(r3837, bit_or(r381B, r381C), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3847 = less(r3838, body.constant(int(64)));
                                    ir_if *f3846 = new(mem_ctx) ir_if(operand(r3847).val);
                                    exec_list *const f3846_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3846->then_instructions;

                                       body.emit(assign(r3839, lshift(r381D, r383C), 0x01));

                                       ir_expression *const r3848 = bit_and(r3838, body.constant(int(31)));
                                       body.emit(assign(r383A, rshift(r381D, r3848), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3846->else_instructions;

                                       ir_variable *const r3849 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r384B = equal(r3838, body.constant(int(64)));
                                       ir_if *f384A = new(mem_ctx) ir_if(operand(r384B).val);
                                       exec_list *const f384A_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f384A->then_instructions;

                                          body.emit(assign(r3849, r381D, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f384A->else_instructions;

                                          ir_expression *const r384C = nequal(r381D, body.constant(0u));
                                          ir_expression *const r384D = expr(ir_unop_b2i, r384C);
                                          body.emit(assign(r3849, expr(ir_unop_i2u, r384D), 0x01));


                                       body.instructions = f384A_parent_instructions;
                                       body.emit(f384A);

                                       /* END IF */

                                       body.emit(assign(r3839, r3849, 0x01));

                                       body.emit(assign(r383A, body.constant(0u), 0x01));


                                    body.instructions = f3846_parent_instructions;
                                    body.emit(f3846);

                                    /* END IF */


                                 body.instructions = f3844_parent_instructions;
                                 body.emit(f3844);

                                 /* END IF */

                                 body.emit(assign(r383B, body.constant(0u), 0x01));


                              body.instructions = f3840_parent_instructions;
                              body.emit(f3840);

                              /* END IF */

                              ir_expression *const r384E = nequal(r3837, body.constant(0u));
                              ir_expression *const r384F = expr(ir_unop_b2i, r384E);
                              ir_expression *const r3850 = expr(ir_unop_i2u, r384F);
                              body.emit(assign(r3839, bit_or(r3839, r3850), 0x01));


                           body.instructions = f383E_parent_instructions;
                           body.emit(f383E);

                           /* END IF */

                           body.emit(assign(r3821, r383B, 0x01));

                           body.emit(assign(r3822, r383A, 0x01));

                           body.emit(assign(r3823, r3839, 0x01));

                           body.emit(assign(r3820, body.constant(int(0)), 0x01));

                           body.emit(assign(r3826, less(r3839, body.constant(0u)), 0x01));


                        body.instructions = f3835_parent_instructions;
                        body.emit(f3835);

                        /* END IF */


                     body.instructions = f3832_parent_instructions;
                     body.emit(f3832);

                     /* END IF */


                  body.instructions = f3828_parent_instructions;
                  body.emit(f3828);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3851 = new(mem_ctx) ir_if(operand(r3824).val);
                  exec_list *const f3851_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3851->then_instructions;

                     /* IF CONDITION */
                     ir_if *f3852 = new(mem_ctx) ir_if(operand(r3826).val);
                     exec_list *const f3852_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3852->then_instructions;

                        ir_variable *const r3853 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r3853, add(r3822, body.constant(1u)), 0x01));

                        ir_expression *const r3854 = less(r3853, r3822);
                        ir_expression *const r3855 = expr(ir_unop_b2i, r3854);
                        ir_expression *const r3856 = expr(ir_unop_i2u, r3855);
                        body.emit(assign(r3821, add(r3821, r3856), 0x01));

                        ir_expression *const r3857 = equal(r3823, body.constant(0u));
                        ir_expression *const r3858 = expr(ir_unop_b2i, r3857);
                        ir_expression *const r3859 = expr(ir_unop_i2u, r3858);
                        ir_expression *const r385A = add(r3823, r3859);
                        ir_expression *const r385B = bit_and(r385A, body.constant(1u));
                        ir_expression *const r385C = expr(ir_unop_bit_not, r385B);
                        body.emit(assign(r3822, bit_and(r3853, r385C), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3852->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r385E = bit_or(r3821, r3822);
                        ir_expression *const r385F = equal(r385E, body.constant(0u));
                        ir_if *f385D = new(mem_ctx) ir_if(operand(r385F).val);
                        exec_list *const f385D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f385D->then_instructions;

                           body.emit(assign(r3820, body.constant(int(0)), 0x01));


                        body.instructions = f385D_parent_instructions;
                        body.emit(f385D);

                        /* END IF */


                     body.instructions = f3852_parent_instructions;
                     body.emit(f3852);

                     /* END IF */

                     ir_variable *const r3860 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3860);
                     ir_expression *const r3861 = lshift(r3753, body.constant(int(31)));
                     ir_expression *const r3862 = expr(ir_unop_i2u, r3820);
                     ir_expression *const r3863 = lshift(r3862, body.constant(int(20)));
                     ir_expression *const r3864 = add(r3861, r3863);
                     body.emit(assign(r3860, add(r3864, r3821), 0x02));

                     body.emit(assign(r3860, r3822, 0x01));

                     body.emit(assign(r3825, r3860, 0x03));

                     body.emit(assign(r3824, body.constant(false), 0x01));


                  body.instructions = f3851_parent_instructions;
                  body.emit(f3851);

                  /* END IF */

                  body.emit(assign(r3758, r3825, 0x03));

                  body.emit(assign(r3757, body.constant(false), 0x01));


               body.instructions = f3817_parent_instructions;
               body.emit(f3817);

               /* END IF */


            body.instructions = f37ED_parent_instructions;
            body.emit(f37ED);

            /* END IF */


         body.instructions = f37AB_parent_instructions;
         body.emit(f37AB);

         /* END IF */


      body.instructions = f376C_parent_instructions;
      body.emit(f376C);

      /* END IF */

      /* IF CONDITION */
      ir_if *f3865 = new(mem_ctx) ir_if(operand(r3757).val);
      exec_list *const f3865_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3865->then_instructions;

         body.emit(assign(r375C, bit_or(r375C, body.constant(1048576u)), 0x01));

         ir_variable *const r3866 = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r3867 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r3867, add(r375D, r375B), 0x01));

         ir_expression *const r3868 = add(r375C, r375A);
         ir_expression *const r3869 = less(r3867, r375D);
         ir_expression *const r386A = expr(ir_unop_b2i, r3869);
         ir_expression *const r386B = expr(ir_unop_i2u, r386A);
         body.emit(assign(r3866, add(r3868, r386B), 0x01));

         body.emit(assign(r3760, r3866, 0x01));

         body.emit(assign(r375E, add(r375E, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r386D = less(r3866, body.constant(2097152u));
         ir_if *f386C = new(mem_ctx) ir_if(operand(r386D).val);
         exec_list *const f386C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f386C->then_instructions;

            ir_variable *const r386E = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r386E, r375E, 0x01));

            ir_variable *const r386F = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r386F, r3866, 0x01));

            ir_variable *const r3870 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r3870, r3867, 0x01));

            ir_variable *const r3871 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r3871, r375F, 0x01));

            ir_variable *const r3872 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r3872, body.constant(true), 0x01));

            ir_variable *const r3873 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r3874 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r3874);
            ir_expression *const r3875 = expr(ir_unop_u2i, r375F);
            body.emit(assign(r3874, less(r3875, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3877 = lequal(body.constant(int(2045)), r375E);
            ir_if *f3876 = new(mem_ctx) ir_if(operand(r3877).val);
            exec_list *const f3876_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3876->then_instructions;

               ir_variable *const r3878 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r387A = less(body.constant(int(2045)), r375E);
               ir_if *f3879 = new(mem_ctx) ir_if(operand(r387A).val);
               exec_list *const f3879_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3879->then_instructions;

                  body.emit(assign(r3878, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3879->else_instructions;

                  ir_variable *const r387B = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r387D = equal(r375E, body.constant(int(2045)));
                  ir_if *f387C = new(mem_ctx) ir_if(operand(r387D).val);
                  exec_list *const f387C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f387C->then_instructions;

                     ir_expression *const r387E = equal(body.constant(2097151u), r3866);
                     ir_expression *const r387F = equal(body.constant(4294967295u), r3867);
                     body.emit(assign(r387B, logic_and(r387E, r387F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f387C->else_instructions;

                     body.emit(assign(r387B, body.constant(false), 0x01));


                  body.instructions = f387C_parent_instructions;
                  body.emit(f387C);

                  /* END IF */

                  body.emit(assign(r3878, logic_and(r387B, r3874), 0x01));


               body.instructions = f3879_parent_instructions;
               body.emit(f3879);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3880 = new(mem_ctx) ir_if(operand(r3878).val);
               exec_list *const f3880_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3880->then_instructions;

                  ir_variable *const r3881 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3881);
                  ir_expression *const r3882 = lshift(r3753, body.constant(int(31)));
                  body.emit(assign(r3881, add(r3882, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r3881, body.constant(0u), 0x01));

                  body.emit(assign(r3873, r3881, 0x03));

                  body.emit(assign(r3872, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3880->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3884 = less(r375E, body.constant(int(0)));
                  ir_if *f3883 = new(mem_ctx) ir_if(operand(r3884).val);
                  exec_list *const f3883_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3883->then_instructions;

                     ir_variable *const r3885 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r3885, r375F, 0x01));

                     ir_variable *const r3886 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r3886, neg(r375E), 0x01));

                     ir_variable *const r3887 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r3887);
                     ir_variable *const r3888 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3888);
                     ir_variable *const r3889 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3889);
                     ir_variable *const r388A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r388B = neg(r3886);
                     body.emit(assign(r388A, bit_and(r388B, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r388D = equal(r3886, body.constant(int(0)));
                     ir_if *f388C = new(mem_ctx) ir_if(operand(r388D).val);
                     exec_list *const f388C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f388C->then_instructions;

                        body.emit(assign(r3887, r375F, 0x01));

                        body.emit(assign(r3888, r3867, 0x01));

                        body.emit(assign(r3889, r3866, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f388C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r388F = less(r3886, body.constant(int(32)));
                        ir_if *f388E = new(mem_ctx) ir_if(operand(r388F).val);
                        exec_list *const f388E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f388E->then_instructions;

                           body.emit(assign(r3887, lshift(r3867, r388A), 0x01));

                           ir_expression *const r3890 = lshift(r3866, r388A);
                           ir_expression *const r3891 = rshift(r3867, r3886);
                           body.emit(assign(r3888, bit_or(r3890, r3891), 0x01));

                           body.emit(assign(r3889, rshift(r3866, r3886), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f388E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3893 = equal(r3886, body.constant(int(32)));
                           ir_if *f3892 = new(mem_ctx) ir_if(operand(r3893).val);
                           exec_list *const f3892_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3892->then_instructions;

                              body.emit(assign(r3887, r3867, 0x01));

                              body.emit(assign(r3888, r3866, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3892->else_instructions;

                              body.emit(assign(r3885, bit_or(r375F, r3867), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3895 = less(r3886, body.constant(int(64)));
                              ir_if *f3894 = new(mem_ctx) ir_if(operand(r3895).val);
                              exec_list *const f3894_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3894->then_instructions;

                                 body.emit(assign(r3887, lshift(r3866, r388A), 0x01));

                                 ir_expression *const r3896 = bit_and(r3886, body.constant(int(31)));
                                 body.emit(assign(r3888, rshift(r3866, r3896), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3894->else_instructions;

                                 ir_variable *const r3897 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3899 = equal(r3886, body.constant(int(64)));
                                 ir_if *f3898 = new(mem_ctx) ir_if(operand(r3899).val);
                                 exec_list *const f3898_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3898->then_instructions;

                                    body.emit(assign(r3897, r3866, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3898->else_instructions;

                                    ir_expression *const r389A = nequal(r3866, body.constant(0u));
                                    ir_expression *const r389B = expr(ir_unop_b2i, r389A);
                                    body.emit(assign(r3897, expr(ir_unop_i2u, r389B), 0x01));


                                 body.instructions = f3898_parent_instructions;
                                 body.emit(f3898);

                                 /* END IF */

                                 body.emit(assign(r3887, r3897, 0x01));

                                 body.emit(assign(r3888, body.constant(0u), 0x01));


                              body.instructions = f3894_parent_instructions;
                              body.emit(f3894);

                              /* END IF */


                           body.instructions = f3892_parent_instructions;
                           body.emit(f3892);

                           /* END IF */

                           body.emit(assign(r3889, body.constant(0u), 0x01));


                        body.instructions = f388E_parent_instructions;
                        body.emit(f388E);

                        /* END IF */

                        ir_expression *const r389C = nequal(r3885, body.constant(0u));
                        ir_expression *const r389D = expr(ir_unop_b2i, r389C);
                        ir_expression *const r389E = expr(ir_unop_i2u, r389D);
                        body.emit(assign(r3887, bit_or(r3887, r389E), 0x01));


                     body.instructions = f388C_parent_instructions;
                     body.emit(f388C);

                     /* END IF */

                     body.emit(assign(r386F, r3889, 0x01));

                     body.emit(assign(r3870, r3888, 0x01));

                     body.emit(assign(r3871, r3887, 0x01));

                     body.emit(assign(r386E, body.constant(int(0)), 0x01));

                     body.emit(assign(r3874, less(r3887, body.constant(0u)), 0x01));


                  body.instructions = f3883_parent_instructions;
                  body.emit(f3883);

                  /* END IF */


               body.instructions = f3880_parent_instructions;
               body.emit(f3880);

               /* END IF */


            body.instructions = f3876_parent_instructions;
            body.emit(f3876);

            /* END IF */

            /* IF CONDITION */
            ir_if *f389F = new(mem_ctx) ir_if(operand(r3872).val);
            exec_list *const f389F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f389F->then_instructions;

               /* IF CONDITION */
               ir_if *f38A0 = new(mem_ctx) ir_if(operand(r3874).val);
               exec_list *const f38A0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f38A0->then_instructions;

                  ir_variable *const r38A1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r38A1, add(r3870, body.constant(1u)), 0x01));

                  ir_expression *const r38A2 = less(r38A1, r3870);
                  ir_expression *const r38A3 = expr(ir_unop_b2i, r38A2);
                  ir_expression *const r38A4 = expr(ir_unop_i2u, r38A3);
                  body.emit(assign(r386F, add(r386F, r38A4), 0x01));

                  ir_expression *const r38A5 = equal(r3871, body.constant(0u));
                  ir_expression *const r38A6 = expr(ir_unop_b2i, r38A5);
                  ir_expression *const r38A7 = expr(ir_unop_i2u, r38A6);
                  ir_expression *const r38A8 = add(r3871, r38A7);
                  ir_expression *const r38A9 = bit_and(r38A8, body.constant(1u));
                  ir_expression *const r38AA = expr(ir_unop_bit_not, r38A9);
                  body.emit(assign(r3870, bit_and(r38A1, r38AA), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f38A0->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r38AC = bit_or(r386F, r3870);
                  ir_expression *const r38AD = equal(r38AC, body.constant(0u));
                  ir_if *f38AB = new(mem_ctx) ir_if(operand(r38AD).val);
                  exec_list *const f38AB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f38AB->then_instructions;

                     body.emit(assign(r386E, body.constant(int(0)), 0x01));


                  body.instructions = f38AB_parent_instructions;
                  body.emit(f38AB);

                  /* END IF */


               body.instructions = f38A0_parent_instructions;
               body.emit(f38A0);

               /* END IF */

               ir_variable *const r38AE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r38AE);
               ir_expression *const r38AF = lshift(r3753, body.constant(int(31)));
               ir_expression *const r38B0 = expr(ir_unop_i2u, r386E);
               ir_expression *const r38B1 = lshift(r38B0, body.constant(int(20)));
               ir_expression *const r38B2 = add(r38AF, r38B1);
               body.emit(assign(r38AE, add(r38B2, r386F), 0x02));

               body.emit(assign(r38AE, r3870, 0x01));

               body.emit(assign(r3873, r38AE, 0x03));

               body.emit(assign(r3872, body.constant(false), 0x01));


            body.instructions = f389F_parent_instructions;
            body.emit(f389F);

            /* END IF */

            body.emit(assign(r3758, r3873, 0x03));

            body.emit(assign(r3757, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f386C->else_instructions;

            body.emit(assign(r375E, add(r375E, body.constant(int(1))), 0x01));

            ir_variable *const r38B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r38B3);
            ir_variable *const r38B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r38B4);
            ir_variable *const r38B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r38B5);
            body.emit(assign(r38B3, lshift(r3867, body.constant(int(31))), 0x01));

            ir_expression *const r38B6 = lshift(r3866, body.constant(int(31)));
            ir_expression *const r38B7 = rshift(r3867, body.constant(int(1)));
            body.emit(assign(r38B4, bit_or(r38B6, r38B7), 0x01));

            body.emit(assign(r38B5, rshift(r3866, body.constant(int(1))), 0x01));

            ir_expression *const r38B8 = nequal(r375F, body.constant(0u));
            ir_expression *const r38B9 = expr(ir_unop_b2i, r38B8);
            ir_expression *const r38BA = expr(ir_unop_i2u, r38B9);
            body.emit(assign(r38B3, bit_or(r38B3, r38BA), 0x01));

            body.emit(assign(r3760, r38B5, 0x01));

            body.emit(assign(r375F, r38B3, 0x01));

            ir_variable *const r38BB = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r38BB, r375E, 0x01));

            ir_variable *const r38BC = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r38BC, r38B5, 0x01));

            ir_variable *const r38BD = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r38BD, r38B4, 0x01));

            ir_variable *const r38BE = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r38BE, r38B3, 0x01));

            ir_variable *const r38BF = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r38BF, body.constant(true), 0x01));

            ir_variable *const r38C0 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r38C1 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r38C1);
            ir_expression *const r38C2 = expr(ir_unop_u2i, r38B3);
            body.emit(assign(r38C1, less(r38C2, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r38C4 = lequal(body.constant(int(2045)), r375E);
            ir_if *f38C3 = new(mem_ctx) ir_if(operand(r38C4).val);
            exec_list *const f38C3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f38C3->then_instructions;

               ir_variable *const r38C5 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r38C7 = less(body.constant(int(2045)), r375E);
               ir_if *f38C6 = new(mem_ctx) ir_if(operand(r38C7).val);
               exec_list *const f38C6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f38C6->then_instructions;

                  body.emit(assign(r38C5, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f38C6->else_instructions;

                  ir_variable *const r38C8 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r38CA = equal(r375E, body.constant(int(2045)));
                  ir_if *f38C9 = new(mem_ctx) ir_if(operand(r38CA).val);
                  exec_list *const f38C9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f38C9->then_instructions;

                     ir_expression *const r38CB = equal(body.constant(2097151u), r38B5);
                     ir_expression *const r38CC = equal(body.constant(4294967295u), r38B4);
                     body.emit(assign(r38C8, logic_and(r38CB, r38CC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f38C9->else_instructions;

                     body.emit(assign(r38C8, body.constant(false), 0x01));


                  body.instructions = f38C9_parent_instructions;
                  body.emit(f38C9);

                  /* END IF */

                  body.emit(assign(r38C5, logic_and(r38C8, r38C1), 0x01));


               body.instructions = f38C6_parent_instructions;
               body.emit(f38C6);

               /* END IF */

               /* IF CONDITION */
               ir_if *f38CD = new(mem_ctx) ir_if(operand(r38C5).val);
               exec_list *const f38CD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f38CD->then_instructions;

                  ir_variable *const r38CE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r38CE);
                  ir_expression *const r38CF = lshift(r3753, body.constant(int(31)));
                  body.emit(assign(r38CE, add(r38CF, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r38CE, body.constant(0u), 0x01));

                  body.emit(assign(r38C0, r38CE, 0x03));

                  body.emit(assign(r38BF, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f38CD->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r38D1 = less(r375E, body.constant(int(0)));
                  ir_if *f38D0 = new(mem_ctx) ir_if(operand(r38D1).val);
                  exec_list *const f38D0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f38D0->then_instructions;

                     ir_variable *const r38D2 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r38D2, r38B3, 0x01));

                     ir_variable *const r38D3 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r38D3, neg(r375E), 0x01));

                     ir_variable *const r38D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r38D4);
                     ir_variable *const r38D5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r38D5);
                     ir_variable *const r38D6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r38D6);
                     ir_variable *const r38D7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r38D8 = neg(r38D3);
                     body.emit(assign(r38D7, bit_and(r38D8, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r38DA = equal(r38D3, body.constant(int(0)));
                     ir_if *f38D9 = new(mem_ctx) ir_if(operand(r38DA).val);
                     exec_list *const f38D9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f38D9->then_instructions;

                        body.emit(assign(r38D4, r38B3, 0x01));

                        body.emit(assign(r38D5, r38B4, 0x01));

                        body.emit(assign(r38D6, r38B5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f38D9->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r38DC = less(r38D3, body.constant(int(32)));
                        ir_if *f38DB = new(mem_ctx) ir_if(operand(r38DC).val);
                        exec_list *const f38DB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f38DB->then_instructions;

                           body.emit(assign(r38D4, lshift(r38B4, r38D7), 0x01));

                           ir_expression *const r38DD = lshift(r38B5, r38D7);
                           ir_expression *const r38DE = rshift(r38B4, r38D3);
                           body.emit(assign(r38D5, bit_or(r38DD, r38DE), 0x01));

                           body.emit(assign(r38D6, rshift(r38B5, r38D3), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f38DB->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r38E0 = equal(r38D3, body.constant(int(32)));
                           ir_if *f38DF = new(mem_ctx) ir_if(operand(r38E0).val);
                           exec_list *const f38DF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f38DF->then_instructions;

                              body.emit(assign(r38D4, r38B4, 0x01));

                              body.emit(assign(r38D5, r38B5, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f38DF->else_instructions;

                              body.emit(assign(r38D2, bit_or(r38B3, r38B4), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r38E2 = less(r38D3, body.constant(int(64)));
                              ir_if *f38E1 = new(mem_ctx) ir_if(operand(r38E2).val);
                              exec_list *const f38E1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f38E1->then_instructions;

                                 body.emit(assign(r38D4, lshift(r38B5, r38D7), 0x01));

                                 ir_expression *const r38E3 = bit_and(r38D3, body.constant(int(31)));
                                 body.emit(assign(r38D5, rshift(r38B5, r38E3), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f38E1->else_instructions;

                                 ir_variable *const r38E4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r38E6 = equal(r38D3, body.constant(int(64)));
                                 ir_if *f38E5 = new(mem_ctx) ir_if(operand(r38E6).val);
                                 exec_list *const f38E5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f38E5->then_instructions;

                                    body.emit(assign(r38E4, r38B5, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f38E5->else_instructions;

                                    ir_expression *const r38E7 = nequal(r38B5, body.constant(0u));
                                    ir_expression *const r38E8 = expr(ir_unop_b2i, r38E7);
                                    body.emit(assign(r38E4, expr(ir_unop_i2u, r38E8), 0x01));


                                 body.instructions = f38E5_parent_instructions;
                                 body.emit(f38E5);

                                 /* END IF */

                                 body.emit(assign(r38D4, r38E4, 0x01));

                                 body.emit(assign(r38D5, body.constant(0u), 0x01));


                              body.instructions = f38E1_parent_instructions;
                              body.emit(f38E1);

                              /* END IF */


                           body.instructions = f38DF_parent_instructions;
                           body.emit(f38DF);

                           /* END IF */

                           body.emit(assign(r38D6, body.constant(0u), 0x01));


                        body.instructions = f38DB_parent_instructions;
                        body.emit(f38DB);

                        /* END IF */

                        ir_expression *const r38E9 = nequal(r38D2, body.constant(0u));
                        ir_expression *const r38EA = expr(ir_unop_b2i, r38E9);
                        ir_expression *const r38EB = expr(ir_unop_i2u, r38EA);
                        body.emit(assign(r38D4, bit_or(r38D4, r38EB), 0x01));


                     body.instructions = f38D9_parent_instructions;
                     body.emit(f38D9);

                     /* END IF */

                     body.emit(assign(r38BC, r38D6, 0x01));

                     body.emit(assign(r38BD, r38D5, 0x01));

                     body.emit(assign(r38BE, r38D4, 0x01));

                     body.emit(assign(r38BB, body.constant(int(0)), 0x01));

                     body.emit(assign(r38C1, less(r38D4, body.constant(0u)), 0x01));


                  body.instructions = f38D0_parent_instructions;
                  body.emit(f38D0);

                  /* END IF */


               body.instructions = f38CD_parent_instructions;
               body.emit(f38CD);

               /* END IF */


            body.instructions = f38C3_parent_instructions;
            body.emit(f38C3);

            /* END IF */

            /* IF CONDITION */
            ir_if *f38EC = new(mem_ctx) ir_if(operand(r38BF).val);
            exec_list *const f38EC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f38EC->then_instructions;

               /* IF CONDITION */
               ir_if *f38ED = new(mem_ctx) ir_if(operand(r38C1).val);
               exec_list *const f38ED_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f38ED->then_instructions;

                  ir_variable *const r38EE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r38EE, add(r38BD, body.constant(1u)), 0x01));

                  ir_expression *const r38EF = less(r38EE, r38BD);
                  ir_expression *const r38F0 = expr(ir_unop_b2i, r38EF);
                  ir_expression *const r38F1 = expr(ir_unop_i2u, r38F0);
                  body.emit(assign(r38BC, add(r38BC, r38F1), 0x01));

                  ir_expression *const r38F2 = equal(r38BE, body.constant(0u));
                  ir_expression *const r38F3 = expr(ir_unop_b2i, r38F2);
                  ir_expression *const r38F4 = expr(ir_unop_i2u, r38F3);
                  ir_expression *const r38F5 = add(r38BE, r38F4);
                  ir_expression *const r38F6 = bit_and(r38F5, body.constant(1u));
                  ir_expression *const r38F7 = expr(ir_unop_bit_not, r38F6);
                  body.emit(assign(r38BD, bit_and(r38EE, r38F7), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f38ED->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r38F9 = bit_or(r38BC, r38BD);
                  ir_expression *const r38FA = equal(r38F9, body.constant(0u));
                  ir_if *f38F8 = new(mem_ctx) ir_if(operand(r38FA).val);
                  exec_list *const f38F8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f38F8->then_instructions;

                     body.emit(assign(r38BB, body.constant(int(0)), 0x01));


                  body.instructions = f38F8_parent_instructions;
                  body.emit(f38F8);

                  /* END IF */


               body.instructions = f38ED_parent_instructions;
               body.emit(f38ED);

               /* END IF */

               ir_variable *const r38FB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r38FB);
               ir_expression *const r38FC = lshift(r3753, body.constant(int(31)));
               ir_expression *const r38FD = expr(ir_unop_i2u, r38BB);
               ir_expression *const r38FE = lshift(r38FD, body.constant(int(20)));
               ir_expression *const r38FF = add(r38FC, r38FE);
               body.emit(assign(r38FB, add(r38FF, r38BC), 0x02));

               body.emit(assign(r38FB, r38BD, 0x01));

               body.emit(assign(r38C0, r38FB, 0x03));

               body.emit(assign(r38BF, body.constant(false), 0x01));


            body.instructions = f38EC_parent_instructions;
            body.emit(f38EC);

            /* END IF */

            body.emit(assign(r3758, r38C0, 0x03));

            body.emit(assign(r3757, body.constant(false), 0x01));


         body.instructions = f386C_parent_instructions;
         body.emit(f386C);

         /* END IF */


      body.instructions = f3865_parent_instructions;
      body.emit(f3865);

      /* END IF */

      body.emit(assign(r3752, r3758, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f3755->else_instructions;

      ir_variable *const r3900 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r3900, r3753, 0x01));

      ir_variable *const r3901 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r3902 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r3902);
      ir_variable *const r3903 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r3903);
      ir_variable *const r3904 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r3904);
      ir_variable *const r3905 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r3905);
      ir_variable *const r3906 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r3906);
      ir_variable *const r3907 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r3907);
      ir_variable *const r3908 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r3908);
      ir_variable *const r3909 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r3909);
      ir_variable *const r390A = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r390B = rshift(swizzle_y(r2D5A), body.constant(int(20)));
      ir_expression *const r390C = bit_and(r390B, body.constant(2047u));
      body.emit(assign(r390A, expr(ir_unop_u2i, r390C), 0x01));

      body.emit(assign(r3904, r390A, 0x01));

      ir_variable *const r390D = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r390E = rshift(swizzle_y(r3749), body.constant(int(20)));
      ir_expression *const r390F = bit_and(r390E, body.constant(2047u));
      body.emit(assign(r390D, expr(ir_unop_u2i, r390F), 0x01));

      body.emit(assign(r3903, r390D, 0x01));

      body.emit(assign(r3902, sub(r390A, r390D), 0x01));

      ir_variable *const r3910 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r3910, lshift(swizzle_x(r2D5A), body.constant(int(10))), 0x01));

      ir_variable *const r3911 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r3912 = bit_and(swizzle_y(r2D5A), body.constant(1048575u));
      ir_expression *const r3913 = lshift(r3912, body.constant(int(10)));
      ir_expression *const r3914 = rshift(swizzle_x(r2D5A), body.constant(int(22)));
      body.emit(assign(r3911, bit_or(r3913, r3914), 0x01));

      body.emit(assign(r3907, r3911, 0x01));

      body.emit(assign(r3908, r3910, 0x01));

      ir_variable *const r3915 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r3915, lshift(swizzle_x(r3749), body.constant(int(10))), 0x01));

      ir_variable *const r3916 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r3917 = bit_and(swizzle_y(r3749), body.constant(1048575u));
      ir_expression *const r3918 = lshift(r3917, body.constant(int(10)));
      ir_expression *const r3919 = rshift(swizzle_x(r3749), body.constant(int(22)));
      body.emit(assign(r3916, bit_or(r3918, r3919), 0x01));

      body.emit(assign(r3905, r3916, 0x01));

      body.emit(assign(r3906, r3915, 0x01));

      /* IF CONDITION */
      ir_expression *const r391B = less(body.constant(int(0)), r3902);
      ir_if *f391A = new(mem_ctx) ir_if(operand(r391B).val);
      exec_list *const f391A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f391A->then_instructions;

         /* IF CONDITION */
         ir_expression *const r391D = equal(r390A, body.constant(int(2047)));
         ir_if *f391C = new(mem_ctx) ir_if(operand(r391D).val);
         exec_list *const f391C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f391C->then_instructions;

            /* IF CONDITION */
            ir_expression *const r391F = bit_or(r3911, r3910);
            ir_expression *const r3920 = nequal(r391F, body.constant(0u));
            ir_if *f391E = new(mem_ctx) ir_if(operand(r3920).val);
            exec_list *const f391E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f391E->then_instructions;

               ir_variable *const r3921 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r3921, swizzle_x(r2D5A), 0x01));

               ir_variable *const r3922 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r3922, swizzle_x(r3749), 0x01));

               ir_variable *const r3923 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3924 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r3925 = rshift(swizzle_y(r2D5A), body.constant(int(19)));
               ir_expression *const r3926 = bit_and(r3925, body.constant(4095u));
               ir_expression *const r3927 = equal(r3926, body.constant(4094u));
               ir_expression *const r3928 = nequal(swizzle_x(r2D5A), body.constant(0u));
               ir_expression *const r3929 = bit_and(swizzle_y(r2D5A), body.constant(524287u));
               ir_expression *const r392A = nequal(r3929, body.constant(0u));
               ir_expression *const r392B = logic_or(r3928, r392A);
               body.emit(assign(r3924, logic_and(r3927, r392B), 0x01));

               ir_variable *const r392C = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r392D = lshift(swizzle_y(r3749), body.constant(int(1)));
               ir_expression *const r392E = lequal(body.constant(4292870144u), r392D);
               ir_expression *const r392F = nequal(swizzle_x(r3749), body.constant(0u));
               ir_expression *const r3930 = bit_and(swizzle_y(r3749), body.constant(1048575u));
               ir_expression *const r3931 = nequal(r3930, body.constant(0u));
               ir_expression *const r3932 = logic_or(r392F, r3931);
               body.emit(assign(r392C, logic_and(r392E, r3932), 0x01));

               body.emit(assign(r3921, bit_or(swizzle_y(r2D5A), body.constant(524288u)), 0x02));

               body.emit(assign(r3922, bit_or(swizzle_y(r3749), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r3934 = lshift(swizzle_y(r2D5A), body.constant(int(1)));
               ir_expression *const r3935 = lequal(body.constant(4292870144u), r3934);
               ir_expression *const r3936 = nequal(swizzle_x(r2D5A), body.constant(0u));
               ir_expression *const r3937 = bit_and(swizzle_y(r2D5A), body.constant(1048575u));
               ir_expression *const r3938 = nequal(r3937, body.constant(0u));
               ir_expression *const r3939 = logic_or(r3936, r3938);
               ir_expression *const r393A = logic_and(r3935, r3939);
               ir_if *f3933 = new(mem_ctx) ir_if(operand(r393A).val);
               exec_list *const f3933_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3933->then_instructions;

                  ir_variable *const r393B = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r393D = logic_and(r3924, r392C);
                  ir_if *f393C = new(mem_ctx) ir_if(operand(r393D).val);
                  exec_list *const f393C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f393C->then_instructions;

                     body.emit(assign(r393B, r3922, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f393C->else_instructions;

                     body.emit(assign(r393B, r3921, 0x03));


                  body.instructions = f393C_parent_instructions;
                  body.emit(f393C);

                  /* END IF */

                  body.emit(assign(r3923, r393B, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3933->else_instructions;

                  body.emit(assign(r3923, r3922, 0x03));


               body.instructions = f3933_parent_instructions;
               body.emit(f3933);

               /* END IF */

               body.emit(assign(r3901, r3923, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f391E->else_instructions;

               body.emit(assign(r3901, r2D5A, 0x03));


            body.instructions = f391E_parent_instructions;
            body.emit(f391E);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f391C->else_instructions;

            /* IF CONDITION */
            ir_expression *const r393F = equal(r390D, body.constant(int(0)));
            ir_if *f393E = new(mem_ctx) ir_if(operand(r393F).val);
            exec_list *const f393E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f393E->then_instructions;

               body.emit(assign(r3902, add(r3902, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f393E->else_instructions;

               body.emit(assign(r3905, bit_or(r3916, body.constant(1073741824u)), 0x01));


            body.instructions = f393E_parent_instructions;
            body.emit(f393E);

            /* END IF */

            ir_variable *const r3940 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r3940);
            ir_variable *const r3941 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r3941);
            ir_variable *const r3942 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r3943 = neg(r3902);
            body.emit(assign(r3942, bit_and(r3943, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3945 = equal(r3902, body.constant(int(0)));
            ir_if *f3944 = new(mem_ctx) ir_if(operand(r3945).val);
            exec_list *const f3944_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3944->then_instructions;

               body.emit(assign(r3940, r3915, 0x01));

               body.emit(assign(r3941, r3905, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3944->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3947 = less(r3902, body.constant(int(32)));
               ir_if *f3946 = new(mem_ctx) ir_if(operand(r3947).val);
               exec_list *const f3946_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3946->then_instructions;

                  ir_expression *const r3948 = lshift(r3905, r3942);
                  ir_expression *const r3949 = rshift(r3915, r3902);
                  ir_expression *const r394A = bit_or(r3948, r3949);
                  ir_expression *const r394B = lshift(r3915, r3942);
                  ir_expression *const r394C = nequal(r394B, body.constant(0u));
                  ir_expression *const r394D = expr(ir_unop_b2i, r394C);
                  ir_expression *const r394E = expr(ir_unop_i2u, r394D);
                  body.emit(assign(r3940, bit_or(r394A, r394E), 0x01));

                  body.emit(assign(r3941, rshift(r3905, r3902), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3946->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3950 = equal(r3902, body.constant(int(32)));
                  ir_if *f394F = new(mem_ctx) ir_if(operand(r3950).val);
                  exec_list *const f394F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f394F->then_instructions;

                     ir_expression *const r3951 = nequal(r3915, body.constant(0u));
                     ir_expression *const r3952 = expr(ir_unop_b2i, r3951);
                     ir_expression *const r3953 = expr(ir_unop_i2u, r3952);
                     body.emit(assign(r3940, bit_or(r3905, r3953), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f394F->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3955 = less(r3902, body.constant(int(64)));
                     ir_if *f3954 = new(mem_ctx) ir_if(operand(r3955).val);
                     exec_list *const f3954_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3954->then_instructions;

                        ir_expression *const r3956 = bit_and(r3902, body.constant(int(31)));
                        ir_expression *const r3957 = rshift(r3905, r3956);
                        ir_expression *const r3958 = lshift(r3905, r3942);
                        ir_expression *const r3959 = bit_or(r3958, r3915);
                        ir_expression *const r395A = nequal(r3959, body.constant(0u));
                        ir_expression *const r395B = expr(ir_unop_b2i, r395A);
                        ir_expression *const r395C = expr(ir_unop_i2u, r395B);
                        body.emit(assign(r3940, bit_or(r3957, r395C), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3954->else_instructions;

                        ir_expression *const r395D = bit_or(r3905, r3915);
                        ir_expression *const r395E = nequal(r395D, body.constant(0u));
                        ir_expression *const r395F = expr(ir_unop_b2i, r395E);
                        body.emit(assign(r3940, expr(ir_unop_i2u, r395F), 0x01));


                     body.instructions = f3954_parent_instructions;
                     body.emit(f3954);

                     /* END IF */


                  body.instructions = f394F_parent_instructions;
                  body.emit(f394F);

                  /* END IF */

                  body.emit(assign(r3941, body.constant(0u), 0x01));


               body.instructions = f3946_parent_instructions;
               body.emit(f3946);

               /* END IF */


            body.instructions = f3944_parent_instructions;
            body.emit(f3944);

            /* END IF */

            body.emit(assign(r3905, r3941, 0x01));

            body.emit(assign(r3906, r3940, 0x01));

            body.emit(assign(r3907, bit_or(r3911, body.constant(1073741824u)), 0x01));

            ir_variable *const r3960 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r3961 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r3961, sub(r3910, r3940), 0x01));

            ir_expression *const r3962 = sub(r3907, r3941);
            ir_expression *const r3963 = less(r3910, r3940);
            ir_expression *const r3964 = expr(ir_unop_b2i, r3963);
            ir_expression *const r3965 = expr(ir_unop_i2u, r3964);
            body.emit(assign(r3960, sub(r3962, r3965), 0x01));

            body.emit(assign(r3909, add(r390A, body.constant(int(-1))), 0x01));

            ir_variable *const r3966 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r3966, add(r3909, body.constant(int(-10))), 0x01));

            ir_variable *const r3967 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r3967, r3960, 0x01));

            ir_variable *const r3968 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r3968, r3961, 0x01));

            ir_variable *const r3969 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r3969);
            ir_variable *const r396A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r396A);
            /* IF CONDITION */
            ir_expression *const r396C = equal(r3960, body.constant(0u));
            ir_if *f396B = new(mem_ctx) ir_if(operand(r396C).val);
            exec_list *const f396B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f396B->then_instructions;

               body.emit(assign(r3967, r3961, 0x01));

               body.emit(assign(r3968, body.constant(0u), 0x01));

               body.emit(assign(r3966, add(r3966, body.constant(int(-32))), 0x01));


            body.instructions = f396B_parent_instructions;
            body.emit(f396B);

            /* END IF */

            ir_variable *const r396D = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r396D, r3967, 0x01));

            ir_variable *const r396E = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r396F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r396F);
            /* IF CONDITION */
            ir_expression *const r3971 = equal(r3967, body.constant(0u));
            ir_if *f3970 = new(mem_ctx) ir_if(operand(r3971).val);
            exec_list *const f3970_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3970->then_instructions;

               body.emit(assign(r396E, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3970->else_instructions;

               body.emit(assign(r396F, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r3973 = bit_and(r3967, body.constant(4294901760u));
               ir_expression *const r3974 = equal(r3973, body.constant(0u));
               ir_if *f3972 = new(mem_ctx) ir_if(operand(r3974).val);
               exec_list *const f3972_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3972->then_instructions;

                  body.emit(assign(r396F, body.constant(int(16)), 0x01));

                  body.emit(assign(r396D, lshift(r3967, body.constant(int(16))), 0x01));


               body.instructions = f3972_parent_instructions;
               body.emit(f3972);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3976 = bit_and(r396D, body.constant(4278190080u));
               ir_expression *const r3977 = equal(r3976, body.constant(0u));
               ir_if *f3975 = new(mem_ctx) ir_if(operand(r3977).val);
               exec_list *const f3975_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3975->then_instructions;

                  body.emit(assign(r396F, add(r396F, body.constant(int(8))), 0x01));

                  body.emit(assign(r396D, lshift(r396D, body.constant(int(8))), 0x01));


               body.instructions = f3975_parent_instructions;
               body.emit(f3975);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3979 = bit_and(r396D, body.constant(4026531840u));
               ir_expression *const r397A = equal(r3979, body.constant(0u));
               ir_if *f3978 = new(mem_ctx) ir_if(operand(r397A).val);
               exec_list *const f3978_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3978->then_instructions;

                  body.emit(assign(r396F, add(r396F, body.constant(int(4))), 0x01));

                  body.emit(assign(r396D, lshift(r396D, body.constant(int(4))), 0x01));


               body.instructions = f3978_parent_instructions;
               body.emit(f3978);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r397C = bit_and(r396D, body.constant(3221225472u));
               ir_expression *const r397D = equal(r397C, body.constant(0u));
               ir_if *f397B = new(mem_ctx) ir_if(operand(r397D).val);
               exec_list *const f397B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f397B->then_instructions;

                  body.emit(assign(r396F, add(r396F, body.constant(int(2))), 0x01));

                  body.emit(assign(r396D, lshift(r396D, body.constant(int(2))), 0x01));


               body.instructions = f397B_parent_instructions;
               body.emit(f397B);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r397F = bit_and(r396D, body.constant(2147483648u));
               ir_expression *const r3980 = equal(r397F, body.constant(0u));
               ir_if *f397E = new(mem_ctx) ir_if(operand(r3980).val);
               exec_list *const f397E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f397E->then_instructions;

                  body.emit(assign(r396F, add(r396F, body.constant(int(1))), 0x01));


               body.instructions = f397E_parent_instructions;
               body.emit(f397E);

               /* END IF */

               body.emit(assign(r396E, r396F, 0x01));


            body.instructions = f3970_parent_instructions;
            body.emit(f3970);

            /* END IF */

            body.emit(assign(r396A, add(r396E, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3982 = lequal(body.constant(int(0)), r396A);
            ir_if *f3981 = new(mem_ctx) ir_if(operand(r3982).val);
            exec_list *const f3981_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3981->then_instructions;

               body.emit(assign(r3969, body.constant(0u), 0x01));

               ir_variable *const r3983 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3983, lshift(r3968, r396A), 0x01));

               ir_variable *const r3984 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r3986 = equal(r396A, body.constant(int(0)));
               ir_if *f3985 = new(mem_ctx) ir_if(operand(r3986).val);
               exec_list *const f3985_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3985->then_instructions;

                  body.emit(assign(r3984, r3967, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3985->else_instructions;

                  ir_expression *const r3987 = lshift(r3967, r396A);
                  ir_expression *const r3988 = neg(r396A);
                  ir_expression *const r3989 = bit_and(r3988, body.constant(int(31)));
                  ir_expression *const r398A = rshift(r3968, r3989);
                  body.emit(assign(r3984, bit_or(r3987, r398A), 0x01));


               body.instructions = f3985_parent_instructions;
               body.emit(f3985);

               /* END IF */

               body.emit(assign(r3967, r3984, 0x01));

               body.emit(assign(r3968, r3983, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3981->else_instructions;

               ir_variable *const r398B = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r398B, body.constant(0u), 0x01));

               ir_variable *const r398C = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r398C, neg(r396A), 0x01));

               ir_variable *const r398D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r398D);
               ir_variable *const r398E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r398E);
               ir_variable *const r398F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r398F);
               ir_variable *const r3990 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r3991 = neg(r398C);
               body.emit(assign(r3990, bit_and(r3991, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3993 = equal(r398C, body.constant(int(0)));
               ir_if *f3992 = new(mem_ctx) ir_if(operand(r3993).val);
               exec_list *const f3992_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3992->then_instructions;

                  body.emit(assign(r398D, r398B, 0x01));

                  body.emit(assign(r398E, r3968, 0x01));

                  body.emit(assign(r398F, r3967, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3992->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3995 = less(r398C, body.constant(int(32)));
                  ir_if *f3994 = new(mem_ctx) ir_if(operand(r3995).val);
                  exec_list *const f3994_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3994->then_instructions;

                     body.emit(assign(r398D, lshift(r3968, r3990), 0x01));

                     ir_expression *const r3996 = lshift(r3967, r3990);
                     ir_expression *const r3997 = rshift(r3968, r398C);
                     body.emit(assign(r398E, bit_or(r3996, r3997), 0x01));

                     body.emit(assign(r398F, rshift(r3967, r398C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3994->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3999 = equal(r398C, body.constant(int(32)));
                     ir_if *f3998 = new(mem_ctx) ir_if(operand(r3999).val);
                     exec_list *const f3998_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3998->then_instructions;

                        body.emit(assign(r398D, r3968, 0x01));

                        body.emit(assign(r398E, r3967, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3998->else_instructions;

                        body.emit(assign(r398B, bit_or(body.constant(0u), r3968), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r399B = less(r398C, body.constant(int(64)));
                        ir_if *f399A = new(mem_ctx) ir_if(operand(r399B).val);
                        exec_list *const f399A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f399A->then_instructions;

                           body.emit(assign(r398D, lshift(r3967, r3990), 0x01));

                           ir_expression *const r399C = bit_and(r398C, body.constant(int(31)));
                           body.emit(assign(r398E, rshift(r3967, r399C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f399A->else_instructions;

                           ir_variable *const r399D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r399F = equal(r398C, body.constant(int(64)));
                           ir_if *f399E = new(mem_ctx) ir_if(operand(r399F).val);
                           exec_list *const f399E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f399E->then_instructions;

                              body.emit(assign(r399D, r3967, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f399E->else_instructions;

                              ir_expression *const r39A0 = nequal(r3967, body.constant(0u));
                              ir_expression *const r39A1 = expr(ir_unop_b2i, r39A0);
                              body.emit(assign(r399D, expr(ir_unop_i2u, r39A1), 0x01));


                           body.instructions = f399E_parent_instructions;
                           body.emit(f399E);

                           /* END IF */

                           body.emit(assign(r398D, r399D, 0x01));

                           body.emit(assign(r398E, body.constant(0u), 0x01));


                        body.instructions = f399A_parent_instructions;
                        body.emit(f399A);

                        /* END IF */


                     body.instructions = f3998_parent_instructions;
                     body.emit(f3998);

                     /* END IF */

                     body.emit(assign(r398F, body.constant(0u), 0x01));


                  body.instructions = f3994_parent_instructions;
                  body.emit(f3994);

                  /* END IF */

                  ir_expression *const r39A2 = nequal(r398B, body.constant(0u));
                  ir_expression *const r39A3 = expr(ir_unop_b2i, r39A2);
                  ir_expression *const r39A4 = expr(ir_unop_i2u, r39A3);
                  body.emit(assign(r398D, bit_or(r398D, r39A4), 0x01));


               body.instructions = f3992_parent_instructions;
               body.emit(f3992);

               /* END IF */

               body.emit(assign(r3967, r398F, 0x01));

               body.emit(assign(r3968, r398E, 0x01));

               body.emit(assign(r3969, r398D, 0x01));


            body.instructions = f3981_parent_instructions;
            body.emit(f3981);

            /* END IF */

            body.emit(assign(r3966, sub(r3966, r396A), 0x01));

            ir_variable *const r39A5 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r39A5, r3966, 0x01));

            ir_variable *const r39A6 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r39A6, r3967, 0x01));

            ir_variable *const r39A7 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r39A7, r3968, 0x01));

            ir_variable *const r39A8 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r39A8, r3969, 0x01));

            ir_variable *const r39A9 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r39A9, body.constant(true), 0x01));

            ir_variable *const r39AA = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r39AB = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r39AB);
            ir_expression *const r39AC = expr(ir_unop_u2i, r3969);
            body.emit(assign(r39AB, less(r39AC, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r39AE = lequal(body.constant(int(2045)), r3966);
            ir_if *f39AD = new(mem_ctx) ir_if(operand(r39AE).val);
            exec_list *const f39AD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f39AD->then_instructions;

               ir_variable *const r39AF = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r39B1 = less(body.constant(int(2045)), r3966);
               ir_if *f39B0 = new(mem_ctx) ir_if(operand(r39B1).val);
               exec_list *const f39B0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f39B0->then_instructions;

                  body.emit(assign(r39AF, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f39B0->else_instructions;

                  ir_variable *const r39B2 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r39B4 = equal(r3966, body.constant(int(2045)));
                  ir_if *f39B3 = new(mem_ctx) ir_if(operand(r39B4).val);
                  exec_list *const f39B3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f39B3->then_instructions;

                     ir_expression *const r39B5 = equal(body.constant(2097151u), r3967);
                     ir_expression *const r39B6 = equal(body.constant(4294967295u), r3968);
                     body.emit(assign(r39B2, logic_and(r39B5, r39B6), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f39B3->else_instructions;

                     body.emit(assign(r39B2, body.constant(false), 0x01));


                  body.instructions = f39B3_parent_instructions;
                  body.emit(f39B3);

                  /* END IF */

                  body.emit(assign(r39AF, logic_and(r39B2, r39AB), 0x01));


               body.instructions = f39B0_parent_instructions;
               body.emit(f39B0);

               /* END IF */

               /* IF CONDITION */
               ir_if *f39B7 = new(mem_ctx) ir_if(operand(r39AF).val);
               exec_list *const f39B7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f39B7->then_instructions;

                  ir_variable *const r39B8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r39B8);
                  ir_expression *const r39B9 = lshift(r3753, body.constant(int(31)));
                  body.emit(assign(r39B8, add(r39B9, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r39B8, body.constant(0u), 0x01));

                  body.emit(assign(r39AA, r39B8, 0x03));

                  body.emit(assign(r39A9, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f39B7->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r39BB = less(r3966, body.constant(int(0)));
                  ir_if *f39BA = new(mem_ctx) ir_if(operand(r39BB).val);
                  exec_list *const f39BA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f39BA->then_instructions;

                     ir_variable *const r39BC = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r39BC, r3969, 0x01));

                     ir_variable *const r39BD = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r39BD, neg(r3966), 0x01));

                     ir_variable *const r39BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r39BE);
                     ir_variable *const r39BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r39BF);
                     ir_variable *const r39C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r39C0);
                     ir_variable *const r39C1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r39C2 = neg(r39BD);
                     body.emit(assign(r39C1, bit_and(r39C2, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r39C4 = equal(r39BD, body.constant(int(0)));
                     ir_if *f39C3 = new(mem_ctx) ir_if(operand(r39C4).val);
                     exec_list *const f39C3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f39C3->then_instructions;

                        body.emit(assign(r39BE, r3969, 0x01));

                        body.emit(assign(r39BF, r3968, 0x01));

                        body.emit(assign(r39C0, r3967, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f39C3->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r39C6 = less(r39BD, body.constant(int(32)));
                        ir_if *f39C5 = new(mem_ctx) ir_if(operand(r39C6).val);
                        exec_list *const f39C5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f39C5->then_instructions;

                           body.emit(assign(r39BE, lshift(r3968, r39C1), 0x01));

                           ir_expression *const r39C7 = lshift(r3967, r39C1);
                           ir_expression *const r39C8 = rshift(r3968, r39BD);
                           body.emit(assign(r39BF, bit_or(r39C7, r39C8), 0x01));

                           body.emit(assign(r39C0, rshift(r3967, r39BD), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f39C5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r39CA = equal(r39BD, body.constant(int(32)));
                           ir_if *f39C9 = new(mem_ctx) ir_if(operand(r39CA).val);
                           exec_list *const f39C9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f39C9->then_instructions;

                              body.emit(assign(r39BE, r3968, 0x01));

                              body.emit(assign(r39BF, r3967, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f39C9->else_instructions;

                              body.emit(assign(r39BC, bit_or(r3969, r3968), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r39CC = less(r39BD, body.constant(int(64)));
                              ir_if *f39CB = new(mem_ctx) ir_if(operand(r39CC).val);
                              exec_list *const f39CB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f39CB->then_instructions;

                                 body.emit(assign(r39BE, lshift(r3967, r39C1), 0x01));

                                 ir_expression *const r39CD = bit_and(r39BD, body.constant(int(31)));
                                 body.emit(assign(r39BF, rshift(r3967, r39CD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f39CB->else_instructions;

                                 ir_variable *const r39CE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r39D0 = equal(r39BD, body.constant(int(64)));
                                 ir_if *f39CF = new(mem_ctx) ir_if(operand(r39D0).val);
                                 exec_list *const f39CF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f39CF->then_instructions;

                                    body.emit(assign(r39CE, r3967, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f39CF->else_instructions;

                                    ir_expression *const r39D1 = nequal(r3967, body.constant(0u));
                                    ir_expression *const r39D2 = expr(ir_unop_b2i, r39D1);
                                    body.emit(assign(r39CE, expr(ir_unop_i2u, r39D2), 0x01));


                                 body.instructions = f39CF_parent_instructions;
                                 body.emit(f39CF);

                                 /* END IF */

                                 body.emit(assign(r39BE, r39CE, 0x01));

                                 body.emit(assign(r39BF, body.constant(0u), 0x01));


                              body.instructions = f39CB_parent_instructions;
                              body.emit(f39CB);

                              /* END IF */


                           body.instructions = f39C9_parent_instructions;
                           body.emit(f39C9);

                           /* END IF */

                           body.emit(assign(r39C0, body.constant(0u), 0x01));


                        body.instructions = f39C5_parent_instructions;
                        body.emit(f39C5);

                        /* END IF */

                        ir_expression *const r39D3 = nequal(r39BC, body.constant(0u));
                        ir_expression *const r39D4 = expr(ir_unop_b2i, r39D3);
                        ir_expression *const r39D5 = expr(ir_unop_i2u, r39D4);
                        body.emit(assign(r39BE, bit_or(r39BE, r39D5), 0x01));


                     body.instructions = f39C3_parent_instructions;
                     body.emit(f39C3);

                     /* END IF */

                     body.emit(assign(r39A6, r39C0, 0x01));

                     body.emit(assign(r39A7, r39BF, 0x01));

                     body.emit(assign(r39A8, r39BE, 0x01));

                     body.emit(assign(r39A5, body.constant(int(0)), 0x01));

                     body.emit(assign(r39AB, less(r39BE, body.constant(0u)), 0x01));


                  body.instructions = f39BA_parent_instructions;
                  body.emit(f39BA);

                  /* END IF */


               body.instructions = f39B7_parent_instructions;
               body.emit(f39B7);

               /* END IF */


            body.instructions = f39AD_parent_instructions;
            body.emit(f39AD);

            /* END IF */

            /* IF CONDITION */
            ir_if *f39D6 = new(mem_ctx) ir_if(operand(r39A9).val);
            exec_list *const f39D6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f39D6->then_instructions;

               /* IF CONDITION */
               ir_if *f39D7 = new(mem_ctx) ir_if(operand(r39AB).val);
               exec_list *const f39D7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f39D7->then_instructions;

                  ir_variable *const r39D8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r39D8, add(r39A7, body.constant(1u)), 0x01));

                  ir_expression *const r39D9 = less(r39D8, r39A7);
                  ir_expression *const r39DA = expr(ir_unop_b2i, r39D9);
                  ir_expression *const r39DB = expr(ir_unop_i2u, r39DA);
                  body.emit(assign(r39A6, add(r39A6, r39DB), 0x01));

                  ir_expression *const r39DC = equal(r39A8, body.constant(0u));
                  ir_expression *const r39DD = expr(ir_unop_b2i, r39DC);
                  ir_expression *const r39DE = expr(ir_unop_i2u, r39DD);
                  ir_expression *const r39DF = add(r39A8, r39DE);
                  ir_expression *const r39E0 = bit_and(r39DF, body.constant(1u));
                  ir_expression *const r39E1 = expr(ir_unop_bit_not, r39E0);
                  body.emit(assign(r39A7, bit_and(r39D8, r39E1), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f39D7->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r39E3 = bit_or(r39A6, r39A7);
                  ir_expression *const r39E4 = equal(r39E3, body.constant(0u));
                  ir_if *f39E2 = new(mem_ctx) ir_if(operand(r39E4).val);
                  exec_list *const f39E2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f39E2->then_instructions;

                     body.emit(assign(r39A5, body.constant(int(0)), 0x01));


                  body.instructions = f39E2_parent_instructions;
                  body.emit(f39E2);

                  /* END IF */


               body.instructions = f39D7_parent_instructions;
               body.emit(f39D7);

               /* END IF */

               ir_variable *const r39E5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r39E5);
               ir_expression *const r39E6 = lshift(r3753, body.constant(int(31)));
               ir_expression *const r39E7 = expr(ir_unop_i2u, r39A5);
               ir_expression *const r39E8 = lshift(r39E7, body.constant(int(20)));
               ir_expression *const r39E9 = add(r39E6, r39E8);
               body.emit(assign(r39E5, add(r39E9, r39A6), 0x02));

               body.emit(assign(r39E5, r39A7, 0x01));

               body.emit(assign(r39AA, r39E5, 0x03));

               body.emit(assign(r39A9, body.constant(false), 0x01));


            body.instructions = f39D6_parent_instructions;
            body.emit(f39D6);

            /* END IF */

            body.emit(assign(r3901, r39AA, 0x03));


         body.instructions = f391C_parent_instructions;
         body.emit(f391C);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f391A->else_instructions;

         /* IF CONDITION */
         ir_expression *const r39EB = less(r3902, body.constant(int(0)));
         ir_if *f39EA = new(mem_ctx) ir_if(operand(r39EB).val);
         exec_list *const f39EA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f39EA->then_instructions;

            /* IF CONDITION */
            ir_expression *const r39ED = equal(r390D, body.constant(int(2047)));
            ir_if *f39EC = new(mem_ctx) ir_if(operand(r39ED).val);
            exec_list *const f39EC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f39EC->then_instructions;

               /* IF CONDITION */
               ir_expression *const r39EF = bit_or(r3905, r3906);
               ir_expression *const r39F0 = nequal(r39EF, body.constant(0u));
               ir_if *f39EE = new(mem_ctx) ir_if(operand(r39F0).val);
               exec_list *const f39EE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f39EE->then_instructions;

                  ir_variable *const r39F1 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r39F1, swizzle_x(r2D5A), 0x01));

                  ir_variable *const r39F2 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r39F2, swizzle_x(r3749), 0x01));

                  ir_variable *const r39F3 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r39F4 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r39F5 = rshift(swizzle_y(r2D5A), body.constant(int(19)));
                  ir_expression *const r39F6 = bit_and(r39F5, body.constant(4095u));
                  ir_expression *const r39F7 = equal(r39F6, body.constant(4094u));
                  ir_expression *const r39F8 = nequal(swizzle_x(r2D5A), body.constant(0u));
                  ir_expression *const r39F9 = bit_and(swizzle_y(r2D5A), body.constant(524287u));
                  ir_expression *const r39FA = nequal(r39F9, body.constant(0u));
                  ir_expression *const r39FB = logic_or(r39F8, r39FA);
                  body.emit(assign(r39F4, logic_and(r39F7, r39FB), 0x01));

                  ir_variable *const r39FC = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r39FD = lshift(swizzle_y(r3749), body.constant(int(1)));
                  ir_expression *const r39FE = lequal(body.constant(4292870144u), r39FD);
                  ir_expression *const r39FF = nequal(swizzle_x(r3749), body.constant(0u));
                  ir_expression *const r3A00 = bit_and(swizzle_y(r3749), body.constant(1048575u));
                  ir_expression *const r3A01 = nequal(r3A00, body.constant(0u));
                  ir_expression *const r3A02 = logic_or(r39FF, r3A01);
                  body.emit(assign(r39FC, logic_and(r39FE, r3A02), 0x01));

                  body.emit(assign(r39F1, bit_or(swizzle_y(r2D5A), body.constant(524288u)), 0x02));

                  body.emit(assign(r39F2, bit_or(swizzle_y(r3749), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r3A04 = lshift(swizzle_y(r2D5A), body.constant(int(1)));
                  ir_expression *const r3A05 = lequal(body.constant(4292870144u), r3A04);
                  ir_expression *const r3A06 = nequal(swizzle_x(r2D5A), body.constant(0u));
                  ir_expression *const r3A07 = bit_and(swizzle_y(r2D5A), body.constant(1048575u));
                  ir_expression *const r3A08 = nequal(r3A07, body.constant(0u));
                  ir_expression *const r3A09 = logic_or(r3A06, r3A08);
                  ir_expression *const r3A0A = logic_and(r3A05, r3A09);
                  ir_if *f3A03 = new(mem_ctx) ir_if(operand(r3A0A).val);
                  exec_list *const f3A03_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A03->then_instructions;

                     ir_variable *const r3A0B = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3A0D = logic_and(r39F4, r39FC);
                     ir_if *f3A0C = new(mem_ctx) ir_if(operand(r3A0D).val);
                     exec_list *const f3A0C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A0C->then_instructions;

                        body.emit(assign(r3A0B, r39F2, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3A0C->else_instructions;

                        body.emit(assign(r3A0B, r39F1, 0x03));


                     body.instructions = f3A0C_parent_instructions;
                     body.emit(f3A0C);

                     /* END IF */

                     body.emit(assign(r39F3, r3A0B, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A03->else_instructions;

                     body.emit(assign(r39F3, r39F2, 0x03));


                  body.instructions = f3A03_parent_instructions;
                  body.emit(f3A03);

                  /* END IF */

                  body.emit(assign(r3901, r39F3, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f39EE->else_instructions;

                  ir_variable *const r3A0E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3A0E);
                  ir_expression *const r3A0F = bit_xor(r3753, body.constant(1u));
                  ir_expression *const r3A10 = lshift(r3A0F, body.constant(int(31)));
                  body.emit(assign(r3A0E, add(r3A10, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r3A0E, body.constant(0u), 0x01));

                  body.emit(assign(r3901, r3A0E, 0x03));


               body.instructions = f39EE_parent_instructions;
               body.emit(f39EE);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f39EC->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3A12 = equal(r390A, body.constant(int(0)));
               ir_if *f3A11 = new(mem_ctx) ir_if(operand(r3A12).val);
               exec_list *const f3A11_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A11->then_instructions;

                  body.emit(assign(r3902, add(r3902, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3A11->else_instructions;

                  body.emit(assign(r3907, bit_or(r3907, body.constant(1073741824u)), 0x01));


               body.instructions = f3A11_parent_instructions;
               body.emit(f3A11);

               /* END IF */

               ir_variable *const r3A13 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r3A13, neg(r3902), 0x01));

               ir_variable *const r3A14 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3A14);
               ir_variable *const r3A15 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3A15);
               ir_variable *const r3A16 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r3A17 = neg(r3A13);
               body.emit(assign(r3A16, bit_and(r3A17, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3A19 = equal(r3A13, body.constant(int(0)));
               ir_if *f3A18 = new(mem_ctx) ir_if(operand(r3A19).val);
               exec_list *const f3A18_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A18->then_instructions;

                  body.emit(assign(r3A14, r3910, 0x01));

                  body.emit(assign(r3A15, r3907, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3A18->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3A1B = less(r3A13, body.constant(int(32)));
                  ir_if *f3A1A = new(mem_ctx) ir_if(operand(r3A1B).val);
                  exec_list *const f3A1A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A1A->then_instructions;

                     ir_expression *const r3A1C = lshift(r3907, r3A16);
                     ir_expression *const r3A1D = rshift(r3910, r3A13);
                     ir_expression *const r3A1E = bit_or(r3A1C, r3A1D);
                     ir_expression *const r3A1F = lshift(r3910, r3A16);
                     ir_expression *const r3A20 = nequal(r3A1F, body.constant(0u));
                     ir_expression *const r3A21 = expr(ir_unop_b2i, r3A20);
                     ir_expression *const r3A22 = expr(ir_unop_i2u, r3A21);
                     body.emit(assign(r3A14, bit_or(r3A1E, r3A22), 0x01));

                     body.emit(assign(r3A15, rshift(r3907, r3A13), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A1A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3A24 = equal(r3A13, body.constant(int(32)));
                     ir_if *f3A23 = new(mem_ctx) ir_if(operand(r3A24).val);
                     exec_list *const f3A23_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A23->then_instructions;

                        ir_expression *const r3A25 = nequal(r3910, body.constant(0u));
                        ir_expression *const r3A26 = expr(ir_unop_b2i, r3A25);
                        ir_expression *const r3A27 = expr(ir_unop_i2u, r3A26);
                        body.emit(assign(r3A14, bit_or(r3907, r3A27), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3A23->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3A29 = less(r3A13, body.constant(int(64)));
                        ir_if *f3A28 = new(mem_ctx) ir_if(operand(r3A29).val);
                        exec_list *const f3A28_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3A28->then_instructions;

                           ir_expression *const r3A2A = bit_and(r3A13, body.constant(int(31)));
                           ir_expression *const r3A2B = rshift(r3907, r3A2A);
                           ir_expression *const r3A2C = lshift(r3907, r3A16);
                           ir_expression *const r3A2D = bit_or(r3A2C, r3910);
                           ir_expression *const r3A2E = nequal(r3A2D, body.constant(0u));
                           ir_expression *const r3A2F = expr(ir_unop_b2i, r3A2E);
                           ir_expression *const r3A30 = expr(ir_unop_i2u, r3A2F);
                           body.emit(assign(r3A14, bit_or(r3A2B, r3A30), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3A28->else_instructions;

                           ir_expression *const r3A31 = bit_or(r3907, r3910);
                           ir_expression *const r3A32 = nequal(r3A31, body.constant(0u));
                           ir_expression *const r3A33 = expr(ir_unop_b2i, r3A32);
                           body.emit(assign(r3A14, expr(ir_unop_i2u, r3A33), 0x01));


                        body.instructions = f3A28_parent_instructions;
                        body.emit(f3A28);

                        /* END IF */


                     body.instructions = f3A23_parent_instructions;
                     body.emit(f3A23);

                     /* END IF */

                     body.emit(assign(r3A15, body.constant(0u), 0x01));


                  body.instructions = f3A1A_parent_instructions;
                  body.emit(f3A1A);

                  /* END IF */


               body.instructions = f3A18_parent_instructions;
               body.emit(f3A18);

               /* END IF */

               body.emit(assign(r3907, r3A15, 0x01));

               body.emit(assign(r3908, r3A14, 0x01));

               body.emit(assign(r3905, bit_or(r3905, body.constant(1073741824u)), 0x01));

               ir_variable *const r3A34 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r3A35 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3A35, sub(r3906, r3A14), 0x01));

               ir_expression *const r3A36 = sub(r3905, r3A15);
               ir_expression *const r3A37 = less(r3906, r3A14);
               ir_expression *const r3A38 = expr(ir_unop_b2i, r3A37);
               ir_expression *const r3A39 = expr(ir_unop_i2u, r3A38);
               body.emit(assign(r3A34, sub(r3A36, r3A39), 0x01));

               body.emit(assign(r3900, bit_xor(r3753, body.constant(1u)), 0x01));

               body.emit(assign(r3909, add(r390D, body.constant(int(-1))), 0x01));

               ir_variable *const r3A3A = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3A3A, add(r3909, body.constant(int(-10))), 0x01));

               ir_variable *const r3A3B = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3A3B, r3A34, 0x01));

               ir_variable *const r3A3C = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3A3C, r3A35, 0x01));

               ir_variable *const r3A3D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r3A3D);
               ir_variable *const r3A3E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3A3E);
               /* IF CONDITION */
               ir_expression *const r3A40 = equal(r3A34, body.constant(0u));
               ir_if *f3A3F = new(mem_ctx) ir_if(operand(r3A40).val);
               exec_list *const f3A3F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A3F->then_instructions;

                  body.emit(assign(r3A3B, r3A35, 0x01));

                  body.emit(assign(r3A3C, body.constant(0u), 0x01));

                  body.emit(assign(r3A3A, add(r3A3A, body.constant(int(-32))), 0x01));


               body.instructions = f3A3F_parent_instructions;
               body.emit(f3A3F);

               /* END IF */

               ir_variable *const r3A41 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r3A41, r3A3B, 0x01));

               ir_variable *const r3A42 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r3A43 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3A43);
               /* IF CONDITION */
               ir_expression *const r3A45 = equal(r3A3B, body.constant(0u));
               ir_if *f3A44 = new(mem_ctx) ir_if(operand(r3A45).val);
               exec_list *const f3A44_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A44->then_instructions;

                  body.emit(assign(r3A42, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3A44->else_instructions;

                  body.emit(assign(r3A43, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3A47 = bit_and(r3A3B, body.constant(4294901760u));
                  ir_expression *const r3A48 = equal(r3A47, body.constant(0u));
                  ir_if *f3A46 = new(mem_ctx) ir_if(operand(r3A48).val);
                  exec_list *const f3A46_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A46->then_instructions;

                     body.emit(assign(r3A43, body.constant(int(16)), 0x01));

                     body.emit(assign(r3A41, lshift(r3A3B, body.constant(int(16))), 0x01));


                  body.instructions = f3A46_parent_instructions;
                  body.emit(f3A46);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3A4A = bit_and(r3A41, body.constant(4278190080u));
                  ir_expression *const r3A4B = equal(r3A4A, body.constant(0u));
                  ir_if *f3A49 = new(mem_ctx) ir_if(operand(r3A4B).val);
                  exec_list *const f3A49_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A49->then_instructions;

                     body.emit(assign(r3A43, add(r3A43, body.constant(int(8))), 0x01));

                     body.emit(assign(r3A41, lshift(r3A41, body.constant(int(8))), 0x01));


                  body.instructions = f3A49_parent_instructions;
                  body.emit(f3A49);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3A4D = bit_and(r3A41, body.constant(4026531840u));
                  ir_expression *const r3A4E = equal(r3A4D, body.constant(0u));
                  ir_if *f3A4C = new(mem_ctx) ir_if(operand(r3A4E).val);
                  exec_list *const f3A4C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A4C->then_instructions;

                     body.emit(assign(r3A43, add(r3A43, body.constant(int(4))), 0x01));

                     body.emit(assign(r3A41, lshift(r3A41, body.constant(int(4))), 0x01));


                  body.instructions = f3A4C_parent_instructions;
                  body.emit(f3A4C);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3A50 = bit_and(r3A41, body.constant(3221225472u));
                  ir_expression *const r3A51 = equal(r3A50, body.constant(0u));
                  ir_if *f3A4F = new(mem_ctx) ir_if(operand(r3A51).val);
                  exec_list *const f3A4F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A4F->then_instructions;

                     body.emit(assign(r3A43, add(r3A43, body.constant(int(2))), 0x01));

                     body.emit(assign(r3A41, lshift(r3A41, body.constant(int(2))), 0x01));


                  body.instructions = f3A4F_parent_instructions;
                  body.emit(f3A4F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3A53 = bit_and(r3A41, body.constant(2147483648u));
                  ir_expression *const r3A54 = equal(r3A53, body.constant(0u));
                  ir_if *f3A52 = new(mem_ctx) ir_if(operand(r3A54).val);
                  exec_list *const f3A52_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A52->then_instructions;

                     body.emit(assign(r3A43, add(r3A43, body.constant(int(1))), 0x01));


                  body.instructions = f3A52_parent_instructions;
                  body.emit(f3A52);

                  /* END IF */

                  body.emit(assign(r3A42, r3A43, 0x01));


               body.instructions = f3A44_parent_instructions;
               body.emit(f3A44);

               /* END IF */

               body.emit(assign(r3A3E, add(r3A42, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3A56 = lequal(body.constant(int(0)), r3A3E);
               ir_if *f3A55 = new(mem_ctx) ir_if(operand(r3A56).val);
               exec_list *const f3A55_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A55->then_instructions;

                  body.emit(assign(r3A3D, body.constant(0u), 0x01));

                  ir_variable *const r3A57 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3A57, lshift(r3A3C, r3A3E), 0x01));

                  ir_variable *const r3A58 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3A5A = equal(r3A3E, body.constant(int(0)));
                  ir_if *f3A59 = new(mem_ctx) ir_if(operand(r3A5A).val);
                  exec_list *const f3A59_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A59->then_instructions;

                     body.emit(assign(r3A58, r3A3B, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A59->else_instructions;

                     ir_expression *const r3A5B = lshift(r3A3B, r3A3E);
                     ir_expression *const r3A5C = neg(r3A3E);
                     ir_expression *const r3A5D = bit_and(r3A5C, body.constant(int(31)));
                     ir_expression *const r3A5E = rshift(r3A3C, r3A5D);
                     body.emit(assign(r3A58, bit_or(r3A5B, r3A5E), 0x01));


                  body.instructions = f3A59_parent_instructions;
                  body.emit(f3A59);

                  /* END IF */

                  body.emit(assign(r3A3B, r3A58, 0x01));

                  body.emit(assign(r3A3C, r3A57, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3A55->else_instructions;

                  ir_variable *const r3A5F = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r3A5F, body.constant(0u), 0x01));

                  ir_variable *const r3A60 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r3A60, neg(r3A3E), 0x01));

                  ir_variable *const r3A61 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r3A61);
                  ir_variable *const r3A62 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3A62);
                  ir_variable *const r3A63 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r3A63);
                  ir_variable *const r3A64 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r3A65 = neg(r3A60);
                  body.emit(assign(r3A64, bit_and(r3A65, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3A67 = equal(r3A60, body.constant(int(0)));
                  ir_if *f3A66 = new(mem_ctx) ir_if(operand(r3A67).val);
                  exec_list *const f3A66_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A66->then_instructions;

                     body.emit(assign(r3A61, r3A5F, 0x01));

                     body.emit(assign(r3A62, r3A3C, 0x01));

                     body.emit(assign(r3A63, r3A3B, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A66->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3A69 = less(r3A60, body.constant(int(32)));
                     ir_if *f3A68 = new(mem_ctx) ir_if(operand(r3A69).val);
                     exec_list *const f3A68_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A68->then_instructions;

                        body.emit(assign(r3A61, lshift(r3A3C, r3A64), 0x01));

                        ir_expression *const r3A6A = lshift(r3A3B, r3A64);
                        ir_expression *const r3A6B = rshift(r3A3C, r3A60);
                        body.emit(assign(r3A62, bit_or(r3A6A, r3A6B), 0x01));

                        body.emit(assign(r3A63, rshift(r3A3B, r3A60), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3A68->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3A6D = equal(r3A60, body.constant(int(32)));
                        ir_if *f3A6C = new(mem_ctx) ir_if(operand(r3A6D).val);
                        exec_list *const f3A6C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3A6C->then_instructions;

                           body.emit(assign(r3A61, r3A3C, 0x01));

                           body.emit(assign(r3A62, r3A3B, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3A6C->else_instructions;

                           body.emit(assign(r3A5F, bit_or(body.constant(0u), r3A3C), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3A6F = less(r3A60, body.constant(int(64)));
                           ir_if *f3A6E = new(mem_ctx) ir_if(operand(r3A6F).val);
                           exec_list *const f3A6E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3A6E->then_instructions;

                              body.emit(assign(r3A61, lshift(r3A3B, r3A64), 0x01));

                              ir_expression *const r3A70 = bit_and(r3A60, body.constant(int(31)));
                              body.emit(assign(r3A62, rshift(r3A3B, r3A70), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3A6E->else_instructions;

                              ir_variable *const r3A71 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3A73 = equal(r3A60, body.constant(int(64)));
                              ir_if *f3A72 = new(mem_ctx) ir_if(operand(r3A73).val);
                              exec_list *const f3A72_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3A72->then_instructions;

                                 body.emit(assign(r3A71, r3A3B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3A72->else_instructions;

                                 ir_expression *const r3A74 = nequal(r3A3B, body.constant(0u));
                                 ir_expression *const r3A75 = expr(ir_unop_b2i, r3A74);
                                 body.emit(assign(r3A71, expr(ir_unop_i2u, r3A75), 0x01));


                              body.instructions = f3A72_parent_instructions;
                              body.emit(f3A72);

                              /* END IF */

                              body.emit(assign(r3A61, r3A71, 0x01));

                              body.emit(assign(r3A62, body.constant(0u), 0x01));


                           body.instructions = f3A6E_parent_instructions;
                           body.emit(f3A6E);

                           /* END IF */


                        body.instructions = f3A6C_parent_instructions;
                        body.emit(f3A6C);

                        /* END IF */

                        body.emit(assign(r3A63, body.constant(0u), 0x01));


                     body.instructions = f3A68_parent_instructions;
                     body.emit(f3A68);

                     /* END IF */

                     ir_expression *const r3A76 = nequal(r3A5F, body.constant(0u));
                     ir_expression *const r3A77 = expr(ir_unop_b2i, r3A76);
                     ir_expression *const r3A78 = expr(ir_unop_i2u, r3A77);
                     body.emit(assign(r3A61, bit_or(r3A61, r3A78), 0x01));


                  body.instructions = f3A66_parent_instructions;
                  body.emit(f3A66);

                  /* END IF */

                  body.emit(assign(r3A3B, r3A63, 0x01));

                  body.emit(assign(r3A3C, r3A62, 0x01));

                  body.emit(assign(r3A3D, r3A61, 0x01));


               body.instructions = f3A55_parent_instructions;
               body.emit(f3A55);

               /* END IF */

               body.emit(assign(r3A3A, sub(r3A3A, r3A3E), 0x01));

               ir_variable *const r3A79 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3A79, r3A3A, 0x01));

               ir_variable *const r3A7A = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3A7A, r3A3B, 0x01));

               ir_variable *const r3A7B = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3A7B, r3A3C, 0x01));

               ir_variable *const r3A7C = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3A7C, r3A3D, 0x01));

               ir_variable *const r3A7D = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r3A7D, body.constant(true), 0x01));

               ir_variable *const r3A7E = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3A7F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3A7F);
               ir_expression *const r3A80 = expr(ir_unop_u2i, r3A3D);
               body.emit(assign(r3A7F, less(r3A80, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3A82 = lequal(body.constant(int(2045)), r3A3A);
               ir_if *f3A81 = new(mem_ctx) ir_if(operand(r3A82).val);
               exec_list *const f3A81_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A81->then_instructions;

                  ir_variable *const r3A83 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3A85 = less(body.constant(int(2045)), r3A3A);
                  ir_if *f3A84 = new(mem_ctx) ir_if(operand(r3A85).val);
                  exec_list *const f3A84_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A84->then_instructions;

                     body.emit(assign(r3A83, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A84->else_instructions;

                     ir_variable *const r3A86 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3A88 = equal(r3A3A, body.constant(int(2045)));
                     ir_if *f3A87 = new(mem_ctx) ir_if(operand(r3A88).val);
                     exec_list *const f3A87_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A87->then_instructions;

                        ir_expression *const r3A89 = equal(body.constant(2097151u), r3A3B);
                        ir_expression *const r3A8A = equal(body.constant(4294967295u), r3A3C);
                        body.emit(assign(r3A86, logic_and(r3A89, r3A8A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3A87->else_instructions;

                        body.emit(assign(r3A86, body.constant(false), 0x01));


                     body.instructions = f3A87_parent_instructions;
                     body.emit(f3A87);

                     /* END IF */

                     body.emit(assign(r3A83, logic_and(r3A86, r3A7F), 0x01));


                  body.instructions = f3A84_parent_instructions;
                  body.emit(f3A84);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3A8B = new(mem_ctx) ir_if(operand(r3A83).val);
                  exec_list *const f3A8B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A8B->then_instructions;

                     ir_variable *const r3A8C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3A8C);
                     ir_expression *const r3A8D = lshift(r3900, body.constant(int(31)));
                     body.emit(assign(r3A8C, add(r3A8D, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3A8C, body.constant(0u), 0x01));

                     body.emit(assign(r3A7E, r3A8C, 0x03));

                     body.emit(assign(r3A7D, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A8B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3A8F = less(r3A3A, body.constant(int(0)));
                     ir_if *f3A8E = new(mem_ctx) ir_if(operand(r3A8F).val);
                     exec_list *const f3A8E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A8E->then_instructions;

                        ir_variable *const r3A90 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3A90, r3A3D, 0x01));

                        ir_variable *const r3A91 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3A91, neg(r3A3A), 0x01));

                        ir_variable *const r3A92 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3A92);
                        ir_variable *const r3A93 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3A93);
                        ir_variable *const r3A94 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3A94);
                        ir_variable *const r3A95 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3A96 = neg(r3A91);
                        body.emit(assign(r3A95, bit_and(r3A96, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3A98 = equal(r3A91, body.constant(int(0)));
                        ir_if *f3A97 = new(mem_ctx) ir_if(operand(r3A98).val);
                        exec_list *const f3A97_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3A97->then_instructions;

                           body.emit(assign(r3A92, r3A3D, 0x01));

                           body.emit(assign(r3A93, r3A3C, 0x01));

                           body.emit(assign(r3A94, r3A3B, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3A97->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3A9A = less(r3A91, body.constant(int(32)));
                           ir_if *f3A99 = new(mem_ctx) ir_if(operand(r3A9A).val);
                           exec_list *const f3A99_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3A99->then_instructions;

                              body.emit(assign(r3A92, lshift(r3A3C, r3A95), 0x01));

                              ir_expression *const r3A9B = lshift(r3A3B, r3A95);
                              ir_expression *const r3A9C = rshift(r3A3C, r3A91);
                              body.emit(assign(r3A93, bit_or(r3A9B, r3A9C), 0x01));

                              body.emit(assign(r3A94, rshift(r3A3B, r3A91), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3A99->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3A9E = equal(r3A91, body.constant(int(32)));
                              ir_if *f3A9D = new(mem_ctx) ir_if(operand(r3A9E).val);
                              exec_list *const f3A9D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3A9D->then_instructions;

                                 body.emit(assign(r3A92, r3A3C, 0x01));

                                 body.emit(assign(r3A93, r3A3B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3A9D->else_instructions;

                                 body.emit(assign(r3A90, bit_or(r3A3D, r3A3C), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3AA0 = less(r3A91, body.constant(int(64)));
                                 ir_if *f3A9F = new(mem_ctx) ir_if(operand(r3AA0).val);
                                 exec_list *const f3A9F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3A9F->then_instructions;

                                    body.emit(assign(r3A92, lshift(r3A3B, r3A95), 0x01));

                                    ir_expression *const r3AA1 = bit_and(r3A91, body.constant(int(31)));
                                    body.emit(assign(r3A93, rshift(r3A3B, r3AA1), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3A9F->else_instructions;

                                    ir_variable *const r3AA2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3AA4 = equal(r3A91, body.constant(int(64)));
                                    ir_if *f3AA3 = new(mem_ctx) ir_if(operand(r3AA4).val);
                                    exec_list *const f3AA3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3AA3->then_instructions;

                                       body.emit(assign(r3AA2, r3A3B, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3AA3->else_instructions;

                                       ir_expression *const r3AA5 = nequal(r3A3B, body.constant(0u));
                                       ir_expression *const r3AA6 = expr(ir_unop_b2i, r3AA5);
                                       body.emit(assign(r3AA2, expr(ir_unop_i2u, r3AA6), 0x01));


                                    body.instructions = f3AA3_parent_instructions;
                                    body.emit(f3AA3);

                                    /* END IF */

                                    body.emit(assign(r3A92, r3AA2, 0x01));

                                    body.emit(assign(r3A93, body.constant(0u), 0x01));


                                 body.instructions = f3A9F_parent_instructions;
                                 body.emit(f3A9F);

                                 /* END IF */


                              body.instructions = f3A9D_parent_instructions;
                              body.emit(f3A9D);

                              /* END IF */

                              body.emit(assign(r3A94, body.constant(0u), 0x01));


                           body.instructions = f3A99_parent_instructions;
                           body.emit(f3A99);

                           /* END IF */

                           ir_expression *const r3AA7 = nequal(r3A90, body.constant(0u));
                           ir_expression *const r3AA8 = expr(ir_unop_b2i, r3AA7);
                           ir_expression *const r3AA9 = expr(ir_unop_i2u, r3AA8);
                           body.emit(assign(r3A92, bit_or(r3A92, r3AA9), 0x01));


                        body.instructions = f3A97_parent_instructions;
                        body.emit(f3A97);

                        /* END IF */

                        body.emit(assign(r3A7A, r3A94, 0x01));

                        body.emit(assign(r3A7B, r3A93, 0x01));

                        body.emit(assign(r3A7C, r3A92, 0x01));

                        body.emit(assign(r3A79, body.constant(int(0)), 0x01));

                        body.emit(assign(r3A7F, less(r3A92, body.constant(0u)), 0x01));


                     body.instructions = f3A8E_parent_instructions;
                     body.emit(f3A8E);

                     /* END IF */


                  body.instructions = f3A8B_parent_instructions;
                  body.emit(f3A8B);

                  /* END IF */


               body.instructions = f3A81_parent_instructions;
               body.emit(f3A81);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3AAA = new(mem_ctx) ir_if(operand(r3A7D).val);
               exec_list *const f3AAA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3AAA->then_instructions;

                  /* IF CONDITION */
                  ir_if *f3AAB = new(mem_ctx) ir_if(operand(r3A7F).val);
                  exec_list *const f3AAB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3AAB->then_instructions;

                     ir_variable *const r3AAC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3AAC, add(r3A7B, body.constant(1u)), 0x01));

                     ir_expression *const r3AAD = less(r3AAC, r3A7B);
                     ir_expression *const r3AAE = expr(ir_unop_b2i, r3AAD);
                     ir_expression *const r3AAF = expr(ir_unop_i2u, r3AAE);
                     body.emit(assign(r3A7A, add(r3A7A, r3AAF), 0x01));

                     ir_expression *const r3AB0 = equal(r3A7C, body.constant(0u));
                     ir_expression *const r3AB1 = expr(ir_unop_b2i, r3AB0);
                     ir_expression *const r3AB2 = expr(ir_unop_i2u, r3AB1);
                     ir_expression *const r3AB3 = add(r3A7C, r3AB2);
                     ir_expression *const r3AB4 = bit_and(r3AB3, body.constant(1u));
                     ir_expression *const r3AB5 = expr(ir_unop_bit_not, r3AB4);
                     body.emit(assign(r3A7B, bit_and(r3AAC, r3AB5), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3AAB->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3AB7 = bit_or(r3A7A, r3A7B);
                     ir_expression *const r3AB8 = equal(r3AB7, body.constant(0u));
                     ir_if *f3AB6 = new(mem_ctx) ir_if(operand(r3AB8).val);
                     exec_list *const f3AB6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AB6->then_instructions;

                        body.emit(assign(r3A79, body.constant(int(0)), 0x01));


                     body.instructions = f3AB6_parent_instructions;
                     body.emit(f3AB6);

                     /* END IF */


                  body.instructions = f3AAB_parent_instructions;
                  body.emit(f3AAB);

                  /* END IF */

                  ir_variable *const r3AB9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3AB9);
                  ir_expression *const r3ABA = lshift(r3900, body.constant(int(31)));
                  ir_expression *const r3ABB = expr(ir_unop_i2u, r3A79);
                  ir_expression *const r3ABC = lshift(r3ABB, body.constant(int(20)));
                  ir_expression *const r3ABD = add(r3ABA, r3ABC);
                  body.emit(assign(r3AB9, add(r3ABD, r3A7A), 0x02));

                  body.emit(assign(r3AB9, r3A7B, 0x01));

                  body.emit(assign(r3A7E, r3AB9, 0x03));

                  body.emit(assign(r3A7D, body.constant(false), 0x01));


               body.instructions = f3AAA_parent_instructions;
               body.emit(f3AAA);

               /* END IF */

               body.emit(assign(r3901, r3A7E, 0x03));


            body.instructions = f39EC_parent_instructions;
            body.emit(f39EC);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f39EA->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3ABF = equal(r390A, body.constant(int(2047)));
            ir_if *f3ABE = new(mem_ctx) ir_if(operand(r3ABF).val);
            exec_list *const f3ABE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3ABE->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3AC1 = bit_or(r3907, r3908);
               ir_expression *const r3AC2 = bit_or(r3905, r3906);
               ir_expression *const r3AC3 = bit_or(r3AC1, r3AC2);
               ir_expression *const r3AC4 = nequal(r3AC3, body.constant(0u));
               ir_if *f3AC0 = new(mem_ctx) ir_if(operand(r3AC4).val);
               exec_list *const f3AC0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3AC0->then_instructions;

                  ir_variable *const r3AC5 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r3AC5, swizzle_x(r2D5A), 0x01));

                  ir_variable *const r3AC6 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r3AC6, swizzle_x(r3749), 0x01));

                  ir_variable *const r3AC7 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3AC8 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r3AC9 = rshift(swizzle_y(r2D5A), body.constant(int(19)));
                  ir_expression *const r3ACA = bit_and(r3AC9, body.constant(4095u));
                  ir_expression *const r3ACB = equal(r3ACA, body.constant(4094u));
                  ir_expression *const r3ACC = nequal(swizzle_x(r2D5A), body.constant(0u));
                  ir_expression *const r3ACD = bit_and(swizzle_y(r2D5A), body.constant(524287u));
                  ir_expression *const r3ACE = nequal(r3ACD, body.constant(0u));
                  ir_expression *const r3ACF = logic_or(r3ACC, r3ACE);
                  body.emit(assign(r3AC8, logic_and(r3ACB, r3ACF), 0x01));

                  ir_variable *const r3AD0 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r3AD1 = lshift(swizzle_y(r3749), body.constant(int(1)));
                  ir_expression *const r3AD2 = lequal(body.constant(4292870144u), r3AD1);
                  ir_expression *const r3AD3 = nequal(swizzle_x(r3749), body.constant(0u));
                  ir_expression *const r3AD4 = bit_and(swizzle_y(r3749), body.constant(1048575u));
                  ir_expression *const r3AD5 = nequal(r3AD4, body.constant(0u));
                  ir_expression *const r3AD6 = logic_or(r3AD3, r3AD5);
                  body.emit(assign(r3AD0, logic_and(r3AD2, r3AD6), 0x01));

                  body.emit(assign(r3AC5, bit_or(swizzle_y(r2D5A), body.constant(524288u)), 0x02));

                  body.emit(assign(r3AC6, bit_or(swizzle_y(r3749), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r3AD8 = lshift(swizzle_y(r2D5A), body.constant(int(1)));
                  ir_expression *const r3AD9 = lequal(body.constant(4292870144u), r3AD8);
                  ir_expression *const r3ADA = nequal(swizzle_x(r2D5A), body.constant(0u));
                  ir_expression *const r3ADB = bit_and(swizzle_y(r2D5A), body.constant(1048575u));
                  ir_expression *const r3ADC = nequal(r3ADB, body.constant(0u));
                  ir_expression *const r3ADD = logic_or(r3ADA, r3ADC);
                  ir_expression *const r3ADE = logic_and(r3AD9, r3ADD);
                  ir_if *f3AD7 = new(mem_ctx) ir_if(operand(r3ADE).val);
                  exec_list *const f3AD7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3AD7->then_instructions;

                     ir_variable *const r3ADF = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3AE1 = logic_and(r3AC8, r3AD0);
                     ir_if *f3AE0 = new(mem_ctx) ir_if(operand(r3AE1).val);
                     exec_list *const f3AE0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AE0->then_instructions;

                        body.emit(assign(r3ADF, r3AC6, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3AE0->else_instructions;

                        body.emit(assign(r3ADF, r3AC5, 0x03));


                     body.instructions = f3AE0_parent_instructions;
                     body.emit(f3AE0);

                     /* END IF */

                     body.emit(assign(r3AC7, r3ADF, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3AD7->else_instructions;

                     body.emit(assign(r3AC7, r3AC6, 0x03));


                  body.instructions = f3AD7_parent_instructions;
                  body.emit(f3AD7);

                  /* END IF */

                  body.emit(assign(r3901, r3AC7, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3AC0->else_instructions;

                  ir_constant_data r3AE2_data;
                  memset(&r3AE2_data, 0, sizeof(ir_constant_data));
                  r3AE2_data.u[0] = 4294967295;
                  r3AE2_data.u[1] = 4294967295;
                  ir_constant *const r3AE2 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3AE2_data);
                  body.emit(assign(r3901, r3AE2, 0x03));


               body.instructions = f3AC0_parent_instructions;
               body.emit(f3AC0);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3ABE->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3AE4 = equal(r390A, body.constant(int(0)));
               ir_if *f3AE3 = new(mem_ctx) ir_if(operand(r3AE4).val);
               exec_list *const f3AE3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3AE3->then_instructions;

                  body.emit(assign(r3904, body.constant(int(1)), 0x01));

                  body.emit(assign(r3903, body.constant(int(1)), 0x01));


               body.instructions = f3AE3_parent_instructions;
               body.emit(f3AE3);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3AE6 = less(r3905, r3907);
               ir_if *f3AE5 = new(mem_ctx) ir_if(operand(r3AE6).val);
               exec_list *const f3AE5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3AE5->then_instructions;

                  ir_variable *const r3AE7 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r3AE8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3AE8, sub(r3908, r3906), 0x01));

                  ir_expression *const r3AE9 = sub(r3907, r3905);
                  ir_expression *const r3AEA = less(r3908, r3906);
                  ir_expression *const r3AEB = expr(ir_unop_b2i, r3AEA);
                  ir_expression *const r3AEC = expr(ir_unop_i2u, r3AEB);
                  body.emit(assign(r3AE7, sub(r3AE9, r3AEC), 0x01));

                  body.emit(assign(r3909, add(r3904, body.constant(int(-1))), 0x01));

                  ir_variable *const r3AED = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r3AED, add(r3909, body.constant(int(-10))), 0x01));

                  ir_variable *const r3AEE = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r3AEE, r3AE7, 0x01));

                  ir_variable *const r3AEF = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r3AEF, r3AE8, 0x01));

                  ir_variable *const r3AF0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r3AF0);
                  ir_variable *const r3AF1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3AF1);
                  /* IF CONDITION */
                  ir_expression *const r3AF3 = equal(r3AE7, body.constant(0u));
                  ir_if *f3AF2 = new(mem_ctx) ir_if(operand(r3AF3).val);
                  exec_list *const f3AF2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3AF2->then_instructions;

                     body.emit(assign(r3AEE, r3AE8, 0x01));

                     body.emit(assign(r3AEF, body.constant(0u), 0x01));

                     body.emit(assign(r3AED, add(r3AED, body.constant(int(-32))), 0x01));


                  body.instructions = f3AF2_parent_instructions;
                  body.emit(f3AF2);

                  /* END IF */

                  ir_variable *const r3AF4 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r3AF4, r3AEE, 0x01));

                  ir_variable *const r3AF5 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3AF6 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3AF6);
                  /* IF CONDITION */
                  ir_expression *const r3AF8 = equal(r3AEE, body.constant(0u));
                  ir_if *f3AF7 = new(mem_ctx) ir_if(operand(r3AF8).val);
                  exec_list *const f3AF7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3AF7->then_instructions;

                     body.emit(assign(r3AF5, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3AF7->else_instructions;

                     body.emit(assign(r3AF6, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3AFA = bit_and(r3AEE, body.constant(4294901760u));
                     ir_expression *const r3AFB = equal(r3AFA, body.constant(0u));
                     ir_if *f3AF9 = new(mem_ctx) ir_if(operand(r3AFB).val);
                     exec_list *const f3AF9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AF9->then_instructions;

                        body.emit(assign(r3AF6, body.constant(int(16)), 0x01));

                        body.emit(assign(r3AF4, lshift(r3AEE, body.constant(int(16))), 0x01));


                     body.instructions = f3AF9_parent_instructions;
                     body.emit(f3AF9);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3AFD = bit_and(r3AF4, body.constant(4278190080u));
                     ir_expression *const r3AFE = equal(r3AFD, body.constant(0u));
                     ir_if *f3AFC = new(mem_ctx) ir_if(operand(r3AFE).val);
                     exec_list *const f3AFC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AFC->then_instructions;

                        body.emit(assign(r3AF6, add(r3AF6, body.constant(int(8))), 0x01));

                        body.emit(assign(r3AF4, lshift(r3AF4, body.constant(int(8))), 0x01));


                     body.instructions = f3AFC_parent_instructions;
                     body.emit(f3AFC);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3B00 = bit_and(r3AF4, body.constant(4026531840u));
                     ir_expression *const r3B01 = equal(r3B00, body.constant(0u));
                     ir_if *f3AFF = new(mem_ctx) ir_if(operand(r3B01).val);
                     exec_list *const f3AFF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AFF->then_instructions;

                        body.emit(assign(r3AF6, add(r3AF6, body.constant(int(4))), 0x01));

                        body.emit(assign(r3AF4, lshift(r3AF4, body.constant(int(4))), 0x01));


                     body.instructions = f3AFF_parent_instructions;
                     body.emit(f3AFF);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3B03 = bit_and(r3AF4, body.constant(3221225472u));
                     ir_expression *const r3B04 = equal(r3B03, body.constant(0u));
                     ir_if *f3B02 = new(mem_ctx) ir_if(operand(r3B04).val);
                     exec_list *const f3B02_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B02->then_instructions;

                        body.emit(assign(r3AF6, add(r3AF6, body.constant(int(2))), 0x01));

                        body.emit(assign(r3AF4, lshift(r3AF4, body.constant(int(2))), 0x01));


                     body.instructions = f3B02_parent_instructions;
                     body.emit(f3B02);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3B06 = bit_and(r3AF4, body.constant(2147483648u));
                     ir_expression *const r3B07 = equal(r3B06, body.constant(0u));
                     ir_if *f3B05 = new(mem_ctx) ir_if(operand(r3B07).val);
                     exec_list *const f3B05_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B05->then_instructions;

                        body.emit(assign(r3AF6, add(r3AF6, body.constant(int(1))), 0x01));


                     body.instructions = f3B05_parent_instructions;
                     body.emit(f3B05);

                     /* END IF */

                     body.emit(assign(r3AF5, r3AF6, 0x01));


                  body.instructions = f3AF7_parent_instructions;
                  body.emit(f3AF7);

                  /* END IF */

                  body.emit(assign(r3AF1, add(r3AF5, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3B09 = lequal(body.constant(int(0)), r3AF1);
                  ir_if *f3B08 = new(mem_ctx) ir_if(operand(r3B09).val);
                  exec_list *const f3B08_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B08->then_instructions;

                     body.emit(assign(r3AF0, body.constant(0u), 0x01));

                     ir_variable *const r3B0A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3B0A, lshift(r3AEF, r3AF1), 0x01));

                     ir_variable *const r3B0B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3B0D = equal(r3AF1, body.constant(int(0)));
                     ir_if *f3B0C = new(mem_ctx) ir_if(operand(r3B0D).val);
                     exec_list *const f3B0C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B0C->then_instructions;

                        body.emit(assign(r3B0B, r3AEE, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3B0C->else_instructions;

                        ir_expression *const r3B0E = lshift(r3AEE, r3AF1);
                        ir_expression *const r3B0F = neg(r3AF1);
                        ir_expression *const r3B10 = bit_and(r3B0F, body.constant(int(31)));
                        ir_expression *const r3B11 = rshift(r3AEF, r3B10);
                        body.emit(assign(r3B0B, bit_or(r3B0E, r3B11), 0x01));


                     body.instructions = f3B0C_parent_instructions;
                     body.emit(f3B0C);

                     /* END IF */

                     body.emit(assign(r3AEE, r3B0B, 0x01));

                     body.emit(assign(r3AEF, r3B0A, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3B08->else_instructions;

                     ir_variable *const r3B12 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r3B12, body.constant(0u), 0x01));

                     ir_variable *const r3B13 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r3B13, neg(r3AF1), 0x01));

                     ir_variable *const r3B14 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r3B14);
                     ir_variable *const r3B15 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3B15);
                     ir_variable *const r3B16 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3B16);
                     ir_variable *const r3B17 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r3B18 = neg(r3B13);
                     body.emit(assign(r3B17, bit_and(r3B18, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3B1A = equal(r3B13, body.constant(int(0)));
                     ir_if *f3B19 = new(mem_ctx) ir_if(operand(r3B1A).val);
                     exec_list *const f3B19_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B19->then_instructions;

                        body.emit(assign(r3B14, r3B12, 0x01));

                        body.emit(assign(r3B15, r3AEF, 0x01));

                        body.emit(assign(r3B16, r3AEE, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3B19->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3B1C = less(r3B13, body.constant(int(32)));
                        ir_if *f3B1B = new(mem_ctx) ir_if(operand(r3B1C).val);
                        exec_list *const f3B1B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3B1B->then_instructions;

                           body.emit(assign(r3B14, lshift(r3AEF, r3B17), 0x01));

                           ir_expression *const r3B1D = lshift(r3AEE, r3B17);
                           ir_expression *const r3B1E = rshift(r3AEF, r3B13);
                           body.emit(assign(r3B15, bit_or(r3B1D, r3B1E), 0x01));

                           body.emit(assign(r3B16, rshift(r3AEE, r3B13), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3B1B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3B20 = equal(r3B13, body.constant(int(32)));
                           ir_if *f3B1F = new(mem_ctx) ir_if(operand(r3B20).val);
                           exec_list *const f3B1F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3B1F->then_instructions;

                              body.emit(assign(r3B14, r3AEF, 0x01));

                              body.emit(assign(r3B15, r3AEE, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3B1F->else_instructions;

                              body.emit(assign(r3B12, bit_or(body.constant(0u), r3AEF), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3B22 = less(r3B13, body.constant(int(64)));
                              ir_if *f3B21 = new(mem_ctx) ir_if(operand(r3B22).val);
                              exec_list *const f3B21_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3B21->then_instructions;

                                 body.emit(assign(r3B14, lshift(r3AEE, r3B17), 0x01));

                                 ir_expression *const r3B23 = bit_and(r3B13, body.constant(int(31)));
                                 body.emit(assign(r3B15, rshift(r3AEE, r3B23), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3B21->else_instructions;

                                 ir_variable *const r3B24 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3B26 = equal(r3B13, body.constant(int(64)));
                                 ir_if *f3B25 = new(mem_ctx) ir_if(operand(r3B26).val);
                                 exec_list *const f3B25_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3B25->then_instructions;

                                    body.emit(assign(r3B24, r3AEE, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3B25->else_instructions;

                                    ir_expression *const r3B27 = nequal(r3AEE, body.constant(0u));
                                    ir_expression *const r3B28 = expr(ir_unop_b2i, r3B27);
                                    body.emit(assign(r3B24, expr(ir_unop_i2u, r3B28), 0x01));


                                 body.instructions = f3B25_parent_instructions;
                                 body.emit(f3B25);

                                 /* END IF */

                                 body.emit(assign(r3B14, r3B24, 0x01));

                                 body.emit(assign(r3B15, body.constant(0u), 0x01));


                              body.instructions = f3B21_parent_instructions;
                              body.emit(f3B21);

                              /* END IF */


                           body.instructions = f3B1F_parent_instructions;
                           body.emit(f3B1F);

                           /* END IF */

                           body.emit(assign(r3B16, body.constant(0u), 0x01));


                        body.instructions = f3B1B_parent_instructions;
                        body.emit(f3B1B);

                        /* END IF */

                        ir_expression *const r3B29 = nequal(r3B12, body.constant(0u));
                        ir_expression *const r3B2A = expr(ir_unop_b2i, r3B29);
                        ir_expression *const r3B2B = expr(ir_unop_i2u, r3B2A);
                        body.emit(assign(r3B14, bit_or(r3B14, r3B2B), 0x01));


                     body.instructions = f3B19_parent_instructions;
                     body.emit(f3B19);

                     /* END IF */

                     body.emit(assign(r3AEE, r3B16, 0x01));

                     body.emit(assign(r3AEF, r3B15, 0x01));

                     body.emit(assign(r3AF0, r3B14, 0x01));


                  body.instructions = f3B08_parent_instructions;
                  body.emit(f3B08);

                  /* END IF */

                  body.emit(assign(r3AED, sub(r3AED, r3AF1), 0x01));

                  ir_variable *const r3B2C = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r3B2C, r3AED, 0x01));

                  ir_variable *const r3B2D = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r3B2D, r3AEE, 0x01));

                  ir_variable *const r3B2E = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r3B2E, r3AEF, 0x01));

                  ir_variable *const r3B2F = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r3B2F, r3AF0, 0x01));

                  ir_variable *const r3B30 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r3B30, body.constant(true), 0x01));

                  ir_variable *const r3B31 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3B32 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r3B32);
                  ir_expression *const r3B33 = expr(ir_unop_u2i, r3AF0);
                  body.emit(assign(r3B32, less(r3B33, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3B35 = lequal(body.constant(int(2045)), r3AED);
                  ir_if *f3B34 = new(mem_ctx) ir_if(operand(r3B35).val);
                  exec_list *const f3B34_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B34->then_instructions;

                     ir_variable *const r3B36 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3B38 = less(body.constant(int(2045)), r3AED);
                     ir_if *f3B37 = new(mem_ctx) ir_if(operand(r3B38).val);
                     exec_list *const f3B37_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B37->then_instructions;

                        body.emit(assign(r3B36, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3B37->else_instructions;

                        ir_variable *const r3B39 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3B3B = equal(r3AED, body.constant(int(2045)));
                        ir_if *f3B3A = new(mem_ctx) ir_if(operand(r3B3B).val);
                        exec_list *const f3B3A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3B3A->then_instructions;

                           ir_expression *const r3B3C = equal(body.constant(2097151u), r3AEE);
                           ir_expression *const r3B3D = equal(body.constant(4294967295u), r3AEF);
                           body.emit(assign(r3B39, logic_and(r3B3C, r3B3D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3B3A->else_instructions;

                           body.emit(assign(r3B39, body.constant(false), 0x01));


                        body.instructions = f3B3A_parent_instructions;
                        body.emit(f3B3A);

                        /* END IF */

                        body.emit(assign(r3B36, logic_and(r3B39, r3B32), 0x01));


                     body.instructions = f3B37_parent_instructions;
                     body.emit(f3B37);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f3B3E = new(mem_ctx) ir_if(operand(r3B36).val);
                     exec_list *const f3B3E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B3E->then_instructions;

                        ir_variable *const r3B3F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3B3F);
                        ir_expression *const r3B40 = lshift(r3900, body.constant(int(31)));
                        body.emit(assign(r3B3F, add(r3B40, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r3B3F, body.constant(0u), 0x01));

                        body.emit(assign(r3B31, r3B3F, 0x03));

                        body.emit(assign(r3B30, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3B3E->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3B42 = less(r3AED, body.constant(int(0)));
                        ir_if *f3B41 = new(mem_ctx) ir_if(operand(r3B42).val);
                        exec_list *const f3B41_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3B41->then_instructions;

                           ir_variable *const r3B43 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3B43, r3AF0, 0x01));

                           ir_variable *const r3B44 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3B44, neg(r3AED), 0x01));

                           ir_variable *const r3B45 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3B45);
                           ir_variable *const r3B46 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3B46);
                           ir_variable *const r3B47 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3B47);
                           ir_variable *const r3B48 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r3B49 = neg(r3B44);
                           body.emit(assign(r3B48, bit_and(r3B49, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3B4B = equal(r3B44, body.constant(int(0)));
                           ir_if *f3B4A = new(mem_ctx) ir_if(operand(r3B4B).val);
                           exec_list *const f3B4A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3B4A->then_instructions;

                              body.emit(assign(r3B45, r3AF0, 0x01));

                              body.emit(assign(r3B46, r3AEF, 0x01));

                              body.emit(assign(r3B47, r3AEE, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3B4A->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3B4D = less(r3B44, body.constant(int(32)));
                              ir_if *f3B4C = new(mem_ctx) ir_if(operand(r3B4D).val);
                              exec_list *const f3B4C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3B4C->then_instructions;

                                 body.emit(assign(r3B45, lshift(r3AEF, r3B48), 0x01));

                                 ir_expression *const r3B4E = lshift(r3AEE, r3B48);
                                 ir_expression *const r3B4F = rshift(r3AEF, r3B44);
                                 body.emit(assign(r3B46, bit_or(r3B4E, r3B4F), 0x01));

                                 body.emit(assign(r3B47, rshift(r3AEE, r3B44), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3B4C->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3B51 = equal(r3B44, body.constant(int(32)));
                                 ir_if *f3B50 = new(mem_ctx) ir_if(operand(r3B51).val);
                                 exec_list *const f3B50_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3B50->then_instructions;

                                    body.emit(assign(r3B45, r3AEF, 0x01));

                                    body.emit(assign(r3B46, r3AEE, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3B50->else_instructions;

                                    body.emit(assign(r3B43, bit_or(r3AF0, r3AEF), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3B53 = less(r3B44, body.constant(int(64)));
                                    ir_if *f3B52 = new(mem_ctx) ir_if(operand(r3B53).val);
                                    exec_list *const f3B52_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3B52->then_instructions;

                                       body.emit(assign(r3B45, lshift(r3AEE, r3B48), 0x01));

                                       ir_expression *const r3B54 = bit_and(r3B44, body.constant(int(31)));
                                       body.emit(assign(r3B46, rshift(r3AEE, r3B54), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3B52->else_instructions;

                                       ir_variable *const r3B55 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3B57 = equal(r3B44, body.constant(int(64)));
                                       ir_if *f3B56 = new(mem_ctx) ir_if(operand(r3B57).val);
                                       exec_list *const f3B56_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3B56->then_instructions;

                                          body.emit(assign(r3B55, r3AEE, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3B56->else_instructions;

                                          ir_expression *const r3B58 = nequal(r3AEE, body.constant(0u));
                                          ir_expression *const r3B59 = expr(ir_unop_b2i, r3B58);
                                          body.emit(assign(r3B55, expr(ir_unop_i2u, r3B59), 0x01));


                                       body.instructions = f3B56_parent_instructions;
                                       body.emit(f3B56);

                                       /* END IF */

                                       body.emit(assign(r3B45, r3B55, 0x01));

                                       body.emit(assign(r3B46, body.constant(0u), 0x01));


                                    body.instructions = f3B52_parent_instructions;
                                    body.emit(f3B52);

                                    /* END IF */


                                 body.instructions = f3B50_parent_instructions;
                                 body.emit(f3B50);

                                 /* END IF */

                                 body.emit(assign(r3B47, body.constant(0u), 0x01));


                              body.instructions = f3B4C_parent_instructions;
                              body.emit(f3B4C);

                              /* END IF */

                              ir_expression *const r3B5A = nequal(r3B43, body.constant(0u));
                              ir_expression *const r3B5B = expr(ir_unop_b2i, r3B5A);
                              ir_expression *const r3B5C = expr(ir_unop_i2u, r3B5B);
                              body.emit(assign(r3B45, bit_or(r3B45, r3B5C), 0x01));


                           body.instructions = f3B4A_parent_instructions;
                           body.emit(f3B4A);

                           /* END IF */

                           body.emit(assign(r3B2D, r3B47, 0x01));

                           body.emit(assign(r3B2E, r3B46, 0x01));

                           body.emit(assign(r3B2F, r3B45, 0x01));

                           body.emit(assign(r3B2C, body.constant(int(0)), 0x01));

                           body.emit(assign(r3B32, less(r3B45, body.constant(0u)), 0x01));


                        body.instructions = f3B41_parent_instructions;
                        body.emit(f3B41);

                        /* END IF */


                     body.instructions = f3B3E_parent_instructions;
                     body.emit(f3B3E);

                     /* END IF */


                  body.instructions = f3B34_parent_instructions;
                  body.emit(f3B34);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3B5D = new(mem_ctx) ir_if(operand(r3B30).val);
                  exec_list *const f3B5D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B5D->then_instructions;

                     /* IF CONDITION */
                     ir_if *f3B5E = new(mem_ctx) ir_if(operand(r3B32).val);
                     exec_list *const f3B5E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B5E->then_instructions;

                        ir_variable *const r3B5F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r3B5F, add(r3B2E, body.constant(1u)), 0x01));

                        ir_expression *const r3B60 = less(r3B5F, r3B2E);
                        ir_expression *const r3B61 = expr(ir_unop_b2i, r3B60);
                        ir_expression *const r3B62 = expr(ir_unop_i2u, r3B61);
                        body.emit(assign(r3B2D, add(r3B2D, r3B62), 0x01));

                        ir_expression *const r3B63 = equal(r3B2F, body.constant(0u));
                        ir_expression *const r3B64 = expr(ir_unop_b2i, r3B63);
                        ir_expression *const r3B65 = expr(ir_unop_i2u, r3B64);
                        ir_expression *const r3B66 = add(r3B2F, r3B65);
                        ir_expression *const r3B67 = bit_and(r3B66, body.constant(1u));
                        ir_expression *const r3B68 = expr(ir_unop_bit_not, r3B67);
                        body.emit(assign(r3B2E, bit_and(r3B5F, r3B68), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3B5E->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3B6A = bit_or(r3B2D, r3B2E);
                        ir_expression *const r3B6B = equal(r3B6A, body.constant(0u));
                        ir_if *f3B69 = new(mem_ctx) ir_if(operand(r3B6B).val);
                        exec_list *const f3B69_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3B69->then_instructions;

                           body.emit(assign(r3B2C, body.constant(int(0)), 0x01));


                        body.instructions = f3B69_parent_instructions;
                        body.emit(f3B69);

                        /* END IF */


                     body.instructions = f3B5E_parent_instructions;
                     body.emit(f3B5E);

                     /* END IF */

                     ir_variable *const r3B6C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3B6C);
                     ir_expression *const r3B6D = lshift(r3900, body.constant(int(31)));
                     ir_expression *const r3B6E = expr(ir_unop_i2u, r3B2C);
                     ir_expression *const r3B6F = lshift(r3B6E, body.constant(int(20)));
                     ir_expression *const r3B70 = add(r3B6D, r3B6F);
                     body.emit(assign(r3B6C, add(r3B70, r3B2D), 0x02));

                     body.emit(assign(r3B6C, r3B2E, 0x01));

                     body.emit(assign(r3B31, r3B6C, 0x03));

                     body.emit(assign(r3B30, body.constant(false), 0x01));


                  body.instructions = f3B5D_parent_instructions;
                  body.emit(f3B5D);

                  /* END IF */

                  body.emit(assign(r3901, r3B31, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3AE5->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3B72 = less(r3907, r3905);
                  ir_if *f3B71 = new(mem_ctx) ir_if(operand(r3B72).val);
                  exec_list *const f3B71_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B71->then_instructions;

                     ir_variable *const r3B73 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r3B74 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3B74, sub(r3906, r3908), 0x01));

                     ir_expression *const r3B75 = sub(r3905, r3907);
                     ir_expression *const r3B76 = less(r3906, r3908);
                     ir_expression *const r3B77 = expr(ir_unop_b2i, r3B76);
                     ir_expression *const r3B78 = expr(ir_unop_i2u, r3B77);
                     body.emit(assign(r3B73, sub(r3B75, r3B78), 0x01));

                     body.emit(assign(r3900, bit_xor(r3900, body.constant(1u)), 0x01));

                     body.emit(assign(r3909, add(r3903, body.constant(int(-1))), 0x01));

                     ir_variable *const r3B79 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r3B79, add(r3909, body.constant(int(-10))), 0x01));

                     ir_variable *const r3B7A = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r3B7A, r3B73, 0x01));

                     ir_variable *const r3B7B = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r3B7B, r3B74, 0x01));

                     ir_variable *const r3B7C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r3B7C);
                     ir_variable *const r3B7D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3B7D);
                     /* IF CONDITION */
                     ir_expression *const r3B7F = equal(r3B73, body.constant(0u));
                     ir_if *f3B7E = new(mem_ctx) ir_if(operand(r3B7F).val);
                     exec_list *const f3B7E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B7E->then_instructions;

                        body.emit(assign(r3B7A, r3B74, 0x01));

                        body.emit(assign(r3B7B, body.constant(0u), 0x01));

                        body.emit(assign(r3B79, add(r3B79, body.constant(int(-32))), 0x01));


                     body.instructions = f3B7E_parent_instructions;
                     body.emit(f3B7E);

                     /* END IF */

                     ir_variable *const r3B80 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3B80, r3B7A, 0x01));

                     ir_variable *const r3B81 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3B82 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3B82);
                     /* IF CONDITION */
                     ir_expression *const r3B84 = equal(r3B7A, body.constant(0u));
                     ir_if *f3B83 = new(mem_ctx) ir_if(operand(r3B84).val);
                     exec_list *const f3B83_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B83->then_instructions;

                        body.emit(assign(r3B81, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3B83->else_instructions;

                        body.emit(assign(r3B82, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3B86 = bit_and(r3B7A, body.constant(4294901760u));
                        ir_expression *const r3B87 = equal(r3B86, body.constant(0u));
                        ir_if *f3B85 = new(mem_ctx) ir_if(operand(r3B87).val);
                        exec_list *const f3B85_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3B85->then_instructions;

                           body.emit(assign(r3B82, body.constant(int(16)), 0x01));

                           body.emit(assign(r3B80, lshift(r3B7A, body.constant(int(16))), 0x01));


                        body.instructions = f3B85_parent_instructions;
                        body.emit(f3B85);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3B89 = bit_and(r3B80, body.constant(4278190080u));
                        ir_expression *const r3B8A = equal(r3B89, body.constant(0u));
                        ir_if *f3B88 = new(mem_ctx) ir_if(operand(r3B8A).val);
                        exec_list *const f3B88_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3B88->then_instructions;

                           body.emit(assign(r3B82, add(r3B82, body.constant(int(8))), 0x01));

                           body.emit(assign(r3B80, lshift(r3B80, body.constant(int(8))), 0x01));


                        body.instructions = f3B88_parent_instructions;
                        body.emit(f3B88);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3B8C = bit_and(r3B80, body.constant(4026531840u));
                        ir_expression *const r3B8D = equal(r3B8C, body.constant(0u));
                        ir_if *f3B8B = new(mem_ctx) ir_if(operand(r3B8D).val);
                        exec_list *const f3B8B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3B8B->then_instructions;

                           body.emit(assign(r3B82, add(r3B82, body.constant(int(4))), 0x01));

                           body.emit(assign(r3B80, lshift(r3B80, body.constant(int(4))), 0x01));


                        body.instructions = f3B8B_parent_instructions;
                        body.emit(f3B8B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3B8F = bit_and(r3B80, body.constant(3221225472u));
                        ir_expression *const r3B90 = equal(r3B8F, body.constant(0u));
                        ir_if *f3B8E = new(mem_ctx) ir_if(operand(r3B90).val);
                        exec_list *const f3B8E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3B8E->then_instructions;

                           body.emit(assign(r3B82, add(r3B82, body.constant(int(2))), 0x01));

                           body.emit(assign(r3B80, lshift(r3B80, body.constant(int(2))), 0x01));


                        body.instructions = f3B8E_parent_instructions;
                        body.emit(f3B8E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3B92 = bit_and(r3B80, body.constant(2147483648u));
                        ir_expression *const r3B93 = equal(r3B92, body.constant(0u));
                        ir_if *f3B91 = new(mem_ctx) ir_if(operand(r3B93).val);
                        exec_list *const f3B91_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3B91->then_instructions;

                           body.emit(assign(r3B82, add(r3B82, body.constant(int(1))), 0x01));


                        body.instructions = f3B91_parent_instructions;
                        body.emit(f3B91);

                        /* END IF */

                        body.emit(assign(r3B81, r3B82, 0x01));


                     body.instructions = f3B83_parent_instructions;
                     body.emit(f3B83);

                     /* END IF */

                     body.emit(assign(r3B7D, add(r3B81, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3B95 = lequal(body.constant(int(0)), r3B7D);
                     ir_if *f3B94 = new(mem_ctx) ir_if(operand(r3B95).val);
                     exec_list *const f3B94_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B94->then_instructions;

                        body.emit(assign(r3B7C, body.constant(0u), 0x01));

                        ir_variable *const r3B96 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r3B96, lshift(r3B7B, r3B7D), 0x01));

                        ir_variable *const r3B97 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3B99 = equal(r3B7D, body.constant(int(0)));
                        ir_if *f3B98 = new(mem_ctx) ir_if(operand(r3B99).val);
                        exec_list *const f3B98_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3B98->then_instructions;

                           body.emit(assign(r3B97, r3B7A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3B98->else_instructions;

                           ir_expression *const r3B9A = lshift(r3B7A, r3B7D);
                           ir_expression *const r3B9B = neg(r3B7D);
                           ir_expression *const r3B9C = bit_and(r3B9B, body.constant(int(31)));
                           ir_expression *const r3B9D = rshift(r3B7B, r3B9C);
                           body.emit(assign(r3B97, bit_or(r3B9A, r3B9D), 0x01));


                        body.instructions = f3B98_parent_instructions;
                        body.emit(f3B98);

                        /* END IF */

                        body.emit(assign(r3B7A, r3B97, 0x01));

                        body.emit(assign(r3B7B, r3B96, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3B94->else_instructions;

                        ir_variable *const r3B9E = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3B9E, body.constant(0u), 0x01));

                        ir_variable *const r3B9F = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3B9F, neg(r3B7D), 0x01));

                        ir_variable *const r3BA0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3BA0);
                        ir_variable *const r3BA1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3BA1);
                        ir_variable *const r3BA2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3BA2);
                        ir_variable *const r3BA3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3BA4 = neg(r3B9F);
                        body.emit(assign(r3BA3, bit_and(r3BA4, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3BA6 = equal(r3B9F, body.constant(int(0)));
                        ir_if *f3BA5 = new(mem_ctx) ir_if(operand(r3BA6).val);
                        exec_list *const f3BA5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3BA5->then_instructions;

                           body.emit(assign(r3BA0, r3B9E, 0x01));

                           body.emit(assign(r3BA1, r3B7B, 0x01));

                           body.emit(assign(r3BA2, r3B7A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3BA5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3BA8 = less(r3B9F, body.constant(int(32)));
                           ir_if *f3BA7 = new(mem_ctx) ir_if(operand(r3BA8).val);
                           exec_list *const f3BA7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3BA7->then_instructions;

                              body.emit(assign(r3BA0, lshift(r3B7B, r3BA3), 0x01));

                              ir_expression *const r3BA9 = lshift(r3B7A, r3BA3);
                              ir_expression *const r3BAA = rshift(r3B7B, r3B9F);
                              body.emit(assign(r3BA1, bit_or(r3BA9, r3BAA), 0x01));

                              body.emit(assign(r3BA2, rshift(r3B7A, r3B9F), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3BA7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3BAC = equal(r3B9F, body.constant(int(32)));
                              ir_if *f3BAB = new(mem_ctx) ir_if(operand(r3BAC).val);
                              exec_list *const f3BAB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3BAB->then_instructions;

                                 body.emit(assign(r3BA0, r3B7B, 0x01));

                                 body.emit(assign(r3BA1, r3B7A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3BAB->else_instructions;

                                 body.emit(assign(r3B9E, bit_or(body.constant(0u), r3B7B), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3BAE = less(r3B9F, body.constant(int(64)));
                                 ir_if *f3BAD = new(mem_ctx) ir_if(operand(r3BAE).val);
                                 exec_list *const f3BAD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3BAD->then_instructions;

                                    body.emit(assign(r3BA0, lshift(r3B7A, r3BA3), 0x01));

                                    ir_expression *const r3BAF = bit_and(r3B9F, body.constant(int(31)));
                                    body.emit(assign(r3BA1, rshift(r3B7A, r3BAF), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3BAD->else_instructions;

                                    ir_variable *const r3BB0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3BB2 = equal(r3B9F, body.constant(int(64)));
                                    ir_if *f3BB1 = new(mem_ctx) ir_if(operand(r3BB2).val);
                                    exec_list *const f3BB1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3BB1->then_instructions;

                                       body.emit(assign(r3BB0, r3B7A, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3BB1->else_instructions;

                                       ir_expression *const r3BB3 = nequal(r3B7A, body.constant(0u));
                                       ir_expression *const r3BB4 = expr(ir_unop_b2i, r3BB3);
                                       body.emit(assign(r3BB0, expr(ir_unop_i2u, r3BB4), 0x01));


                                    body.instructions = f3BB1_parent_instructions;
                                    body.emit(f3BB1);

                                    /* END IF */

                                    body.emit(assign(r3BA0, r3BB0, 0x01));

                                    body.emit(assign(r3BA1, body.constant(0u), 0x01));


                                 body.instructions = f3BAD_parent_instructions;
                                 body.emit(f3BAD);

                                 /* END IF */


                              body.instructions = f3BAB_parent_instructions;
                              body.emit(f3BAB);

                              /* END IF */

                              body.emit(assign(r3BA2, body.constant(0u), 0x01));


                           body.instructions = f3BA7_parent_instructions;
                           body.emit(f3BA7);

                           /* END IF */

                           ir_expression *const r3BB5 = nequal(r3B9E, body.constant(0u));
                           ir_expression *const r3BB6 = expr(ir_unop_b2i, r3BB5);
                           ir_expression *const r3BB7 = expr(ir_unop_i2u, r3BB6);
                           body.emit(assign(r3BA0, bit_or(r3BA0, r3BB7), 0x01));


                        body.instructions = f3BA5_parent_instructions;
                        body.emit(f3BA5);

                        /* END IF */

                        body.emit(assign(r3B7A, r3BA2, 0x01));

                        body.emit(assign(r3B7B, r3BA1, 0x01));

                        body.emit(assign(r3B7C, r3BA0, 0x01));


                     body.instructions = f3B94_parent_instructions;
                     body.emit(f3B94);

                     /* END IF */

                     body.emit(assign(r3B79, sub(r3B79, r3B7D), 0x01));

                     ir_variable *const r3BB8 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r3BB8, r3B79, 0x01));

                     ir_variable *const r3BB9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r3BB9, r3B7A, 0x01));

                     ir_variable *const r3BBA = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r3BBA, r3B7B, 0x01));

                     ir_variable *const r3BBB = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r3BBB, r3B7C, 0x01));

                     ir_variable *const r3BBC = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r3BBC, body.constant(true), 0x01));

                     ir_variable *const r3BBD = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r3BBE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r3BBE);
                     ir_expression *const r3BBF = expr(ir_unop_u2i, r3B7C);
                     body.emit(assign(r3BBE, less(r3BBF, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3BC1 = lequal(body.constant(int(2045)), r3B79);
                     ir_if *f3BC0 = new(mem_ctx) ir_if(operand(r3BC1).val);
                     exec_list *const f3BC0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3BC0->then_instructions;

                        ir_variable *const r3BC2 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3BC4 = less(body.constant(int(2045)), r3B79);
                        ir_if *f3BC3 = new(mem_ctx) ir_if(operand(r3BC4).val);
                        exec_list *const f3BC3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3BC3->then_instructions;

                           body.emit(assign(r3BC2, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3BC3->else_instructions;

                           ir_variable *const r3BC5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3BC7 = equal(r3B79, body.constant(int(2045)));
                           ir_if *f3BC6 = new(mem_ctx) ir_if(operand(r3BC7).val);
                           exec_list *const f3BC6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3BC6->then_instructions;

                              ir_expression *const r3BC8 = equal(body.constant(2097151u), r3B7A);
                              ir_expression *const r3BC9 = equal(body.constant(4294967295u), r3B7B);
                              body.emit(assign(r3BC5, logic_and(r3BC8, r3BC9), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3BC6->else_instructions;

                              body.emit(assign(r3BC5, body.constant(false), 0x01));


                           body.instructions = f3BC6_parent_instructions;
                           body.emit(f3BC6);

                           /* END IF */

                           body.emit(assign(r3BC2, logic_and(r3BC5, r3BBE), 0x01));


                        body.instructions = f3BC3_parent_instructions;
                        body.emit(f3BC3);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f3BCA = new(mem_ctx) ir_if(operand(r3BC2).val);
                        exec_list *const f3BCA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3BCA->then_instructions;

                           ir_variable *const r3BCB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3BCB);
                           ir_expression *const r3BCC = lshift(r3900, body.constant(int(31)));
                           body.emit(assign(r3BCB, add(r3BCC, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r3BCB, body.constant(0u), 0x01));

                           body.emit(assign(r3BBD, r3BCB, 0x03));

                           body.emit(assign(r3BBC, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3BCA->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3BCE = less(r3B79, body.constant(int(0)));
                           ir_if *f3BCD = new(mem_ctx) ir_if(operand(r3BCE).val);
                           exec_list *const f3BCD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3BCD->then_instructions;

                              ir_variable *const r3BCF = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r3BCF, r3B7C, 0x01));

                              ir_variable *const r3BD0 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r3BD0, neg(r3B79), 0x01));

                              ir_variable *const r3BD1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r3BD1);
                              ir_variable *const r3BD2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r3BD2);
                              ir_variable *const r3BD3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r3BD3);
                              ir_variable *const r3BD4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r3BD5 = neg(r3BD0);
                              body.emit(assign(r3BD4, bit_and(r3BD5, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3BD7 = equal(r3BD0, body.constant(int(0)));
                              ir_if *f3BD6 = new(mem_ctx) ir_if(operand(r3BD7).val);
                              exec_list *const f3BD6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3BD6->then_instructions;

                                 body.emit(assign(r3BD1, r3B7C, 0x01));

                                 body.emit(assign(r3BD2, r3B7B, 0x01));

                                 body.emit(assign(r3BD3, r3B7A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3BD6->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3BD9 = less(r3BD0, body.constant(int(32)));
                                 ir_if *f3BD8 = new(mem_ctx) ir_if(operand(r3BD9).val);
                                 exec_list *const f3BD8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3BD8->then_instructions;

                                    body.emit(assign(r3BD1, lshift(r3B7B, r3BD4), 0x01));

                                    ir_expression *const r3BDA = lshift(r3B7A, r3BD4);
                                    ir_expression *const r3BDB = rshift(r3B7B, r3BD0);
                                    body.emit(assign(r3BD2, bit_or(r3BDA, r3BDB), 0x01));

                                    body.emit(assign(r3BD3, rshift(r3B7A, r3BD0), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3BD8->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3BDD = equal(r3BD0, body.constant(int(32)));
                                    ir_if *f3BDC = new(mem_ctx) ir_if(operand(r3BDD).val);
                                    exec_list *const f3BDC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3BDC->then_instructions;

                                       body.emit(assign(r3BD1, r3B7B, 0x01));

                                       body.emit(assign(r3BD2, r3B7A, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3BDC->else_instructions;

                                       body.emit(assign(r3BCF, bit_or(r3B7C, r3B7B), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r3BDF = less(r3BD0, body.constant(int(64)));
                                       ir_if *f3BDE = new(mem_ctx) ir_if(operand(r3BDF).val);
                                       exec_list *const f3BDE_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3BDE->then_instructions;

                                          body.emit(assign(r3BD1, lshift(r3B7A, r3BD4), 0x01));

                                          ir_expression *const r3BE0 = bit_and(r3BD0, body.constant(int(31)));
                                          body.emit(assign(r3BD2, rshift(r3B7A, r3BE0), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3BDE->else_instructions;

                                          ir_variable *const r3BE1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3BE3 = equal(r3BD0, body.constant(int(64)));
                                          ir_if *f3BE2 = new(mem_ctx) ir_if(operand(r3BE3).val);
                                          exec_list *const f3BE2_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3BE2->then_instructions;

                                             body.emit(assign(r3BE1, r3B7A, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3BE2->else_instructions;

                                             ir_expression *const r3BE4 = nequal(r3B7A, body.constant(0u));
                                             ir_expression *const r3BE5 = expr(ir_unop_b2i, r3BE4);
                                             body.emit(assign(r3BE1, expr(ir_unop_i2u, r3BE5), 0x01));


                                          body.instructions = f3BE2_parent_instructions;
                                          body.emit(f3BE2);

                                          /* END IF */

                                          body.emit(assign(r3BD1, r3BE1, 0x01));

                                          body.emit(assign(r3BD2, body.constant(0u), 0x01));


                                       body.instructions = f3BDE_parent_instructions;
                                       body.emit(f3BDE);

                                       /* END IF */


                                    body.instructions = f3BDC_parent_instructions;
                                    body.emit(f3BDC);

                                    /* END IF */

                                    body.emit(assign(r3BD3, body.constant(0u), 0x01));


                                 body.instructions = f3BD8_parent_instructions;
                                 body.emit(f3BD8);

                                 /* END IF */

                                 ir_expression *const r3BE6 = nequal(r3BCF, body.constant(0u));
                                 ir_expression *const r3BE7 = expr(ir_unop_b2i, r3BE6);
                                 ir_expression *const r3BE8 = expr(ir_unop_i2u, r3BE7);
                                 body.emit(assign(r3BD1, bit_or(r3BD1, r3BE8), 0x01));


                              body.instructions = f3BD6_parent_instructions;
                              body.emit(f3BD6);

                              /* END IF */

                              body.emit(assign(r3BB9, r3BD3, 0x01));

                              body.emit(assign(r3BBA, r3BD2, 0x01));

                              body.emit(assign(r3BBB, r3BD1, 0x01));

                              body.emit(assign(r3BB8, body.constant(int(0)), 0x01));

                              body.emit(assign(r3BBE, less(r3BD1, body.constant(0u)), 0x01));


                           body.instructions = f3BCD_parent_instructions;
                           body.emit(f3BCD);

                           /* END IF */


                        body.instructions = f3BCA_parent_instructions;
                        body.emit(f3BCA);

                        /* END IF */


                     body.instructions = f3BC0_parent_instructions;
                     body.emit(f3BC0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f3BE9 = new(mem_ctx) ir_if(operand(r3BBC).val);
                     exec_list *const f3BE9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3BE9->then_instructions;

                        /* IF CONDITION */
                        ir_if *f3BEA = new(mem_ctx) ir_if(operand(r3BBE).val);
                        exec_list *const f3BEA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3BEA->then_instructions;

                           ir_variable *const r3BEB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r3BEB, add(r3BBA, body.constant(1u)), 0x01));

                           ir_expression *const r3BEC = less(r3BEB, r3BBA);
                           ir_expression *const r3BED = expr(ir_unop_b2i, r3BEC);
                           ir_expression *const r3BEE = expr(ir_unop_i2u, r3BED);
                           body.emit(assign(r3BB9, add(r3BB9, r3BEE), 0x01));

                           ir_expression *const r3BEF = equal(r3BBB, body.constant(0u));
                           ir_expression *const r3BF0 = expr(ir_unop_b2i, r3BEF);
                           ir_expression *const r3BF1 = expr(ir_unop_i2u, r3BF0);
                           ir_expression *const r3BF2 = add(r3BBB, r3BF1);
                           ir_expression *const r3BF3 = bit_and(r3BF2, body.constant(1u));
                           ir_expression *const r3BF4 = expr(ir_unop_bit_not, r3BF3);
                           body.emit(assign(r3BBA, bit_and(r3BEB, r3BF4), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3BEA->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3BF6 = bit_or(r3BB9, r3BBA);
                           ir_expression *const r3BF7 = equal(r3BF6, body.constant(0u));
                           ir_if *f3BF5 = new(mem_ctx) ir_if(operand(r3BF7).val);
                           exec_list *const f3BF5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3BF5->then_instructions;

                              body.emit(assign(r3BB8, body.constant(int(0)), 0x01));


                           body.instructions = f3BF5_parent_instructions;
                           body.emit(f3BF5);

                           /* END IF */


                        body.instructions = f3BEA_parent_instructions;
                        body.emit(f3BEA);

                        /* END IF */

                        ir_variable *const r3BF8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3BF8);
                        ir_expression *const r3BF9 = lshift(r3900, body.constant(int(31)));
                        ir_expression *const r3BFA = expr(ir_unop_i2u, r3BB8);
                        ir_expression *const r3BFB = lshift(r3BFA, body.constant(int(20)));
                        ir_expression *const r3BFC = add(r3BF9, r3BFB);
                        body.emit(assign(r3BF8, add(r3BFC, r3BB9), 0x02));

                        body.emit(assign(r3BF8, r3BBA, 0x01));

                        body.emit(assign(r3BBD, r3BF8, 0x03));

                        body.emit(assign(r3BBC, body.constant(false), 0x01));


                     body.instructions = f3BE9_parent_instructions;
                     body.emit(f3BE9);

                     /* END IF */

                     body.emit(assign(r3901, r3BBD, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3B71->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3BFE = less(r3906, r3908);
                     ir_if *f3BFD = new(mem_ctx) ir_if(operand(r3BFE).val);
                     exec_list *const f3BFD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3BFD->then_instructions;

                        ir_variable *const r3BFF = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r3C00 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r3C00, sub(r3908, r3906), 0x01));

                        ir_expression *const r3C01 = sub(r3907, r3905);
                        ir_expression *const r3C02 = less(r3908, r3906);
                        ir_expression *const r3C03 = expr(ir_unop_b2i, r3C02);
                        ir_expression *const r3C04 = expr(ir_unop_i2u, r3C03);
                        body.emit(assign(r3BFF, sub(r3C01, r3C04), 0x01));

                        body.emit(assign(r3909, add(r3904, body.constant(int(-1))), 0x01));

                        ir_variable *const r3C05 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r3C05, add(r3909, body.constant(int(-10))), 0x01));

                        ir_variable *const r3C06 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r3C06, r3BFF, 0x01));

                        ir_variable *const r3C07 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r3C07, r3C00, 0x01));

                        ir_variable *const r3C08 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r3C08);
                        ir_variable *const r3C09 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r3C09);
                        /* IF CONDITION */
                        ir_expression *const r3C0B = equal(r3BFF, body.constant(0u));
                        ir_if *f3C0A = new(mem_ctx) ir_if(operand(r3C0B).val);
                        exec_list *const f3C0A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C0A->then_instructions;

                           body.emit(assign(r3C06, r3C00, 0x01));

                           body.emit(assign(r3C07, body.constant(0u), 0x01));

                           body.emit(assign(r3C05, add(r3C05, body.constant(int(-32))), 0x01));


                        body.instructions = f3C0A_parent_instructions;
                        body.emit(f3C0A);

                        /* END IF */

                        ir_variable *const r3C0C = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r3C0C, r3C06, 0x01));

                        ir_variable *const r3C0D = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r3C0E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r3C0E);
                        /* IF CONDITION */
                        ir_expression *const r3C10 = equal(r3C06, body.constant(0u));
                        ir_if *f3C0F = new(mem_ctx) ir_if(operand(r3C10).val);
                        exec_list *const f3C0F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C0F->then_instructions;

                           body.emit(assign(r3C0D, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3C0F->else_instructions;

                           body.emit(assign(r3C0E, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3C12 = bit_and(r3C06, body.constant(4294901760u));
                           ir_expression *const r3C13 = equal(r3C12, body.constant(0u));
                           ir_if *f3C11 = new(mem_ctx) ir_if(operand(r3C13).val);
                           exec_list *const f3C11_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C11->then_instructions;

                              body.emit(assign(r3C0E, body.constant(int(16)), 0x01));

                              body.emit(assign(r3C0C, lshift(r3C06, body.constant(int(16))), 0x01));


                           body.instructions = f3C11_parent_instructions;
                           body.emit(f3C11);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3C15 = bit_and(r3C0C, body.constant(4278190080u));
                           ir_expression *const r3C16 = equal(r3C15, body.constant(0u));
                           ir_if *f3C14 = new(mem_ctx) ir_if(operand(r3C16).val);
                           exec_list *const f3C14_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C14->then_instructions;

                              body.emit(assign(r3C0E, add(r3C0E, body.constant(int(8))), 0x01));

                              body.emit(assign(r3C0C, lshift(r3C0C, body.constant(int(8))), 0x01));


                           body.instructions = f3C14_parent_instructions;
                           body.emit(f3C14);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3C18 = bit_and(r3C0C, body.constant(4026531840u));
                           ir_expression *const r3C19 = equal(r3C18, body.constant(0u));
                           ir_if *f3C17 = new(mem_ctx) ir_if(operand(r3C19).val);
                           exec_list *const f3C17_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C17->then_instructions;

                              body.emit(assign(r3C0E, add(r3C0E, body.constant(int(4))), 0x01));

                              body.emit(assign(r3C0C, lshift(r3C0C, body.constant(int(4))), 0x01));


                           body.instructions = f3C17_parent_instructions;
                           body.emit(f3C17);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3C1B = bit_and(r3C0C, body.constant(3221225472u));
                           ir_expression *const r3C1C = equal(r3C1B, body.constant(0u));
                           ir_if *f3C1A = new(mem_ctx) ir_if(operand(r3C1C).val);
                           exec_list *const f3C1A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C1A->then_instructions;

                              body.emit(assign(r3C0E, add(r3C0E, body.constant(int(2))), 0x01));

                              body.emit(assign(r3C0C, lshift(r3C0C, body.constant(int(2))), 0x01));


                           body.instructions = f3C1A_parent_instructions;
                           body.emit(f3C1A);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3C1E = bit_and(r3C0C, body.constant(2147483648u));
                           ir_expression *const r3C1F = equal(r3C1E, body.constant(0u));
                           ir_if *f3C1D = new(mem_ctx) ir_if(operand(r3C1F).val);
                           exec_list *const f3C1D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C1D->then_instructions;

                              body.emit(assign(r3C0E, add(r3C0E, body.constant(int(1))), 0x01));


                           body.instructions = f3C1D_parent_instructions;
                           body.emit(f3C1D);

                           /* END IF */

                           body.emit(assign(r3C0D, r3C0E, 0x01));


                        body.instructions = f3C0F_parent_instructions;
                        body.emit(f3C0F);

                        /* END IF */

                        body.emit(assign(r3C09, add(r3C0D, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3C21 = lequal(body.constant(int(0)), r3C09);
                        ir_if *f3C20 = new(mem_ctx) ir_if(operand(r3C21).val);
                        exec_list *const f3C20_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C20->then_instructions;

                           body.emit(assign(r3C08, body.constant(0u), 0x01));

                           ir_variable *const r3C22 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r3C22, lshift(r3C07, r3C09), 0x01));

                           ir_variable *const r3C23 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3C25 = equal(r3C09, body.constant(int(0)));
                           ir_if *f3C24 = new(mem_ctx) ir_if(operand(r3C25).val);
                           exec_list *const f3C24_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C24->then_instructions;

                              body.emit(assign(r3C23, r3C06, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3C24->else_instructions;

                              ir_expression *const r3C26 = lshift(r3C06, r3C09);
                              ir_expression *const r3C27 = neg(r3C09);
                              ir_expression *const r3C28 = bit_and(r3C27, body.constant(int(31)));
                              ir_expression *const r3C29 = rshift(r3C07, r3C28);
                              body.emit(assign(r3C23, bit_or(r3C26, r3C29), 0x01));


                           body.instructions = f3C24_parent_instructions;
                           body.emit(f3C24);

                           /* END IF */

                           body.emit(assign(r3C06, r3C23, 0x01));

                           body.emit(assign(r3C07, r3C22, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3C20->else_instructions;

                           ir_variable *const r3C2A = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3C2A, body.constant(0u), 0x01));

                           ir_variable *const r3C2B = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3C2B, neg(r3C09), 0x01));

                           ir_variable *const r3C2C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3C2C);
                           ir_variable *const r3C2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3C2D);
                           ir_variable *const r3C2E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3C2E);
                           ir_variable *const r3C2F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r3C30 = neg(r3C2B);
                           body.emit(assign(r3C2F, bit_and(r3C30, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3C32 = equal(r3C2B, body.constant(int(0)));
                           ir_if *f3C31 = new(mem_ctx) ir_if(operand(r3C32).val);
                           exec_list *const f3C31_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C31->then_instructions;

                              body.emit(assign(r3C2C, r3C2A, 0x01));

                              body.emit(assign(r3C2D, r3C07, 0x01));

                              body.emit(assign(r3C2E, r3C06, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3C31->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3C34 = less(r3C2B, body.constant(int(32)));
                              ir_if *f3C33 = new(mem_ctx) ir_if(operand(r3C34).val);
                              exec_list *const f3C33_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3C33->then_instructions;

                                 body.emit(assign(r3C2C, lshift(r3C07, r3C2F), 0x01));

                                 ir_expression *const r3C35 = lshift(r3C06, r3C2F);
                                 ir_expression *const r3C36 = rshift(r3C07, r3C2B);
                                 body.emit(assign(r3C2D, bit_or(r3C35, r3C36), 0x01));

                                 body.emit(assign(r3C2E, rshift(r3C06, r3C2B), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3C33->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3C38 = equal(r3C2B, body.constant(int(32)));
                                 ir_if *f3C37 = new(mem_ctx) ir_if(operand(r3C38).val);
                                 exec_list *const f3C37_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3C37->then_instructions;

                                    body.emit(assign(r3C2C, r3C07, 0x01));

                                    body.emit(assign(r3C2D, r3C06, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3C37->else_instructions;

                                    body.emit(assign(r3C2A, bit_or(body.constant(0u), r3C07), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3C3A = less(r3C2B, body.constant(int(64)));
                                    ir_if *f3C39 = new(mem_ctx) ir_if(operand(r3C3A).val);
                                    exec_list *const f3C39_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3C39->then_instructions;

                                       body.emit(assign(r3C2C, lshift(r3C06, r3C2F), 0x01));

                                       ir_expression *const r3C3B = bit_and(r3C2B, body.constant(int(31)));
                                       body.emit(assign(r3C2D, rshift(r3C06, r3C3B), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3C39->else_instructions;

                                       ir_variable *const r3C3C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3C3E = equal(r3C2B, body.constant(int(64)));
                                       ir_if *f3C3D = new(mem_ctx) ir_if(operand(r3C3E).val);
                                       exec_list *const f3C3D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3C3D->then_instructions;

                                          body.emit(assign(r3C3C, r3C06, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3C3D->else_instructions;

                                          ir_expression *const r3C3F = nequal(r3C06, body.constant(0u));
                                          ir_expression *const r3C40 = expr(ir_unop_b2i, r3C3F);
                                          body.emit(assign(r3C3C, expr(ir_unop_i2u, r3C40), 0x01));


                                       body.instructions = f3C3D_parent_instructions;
                                       body.emit(f3C3D);

                                       /* END IF */

                                       body.emit(assign(r3C2C, r3C3C, 0x01));

                                       body.emit(assign(r3C2D, body.constant(0u), 0x01));


                                    body.instructions = f3C39_parent_instructions;
                                    body.emit(f3C39);

                                    /* END IF */


                                 body.instructions = f3C37_parent_instructions;
                                 body.emit(f3C37);

                                 /* END IF */

                                 body.emit(assign(r3C2E, body.constant(0u), 0x01));


                              body.instructions = f3C33_parent_instructions;
                              body.emit(f3C33);

                              /* END IF */

                              ir_expression *const r3C41 = nequal(r3C2A, body.constant(0u));
                              ir_expression *const r3C42 = expr(ir_unop_b2i, r3C41);
                              ir_expression *const r3C43 = expr(ir_unop_i2u, r3C42);
                              body.emit(assign(r3C2C, bit_or(r3C2C, r3C43), 0x01));


                           body.instructions = f3C31_parent_instructions;
                           body.emit(f3C31);

                           /* END IF */

                           body.emit(assign(r3C06, r3C2E, 0x01));

                           body.emit(assign(r3C07, r3C2D, 0x01));

                           body.emit(assign(r3C08, r3C2C, 0x01));


                        body.instructions = f3C20_parent_instructions;
                        body.emit(f3C20);

                        /* END IF */

                        body.emit(assign(r3C05, sub(r3C05, r3C09), 0x01));

                        ir_variable *const r3C44 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r3C44, r3C05, 0x01));

                        ir_variable *const r3C45 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r3C45, r3C06, 0x01));

                        ir_variable *const r3C46 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r3C46, r3C07, 0x01));

                        ir_variable *const r3C47 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r3C47, r3C08, 0x01));

                        ir_variable *const r3C48 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r3C48, body.constant(true), 0x01));

                        ir_variable *const r3C49 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r3C4A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r3C4A);
                        ir_expression *const r3C4B = expr(ir_unop_u2i, r3C08);
                        body.emit(assign(r3C4A, less(r3C4B, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3C4D = lequal(body.constant(int(2045)), r3C05);
                        ir_if *f3C4C = new(mem_ctx) ir_if(operand(r3C4D).val);
                        exec_list *const f3C4C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C4C->then_instructions;

                           ir_variable *const r3C4E = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3C50 = less(body.constant(int(2045)), r3C05);
                           ir_if *f3C4F = new(mem_ctx) ir_if(operand(r3C50).val);
                           exec_list *const f3C4F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C4F->then_instructions;

                              body.emit(assign(r3C4E, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3C4F->else_instructions;

                              ir_variable *const r3C51 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3C53 = equal(r3C05, body.constant(int(2045)));
                              ir_if *f3C52 = new(mem_ctx) ir_if(operand(r3C53).val);
                              exec_list *const f3C52_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3C52->then_instructions;

                                 ir_expression *const r3C54 = equal(body.constant(2097151u), r3C06);
                                 ir_expression *const r3C55 = equal(body.constant(4294967295u), r3C07);
                                 body.emit(assign(r3C51, logic_and(r3C54, r3C55), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3C52->else_instructions;

                                 body.emit(assign(r3C51, body.constant(false), 0x01));


                              body.instructions = f3C52_parent_instructions;
                              body.emit(f3C52);

                              /* END IF */

                              body.emit(assign(r3C4E, logic_and(r3C51, r3C4A), 0x01));


                           body.instructions = f3C4F_parent_instructions;
                           body.emit(f3C4F);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f3C56 = new(mem_ctx) ir_if(operand(r3C4E).val);
                           exec_list *const f3C56_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C56->then_instructions;

                              ir_variable *const r3C57 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3C57);
                              ir_expression *const r3C58 = lshift(r3900, body.constant(int(31)));
                              body.emit(assign(r3C57, add(r3C58, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r3C57, body.constant(0u), 0x01));

                              body.emit(assign(r3C49, r3C57, 0x03));

                              body.emit(assign(r3C48, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3C56->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3C5A = less(r3C05, body.constant(int(0)));
                              ir_if *f3C59 = new(mem_ctx) ir_if(operand(r3C5A).val);
                              exec_list *const f3C59_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3C59->then_instructions;

                                 ir_variable *const r3C5B = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r3C5B, r3C08, 0x01));

                                 ir_variable *const r3C5C = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r3C5C, neg(r3C05), 0x01));

                                 ir_variable *const r3C5D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r3C5D);
                                 ir_variable *const r3C5E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r3C5E);
                                 ir_variable *const r3C5F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r3C5F);
                                 ir_variable *const r3C60 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r3C61 = neg(r3C5C);
                                 body.emit(assign(r3C60, bit_and(r3C61, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3C63 = equal(r3C5C, body.constant(int(0)));
                                 ir_if *f3C62 = new(mem_ctx) ir_if(operand(r3C63).val);
                                 exec_list *const f3C62_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3C62->then_instructions;

                                    body.emit(assign(r3C5D, r3C08, 0x01));

                                    body.emit(assign(r3C5E, r3C07, 0x01));

                                    body.emit(assign(r3C5F, r3C06, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3C62->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3C65 = less(r3C5C, body.constant(int(32)));
                                    ir_if *f3C64 = new(mem_ctx) ir_if(operand(r3C65).val);
                                    exec_list *const f3C64_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3C64->then_instructions;

                                       body.emit(assign(r3C5D, lshift(r3C07, r3C60), 0x01));

                                       ir_expression *const r3C66 = lshift(r3C06, r3C60);
                                       ir_expression *const r3C67 = rshift(r3C07, r3C5C);
                                       body.emit(assign(r3C5E, bit_or(r3C66, r3C67), 0x01));

                                       body.emit(assign(r3C5F, rshift(r3C06, r3C5C), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3C64->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r3C69 = equal(r3C5C, body.constant(int(32)));
                                       ir_if *f3C68 = new(mem_ctx) ir_if(operand(r3C69).val);
                                       exec_list *const f3C68_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3C68->then_instructions;

                                          body.emit(assign(r3C5D, r3C07, 0x01));

                                          body.emit(assign(r3C5E, r3C06, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3C68->else_instructions;

                                          body.emit(assign(r3C5B, bit_or(r3C08, r3C07), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r3C6B = less(r3C5C, body.constant(int(64)));
                                          ir_if *f3C6A = new(mem_ctx) ir_if(operand(r3C6B).val);
                                          exec_list *const f3C6A_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3C6A->then_instructions;

                                             body.emit(assign(r3C5D, lshift(r3C06, r3C60), 0x01));

                                             ir_expression *const r3C6C = bit_and(r3C5C, body.constant(int(31)));
                                             body.emit(assign(r3C5E, rshift(r3C06, r3C6C), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3C6A->else_instructions;

                                             ir_variable *const r3C6D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r3C6F = equal(r3C5C, body.constant(int(64)));
                                             ir_if *f3C6E = new(mem_ctx) ir_if(operand(r3C6F).val);
                                             exec_list *const f3C6E_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3C6E->then_instructions;

                                                body.emit(assign(r3C6D, r3C06, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3C6E->else_instructions;

                                                ir_expression *const r3C70 = nequal(r3C06, body.constant(0u));
                                                ir_expression *const r3C71 = expr(ir_unop_b2i, r3C70);
                                                body.emit(assign(r3C6D, expr(ir_unop_i2u, r3C71), 0x01));


                                             body.instructions = f3C6E_parent_instructions;
                                             body.emit(f3C6E);

                                             /* END IF */

                                             body.emit(assign(r3C5D, r3C6D, 0x01));

                                             body.emit(assign(r3C5E, body.constant(0u), 0x01));


                                          body.instructions = f3C6A_parent_instructions;
                                          body.emit(f3C6A);

                                          /* END IF */


                                       body.instructions = f3C68_parent_instructions;
                                       body.emit(f3C68);

                                       /* END IF */

                                       body.emit(assign(r3C5F, body.constant(0u), 0x01));


                                    body.instructions = f3C64_parent_instructions;
                                    body.emit(f3C64);

                                    /* END IF */

                                    ir_expression *const r3C72 = nequal(r3C5B, body.constant(0u));
                                    ir_expression *const r3C73 = expr(ir_unop_b2i, r3C72);
                                    ir_expression *const r3C74 = expr(ir_unop_i2u, r3C73);
                                    body.emit(assign(r3C5D, bit_or(r3C5D, r3C74), 0x01));


                                 body.instructions = f3C62_parent_instructions;
                                 body.emit(f3C62);

                                 /* END IF */

                                 body.emit(assign(r3C45, r3C5F, 0x01));

                                 body.emit(assign(r3C46, r3C5E, 0x01));

                                 body.emit(assign(r3C47, r3C5D, 0x01));

                                 body.emit(assign(r3C44, body.constant(int(0)), 0x01));

                                 body.emit(assign(r3C4A, less(r3C5D, body.constant(0u)), 0x01));


                              body.instructions = f3C59_parent_instructions;
                              body.emit(f3C59);

                              /* END IF */


                           body.instructions = f3C56_parent_instructions;
                           body.emit(f3C56);

                           /* END IF */


                        body.instructions = f3C4C_parent_instructions;
                        body.emit(f3C4C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f3C75 = new(mem_ctx) ir_if(operand(r3C48).val);
                        exec_list *const f3C75_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C75->then_instructions;

                           /* IF CONDITION */
                           ir_if *f3C76 = new(mem_ctx) ir_if(operand(r3C4A).val);
                           exec_list *const f3C76_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C76->then_instructions;

                              ir_variable *const r3C77 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r3C77, add(r3C46, body.constant(1u)), 0x01));

                              ir_expression *const r3C78 = less(r3C77, r3C46);
                              ir_expression *const r3C79 = expr(ir_unop_b2i, r3C78);
                              ir_expression *const r3C7A = expr(ir_unop_i2u, r3C79);
                              body.emit(assign(r3C45, add(r3C45, r3C7A), 0x01));

                              ir_expression *const r3C7B = equal(r3C47, body.constant(0u));
                              ir_expression *const r3C7C = expr(ir_unop_b2i, r3C7B);
                              ir_expression *const r3C7D = expr(ir_unop_i2u, r3C7C);
                              ir_expression *const r3C7E = add(r3C47, r3C7D);
                              ir_expression *const r3C7F = bit_and(r3C7E, body.constant(1u));
                              ir_expression *const r3C80 = expr(ir_unop_bit_not, r3C7F);
                              body.emit(assign(r3C46, bit_and(r3C77, r3C80), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3C76->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3C82 = bit_or(r3C45, r3C46);
                              ir_expression *const r3C83 = equal(r3C82, body.constant(0u));
                              ir_if *f3C81 = new(mem_ctx) ir_if(operand(r3C83).val);
                              exec_list *const f3C81_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3C81->then_instructions;

                                 body.emit(assign(r3C44, body.constant(int(0)), 0x01));


                              body.instructions = f3C81_parent_instructions;
                              body.emit(f3C81);

                              /* END IF */


                           body.instructions = f3C76_parent_instructions;
                           body.emit(f3C76);

                           /* END IF */

                           ir_variable *const r3C84 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3C84);
                           ir_expression *const r3C85 = lshift(r3900, body.constant(int(31)));
                           ir_expression *const r3C86 = expr(ir_unop_i2u, r3C44);
                           ir_expression *const r3C87 = lshift(r3C86, body.constant(int(20)));
                           ir_expression *const r3C88 = add(r3C85, r3C87);
                           body.emit(assign(r3C84, add(r3C88, r3C45), 0x02));

                           body.emit(assign(r3C84, r3C46, 0x01));

                           body.emit(assign(r3C49, r3C84, 0x03));

                           body.emit(assign(r3C48, body.constant(false), 0x01));


                        body.instructions = f3C75_parent_instructions;
                        body.emit(f3C75);

                        /* END IF */

                        body.emit(assign(r3901, r3C49, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3BFD->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3C8A = less(r3908, r3906);
                        ir_if *f3C89 = new(mem_ctx) ir_if(operand(r3C8A).val);
                        exec_list *const f3C89_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C89->then_instructions;

                           ir_variable *const r3C8B = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r3C8C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r3C8C, sub(r3906, r3908), 0x01));

                           ir_expression *const r3C8D = sub(r3905, r3907);
                           ir_expression *const r3C8E = less(r3906, r3908);
                           ir_expression *const r3C8F = expr(ir_unop_b2i, r3C8E);
                           ir_expression *const r3C90 = expr(ir_unop_i2u, r3C8F);
                           body.emit(assign(r3C8B, sub(r3C8D, r3C90), 0x01));

                           body.emit(assign(r3900, bit_xor(r3900, body.constant(1u)), 0x01));

                           body.emit(assign(r3909, add(r3903, body.constant(int(-1))), 0x01));

                           ir_variable *const r3C91 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r3C91, add(r3909, body.constant(int(-10))), 0x01));

                           ir_variable *const r3C92 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r3C92, r3C8B, 0x01));

                           ir_variable *const r3C93 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r3C93, r3C8C, 0x01));

                           ir_variable *const r3C94 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r3C94);
                           ir_variable *const r3C95 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r3C95);
                           /* IF CONDITION */
                           ir_expression *const r3C97 = equal(r3C8B, body.constant(0u));
                           ir_if *f3C96 = new(mem_ctx) ir_if(operand(r3C97).val);
                           exec_list *const f3C96_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C96->then_instructions;

                              body.emit(assign(r3C92, r3C8C, 0x01));

                              body.emit(assign(r3C93, body.constant(0u), 0x01));

                              body.emit(assign(r3C91, add(r3C91, body.constant(int(-32))), 0x01));


                           body.instructions = f3C96_parent_instructions;
                           body.emit(f3C96);

                           /* END IF */

                           ir_variable *const r3C98 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r3C98, r3C92, 0x01));

                           ir_variable *const r3C99 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r3C9A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r3C9A);
                           /* IF CONDITION */
                           ir_expression *const r3C9C = equal(r3C92, body.constant(0u));
                           ir_if *f3C9B = new(mem_ctx) ir_if(operand(r3C9C).val);
                           exec_list *const f3C9B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C9B->then_instructions;

                              body.emit(assign(r3C99, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3C9B->else_instructions;

                              body.emit(assign(r3C9A, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3C9E = bit_and(r3C92, body.constant(4294901760u));
                              ir_expression *const r3C9F = equal(r3C9E, body.constant(0u));
                              ir_if *f3C9D = new(mem_ctx) ir_if(operand(r3C9F).val);
                              exec_list *const f3C9D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3C9D->then_instructions;

                                 body.emit(assign(r3C9A, body.constant(int(16)), 0x01));

                                 body.emit(assign(r3C98, lshift(r3C92, body.constant(int(16))), 0x01));


                              body.instructions = f3C9D_parent_instructions;
                              body.emit(f3C9D);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3CA1 = bit_and(r3C98, body.constant(4278190080u));
                              ir_expression *const r3CA2 = equal(r3CA1, body.constant(0u));
                              ir_if *f3CA0 = new(mem_ctx) ir_if(operand(r3CA2).val);
                              exec_list *const f3CA0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3CA0->then_instructions;

                                 body.emit(assign(r3C9A, add(r3C9A, body.constant(int(8))), 0x01));

                                 body.emit(assign(r3C98, lshift(r3C98, body.constant(int(8))), 0x01));


                              body.instructions = f3CA0_parent_instructions;
                              body.emit(f3CA0);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3CA4 = bit_and(r3C98, body.constant(4026531840u));
                              ir_expression *const r3CA5 = equal(r3CA4, body.constant(0u));
                              ir_if *f3CA3 = new(mem_ctx) ir_if(operand(r3CA5).val);
                              exec_list *const f3CA3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3CA3->then_instructions;

                                 body.emit(assign(r3C9A, add(r3C9A, body.constant(int(4))), 0x01));

                                 body.emit(assign(r3C98, lshift(r3C98, body.constant(int(4))), 0x01));


                              body.instructions = f3CA3_parent_instructions;
                              body.emit(f3CA3);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3CA7 = bit_and(r3C98, body.constant(3221225472u));
                              ir_expression *const r3CA8 = equal(r3CA7, body.constant(0u));
                              ir_if *f3CA6 = new(mem_ctx) ir_if(operand(r3CA8).val);
                              exec_list *const f3CA6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3CA6->then_instructions;

                                 body.emit(assign(r3C9A, add(r3C9A, body.constant(int(2))), 0x01));

                                 body.emit(assign(r3C98, lshift(r3C98, body.constant(int(2))), 0x01));


                              body.instructions = f3CA6_parent_instructions;
                              body.emit(f3CA6);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3CAA = bit_and(r3C98, body.constant(2147483648u));
                              ir_expression *const r3CAB = equal(r3CAA, body.constant(0u));
                              ir_if *f3CA9 = new(mem_ctx) ir_if(operand(r3CAB).val);
                              exec_list *const f3CA9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3CA9->then_instructions;

                                 body.emit(assign(r3C9A, add(r3C9A, body.constant(int(1))), 0x01));


                              body.instructions = f3CA9_parent_instructions;
                              body.emit(f3CA9);

                              /* END IF */

                              body.emit(assign(r3C99, r3C9A, 0x01));


                           body.instructions = f3C9B_parent_instructions;
                           body.emit(f3C9B);

                           /* END IF */

                           body.emit(assign(r3C95, add(r3C99, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3CAD = lequal(body.constant(int(0)), r3C95);
                           ir_if *f3CAC = new(mem_ctx) ir_if(operand(r3CAD).val);
                           exec_list *const f3CAC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3CAC->then_instructions;

                              body.emit(assign(r3C94, body.constant(0u), 0x01));

                              ir_variable *const r3CAE = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r3CAE, lshift(r3C93, r3C95), 0x01));

                              ir_variable *const r3CAF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3CB1 = equal(r3C95, body.constant(int(0)));
                              ir_if *f3CB0 = new(mem_ctx) ir_if(operand(r3CB1).val);
                              exec_list *const f3CB0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3CB0->then_instructions;

                                 body.emit(assign(r3CAF, r3C92, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3CB0->else_instructions;

                                 ir_expression *const r3CB2 = lshift(r3C92, r3C95);
                                 ir_expression *const r3CB3 = neg(r3C95);
                                 ir_expression *const r3CB4 = bit_and(r3CB3, body.constant(int(31)));
                                 ir_expression *const r3CB5 = rshift(r3C93, r3CB4);
                                 body.emit(assign(r3CAF, bit_or(r3CB2, r3CB5), 0x01));


                              body.instructions = f3CB0_parent_instructions;
                              body.emit(f3CB0);

                              /* END IF */

                              body.emit(assign(r3C92, r3CAF, 0x01));

                              body.emit(assign(r3C93, r3CAE, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3CAC->else_instructions;

                              ir_variable *const r3CB6 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r3CB6, body.constant(0u), 0x01));

                              ir_variable *const r3CB7 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r3CB7, neg(r3C95), 0x01));

                              ir_variable *const r3CB8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r3CB8);
                              ir_variable *const r3CB9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r3CB9);
                              ir_variable *const r3CBA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r3CBA);
                              ir_variable *const r3CBB = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r3CBC = neg(r3CB7);
                              body.emit(assign(r3CBB, bit_and(r3CBC, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3CBE = equal(r3CB7, body.constant(int(0)));
                              ir_if *f3CBD = new(mem_ctx) ir_if(operand(r3CBE).val);
                              exec_list *const f3CBD_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3CBD->then_instructions;

                                 body.emit(assign(r3CB8, r3CB6, 0x01));

                                 body.emit(assign(r3CB9, r3C93, 0x01));

                                 body.emit(assign(r3CBA, r3C92, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3CBD->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3CC0 = less(r3CB7, body.constant(int(32)));
                                 ir_if *f3CBF = new(mem_ctx) ir_if(operand(r3CC0).val);
                                 exec_list *const f3CBF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3CBF->then_instructions;

                                    body.emit(assign(r3CB8, lshift(r3C93, r3CBB), 0x01));

                                    ir_expression *const r3CC1 = lshift(r3C92, r3CBB);
                                    ir_expression *const r3CC2 = rshift(r3C93, r3CB7);
                                    body.emit(assign(r3CB9, bit_or(r3CC1, r3CC2), 0x01));

                                    body.emit(assign(r3CBA, rshift(r3C92, r3CB7), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3CBF->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3CC4 = equal(r3CB7, body.constant(int(32)));
                                    ir_if *f3CC3 = new(mem_ctx) ir_if(operand(r3CC4).val);
                                    exec_list *const f3CC3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3CC3->then_instructions;

                                       body.emit(assign(r3CB8, r3C93, 0x01));

                                       body.emit(assign(r3CB9, r3C92, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3CC3->else_instructions;

                                       body.emit(assign(r3CB6, bit_or(body.constant(0u), r3C93), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r3CC6 = less(r3CB7, body.constant(int(64)));
                                       ir_if *f3CC5 = new(mem_ctx) ir_if(operand(r3CC6).val);
                                       exec_list *const f3CC5_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3CC5->then_instructions;

                                          body.emit(assign(r3CB8, lshift(r3C92, r3CBB), 0x01));

                                          ir_expression *const r3CC7 = bit_and(r3CB7, body.constant(int(31)));
                                          body.emit(assign(r3CB9, rshift(r3C92, r3CC7), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3CC5->else_instructions;

                                          ir_variable *const r3CC8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3CCA = equal(r3CB7, body.constant(int(64)));
                                          ir_if *f3CC9 = new(mem_ctx) ir_if(operand(r3CCA).val);
                                          exec_list *const f3CC9_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3CC9->then_instructions;

                                             body.emit(assign(r3CC8, r3C92, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3CC9->else_instructions;

                                             ir_expression *const r3CCB = nequal(r3C92, body.constant(0u));
                                             ir_expression *const r3CCC = expr(ir_unop_b2i, r3CCB);
                                             body.emit(assign(r3CC8, expr(ir_unop_i2u, r3CCC), 0x01));


                                          body.instructions = f3CC9_parent_instructions;
                                          body.emit(f3CC9);

                                          /* END IF */

                                          body.emit(assign(r3CB8, r3CC8, 0x01));

                                          body.emit(assign(r3CB9, body.constant(0u), 0x01));


                                       body.instructions = f3CC5_parent_instructions;
                                       body.emit(f3CC5);

                                       /* END IF */


                                    body.instructions = f3CC3_parent_instructions;
                                    body.emit(f3CC3);

                                    /* END IF */

                                    body.emit(assign(r3CBA, body.constant(0u), 0x01));


                                 body.instructions = f3CBF_parent_instructions;
                                 body.emit(f3CBF);

                                 /* END IF */

                                 ir_expression *const r3CCD = nequal(r3CB6, body.constant(0u));
                                 ir_expression *const r3CCE = expr(ir_unop_b2i, r3CCD);
                                 ir_expression *const r3CCF = expr(ir_unop_i2u, r3CCE);
                                 body.emit(assign(r3CB8, bit_or(r3CB8, r3CCF), 0x01));


                              body.instructions = f3CBD_parent_instructions;
                              body.emit(f3CBD);

                              /* END IF */

                              body.emit(assign(r3C92, r3CBA, 0x01));

                              body.emit(assign(r3C93, r3CB9, 0x01));

                              body.emit(assign(r3C94, r3CB8, 0x01));


                           body.instructions = f3CAC_parent_instructions;
                           body.emit(f3CAC);

                           /* END IF */

                           body.emit(assign(r3C91, sub(r3C91, r3C95), 0x01));

                           ir_variable *const r3CD0 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r3CD0, r3C91, 0x01));

                           ir_variable *const r3CD1 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r3CD1, r3C92, 0x01));

                           ir_variable *const r3CD2 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r3CD2, r3C93, 0x01));

                           ir_variable *const r3CD3 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r3CD3, r3C94, 0x01));

                           ir_variable *const r3CD4 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r3CD4, body.constant(true), 0x01));

                           ir_variable *const r3CD5 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r3CD6 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r3CD6);
                           ir_expression *const r3CD7 = expr(ir_unop_u2i, r3C94);
                           body.emit(assign(r3CD6, less(r3CD7, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3CD9 = lequal(body.constant(int(2045)), r3C91);
                           ir_if *f3CD8 = new(mem_ctx) ir_if(operand(r3CD9).val);
                           exec_list *const f3CD8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3CD8->then_instructions;

                              ir_variable *const r3CDA = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3CDC = less(body.constant(int(2045)), r3C91);
                              ir_if *f3CDB = new(mem_ctx) ir_if(operand(r3CDC).val);
                              exec_list *const f3CDB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3CDB->then_instructions;

                                 body.emit(assign(r3CDA, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3CDB->else_instructions;

                                 ir_variable *const r3CDD = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3CDF = equal(r3C91, body.constant(int(2045)));
                                 ir_if *f3CDE = new(mem_ctx) ir_if(operand(r3CDF).val);
                                 exec_list *const f3CDE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3CDE->then_instructions;

                                    ir_expression *const r3CE0 = equal(body.constant(2097151u), r3C92);
                                    ir_expression *const r3CE1 = equal(body.constant(4294967295u), r3C93);
                                    body.emit(assign(r3CDD, logic_and(r3CE0, r3CE1), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3CDE->else_instructions;

                                    body.emit(assign(r3CDD, body.constant(false), 0x01));


                                 body.instructions = f3CDE_parent_instructions;
                                 body.emit(f3CDE);

                                 /* END IF */

                                 body.emit(assign(r3CDA, logic_and(r3CDD, r3CD6), 0x01));


                              body.instructions = f3CDB_parent_instructions;
                              body.emit(f3CDB);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f3CE2 = new(mem_ctx) ir_if(operand(r3CDA).val);
                              exec_list *const f3CE2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3CE2->then_instructions;

                                 ir_variable *const r3CE3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r3CE3);
                                 ir_expression *const r3CE4 = lshift(r3900, body.constant(int(31)));
                                 body.emit(assign(r3CE3, add(r3CE4, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r3CE3, body.constant(0u), 0x01));

                                 body.emit(assign(r3CD5, r3CE3, 0x03));

                                 body.emit(assign(r3CD4, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3CE2->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3CE6 = less(r3C91, body.constant(int(0)));
                                 ir_if *f3CE5 = new(mem_ctx) ir_if(operand(r3CE6).val);
                                 exec_list *const f3CE5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3CE5->then_instructions;

                                    ir_variable *const r3CE7 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r3CE7, r3C94, 0x01));

                                    ir_variable *const r3CE8 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r3CE8, neg(r3C91), 0x01));

                                    ir_variable *const r3CE9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r3CE9);
                                    ir_variable *const r3CEA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r3CEA);
                                    ir_variable *const r3CEB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r3CEB);
                                    ir_variable *const r3CEC = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r3CED = neg(r3CE8);
                                    body.emit(assign(r3CEC, bit_and(r3CED, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3CEF = equal(r3CE8, body.constant(int(0)));
                                    ir_if *f3CEE = new(mem_ctx) ir_if(operand(r3CEF).val);
                                    exec_list *const f3CEE_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3CEE->then_instructions;

                                       body.emit(assign(r3CE9, r3C94, 0x01));

                                       body.emit(assign(r3CEA, r3C93, 0x01));

                                       body.emit(assign(r3CEB, r3C92, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3CEE->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r3CF1 = less(r3CE8, body.constant(int(32)));
                                       ir_if *f3CF0 = new(mem_ctx) ir_if(operand(r3CF1).val);
                                       exec_list *const f3CF0_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3CF0->then_instructions;

                                          body.emit(assign(r3CE9, lshift(r3C93, r3CEC), 0x01));

                                          ir_expression *const r3CF2 = lshift(r3C92, r3CEC);
                                          ir_expression *const r3CF3 = rshift(r3C93, r3CE8);
                                          body.emit(assign(r3CEA, bit_or(r3CF2, r3CF3), 0x01));

                                          body.emit(assign(r3CEB, rshift(r3C92, r3CE8), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3CF0->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r3CF5 = equal(r3CE8, body.constant(int(32)));
                                          ir_if *f3CF4 = new(mem_ctx) ir_if(operand(r3CF5).val);
                                          exec_list *const f3CF4_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3CF4->then_instructions;

                                             body.emit(assign(r3CE9, r3C93, 0x01));

                                             body.emit(assign(r3CEA, r3C92, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3CF4->else_instructions;

                                             body.emit(assign(r3CE7, bit_or(r3C94, r3C93), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r3CF7 = less(r3CE8, body.constant(int(64)));
                                             ir_if *f3CF6 = new(mem_ctx) ir_if(operand(r3CF7).val);
                                             exec_list *const f3CF6_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3CF6->then_instructions;

                                                body.emit(assign(r3CE9, lshift(r3C92, r3CEC), 0x01));

                                                ir_expression *const r3CF8 = bit_and(r3CE8, body.constant(int(31)));
                                                body.emit(assign(r3CEA, rshift(r3C92, r3CF8), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3CF6->else_instructions;

                                                ir_variable *const r3CF9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r3CFB = equal(r3CE8, body.constant(int(64)));
                                                ir_if *f3CFA = new(mem_ctx) ir_if(operand(r3CFB).val);
                                                exec_list *const f3CFA_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f3CFA->then_instructions;

                                                   body.emit(assign(r3CF9, r3C92, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f3CFA->else_instructions;

                                                   ir_expression *const r3CFC = nequal(r3C92, body.constant(0u));
                                                   ir_expression *const r3CFD = expr(ir_unop_b2i, r3CFC);
                                                   body.emit(assign(r3CF9, expr(ir_unop_i2u, r3CFD), 0x01));


                                                body.instructions = f3CFA_parent_instructions;
                                                body.emit(f3CFA);

                                                /* END IF */

                                                body.emit(assign(r3CE9, r3CF9, 0x01));

                                                body.emit(assign(r3CEA, body.constant(0u), 0x01));


                                             body.instructions = f3CF6_parent_instructions;
                                             body.emit(f3CF6);

                                             /* END IF */


                                          body.instructions = f3CF4_parent_instructions;
                                          body.emit(f3CF4);

                                          /* END IF */

                                          body.emit(assign(r3CEB, body.constant(0u), 0x01));


                                       body.instructions = f3CF0_parent_instructions;
                                       body.emit(f3CF0);

                                       /* END IF */

                                       ir_expression *const r3CFE = nequal(r3CE7, body.constant(0u));
                                       ir_expression *const r3CFF = expr(ir_unop_b2i, r3CFE);
                                       ir_expression *const r3D00 = expr(ir_unop_i2u, r3CFF);
                                       body.emit(assign(r3CE9, bit_or(r3CE9, r3D00), 0x01));


                                    body.instructions = f3CEE_parent_instructions;
                                    body.emit(f3CEE);

                                    /* END IF */

                                    body.emit(assign(r3CD1, r3CEB, 0x01));

                                    body.emit(assign(r3CD2, r3CEA, 0x01));

                                    body.emit(assign(r3CD3, r3CE9, 0x01));

                                    body.emit(assign(r3CD0, body.constant(int(0)), 0x01));

                                    body.emit(assign(r3CD6, less(r3CE9, body.constant(0u)), 0x01));


                                 body.instructions = f3CE5_parent_instructions;
                                 body.emit(f3CE5);

                                 /* END IF */


                              body.instructions = f3CE2_parent_instructions;
                              body.emit(f3CE2);

                              /* END IF */


                           body.instructions = f3CD8_parent_instructions;
                           body.emit(f3CD8);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f3D01 = new(mem_ctx) ir_if(operand(r3CD4).val);
                           exec_list *const f3D01_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3D01->then_instructions;

                              /* IF CONDITION */
                              ir_if *f3D02 = new(mem_ctx) ir_if(operand(r3CD6).val);
                              exec_list *const f3D02_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3D02->then_instructions;

                                 ir_variable *const r3D03 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r3D03, add(r3CD2, body.constant(1u)), 0x01));

                                 ir_expression *const r3D04 = less(r3D03, r3CD2);
                                 ir_expression *const r3D05 = expr(ir_unop_b2i, r3D04);
                                 ir_expression *const r3D06 = expr(ir_unop_i2u, r3D05);
                                 body.emit(assign(r3CD1, add(r3CD1, r3D06), 0x01));

                                 ir_expression *const r3D07 = equal(r3CD3, body.constant(0u));
                                 ir_expression *const r3D08 = expr(ir_unop_b2i, r3D07);
                                 ir_expression *const r3D09 = expr(ir_unop_i2u, r3D08);
                                 ir_expression *const r3D0A = add(r3CD3, r3D09);
                                 ir_expression *const r3D0B = bit_and(r3D0A, body.constant(1u));
                                 ir_expression *const r3D0C = expr(ir_unop_bit_not, r3D0B);
                                 body.emit(assign(r3CD2, bit_and(r3D03, r3D0C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3D02->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3D0E = bit_or(r3CD1, r3CD2);
                                 ir_expression *const r3D0F = equal(r3D0E, body.constant(0u));
                                 ir_if *f3D0D = new(mem_ctx) ir_if(operand(r3D0F).val);
                                 exec_list *const f3D0D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3D0D->then_instructions;

                                    body.emit(assign(r3CD0, body.constant(int(0)), 0x01));


                                 body.instructions = f3D0D_parent_instructions;
                                 body.emit(f3D0D);

                                 /* END IF */


                              body.instructions = f3D02_parent_instructions;
                              body.emit(f3D02);

                              /* END IF */

                              ir_variable *const r3D10 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3D10);
                              ir_expression *const r3D11 = lshift(r3900, body.constant(int(31)));
                              ir_expression *const r3D12 = expr(ir_unop_i2u, r3CD0);
                              ir_expression *const r3D13 = lshift(r3D12, body.constant(int(20)));
                              ir_expression *const r3D14 = add(r3D11, r3D13);
                              body.emit(assign(r3D10, add(r3D14, r3CD1), 0x02));

                              body.emit(assign(r3D10, r3CD2, 0x01));

                              body.emit(assign(r3CD5, r3D10, 0x03));

                              body.emit(assign(r3CD4, body.constant(false), 0x01));


                           body.instructions = f3D01_parent_instructions;
                           body.emit(f3D01);

                           /* END IF */

                           body.emit(assign(r3901, r3CD5, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3C89->else_instructions;

                           ir_variable *const r3D15 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3D15);
                           body.emit(assign(r3D15, body.constant(0u), 0x02));

                           body.emit(assign(r3D15, body.constant(0u), 0x01));

                           body.emit(assign(r3901, r3D15, 0x03));


                        body.instructions = f3C89_parent_instructions;
                        body.emit(f3C89);

                        /* END IF */


                     body.instructions = f3BFD_parent_instructions;
                     body.emit(f3BFD);

                     /* END IF */


                  body.instructions = f3B71_parent_instructions;
                  body.emit(f3B71);

                  /* END IF */


               body.instructions = f3AE5_parent_instructions;
               body.emit(f3AE5);

               /* END IF */


            body.instructions = f3ABE_parent_instructions;
            body.emit(f3ABE);

            /* END IF */


         body.instructions = f39EA_parent_instructions;
         body.emit(f39EA);

         /* END IF */


      body.instructions = f391A_parent_instructions;
      body.emit(f391A);

      /* END IF */

      body.emit(assign(r3752, r3901, 0x03));


   body.instructions = f3755_parent_instructions;
   body.emit(f3755);

   /* END IF */

   ir_variable *const r3D16 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r3D17 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r3D17);
   ir_variable *const r3D18 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r3D18);
   ir_expression *const r3D19 = rshift(swizzle_y(r3752), body.constant(int(20)));
   ir_expression *const r3D1A = bit_and(r3D19, body.constant(2047u));
   ir_expression *const r3D1B = expr(ir_unop_u2i, r3D1A);
   ir_expression *const r3D1C = equal(r3D1B, body.constant(int(2047)));
   ir_expression *const r3D1D = bit_and(swizzle_y(r3752), body.constant(1048575u));
   ir_expression *const r3D1E = bit_or(r3D1D, swizzle_x(r3752));
   ir_expression *const r3D1F = nequal(r3D1E, body.constant(0u));
   body.emit(assign(r3D18, logic_and(r3D1C, r3D1F), 0x01));

   ir_expression *const r3D20 = rshift(swizzle_y(r2D5B), body.constant(int(20)));
   ir_expression *const r3D21 = bit_and(r3D20, body.constant(2047u));
   ir_expression *const r3D22 = expr(ir_unop_u2i, r3D21);
   ir_expression *const r3D23 = equal(r3D22, body.constant(int(2047)));
   ir_expression *const r3D24 = bit_and(swizzle_y(r2D5B), body.constant(1048575u));
   ir_expression *const r3D25 = bit_or(r3D24, swizzle_x(r2D5B));
   ir_expression *const r3D26 = nequal(r3D25, body.constant(0u));
   body.emit(assign(r3D17, logic_and(r3D23, r3D26), 0x01));

   /* IF CONDITION */
   ir_expression *const r3D28 = logic_or(r3D18, r3D17);
   ir_if *f3D27 = new(mem_ctx) ir_if(operand(r3D28).val);
   exec_list *const f3D27_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f3D27->then_instructions;

      body.emit(assign(r3D16, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f3D27->else_instructions;

      ir_expression *const r3D29 = equal(swizzle_x(r3752), swizzle_x(r2D5B));
      ir_expression *const r3D2A = equal(swizzle_y(r3752), swizzle_y(r2D5B));
      ir_expression *const r3D2B = equal(swizzle_x(r3752), body.constant(0u));
      ir_expression *const r3D2C = bit_or(swizzle_y(r3752), swizzle_y(r2D5B));
      ir_expression *const r3D2D = lshift(r3D2C, body.constant(int(1)));
      ir_expression *const r3D2E = equal(r3D2D, body.constant(0u));
      ir_expression *const r3D2F = logic_and(r3D2B, r3D2E);
      ir_expression *const r3D30 = logic_or(r3D2A, r3D2F);
      body.emit(assign(r3D16, logic_and(r3D29, r3D30), 0x01));


   body.instructions = f3D27_parent_instructions;
   body.emit(f3D27);

   /* END IF */

   ir_variable *const r3D31 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_expression *const r3D33 = expr(ir_unop_logic_not, r3D16);
   ir_if *f3D32 = new(mem_ctx) ir_if(operand(r3D33).val);
   exec_list *const f3D32_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f3D32->then_instructions;

      body.emit(assign(r3D31, r3752, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f3D32->else_instructions;

      body.emit(assign(r3D31, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


   body.instructions = f3D32_parent_instructions;
   body.emit(f3D32);

   /* END IF */

   body.emit(ret(r3D31));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fsign64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r3D34 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r3D34);
   ir_variable *const r3D35 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r3D36 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "retval", ir_var_auto);
   body.emit(r3D36);
   /* IF CONDITION */
   ir_expression *const r3D38 = lshift(swizzle_y(r3D34), body.constant(int(1)));
   ir_expression *const r3D39 = bit_or(r3D38, swizzle_x(r3D34));
   ir_expression *const r3D3A = equal(r3D39, body.constant(0u));
   ir_if *f3D37 = new(mem_ctx) ir_if(operand(r3D3A).val);
   exec_list *const f3D37_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f3D37->then_instructions;

      body.emit(assign(r3D35, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f3D37->else_instructions;

      body.emit(assign(r3D36, body.constant(0u), 0x01));

      ir_expression *const r3D3B = bit_and(swizzle_y(r3D34), body.constant(2147483648u));
      body.emit(assign(r3D36, bit_or(r3D3B, body.constant(1072693248u)), 0x02));

      body.emit(assign(r3D35, r3D36, 0x03));


   body.instructions = f3D37_parent_instructions;
   body.emit(f3D37);

   /* END IF */

   body.emit(ret(r3D35));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
