ir_function_signature *
fabs64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000B);
   body.emit(assign(r000B, bit_and(swizzle_y(r000B), body.constant(2147483647u)), 0x02));

   body.emit(ret(r000B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
is_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000C);
   ir_expression *const r000D = lshift(swizzle_y(r000C), body.constant(int(1)));
   ir_expression *const r000E = lequal(body.constant(4292870144u), r000D);
   ir_expression *const r000F = nequal(swizzle_x(r000C), body.constant(0u));
   ir_expression *const r0010 = bit_and(swizzle_y(r000C), body.constant(1048575u));
   ir_expression *const r0011 = nequal(r0010, body.constant(0u));
   ir_expression *const r0012 = logic_or(r000F, r0011);
   ir_expression *const r0013 = logic_and(r000E, r0012);
   body.emit(ret(r0013));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fneg64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0014 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0014);
   ir_variable *const r0015 = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r0017 = lshift(swizzle_y(r0014), body.constant(int(1)));
   ir_expression *const r0018 = lequal(body.constant(4292870144u), r0017);
   ir_expression *const r0019 = nequal(swizzle_x(r0014), body.constant(0u));
   ir_expression *const r001A = bit_and(swizzle_y(r0014), body.constant(1048575u));
   ir_expression *const r001B = nequal(r001A, body.constant(0u));
   ir_expression *const r001C = logic_or(r0019, r001B);
   ir_expression *const r001D = logic_and(r0018, r001C);
   ir_if *f0016 = new(mem_ctx) ir_if(operand(r001D).val);
   exec_list *const f0016_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0016->then_instructions;

      body.emit(assign(r0015, r0014, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0016->else_instructions;

      body.emit(assign(r0014, bit_xor(swizzle_y(r0014), body.constant(2147483648u)), 0x02));

      body.emit(assign(r0015, r0014, 0x03));


   body.instructions = f0016_parent_instructions;
   body.emit(f0016);

   /* END IF */

   body.emit(ret(r0015));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64FracLo(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r001E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r001E);
   ir_swizzle *const r001F = swizzle_x(r001E);
   body.emit(ret(r001F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64FracHi(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0020 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0020);
   ir_expression *const r0021 = bit_and(swizzle_y(r0020), body.constant(1048575u));
   body.emit(ret(r0021));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0022 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0022);
   ir_expression *const r0023 = rshift(swizzle_y(r0022), body.constant(int(20)));
   ir_expression *const r0024 = bit_and(r0023, body.constant(2047u));
   ir_expression *const r0025 = expr(ir_unop_u2i, r0024);
   body.emit(ret(r0025));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
feq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0026 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0026);
   ir_variable *const r0027 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0027);
   ir_variable *const r0028 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0029 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0029);
   ir_variable *const r002A = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r002A);
   ir_expression *const r002B = rshift(swizzle_y(r0026), body.constant(int(20)));
   ir_expression *const r002C = bit_and(r002B, body.constant(2047u));
   ir_expression *const r002D = expr(ir_unop_u2i, r002C);
   ir_expression *const r002E = equal(r002D, body.constant(int(2047)));
   ir_expression *const r002F = bit_and(swizzle_y(r0026), body.constant(1048575u));
   ir_expression *const r0030 = bit_or(r002F, swizzle_x(r0026));
   ir_expression *const r0031 = nequal(r0030, body.constant(0u));
   body.emit(assign(r002A, logic_and(r002E, r0031), 0x01));

   ir_expression *const r0032 = rshift(swizzle_y(r0027), body.constant(int(20)));
   ir_expression *const r0033 = bit_and(r0032, body.constant(2047u));
   ir_expression *const r0034 = expr(ir_unop_u2i, r0033);
   ir_expression *const r0035 = equal(r0034, body.constant(int(2047)));
   ir_expression *const r0036 = bit_and(swizzle_y(r0027), body.constant(1048575u));
   ir_expression *const r0037 = bit_or(r0036, swizzle_x(r0027));
   ir_expression *const r0038 = nequal(r0037, body.constant(0u));
   body.emit(assign(r0029, logic_and(r0035, r0038), 0x01));

   /* IF CONDITION */
   ir_expression *const r003A = logic_or(r002A, r0029);
   ir_if *f0039 = new(mem_ctx) ir_if(operand(r003A).val);
   exec_list *const f0039_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0039->then_instructions;

      body.emit(assign(r0028, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0039->else_instructions;

      ir_expression *const r003B = equal(swizzle_x(r0026), swizzle_x(r0027));
      ir_expression *const r003C = equal(swizzle_y(r0026), swizzle_y(r0027));
      ir_expression *const r003D = equal(swizzle_x(r0026), body.constant(0u));
      ir_expression *const r003E = bit_or(swizzle_y(r0026), swizzle_y(r0027));
      ir_expression *const r003F = lshift(r003E, body.constant(int(1)));
      ir_expression *const r0040 = equal(r003F, body.constant(0u));
      ir_expression *const r0041 = logic_and(r003D, r0040);
      ir_expression *const r0042 = logic_or(r003C, r0041);
      body.emit(assign(r0028, logic_and(r003B, r0042), 0x01));


   body.instructions = f0039_parent_instructions;
   body.emit(f0039);

   /* END IF */

   body.emit(ret(r0028));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0043 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0043);
   ir_expression *const r0044 = rshift(swizzle_y(r0043), body.constant(int(31)));
   body.emit(ret(r0044));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
le64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0045 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0045);
   ir_variable *const r0046 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0046);
   ir_variable *const r0047 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r0047);
   ir_variable *const r0048 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r0048);
   ir_expression *const r0049 = less(r0045, r0047);
   ir_expression *const r004A = equal(r0045, r0047);
   ir_expression *const r004B = lequal(r0046, r0048);
   ir_expression *const r004C = logic_and(r004A, r004B);
   ir_expression *const r004D = logic_or(r0049, r004C);
   body.emit(ret(r004D));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fle64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r004E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r004E);
   ir_variable *const r004F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r004F);
   ir_variable *const r0050 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0051 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0051);
   ir_variable *const r0052 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0052);
   ir_expression *const r0053 = rshift(swizzle_y(r004E), body.constant(int(20)));
   ir_expression *const r0054 = bit_and(r0053, body.constant(2047u));
   ir_expression *const r0055 = expr(ir_unop_u2i, r0054);
   ir_expression *const r0056 = equal(r0055, body.constant(int(2047)));
   ir_expression *const r0057 = bit_and(swizzle_y(r004E), body.constant(1048575u));
   ir_expression *const r0058 = bit_or(r0057, swizzle_x(r004E));
   ir_expression *const r0059 = nequal(r0058, body.constant(0u));
   body.emit(assign(r0052, logic_and(r0056, r0059), 0x01));

   ir_expression *const r005A = rshift(swizzle_y(r004F), body.constant(int(20)));
   ir_expression *const r005B = bit_and(r005A, body.constant(2047u));
   ir_expression *const r005C = expr(ir_unop_u2i, r005B);
   ir_expression *const r005D = equal(r005C, body.constant(int(2047)));
   ir_expression *const r005E = bit_and(swizzle_y(r004F), body.constant(1048575u));
   ir_expression *const r005F = bit_or(r005E, swizzle_x(r004F));
   ir_expression *const r0060 = nequal(r005F, body.constant(0u));
   body.emit(assign(r0051, logic_and(r005D, r0060), 0x01));

   /* IF CONDITION */
   ir_expression *const r0062 = logic_or(r0052, r0051);
   ir_if *f0061 = new(mem_ctx) ir_if(operand(r0062).val);
   exec_list *const f0061_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0061->then_instructions;

      body.emit(assign(r0050, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0061->else_instructions;

      ir_variable *const r0063 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0063, rshift(swizzle_y(r004E), body.constant(int(31))), 0x01));

      ir_variable *const r0064 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0064, rshift(swizzle_y(r004F), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0066 = nequal(r0063, r0064);
      ir_if *f0065 = new(mem_ctx) ir_if(operand(r0066).val);
      exec_list *const f0065_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0065->then_instructions;

         ir_expression *const r0067 = nequal(r0063, body.constant(0u));
         ir_expression *const r0068 = bit_or(swizzle_y(r004E), swizzle_y(r004F));
         ir_expression *const r0069 = lshift(r0068, body.constant(int(1)));
         ir_expression *const r006A = bit_or(r0069, swizzle_x(r004E));
         ir_expression *const r006B = bit_or(r006A, swizzle_x(r004F));
         ir_expression *const r006C = equal(r006B, body.constant(0u));
         body.emit(assign(r0050, logic_or(r0067, r006C), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0065->else_instructions;

         ir_variable *const r006D = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r006F = nequal(r0063, body.constant(0u));
         ir_if *f006E = new(mem_ctx) ir_if(operand(r006F).val);
         exec_list *const f006E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f006E->then_instructions;

            ir_expression *const r0070 = less(swizzle_y(r004F), swizzle_y(r004E));
            ir_expression *const r0071 = equal(swizzle_y(r004F), swizzle_y(r004E));
            ir_expression *const r0072 = lequal(swizzle_x(r004F), swizzle_x(r004E));
            ir_expression *const r0073 = logic_and(r0071, r0072);
            body.emit(assign(r006D, logic_or(r0070, r0073), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f006E->else_instructions;

            ir_expression *const r0074 = less(swizzle_y(r004E), swizzle_y(r004F));
            ir_expression *const r0075 = equal(swizzle_y(r004E), swizzle_y(r004F));
            ir_expression *const r0076 = lequal(swizzle_x(r004E), swizzle_x(r004F));
            ir_expression *const r0077 = logic_and(r0075, r0076);
            body.emit(assign(r006D, logic_or(r0074, r0077), 0x01));


         body.instructions = f006E_parent_instructions;
         body.emit(f006E);

         /* END IF */

         body.emit(assign(r0050, r006D, 0x01));


      body.instructions = f0065_parent_instructions;
      body.emit(f0065);

      /* END IF */


   body.instructions = f0061_parent_instructions;
   body.emit(f0061);

   /* END IF */

   body.emit(ret(r0050));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
lt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0078 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0078);
   ir_variable *const r0079 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0079);
   ir_variable *const r007A = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r007A);
   ir_variable *const r007B = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r007B);
   ir_expression *const r007C = less(r0078, r007A);
   ir_expression *const r007D = equal(r0078, r007A);
   ir_expression *const r007E = less(r0079, r007B);
   ir_expression *const r007F = logic_and(r007D, r007E);
   ir_expression *const r0080 = logic_or(r007C, r007F);
   body.emit(ret(r0080));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
flt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0081 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0081);
   ir_variable *const r0082 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0082);
   ir_variable *const r0083 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0084 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0084);
   ir_variable *const r0085 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0085);
   ir_expression *const r0086 = rshift(swizzle_y(r0081), body.constant(int(20)));
   ir_expression *const r0087 = bit_and(r0086, body.constant(2047u));
   ir_expression *const r0088 = expr(ir_unop_u2i, r0087);
   ir_expression *const r0089 = equal(r0088, body.constant(int(2047)));
   ir_expression *const r008A = bit_and(swizzle_y(r0081), body.constant(1048575u));
   ir_expression *const r008B = bit_or(r008A, swizzle_x(r0081));
   ir_expression *const r008C = nequal(r008B, body.constant(0u));
   body.emit(assign(r0085, logic_and(r0089, r008C), 0x01));

   ir_expression *const r008D = rshift(swizzle_y(r0082), body.constant(int(20)));
   ir_expression *const r008E = bit_and(r008D, body.constant(2047u));
   ir_expression *const r008F = expr(ir_unop_u2i, r008E);
   ir_expression *const r0090 = equal(r008F, body.constant(int(2047)));
   ir_expression *const r0091 = bit_and(swizzle_y(r0082), body.constant(1048575u));
   ir_expression *const r0092 = bit_or(r0091, swizzle_x(r0082));
   ir_expression *const r0093 = nequal(r0092, body.constant(0u));
   body.emit(assign(r0084, logic_and(r0090, r0093), 0x01));

   /* IF CONDITION */
   ir_expression *const r0095 = logic_or(r0085, r0084);
   ir_if *f0094 = new(mem_ctx) ir_if(operand(r0095).val);
   exec_list *const f0094_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0094->then_instructions;

      body.emit(assign(r0083, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0094->else_instructions;

      ir_variable *const r0096 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0096, rshift(swizzle_y(r0081), body.constant(int(31))), 0x01));

      ir_variable *const r0097 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0097, rshift(swizzle_y(r0082), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0099 = nequal(r0096, r0097);
      ir_if *f0098 = new(mem_ctx) ir_if(operand(r0099).val);
      exec_list *const f0098_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0098->then_instructions;

         ir_expression *const r009A = nequal(r0096, body.constant(0u));
         ir_expression *const r009B = bit_or(swizzle_y(r0081), swizzle_y(r0082));
         ir_expression *const r009C = lshift(r009B, body.constant(int(1)));
         ir_expression *const r009D = bit_or(r009C, swizzle_x(r0081));
         ir_expression *const r009E = bit_or(r009D, swizzle_x(r0082));
         ir_expression *const r009F = nequal(r009E, body.constant(0u));
         body.emit(assign(r0083, logic_and(r009A, r009F), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0098->else_instructions;

         ir_variable *const r00A0 = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r00A2 = nequal(r0096, body.constant(0u));
         ir_if *f00A1 = new(mem_ctx) ir_if(operand(r00A2).val);
         exec_list *const f00A1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f00A1->then_instructions;

            ir_expression *const r00A3 = less(swizzle_y(r0082), swizzle_y(r0081));
            ir_expression *const r00A4 = equal(swizzle_y(r0082), swizzle_y(r0081));
            ir_expression *const r00A5 = less(swizzle_x(r0082), swizzle_x(r0081));
            ir_expression *const r00A6 = logic_and(r00A4, r00A5);
            body.emit(assign(r00A0, logic_or(r00A3, r00A6), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f00A1->else_instructions;

            ir_expression *const r00A7 = less(swizzle_y(r0081), swizzle_y(r0082));
            ir_expression *const r00A8 = equal(swizzle_y(r0081), swizzle_y(r0082));
            ir_expression *const r00A9 = less(swizzle_x(r0081), swizzle_x(r0082));
            ir_expression *const r00AA = logic_and(r00A8, r00A9);
            body.emit(assign(r00A0, logic_or(r00A7, r00AA), 0x01));


         body.instructions = f00A1_parent_instructions;
         body.emit(f00A1);

         /* END IF */

         body.emit(assign(r0083, r00A0, 0x01));


      body.instructions = f0098_parent_instructions;
      body.emit(f0098);

      /* END IF */


   body.instructions = f0094_parent_instructions;
   body.emit(f0094);

   /* END IF */

   body.emit(ret(r0083));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00AB);
   ir_variable *const r00AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00AC);
   ir_variable *const r00AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00AD);
   ir_variable *const r00AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00AE);
   ir_variable *const r00AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00AF);
   ir_variable *const r00B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00B0);
   ir_variable *const r00B1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r00B1, add(r00AC, r00AE), 0x01));

   body.emit(assign(r00B0, r00B1, 0x01));

   ir_expression *const r00B2 = add(r00AB, r00AD);
   ir_expression *const r00B3 = less(r00B1, r00AC);
   ir_expression *const r00B4 = expr(ir_unop_b2i, r00B3);
   ir_expression *const r00B5 = expr(ir_unop_i2u, r00B4);
   body.emit(assign(r00AF, add(r00B2, r00B5), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00B6);
   ir_variable *const r00B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00B7);
   ir_variable *const r00B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00B8);
   ir_variable *const r00B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00B9);
   ir_variable *const r00BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00BA);
   ir_variable *const r00BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00BB);
   body.emit(assign(r00BB, sub(r00B7, r00B9), 0x01));

   ir_expression *const r00BC = sub(r00B6, r00B8);
   ir_expression *const r00BD = less(r00B7, r00B9);
   ir_expression *const r00BE = expr(ir_unop_b2i, r00BD);
   ir_expression *const r00BF = expr(ir_unop_i2u, r00BE);
   body.emit(assign(r00BA, sub(r00BC, r00BF), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
eq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00C0);
   ir_variable *const r00C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00C1);
   ir_variable *const r00C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00C2);
   ir_variable *const r00C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00C3);
   ir_expression *const r00C4 = equal(r00C0, r00C2);
   ir_expression *const r00C5 = equal(r00C1, r00C3);
   ir_expression *const r00C6 = logic_and(r00C4, r00C5);
   body.emit(ret(r00C6));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
float64_is_signaling_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00C7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r00C7);
   ir_expression *const r00C8 = rshift(swizzle_y(r00C7), body.constant(int(19)));
   ir_expression *const r00C9 = bit_and(r00C8, body.constant(4095u));
   ir_expression *const r00CA = equal(r00C9, body.constant(4094u));
   ir_expression *const r00CB = nequal(swizzle_x(r00C7), body.constant(0u));
   ir_expression *const r00CC = bit_and(swizzle_y(r00C7), body.constant(524287u));
   ir_expression *const r00CD = nequal(r00CC, body.constant(0u));
   ir_expression *const r00CE = logic_or(r00CB, r00CD);
   ir_expression *const r00CF = logic_and(r00CA, r00CE);
   body.emit(ret(r00CF));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00D0);
   ir_variable *const r00D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00D1);
   ir_variable *const r00D2 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00D2);
   ir_variable *const r00D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D3);
   ir_variable *const r00D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D4);
   ir_variable *const r00D5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00D5);
   ir_variable *const r00D6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00D6);
   ir_variable *const r00D7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r00D8 = neg(r00D2);
   body.emit(assign(r00D7, bit_and(r00D8, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r00DA = equal(r00D2, body.constant(int(0)));
   ir_if *f00D9 = new(mem_ctx) ir_if(operand(r00DA).val);
   exec_list *const f00D9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f00D9->then_instructions;

      body.emit(assign(r00D5, r00D1, 0x01));

      body.emit(assign(r00D6, r00D0, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f00D9->else_instructions;

      /* IF CONDITION */
      ir_expression *const r00DC = less(r00D2, body.constant(int(32)));
      ir_if *f00DB = new(mem_ctx) ir_if(operand(r00DC).val);
      exec_list *const f00DB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f00DB->then_instructions;

         ir_expression *const r00DD = lshift(r00D0, r00D7);
         ir_expression *const r00DE = rshift(r00D1, r00D2);
         ir_expression *const r00DF = bit_or(r00DD, r00DE);
         ir_expression *const r00E0 = lshift(r00D1, r00D7);
         ir_expression *const r00E1 = nequal(r00E0, body.constant(0u));
         ir_expression *const r00E2 = expr(ir_unop_b2i, r00E1);
         ir_expression *const r00E3 = expr(ir_unop_i2u, r00E2);
         body.emit(assign(r00D5, bit_or(r00DF, r00E3), 0x01));

         body.emit(assign(r00D6, rshift(r00D0, r00D2), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f00DB->else_instructions;

         /* IF CONDITION */
         ir_expression *const r00E5 = equal(r00D2, body.constant(int(32)));
         ir_if *f00E4 = new(mem_ctx) ir_if(operand(r00E5).val);
         exec_list *const f00E4_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f00E4->then_instructions;

            ir_expression *const r00E6 = nequal(r00D1, body.constant(0u));
            ir_expression *const r00E7 = expr(ir_unop_b2i, r00E6);
            ir_expression *const r00E8 = expr(ir_unop_i2u, r00E7);
            body.emit(assign(r00D5, bit_or(r00D0, r00E8), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f00E4->else_instructions;

            /* IF CONDITION */
            ir_expression *const r00EA = less(r00D2, body.constant(int(64)));
            ir_if *f00E9 = new(mem_ctx) ir_if(operand(r00EA).val);
            exec_list *const f00E9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f00E9->then_instructions;

               ir_expression *const r00EB = bit_and(r00D2, body.constant(int(31)));
               ir_expression *const r00EC = rshift(r00D0, r00EB);
               ir_expression *const r00ED = lshift(r00D0, r00D7);
               ir_expression *const r00EE = bit_or(r00ED, r00D1);
               ir_expression *const r00EF = nequal(r00EE, body.constant(0u));
               ir_expression *const r00F0 = expr(ir_unop_b2i, r00EF);
               ir_expression *const r00F1 = expr(ir_unop_i2u, r00F0);
               body.emit(assign(r00D5, bit_or(r00EC, r00F1), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f00E9->else_instructions;

               ir_expression *const r00F2 = bit_or(r00D0, r00D1);
               ir_expression *const r00F3 = nequal(r00F2, body.constant(0u));
               ir_expression *const r00F4 = expr(ir_unop_b2i, r00F3);
               body.emit(assign(r00D5, expr(ir_unop_i2u, r00F4), 0x01));


            body.instructions = f00E9_parent_instructions;
            body.emit(f00E9);

            /* END IF */


         body.instructions = f00E4_parent_instructions;
         body.emit(f00E4);

         /* END IF */

         body.emit(assign(r00D6, body.constant(0u), 0x01));


      body.instructions = f00DB_parent_instructions;
      body.emit(f00DB);

      /* END IF */


   body.instructions = f00D9_parent_instructions;
   body.emit(f00D9);

   /* END IF */

   body.emit(assign(r00D4, r00D5, 0x01));

   body.emit(assign(r00D3, r00D6, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64ExtraRightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00F5);
   ir_variable *const r00F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00F6);
   ir_variable *const r00F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r00F7);
   ir_variable *const r00F8 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00F8);
   ir_variable *const r00F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00F9);
   ir_variable *const r00FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00FA);
   ir_variable *const r00FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00FB);
   ir_variable *const r00FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
   body.emit(r00FC);
   ir_variable *const r00FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00FD);
   ir_variable *const r00FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00FE);
   ir_variable *const r00FF = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r0100 = neg(r00F8);
   body.emit(assign(r00FF, bit_and(r0100, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0102 = equal(r00F8, body.constant(int(0)));
   ir_if *f0101 = new(mem_ctx) ir_if(operand(r0102).val);
   exec_list *const f0101_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0101->then_instructions;

      body.emit(assign(r00FC, r00F7, 0x01));

      body.emit(assign(r00FD, r00F6, 0x01));

      body.emit(assign(r00FE, r00F5, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0101->else_instructions;

      /* IF CONDITION */
      ir_expression *const r0104 = less(r00F8, body.constant(int(32)));
      ir_if *f0103 = new(mem_ctx) ir_if(operand(r0104).val);
      exec_list *const f0103_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0103->then_instructions;

         body.emit(assign(r00FC, lshift(r00F6, r00FF), 0x01));

         ir_expression *const r0105 = lshift(r00F5, r00FF);
         ir_expression *const r0106 = rshift(r00F6, r00F8);
         body.emit(assign(r00FD, bit_or(r0105, r0106), 0x01));

         body.emit(assign(r00FE, rshift(r00F5, r00F8), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0103->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0108 = equal(r00F8, body.constant(int(32)));
         ir_if *f0107 = new(mem_ctx) ir_if(operand(r0108).val);
         exec_list *const f0107_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0107->then_instructions;

            body.emit(assign(r00FC, r00F6, 0x01));

            body.emit(assign(r00FD, r00F5, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0107->else_instructions;

            body.emit(assign(r00F7, bit_or(r00F7, r00F6), 0x01));

            /* IF CONDITION */
            ir_expression *const r010A = less(r00F8, body.constant(int(64)));
            ir_if *f0109 = new(mem_ctx) ir_if(operand(r010A).val);
            exec_list *const f0109_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0109->then_instructions;

               body.emit(assign(r00FC, lshift(r00F5, r00FF), 0x01));

               ir_expression *const r010B = bit_and(r00F8, body.constant(int(31)));
               body.emit(assign(r00FD, rshift(r00F5, r010B), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0109->else_instructions;

               ir_variable *const r010C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r010E = equal(r00F8, body.constant(int(64)));
               ir_if *f010D = new(mem_ctx) ir_if(operand(r010E).val);
               exec_list *const f010D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f010D->then_instructions;

                  body.emit(assign(r010C, r00F5, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f010D->else_instructions;

                  ir_expression *const r010F = nequal(r00F5, body.constant(0u));
                  ir_expression *const r0110 = expr(ir_unop_b2i, r010F);
                  body.emit(assign(r010C, expr(ir_unop_i2u, r0110), 0x01));


               body.instructions = f010D_parent_instructions;
               body.emit(f010D);

               /* END IF */

               body.emit(assign(r00FC, r010C, 0x01));

               body.emit(assign(r00FD, body.constant(0u), 0x01));


            body.instructions = f0109_parent_instructions;
            body.emit(f0109);

            /* END IF */


         body.instructions = f0107_parent_instructions;
         body.emit(f0107);

         /* END IF */

         body.emit(assign(r00FE, body.constant(0u), 0x01));


      body.instructions = f0103_parent_instructions;
      body.emit(f0103);

      /* END IF */

      ir_expression *const r0111 = nequal(r00F7, body.constant(0u));
      ir_expression *const r0112 = expr(ir_unop_b2i, r0111);
      ir_expression *const r0113 = expr(ir_unop_i2u, r0112);
      body.emit(assign(r00FC, bit_or(r00FC, r0113), 0x01));


   body.instructions = f0101_parent_instructions;
   body.emit(f0101);

   /* END IF */

   body.emit(assign(r00FB, r00FC, 0x01));

   body.emit(assign(r00FA, r00FD, 0x01));

   body.emit(assign(r00F9, r00FE, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shortShift64Left(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0114 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0114);
   ir_variable *const r0115 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0115);
   ir_variable *const r0116 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r0116);
   ir_variable *const r0117 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0117);
   ir_variable *const r0118 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0118);
   body.emit(assign(r0118, lshift(r0115, r0116), 0x01));

   ir_variable *const r0119 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   /* IF CONDITION */
   ir_expression *const r011B = equal(r0116, body.constant(int(0)));
   ir_if *f011A = new(mem_ctx) ir_if(operand(r011B).val);
   exec_list *const f011A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f011A->then_instructions;

      body.emit(assign(r0119, r0114, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f011A->else_instructions;

      ir_expression *const r011C = lshift(r0114, r0116);
      ir_expression *const r011D = neg(r0116);
      ir_expression *const r011E = bit_and(r011D, body.constant(int(31)));
      ir_expression *const r011F = rshift(r0115, r011E);
      body.emit(assign(r0119, bit_or(r011C, r011F), 0x01));


   body.instructions = f011A_parent_instructions;
   body.emit(f011A);

   /* END IF */

   body.emit(assign(r0117, r0119, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0120 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0120);
   ir_variable *const r0121 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0121);
   ir_variable *const r0122 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0122);
   ir_variable *const r0123 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0123);
   ir_variable *const r0124 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
   body.emit(r0124);
   ir_expression *const r0125 = lshift(r0120, body.constant(int(31)));
   ir_expression *const r0126 = expr(ir_unop_i2u, r0121);
   ir_expression *const r0127 = lshift(r0126, body.constant(int(20)));
   ir_expression *const r0128 = add(r0125, r0127);
   body.emit(assign(r0124, add(r0128, r0122), 0x02));

   body.emit(assign(r0124, r0123, 0x01));

   body.emit(ret(r0124));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0129 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0129);
   ir_variable *const r012A = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r012A);
   ir_variable *const r012B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r012B);
   ir_variable *const r012C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r012C);
   ir_variable *const r012D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_function_in);
   sig_parameters.push_tail(r012D);
   ir_variable *const r012E = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r012E, body.constant(true), 0x01));

   ir_variable *const r012F = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0130 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r0130);
   ir_expression *const r0131 = expr(ir_unop_u2i, r012D);
   body.emit(assign(r0130, less(r0131, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0133 = lequal(body.constant(int(2045)), r012A);
   ir_if *f0132 = new(mem_ctx) ir_if(operand(r0133).val);
   exec_list *const f0132_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0132->then_instructions;

      ir_variable *const r0134 = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r0136 = less(body.constant(int(2045)), r012A);
      ir_if *f0135 = new(mem_ctx) ir_if(operand(r0136).val);
      exec_list *const f0135_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0135->then_instructions;

         body.emit(assign(r0134, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0135->else_instructions;

         ir_variable *const r0137 = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r0139 = equal(r012A, body.constant(int(2045)));
         ir_if *f0138 = new(mem_ctx) ir_if(operand(r0139).val);
         exec_list *const f0138_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0138->then_instructions;

            ir_expression *const r013A = equal(body.constant(2097151u), r012B);
            ir_expression *const r013B = equal(body.constant(4294967295u), r012C);
            body.emit(assign(r0137, logic_and(r013A, r013B), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0138->else_instructions;

            body.emit(assign(r0137, body.constant(false), 0x01));


         body.instructions = f0138_parent_instructions;
         body.emit(f0138);

         /* END IF */

         body.emit(assign(r0134, logic_and(r0137, r0130), 0x01));


      body.instructions = f0135_parent_instructions;
      body.emit(f0135);

      /* END IF */

      /* IF CONDITION */
      ir_if *f013C = new(mem_ctx) ir_if(operand(r0134).val);
      exec_list *const f013C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f013C->then_instructions;

         ir_variable *const r013D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r013D);
         ir_expression *const r013E = lshift(r0129, body.constant(int(31)));
         body.emit(assign(r013D, add(r013E, body.constant(2146435072u)), 0x02));

         body.emit(assign(r013D, body.constant(0u), 0x01));

         body.emit(assign(r012F, r013D, 0x03));

         body.emit(assign(r012E, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f013C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0140 = less(r012A, body.constant(int(0)));
         ir_if *f013F = new(mem_ctx) ir_if(operand(r0140).val);
         exec_list *const f013F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f013F->then_instructions;

            ir_variable *const r0141 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r0141, r012D, 0x01));

            ir_variable *const r0142 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r0142, neg(r012A), 0x01));

            ir_variable *const r0143 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r0143);
            ir_variable *const r0144 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0144);
            ir_variable *const r0145 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0145);
            ir_variable *const r0146 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0147 = neg(r0142);
            body.emit(assign(r0146, bit_and(r0147, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0149 = equal(r0142, body.constant(int(0)));
            ir_if *f0148 = new(mem_ctx) ir_if(operand(r0149).val);
            exec_list *const f0148_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0148->then_instructions;

               body.emit(assign(r0143, r012D, 0x01));

               body.emit(assign(r0144, r012C, 0x01));

               body.emit(assign(r0145, r012B, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0148->else_instructions;

               /* IF CONDITION */
               ir_expression *const r014B = less(r0142, body.constant(int(32)));
               ir_if *f014A = new(mem_ctx) ir_if(operand(r014B).val);
               exec_list *const f014A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f014A->then_instructions;

                  body.emit(assign(r0143, lshift(r012C, r0146), 0x01));

                  ir_expression *const r014C = lshift(r012B, r0146);
                  ir_expression *const r014D = rshift(r012C, r0142);
                  body.emit(assign(r0144, bit_or(r014C, r014D), 0x01));

                  body.emit(assign(r0145, rshift(r012B, r0142), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f014A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r014F = equal(r0142, body.constant(int(32)));
                  ir_if *f014E = new(mem_ctx) ir_if(operand(r014F).val);
                  exec_list *const f014E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f014E->then_instructions;

                     body.emit(assign(r0143, r012C, 0x01));

                     body.emit(assign(r0144, r012B, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f014E->else_instructions;

                     body.emit(assign(r0141, bit_or(r012D, r012C), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0151 = less(r0142, body.constant(int(64)));
                     ir_if *f0150 = new(mem_ctx) ir_if(operand(r0151).val);
                     exec_list *const f0150_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0150->then_instructions;

                        body.emit(assign(r0143, lshift(r012B, r0146), 0x01));

                        ir_expression *const r0152 = bit_and(r0142, body.constant(int(31)));
                        body.emit(assign(r0144, rshift(r012B, r0152), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0150->else_instructions;

                        ir_variable *const r0153 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0155 = equal(r0142, body.constant(int(64)));
                        ir_if *f0154 = new(mem_ctx) ir_if(operand(r0155).val);
                        exec_list *const f0154_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0154->then_instructions;

                           body.emit(assign(r0153, r012B, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0154->else_instructions;

                           ir_expression *const r0156 = nequal(r012B, body.constant(0u));
                           ir_expression *const r0157 = expr(ir_unop_b2i, r0156);
                           body.emit(assign(r0153, expr(ir_unop_i2u, r0157), 0x01));


                        body.instructions = f0154_parent_instructions;
                        body.emit(f0154);

                        /* END IF */

                        body.emit(assign(r0143, r0153, 0x01));

                        body.emit(assign(r0144, body.constant(0u), 0x01));


                     body.instructions = f0150_parent_instructions;
                     body.emit(f0150);

                     /* END IF */


                  body.instructions = f014E_parent_instructions;
                  body.emit(f014E);

                  /* END IF */

                  body.emit(assign(r0145, body.constant(0u), 0x01));


               body.instructions = f014A_parent_instructions;
               body.emit(f014A);

               /* END IF */

               ir_expression *const r0158 = nequal(r0141, body.constant(0u));
               ir_expression *const r0159 = expr(ir_unop_b2i, r0158);
               ir_expression *const r015A = expr(ir_unop_i2u, r0159);
               body.emit(assign(r0143, bit_or(r0143, r015A), 0x01));


            body.instructions = f0148_parent_instructions;
            body.emit(f0148);

            /* END IF */

            body.emit(assign(r012B, r0145, 0x01));

            body.emit(assign(r012C, r0144, 0x01));

            body.emit(assign(r012D, r0143, 0x01));

            body.emit(assign(r012A, body.constant(int(0)), 0x01));

            body.emit(assign(r0130, less(r0143, body.constant(0u)), 0x01));


         body.instructions = f013F_parent_instructions;
         body.emit(f013F);

         /* END IF */


      body.instructions = f013C_parent_instructions;
      body.emit(f013C);

      /* END IF */


   body.instructions = f0132_parent_instructions;
   body.emit(f0132);

   /* END IF */

   /* IF CONDITION */
   ir_if *f015B = new(mem_ctx) ir_if(operand(r012E).val);
   exec_list *const f015B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f015B->then_instructions;

      /* IF CONDITION */
      ir_if *f015C = new(mem_ctx) ir_if(operand(r0130).val);
      exec_list *const f015C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f015C->then_instructions;

         ir_variable *const r015D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r015D, add(r012C, body.constant(1u)), 0x01));

         ir_expression *const r015E = less(r015D, r012C);
         ir_expression *const r015F = expr(ir_unop_b2i, r015E);
         ir_expression *const r0160 = expr(ir_unop_i2u, r015F);
         body.emit(assign(r012B, add(r012B, r0160), 0x01));

         ir_expression *const r0161 = equal(r012D, body.constant(0u));
         ir_expression *const r0162 = expr(ir_unop_b2i, r0161);
         ir_expression *const r0163 = expr(ir_unop_i2u, r0162);
         ir_expression *const r0164 = add(r012D, r0163);
         ir_expression *const r0165 = bit_and(r0164, body.constant(1u));
         ir_expression *const r0166 = expr(ir_unop_bit_not, r0165);
         body.emit(assign(r012C, bit_and(r015D, r0166), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f015C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0168 = bit_or(r012B, r012C);
         ir_expression *const r0169 = equal(r0168, body.constant(0u));
         ir_if *f0167 = new(mem_ctx) ir_if(operand(r0169).val);
         exec_list *const f0167_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0167->then_instructions;

            body.emit(assign(r012A, body.constant(int(0)), 0x01));


         body.instructions = f0167_parent_instructions;
         body.emit(f0167);

         /* END IF */


      body.instructions = f015C_parent_instructions;
      body.emit(f015C);

      /* END IF */

      ir_variable *const r016A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r016A);
      ir_expression *const r016B = lshift(r0129, body.constant(int(31)));
      ir_expression *const r016C = expr(ir_unop_i2u, r012A);
      ir_expression *const r016D = lshift(r016C, body.constant(int(20)));
      ir_expression *const r016E = add(r016B, r016D);
      body.emit(assign(r016A, add(r016E, r012B), 0x02));

      body.emit(assign(r016A, r012C, 0x01));

      body.emit(assign(r012F, r016A, 0x03));

      body.emit(assign(r012E, body.constant(false), 0x01));


   body.instructions = f015B_parent_instructions;
   body.emit(f015B);

   /* END IF */

   body.emit(ret(r012F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
countLeadingZeros32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r016F = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r016F);
   ir_variable *const r0170 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r0171 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r0171);
   /* IF CONDITION */
   ir_expression *const r0173 = equal(r016F, body.constant(0u));
   ir_if *f0172 = new(mem_ctx) ir_if(operand(r0173).val);
   exec_list *const f0172_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0172->then_instructions;

      body.emit(assign(r0170, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0172->else_instructions;

      body.emit(assign(r0171, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r0175 = bit_and(r016F, body.constant(4294901760u));
      ir_expression *const r0176 = equal(r0175, body.constant(0u));
      ir_if *f0174 = new(mem_ctx) ir_if(operand(r0176).val);
      exec_list *const f0174_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0174->then_instructions;

         body.emit(assign(r0171, body.constant(int(16)), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(16))), 0x01));


      body.instructions = f0174_parent_instructions;
      body.emit(f0174);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0178 = bit_and(r016F, body.constant(4278190080u));
      ir_expression *const r0179 = equal(r0178, body.constant(0u));
      ir_if *f0177 = new(mem_ctx) ir_if(operand(r0179).val);
      exec_list *const f0177_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0177->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(8))), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(8))), 0x01));


      body.instructions = f0177_parent_instructions;
      body.emit(f0177);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017B = bit_and(r016F, body.constant(4026531840u));
      ir_expression *const r017C = equal(r017B, body.constant(0u));
      ir_if *f017A = new(mem_ctx) ir_if(operand(r017C).val);
      exec_list *const f017A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017A->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(4))), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(4))), 0x01));


      body.instructions = f017A_parent_instructions;
      body.emit(f017A);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017E = bit_and(r016F, body.constant(3221225472u));
      ir_expression *const r017F = equal(r017E, body.constant(0u));
      ir_if *f017D = new(mem_ctx) ir_if(operand(r017F).val);
      exec_list *const f017D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017D->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(2))), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(2))), 0x01));


      body.instructions = f017D_parent_instructions;
      body.emit(f017D);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0181 = bit_and(r016F, body.constant(2147483648u));
      ir_expression *const r0182 = equal(r0181, body.constant(0u));
      ir_if *f0180 = new(mem_ctx) ir_if(operand(r0182).val);
      exec_list *const f0180_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0180->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(1))), 0x01));


      body.instructions = f0180_parent_instructions;
      body.emit(f0180);

      /* END IF */

      body.emit(assign(r0170, r0171, 0x01));


   body.instructions = f0172_parent_instructions;
   body.emit(f0172);

   /* END IF */

   body.emit(ret(r0170));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeRoundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0183 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0183);
   ir_variable *const r0184 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0184);
   ir_variable *const r0185 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0185);
   ir_variable *const r0186 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0186);
   ir_variable *const r0187 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r0187);
   ir_variable *const r0188 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r0188);
   /* IF CONDITION */
   ir_expression *const r018A = equal(r0185, body.constant(0u));
   ir_if *f0189 = new(mem_ctx) ir_if(operand(r018A).val);
   exec_list *const f0189_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0189->then_instructions;

      body.emit(assign(r0185, r0186, 0x01));

      body.emit(assign(r0186, body.constant(0u), 0x01));

      body.emit(assign(r0184, add(r0184, body.constant(int(-32))), 0x01));


   body.instructions = f0189_parent_instructions;
   body.emit(f0189);

   /* END IF */

   ir_variable *const r018B = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r018B, r0185, 0x01));

   ir_variable *const r018C = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r018D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r018D);
   /* IF CONDITION */
   ir_expression *const r018F = equal(r0185, body.constant(0u));
   ir_if *f018E = new(mem_ctx) ir_if(operand(r018F).val);
   exec_list *const f018E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f018E->then_instructions;

      body.emit(assign(r018C, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f018E->else_instructions;

      body.emit(assign(r018D, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r0191 = bit_and(r0185, body.constant(4294901760u));
      ir_expression *const r0192 = equal(r0191, body.constant(0u));
      ir_if *f0190 = new(mem_ctx) ir_if(operand(r0192).val);
      exec_list *const f0190_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0190->then_instructions;

         body.emit(assign(r018D, body.constant(int(16)), 0x01));

         body.emit(assign(r018B, lshift(r0185, body.constant(int(16))), 0x01));


      body.instructions = f0190_parent_instructions;
      body.emit(f0190);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0194 = bit_and(r018B, body.constant(4278190080u));
      ir_expression *const r0195 = equal(r0194, body.constant(0u));
      ir_if *f0193 = new(mem_ctx) ir_if(operand(r0195).val);
      exec_list *const f0193_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0193->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(8))), 0x01));

         body.emit(assign(r018B, lshift(r018B, body.constant(int(8))), 0x01));


      body.instructions = f0193_parent_instructions;
      body.emit(f0193);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0197 = bit_and(r018B, body.constant(4026531840u));
      ir_expression *const r0198 = equal(r0197, body.constant(0u));
      ir_if *f0196 = new(mem_ctx) ir_if(operand(r0198).val);
      exec_list *const f0196_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0196->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(4))), 0x01));

         body.emit(assign(r018B, lshift(r018B, body.constant(int(4))), 0x01));


      body.instructions = f0196_parent_instructions;
      body.emit(f0196);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r019A = bit_and(r018B, body.constant(3221225472u));
      ir_expression *const r019B = equal(r019A, body.constant(0u));
      ir_if *f0199 = new(mem_ctx) ir_if(operand(r019B).val);
      exec_list *const f0199_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0199->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(2))), 0x01));

         body.emit(assign(r018B, lshift(r018B, body.constant(int(2))), 0x01));


      body.instructions = f0199_parent_instructions;
      body.emit(f0199);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r019D = bit_and(r018B, body.constant(2147483648u));
      ir_expression *const r019E = equal(r019D, body.constant(0u));
      ir_if *f019C = new(mem_ctx) ir_if(operand(r019E).val);
      exec_list *const f019C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f019C->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(1))), 0x01));


      body.instructions = f019C_parent_instructions;
      body.emit(f019C);

      /* END IF */

      body.emit(assign(r018C, r018D, 0x01));


   body.instructions = f018E_parent_instructions;
   body.emit(f018E);

   /* END IF */

   body.emit(assign(r0188, add(r018C, body.constant(int(-11))), 0x01));

   /* IF CONDITION */
   ir_expression *const r01A0 = lequal(body.constant(int(0)), r0188);
   ir_if *f019F = new(mem_ctx) ir_if(operand(r01A0).val);
   exec_list *const f019F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f019F->then_instructions;

      body.emit(assign(r0187, body.constant(0u), 0x01));

      ir_variable *const r01A1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r01A1, lshift(r0186, r0188), 0x01));

      ir_variable *const r01A2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r01A4 = equal(r0188, body.constant(int(0)));
      ir_if *f01A3 = new(mem_ctx) ir_if(operand(r01A4).val);
      exec_list *const f01A3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01A3->then_instructions;

         body.emit(assign(r01A2, r0185, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01A3->else_instructions;

         ir_expression *const r01A5 = lshift(r0185, r0188);
         ir_expression *const r01A6 = neg(r0188);
         ir_expression *const r01A7 = bit_and(r01A6, body.constant(int(31)));
         ir_expression *const r01A8 = rshift(r0186, r01A7);
         body.emit(assign(r01A2, bit_or(r01A5, r01A8), 0x01));


      body.instructions = f01A3_parent_instructions;
      body.emit(f01A3);

      /* END IF */

      body.emit(assign(r0185, r01A2, 0x01));

      body.emit(assign(r0186, r01A1, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f019F->else_instructions;

      ir_variable *const r01A9 = body.make_temp(glsl_type::uint_type, "a2");
      body.emit(assign(r01A9, body.constant(0u), 0x01));

      ir_variable *const r01AA = body.make_temp(glsl_type::int_type, "count");
      body.emit(assign(r01AA, neg(r0188), 0x01));

      ir_variable *const r01AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
      body.emit(r01AB);
      ir_variable *const r01AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r01AC);
      ir_variable *const r01AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r01AD);
      ir_variable *const r01AE = body.make_temp(glsl_type::int_type, "assignment_tmp");
      ir_expression *const r01AF = neg(r01AA);
      body.emit(assign(r01AE, bit_and(r01AF, body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r01B1 = equal(r01AA, body.constant(int(0)));
      ir_if *f01B0 = new(mem_ctx) ir_if(operand(r01B1).val);
      exec_list *const f01B0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01B0->then_instructions;

         body.emit(assign(r01AB, r01A9, 0x01));

         body.emit(assign(r01AC, r0186, 0x01));

         body.emit(assign(r01AD, r0185, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01B0->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01B3 = less(r01AA, body.constant(int(32)));
         ir_if *f01B2 = new(mem_ctx) ir_if(operand(r01B3).val);
         exec_list *const f01B2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01B2->then_instructions;

            body.emit(assign(r01AB, lshift(r0186, r01AE), 0x01));

            ir_expression *const r01B4 = lshift(r0185, r01AE);
            ir_expression *const r01B5 = rshift(r0186, r01AA);
            body.emit(assign(r01AC, bit_or(r01B4, r01B5), 0x01));

            body.emit(assign(r01AD, rshift(r0185, r01AA), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01B2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r01B7 = equal(r01AA, body.constant(int(32)));
            ir_if *f01B6 = new(mem_ctx) ir_if(operand(r01B7).val);
            exec_list *const f01B6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01B6->then_instructions;

               body.emit(assign(r01AB, r0186, 0x01));

               body.emit(assign(r01AC, r0185, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01B6->else_instructions;

               body.emit(assign(r01A9, bit_or(body.constant(0u), r0186), 0x01));

               /* IF CONDITION */
               ir_expression *const r01B9 = less(r01AA, body.constant(int(64)));
               ir_if *f01B8 = new(mem_ctx) ir_if(operand(r01B9).val);
               exec_list *const f01B8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01B8->then_instructions;

                  body.emit(assign(r01AB, lshift(r0185, r01AE), 0x01));

                  ir_expression *const r01BA = bit_and(r01AA, body.constant(int(31)));
                  body.emit(assign(r01AC, rshift(r0185, r01BA), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01B8->else_instructions;

                  ir_variable *const r01BB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r01BD = equal(r01AA, body.constant(int(64)));
                  ir_if *f01BC = new(mem_ctx) ir_if(operand(r01BD).val);
                  exec_list *const f01BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01BC->then_instructions;

                     body.emit(assign(r01BB, r0185, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01BC->else_instructions;

                     ir_expression *const r01BE = nequal(r0185, body.constant(0u));
                     ir_expression *const r01BF = expr(ir_unop_b2i, r01BE);
                     body.emit(assign(r01BB, expr(ir_unop_i2u, r01BF), 0x01));


                  body.instructions = f01BC_parent_instructions;
                  body.emit(f01BC);

                  /* END IF */

                  body.emit(assign(r01AB, r01BB, 0x01));

                  body.emit(assign(r01AC, body.constant(0u), 0x01));


               body.instructions = f01B8_parent_instructions;
               body.emit(f01B8);

               /* END IF */


            body.instructions = f01B6_parent_instructions;
            body.emit(f01B6);

            /* END IF */

            body.emit(assign(r01AD, body.constant(0u), 0x01));


         body.instructions = f01B2_parent_instructions;
         body.emit(f01B2);

         /* END IF */

         ir_expression *const r01C0 = nequal(r01A9, body.constant(0u));
         ir_expression *const r01C1 = expr(ir_unop_b2i, r01C0);
         ir_expression *const r01C2 = expr(ir_unop_i2u, r01C1);
         body.emit(assign(r01AB, bit_or(r01AB, r01C2), 0x01));


      body.instructions = f01B0_parent_instructions;
      body.emit(f01B0);

      /* END IF */

      body.emit(assign(r0185, r01AD, 0x01));

      body.emit(assign(r0186, r01AC, 0x01));

      body.emit(assign(r0187, r01AB, 0x01));


   body.instructions = f019F_parent_instructions;
   body.emit(f019F);

   /* END IF */

   body.emit(assign(r0184, sub(r0184, r0188), 0x01));

   ir_variable *const r01C3 = body.make_temp(glsl_type::int_type, "zExp");
   body.emit(assign(r01C3, r0184, 0x01));

   ir_variable *const r01C4 = body.make_temp(glsl_type::uint_type, "zFrac0");
   body.emit(assign(r01C4, r0185, 0x01));

   ir_variable *const r01C5 = body.make_temp(glsl_type::uint_type, "zFrac1");
   body.emit(assign(r01C5, r0186, 0x01));

   ir_variable *const r01C6 = body.make_temp(glsl_type::uint_type, "zFrac2");
   body.emit(assign(r01C6, r0187, 0x01));

   ir_variable *const r01C7 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r01C7, body.constant(true), 0x01));

   ir_variable *const r01C8 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r01C9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r01C9);
   ir_expression *const r01CA = expr(ir_unop_u2i, r0187);
   body.emit(assign(r01C9, less(r01CA, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r01CC = lequal(body.constant(int(2045)), r0184);
   ir_if *f01CB = new(mem_ctx) ir_if(operand(r01CC).val);
   exec_list *const f01CB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01CB->then_instructions;

      ir_variable *const r01CD = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r01CF = less(body.constant(int(2045)), r0184);
      ir_if *f01CE = new(mem_ctx) ir_if(operand(r01CF).val);
      exec_list *const f01CE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01CE->then_instructions;

         body.emit(assign(r01CD, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01CE->else_instructions;

         ir_variable *const r01D0 = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r01D2 = equal(r0184, body.constant(int(2045)));
         ir_if *f01D1 = new(mem_ctx) ir_if(operand(r01D2).val);
         exec_list *const f01D1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01D1->then_instructions;

            ir_expression *const r01D3 = equal(body.constant(2097151u), r0185);
            ir_expression *const r01D4 = equal(body.constant(4294967295u), r0186);
            body.emit(assign(r01D0, logic_and(r01D3, r01D4), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01D1->else_instructions;

            body.emit(assign(r01D0, body.constant(false), 0x01));


         body.instructions = f01D1_parent_instructions;
         body.emit(f01D1);

         /* END IF */

         body.emit(assign(r01CD, logic_and(r01D0, r01C9), 0x01));


      body.instructions = f01CE_parent_instructions;
      body.emit(f01CE);

      /* END IF */

      /* IF CONDITION */
      ir_if *f01D5 = new(mem_ctx) ir_if(operand(r01CD).val);
      exec_list *const f01D5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01D5->then_instructions;

         ir_variable *const r01D6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r01D6);
         ir_expression *const r01D7 = lshift(r0183, body.constant(int(31)));
         body.emit(assign(r01D6, add(r01D7, body.constant(2146435072u)), 0x02));

         body.emit(assign(r01D6, body.constant(0u), 0x01));

         body.emit(assign(r01C8, r01D6, 0x03));

         body.emit(assign(r01C7, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01D5->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01D9 = less(r0184, body.constant(int(0)));
         ir_if *f01D8 = new(mem_ctx) ir_if(operand(r01D9).val);
         exec_list *const f01D8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01D8->then_instructions;

            ir_variable *const r01DA = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r01DA, r0187, 0x01));

            ir_variable *const r01DB = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r01DB, neg(r0184), 0x01));

            ir_variable *const r01DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r01DC);
            ir_variable *const r01DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r01DD);
            ir_variable *const r01DE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r01DE);
            ir_variable *const r01DF = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r01E0 = neg(r01DB);
            body.emit(assign(r01DF, bit_and(r01E0, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r01E2 = equal(r01DB, body.constant(int(0)));
            ir_if *f01E1 = new(mem_ctx) ir_if(operand(r01E2).val);
            exec_list *const f01E1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01E1->then_instructions;

               body.emit(assign(r01DC, r0187, 0x01));

               body.emit(assign(r01DD, r0186, 0x01));

               body.emit(assign(r01DE, r0185, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01E1->else_instructions;

               /* IF CONDITION */
               ir_expression *const r01E4 = less(r01DB, body.constant(int(32)));
               ir_if *f01E3 = new(mem_ctx) ir_if(operand(r01E4).val);
               exec_list *const f01E3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01E3->then_instructions;

                  body.emit(assign(r01DC, lshift(r0186, r01DF), 0x01));

                  ir_expression *const r01E5 = lshift(r0185, r01DF);
                  ir_expression *const r01E6 = rshift(r0186, r01DB);
                  body.emit(assign(r01DD, bit_or(r01E5, r01E6), 0x01));

                  body.emit(assign(r01DE, rshift(r0185, r01DB), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01E3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r01E8 = equal(r01DB, body.constant(int(32)));
                  ir_if *f01E7 = new(mem_ctx) ir_if(operand(r01E8).val);
                  exec_list *const f01E7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01E7->then_instructions;

                     body.emit(assign(r01DC, r0186, 0x01));

                     body.emit(assign(r01DD, r0185, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01E7->else_instructions;

                     body.emit(assign(r01DA, bit_or(r0187, r0186), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r01EA = less(r01DB, body.constant(int(64)));
                     ir_if *f01E9 = new(mem_ctx) ir_if(operand(r01EA).val);
                     exec_list *const f01E9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f01E9->then_instructions;

                        body.emit(assign(r01DC, lshift(r0185, r01DF), 0x01));

                        ir_expression *const r01EB = bit_and(r01DB, body.constant(int(31)));
                        body.emit(assign(r01DD, rshift(r0185, r01EB), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f01E9->else_instructions;

                        ir_variable *const r01EC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r01EE = equal(r01DB, body.constant(int(64)));
                        ir_if *f01ED = new(mem_ctx) ir_if(operand(r01EE).val);
                        exec_list *const f01ED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f01ED->then_instructions;

                           body.emit(assign(r01EC, r0185, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f01ED->else_instructions;

                           ir_expression *const r01EF = nequal(r0185, body.constant(0u));
                           ir_expression *const r01F0 = expr(ir_unop_b2i, r01EF);
                           body.emit(assign(r01EC, expr(ir_unop_i2u, r01F0), 0x01));


                        body.instructions = f01ED_parent_instructions;
                        body.emit(f01ED);

                        /* END IF */

                        body.emit(assign(r01DC, r01EC, 0x01));

                        body.emit(assign(r01DD, body.constant(0u), 0x01));


                     body.instructions = f01E9_parent_instructions;
                     body.emit(f01E9);

                     /* END IF */


                  body.instructions = f01E7_parent_instructions;
                  body.emit(f01E7);

                  /* END IF */

                  body.emit(assign(r01DE, body.constant(0u), 0x01));


               body.instructions = f01E3_parent_instructions;
               body.emit(f01E3);

               /* END IF */

               ir_expression *const r01F1 = nequal(r01DA, body.constant(0u));
               ir_expression *const r01F2 = expr(ir_unop_b2i, r01F1);
               ir_expression *const r01F3 = expr(ir_unop_i2u, r01F2);
               body.emit(assign(r01DC, bit_or(r01DC, r01F3), 0x01));


            body.instructions = f01E1_parent_instructions;
            body.emit(f01E1);

            /* END IF */

            body.emit(assign(r01C4, r01DE, 0x01));

            body.emit(assign(r01C5, r01DD, 0x01));

            body.emit(assign(r01C6, r01DC, 0x01));

            body.emit(assign(r01C3, body.constant(int(0)), 0x01));

            body.emit(assign(r01C9, less(r01DC, body.constant(0u)), 0x01));


         body.instructions = f01D8_parent_instructions;
         body.emit(f01D8);

         /* END IF */


      body.instructions = f01D5_parent_instructions;
      body.emit(f01D5);

      /* END IF */


   body.instructions = f01CB_parent_instructions;
   body.emit(f01CB);

   /* END IF */

   /* IF CONDITION */
   ir_if *f01F4 = new(mem_ctx) ir_if(operand(r01C7).val);
   exec_list *const f01F4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01F4->then_instructions;

      /* IF CONDITION */
      ir_if *f01F5 = new(mem_ctx) ir_if(operand(r01C9).val);
      exec_list *const f01F5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01F5->then_instructions;

         ir_variable *const r01F6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r01F6, add(r01C5, body.constant(1u)), 0x01));

         ir_expression *const r01F7 = less(r01F6, r01C5);
         ir_expression *const r01F8 = expr(ir_unop_b2i, r01F7);
         ir_expression *const r01F9 = expr(ir_unop_i2u, r01F8);
         body.emit(assign(r01C4, add(r01C4, r01F9), 0x01));

         ir_expression *const r01FA = equal(r01C6, body.constant(0u));
         ir_expression *const r01FB = expr(ir_unop_b2i, r01FA);
         ir_expression *const r01FC = expr(ir_unop_i2u, r01FB);
         ir_expression *const r01FD = add(r01C6, r01FC);
         ir_expression *const r01FE = bit_and(r01FD, body.constant(1u));
         ir_expression *const r01FF = expr(ir_unop_bit_not, r01FE);
         body.emit(assign(r01C5, bit_and(r01F6, r01FF), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01F5->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0201 = bit_or(r01C4, r01C5);
         ir_expression *const r0202 = equal(r0201, body.constant(0u));
         ir_if *f0200 = new(mem_ctx) ir_if(operand(r0202).val);
         exec_list *const f0200_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0200->then_instructions;

            body.emit(assign(r01C3, body.constant(int(0)), 0x01));


         body.instructions = f0200_parent_instructions;
         body.emit(f0200);

         /* END IF */


      body.instructions = f01F5_parent_instructions;
      body.emit(f01F5);

      /* END IF */

      ir_variable *const r0203 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r0203);
      ir_expression *const r0204 = lshift(r0183, body.constant(int(31)));
      ir_expression *const r0205 = expr(ir_unop_i2u, r01C3);
      ir_expression *const r0206 = lshift(r0205, body.constant(int(20)));
      ir_expression *const r0207 = add(r0204, r0206);
      body.emit(assign(r0203, add(r0207, r01C4), 0x02));

      body.emit(assign(r0203, r01C5, 0x01));

      body.emit(assign(r01C8, r0203, 0x03));

      body.emit(assign(r01C7, body.constant(false), 0x01));


   body.instructions = f01F4_parent_instructions;
   body.emit(f01F4);

   /* END IF */

   body.emit(ret(r01C8));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
propagateFloat64NaN(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0208 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0208);
   ir_variable *const r0209 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0209);
   ir_variable *const r020A = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r020B = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r020C = lshift(swizzle_y(r0208), body.constant(int(1)));
   ir_expression *const r020D = lequal(body.constant(4292870144u), r020C);
   ir_expression *const r020E = nequal(swizzle_x(r0208), body.constant(0u));
   ir_expression *const r020F = bit_and(swizzle_y(r0208), body.constant(1048575u));
   ir_expression *const r0210 = nequal(r020F, body.constant(0u));
   ir_expression *const r0211 = logic_or(r020E, r0210);
   body.emit(assign(r020B, logic_and(r020D, r0211), 0x01));

   ir_variable *const r0212 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
   ir_expression *const r0213 = rshift(swizzle_y(r0208), body.constant(int(19)));
   ir_expression *const r0214 = bit_and(r0213, body.constant(4095u));
   ir_expression *const r0215 = equal(r0214, body.constant(4094u));
   ir_expression *const r0216 = nequal(swizzle_x(r0208), body.constant(0u));
   ir_expression *const r0217 = bit_and(swizzle_y(r0208), body.constant(524287u));
   ir_expression *const r0218 = nequal(r0217, body.constant(0u));
   ir_expression *const r0219 = logic_or(r0216, r0218);
   body.emit(assign(r0212, logic_and(r0215, r0219), 0x01));

   ir_variable *const r021A = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r021B = lshift(swizzle_y(r0209), body.constant(int(1)));
   ir_expression *const r021C = lequal(body.constant(4292870144u), r021B);
   ir_expression *const r021D = nequal(swizzle_x(r0209), body.constant(0u));
   ir_expression *const r021E = bit_and(swizzle_y(r0209), body.constant(1048575u));
   ir_expression *const r021F = nequal(r021E, body.constant(0u));
   ir_expression *const r0220 = logic_or(r021D, r021F);
   body.emit(assign(r021A, logic_and(r021C, r0220), 0x01));

   body.emit(assign(r0208, bit_or(swizzle_y(r0208), body.constant(524288u)), 0x02));

   body.emit(assign(r0209, bit_or(swizzle_y(r0209), body.constant(524288u)), 0x02));

   /* IF CONDITION */
   ir_if *f0221 = new(mem_ctx) ir_if(operand(r020B).val);
   exec_list *const f0221_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0221->then_instructions;

      ir_variable *const r0222 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r0224 = logic_and(r0212, r021A);
      ir_if *f0223 = new(mem_ctx) ir_if(operand(r0224).val);
      exec_list *const f0223_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0223->then_instructions;

         body.emit(assign(r0222, r0209, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0223->else_instructions;

         body.emit(assign(r0222, r0208, 0x03));


      body.instructions = f0223_parent_instructions;
      body.emit(f0223);

      /* END IF */

      body.emit(assign(r020A, r0222, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0221->else_instructions;

      body.emit(assign(r020A, r0209, 0x03));


   body.instructions = f0221_parent_instructions;
   body.emit(f0221);

   /* END IF */

   body.emit(ret(r020A));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
addFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0225 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0225);
   ir_variable *const r0226 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0226);
   ir_variable *const r0227 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0227);
   ir_variable *const r0228 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r0228, body.constant(true), 0x01));

   ir_variable *const r0229 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r022A = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r022A);
   ir_variable *const r022B = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r022B);
   ir_variable *const r022C = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r022C);
   ir_variable *const r022D = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r022D);
   ir_variable *const r022E = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r022E);
   ir_variable *const r022F = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r022F);
   ir_variable *const r0230 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r0230);
   ir_variable *const r0231 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r0231);
   body.emit(assign(r0231, body.constant(0u), 0x01));

   body.emit(assign(r0230, body.constant(0u), 0x01));

   ir_variable *const r0232 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r0232, swizzle_x(r0225), 0x01));

   body.emit(assign(r022E, r0232, 0x01));

   ir_variable *const r0233 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r0233, bit_and(swizzle_y(r0225), body.constant(1048575u)), 0x01));

   body.emit(assign(r022D, r0233, 0x01));

   ir_variable *const r0234 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r0234, swizzle_x(r0226), 0x01));

   body.emit(assign(r022C, r0234, 0x01));

   ir_variable *const r0235 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r0235, bit_and(swizzle_y(r0226), body.constant(1048575u)), 0x01));

   body.emit(assign(r022B, r0235, 0x01));

   ir_variable *const r0236 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0237 = rshift(swizzle_y(r0225), body.constant(int(20)));
   ir_expression *const r0238 = bit_and(r0237, body.constant(2047u));
   body.emit(assign(r0236, expr(ir_unop_u2i, r0238), 0x01));

   ir_variable *const r0239 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r023A = rshift(swizzle_y(r0226), body.constant(int(20)));
   ir_expression *const r023B = bit_and(r023A, body.constant(2047u));
   body.emit(assign(r0239, expr(ir_unop_u2i, r023B), 0x01));

   ir_variable *const r023C = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r023C, sub(r0236, r0239), 0x01));

   body.emit(assign(r022A, r023C, 0x01));

   /* IF CONDITION */
   ir_expression *const r023E = less(body.constant(int(0)), r023C);
   ir_if *f023D = new(mem_ctx) ir_if(operand(r023E).val);
   exec_list *const f023D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f023D->then_instructions;

      /* IF CONDITION */
      ir_expression *const r0240 = equal(r0236, body.constant(int(2047)));
      ir_if *f023F = new(mem_ctx) ir_if(operand(r0240).val);
      exec_list *const f023F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f023F->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0242 = bit_or(r0233, swizzle_x(r0225));
         ir_expression *const r0243 = nequal(r0242, body.constant(0u));
         ir_if *f0241 = new(mem_ctx) ir_if(operand(r0243).val);
         exec_list *const f0241_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0241->then_instructions;

            ir_variable *const r0244 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r0244, swizzle_x(r0225), 0x01));

            ir_variable *const r0245 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r0245, swizzle_x(r0226), 0x01));

            ir_variable *const r0246 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0247 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r0248 = rshift(swizzle_y(r0225), body.constant(int(19)));
            ir_expression *const r0249 = bit_and(r0248, body.constant(4095u));
            ir_expression *const r024A = equal(r0249, body.constant(4094u));
            ir_expression *const r024B = nequal(swizzle_x(r0225), body.constant(0u));
            ir_expression *const r024C = bit_and(swizzle_y(r0225), body.constant(524287u));
            ir_expression *const r024D = nequal(r024C, body.constant(0u));
            ir_expression *const r024E = logic_or(r024B, r024D);
            body.emit(assign(r0247, logic_and(r024A, r024E), 0x01));

            ir_variable *const r024F = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r0250 = lshift(swizzle_y(r0226), body.constant(int(1)));
            ir_expression *const r0251 = lequal(body.constant(4292870144u), r0250);
            ir_expression *const r0252 = nequal(swizzle_x(r0226), body.constant(0u));
            ir_expression *const r0253 = bit_and(swizzle_y(r0226), body.constant(1048575u));
            ir_expression *const r0254 = nequal(r0253, body.constant(0u));
            ir_expression *const r0255 = logic_or(r0252, r0254);
            body.emit(assign(r024F, logic_and(r0251, r0255), 0x01));

            body.emit(assign(r0244, bit_or(swizzle_y(r0225), body.constant(524288u)), 0x02));

            body.emit(assign(r0245, bit_or(swizzle_y(r0226), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0257 = lshift(swizzle_y(r0225), body.constant(int(1)));
            ir_expression *const r0258 = lequal(body.constant(4292870144u), r0257);
            ir_expression *const r0259 = nequal(swizzle_x(r0225), body.constant(0u));
            ir_expression *const r025A = bit_and(swizzle_y(r0225), body.constant(1048575u));
            ir_expression *const r025B = nequal(r025A, body.constant(0u));
            ir_expression *const r025C = logic_or(r0259, r025B);
            ir_expression *const r025D = logic_and(r0258, r025C);
            ir_if *f0256 = new(mem_ctx) ir_if(operand(r025D).val);
            exec_list *const f0256_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0256->then_instructions;

               ir_variable *const r025E = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0260 = logic_and(r0247, r024F);
               ir_if *f025F = new(mem_ctx) ir_if(operand(r0260).val);
               exec_list *const f025F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f025F->then_instructions;

                  body.emit(assign(r025E, r0245, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f025F->else_instructions;

                  body.emit(assign(r025E, r0244, 0x03));


               body.instructions = f025F_parent_instructions;
               body.emit(f025F);

               /* END IF */

               body.emit(assign(r0246, r025E, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0256->else_instructions;

               body.emit(assign(r0246, r0245, 0x03));


            body.instructions = f0256_parent_instructions;
            body.emit(f0256);

            /* END IF */

            body.emit(assign(r0229, r0246, 0x03));

            body.emit(assign(r0228, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0241->else_instructions;

            body.emit(assign(r0229, r0225, 0x03));

            body.emit(assign(r0228, body.constant(false), 0x01));


         body.instructions = f0241_parent_instructions;
         body.emit(f0241);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f023F->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0262 = equal(r0239, body.constant(int(0)));
         ir_if *f0261 = new(mem_ctx) ir_if(operand(r0262).val);
         exec_list *const f0261_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0261->then_instructions;

            body.emit(assign(r022A, add(r023C, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0261->else_instructions;

            body.emit(assign(r022B, bit_or(r0235, body.constant(1048576u)), 0x01));


         body.instructions = f0261_parent_instructions;
         body.emit(f0261);

         /* END IF */

         ir_variable *const r0263 = body.make_temp(glsl_type::uint_type, "a2");
         body.emit(assign(r0263, body.constant(0u), 0x01));

         ir_variable *const r0264 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r0264);
         ir_variable *const r0265 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0265);
         ir_variable *const r0266 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0266);
         ir_variable *const r0267 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0268 = neg(r022A);
         body.emit(assign(r0267, bit_and(r0268, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r026A = equal(r022A, body.constant(int(0)));
         ir_if *f0269 = new(mem_ctx) ir_if(operand(r026A).val);
         exec_list *const f0269_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0269->then_instructions;

            body.emit(assign(r0264, r0263, 0x01));

            body.emit(assign(r0265, r0234, 0x01));

            body.emit(assign(r0266, r022B, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0269->else_instructions;

            /* IF CONDITION */
            ir_expression *const r026C = less(r022A, body.constant(int(32)));
            ir_if *f026B = new(mem_ctx) ir_if(operand(r026C).val);
            exec_list *const f026B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f026B->then_instructions;

               body.emit(assign(r0264, lshift(swizzle_x(r0226), r0267), 0x01));

               ir_expression *const r026D = lshift(r022B, r0267);
               ir_expression *const r026E = rshift(swizzle_x(r0226), r022A);
               body.emit(assign(r0265, bit_or(r026D, r026E), 0x01));

               body.emit(assign(r0266, rshift(r022B, r022A), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f026B->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0270 = equal(r022A, body.constant(int(32)));
               ir_if *f026F = new(mem_ctx) ir_if(operand(r0270).val);
               exec_list *const f026F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f026F->then_instructions;

                  body.emit(assign(r0264, r0234, 0x01));

                  body.emit(assign(r0265, r022B, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f026F->else_instructions;

                  body.emit(assign(r0263, bit_or(body.constant(0u), swizzle_x(r0226)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0272 = less(r022A, body.constant(int(64)));
                  ir_if *f0271 = new(mem_ctx) ir_if(operand(r0272).val);
                  exec_list *const f0271_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0271->then_instructions;

                     body.emit(assign(r0264, lshift(r022B, r0267), 0x01));

                     ir_expression *const r0273 = bit_and(r022A, body.constant(int(31)));
                     body.emit(assign(r0265, rshift(r022B, r0273), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0271->else_instructions;

                     ir_variable *const r0274 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0276 = equal(r022A, body.constant(int(64)));
                     ir_if *f0275 = new(mem_ctx) ir_if(operand(r0276).val);
                     exec_list *const f0275_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0275->then_instructions;

                        body.emit(assign(r0274, r022B, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0275->else_instructions;

                        ir_expression *const r0277 = nequal(r022B, body.constant(0u));
                        ir_expression *const r0278 = expr(ir_unop_b2i, r0277);
                        body.emit(assign(r0274, expr(ir_unop_i2u, r0278), 0x01));


                     body.instructions = f0275_parent_instructions;
                     body.emit(f0275);

                     /* END IF */

                     body.emit(assign(r0264, r0274, 0x01));

                     body.emit(assign(r0265, body.constant(0u), 0x01));


                  body.instructions = f0271_parent_instructions;
                  body.emit(f0271);

                  /* END IF */


               body.instructions = f026F_parent_instructions;
               body.emit(f026F);

               /* END IF */

               body.emit(assign(r0266, body.constant(0u), 0x01));


            body.instructions = f026B_parent_instructions;
            body.emit(f026B);

            /* END IF */

            ir_expression *const r0279 = nequal(r0263, body.constant(0u));
            ir_expression *const r027A = expr(ir_unop_b2i, r0279);
            ir_expression *const r027B = expr(ir_unop_i2u, r027A);
            body.emit(assign(r0264, bit_or(r0264, r027B), 0x01));


         body.instructions = f0269_parent_instructions;
         body.emit(f0269);

         /* END IF */

         body.emit(assign(r022B, r0266, 0x01));

         body.emit(assign(r022C, r0265, 0x01));

         body.emit(assign(r0230, r0264, 0x01));

         body.emit(assign(r022F, r0236, 0x01));


      body.instructions = f023F_parent_instructions;
      body.emit(f023F);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f023D->else_instructions;

      /* IF CONDITION */
      ir_expression *const r027D = less(r022A, body.constant(int(0)));
      ir_if *f027C = new(mem_ctx) ir_if(operand(r027D).val);
      exec_list *const f027C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f027C->then_instructions;

         /* IF CONDITION */
         ir_expression *const r027F = equal(r0239, body.constant(int(2047)));
         ir_if *f027E = new(mem_ctx) ir_if(operand(r027F).val);
         exec_list *const f027E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f027E->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0281 = bit_or(r022B, r022C);
            ir_expression *const r0282 = nequal(r0281, body.constant(0u));
            ir_if *f0280 = new(mem_ctx) ir_if(operand(r0282).val);
            exec_list *const f0280_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0280->then_instructions;

               ir_variable *const r0283 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0283, swizzle_x(r0225), 0x01));

               ir_variable *const r0284 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0284, swizzle_x(r0226), 0x01));

               ir_variable *const r0285 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0286 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0287 = rshift(swizzle_y(r0225), body.constant(int(19)));
               ir_expression *const r0288 = bit_and(r0287, body.constant(4095u));
               ir_expression *const r0289 = equal(r0288, body.constant(4094u));
               ir_expression *const r028A = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r028B = bit_and(swizzle_y(r0225), body.constant(524287u));
               ir_expression *const r028C = nequal(r028B, body.constant(0u));
               ir_expression *const r028D = logic_or(r028A, r028C);
               body.emit(assign(r0286, logic_and(r0289, r028D), 0x01));

               ir_variable *const r028E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r028F = lshift(swizzle_y(r0226), body.constant(int(1)));
               ir_expression *const r0290 = lequal(body.constant(4292870144u), r028F);
               ir_expression *const r0291 = nequal(swizzle_x(r0226), body.constant(0u));
               ir_expression *const r0292 = bit_and(swizzle_y(r0226), body.constant(1048575u));
               ir_expression *const r0293 = nequal(r0292, body.constant(0u));
               ir_expression *const r0294 = logic_or(r0291, r0293);
               body.emit(assign(r028E, logic_and(r0290, r0294), 0x01));

               body.emit(assign(r0283, bit_or(swizzle_y(r0225), body.constant(524288u)), 0x02));

               body.emit(assign(r0284, bit_or(swizzle_y(r0226), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r0296 = lshift(swizzle_y(r0225), body.constant(int(1)));
               ir_expression *const r0297 = lequal(body.constant(4292870144u), r0296);
               ir_expression *const r0298 = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r0299 = bit_and(swizzle_y(r0225), body.constant(1048575u));
               ir_expression *const r029A = nequal(r0299, body.constant(0u));
               ir_expression *const r029B = logic_or(r0298, r029A);
               ir_expression *const r029C = logic_and(r0297, r029B);
               ir_if *f0295 = new(mem_ctx) ir_if(operand(r029C).val);
               exec_list *const f0295_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0295->then_instructions;

                  ir_variable *const r029D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r029F = logic_and(r0286, r028E);
                  ir_if *f029E = new(mem_ctx) ir_if(operand(r029F).val);
                  exec_list *const f029E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f029E->then_instructions;

                     body.emit(assign(r029D, r0284, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f029E->else_instructions;

                     body.emit(assign(r029D, r0283, 0x03));


                  body.instructions = f029E_parent_instructions;
                  body.emit(f029E);

                  /* END IF */

                  body.emit(assign(r0285, r029D, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0295->else_instructions;

                  body.emit(assign(r0285, r0284, 0x03));


               body.instructions = f0295_parent_instructions;
               body.emit(f0295);

               /* END IF */

               body.emit(assign(r0229, r0285, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0280->else_instructions;

               ir_variable *const r02A0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r02A0);
               ir_expression *const r02A1 = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r02A0, add(r02A1, body.constant(2146435072u)), 0x02));

               body.emit(assign(r02A0, body.constant(0u), 0x01));

               body.emit(assign(r0229, r02A0, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


            body.instructions = f0280_parent_instructions;
            body.emit(f0280);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f027E->else_instructions;

            /* IF CONDITION */
            ir_expression *const r02A3 = equal(r0236, body.constant(int(0)));
            ir_if *f02A2 = new(mem_ctx) ir_if(operand(r02A3).val);
            exec_list *const f02A2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02A2->then_instructions;

               body.emit(assign(r022A, add(r022A, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02A2->else_instructions;

               body.emit(assign(r022D, bit_or(r0233, body.constant(1048576u)), 0x01));


            body.instructions = f02A2_parent_instructions;
            body.emit(f02A2);

            /* END IF */

            ir_variable *const r02A4 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r02A4, body.constant(0u), 0x01));

            ir_variable *const r02A5 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r02A5, neg(r022A), 0x01));

            ir_variable *const r02A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r02A6);
            ir_variable *const r02A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r02A7);
            ir_variable *const r02A8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r02A8);
            ir_variable *const r02A9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r02AA = neg(r02A5);
            body.emit(assign(r02A9, bit_and(r02AA, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r02AC = equal(r02A5, body.constant(int(0)));
            ir_if *f02AB = new(mem_ctx) ir_if(operand(r02AC).val);
            exec_list *const f02AB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02AB->then_instructions;

               body.emit(assign(r02A6, r02A4, 0x01));

               body.emit(assign(r02A7, r0232, 0x01));

               body.emit(assign(r02A8, r022D, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02AB->else_instructions;

               /* IF CONDITION */
               ir_expression *const r02AE = less(r02A5, body.constant(int(32)));
               ir_if *f02AD = new(mem_ctx) ir_if(operand(r02AE).val);
               exec_list *const f02AD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02AD->then_instructions;

                  body.emit(assign(r02A6, lshift(swizzle_x(r0225), r02A9), 0x01));

                  ir_expression *const r02AF = lshift(r022D, r02A9);
                  ir_expression *const r02B0 = rshift(swizzle_x(r0225), r02A5);
                  body.emit(assign(r02A7, bit_or(r02AF, r02B0), 0x01));

                  body.emit(assign(r02A8, rshift(r022D, r02A5), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02AD->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r02B2 = equal(r02A5, body.constant(int(32)));
                  ir_if *f02B1 = new(mem_ctx) ir_if(operand(r02B2).val);
                  exec_list *const f02B1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02B1->then_instructions;

                     body.emit(assign(r02A6, r0232, 0x01));

                     body.emit(assign(r02A7, r022D, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02B1->else_instructions;

                     body.emit(assign(r02A4, bit_or(body.constant(0u), swizzle_x(r0225)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r02B4 = less(r02A5, body.constant(int(64)));
                     ir_if *f02B3 = new(mem_ctx) ir_if(operand(r02B4).val);
                     exec_list *const f02B3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02B3->then_instructions;

                        body.emit(assign(r02A6, lshift(r022D, r02A9), 0x01));

                        ir_expression *const r02B5 = bit_and(r02A5, body.constant(int(31)));
                        body.emit(assign(r02A7, rshift(r022D, r02B5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02B3->else_instructions;

                        ir_variable *const r02B6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r02B8 = equal(r02A5, body.constant(int(64)));
                        ir_if *f02B7 = new(mem_ctx) ir_if(operand(r02B8).val);
                        exec_list *const f02B7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f02B7->then_instructions;

                           body.emit(assign(r02B6, r022D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f02B7->else_instructions;

                           ir_expression *const r02B9 = nequal(r022D, body.constant(0u));
                           ir_expression *const r02BA = expr(ir_unop_b2i, r02B9);
                           body.emit(assign(r02B6, expr(ir_unop_i2u, r02BA), 0x01));


                        body.instructions = f02B7_parent_instructions;
                        body.emit(f02B7);

                        /* END IF */

                        body.emit(assign(r02A6, r02B6, 0x01));

                        body.emit(assign(r02A7, body.constant(0u), 0x01));


                     body.instructions = f02B3_parent_instructions;
                     body.emit(f02B3);

                     /* END IF */


                  body.instructions = f02B1_parent_instructions;
                  body.emit(f02B1);

                  /* END IF */

                  body.emit(assign(r02A8, body.constant(0u), 0x01));


               body.instructions = f02AD_parent_instructions;
               body.emit(f02AD);

               /* END IF */

               ir_expression *const r02BB = nequal(r02A4, body.constant(0u));
               ir_expression *const r02BC = expr(ir_unop_b2i, r02BB);
               ir_expression *const r02BD = expr(ir_unop_i2u, r02BC);
               body.emit(assign(r02A6, bit_or(r02A6, r02BD), 0x01));


            body.instructions = f02AB_parent_instructions;
            body.emit(f02AB);

            /* END IF */

            body.emit(assign(r022D, r02A8, 0x01));

            body.emit(assign(r022E, r02A7, 0x01));

            body.emit(assign(r0230, r02A6, 0x01));

            body.emit(assign(r022F, r0239, 0x01));


         body.instructions = f027E_parent_instructions;
         body.emit(f027E);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f027C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r02BF = equal(r0236, body.constant(int(2047)));
         ir_if *f02BE = new(mem_ctx) ir_if(operand(r02BF).val);
         exec_list *const f02BE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f02BE->then_instructions;

            /* IF CONDITION */
            ir_expression *const r02C1 = bit_or(r022D, r022E);
            ir_expression *const r02C2 = bit_or(r022B, r022C);
            ir_expression *const r02C3 = bit_or(r02C1, r02C2);
            ir_expression *const r02C4 = nequal(r02C3, body.constant(0u));
            ir_if *f02C0 = new(mem_ctx) ir_if(operand(r02C4).val);
            exec_list *const f02C0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02C0->then_instructions;

               ir_variable *const r02C5 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r02C5, swizzle_x(r0225), 0x01));

               ir_variable *const r02C6 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r02C6, swizzle_x(r0226), 0x01));

               ir_variable *const r02C7 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02C8 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r02C9 = rshift(swizzle_y(r0225), body.constant(int(19)));
               ir_expression *const r02CA = bit_and(r02C9, body.constant(4095u));
               ir_expression *const r02CB = equal(r02CA, body.constant(4094u));
               ir_expression *const r02CC = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r02CD = bit_and(swizzle_y(r0225), body.constant(524287u));
               ir_expression *const r02CE = nequal(r02CD, body.constant(0u));
               ir_expression *const r02CF = logic_or(r02CC, r02CE);
               body.emit(assign(r02C8, logic_and(r02CB, r02CF), 0x01));

               ir_variable *const r02D0 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r02D1 = lshift(swizzle_y(r0226), body.constant(int(1)));
               ir_expression *const r02D2 = lequal(body.constant(4292870144u), r02D1);
               ir_expression *const r02D3 = nequal(swizzle_x(r0226), body.constant(0u));
               ir_expression *const r02D4 = bit_and(swizzle_y(r0226), body.constant(1048575u));
               ir_expression *const r02D5 = nequal(r02D4, body.constant(0u));
               ir_expression *const r02D6 = logic_or(r02D3, r02D5);
               body.emit(assign(r02D0, logic_and(r02D2, r02D6), 0x01));

               body.emit(assign(r02C5, bit_or(swizzle_y(r0225), body.constant(524288u)), 0x02));

               body.emit(assign(r02C6, bit_or(swizzle_y(r0226), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r02D8 = lshift(swizzle_y(r0225), body.constant(int(1)));
               ir_expression *const r02D9 = lequal(body.constant(4292870144u), r02D8);
               ir_expression *const r02DA = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r02DB = bit_and(swizzle_y(r0225), body.constant(1048575u));
               ir_expression *const r02DC = nequal(r02DB, body.constant(0u));
               ir_expression *const r02DD = logic_or(r02DA, r02DC);
               ir_expression *const r02DE = logic_and(r02D9, r02DD);
               ir_if *f02D7 = new(mem_ctx) ir_if(operand(r02DE).val);
               exec_list *const f02D7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02D7->then_instructions;

                  ir_variable *const r02DF = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02E1 = logic_and(r02C8, r02D0);
                  ir_if *f02E0 = new(mem_ctx) ir_if(operand(r02E1).val);
                  exec_list *const f02E0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02E0->then_instructions;

                     body.emit(assign(r02DF, r02C6, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02E0->else_instructions;

                     body.emit(assign(r02DF, r02C5, 0x03));


                  body.instructions = f02E0_parent_instructions;
                  body.emit(f02E0);

                  /* END IF */

                  body.emit(assign(r02C7, r02DF, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02D7->else_instructions;

                  body.emit(assign(r02C7, r02C6, 0x03));


               body.instructions = f02D7_parent_instructions;
               body.emit(f02D7);

               /* END IF */

               body.emit(assign(r0229, r02C7, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02C0->else_instructions;

               body.emit(assign(r0229, r0225, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


            body.instructions = f02C0_parent_instructions;
            body.emit(f02C0);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f02BE->else_instructions;

            ir_variable *const r02E2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r02E3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r02E3, add(r022E, r022C), 0x01));

            ir_expression *const r02E4 = add(r022D, r022B);
            ir_expression *const r02E5 = less(r02E3, r022E);
            ir_expression *const r02E6 = expr(ir_unop_b2i, r02E5);
            ir_expression *const r02E7 = expr(ir_unop_i2u, r02E6);
            body.emit(assign(r02E2, add(r02E4, r02E7), 0x01));

            body.emit(assign(r0231, r02E2, 0x01));

            /* IF CONDITION */
            ir_expression *const r02E9 = equal(r0236, body.constant(int(0)));
            ir_if *f02E8 = new(mem_ctx) ir_if(operand(r02E9).val);
            exec_list *const f02E8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02E8->then_instructions;

               ir_variable *const r02EA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r02EA);
               ir_expression *const r02EB = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r02EA, add(r02EB, r02E2), 0x02));

               body.emit(assign(r02EA, r02E3, 0x01));

               body.emit(assign(r0229, r02EA, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02E8->else_instructions;

               body.emit(assign(r0231, bit_or(r02E2, body.constant(2097152u)), 0x01));

               body.emit(assign(r022F, r0236, 0x01));

               ir_variable *const r02EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r02EC);
               ir_variable *const r02ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r02ED);
               ir_variable *const r02EE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r02EE);
               body.emit(assign(r02EC, lshift(r02E3, body.constant(int(31))), 0x01));

               ir_expression *const r02EF = lshift(r0231, body.constant(int(31)));
               ir_expression *const r02F0 = rshift(r02E3, body.constant(int(1)));
               body.emit(assign(r02ED, bit_or(r02EF, r02F0), 0x01));

               body.emit(assign(r02EE, rshift(r0231, body.constant(int(1))), 0x01));

               body.emit(assign(r02EC, bit_or(r02EC, body.constant(0u)), 0x01));

               body.emit(assign(r0231, r02EE, 0x01));

               body.emit(assign(r0230, r02EC, 0x01));

               ir_variable *const r02F1 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r02F1, r0236, 0x01));

               ir_variable *const r02F2 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r02F2, r02EE, 0x01));

               ir_variable *const r02F3 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r02F3, r02ED, 0x01));

               ir_variable *const r02F4 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r02F4, r02EC, 0x01));

               ir_variable *const r02F5 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r02F5, body.constant(true), 0x01));

               ir_variable *const r02F6 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02F7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r02F7);
               ir_expression *const r02F8 = expr(ir_unop_u2i, r02EC);
               body.emit(assign(r02F7, less(r02F8, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r02FA = lequal(body.constant(int(2045)), r0236);
               ir_if *f02F9 = new(mem_ctx) ir_if(operand(r02FA).val);
               exec_list *const f02F9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02F9->then_instructions;

                  ir_variable *const r02FB = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02FD = less(body.constant(int(2045)), r0236);
                  ir_if *f02FC = new(mem_ctx) ir_if(operand(r02FD).val);
                  exec_list *const f02FC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02FC->then_instructions;

                     body.emit(assign(r02FB, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02FC->else_instructions;

                     ir_variable *const r02FE = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0300 = equal(r0236, body.constant(int(2045)));
                     ir_if *f02FF = new(mem_ctx) ir_if(operand(r0300).val);
                     exec_list *const f02FF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02FF->then_instructions;

                        ir_expression *const r0301 = equal(body.constant(2097151u), r02EE);
                        ir_expression *const r0302 = equal(body.constant(4294967295u), r02ED);
                        body.emit(assign(r02FE, logic_and(r0301, r0302), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02FF->else_instructions;

                        body.emit(assign(r02FE, body.constant(false), 0x01));


                     body.instructions = f02FF_parent_instructions;
                     body.emit(f02FF);

                     /* END IF */

                     body.emit(assign(r02FB, logic_and(r02FE, r02F7), 0x01));


                  body.instructions = f02FC_parent_instructions;
                  body.emit(f02FC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0303 = new(mem_ctx) ir_if(operand(r02FB).val);
                  exec_list *const f0303_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0303->then_instructions;

                     ir_variable *const r0304 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0304);
                     ir_expression *const r0305 = lshift(r0227, body.constant(int(31)));
                     body.emit(assign(r0304, add(r0305, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0304, body.constant(0u), 0x01));

                     body.emit(assign(r02F6, r0304, 0x03));

                     body.emit(assign(r02F5, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0303->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0307 = less(r0236, body.constant(int(0)));
                     ir_if *f0306 = new(mem_ctx) ir_if(operand(r0307).val);
                     exec_list *const f0306_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0306->then_instructions;

                        ir_variable *const r0308 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0308, r02EC, 0x01));

                        ir_variable *const r0309 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0309, neg(r0236), 0x01));

                        ir_variable *const r030A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r030A);
                        ir_variable *const r030B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r030B);
                        ir_variable *const r030C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r030C);
                        ir_variable *const r030D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r030E = neg(r0309);
                        body.emit(assign(r030D, bit_and(r030E, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0310 = equal(r0309, body.constant(int(0)));
                        ir_if *f030F = new(mem_ctx) ir_if(operand(r0310).val);
                        exec_list *const f030F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f030F->then_instructions;

                           body.emit(assign(r030A, r02EC, 0x01));

                           body.emit(assign(r030B, r02ED, 0x01));

                           body.emit(assign(r030C, r02EE, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f030F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0312 = less(r0309, body.constant(int(32)));
                           ir_if *f0311 = new(mem_ctx) ir_if(operand(r0312).val);
                           exec_list *const f0311_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0311->then_instructions;

                              body.emit(assign(r030A, lshift(r02ED, r030D), 0x01));

                              ir_expression *const r0313 = lshift(r02EE, r030D);
                              ir_expression *const r0314 = rshift(r02ED, r0309);
                              body.emit(assign(r030B, bit_or(r0313, r0314), 0x01));

                              body.emit(assign(r030C, rshift(r02EE, r0309), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0311->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0316 = equal(r0309, body.constant(int(32)));
                              ir_if *f0315 = new(mem_ctx) ir_if(operand(r0316).val);
                              exec_list *const f0315_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0315->then_instructions;

                                 body.emit(assign(r030A, r02ED, 0x01));

                                 body.emit(assign(r030B, r02EE, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0315->else_instructions;

                                 body.emit(assign(r0308, bit_or(r02EC, r02ED), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0318 = less(r0309, body.constant(int(64)));
                                 ir_if *f0317 = new(mem_ctx) ir_if(operand(r0318).val);
                                 exec_list *const f0317_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0317->then_instructions;

                                    body.emit(assign(r030A, lshift(r02EE, r030D), 0x01));

                                    ir_expression *const r0319 = bit_and(r0309, body.constant(int(31)));
                                    body.emit(assign(r030B, rshift(r02EE, r0319), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0317->else_instructions;

                                    ir_variable *const r031A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r031C = equal(r0309, body.constant(int(64)));
                                    ir_if *f031B = new(mem_ctx) ir_if(operand(r031C).val);
                                    exec_list *const f031B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f031B->then_instructions;

                                       body.emit(assign(r031A, r02EE, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f031B->else_instructions;

                                       ir_expression *const r031D = nequal(r02EE, body.constant(0u));
                                       ir_expression *const r031E = expr(ir_unop_b2i, r031D);
                                       body.emit(assign(r031A, expr(ir_unop_i2u, r031E), 0x01));


                                    body.instructions = f031B_parent_instructions;
                                    body.emit(f031B);

                                    /* END IF */

                                    body.emit(assign(r030A, r031A, 0x01));

                                    body.emit(assign(r030B, body.constant(0u), 0x01));


                                 body.instructions = f0317_parent_instructions;
                                 body.emit(f0317);

                                 /* END IF */


                              body.instructions = f0315_parent_instructions;
                              body.emit(f0315);

                              /* END IF */

                              body.emit(assign(r030C, body.constant(0u), 0x01));


                           body.instructions = f0311_parent_instructions;
                           body.emit(f0311);

                           /* END IF */

                           ir_expression *const r031F = nequal(r0308, body.constant(0u));
                           ir_expression *const r0320 = expr(ir_unop_b2i, r031F);
                           ir_expression *const r0321 = expr(ir_unop_i2u, r0320);
                           body.emit(assign(r030A, bit_or(r030A, r0321), 0x01));


                        body.instructions = f030F_parent_instructions;
                        body.emit(f030F);

                        /* END IF */

                        body.emit(assign(r02F2, r030C, 0x01));

                        body.emit(assign(r02F3, r030B, 0x01));

                        body.emit(assign(r02F4, r030A, 0x01));

                        body.emit(assign(r02F1, body.constant(int(0)), 0x01));

                        body.emit(assign(r02F7, less(r030A, body.constant(0u)), 0x01));


                     body.instructions = f0306_parent_instructions;
                     body.emit(f0306);

                     /* END IF */


                  body.instructions = f0303_parent_instructions;
                  body.emit(f0303);

                  /* END IF */


               body.instructions = f02F9_parent_instructions;
               body.emit(f02F9);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0322 = new(mem_ctx) ir_if(operand(r02F5).val);
               exec_list *const f0322_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0322->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0323 = new(mem_ctx) ir_if(operand(r02F7).val);
                  exec_list *const f0323_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0323->then_instructions;

                     ir_variable *const r0324 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0324, add(r02F3, body.constant(1u)), 0x01));

                     ir_expression *const r0325 = less(r0324, r02F3);
                     ir_expression *const r0326 = expr(ir_unop_b2i, r0325);
                     ir_expression *const r0327 = expr(ir_unop_i2u, r0326);
                     body.emit(assign(r02F2, add(r02F2, r0327), 0x01));

                     ir_expression *const r0328 = equal(r02F4, body.constant(0u));
                     ir_expression *const r0329 = expr(ir_unop_b2i, r0328);
                     ir_expression *const r032A = expr(ir_unop_i2u, r0329);
                     ir_expression *const r032B = add(r02F4, r032A);
                     ir_expression *const r032C = bit_and(r032B, body.constant(1u));
                     ir_expression *const r032D = expr(ir_unop_bit_not, r032C);
                     body.emit(assign(r02F3, bit_and(r0324, r032D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0323->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r032F = bit_or(r02F2, r02F3);
                     ir_expression *const r0330 = equal(r032F, body.constant(0u));
                     ir_if *f032E = new(mem_ctx) ir_if(operand(r0330).val);
                     exec_list *const f032E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f032E->then_instructions;

                        body.emit(assign(r02F1, body.constant(int(0)), 0x01));


                     body.instructions = f032E_parent_instructions;
                     body.emit(f032E);

                     /* END IF */


                  body.instructions = f0323_parent_instructions;
                  body.emit(f0323);

                  /* END IF */

                  ir_variable *const r0331 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0331);
                  ir_expression *const r0332 = lshift(r0227, body.constant(int(31)));
                  ir_expression *const r0333 = expr(ir_unop_i2u, r02F1);
                  ir_expression *const r0334 = lshift(r0333, body.constant(int(20)));
                  ir_expression *const r0335 = add(r0332, r0334);
                  body.emit(assign(r0331, add(r0335, r02F2), 0x02));

                  body.emit(assign(r0331, r02F3, 0x01));

                  body.emit(assign(r02F6, r0331, 0x03));

                  body.emit(assign(r02F5, body.constant(false), 0x01));


               body.instructions = f0322_parent_instructions;
               body.emit(f0322);

               /* END IF */

               body.emit(assign(r0229, r02F6, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


            body.instructions = f02E8_parent_instructions;
            body.emit(f02E8);

            /* END IF */


         body.instructions = f02BE_parent_instructions;
         body.emit(f02BE);

         /* END IF */


      body.instructions = f027C_parent_instructions;
      body.emit(f027C);

      /* END IF */


   body.instructions = f023D_parent_instructions;
   body.emit(f023D);

   /* END IF */

   /* IF CONDITION */
   ir_if *f0336 = new(mem_ctx) ir_if(operand(r0228).val);
   exec_list *const f0336_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0336->then_instructions;

      body.emit(assign(r022D, bit_or(r022D, body.constant(1048576u)), 0x01));

      ir_variable *const r0337 = body.make_temp(glsl_type::uint_type, "z0Ptr");
      ir_variable *const r0338 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r0338, add(r022E, r022C), 0x01));

      ir_expression *const r0339 = add(r022D, r022B);
      ir_expression *const r033A = less(r0338, r022E);
      ir_expression *const r033B = expr(ir_unop_b2i, r033A);
      ir_expression *const r033C = expr(ir_unop_i2u, r033B);
      body.emit(assign(r0337, add(r0339, r033C), 0x01));

      body.emit(assign(r0231, r0337, 0x01));

      body.emit(assign(r022F, add(r022F, body.constant(int(-1))), 0x01));

      /* IF CONDITION */
      ir_expression *const r033E = less(r0337, body.constant(2097152u));
      ir_if *f033D = new(mem_ctx) ir_if(operand(r033E).val);
      exec_list *const f033D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f033D->then_instructions;

         ir_variable *const r033F = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r033F, r022F, 0x01));

         ir_variable *const r0340 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0340, r0337, 0x01));

         ir_variable *const r0341 = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r0341, r0338, 0x01));

         ir_variable *const r0342 = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r0342, r0230, 0x01));

         ir_variable *const r0343 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r0343, body.constant(true), 0x01));

         ir_variable *const r0344 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0345 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0345);
         ir_expression *const r0346 = expr(ir_unop_u2i, r0230);
         body.emit(assign(r0345, less(r0346, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0348 = lequal(body.constant(int(2045)), r022F);
         ir_if *f0347 = new(mem_ctx) ir_if(operand(r0348).val);
         exec_list *const f0347_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0347->then_instructions;

            ir_variable *const r0349 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r034B = less(body.constant(int(2045)), r022F);
            ir_if *f034A = new(mem_ctx) ir_if(operand(r034B).val);
            exec_list *const f034A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f034A->then_instructions;

               body.emit(assign(r0349, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f034A->else_instructions;

               ir_variable *const r034C = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r034E = equal(r022F, body.constant(int(2045)));
               ir_if *f034D = new(mem_ctx) ir_if(operand(r034E).val);
               exec_list *const f034D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f034D->then_instructions;

                  ir_expression *const r034F = equal(body.constant(2097151u), r0337);
                  ir_expression *const r0350 = equal(body.constant(4294967295u), r0338);
                  body.emit(assign(r034C, logic_and(r034F, r0350), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f034D->else_instructions;

                  body.emit(assign(r034C, body.constant(false), 0x01));


               body.instructions = f034D_parent_instructions;
               body.emit(f034D);

               /* END IF */

               body.emit(assign(r0349, logic_and(r034C, r0345), 0x01));


            body.instructions = f034A_parent_instructions;
            body.emit(f034A);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0351 = new(mem_ctx) ir_if(operand(r0349).val);
            exec_list *const f0351_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0351->then_instructions;

               ir_variable *const r0352 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0352);
               ir_expression *const r0353 = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r0352, add(r0353, body.constant(2146435072u)), 0x02));

               body.emit(assign(r0352, body.constant(0u), 0x01));

               body.emit(assign(r0344, r0352, 0x03));

               body.emit(assign(r0343, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0351->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0355 = less(r022F, body.constant(int(0)));
               ir_if *f0354 = new(mem_ctx) ir_if(operand(r0355).val);
               exec_list *const f0354_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0354->then_instructions;

                  ir_variable *const r0356 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0356, r0230, 0x01));

                  ir_variable *const r0357 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0357, neg(r022F), 0x01));

                  ir_variable *const r0358 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0358);
                  ir_variable *const r0359 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0359);
                  ir_variable *const r035A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r035A);
                  ir_variable *const r035B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r035C = neg(r0357);
                  body.emit(assign(r035B, bit_and(r035C, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r035E = equal(r0357, body.constant(int(0)));
                  ir_if *f035D = new(mem_ctx) ir_if(operand(r035E).val);
                  exec_list *const f035D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f035D->then_instructions;

                     body.emit(assign(r0358, r0230, 0x01));

                     body.emit(assign(r0359, r0338, 0x01));

                     body.emit(assign(r035A, r0337, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f035D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0360 = less(r0357, body.constant(int(32)));
                     ir_if *f035F = new(mem_ctx) ir_if(operand(r0360).val);
                     exec_list *const f035F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f035F->then_instructions;

                        body.emit(assign(r0358, lshift(r0338, r035B), 0x01));

                        ir_expression *const r0361 = lshift(r0337, r035B);
                        ir_expression *const r0362 = rshift(r0338, r0357);
                        body.emit(assign(r0359, bit_or(r0361, r0362), 0x01));

                        body.emit(assign(r035A, rshift(r0337, r0357), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f035F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0364 = equal(r0357, body.constant(int(32)));
                        ir_if *f0363 = new(mem_ctx) ir_if(operand(r0364).val);
                        exec_list *const f0363_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0363->then_instructions;

                           body.emit(assign(r0358, r0338, 0x01));

                           body.emit(assign(r0359, r0337, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0363->else_instructions;

                           body.emit(assign(r0356, bit_or(r0230, r0338), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0366 = less(r0357, body.constant(int(64)));
                           ir_if *f0365 = new(mem_ctx) ir_if(operand(r0366).val);
                           exec_list *const f0365_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0365->then_instructions;

                              body.emit(assign(r0358, lshift(r0337, r035B), 0x01));

                              ir_expression *const r0367 = bit_and(r0357, body.constant(int(31)));
                              body.emit(assign(r0359, rshift(r0337, r0367), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0365->else_instructions;

                              ir_variable *const r0368 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r036A = equal(r0357, body.constant(int(64)));
                              ir_if *f0369 = new(mem_ctx) ir_if(operand(r036A).val);
                              exec_list *const f0369_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0369->then_instructions;

                                 body.emit(assign(r0368, r0337, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0369->else_instructions;

                                 ir_expression *const r036B = nequal(r0337, body.constant(0u));
                                 ir_expression *const r036C = expr(ir_unop_b2i, r036B);
                                 body.emit(assign(r0368, expr(ir_unop_i2u, r036C), 0x01));


                              body.instructions = f0369_parent_instructions;
                              body.emit(f0369);

                              /* END IF */

                              body.emit(assign(r0358, r0368, 0x01));

                              body.emit(assign(r0359, body.constant(0u), 0x01));


                           body.instructions = f0365_parent_instructions;
                           body.emit(f0365);

                           /* END IF */


                        body.instructions = f0363_parent_instructions;
                        body.emit(f0363);

                        /* END IF */

                        body.emit(assign(r035A, body.constant(0u), 0x01));


                     body.instructions = f035F_parent_instructions;
                     body.emit(f035F);

                     /* END IF */

                     ir_expression *const r036D = nequal(r0356, body.constant(0u));
                     ir_expression *const r036E = expr(ir_unop_b2i, r036D);
                     ir_expression *const r036F = expr(ir_unop_i2u, r036E);
                     body.emit(assign(r0358, bit_or(r0358, r036F), 0x01));


                  body.instructions = f035D_parent_instructions;
                  body.emit(f035D);

                  /* END IF */

                  body.emit(assign(r0340, r035A, 0x01));

                  body.emit(assign(r0341, r0359, 0x01));

                  body.emit(assign(r0342, r0358, 0x01));

                  body.emit(assign(r033F, body.constant(int(0)), 0x01));

                  body.emit(assign(r0345, less(r0358, body.constant(0u)), 0x01));


               body.instructions = f0354_parent_instructions;
               body.emit(f0354);

               /* END IF */


            body.instructions = f0351_parent_instructions;
            body.emit(f0351);

            /* END IF */


         body.instructions = f0347_parent_instructions;
         body.emit(f0347);

         /* END IF */

         /* IF CONDITION */
         ir_if *f0370 = new(mem_ctx) ir_if(operand(r0343).val);
         exec_list *const f0370_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0370->then_instructions;

            /* IF CONDITION */
            ir_if *f0371 = new(mem_ctx) ir_if(operand(r0345).val);
            exec_list *const f0371_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0371->then_instructions;

               ir_variable *const r0372 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0372, add(r0341, body.constant(1u)), 0x01));

               ir_expression *const r0373 = less(r0372, r0341);
               ir_expression *const r0374 = expr(ir_unop_b2i, r0373);
               ir_expression *const r0375 = expr(ir_unop_i2u, r0374);
               body.emit(assign(r0340, add(r0340, r0375), 0x01));

               ir_expression *const r0376 = equal(r0342, body.constant(0u));
               ir_expression *const r0377 = expr(ir_unop_b2i, r0376);
               ir_expression *const r0378 = expr(ir_unop_i2u, r0377);
               ir_expression *const r0379 = add(r0342, r0378);
               ir_expression *const r037A = bit_and(r0379, body.constant(1u));
               ir_expression *const r037B = expr(ir_unop_bit_not, r037A);
               body.emit(assign(r0341, bit_and(r0372, r037B), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0371->else_instructions;

               /* IF CONDITION */
               ir_expression *const r037D = bit_or(r0340, r0341);
               ir_expression *const r037E = equal(r037D, body.constant(0u));
               ir_if *f037C = new(mem_ctx) ir_if(operand(r037E).val);
               exec_list *const f037C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f037C->then_instructions;

                  body.emit(assign(r033F, body.constant(int(0)), 0x01));


               body.instructions = f037C_parent_instructions;
               body.emit(f037C);

               /* END IF */


            body.instructions = f0371_parent_instructions;
            body.emit(f0371);

            /* END IF */

            ir_variable *const r037F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r037F);
            ir_expression *const r0380 = lshift(r0227, body.constant(int(31)));
            ir_expression *const r0381 = expr(ir_unop_i2u, r033F);
            ir_expression *const r0382 = lshift(r0381, body.constant(int(20)));
            ir_expression *const r0383 = add(r0380, r0382);
            body.emit(assign(r037F, add(r0383, r0340), 0x02));

            body.emit(assign(r037F, r0341, 0x01));

            body.emit(assign(r0344, r037F, 0x03));

            body.emit(assign(r0343, body.constant(false), 0x01));


         body.instructions = f0370_parent_instructions;
         body.emit(f0370);

         /* END IF */

         body.emit(assign(r0229, r0344, 0x03));

         body.emit(assign(r0228, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f033D->else_instructions;

         body.emit(assign(r022F, add(r022F, body.constant(int(1))), 0x01));

         ir_variable *const r0384 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r0384);
         ir_variable *const r0385 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0385);
         ir_variable *const r0386 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0386);
         body.emit(assign(r0384, lshift(r0338, body.constant(int(31))), 0x01));

         ir_expression *const r0387 = lshift(r0337, body.constant(int(31)));
         ir_expression *const r0388 = rshift(r0338, body.constant(int(1)));
         body.emit(assign(r0385, bit_or(r0387, r0388), 0x01));

         body.emit(assign(r0386, rshift(r0337, body.constant(int(1))), 0x01));

         ir_expression *const r0389 = nequal(r0230, body.constant(0u));
         ir_expression *const r038A = expr(ir_unop_b2i, r0389);
         ir_expression *const r038B = expr(ir_unop_i2u, r038A);
         body.emit(assign(r0384, bit_or(r0384, r038B), 0x01));

         body.emit(assign(r0231, r0386, 0x01));

         body.emit(assign(r0230, r0384, 0x01));

         ir_variable *const r038C = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r038C, r022F, 0x01));

         ir_variable *const r038D = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r038D, r0386, 0x01));

         ir_variable *const r038E = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r038E, r0385, 0x01));

         ir_variable *const r038F = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r038F, r0384, 0x01));

         ir_variable *const r0390 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r0390, body.constant(true), 0x01));

         ir_variable *const r0391 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0392 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0392);
         ir_expression *const r0393 = expr(ir_unop_u2i, r0384);
         body.emit(assign(r0392, less(r0393, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0395 = lequal(body.constant(int(2045)), r022F);
         ir_if *f0394 = new(mem_ctx) ir_if(operand(r0395).val);
         exec_list *const f0394_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0394->then_instructions;

            ir_variable *const r0396 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0398 = less(body.constant(int(2045)), r022F);
            ir_if *f0397 = new(mem_ctx) ir_if(operand(r0398).val);
            exec_list *const f0397_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0397->then_instructions;

               body.emit(assign(r0396, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0397->else_instructions;

               ir_variable *const r0399 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r039B = equal(r022F, body.constant(int(2045)));
               ir_if *f039A = new(mem_ctx) ir_if(operand(r039B).val);
               exec_list *const f039A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f039A->then_instructions;

                  ir_expression *const r039C = equal(body.constant(2097151u), r0386);
                  ir_expression *const r039D = equal(body.constant(4294967295u), r0385);
                  body.emit(assign(r0399, logic_and(r039C, r039D), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f039A->else_instructions;

                  body.emit(assign(r0399, body.constant(false), 0x01));


               body.instructions = f039A_parent_instructions;
               body.emit(f039A);

               /* END IF */

               body.emit(assign(r0396, logic_and(r0399, r0392), 0x01));


            body.instructions = f0397_parent_instructions;
            body.emit(f0397);

            /* END IF */

            /* IF CONDITION */
            ir_if *f039E = new(mem_ctx) ir_if(operand(r0396).val);
            exec_list *const f039E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f039E->then_instructions;

               ir_variable *const r039F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r039F);
               ir_expression *const r03A0 = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r039F, add(r03A0, body.constant(2146435072u)), 0x02));

               body.emit(assign(r039F, body.constant(0u), 0x01));

               body.emit(assign(r0391, r039F, 0x03));

               body.emit(assign(r0390, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f039E->else_instructions;

               /* IF CONDITION */
               ir_expression *const r03A2 = less(r022F, body.constant(int(0)));
               ir_if *f03A1 = new(mem_ctx) ir_if(operand(r03A2).val);
               exec_list *const f03A1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f03A1->then_instructions;

                  ir_variable *const r03A3 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r03A3, r0384, 0x01));

                  ir_variable *const r03A4 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r03A4, neg(r022F), 0x01));

                  ir_variable *const r03A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r03A5);
                  ir_variable *const r03A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r03A6);
                  ir_variable *const r03A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r03A7);
                  ir_variable *const r03A8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r03A9 = neg(r03A4);
                  body.emit(assign(r03A8, bit_and(r03A9, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r03AB = equal(r03A4, body.constant(int(0)));
                  ir_if *f03AA = new(mem_ctx) ir_if(operand(r03AB).val);
                  exec_list *const f03AA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f03AA->then_instructions;

                     body.emit(assign(r03A5, r0384, 0x01));

                     body.emit(assign(r03A6, r0385, 0x01));

                     body.emit(assign(r03A7, r0386, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f03AA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r03AD = less(r03A4, body.constant(int(32)));
                     ir_if *f03AC = new(mem_ctx) ir_if(operand(r03AD).val);
                     exec_list *const f03AC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f03AC->then_instructions;

                        body.emit(assign(r03A5, lshift(r0385, r03A8), 0x01));

                        ir_expression *const r03AE = lshift(r0386, r03A8);
                        ir_expression *const r03AF = rshift(r0385, r03A4);
                        body.emit(assign(r03A6, bit_or(r03AE, r03AF), 0x01));

                        body.emit(assign(r03A7, rshift(r0386, r03A4), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f03AC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r03B1 = equal(r03A4, body.constant(int(32)));
                        ir_if *f03B0 = new(mem_ctx) ir_if(operand(r03B1).val);
                        exec_list *const f03B0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f03B0->then_instructions;

                           body.emit(assign(r03A5, r0385, 0x01));

                           body.emit(assign(r03A6, r0386, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f03B0->else_instructions;

                           body.emit(assign(r03A3, bit_or(r0384, r0385), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r03B3 = less(r03A4, body.constant(int(64)));
                           ir_if *f03B2 = new(mem_ctx) ir_if(operand(r03B3).val);
                           exec_list *const f03B2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f03B2->then_instructions;

                              body.emit(assign(r03A5, lshift(r0386, r03A8), 0x01));

                              ir_expression *const r03B4 = bit_and(r03A4, body.constant(int(31)));
                              body.emit(assign(r03A6, rshift(r0386, r03B4), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f03B2->else_instructions;

                              ir_variable *const r03B5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r03B7 = equal(r03A4, body.constant(int(64)));
                              ir_if *f03B6 = new(mem_ctx) ir_if(operand(r03B7).val);
                              exec_list *const f03B6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f03B6->then_instructions;

                                 body.emit(assign(r03B5, r0386, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f03B6->else_instructions;

                                 ir_expression *const r03B8 = nequal(r0386, body.constant(0u));
                                 ir_expression *const r03B9 = expr(ir_unop_b2i, r03B8);
                                 body.emit(assign(r03B5, expr(ir_unop_i2u, r03B9), 0x01));


                              body.instructions = f03B6_parent_instructions;
                              body.emit(f03B6);

                              /* END IF */

                              body.emit(assign(r03A5, r03B5, 0x01));

                              body.emit(assign(r03A6, body.constant(0u), 0x01));


                           body.instructions = f03B2_parent_instructions;
                           body.emit(f03B2);

                           /* END IF */


                        body.instructions = f03B0_parent_instructions;
                        body.emit(f03B0);

                        /* END IF */

                        body.emit(assign(r03A7, body.constant(0u), 0x01));


                     body.instructions = f03AC_parent_instructions;
                     body.emit(f03AC);

                     /* END IF */

                     ir_expression *const r03BA = nequal(r03A3, body.constant(0u));
                     ir_expression *const r03BB = expr(ir_unop_b2i, r03BA);
                     ir_expression *const r03BC = expr(ir_unop_i2u, r03BB);
                     body.emit(assign(r03A5, bit_or(r03A5, r03BC), 0x01));


                  body.instructions = f03AA_parent_instructions;
                  body.emit(f03AA);

                  /* END IF */

                  body.emit(assign(r038D, r03A7, 0x01));

                  body.emit(assign(r038E, r03A6, 0x01));

                  body.emit(assign(r038F, r03A5, 0x01));

                  body.emit(assign(r038C, body.constant(int(0)), 0x01));

                  body.emit(assign(r0392, less(r03A5, body.constant(0u)), 0x01));


               body.instructions = f03A1_parent_instructions;
               body.emit(f03A1);

               /* END IF */


            body.instructions = f039E_parent_instructions;
            body.emit(f039E);

            /* END IF */


         body.instructions = f0394_parent_instructions;
         body.emit(f0394);

         /* END IF */

         /* IF CONDITION */
         ir_if *f03BD = new(mem_ctx) ir_if(operand(r0390).val);
         exec_list *const f03BD_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03BD->then_instructions;

            /* IF CONDITION */
            ir_if *f03BE = new(mem_ctx) ir_if(operand(r0392).val);
            exec_list *const f03BE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f03BE->then_instructions;

               ir_variable *const r03BF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r03BF, add(r038E, body.constant(1u)), 0x01));

               ir_expression *const r03C0 = less(r03BF, r038E);
               ir_expression *const r03C1 = expr(ir_unop_b2i, r03C0);
               ir_expression *const r03C2 = expr(ir_unop_i2u, r03C1);
               body.emit(assign(r038D, add(r038D, r03C2), 0x01));

               ir_expression *const r03C3 = equal(r038F, body.constant(0u));
               ir_expression *const r03C4 = expr(ir_unop_b2i, r03C3);
               ir_expression *const r03C5 = expr(ir_unop_i2u, r03C4);
               ir_expression *const r03C6 = add(r038F, r03C5);
               ir_expression *const r03C7 = bit_and(r03C6, body.constant(1u));
               ir_expression *const r03C8 = expr(ir_unop_bit_not, r03C7);
               body.emit(assign(r038E, bit_and(r03BF, r03C8), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f03BE->else_instructions;

               /* IF CONDITION */
               ir_expression *const r03CA = bit_or(r038D, r038E);
               ir_expression *const r03CB = equal(r03CA, body.constant(0u));
               ir_if *f03C9 = new(mem_ctx) ir_if(operand(r03CB).val);
               exec_list *const f03C9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f03C9->then_instructions;

                  body.emit(assign(r038C, body.constant(int(0)), 0x01));


               body.instructions = f03C9_parent_instructions;
               body.emit(f03C9);

               /* END IF */


            body.instructions = f03BE_parent_instructions;
            body.emit(f03BE);

            /* END IF */

            ir_variable *const r03CC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r03CC);
            ir_expression *const r03CD = lshift(r0227, body.constant(int(31)));
            ir_expression *const r03CE = expr(ir_unop_i2u, r038C);
            ir_expression *const r03CF = lshift(r03CE, body.constant(int(20)));
            ir_expression *const r03D0 = add(r03CD, r03CF);
            body.emit(assign(r03CC, add(r03D0, r038D), 0x02));

            body.emit(assign(r03CC, r038E, 0x01));

            body.emit(assign(r0391, r03CC, 0x03));

            body.emit(assign(r0390, body.constant(false), 0x01));


         body.instructions = f03BD_parent_instructions;
         body.emit(f03BD);

         /* END IF */

         body.emit(assign(r0229, r0391, 0x03));

         body.emit(assign(r0228, body.constant(false), 0x01));


      body.instructions = f033D_parent_instructions;
      body.emit(f033D);

      /* END IF */


   body.instructions = f0336_parent_instructions;
   body.emit(f0336);

   /* END IF */

   body.emit(ret(r0229));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
subFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r03D1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r03D1);
   ir_variable *const r03D2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r03D2);
   ir_variable *const r03D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r03D3);
   ir_variable *const r03D4 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r03D5 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r03D5);
   ir_variable *const r03D6 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r03D6);
   ir_variable *const r03D7 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r03D7);
   ir_variable *const r03D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r03D8);
   ir_variable *const r03D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r03D9);
   ir_variable *const r03DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r03DA);
   ir_variable *const r03DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r03DB);
   ir_variable *const r03DC = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r03DC);
   ir_variable *const r03DD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03DE = rshift(swizzle_y(r03D1), body.constant(int(20)));
   ir_expression *const r03DF = bit_and(r03DE, body.constant(2047u));
   body.emit(assign(r03DD, expr(ir_unop_u2i, r03DF), 0x01));

   body.emit(assign(r03D7, r03DD, 0x01));

   ir_variable *const r03E0 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03E1 = rshift(swizzle_y(r03D2), body.constant(int(20)));
   ir_expression *const r03E2 = bit_and(r03E1, body.constant(2047u));
   body.emit(assign(r03E0, expr(ir_unop_u2i, r03E2), 0x01));

   body.emit(assign(r03D6, r03E0, 0x01));

   body.emit(assign(r03D5, sub(r03DD, r03E0), 0x01));

   ir_variable *const r03E3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E3, lshift(swizzle_x(r03D1), body.constant(int(10))), 0x01));

   ir_variable *const r03E4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03E5 = bit_and(swizzle_y(r03D1), body.constant(1048575u));
   ir_expression *const r03E6 = lshift(r03E5, body.constant(int(10)));
   ir_expression *const r03E7 = rshift(swizzle_x(r03D1), body.constant(int(22)));
   body.emit(assign(r03E4, bit_or(r03E6, r03E7), 0x01));

   body.emit(assign(r03DA, r03E4, 0x01));

   body.emit(assign(r03DB, r03E3, 0x01));

   ir_variable *const r03E8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E8, lshift(swizzle_x(r03D2), body.constant(int(10))), 0x01));

   ir_variable *const r03E9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03EA = bit_and(swizzle_y(r03D2), body.constant(1048575u));
   ir_expression *const r03EB = lshift(r03EA, body.constant(int(10)));
   ir_expression *const r03EC = rshift(swizzle_x(r03D2), body.constant(int(22)));
   body.emit(assign(r03E9, bit_or(r03EB, r03EC), 0x01));

   body.emit(assign(r03D8, r03E9, 0x01));

   body.emit(assign(r03D9, r03E8, 0x01));

   /* IF CONDITION */
   ir_expression *const r03EE = less(body.constant(int(0)), r03D5);
   ir_if *f03ED = new(mem_ctx) ir_if(operand(r03EE).val);
   exec_list *const f03ED_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f03ED->then_instructions;

      /* IF CONDITION */
      ir_expression *const r03F0 = equal(r03DD, body.constant(int(2047)));
      ir_if *f03EF = new(mem_ctx) ir_if(operand(r03F0).val);
      exec_list *const f03EF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f03EF->then_instructions;

         /* IF CONDITION */
         ir_expression *const r03F2 = bit_or(r03E4, r03E3);
         ir_expression *const r03F3 = nequal(r03F2, body.constant(0u));
         ir_if *f03F1 = new(mem_ctx) ir_if(operand(r03F3).val);
         exec_list *const f03F1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03F1->then_instructions;

            ir_variable *const r03F4 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r03F4, swizzle_x(r03D1), 0x01));

            ir_variable *const r03F5 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r03F5, swizzle_x(r03D2), 0x01));

            ir_variable *const r03F6 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r03F7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r03F8 = rshift(swizzle_y(r03D1), body.constant(int(19)));
            ir_expression *const r03F9 = bit_and(r03F8, body.constant(4095u));
            ir_expression *const r03FA = equal(r03F9, body.constant(4094u));
            ir_expression *const r03FB = nequal(swizzle_x(r03D1), body.constant(0u));
            ir_expression *const r03FC = bit_and(swizzle_y(r03D1), body.constant(524287u));
            ir_expression *const r03FD = nequal(r03FC, body.constant(0u));
            ir_expression *const r03FE = logic_or(r03FB, r03FD);
            body.emit(assign(r03F7, logic_and(r03FA, r03FE), 0x01));

            ir_variable *const r03FF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r0400 = lshift(swizzle_y(r03D2), body.constant(int(1)));
            ir_expression *const r0401 = lequal(body.constant(4292870144u), r0400);
            ir_expression *const r0402 = nequal(swizzle_x(r03D2), body.constant(0u));
            ir_expression *const r0403 = bit_and(swizzle_y(r03D2), body.constant(1048575u));
            ir_expression *const r0404 = nequal(r0403, body.constant(0u));
            ir_expression *const r0405 = logic_or(r0402, r0404);
            body.emit(assign(r03FF, logic_and(r0401, r0405), 0x01));

            body.emit(assign(r03F4, bit_or(swizzle_y(r03D1), body.constant(524288u)), 0x02));

            body.emit(assign(r03F5, bit_or(swizzle_y(r03D2), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0407 = lshift(swizzle_y(r03D1), body.constant(int(1)));
            ir_expression *const r0408 = lequal(body.constant(4292870144u), r0407);
            ir_expression *const r0409 = nequal(swizzle_x(r03D1), body.constant(0u));
            ir_expression *const r040A = bit_and(swizzle_y(r03D1), body.constant(1048575u));
            ir_expression *const r040B = nequal(r040A, body.constant(0u));
            ir_expression *const r040C = logic_or(r0409, r040B);
            ir_expression *const r040D = logic_and(r0408, r040C);
            ir_if *f0406 = new(mem_ctx) ir_if(operand(r040D).val);
            exec_list *const f0406_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0406->then_instructions;

               ir_variable *const r040E = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0410 = logic_and(r03F7, r03FF);
               ir_if *f040F = new(mem_ctx) ir_if(operand(r0410).val);
               exec_list *const f040F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f040F->then_instructions;

                  body.emit(assign(r040E, r03F5, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f040F->else_instructions;

                  body.emit(assign(r040E, r03F4, 0x03));


               body.instructions = f040F_parent_instructions;
               body.emit(f040F);

               /* END IF */

               body.emit(assign(r03F6, r040E, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0406->else_instructions;

               body.emit(assign(r03F6, r03F5, 0x03));


            body.instructions = f0406_parent_instructions;
            body.emit(f0406);

            /* END IF */

            body.emit(assign(r03D4, r03F6, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f03F1->else_instructions;

            body.emit(assign(r03D4, r03D1, 0x03));


         body.instructions = f03F1_parent_instructions;
         body.emit(f03F1);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f03EF->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0412 = equal(r03E0, body.constant(int(0)));
         ir_if *f0411 = new(mem_ctx) ir_if(operand(r0412).val);
         exec_list *const f0411_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0411->then_instructions;

            body.emit(assign(r03D5, add(r03D5, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0411->else_instructions;

            body.emit(assign(r03D8, bit_or(r03E9, body.constant(1073741824u)), 0x01));


         body.instructions = f0411_parent_instructions;
         body.emit(f0411);

         /* END IF */

         ir_variable *const r0413 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0413);
         ir_variable *const r0414 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0414);
         ir_variable *const r0415 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0416 = neg(r03D5);
         body.emit(assign(r0415, bit_and(r0416, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0418 = equal(r03D5, body.constant(int(0)));
         ir_if *f0417 = new(mem_ctx) ir_if(operand(r0418).val);
         exec_list *const f0417_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0417->then_instructions;

            body.emit(assign(r0413, r03E8, 0x01));

            body.emit(assign(r0414, r03D8, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0417->else_instructions;

            /* IF CONDITION */
            ir_expression *const r041A = less(r03D5, body.constant(int(32)));
            ir_if *f0419 = new(mem_ctx) ir_if(operand(r041A).val);
            exec_list *const f0419_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0419->then_instructions;

               ir_expression *const r041B = lshift(r03D8, r0415);
               ir_expression *const r041C = rshift(r03E8, r03D5);
               ir_expression *const r041D = bit_or(r041B, r041C);
               ir_expression *const r041E = lshift(r03E8, r0415);
               ir_expression *const r041F = nequal(r041E, body.constant(0u));
               ir_expression *const r0420 = expr(ir_unop_b2i, r041F);
               ir_expression *const r0421 = expr(ir_unop_i2u, r0420);
               body.emit(assign(r0413, bit_or(r041D, r0421), 0x01));

               body.emit(assign(r0414, rshift(r03D8, r03D5), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0419->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0423 = equal(r03D5, body.constant(int(32)));
               ir_if *f0422 = new(mem_ctx) ir_if(operand(r0423).val);
               exec_list *const f0422_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0422->then_instructions;

                  ir_expression *const r0424 = nequal(r03E8, body.constant(0u));
                  ir_expression *const r0425 = expr(ir_unop_b2i, r0424);
                  ir_expression *const r0426 = expr(ir_unop_i2u, r0425);
                  body.emit(assign(r0413, bit_or(r03D8, r0426), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0422->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0428 = less(r03D5, body.constant(int(64)));
                  ir_if *f0427 = new(mem_ctx) ir_if(operand(r0428).val);
                  exec_list *const f0427_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0427->then_instructions;

                     ir_expression *const r0429 = bit_and(r03D5, body.constant(int(31)));
                     ir_expression *const r042A = rshift(r03D8, r0429);
                     ir_expression *const r042B = lshift(r03D8, r0415);
                     ir_expression *const r042C = bit_or(r042B, r03E8);
                     ir_expression *const r042D = nequal(r042C, body.constant(0u));
                     ir_expression *const r042E = expr(ir_unop_b2i, r042D);
                     ir_expression *const r042F = expr(ir_unop_i2u, r042E);
                     body.emit(assign(r0413, bit_or(r042A, r042F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0427->else_instructions;

                     ir_expression *const r0430 = bit_or(r03D8, r03E8);
                     ir_expression *const r0431 = nequal(r0430, body.constant(0u));
                     ir_expression *const r0432 = expr(ir_unop_b2i, r0431);
                     body.emit(assign(r0413, expr(ir_unop_i2u, r0432), 0x01));


                  body.instructions = f0427_parent_instructions;
                  body.emit(f0427);

                  /* END IF */


               body.instructions = f0422_parent_instructions;
               body.emit(f0422);

               /* END IF */

               body.emit(assign(r0414, body.constant(0u), 0x01));


            body.instructions = f0419_parent_instructions;
            body.emit(f0419);

            /* END IF */


         body.instructions = f0417_parent_instructions;
         body.emit(f0417);

         /* END IF */

         body.emit(assign(r03D8, r0414, 0x01));

         body.emit(assign(r03D9, r0413, 0x01));

         body.emit(assign(r03DA, bit_or(r03E4, body.constant(1073741824u)), 0x01));

         ir_variable *const r0433 = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r0434 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r0434, sub(r03E3, r0413), 0x01));

         ir_expression *const r0435 = sub(r03DA, r0414);
         ir_expression *const r0436 = less(r03E3, r0413);
         ir_expression *const r0437 = expr(ir_unop_b2i, r0436);
         ir_expression *const r0438 = expr(ir_unop_i2u, r0437);
         body.emit(assign(r0433, sub(r0435, r0438), 0x01));

         body.emit(assign(r03DC, add(r03DD, body.constant(int(-1))), 0x01));

         ir_variable *const r0439 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0439, add(r03DC, body.constant(int(-10))), 0x01));

         ir_variable *const r043A = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r043A, r0433, 0x01));

         ir_variable *const r043B = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r043B, r0434, 0x01));

         ir_variable *const r043C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r043C);
         ir_variable *const r043D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r043D);
         /* IF CONDITION */
         ir_expression *const r043F = equal(r0433, body.constant(0u));
         ir_if *f043E = new(mem_ctx) ir_if(operand(r043F).val);
         exec_list *const f043E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f043E->then_instructions;

            body.emit(assign(r043A, r0434, 0x01));

            body.emit(assign(r043B, body.constant(0u), 0x01));

            body.emit(assign(r0439, add(r0439, body.constant(int(-32))), 0x01));


         body.instructions = f043E_parent_instructions;
         body.emit(f043E);

         /* END IF */

         ir_variable *const r0440 = body.make_temp(glsl_type::uint_type, "a");
         body.emit(assign(r0440, r043A, 0x01));

         ir_variable *const r0441 = body.make_temp(glsl_type::int_type, "return_value");
         ir_variable *const r0442 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r0442);
         /* IF CONDITION */
         ir_expression *const r0444 = equal(r043A, body.constant(0u));
         ir_if *f0443 = new(mem_ctx) ir_if(operand(r0444).val);
         exec_list *const f0443_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0443->then_instructions;

            body.emit(assign(r0441, body.constant(int(32)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0443->else_instructions;

            body.emit(assign(r0442, body.constant(int(0)), 0x01));

            /* IF CONDITION */
            ir_expression *const r0446 = bit_and(r043A, body.constant(4294901760u));
            ir_expression *const r0447 = equal(r0446, body.constant(0u));
            ir_if *f0445 = new(mem_ctx) ir_if(operand(r0447).val);
            exec_list *const f0445_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0445->then_instructions;

               body.emit(assign(r0442, body.constant(int(16)), 0x01));

               body.emit(assign(r0440, lshift(r043A, body.constant(int(16))), 0x01));


            body.instructions = f0445_parent_instructions;
            body.emit(f0445);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0449 = bit_and(r0440, body.constant(4278190080u));
            ir_expression *const r044A = equal(r0449, body.constant(0u));
            ir_if *f0448 = new(mem_ctx) ir_if(operand(r044A).val);
            exec_list *const f0448_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0448->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(8))), 0x01));

               body.emit(assign(r0440, lshift(r0440, body.constant(int(8))), 0x01));


            body.instructions = f0448_parent_instructions;
            body.emit(f0448);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044C = bit_and(r0440, body.constant(4026531840u));
            ir_expression *const r044D = equal(r044C, body.constant(0u));
            ir_if *f044B = new(mem_ctx) ir_if(operand(r044D).val);
            exec_list *const f044B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f044B->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(4))), 0x01));

               body.emit(assign(r0440, lshift(r0440, body.constant(int(4))), 0x01));


            body.instructions = f044B_parent_instructions;
            body.emit(f044B);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044F = bit_and(r0440, body.constant(3221225472u));
            ir_expression *const r0450 = equal(r044F, body.constant(0u));
            ir_if *f044E = new(mem_ctx) ir_if(operand(r0450).val);
            exec_list *const f044E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f044E->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(2))), 0x01));

               body.emit(assign(r0440, lshift(r0440, body.constant(int(2))), 0x01));


            body.instructions = f044E_parent_instructions;
            body.emit(f044E);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0452 = bit_and(r0440, body.constant(2147483648u));
            ir_expression *const r0453 = equal(r0452, body.constant(0u));
            ir_if *f0451 = new(mem_ctx) ir_if(operand(r0453).val);
            exec_list *const f0451_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0451->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(1))), 0x01));


            body.instructions = f0451_parent_instructions;
            body.emit(f0451);

            /* END IF */

            body.emit(assign(r0441, r0442, 0x01));


         body.instructions = f0443_parent_instructions;
         body.emit(f0443);

         /* END IF */

         body.emit(assign(r043D, add(r0441, body.constant(int(-11))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0455 = lequal(body.constant(int(0)), r043D);
         ir_if *f0454 = new(mem_ctx) ir_if(operand(r0455).val);
         exec_list *const f0454_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0454->then_instructions;

            body.emit(assign(r043C, body.constant(0u), 0x01));

            ir_variable *const r0456 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0456, lshift(r043B, r043D), 0x01));

            ir_variable *const r0457 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r0459 = equal(r043D, body.constant(int(0)));
            ir_if *f0458 = new(mem_ctx) ir_if(operand(r0459).val);
            exec_list *const f0458_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0458->then_instructions;

               body.emit(assign(r0457, r043A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0458->else_instructions;

               ir_expression *const r045A = lshift(r043A, r043D);
               ir_expression *const r045B = neg(r043D);
               ir_expression *const r045C = bit_and(r045B, body.constant(int(31)));
               ir_expression *const r045D = rshift(r043B, r045C);
               body.emit(assign(r0457, bit_or(r045A, r045D), 0x01));


            body.instructions = f0458_parent_instructions;
            body.emit(f0458);

            /* END IF */

            body.emit(assign(r043A, r0457, 0x01));

            body.emit(assign(r043B, r0456, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0454->else_instructions;

            ir_variable *const r045E = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r045E, body.constant(0u), 0x01));

            ir_variable *const r045F = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r045F, neg(r043D), 0x01));

            ir_variable *const r0460 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r0460);
            ir_variable *const r0461 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0461);
            ir_variable *const r0462 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0462);
            ir_variable *const r0463 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0464 = neg(r045F);
            body.emit(assign(r0463, bit_and(r0464, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0466 = equal(r045F, body.constant(int(0)));
            ir_if *f0465 = new(mem_ctx) ir_if(operand(r0466).val);
            exec_list *const f0465_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0465->then_instructions;

               body.emit(assign(r0460, r045E, 0x01));

               body.emit(assign(r0461, r043B, 0x01));

               body.emit(assign(r0462, r043A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0465->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0468 = less(r045F, body.constant(int(32)));
               ir_if *f0467 = new(mem_ctx) ir_if(operand(r0468).val);
               exec_list *const f0467_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0467->then_instructions;

                  body.emit(assign(r0460, lshift(r043B, r0463), 0x01));

                  ir_expression *const r0469 = lshift(r043A, r0463);
                  ir_expression *const r046A = rshift(r043B, r045F);
                  body.emit(assign(r0461, bit_or(r0469, r046A), 0x01));

                  body.emit(assign(r0462, rshift(r043A, r045F), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0467->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r046C = equal(r045F, body.constant(int(32)));
                  ir_if *f046B = new(mem_ctx) ir_if(operand(r046C).val);
                  exec_list *const f046B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f046B->then_instructions;

                     body.emit(assign(r0460, r043B, 0x01));

                     body.emit(assign(r0461, r043A, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f046B->else_instructions;

                     body.emit(assign(r045E, bit_or(body.constant(0u), r043B), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r046E = less(r045F, body.constant(int(64)));
                     ir_if *f046D = new(mem_ctx) ir_if(operand(r046E).val);
                     exec_list *const f046D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f046D->then_instructions;

                        body.emit(assign(r0460, lshift(r043A, r0463), 0x01));

                        ir_expression *const r046F = bit_and(r045F, body.constant(int(31)));
                        body.emit(assign(r0461, rshift(r043A, r046F), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f046D->else_instructions;

                        ir_variable *const r0470 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0472 = equal(r045F, body.constant(int(64)));
                        ir_if *f0471 = new(mem_ctx) ir_if(operand(r0472).val);
                        exec_list *const f0471_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0471->then_instructions;

                           body.emit(assign(r0470, r043A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0471->else_instructions;

                           ir_expression *const r0473 = nequal(r043A, body.constant(0u));
                           ir_expression *const r0474 = expr(ir_unop_b2i, r0473);
                           body.emit(assign(r0470, expr(ir_unop_i2u, r0474), 0x01));


                        body.instructions = f0471_parent_instructions;
                        body.emit(f0471);

                        /* END IF */

                        body.emit(assign(r0460, r0470, 0x01));

                        body.emit(assign(r0461, body.constant(0u), 0x01));


                     body.instructions = f046D_parent_instructions;
                     body.emit(f046D);

                     /* END IF */


                  body.instructions = f046B_parent_instructions;
                  body.emit(f046B);

                  /* END IF */

                  body.emit(assign(r0462, body.constant(0u), 0x01));


               body.instructions = f0467_parent_instructions;
               body.emit(f0467);

               /* END IF */

               ir_expression *const r0475 = nequal(r045E, body.constant(0u));
               ir_expression *const r0476 = expr(ir_unop_b2i, r0475);
               ir_expression *const r0477 = expr(ir_unop_i2u, r0476);
               body.emit(assign(r0460, bit_or(r0460, r0477), 0x01));


            body.instructions = f0465_parent_instructions;
            body.emit(f0465);

            /* END IF */

            body.emit(assign(r043A, r0462, 0x01));

            body.emit(assign(r043B, r0461, 0x01));

            body.emit(assign(r043C, r0460, 0x01));


         body.instructions = f0454_parent_instructions;
         body.emit(f0454);

         /* END IF */

         body.emit(assign(r0439, sub(r0439, r043D), 0x01));

         ir_variable *const r0478 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0478, r0439, 0x01));

         ir_variable *const r0479 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0479, r043A, 0x01));

         ir_variable *const r047A = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r047A, r043B, 0x01));

         ir_variable *const r047B = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r047B, r043C, 0x01));

         ir_variable *const r047C = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r047C, body.constant(true), 0x01));

         ir_variable *const r047D = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r047E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r047E);
         ir_expression *const r047F = expr(ir_unop_u2i, r043C);
         body.emit(assign(r047E, less(r047F, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0481 = lequal(body.constant(int(2045)), r0439);
         ir_if *f0480 = new(mem_ctx) ir_if(operand(r0481).val);
         exec_list *const f0480_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0480->then_instructions;

            ir_variable *const r0482 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0484 = less(body.constant(int(2045)), r0439);
            ir_if *f0483 = new(mem_ctx) ir_if(operand(r0484).val);
            exec_list *const f0483_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0483->then_instructions;

               body.emit(assign(r0482, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0483->else_instructions;

               ir_variable *const r0485 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r0487 = equal(r0439, body.constant(int(2045)));
               ir_if *f0486 = new(mem_ctx) ir_if(operand(r0487).val);
               exec_list *const f0486_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0486->then_instructions;

                  ir_expression *const r0488 = equal(body.constant(2097151u), r043A);
                  ir_expression *const r0489 = equal(body.constant(4294967295u), r043B);
                  body.emit(assign(r0485, logic_and(r0488, r0489), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0486->else_instructions;

                  body.emit(assign(r0485, body.constant(false), 0x01));


               body.instructions = f0486_parent_instructions;
               body.emit(f0486);

               /* END IF */

               body.emit(assign(r0482, logic_and(r0485, r047E), 0x01));


            body.instructions = f0483_parent_instructions;
            body.emit(f0483);

            /* END IF */

            /* IF CONDITION */
            ir_if *f048A = new(mem_ctx) ir_if(operand(r0482).val);
            exec_list *const f048A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f048A->then_instructions;

               ir_variable *const r048B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r048B);
               ir_expression *const r048C = lshift(r03D3, body.constant(int(31)));
               body.emit(assign(r048B, add(r048C, body.constant(2146435072u)), 0x02));

               body.emit(assign(r048B, body.constant(0u), 0x01));

               body.emit(assign(r047D, r048B, 0x03));

               body.emit(assign(r047C, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f048A->else_instructions;

               /* IF CONDITION */
               ir_expression *const r048E = less(r0439, body.constant(int(0)));
               ir_if *f048D = new(mem_ctx) ir_if(operand(r048E).val);
               exec_list *const f048D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f048D->then_instructions;

                  ir_variable *const r048F = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r048F, r043C, 0x01));

                  ir_variable *const r0490 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0490, neg(r0439), 0x01));

                  ir_variable *const r0491 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0491);
                  ir_variable *const r0492 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0492);
                  ir_variable *const r0493 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0493);
                  ir_variable *const r0494 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0495 = neg(r0490);
                  body.emit(assign(r0494, bit_and(r0495, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0497 = equal(r0490, body.constant(int(0)));
                  ir_if *f0496 = new(mem_ctx) ir_if(operand(r0497).val);
                  exec_list *const f0496_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0496->then_instructions;

                     body.emit(assign(r0491, r043C, 0x01));

                     body.emit(assign(r0492, r043B, 0x01));

                     body.emit(assign(r0493, r043A, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0496->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0499 = less(r0490, body.constant(int(32)));
                     ir_if *f0498 = new(mem_ctx) ir_if(operand(r0499).val);
                     exec_list *const f0498_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0498->then_instructions;

                        body.emit(assign(r0491, lshift(r043B, r0494), 0x01));

                        ir_expression *const r049A = lshift(r043A, r0494);
                        ir_expression *const r049B = rshift(r043B, r0490);
                        body.emit(assign(r0492, bit_or(r049A, r049B), 0x01));

                        body.emit(assign(r0493, rshift(r043A, r0490), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0498->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r049D = equal(r0490, body.constant(int(32)));
                        ir_if *f049C = new(mem_ctx) ir_if(operand(r049D).val);
                        exec_list *const f049C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f049C->then_instructions;

                           body.emit(assign(r0491, r043B, 0x01));

                           body.emit(assign(r0492, r043A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f049C->else_instructions;

                           body.emit(assign(r048F, bit_or(r043C, r043B), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r049F = less(r0490, body.constant(int(64)));
                           ir_if *f049E = new(mem_ctx) ir_if(operand(r049F).val);
                           exec_list *const f049E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f049E->then_instructions;

                              body.emit(assign(r0491, lshift(r043A, r0494), 0x01));

                              ir_expression *const r04A0 = bit_and(r0490, body.constant(int(31)));
                              body.emit(assign(r0492, rshift(r043A, r04A0), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f049E->else_instructions;

                              ir_variable *const r04A1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r04A3 = equal(r0490, body.constant(int(64)));
                              ir_if *f04A2 = new(mem_ctx) ir_if(operand(r04A3).val);
                              exec_list *const f04A2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f04A2->then_instructions;

                                 body.emit(assign(r04A1, r043A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f04A2->else_instructions;

                                 ir_expression *const r04A4 = nequal(r043A, body.constant(0u));
                                 ir_expression *const r04A5 = expr(ir_unop_b2i, r04A4);
                                 body.emit(assign(r04A1, expr(ir_unop_i2u, r04A5), 0x01));


                              body.instructions = f04A2_parent_instructions;
                              body.emit(f04A2);

                              /* END IF */

                              body.emit(assign(r0491, r04A1, 0x01));

                              body.emit(assign(r0492, body.constant(0u), 0x01));


                           body.instructions = f049E_parent_instructions;
                           body.emit(f049E);

                           /* END IF */


                        body.instructions = f049C_parent_instructions;
                        body.emit(f049C);

                        /* END IF */

                        body.emit(assign(r0493, body.constant(0u), 0x01));


                     body.instructions = f0498_parent_instructions;
                     body.emit(f0498);

                     /* END IF */

                     ir_expression *const r04A6 = nequal(r048F, body.constant(0u));
                     ir_expression *const r04A7 = expr(ir_unop_b2i, r04A6);
                     ir_expression *const r04A8 = expr(ir_unop_i2u, r04A7);
                     body.emit(assign(r0491, bit_or(r0491, r04A8), 0x01));


                  body.instructions = f0496_parent_instructions;
                  body.emit(f0496);

                  /* END IF */

                  body.emit(assign(r0479, r0493, 0x01));

                  body.emit(assign(r047A, r0492, 0x01));

                  body.emit(assign(r047B, r0491, 0x01));

                  body.emit(assign(r0478, body.constant(int(0)), 0x01));

                  body.emit(assign(r047E, less(r0491, body.constant(0u)), 0x01));


               body.instructions = f048D_parent_instructions;
               body.emit(f048D);

               /* END IF */


            body.instructions = f048A_parent_instructions;
            body.emit(f048A);

            /* END IF */


         body.instructions = f0480_parent_instructions;
         body.emit(f0480);

         /* END IF */

         /* IF CONDITION */
         ir_if *f04A9 = new(mem_ctx) ir_if(operand(r047C).val);
         exec_list *const f04A9_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04A9->then_instructions;

            /* IF CONDITION */
            ir_if *f04AA = new(mem_ctx) ir_if(operand(r047E).val);
            exec_list *const f04AA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04AA->then_instructions;

               ir_variable *const r04AB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r04AB, add(r047A, body.constant(1u)), 0x01));

               ir_expression *const r04AC = less(r04AB, r047A);
               ir_expression *const r04AD = expr(ir_unop_b2i, r04AC);
               ir_expression *const r04AE = expr(ir_unop_i2u, r04AD);
               body.emit(assign(r0479, add(r0479, r04AE), 0x01));

               ir_expression *const r04AF = equal(r047B, body.constant(0u));
               ir_expression *const r04B0 = expr(ir_unop_b2i, r04AF);
               ir_expression *const r04B1 = expr(ir_unop_i2u, r04B0);
               ir_expression *const r04B2 = add(r047B, r04B1);
               ir_expression *const r04B3 = bit_and(r04B2, body.constant(1u));
               ir_expression *const r04B4 = expr(ir_unop_bit_not, r04B3);
               body.emit(assign(r047A, bit_and(r04AB, r04B4), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04AA->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04B6 = bit_or(r0479, r047A);
               ir_expression *const r04B7 = equal(r04B6, body.constant(0u));
               ir_if *f04B5 = new(mem_ctx) ir_if(operand(r04B7).val);
               exec_list *const f04B5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04B5->then_instructions;

                  body.emit(assign(r0478, body.constant(int(0)), 0x01));


               body.instructions = f04B5_parent_instructions;
               body.emit(f04B5);

               /* END IF */


            body.instructions = f04AA_parent_instructions;
            body.emit(f04AA);

            /* END IF */

            ir_variable *const r04B8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r04B8);
            ir_expression *const r04B9 = lshift(r03D3, body.constant(int(31)));
            ir_expression *const r04BA = expr(ir_unop_i2u, r0478);
            ir_expression *const r04BB = lshift(r04BA, body.constant(int(20)));
            ir_expression *const r04BC = add(r04B9, r04BB);
            body.emit(assign(r04B8, add(r04BC, r0479), 0x02));

            body.emit(assign(r04B8, r047A, 0x01));

            body.emit(assign(r047D, r04B8, 0x03));

            body.emit(assign(r047C, body.constant(false), 0x01));


         body.instructions = f04A9_parent_instructions;
         body.emit(f04A9);

         /* END IF */

         body.emit(assign(r03D4, r047D, 0x03));


      body.instructions = f03EF_parent_instructions;
      body.emit(f03EF);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f03ED->else_instructions;

      /* IF CONDITION */
      ir_expression *const r04BE = less(r03D5, body.constant(int(0)));
      ir_if *f04BD = new(mem_ctx) ir_if(operand(r04BE).val);
      exec_list *const f04BD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f04BD->then_instructions;

         /* IF CONDITION */
         ir_expression *const r04C0 = equal(r03E0, body.constant(int(2047)));
         ir_if *f04BF = new(mem_ctx) ir_if(operand(r04C0).val);
         exec_list *const f04BF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04BF->then_instructions;

            /* IF CONDITION */
            ir_expression *const r04C2 = bit_or(r03D8, r03D9);
            ir_expression *const r04C3 = nequal(r04C2, body.constant(0u));
            ir_if *f04C1 = new(mem_ctx) ir_if(operand(r04C3).val);
            exec_list *const f04C1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04C1->then_instructions;

               ir_variable *const r04C4 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r04C4, swizzle_x(r03D1), 0x01));

               ir_variable *const r04C5 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r04C5, swizzle_x(r03D2), 0x01));

               ir_variable *const r04C6 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r04C7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r04C8 = rshift(swizzle_y(r03D1), body.constant(int(19)));
               ir_expression *const r04C9 = bit_and(r04C8, body.constant(4095u));
               ir_expression *const r04CA = equal(r04C9, body.constant(4094u));
               ir_expression *const r04CB = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r04CC = bit_and(swizzle_y(r03D1), body.constant(524287u));
               ir_expression *const r04CD = nequal(r04CC, body.constant(0u));
               ir_expression *const r04CE = logic_or(r04CB, r04CD);
               body.emit(assign(r04C7, logic_and(r04CA, r04CE), 0x01));

               ir_variable *const r04CF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r04D0 = lshift(swizzle_y(r03D2), body.constant(int(1)));
               ir_expression *const r04D1 = lequal(body.constant(4292870144u), r04D0);
               ir_expression *const r04D2 = nequal(swizzle_x(r03D2), body.constant(0u));
               ir_expression *const r04D3 = bit_and(swizzle_y(r03D2), body.constant(1048575u));
               ir_expression *const r04D4 = nequal(r04D3, body.constant(0u));
               ir_expression *const r04D5 = logic_or(r04D2, r04D4);
               body.emit(assign(r04CF, logic_and(r04D1, r04D5), 0x01));

               body.emit(assign(r04C4, bit_or(swizzle_y(r03D1), body.constant(524288u)), 0x02));

               body.emit(assign(r04C5, bit_or(swizzle_y(r03D2), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r04D7 = lshift(swizzle_y(r03D1), body.constant(int(1)));
               ir_expression *const r04D8 = lequal(body.constant(4292870144u), r04D7);
               ir_expression *const r04D9 = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r04DA = bit_and(swizzle_y(r03D1), body.constant(1048575u));
               ir_expression *const r04DB = nequal(r04DA, body.constant(0u));
               ir_expression *const r04DC = logic_or(r04D9, r04DB);
               ir_expression *const r04DD = logic_and(r04D8, r04DC);
               ir_if *f04D6 = new(mem_ctx) ir_if(operand(r04DD).val);
               exec_list *const f04D6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04D6->then_instructions;

                  ir_variable *const r04DE = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r04E0 = logic_and(r04C7, r04CF);
                  ir_if *f04DF = new(mem_ctx) ir_if(operand(r04E0).val);
                  exec_list *const f04DF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04DF->then_instructions;

                     body.emit(assign(r04DE, r04C5, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04DF->else_instructions;

                     body.emit(assign(r04DE, r04C4, 0x03));


                  body.instructions = f04DF_parent_instructions;
                  body.emit(f04DF);

                  /* END IF */

                  body.emit(assign(r04C6, r04DE, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04D6->else_instructions;

                  body.emit(assign(r04C6, r04C5, 0x03));


               body.instructions = f04D6_parent_instructions;
               body.emit(f04D6);

               /* END IF */

               body.emit(assign(r03D4, r04C6, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04C1->else_instructions;

               ir_variable *const r04E1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r04E1);
               ir_expression *const r04E2 = bit_xor(r03D3, body.constant(1u));
               ir_expression *const r04E3 = lshift(r04E2, body.constant(int(31)));
               body.emit(assign(r04E1, add(r04E3, body.constant(2146435072u)), 0x02));

               body.emit(assign(r04E1, body.constant(0u), 0x01));

               body.emit(assign(r03D4, r04E1, 0x03));


            body.instructions = f04C1_parent_instructions;
            body.emit(f04C1);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f04BF->else_instructions;

            /* IF CONDITION */
            ir_expression *const r04E5 = equal(r03DD, body.constant(int(0)));
            ir_if *f04E4 = new(mem_ctx) ir_if(operand(r04E5).val);
            exec_list *const f04E4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04E4->then_instructions;

               body.emit(assign(r03D5, add(r03D5, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04E4->else_instructions;

               body.emit(assign(r03DA, bit_or(r03DA, body.constant(1073741824u)), 0x01));


            body.instructions = f04E4_parent_instructions;
            body.emit(f04E4);

            /* END IF */

            ir_variable *const r04E6 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r04E6, neg(r03D5), 0x01));

            ir_variable *const r04E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r04E7);
            ir_variable *const r04E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r04E8);
            ir_variable *const r04E9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r04EA = neg(r04E6);
            body.emit(assign(r04E9, bit_and(r04EA, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r04EC = equal(r04E6, body.constant(int(0)));
            ir_if *f04EB = new(mem_ctx) ir_if(operand(r04EC).val);
            exec_list *const f04EB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04EB->then_instructions;

               body.emit(assign(r04E7, r03E3, 0x01));

               body.emit(assign(r04E8, r03DA, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04EB->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04EE = less(r04E6, body.constant(int(32)));
               ir_if *f04ED = new(mem_ctx) ir_if(operand(r04EE).val);
               exec_list *const f04ED_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04ED->then_instructions;

                  ir_expression *const r04EF = lshift(r03DA, r04E9);
                  ir_expression *const r04F0 = rshift(r03E3, r04E6);
                  ir_expression *const r04F1 = bit_or(r04EF, r04F0);
                  ir_expression *const r04F2 = lshift(r03E3, r04E9);
                  ir_expression *const r04F3 = nequal(r04F2, body.constant(0u));
                  ir_expression *const r04F4 = expr(ir_unop_b2i, r04F3);
                  ir_expression *const r04F5 = expr(ir_unop_i2u, r04F4);
                  body.emit(assign(r04E7, bit_or(r04F1, r04F5), 0x01));

                  body.emit(assign(r04E8, rshift(r03DA, r04E6), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04ED->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r04F7 = equal(r04E6, body.constant(int(32)));
                  ir_if *f04F6 = new(mem_ctx) ir_if(operand(r04F7).val);
                  exec_list *const f04F6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04F6->then_instructions;

                     ir_expression *const r04F8 = nequal(r03E3, body.constant(0u));
                     ir_expression *const r04F9 = expr(ir_unop_b2i, r04F8);
                     ir_expression *const r04FA = expr(ir_unop_i2u, r04F9);
                     body.emit(assign(r04E7, bit_or(r03DA, r04FA), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04F6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r04FC = less(r04E6, body.constant(int(64)));
                     ir_if *f04FB = new(mem_ctx) ir_if(operand(r04FC).val);
                     exec_list *const f04FB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f04FB->then_instructions;

                        ir_expression *const r04FD = bit_and(r04E6, body.constant(int(31)));
                        ir_expression *const r04FE = rshift(r03DA, r04FD);
                        ir_expression *const r04FF = lshift(r03DA, r04E9);
                        ir_expression *const r0500 = bit_or(r04FF, r03E3);
                        ir_expression *const r0501 = nequal(r0500, body.constant(0u));
                        ir_expression *const r0502 = expr(ir_unop_b2i, r0501);
                        ir_expression *const r0503 = expr(ir_unop_i2u, r0502);
                        body.emit(assign(r04E7, bit_or(r04FE, r0503), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f04FB->else_instructions;

                        ir_expression *const r0504 = bit_or(r03DA, r03E3);
                        ir_expression *const r0505 = nequal(r0504, body.constant(0u));
                        ir_expression *const r0506 = expr(ir_unop_b2i, r0505);
                        body.emit(assign(r04E7, expr(ir_unop_i2u, r0506), 0x01));


                     body.instructions = f04FB_parent_instructions;
                     body.emit(f04FB);

                     /* END IF */


                  body.instructions = f04F6_parent_instructions;
                  body.emit(f04F6);

                  /* END IF */

                  body.emit(assign(r04E8, body.constant(0u), 0x01));


               body.instructions = f04ED_parent_instructions;
               body.emit(f04ED);

               /* END IF */


            body.instructions = f04EB_parent_instructions;
            body.emit(f04EB);

            /* END IF */

            body.emit(assign(r03DA, r04E8, 0x01));

            body.emit(assign(r03DB, r04E7, 0x01));

            body.emit(assign(r03D8, bit_or(r03D8, body.constant(1073741824u)), 0x01));

            ir_variable *const r0507 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r0508 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0508, sub(r03D9, r04E7), 0x01));

            ir_expression *const r0509 = sub(r03D8, r04E8);
            ir_expression *const r050A = less(r03D9, r04E7);
            ir_expression *const r050B = expr(ir_unop_b2i, r050A);
            ir_expression *const r050C = expr(ir_unop_i2u, r050B);
            body.emit(assign(r0507, sub(r0509, r050C), 0x01));

            body.emit(assign(r03D3, bit_xor(r03D3, body.constant(1u)), 0x01));

            body.emit(assign(r03DC, add(r03E0, body.constant(int(-1))), 0x01));

            ir_variable *const r050D = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r050D, add(r03DC, body.constant(int(-10))), 0x01));

            ir_variable *const r050E = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r050E, r0507, 0x01));

            ir_variable *const r050F = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r050F, r0508, 0x01));

            ir_variable *const r0510 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0510);
            ir_variable *const r0511 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0511);
            /* IF CONDITION */
            ir_expression *const r0513 = equal(r0507, body.constant(0u));
            ir_if *f0512 = new(mem_ctx) ir_if(operand(r0513).val);
            exec_list *const f0512_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0512->then_instructions;

               body.emit(assign(r050E, r0508, 0x01));

               body.emit(assign(r050F, body.constant(0u), 0x01));

               body.emit(assign(r050D, add(r050D, body.constant(int(-32))), 0x01));


            body.instructions = f0512_parent_instructions;
            body.emit(f0512);

            /* END IF */

            ir_variable *const r0514 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0514, r050E, 0x01));

            ir_variable *const r0515 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0516 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0516);
            /* IF CONDITION */
            ir_expression *const r0518 = equal(r050E, body.constant(0u));
            ir_if *f0517 = new(mem_ctx) ir_if(operand(r0518).val);
            exec_list *const f0517_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0517->then_instructions;

               body.emit(assign(r0515, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0517->else_instructions;

               body.emit(assign(r0516, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r051A = bit_and(r050E, body.constant(4294901760u));
               ir_expression *const r051B = equal(r051A, body.constant(0u));
               ir_if *f0519 = new(mem_ctx) ir_if(operand(r051B).val);
               exec_list *const f0519_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0519->then_instructions;

                  body.emit(assign(r0516, body.constant(int(16)), 0x01));

                  body.emit(assign(r0514, lshift(r050E, body.constant(int(16))), 0x01));


               body.instructions = f0519_parent_instructions;
               body.emit(f0519);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r051D = bit_and(r0514, body.constant(4278190080u));
               ir_expression *const r051E = equal(r051D, body.constant(0u));
               ir_if *f051C = new(mem_ctx) ir_if(operand(r051E).val);
               exec_list *const f051C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051C->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(8))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(8))), 0x01));


               body.instructions = f051C_parent_instructions;
               body.emit(f051C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0520 = bit_and(r0514, body.constant(4026531840u));
               ir_expression *const r0521 = equal(r0520, body.constant(0u));
               ir_if *f051F = new(mem_ctx) ir_if(operand(r0521).val);
               exec_list *const f051F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051F->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(4))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(4))), 0x01));


               body.instructions = f051F_parent_instructions;
               body.emit(f051F);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0523 = bit_and(r0514, body.constant(3221225472u));
               ir_expression *const r0524 = equal(r0523, body.constant(0u));
               ir_if *f0522 = new(mem_ctx) ir_if(operand(r0524).val);
               exec_list *const f0522_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0522->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(2))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(2))), 0x01));


               body.instructions = f0522_parent_instructions;
               body.emit(f0522);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0526 = bit_and(r0514, body.constant(2147483648u));
               ir_expression *const r0527 = equal(r0526, body.constant(0u));
               ir_if *f0525 = new(mem_ctx) ir_if(operand(r0527).val);
               exec_list *const f0525_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0525->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(1))), 0x01));


               body.instructions = f0525_parent_instructions;
               body.emit(f0525);

               /* END IF */

               body.emit(assign(r0515, r0516, 0x01));


            body.instructions = f0517_parent_instructions;
            body.emit(f0517);

            /* END IF */

            body.emit(assign(r0511, add(r0515, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0529 = lequal(body.constant(int(0)), r0511);
            ir_if *f0528 = new(mem_ctx) ir_if(operand(r0529).val);
            exec_list *const f0528_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0528->then_instructions;

               body.emit(assign(r0510, body.constant(0u), 0x01));

               ir_variable *const r052A = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r052A, lshift(r050F, r0511), 0x01));

               ir_variable *const r052B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r052D = equal(r0511, body.constant(int(0)));
               ir_if *f052C = new(mem_ctx) ir_if(operand(r052D).val);
               exec_list *const f052C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f052C->then_instructions;

                  body.emit(assign(r052B, r050E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f052C->else_instructions;

                  ir_expression *const r052E = lshift(r050E, r0511);
                  ir_expression *const r052F = neg(r0511);
                  ir_expression *const r0530 = bit_and(r052F, body.constant(int(31)));
                  ir_expression *const r0531 = rshift(r050F, r0530);
                  body.emit(assign(r052B, bit_or(r052E, r0531), 0x01));


               body.instructions = f052C_parent_instructions;
               body.emit(f052C);

               /* END IF */

               body.emit(assign(r050E, r052B, 0x01));

               body.emit(assign(r050F, r052A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0528->else_instructions;

               ir_variable *const r0532 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0532, body.constant(0u), 0x01));

               ir_variable *const r0533 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0533, neg(r0511), 0x01));

               ir_variable *const r0534 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0534);
               ir_variable *const r0535 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0535);
               ir_variable *const r0536 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0536);
               ir_variable *const r0537 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0538 = neg(r0533);
               body.emit(assign(r0537, bit_and(r0538, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r053A = equal(r0533, body.constant(int(0)));
               ir_if *f0539 = new(mem_ctx) ir_if(operand(r053A).val);
               exec_list *const f0539_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0539->then_instructions;

                  body.emit(assign(r0534, r0532, 0x01));

                  body.emit(assign(r0535, r050F, 0x01));

                  body.emit(assign(r0536, r050E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0539->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r053C = less(r0533, body.constant(int(32)));
                  ir_if *f053B = new(mem_ctx) ir_if(operand(r053C).val);
                  exec_list *const f053B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f053B->then_instructions;

                     body.emit(assign(r0534, lshift(r050F, r0537), 0x01));

                     ir_expression *const r053D = lshift(r050E, r0537);
                     ir_expression *const r053E = rshift(r050F, r0533);
                     body.emit(assign(r0535, bit_or(r053D, r053E), 0x01));

                     body.emit(assign(r0536, rshift(r050E, r0533), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f053B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0540 = equal(r0533, body.constant(int(32)));
                     ir_if *f053F = new(mem_ctx) ir_if(operand(r0540).val);
                     exec_list *const f053F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f053F->then_instructions;

                        body.emit(assign(r0534, r050F, 0x01));

                        body.emit(assign(r0535, r050E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f053F->else_instructions;

                        body.emit(assign(r0532, bit_or(body.constant(0u), r050F), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0542 = less(r0533, body.constant(int(64)));
                        ir_if *f0541 = new(mem_ctx) ir_if(operand(r0542).val);
                        exec_list *const f0541_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0541->then_instructions;

                           body.emit(assign(r0534, lshift(r050E, r0537), 0x01));

                           ir_expression *const r0543 = bit_and(r0533, body.constant(int(31)));
                           body.emit(assign(r0535, rshift(r050E, r0543), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0541->else_instructions;

                           ir_variable *const r0544 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0546 = equal(r0533, body.constant(int(64)));
                           ir_if *f0545 = new(mem_ctx) ir_if(operand(r0546).val);
                           exec_list *const f0545_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0545->then_instructions;

                              body.emit(assign(r0544, r050E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0545->else_instructions;

                              ir_expression *const r0547 = nequal(r050E, body.constant(0u));
                              ir_expression *const r0548 = expr(ir_unop_b2i, r0547);
                              body.emit(assign(r0544, expr(ir_unop_i2u, r0548), 0x01));


                           body.instructions = f0545_parent_instructions;
                           body.emit(f0545);

                           /* END IF */

                           body.emit(assign(r0534, r0544, 0x01));

                           body.emit(assign(r0535, body.constant(0u), 0x01));


                        body.instructions = f0541_parent_instructions;
                        body.emit(f0541);

                        /* END IF */


                     body.instructions = f053F_parent_instructions;
                     body.emit(f053F);

                     /* END IF */

                     body.emit(assign(r0536, body.constant(0u), 0x01));


                  body.instructions = f053B_parent_instructions;
                  body.emit(f053B);

                  /* END IF */

                  ir_expression *const r0549 = nequal(r0532, body.constant(0u));
                  ir_expression *const r054A = expr(ir_unop_b2i, r0549);
                  ir_expression *const r054B = expr(ir_unop_i2u, r054A);
                  body.emit(assign(r0534, bit_or(r0534, r054B), 0x01));


               body.instructions = f0539_parent_instructions;
               body.emit(f0539);

               /* END IF */

               body.emit(assign(r050E, r0536, 0x01));

               body.emit(assign(r050F, r0535, 0x01));

               body.emit(assign(r0510, r0534, 0x01));


            body.instructions = f0528_parent_instructions;
            body.emit(f0528);

            /* END IF */

            body.emit(assign(r050D, sub(r050D, r0511), 0x01));

            ir_variable *const r054C = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r054C, r050D, 0x01));

            ir_variable *const r054D = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r054D, r050E, 0x01));

            ir_variable *const r054E = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r054E, r050F, 0x01));

            ir_variable *const r054F = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r054F, r0510, 0x01));

            ir_variable *const r0550 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0550, body.constant(true), 0x01));

            ir_variable *const r0551 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0552 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0552);
            ir_expression *const r0553 = expr(ir_unop_u2i, r0510);
            body.emit(assign(r0552, less(r0553, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0555 = lequal(body.constant(int(2045)), r050D);
            ir_if *f0554 = new(mem_ctx) ir_if(operand(r0555).val);
            exec_list *const f0554_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0554->then_instructions;

               ir_variable *const r0556 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0558 = less(body.constant(int(2045)), r050D);
               ir_if *f0557 = new(mem_ctx) ir_if(operand(r0558).val);
               exec_list *const f0557_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0557->then_instructions;

                  body.emit(assign(r0556, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0557->else_instructions;

                  ir_variable *const r0559 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r055B = equal(r050D, body.constant(int(2045)));
                  ir_if *f055A = new(mem_ctx) ir_if(operand(r055B).val);
                  exec_list *const f055A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f055A->then_instructions;

                     ir_expression *const r055C = equal(body.constant(2097151u), r050E);
                     ir_expression *const r055D = equal(body.constant(4294967295u), r050F);
                     body.emit(assign(r0559, logic_and(r055C, r055D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f055A->else_instructions;

                     body.emit(assign(r0559, body.constant(false), 0x01));


                  body.instructions = f055A_parent_instructions;
                  body.emit(f055A);

                  /* END IF */

                  body.emit(assign(r0556, logic_and(r0559, r0552), 0x01));


               body.instructions = f0557_parent_instructions;
               body.emit(f0557);

               /* END IF */

               /* IF CONDITION */
               ir_if *f055E = new(mem_ctx) ir_if(operand(r0556).val);
               exec_list *const f055E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f055E->then_instructions;

                  ir_variable *const r055F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r055F);
                  ir_expression *const r0560 = lshift(r03D3, body.constant(int(31)));
                  body.emit(assign(r055F, add(r0560, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r055F, body.constant(0u), 0x01));

                  body.emit(assign(r0551, r055F, 0x03));

                  body.emit(assign(r0550, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f055E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0562 = less(r050D, body.constant(int(0)));
                  ir_if *f0561 = new(mem_ctx) ir_if(operand(r0562).val);
                  exec_list *const f0561_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0561->then_instructions;

                     ir_variable *const r0563 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0563, r0510, 0x01));

                     ir_variable *const r0564 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0564, neg(r050D), 0x01));

                     ir_variable *const r0565 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0565);
                     ir_variable *const r0566 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0566);
                     ir_variable *const r0567 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0567);
                     ir_variable *const r0568 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0569 = neg(r0564);
                     body.emit(assign(r0568, bit_and(r0569, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r056B = equal(r0564, body.constant(int(0)));
                     ir_if *f056A = new(mem_ctx) ir_if(operand(r056B).val);
                     exec_list *const f056A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f056A->then_instructions;

                        body.emit(assign(r0565, r0510, 0x01));

                        body.emit(assign(r0566, r050F, 0x01));

                        body.emit(assign(r0567, r050E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f056A->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r056D = less(r0564, body.constant(int(32)));
                        ir_if *f056C = new(mem_ctx) ir_if(operand(r056D).val);
                        exec_list *const f056C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f056C->then_instructions;

                           body.emit(assign(r0565, lshift(r050F, r0568), 0x01));

                           ir_expression *const r056E = lshift(r050E, r0568);
                           ir_expression *const r056F = rshift(r050F, r0564);
                           body.emit(assign(r0566, bit_or(r056E, r056F), 0x01));

                           body.emit(assign(r0567, rshift(r050E, r0564), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f056C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0571 = equal(r0564, body.constant(int(32)));
                           ir_if *f0570 = new(mem_ctx) ir_if(operand(r0571).val);
                           exec_list *const f0570_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0570->then_instructions;

                              body.emit(assign(r0565, r050F, 0x01));

                              body.emit(assign(r0566, r050E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0570->else_instructions;

                              body.emit(assign(r0563, bit_or(r0510, r050F), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0573 = less(r0564, body.constant(int(64)));
                              ir_if *f0572 = new(mem_ctx) ir_if(operand(r0573).val);
                              exec_list *const f0572_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0572->then_instructions;

                                 body.emit(assign(r0565, lshift(r050E, r0568), 0x01));

                                 ir_expression *const r0574 = bit_and(r0564, body.constant(int(31)));
                                 body.emit(assign(r0566, rshift(r050E, r0574), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0572->else_instructions;

                                 ir_variable *const r0575 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0577 = equal(r0564, body.constant(int(64)));
                                 ir_if *f0576 = new(mem_ctx) ir_if(operand(r0577).val);
                                 exec_list *const f0576_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0576->then_instructions;

                                    body.emit(assign(r0575, r050E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0576->else_instructions;

                                    ir_expression *const r0578 = nequal(r050E, body.constant(0u));
                                    ir_expression *const r0579 = expr(ir_unop_b2i, r0578);
                                    body.emit(assign(r0575, expr(ir_unop_i2u, r0579), 0x01));


                                 body.instructions = f0576_parent_instructions;
                                 body.emit(f0576);

                                 /* END IF */

                                 body.emit(assign(r0565, r0575, 0x01));

                                 body.emit(assign(r0566, body.constant(0u), 0x01));


                              body.instructions = f0572_parent_instructions;
                              body.emit(f0572);

                              /* END IF */


                           body.instructions = f0570_parent_instructions;
                           body.emit(f0570);

                           /* END IF */

                           body.emit(assign(r0567, body.constant(0u), 0x01));


                        body.instructions = f056C_parent_instructions;
                        body.emit(f056C);

                        /* END IF */

                        ir_expression *const r057A = nequal(r0563, body.constant(0u));
                        ir_expression *const r057B = expr(ir_unop_b2i, r057A);
                        ir_expression *const r057C = expr(ir_unop_i2u, r057B);
                        body.emit(assign(r0565, bit_or(r0565, r057C), 0x01));


                     body.instructions = f056A_parent_instructions;
                     body.emit(f056A);

                     /* END IF */

                     body.emit(assign(r054D, r0567, 0x01));

                     body.emit(assign(r054E, r0566, 0x01));

                     body.emit(assign(r054F, r0565, 0x01));

                     body.emit(assign(r054C, body.constant(int(0)), 0x01));

                     body.emit(assign(r0552, less(r0565, body.constant(0u)), 0x01));


                  body.instructions = f0561_parent_instructions;
                  body.emit(f0561);

                  /* END IF */


               body.instructions = f055E_parent_instructions;
               body.emit(f055E);

               /* END IF */


            body.instructions = f0554_parent_instructions;
            body.emit(f0554);

            /* END IF */

            /* IF CONDITION */
            ir_if *f057D = new(mem_ctx) ir_if(operand(r0550).val);
            exec_list *const f057D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f057D->then_instructions;

               /* IF CONDITION */
               ir_if *f057E = new(mem_ctx) ir_if(operand(r0552).val);
               exec_list *const f057E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f057E->then_instructions;

                  ir_variable *const r057F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r057F, add(r054E, body.constant(1u)), 0x01));

                  ir_expression *const r0580 = less(r057F, r054E);
                  ir_expression *const r0581 = expr(ir_unop_b2i, r0580);
                  ir_expression *const r0582 = expr(ir_unop_i2u, r0581);
                  body.emit(assign(r054D, add(r054D, r0582), 0x01));

                  ir_expression *const r0583 = equal(r054F, body.constant(0u));
                  ir_expression *const r0584 = expr(ir_unop_b2i, r0583);
                  ir_expression *const r0585 = expr(ir_unop_i2u, r0584);
                  ir_expression *const r0586 = add(r054F, r0585);
                  ir_expression *const r0587 = bit_and(r0586, body.constant(1u));
                  ir_expression *const r0588 = expr(ir_unop_bit_not, r0587);
                  body.emit(assign(r054E, bit_and(r057F, r0588), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f057E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r058A = bit_or(r054D, r054E);
                  ir_expression *const r058B = equal(r058A, body.constant(0u));
                  ir_if *f0589 = new(mem_ctx) ir_if(operand(r058B).val);
                  exec_list *const f0589_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0589->then_instructions;

                     body.emit(assign(r054C, body.constant(int(0)), 0x01));


                  body.instructions = f0589_parent_instructions;
                  body.emit(f0589);

                  /* END IF */


               body.instructions = f057E_parent_instructions;
               body.emit(f057E);

               /* END IF */

               ir_variable *const r058C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r058C);
               ir_expression *const r058D = lshift(r03D3, body.constant(int(31)));
               ir_expression *const r058E = expr(ir_unop_i2u, r054C);
               ir_expression *const r058F = lshift(r058E, body.constant(int(20)));
               ir_expression *const r0590 = add(r058D, r058F);
               body.emit(assign(r058C, add(r0590, r054D), 0x02));

               body.emit(assign(r058C, r054E, 0x01));

               body.emit(assign(r0551, r058C, 0x03));

               body.emit(assign(r0550, body.constant(false), 0x01));


            body.instructions = f057D_parent_instructions;
            body.emit(f057D);

            /* END IF */

            body.emit(assign(r03D4, r0551, 0x03));


         body.instructions = f04BF_parent_instructions;
         body.emit(f04BF);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f04BD->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0592 = equal(r03DD, body.constant(int(2047)));
         ir_if *f0591 = new(mem_ctx) ir_if(operand(r0592).val);
         exec_list *const f0591_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0591->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0594 = bit_or(r03DA, r03DB);
            ir_expression *const r0595 = bit_or(r03D8, r03D9);
            ir_expression *const r0596 = bit_or(r0594, r0595);
            ir_expression *const r0597 = nequal(r0596, body.constant(0u));
            ir_if *f0593 = new(mem_ctx) ir_if(operand(r0597).val);
            exec_list *const f0593_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0593->then_instructions;

               ir_variable *const r0598 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0598, swizzle_x(r03D1), 0x01));

               ir_variable *const r0599 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0599, swizzle_x(r03D2), 0x01));

               ir_variable *const r059A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r059B = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r059C = rshift(swizzle_y(r03D1), body.constant(int(19)));
               ir_expression *const r059D = bit_and(r059C, body.constant(4095u));
               ir_expression *const r059E = equal(r059D, body.constant(4094u));
               ir_expression *const r059F = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r05A0 = bit_and(swizzle_y(r03D1), body.constant(524287u));
               ir_expression *const r05A1 = nequal(r05A0, body.constant(0u));
               ir_expression *const r05A2 = logic_or(r059F, r05A1);
               body.emit(assign(r059B, logic_and(r059E, r05A2), 0x01));

               ir_variable *const r05A3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r05A4 = lshift(swizzle_y(r03D2), body.constant(int(1)));
               ir_expression *const r05A5 = lequal(body.constant(4292870144u), r05A4);
               ir_expression *const r05A6 = nequal(swizzle_x(r03D2), body.constant(0u));
               ir_expression *const r05A7 = bit_and(swizzle_y(r03D2), body.constant(1048575u));
               ir_expression *const r05A8 = nequal(r05A7, body.constant(0u));
               ir_expression *const r05A9 = logic_or(r05A6, r05A8);
               body.emit(assign(r05A3, logic_and(r05A5, r05A9), 0x01));

               body.emit(assign(r0598, bit_or(swizzle_y(r03D1), body.constant(524288u)), 0x02));

               body.emit(assign(r0599, bit_or(swizzle_y(r03D2), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r05AB = lshift(swizzle_y(r03D1), body.constant(int(1)));
               ir_expression *const r05AC = lequal(body.constant(4292870144u), r05AB);
               ir_expression *const r05AD = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r05AE = bit_and(swizzle_y(r03D1), body.constant(1048575u));
               ir_expression *const r05AF = nequal(r05AE, body.constant(0u));
               ir_expression *const r05B0 = logic_or(r05AD, r05AF);
               ir_expression *const r05B1 = logic_and(r05AC, r05B0);
               ir_if *f05AA = new(mem_ctx) ir_if(operand(r05B1).val);
               exec_list *const f05AA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05AA->then_instructions;

                  ir_variable *const r05B2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05B4 = logic_and(r059B, r05A3);
                  ir_if *f05B3 = new(mem_ctx) ir_if(operand(r05B4).val);
                  exec_list *const f05B3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05B3->then_instructions;

                     body.emit(assign(r05B2, r0599, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05B3->else_instructions;

                     body.emit(assign(r05B2, r0598, 0x03));


                  body.instructions = f05B3_parent_instructions;
                  body.emit(f05B3);

                  /* END IF */

                  body.emit(assign(r059A, r05B2, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05AA->else_instructions;

                  body.emit(assign(r059A, r0599, 0x03));


               body.instructions = f05AA_parent_instructions;
               body.emit(f05AA);

               /* END IF */

               body.emit(assign(r03D4, r059A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0593->else_instructions;

               ir_constant_data r05B5_data;
               memset(&r05B5_data, 0, sizeof(ir_constant_data));
               r05B5_data.u[0] = 4294967295;
               r05B5_data.u[1] = 4294967295;
               ir_constant *const r05B5 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r05B5_data);
               body.emit(assign(r03D4, r05B5, 0x03));


            body.instructions = f0593_parent_instructions;
            body.emit(f0593);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0591->else_instructions;

            /* IF CONDITION */
            ir_expression *const r05B7 = equal(r03DD, body.constant(int(0)));
            ir_if *f05B6 = new(mem_ctx) ir_if(operand(r05B7).val);
            exec_list *const f05B6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B6->then_instructions;

               body.emit(assign(r03D7, body.constant(int(1)), 0x01));

               body.emit(assign(r03D6, body.constant(int(1)), 0x01));


            body.instructions = f05B6_parent_instructions;
            body.emit(f05B6);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r05B9 = less(r03D8, r03DA);
            ir_if *f05B8 = new(mem_ctx) ir_if(operand(r05B9).val);
            exec_list *const f05B8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B8->then_instructions;

               ir_variable *const r05BA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r05BB = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r05BB, sub(r03DB, r03D9), 0x01));

               ir_expression *const r05BC = sub(r03DA, r03D8);
               ir_expression *const r05BD = less(r03DB, r03D9);
               ir_expression *const r05BE = expr(ir_unop_b2i, r05BD);
               ir_expression *const r05BF = expr(ir_unop_i2u, r05BE);
               body.emit(assign(r05BA, sub(r05BC, r05BF), 0x01));

               body.emit(assign(r03DC, add(r03D7, body.constant(int(-1))), 0x01));

               ir_variable *const r05C0 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05C0, add(r03DC, body.constant(int(-10))), 0x01));

               ir_variable *const r05C1 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r05C1, r05BA, 0x01));

               ir_variable *const r05C2 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r05C2, r05BB, 0x01));

               ir_variable *const r05C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r05C3);
               ir_variable *const r05C4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05C4);
               /* IF CONDITION */
               ir_expression *const r05C6 = equal(r05BA, body.constant(0u));
               ir_if *f05C5 = new(mem_ctx) ir_if(operand(r05C6).val);
               exec_list *const f05C5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05C5->then_instructions;

                  body.emit(assign(r05C1, r05BB, 0x01));

                  body.emit(assign(r05C2, body.constant(0u), 0x01));

                  body.emit(assign(r05C0, add(r05C0, body.constant(int(-32))), 0x01));


               body.instructions = f05C5_parent_instructions;
               body.emit(f05C5);

               /* END IF */

               ir_variable *const r05C7 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r05C7, r05C1, 0x01));

               ir_variable *const r05C8 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r05C9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05C9);
               /* IF CONDITION */
               ir_expression *const r05CB = equal(r05C1, body.constant(0u));
               ir_if *f05CA = new(mem_ctx) ir_if(operand(r05CB).val);
               exec_list *const f05CA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05CA->then_instructions;

                  body.emit(assign(r05C8, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05CA->else_instructions;

                  body.emit(assign(r05C9, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05CD = bit_and(r05C1, body.constant(4294901760u));
                  ir_expression *const r05CE = equal(r05CD, body.constant(0u));
                  ir_if *f05CC = new(mem_ctx) ir_if(operand(r05CE).val);
                  exec_list *const f05CC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CC->then_instructions;

                     body.emit(assign(r05C9, body.constant(int(16)), 0x01));

                     body.emit(assign(r05C7, lshift(r05C1, body.constant(int(16))), 0x01));


                  body.instructions = f05CC_parent_instructions;
                  body.emit(f05CC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D0 = bit_and(r05C7, body.constant(4278190080u));
                  ir_expression *const r05D1 = equal(r05D0, body.constant(0u));
                  ir_if *f05CF = new(mem_ctx) ir_if(operand(r05D1).val);
                  exec_list *const f05CF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CF->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(8))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(8))), 0x01));


                  body.instructions = f05CF_parent_instructions;
                  body.emit(f05CF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D3 = bit_and(r05C7, body.constant(4026531840u));
                  ir_expression *const r05D4 = equal(r05D3, body.constant(0u));
                  ir_if *f05D2 = new(mem_ctx) ir_if(operand(r05D4).val);
                  exec_list *const f05D2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D2->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(4))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(4))), 0x01));


                  body.instructions = f05D2_parent_instructions;
                  body.emit(f05D2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D6 = bit_and(r05C7, body.constant(3221225472u));
                  ir_expression *const r05D7 = equal(r05D6, body.constant(0u));
                  ir_if *f05D5 = new(mem_ctx) ir_if(operand(r05D7).val);
                  exec_list *const f05D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D5->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(2))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(2))), 0x01));


                  body.instructions = f05D5_parent_instructions;
                  body.emit(f05D5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D9 = bit_and(r05C7, body.constant(2147483648u));
                  ir_expression *const r05DA = equal(r05D9, body.constant(0u));
                  ir_if *f05D8 = new(mem_ctx) ir_if(operand(r05DA).val);
                  exec_list *const f05D8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D8->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(1))), 0x01));


                  body.instructions = f05D8_parent_instructions;
                  body.emit(f05D8);

                  /* END IF */

                  body.emit(assign(r05C8, r05C9, 0x01));


               body.instructions = f05CA_parent_instructions;
               body.emit(f05CA);

               /* END IF */

               body.emit(assign(r05C4, add(r05C8, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r05DC = lequal(body.constant(int(0)), r05C4);
               ir_if *f05DB = new(mem_ctx) ir_if(operand(r05DC).val);
               exec_list *const f05DB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05DB->then_instructions;

                  body.emit(assign(r05C3, body.constant(0u), 0x01));

                  ir_variable *const r05DD = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r05DD, lshift(r05C2, r05C4), 0x01));

                  ir_variable *const r05DE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05E0 = equal(r05C4, body.constant(int(0)));
                  ir_if *f05DF = new(mem_ctx) ir_if(operand(r05E0).val);
                  exec_list *const f05DF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05DF->then_instructions;

                     body.emit(assign(r05DE, r05C1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05DF->else_instructions;

                     ir_expression *const r05E1 = lshift(r05C1, r05C4);
                     ir_expression *const r05E2 = neg(r05C4);
                     ir_expression *const r05E3 = bit_and(r05E2, body.constant(int(31)));
                     ir_expression *const r05E4 = rshift(r05C2, r05E3);
                     body.emit(assign(r05DE, bit_or(r05E1, r05E4), 0x01));


                  body.instructions = f05DF_parent_instructions;
                  body.emit(f05DF);

                  /* END IF */

                  body.emit(assign(r05C1, r05DE, 0x01));

                  body.emit(assign(r05C2, r05DD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05DB->else_instructions;

                  ir_variable *const r05E5 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r05E5, body.constant(0u), 0x01));

                  ir_variable *const r05E6 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r05E6, neg(r05C4), 0x01));

                  ir_variable *const r05E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r05E7);
                  ir_variable *const r05E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r05E8);
                  ir_variable *const r05E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r05E9);
                  ir_variable *const r05EA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r05EB = neg(r05E6);
                  body.emit(assign(r05EA, bit_and(r05EB, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05ED = equal(r05E6, body.constant(int(0)));
                  ir_if *f05EC = new(mem_ctx) ir_if(operand(r05ED).val);
                  exec_list *const f05EC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05EC->then_instructions;

                     body.emit(assign(r05E7, r05E5, 0x01));

                     body.emit(assign(r05E8, r05C2, 0x01));

                     body.emit(assign(r05E9, r05C1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05EC->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r05EF = less(r05E6, body.constant(int(32)));
                     ir_if *f05EE = new(mem_ctx) ir_if(operand(r05EF).val);
                     exec_list *const f05EE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f05EE->then_instructions;

                        body.emit(assign(r05E7, lshift(r05C2, r05EA), 0x01));

                        ir_expression *const r05F0 = lshift(r05C1, r05EA);
                        ir_expression *const r05F1 = rshift(r05C2, r05E6);
                        body.emit(assign(r05E8, bit_or(r05F0, r05F1), 0x01));

                        body.emit(assign(r05E9, rshift(r05C1, r05E6), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f05EE->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r05F3 = equal(r05E6, body.constant(int(32)));
                        ir_if *f05F2 = new(mem_ctx) ir_if(operand(r05F3).val);
                        exec_list *const f05F2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f05F2->then_instructions;

                           body.emit(assign(r05E7, r05C2, 0x01));

                           body.emit(assign(r05E8, r05C1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f05F2->else_instructions;

                           body.emit(assign(r05E5, bit_or(body.constant(0u), r05C2), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r05F5 = less(r05E6, body.constant(int(64)));
                           ir_if *f05F4 = new(mem_ctx) ir_if(operand(r05F5).val);
                           exec_list *const f05F4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f05F4->then_instructions;

                              body.emit(assign(r05E7, lshift(r05C1, r05EA), 0x01));

                              ir_expression *const r05F6 = bit_and(r05E6, body.constant(int(31)));
                              body.emit(assign(r05E8, rshift(r05C1, r05F6), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f05F4->else_instructions;

                              ir_variable *const r05F7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r05F9 = equal(r05E6, body.constant(int(64)));
                              ir_if *f05F8 = new(mem_ctx) ir_if(operand(r05F9).val);
                              exec_list *const f05F8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f05F8->then_instructions;

                                 body.emit(assign(r05F7, r05C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f05F8->else_instructions;

                                 ir_expression *const r05FA = nequal(r05C1, body.constant(0u));
                                 ir_expression *const r05FB = expr(ir_unop_b2i, r05FA);
                                 body.emit(assign(r05F7, expr(ir_unop_i2u, r05FB), 0x01));


                              body.instructions = f05F8_parent_instructions;
                              body.emit(f05F8);

                              /* END IF */

                              body.emit(assign(r05E7, r05F7, 0x01));

                              body.emit(assign(r05E8, body.constant(0u), 0x01));


                           body.instructions = f05F4_parent_instructions;
                           body.emit(f05F4);

                           /* END IF */


                        body.instructions = f05F2_parent_instructions;
                        body.emit(f05F2);

                        /* END IF */

                        body.emit(assign(r05E9, body.constant(0u), 0x01));


                     body.instructions = f05EE_parent_instructions;
                     body.emit(f05EE);

                     /* END IF */

                     ir_expression *const r05FC = nequal(r05E5, body.constant(0u));
                     ir_expression *const r05FD = expr(ir_unop_b2i, r05FC);
                     ir_expression *const r05FE = expr(ir_unop_i2u, r05FD);
                     body.emit(assign(r05E7, bit_or(r05E7, r05FE), 0x01));


                  body.instructions = f05EC_parent_instructions;
                  body.emit(f05EC);

                  /* END IF */

                  body.emit(assign(r05C1, r05E9, 0x01));

                  body.emit(assign(r05C2, r05E8, 0x01));

                  body.emit(assign(r05C3, r05E7, 0x01));


               body.instructions = f05DB_parent_instructions;
               body.emit(f05DB);

               /* END IF */

               body.emit(assign(r05C0, sub(r05C0, r05C4), 0x01));

               ir_variable *const r05FF = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05FF, r05C0, 0x01));

               ir_variable *const r0600 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0600, r05C1, 0x01));

               ir_variable *const r0601 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0601, r05C2, 0x01));

               ir_variable *const r0602 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0602, r05C3, 0x01));

               ir_variable *const r0603 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0603, body.constant(true), 0x01));

               ir_variable *const r0604 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0605 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0605);
               ir_expression *const r0606 = expr(ir_unop_u2i, r05C3);
               body.emit(assign(r0605, less(r0606, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0608 = lequal(body.constant(int(2045)), r05C0);
               ir_if *f0607 = new(mem_ctx) ir_if(operand(r0608).val);
               exec_list *const f0607_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0607->then_instructions;

                  ir_variable *const r0609 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r060B = less(body.constant(int(2045)), r05C0);
                  ir_if *f060A = new(mem_ctx) ir_if(operand(r060B).val);
                  exec_list *const f060A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f060A->then_instructions;

                     body.emit(assign(r0609, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f060A->else_instructions;

                     ir_variable *const r060C = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r060E = equal(r05C0, body.constant(int(2045)));
                     ir_if *f060D = new(mem_ctx) ir_if(operand(r060E).val);
                     exec_list *const f060D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f060D->then_instructions;

                        ir_expression *const r060F = equal(body.constant(2097151u), r05C1);
                        ir_expression *const r0610 = equal(body.constant(4294967295u), r05C2);
                        body.emit(assign(r060C, logic_and(r060F, r0610), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f060D->else_instructions;

                        body.emit(assign(r060C, body.constant(false), 0x01));


                     body.instructions = f060D_parent_instructions;
                     body.emit(f060D);

                     /* END IF */

                     body.emit(assign(r0609, logic_and(r060C, r0605), 0x01));


                  body.instructions = f060A_parent_instructions;
                  body.emit(f060A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0611 = new(mem_ctx) ir_if(operand(r0609).val);
                  exec_list *const f0611_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0611->then_instructions;

                     ir_variable *const r0612 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0612);
                     ir_expression *const r0613 = lshift(r03D3, body.constant(int(31)));
                     body.emit(assign(r0612, add(r0613, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0612, body.constant(0u), 0x01));

                     body.emit(assign(r0604, r0612, 0x03));

                     body.emit(assign(r0603, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0611->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0615 = less(r05C0, body.constant(int(0)));
                     ir_if *f0614 = new(mem_ctx) ir_if(operand(r0615).val);
                     exec_list *const f0614_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0614->then_instructions;

                        ir_variable *const r0616 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0616, r05C3, 0x01));

                        ir_variable *const r0617 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0617, neg(r05C0), 0x01));

                        ir_variable *const r0618 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0618);
                        ir_variable *const r0619 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0619);
                        ir_variable *const r061A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r061A);
                        ir_variable *const r061B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r061C = neg(r0617);
                        body.emit(assign(r061B, bit_and(r061C, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r061E = equal(r0617, body.constant(int(0)));
                        ir_if *f061D = new(mem_ctx) ir_if(operand(r061E).val);
                        exec_list *const f061D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f061D->then_instructions;

                           body.emit(assign(r0618, r05C3, 0x01));

                           body.emit(assign(r0619, r05C2, 0x01));

                           body.emit(assign(r061A, r05C1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f061D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0620 = less(r0617, body.constant(int(32)));
                           ir_if *f061F = new(mem_ctx) ir_if(operand(r0620).val);
                           exec_list *const f061F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f061F->then_instructions;

                              body.emit(assign(r0618, lshift(r05C2, r061B), 0x01));

                              ir_expression *const r0621 = lshift(r05C1, r061B);
                              ir_expression *const r0622 = rshift(r05C2, r0617);
                              body.emit(assign(r0619, bit_or(r0621, r0622), 0x01));

                              body.emit(assign(r061A, rshift(r05C1, r0617), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f061F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0624 = equal(r0617, body.constant(int(32)));
                              ir_if *f0623 = new(mem_ctx) ir_if(operand(r0624).val);
                              exec_list *const f0623_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0623->then_instructions;

                                 body.emit(assign(r0618, r05C2, 0x01));

                                 body.emit(assign(r0619, r05C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0623->else_instructions;

                                 body.emit(assign(r0616, bit_or(r05C3, r05C2), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0626 = less(r0617, body.constant(int(64)));
                                 ir_if *f0625 = new(mem_ctx) ir_if(operand(r0626).val);
                                 exec_list *const f0625_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0625->then_instructions;

                                    body.emit(assign(r0618, lshift(r05C1, r061B), 0x01));

                                    ir_expression *const r0627 = bit_and(r0617, body.constant(int(31)));
                                    body.emit(assign(r0619, rshift(r05C1, r0627), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0625->else_instructions;

                                    ir_variable *const r0628 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r062A = equal(r0617, body.constant(int(64)));
                                    ir_if *f0629 = new(mem_ctx) ir_if(operand(r062A).val);
                                    exec_list *const f0629_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0629->then_instructions;

                                       body.emit(assign(r0628, r05C1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0629->else_instructions;

                                       ir_expression *const r062B = nequal(r05C1, body.constant(0u));
                                       ir_expression *const r062C = expr(ir_unop_b2i, r062B);
                                       body.emit(assign(r0628, expr(ir_unop_i2u, r062C), 0x01));


                                    body.instructions = f0629_parent_instructions;
                                    body.emit(f0629);

                                    /* END IF */

                                    body.emit(assign(r0618, r0628, 0x01));

                                    body.emit(assign(r0619, body.constant(0u), 0x01));


                                 body.instructions = f0625_parent_instructions;
                                 body.emit(f0625);

                                 /* END IF */


                              body.instructions = f0623_parent_instructions;
                              body.emit(f0623);

                              /* END IF */

                              body.emit(assign(r061A, body.constant(0u), 0x01));


                           body.instructions = f061F_parent_instructions;
                           body.emit(f061F);

                           /* END IF */

                           ir_expression *const r062D = nequal(r0616, body.constant(0u));
                           ir_expression *const r062E = expr(ir_unop_b2i, r062D);
                           ir_expression *const r062F = expr(ir_unop_i2u, r062E);
                           body.emit(assign(r0618, bit_or(r0618, r062F), 0x01));


                        body.instructions = f061D_parent_instructions;
                        body.emit(f061D);

                        /* END IF */

                        body.emit(assign(r0600, r061A, 0x01));

                        body.emit(assign(r0601, r0619, 0x01));

                        body.emit(assign(r0602, r0618, 0x01));

                        body.emit(assign(r05FF, body.constant(int(0)), 0x01));

                        body.emit(assign(r0605, less(r0618, body.constant(0u)), 0x01));


                     body.instructions = f0614_parent_instructions;
                     body.emit(f0614);

                     /* END IF */


                  body.instructions = f0611_parent_instructions;
                  body.emit(f0611);

                  /* END IF */


               body.instructions = f0607_parent_instructions;
               body.emit(f0607);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0630 = new(mem_ctx) ir_if(operand(r0603).val);
               exec_list *const f0630_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0630->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0631 = new(mem_ctx) ir_if(operand(r0605).val);
                  exec_list *const f0631_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0631->then_instructions;

                     ir_variable *const r0632 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0632, add(r0601, body.constant(1u)), 0x01));

                     ir_expression *const r0633 = less(r0632, r0601);
                     ir_expression *const r0634 = expr(ir_unop_b2i, r0633);
                     ir_expression *const r0635 = expr(ir_unop_i2u, r0634);
                     body.emit(assign(r0600, add(r0600, r0635), 0x01));

                     ir_expression *const r0636 = equal(r0602, body.constant(0u));
                     ir_expression *const r0637 = expr(ir_unop_b2i, r0636);
                     ir_expression *const r0638 = expr(ir_unop_i2u, r0637);
                     ir_expression *const r0639 = add(r0602, r0638);
                     ir_expression *const r063A = bit_and(r0639, body.constant(1u));
                     ir_expression *const r063B = expr(ir_unop_bit_not, r063A);
                     body.emit(assign(r0601, bit_and(r0632, r063B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0631->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r063D = bit_or(r0600, r0601);
                     ir_expression *const r063E = equal(r063D, body.constant(0u));
                     ir_if *f063C = new(mem_ctx) ir_if(operand(r063E).val);
                     exec_list *const f063C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f063C->then_instructions;

                        body.emit(assign(r05FF, body.constant(int(0)), 0x01));


                     body.instructions = f063C_parent_instructions;
                     body.emit(f063C);

                     /* END IF */


                  body.instructions = f0631_parent_instructions;
                  body.emit(f0631);

                  /* END IF */

                  ir_variable *const r063F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r063F);
                  ir_expression *const r0640 = lshift(r03D3, body.constant(int(31)));
                  ir_expression *const r0641 = expr(ir_unop_i2u, r05FF);
                  ir_expression *const r0642 = lshift(r0641, body.constant(int(20)));
                  ir_expression *const r0643 = add(r0640, r0642);
                  body.emit(assign(r063F, add(r0643, r0600), 0x02));

                  body.emit(assign(r063F, r0601, 0x01));

                  body.emit(assign(r0604, r063F, 0x03));

                  body.emit(assign(r0603, body.constant(false), 0x01));


               body.instructions = f0630_parent_instructions;
               body.emit(f0630);

               /* END IF */

               body.emit(assign(r03D4, r0604, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f05B8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0645 = less(r03DA, r03D8);
               ir_if *f0644 = new(mem_ctx) ir_if(operand(r0645).val);
               exec_list *const f0644_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0644->then_instructions;

                  ir_variable *const r0646 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0647 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0647, sub(r03D9, r03DB), 0x01));

                  ir_expression *const r0648 = sub(r03D8, r03DA);
                  ir_expression *const r0649 = less(r03D9, r03DB);
                  ir_expression *const r064A = expr(ir_unop_b2i, r0649);
                  ir_expression *const r064B = expr(ir_unop_i2u, r064A);
                  body.emit(assign(r0646, sub(r0648, r064B), 0x01));

                  body.emit(assign(r03D3, bit_xor(r03D3, body.constant(1u)), 0x01));

                  body.emit(assign(r03DC, add(r03D6, body.constant(int(-1))), 0x01));

                  ir_variable *const r064C = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r064C, add(r03DC, body.constant(int(-10))), 0x01));

                  ir_variable *const r064D = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r064D, r0646, 0x01));

                  ir_variable *const r064E = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r064E, r0647, 0x01));

                  ir_variable *const r064F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r064F);
                  ir_variable *const r0650 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0650);
                  /* IF CONDITION */
                  ir_expression *const r0652 = equal(r0646, body.constant(0u));
                  ir_if *f0651 = new(mem_ctx) ir_if(operand(r0652).val);
                  exec_list *const f0651_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0651->then_instructions;

                     body.emit(assign(r064D, r0647, 0x01));

                     body.emit(assign(r064E, body.constant(0u), 0x01));

                     body.emit(assign(r064C, add(r064C, body.constant(int(-32))), 0x01));


                  body.instructions = f0651_parent_instructions;
                  body.emit(f0651);

                  /* END IF */

                  ir_variable *const r0653 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0653, r064D, 0x01));

                  ir_variable *const r0654 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0655 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0655);
                  /* IF CONDITION */
                  ir_expression *const r0657 = equal(r064D, body.constant(0u));
                  ir_if *f0656 = new(mem_ctx) ir_if(operand(r0657).val);
                  exec_list *const f0656_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0656->then_instructions;

                     body.emit(assign(r0654, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0656->else_instructions;

                     body.emit(assign(r0655, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0659 = bit_and(r064D, body.constant(4294901760u));
                     ir_expression *const r065A = equal(r0659, body.constant(0u));
                     ir_if *f0658 = new(mem_ctx) ir_if(operand(r065A).val);
                     exec_list *const f0658_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0658->then_instructions;

                        body.emit(assign(r0655, body.constant(int(16)), 0x01));

                        body.emit(assign(r0653, lshift(r064D, body.constant(int(16))), 0x01));


                     body.instructions = f0658_parent_instructions;
                     body.emit(f0658);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065C = bit_and(r0653, body.constant(4278190080u));
                     ir_expression *const r065D = equal(r065C, body.constant(0u));
                     ir_if *f065B = new(mem_ctx) ir_if(operand(r065D).val);
                     exec_list *const f065B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065B->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(8))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(8))), 0x01));


                     body.instructions = f065B_parent_instructions;
                     body.emit(f065B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065F = bit_and(r0653, body.constant(4026531840u));
                     ir_expression *const r0660 = equal(r065F, body.constant(0u));
                     ir_if *f065E = new(mem_ctx) ir_if(operand(r0660).val);
                     exec_list *const f065E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065E->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(4))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(4))), 0x01));


                     body.instructions = f065E_parent_instructions;
                     body.emit(f065E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0662 = bit_and(r0653, body.constant(3221225472u));
                     ir_expression *const r0663 = equal(r0662, body.constant(0u));
                     ir_if *f0661 = new(mem_ctx) ir_if(operand(r0663).val);
                     exec_list *const f0661_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0661->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(2))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(2))), 0x01));


                     body.instructions = f0661_parent_instructions;
                     body.emit(f0661);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0665 = bit_and(r0653, body.constant(2147483648u));
                     ir_expression *const r0666 = equal(r0665, body.constant(0u));
                     ir_if *f0664 = new(mem_ctx) ir_if(operand(r0666).val);
                     exec_list *const f0664_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0664->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(1))), 0x01));


                     body.instructions = f0664_parent_instructions;
                     body.emit(f0664);

                     /* END IF */

                     body.emit(assign(r0654, r0655, 0x01));


                  body.instructions = f0656_parent_instructions;
                  body.emit(f0656);

                  /* END IF */

                  body.emit(assign(r0650, add(r0654, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0668 = lequal(body.constant(int(0)), r0650);
                  ir_if *f0667 = new(mem_ctx) ir_if(operand(r0668).val);
                  exec_list *const f0667_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0667->then_instructions;

                     body.emit(assign(r064F, body.constant(0u), 0x01));

                     ir_variable *const r0669 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0669, lshift(r064E, r0650), 0x01));

                     ir_variable *const r066A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r066C = equal(r0650, body.constant(int(0)));
                     ir_if *f066B = new(mem_ctx) ir_if(operand(r066C).val);
                     exec_list *const f066B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f066B->then_instructions;

                        body.emit(assign(r066A, r064D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f066B->else_instructions;

                        ir_expression *const r066D = lshift(r064D, r0650);
                        ir_expression *const r066E = neg(r0650);
                        ir_expression *const r066F = bit_and(r066E, body.constant(int(31)));
                        ir_expression *const r0670 = rshift(r064E, r066F);
                        body.emit(assign(r066A, bit_or(r066D, r0670), 0x01));


                     body.instructions = f066B_parent_instructions;
                     body.emit(f066B);

                     /* END IF */

                     body.emit(assign(r064D, r066A, 0x01));

                     body.emit(assign(r064E, r0669, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0667->else_instructions;

                     ir_variable *const r0671 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0671, body.constant(0u), 0x01));

                     ir_variable *const r0672 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0672, neg(r0650), 0x01));

                     ir_variable *const r0673 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0673);
                     ir_variable *const r0674 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0674);
                     ir_variable *const r0675 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0675);
                     ir_variable *const r0676 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0677 = neg(r0672);
                     body.emit(assign(r0676, bit_and(r0677, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0679 = equal(r0672, body.constant(int(0)));
                     ir_if *f0678 = new(mem_ctx) ir_if(operand(r0679).val);
                     exec_list *const f0678_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0678->then_instructions;

                        body.emit(assign(r0673, r0671, 0x01));

                        body.emit(assign(r0674, r064E, 0x01));

                        body.emit(assign(r0675, r064D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0678->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r067B = less(r0672, body.constant(int(32)));
                        ir_if *f067A = new(mem_ctx) ir_if(operand(r067B).val);
                        exec_list *const f067A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f067A->then_instructions;

                           body.emit(assign(r0673, lshift(r064E, r0676), 0x01));

                           ir_expression *const r067C = lshift(r064D, r0676);
                           ir_expression *const r067D = rshift(r064E, r0672);
                           body.emit(assign(r0674, bit_or(r067C, r067D), 0x01));

                           body.emit(assign(r0675, rshift(r064D, r0672), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f067A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r067F = equal(r0672, body.constant(int(32)));
                           ir_if *f067E = new(mem_ctx) ir_if(operand(r067F).val);
                           exec_list *const f067E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f067E->then_instructions;

                              body.emit(assign(r0673, r064E, 0x01));

                              body.emit(assign(r0674, r064D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f067E->else_instructions;

                              body.emit(assign(r0671, bit_or(body.constant(0u), r064E), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0681 = less(r0672, body.constant(int(64)));
                              ir_if *f0680 = new(mem_ctx) ir_if(operand(r0681).val);
                              exec_list *const f0680_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0680->then_instructions;

                                 body.emit(assign(r0673, lshift(r064D, r0676), 0x01));

                                 ir_expression *const r0682 = bit_and(r0672, body.constant(int(31)));
                                 body.emit(assign(r0674, rshift(r064D, r0682), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0680->else_instructions;

                                 ir_variable *const r0683 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0685 = equal(r0672, body.constant(int(64)));
                                 ir_if *f0684 = new(mem_ctx) ir_if(operand(r0685).val);
                                 exec_list *const f0684_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0684->then_instructions;

                                    body.emit(assign(r0683, r064D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0684->else_instructions;

                                    ir_expression *const r0686 = nequal(r064D, body.constant(0u));
                                    ir_expression *const r0687 = expr(ir_unop_b2i, r0686);
                                    body.emit(assign(r0683, expr(ir_unop_i2u, r0687), 0x01));


                                 body.instructions = f0684_parent_instructions;
                                 body.emit(f0684);

                                 /* END IF */

                                 body.emit(assign(r0673, r0683, 0x01));

                                 body.emit(assign(r0674, body.constant(0u), 0x01));


                              body.instructions = f0680_parent_instructions;
                              body.emit(f0680);

                              /* END IF */


                           body.instructions = f067E_parent_instructions;
                           body.emit(f067E);

                           /* END IF */

                           body.emit(assign(r0675, body.constant(0u), 0x01));


                        body.instructions = f067A_parent_instructions;
                        body.emit(f067A);

                        /* END IF */

                        ir_expression *const r0688 = nequal(r0671, body.constant(0u));
                        ir_expression *const r0689 = expr(ir_unop_b2i, r0688);
                        ir_expression *const r068A = expr(ir_unop_i2u, r0689);
                        body.emit(assign(r0673, bit_or(r0673, r068A), 0x01));


                     body.instructions = f0678_parent_instructions;
                     body.emit(f0678);

                     /* END IF */

                     body.emit(assign(r064D, r0675, 0x01));

                     body.emit(assign(r064E, r0674, 0x01));

                     body.emit(assign(r064F, r0673, 0x01));


                  body.instructions = f0667_parent_instructions;
                  body.emit(f0667);

                  /* END IF */

                  body.emit(assign(r064C, sub(r064C, r0650), 0x01));

                  ir_variable *const r068B = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r068B, r064C, 0x01));

                  ir_variable *const r068C = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r068C, r064D, 0x01));

                  ir_variable *const r068D = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r068D, r064E, 0x01));

                  ir_variable *const r068E = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r068E, r064F, 0x01));

                  ir_variable *const r068F = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r068F, body.constant(true), 0x01));

                  ir_variable *const r0690 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0691 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0691);
                  ir_expression *const r0692 = expr(ir_unop_u2i, r064F);
                  body.emit(assign(r0691, less(r0692, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0694 = lequal(body.constant(int(2045)), r064C);
                  ir_if *f0693 = new(mem_ctx) ir_if(operand(r0694).val);
                  exec_list *const f0693_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0693->then_instructions;

                     ir_variable *const r0695 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0697 = less(body.constant(int(2045)), r064C);
                     ir_if *f0696 = new(mem_ctx) ir_if(operand(r0697).val);
                     exec_list *const f0696_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0696->then_instructions;

                        body.emit(assign(r0695, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0696->else_instructions;

                        ir_variable *const r0698 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r069A = equal(r064C, body.constant(int(2045)));
                        ir_if *f0699 = new(mem_ctx) ir_if(operand(r069A).val);
                        exec_list *const f0699_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0699->then_instructions;

                           ir_expression *const r069B = equal(body.constant(2097151u), r064D);
                           ir_expression *const r069C = equal(body.constant(4294967295u), r064E);
                           body.emit(assign(r0698, logic_and(r069B, r069C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0699->else_instructions;

                           body.emit(assign(r0698, body.constant(false), 0x01));


                        body.instructions = f0699_parent_instructions;
                        body.emit(f0699);

                        /* END IF */

                        body.emit(assign(r0695, logic_and(r0698, r0691), 0x01));


                     body.instructions = f0696_parent_instructions;
                     body.emit(f0696);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f069D = new(mem_ctx) ir_if(operand(r0695).val);
                     exec_list *const f069D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f069D->then_instructions;

                        ir_variable *const r069E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r069E);
                        ir_expression *const r069F = lshift(r03D3, body.constant(int(31)));
                        body.emit(assign(r069E, add(r069F, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r069E, body.constant(0u), 0x01));

                        body.emit(assign(r0690, r069E, 0x03));

                        body.emit(assign(r068F, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f069D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r06A1 = less(r064C, body.constant(int(0)));
                        ir_if *f06A0 = new(mem_ctx) ir_if(operand(r06A1).val);
                        exec_list *const f06A0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06A0->then_instructions;

                           ir_variable *const r06A2 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r06A2, r064F, 0x01));

                           ir_variable *const r06A3 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r06A3, neg(r064C), 0x01));

                           ir_variable *const r06A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r06A4);
                           ir_variable *const r06A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r06A5);
                           ir_variable *const r06A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r06A6);
                           ir_variable *const r06A7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r06A8 = neg(r06A3);
                           body.emit(assign(r06A7, bit_and(r06A8, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r06AA = equal(r06A3, body.constant(int(0)));
                           ir_if *f06A9 = new(mem_ctx) ir_if(operand(r06AA).val);
                           exec_list *const f06A9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f06A9->then_instructions;

                              body.emit(assign(r06A4, r064F, 0x01));

                              body.emit(assign(r06A5, r064E, 0x01));

                              body.emit(assign(r06A6, r064D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f06A9->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r06AC = less(r06A3, body.constant(int(32)));
                              ir_if *f06AB = new(mem_ctx) ir_if(operand(r06AC).val);
                              exec_list *const f06AB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f06AB->then_instructions;

                                 body.emit(assign(r06A4, lshift(r064E, r06A7), 0x01));

                                 ir_expression *const r06AD = lshift(r064D, r06A7);
                                 ir_expression *const r06AE = rshift(r064E, r06A3);
                                 body.emit(assign(r06A5, bit_or(r06AD, r06AE), 0x01));

                                 body.emit(assign(r06A6, rshift(r064D, r06A3), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f06AB->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r06B0 = equal(r06A3, body.constant(int(32)));
                                 ir_if *f06AF = new(mem_ctx) ir_if(operand(r06B0).val);
                                 exec_list *const f06AF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f06AF->then_instructions;

                                    body.emit(assign(r06A4, r064E, 0x01));

                                    body.emit(assign(r06A5, r064D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f06AF->else_instructions;

                                    body.emit(assign(r06A2, bit_or(r064F, r064E), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r06B2 = less(r06A3, body.constant(int(64)));
                                    ir_if *f06B1 = new(mem_ctx) ir_if(operand(r06B2).val);
                                    exec_list *const f06B1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f06B1->then_instructions;

                                       body.emit(assign(r06A4, lshift(r064D, r06A7), 0x01));

                                       ir_expression *const r06B3 = bit_and(r06A3, body.constant(int(31)));
                                       body.emit(assign(r06A5, rshift(r064D, r06B3), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f06B1->else_instructions;

                                       ir_variable *const r06B4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r06B6 = equal(r06A3, body.constant(int(64)));
                                       ir_if *f06B5 = new(mem_ctx) ir_if(operand(r06B6).val);
                                       exec_list *const f06B5_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f06B5->then_instructions;

                                          body.emit(assign(r06B4, r064D, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f06B5->else_instructions;

                                          ir_expression *const r06B7 = nequal(r064D, body.constant(0u));
                                          ir_expression *const r06B8 = expr(ir_unop_b2i, r06B7);
                                          body.emit(assign(r06B4, expr(ir_unop_i2u, r06B8), 0x01));


                                       body.instructions = f06B5_parent_instructions;
                                       body.emit(f06B5);

                                       /* END IF */

                                       body.emit(assign(r06A4, r06B4, 0x01));

                                       body.emit(assign(r06A5, body.constant(0u), 0x01));


                                    body.instructions = f06B1_parent_instructions;
                                    body.emit(f06B1);

                                    /* END IF */


                                 body.instructions = f06AF_parent_instructions;
                                 body.emit(f06AF);

                                 /* END IF */

                                 body.emit(assign(r06A6, body.constant(0u), 0x01));


                              body.instructions = f06AB_parent_instructions;
                              body.emit(f06AB);

                              /* END IF */

                              ir_expression *const r06B9 = nequal(r06A2, body.constant(0u));
                              ir_expression *const r06BA = expr(ir_unop_b2i, r06B9);
                              ir_expression *const r06BB = expr(ir_unop_i2u, r06BA);
                              body.emit(assign(r06A4, bit_or(r06A4, r06BB), 0x01));


                           body.instructions = f06A9_parent_instructions;
                           body.emit(f06A9);

                           /* END IF */

                           body.emit(assign(r068C, r06A6, 0x01));

                           body.emit(assign(r068D, r06A5, 0x01));

                           body.emit(assign(r068E, r06A4, 0x01));

                           body.emit(assign(r068B, body.constant(int(0)), 0x01));

                           body.emit(assign(r0691, less(r06A4, body.constant(0u)), 0x01));


                        body.instructions = f06A0_parent_instructions;
                        body.emit(f06A0);

                        /* END IF */


                     body.instructions = f069D_parent_instructions;
                     body.emit(f069D);

                     /* END IF */


                  body.instructions = f0693_parent_instructions;
                  body.emit(f0693);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f06BC = new(mem_ctx) ir_if(operand(r068F).val);
                  exec_list *const f06BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06BC->then_instructions;

                     /* IF CONDITION */
                     ir_if *f06BD = new(mem_ctx) ir_if(operand(r0691).val);
                     exec_list *const f06BD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06BD->then_instructions;

                        ir_variable *const r06BE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r06BE, add(r068D, body.constant(1u)), 0x01));

                        ir_expression *const r06BF = less(r06BE, r068D);
                        ir_expression *const r06C0 = expr(ir_unop_b2i, r06BF);
                        ir_expression *const r06C1 = expr(ir_unop_i2u, r06C0);
                        body.emit(assign(r068C, add(r068C, r06C1), 0x01));

                        ir_expression *const r06C2 = equal(r068E, body.constant(0u));
                        ir_expression *const r06C3 = expr(ir_unop_b2i, r06C2);
                        ir_expression *const r06C4 = expr(ir_unop_i2u, r06C3);
                        ir_expression *const r06C5 = add(r068E, r06C4);
                        ir_expression *const r06C6 = bit_and(r06C5, body.constant(1u));
                        ir_expression *const r06C7 = expr(ir_unop_bit_not, r06C6);
                        body.emit(assign(r068D, bit_and(r06BE, r06C7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06BD->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r06C9 = bit_or(r068C, r068D);
                        ir_expression *const r06CA = equal(r06C9, body.constant(0u));
                        ir_if *f06C8 = new(mem_ctx) ir_if(operand(r06CA).val);
                        exec_list *const f06C8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06C8->then_instructions;

                           body.emit(assign(r068B, body.constant(int(0)), 0x01));


                        body.instructions = f06C8_parent_instructions;
                        body.emit(f06C8);

                        /* END IF */


                     body.instructions = f06BD_parent_instructions;
                     body.emit(f06BD);

                     /* END IF */

                     ir_variable *const r06CB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r06CB);
                     ir_expression *const r06CC = lshift(r03D3, body.constant(int(31)));
                     ir_expression *const r06CD = expr(ir_unop_i2u, r068B);
                     ir_expression *const r06CE = lshift(r06CD, body.constant(int(20)));
                     ir_expression *const r06CF = add(r06CC, r06CE);
                     body.emit(assign(r06CB, add(r06CF, r068C), 0x02));

                     body.emit(assign(r06CB, r068D, 0x01));

                     body.emit(assign(r0690, r06CB, 0x03));

                     body.emit(assign(r068F, body.constant(false), 0x01));


                  body.instructions = f06BC_parent_instructions;
                  body.emit(f06BC);

                  /* END IF */

                  body.emit(assign(r03D4, r0690, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0644->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r06D1 = less(r03D9, r03DB);
                  ir_if *f06D0 = new(mem_ctx) ir_if(operand(r06D1).val);
                  exec_list *const f06D0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06D0->then_instructions;

                     ir_variable *const r06D2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r06D3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r06D3, sub(r03DB, r03D9), 0x01));

                     ir_expression *const r06D4 = sub(r03DA, r03D8);
                     ir_expression *const r06D5 = less(r03DB, r03D9);
                     ir_expression *const r06D6 = expr(ir_unop_b2i, r06D5);
                     ir_expression *const r06D7 = expr(ir_unop_i2u, r06D6);
                     body.emit(assign(r06D2, sub(r06D4, r06D7), 0x01));

                     body.emit(assign(r03DC, add(r03D7, body.constant(int(-1))), 0x01));

                     ir_variable *const r06D8 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r06D8, add(r03DC, body.constant(int(-10))), 0x01));

                     ir_variable *const r06D9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r06D9, r06D2, 0x01));

                     ir_variable *const r06DA = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r06DA, r06D3, 0x01));

                     ir_variable *const r06DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r06DB);
                     ir_variable *const r06DC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06DC);
                     /* IF CONDITION */
                     ir_expression *const r06DE = equal(r06D2, body.constant(0u));
                     ir_if *f06DD = new(mem_ctx) ir_if(operand(r06DE).val);
                     exec_list *const f06DD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06DD->then_instructions;

                        body.emit(assign(r06D9, r06D3, 0x01));

                        body.emit(assign(r06DA, body.constant(0u), 0x01));

                        body.emit(assign(r06D8, add(r06D8, body.constant(int(-32))), 0x01));


                     body.instructions = f06DD_parent_instructions;
                     body.emit(f06DD);

                     /* END IF */

                     ir_variable *const r06DF = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r06DF, r06D9, 0x01));

                     ir_variable *const r06E0 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r06E1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06E1);
                     /* IF CONDITION */
                     ir_expression *const r06E3 = equal(r06D9, body.constant(0u));
                     ir_if *f06E2 = new(mem_ctx) ir_if(operand(r06E3).val);
                     exec_list *const f06E2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06E2->then_instructions;

                        body.emit(assign(r06E0, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06E2->else_instructions;

                        body.emit(assign(r06E1, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r06E5 = bit_and(r06D9, body.constant(4294901760u));
                        ir_expression *const r06E6 = equal(r06E5, body.constant(0u));
                        ir_if *f06E4 = new(mem_ctx) ir_if(operand(r06E6).val);
                        exec_list *const f06E4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E4->then_instructions;

                           body.emit(assign(r06E1, body.constant(int(16)), 0x01));

                           body.emit(assign(r06DF, lshift(r06D9, body.constant(int(16))), 0x01));


                        body.instructions = f06E4_parent_instructions;
                        body.emit(f06E4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06E8 = bit_and(r06DF, body.constant(4278190080u));
                        ir_expression *const r06E9 = equal(r06E8, body.constant(0u));
                        ir_if *f06E7 = new(mem_ctx) ir_if(operand(r06E9).val);
                        exec_list *const f06E7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E7->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(8))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(8))), 0x01));


                        body.instructions = f06E7_parent_instructions;
                        body.emit(f06E7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06EB = bit_and(r06DF, body.constant(4026531840u));
                        ir_expression *const r06EC = equal(r06EB, body.constant(0u));
                        ir_if *f06EA = new(mem_ctx) ir_if(operand(r06EC).val);
                        exec_list *const f06EA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06EA->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(4))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(4))), 0x01));


                        body.instructions = f06EA_parent_instructions;
                        body.emit(f06EA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06EE = bit_and(r06DF, body.constant(3221225472u));
                        ir_expression *const r06EF = equal(r06EE, body.constant(0u));
                        ir_if *f06ED = new(mem_ctx) ir_if(operand(r06EF).val);
                        exec_list *const f06ED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06ED->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(2))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(2))), 0x01));


                        body.instructions = f06ED_parent_instructions;
                        body.emit(f06ED);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06F1 = bit_and(r06DF, body.constant(2147483648u));
                        ir_expression *const r06F2 = equal(r06F1, body.constant(0u));
                        ir_if *f06F0 = new(mem_ctx) ir_if(operand(r06F2).val);
                        exec_list *const f06F0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06F0->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(1))), 0x01));


                        body.instructions = f06F0_parent_instructions;
                        body.emit(f06F0);

                        /* END IF */

                        body.emit(assign(r06E0, r06E1, 0x01));


                     body.instructions = f06E2_parent_instructions;
                     body.emit(f06E2);

                     /* END IF */

                     body.emit(assign(r06DC, add(r06E0, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r06F4 = lequal(body.constant(int(0)), r06DC);
                     ir_if *f06F3 = new(mem_ctx) ir_if(operand(r06F4).val);
                     exec_list *const f06F3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06F3->then_instructions;

                        body.emit(assign(r06DB, body.constant(0u), 0x01));

                        ir_variable *const r06F5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r06F5, lshift(r06DA, r06DC), 0x01));

                        ir_variable *const r06F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r06F8 = equal(r06DC, body.constant(int(0)));
                        ir_if *f06F7 = new(mem_ctx) ir_if(operand(r06F8).val);
                        exec_list *const f06F7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06F7->then_instructions;

                           body.emit(assign(r06F6, r06D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f06F7->else_instructions;

                           ir_expression *const r06F9 = lshift(r06D9, r06DC);
                           ir_expression *const r06FA = neg(r06DC);
                           ir_expression *const r06FB = bit_and(r06FA, body.constant(int(31)));
                           ir_expression *const r06FC = rshift(r06DA, r06FB);
                           body.emit(assign(r06F6, bit_or(r06F9, r06FC), 0x01));


                        body.instructions = f06F7_parent_instructions;
                        body.emit(f06F7);

                        /* END IF */

                        body.emit(assign(r06D9, r06F6, 0x01));

                        body.emit(assign(r06DA, r06F5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06F3->else_instructions;

                        ir_variable *const r06FD = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r06FD, body.constant(0u), 0x01));

                        ir_variable *const r06FE = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r06FE, neg(r06DC), 0x01));

                        ir_variable *const r06FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r06FF);
                        ir_variable *const r0700 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0700);
                        ir_variable *const r0701 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0701);
                        ir_variable *const r0702 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0703 = neg(r06FE);
                        body.emit(assign(r0702, bit_and(r0703, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0705 = equal(r06FE, body.constant(int(0)));
                        ir_if *f0704 = new(mem_ctx) ir_if(operand(r0705).val);
                        exec_list *const f0704_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0704->then_instructions;

                           body.emit(assign(r06FF, r06FD, 0x01));

                           body.emit(assign(r0700, r06DA, 0x01));

                           body.emit(assign(r0701, r06D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0704->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0707 = less(r06FE, body.constant(int(32)));
                           ir_if *f0706 = new(mem_ctx) ir_if(operand(r0707).val);
                           exec_list *const f0706_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0706->then_instructions;

                              body.emit(assign(r06FF, lshift(r06DA, r0702), 0x01));

                              ir_expression *const r0708 = lshift(r06D9, r0702);
                              ir_expression *const r0709 = rshift(r06DA, r06FE);
                              body.emit(assign(r0700, bit_or(r0708, r0709), 0x01));

                              body.emit(assign(r0701, rshift(r06D9, r06FE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0706->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r070B = equal(r06FE, body.constant(int(32)));
                              ir_if *f070A = new(mem_ctx) ir_if(operand(r070B).val);
                              exec_list *const f070A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f070A->then_instructions;

                                 body.emit(assign(r06FF, r06DA, 0x01));

                                 body.emit(assign(r0700, r06D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f070A->else_instructions;

                                 body.emit(assign(r06FD, bit_or(body.constant(0u), r06DA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r070D = less(r06FE, body.constant(int(64)));
                                 ir_if *f070C = new(mem_ctx) ir_if(operand(r070D).val);
                                 exec_list *const f070C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f070C->then_instructions;

                                    body.emit(assign(r06FF, lshift(r06D9, r0702), 0x01));

                                    ir_expression *const r070E = bit_and(r06FE, body.constant(int(31)));
                                    body.emit(assign(r0700, rshift(r06D9, r070E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f070C->else_instructions;

                                    ir_variable *const r070F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0711 = equal(r06FE, body.constant(int(64)));
                                    ir_if *f0710 = new(mem_ctx) ir_if(operand(r0711).val);
                                    exec_list *const f0710_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0710->then_instructions;

                                       body.emit(assign(r070F, r06D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0710->else_instructions;

                                       ir_expression *const r0712 = nequal(r06D9, body.constant(0u));
                                       ir_expression *const r0713 = expr(ir_unop_b2i, r0712);
                                       body.emit(assign(r070F, expr(ir_unop_i2u, r0713), 0x01));


                                    body.instructions = f0710_parent_instructions;
                                    body.emit(f0710);

                                    /* END IF */

                                    body.emit(assign(r06FF, r070F, 0x01));

                                    body.emit(assign(r0700, body.constant(0u), 0x01));


                                 body.instructions = f070C_parent_instructions;
                                 body.emit(f070C);

                                 /* END IF */


                              body.instructions = f070A_parent_instructions;
                              body.emit(f070A);

                              /* END IF */

                              body.emit(assign(r0701, body.constant(0u), 0x01));


                           body.instructions = f0706_parent_instructions;
                           body.emit(f0706);

                           /* END IF */

                           ir_expression *const r0714 = nequal(r06FD, body.constant(0u));
                           ir_expression *const r0715 = expr(ir_unop_b2i, r0714);
                           ir_expression *const r0716 = expr(ir_unop_i2u, r0715);
                           body.emit(assign(r06FF, bit_or(r06FF, r0716), 0x01));


                        body.instructions = f0704_parent_instructions;
                        body.emit(f0704);

                        /* END IF */

                        body.emit(assign(r06D9, r0701, 0x01));

                        body.emit(assign(r06DA, r0700, 0x01));

                        body.emit(assign(r06DB, r06FF, 0x01));


                     body.instructions = f06F3_parent_instructions;
                     body.emit(f06F3);

                     /* END IF */

                     body.emit(assign(r06D8, sub(r06D8, r06DC), 0x01));

                     ir_variable *const r0717 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0717, r06D8, 0x01));

                     ir_variable *const r0718 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0718, r06D9, 0x01));

                     ir_variable *const r0719 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0719, r06DA, 0x01));

                     ir_variable *const r071A = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r071A, r06DB, 0x01));

                     ir_variable *const r071B = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r071B, body.constant(true), 0x01));

                     ir_variable *const r071C = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r071D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r071D);
                     ir_expression *const r071E = expr(ir_unop_u2i, r06DB);
                     body.emit(assign(r071D, less(r071E, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0720 = lequal(body.constant(int(2045)), r06D8);
                     ir_if *f071F = new(mem_ctx) ir_if(operand(r0720).val);
                     exec_list *const f071F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f071F->then_instructions;

                        ir_variable *const r0721 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0723 = less(body.constant(int(2045)), r06D8);
                        ir_if *f0722 = new(mem_ctx) ir_if(operand(r0723).val);
                        exec_list *const f0722_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0722->then_instructions;

                           body.emit(assign(r0721, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0722->else_instructions;

                           ir_variable *const r0724 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0726 = equal(r06D8, body.constant(int(2045)));
                           ir_if *f0725 = new(mem_ctx) ir_if(operand(r0726).val);
                           exec_list *const f0725_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0725->then_instructions;

                              ir_expression *const r0727 = equal(body.constant(2097151u), r06D9);
                              ir_expression *const r0728 = equal(body.constant(4294967295u), r06DA);
                              body.emit(assign(r0724, logic_and(r0727, r0728), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0725->else_instructions;

                              body.emit(assign(r0724, body.constant(false), 0x01));


                           body.instructions = f0725_parent_instructions;
                           body.emit(f0725);

                           /* END IF */

                           body.emit(assign(r0721, logic_and(r0724, r071D), 0x01));


                        body.instructions = f0722_parent_instructions;
                        body.emit(f0722);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0729 = new(mem_ctx) ir_if(operand(r0721).val);
                        exec_list *const f0729_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0729->then_instructions;

                           ir_variable *const r072A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r072A);
                           ir_expression *const r072B = lshift(r03D3, body.constant(int(31)));
                           body.emit(assign(r072A, add(r072B, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r072A, body.constant(0u), 0x01));

                           body.emit(assign(r071C, r072A, 0x03));

                           body.emit(assign(r071B, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0729->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r072D = less(r06D8, body.constant(int(0)));
                           ir_if *f072C = new(mem_ctx) ir_if(operand(r072D).val);
                           exec_list *const f072C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f072C->then_instructions;

                              ir_variable *const r072E = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r072E, r06DB, 0x01));

                              ir_variable *const r072F = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r072F, neg(r06D8), 0x01));

                              ir_variable *const r0730 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0730);
                              ir_variable *const r0731 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0731);
                              ir_variable *const r0732 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0732);
                              ir_variable *const r0733 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0734 = neg(r072F);
                              body.emit(assign(r0733, bit_and(r0734, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0736 = equal(r072F, body.constant(int(0)));
                              ir_if *f0735 = new(mem_ctx) ir_if(operand(r0736).val);
                              exec_list *const f0735_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0735->then_instructions;

                                 body.emit(assign(r0730, r06DB, 0x01));

                                 body.emit(assign(r0731, r06DA, 0x01));

                                 body.emit(assign(r0732, r06D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0735->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0738 = less(r072F, body.constant(int(32)));
                                 ir_if *f0737 = new(mem_ctx) ir_if(operand(r0738).val);
                                 exec_list *const f0737_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0737->then_instructions;

                                    body.emit(assign(r0730, lshift(r06DA, r0733), 0x01));

                                    ir_expression *const r0739 = lshift(r06D9, r0733);
                                    ir_expression *const r073A = rshift(r06DA, r072F);
                                    body.emit(assign(r0731, bit_or(r0739, r073A), 0x01));

                                    body.emit(assign(r0732, rshift(r06D9, r072F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0737->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r073C = equal(r072F, body.constant(int(32)));
                                    ir_if *f073B = new(mem_ctx) ir_if(operand(r073C).val);
                                    exec_list *const f073B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f073B->then_instructions;

                                       body.emit(assign(r0730, r06DA, 0x01));

                                       body.emit(assign(r0731, r06D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f073B->else_instructions;

                                       body.emit(assign(r072E, bit_or(r06DB, r06DA), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r073E = less(r072F, body.constant(int(64)));
                                       ir_if *f073D = new(mem_ctx) ir_if(operand(r073E).val);
                                       exec_list *const f073D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f073D->then_instructions;

                                          body.emit(assign(r0730, lshift(r06D9, r0733), 0x01));

                                          ir_expression *const r073F = bit_and(r072F, body.constant(int(31)));
                                          body.emit(assign(r0731, rshift(r06D9, r073F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f073D->else_instructions;

                                          ir_variable *const r0740 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0742 = equal(r072F, body.constant(int(64)));
                                          ir_if *f0741 = new(mem_ctx) ir_if(operand(r0742).val);
                                          exec_list *const f0741_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0741->then_instructions;

                                             body.emit(assign(r0740, r06D9, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0741->else_instructions;

                                             ir_expression *const r0743 = nequal(r06D9, body.constant(0u));
                                             ir_expression *const r0744 = expr(ir_unop_b2i, r0743);
                                             body.emit(assign(r0740, expr(ir_unop_i2u, r0744), 0x01));


                                          body.instructions = f0741_parent_instructions;
                                          body.emit(f0741);

                                          /* END IF */

                                          body.emit(assign(r0730, r0740, 0x01));

                                          body.emit(assign(r0731, body.constant(0u), 0x01));


                                       body.instructions = f073D_parent_instructions;
                                       body.emit(f073D);

                                       /* END IF */


                                    body.instructions = f073B_parent_instructions;
                                    body.emit(f073B);

                                    /* END IF */

                                    body.emit(assign(r0732, body.constant(0u), 0x01));


                                 body.instructions = f0737_parent_instructions;
                                 body.emit(f0737);

                                 /* END IF */

                                 ir_expression *const r0745 = nequal(r072E, body.constant(0u));
                                 ir_expression *const r0746 = expr(ir_unop_b2i, r0745);
                                 ir_expression *const r0747 = expr(ir_unop_i2u, r0746);
                                 body.emit(assign(r0730, bit_or(r0730, r0747), 0x01));


                              body.instructions = f0735_parent_instructions;
                              body.emit(f0735);

                              /* END IF */

                              body.emit(assign(r0718, r0732, 0x01));

                              body.emit(assign(r0719, r0731, 0x01));

                              body.emit(assign(r071A, r0730, 0x01));

                              body.emit(assign(r0717, body.constant(int(0)), 0x01));

                              body.emit(assign(r071D, less(r0730, body.constant(0u)), 0x01));


                           body.instructions = f072C_parent_instructions;
                           body.emit(f072C);

                           /* END IF */


                        body.instructions = f0729_parent_instructions;
                        body.emit(f0729);

                        /* END IF */


                     body.instructions = f071F_parent_instructions;
                     body.emit(f071F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0748 = new(mem_ctx) ir_if(operand(r071B).val);
                     exec_list *const f0748_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0748->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0749 = new(mem_ctx) ir_if(operand(r071D).val);
                        exec_list *const f0749_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0749->then_instructions;

                           ir_variable *const r074A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r074A, add(r0719, body.constant(1u)), 0x01));

                           ir_expression *const r074B = less(r074A, r0719);
                           ir_expression *const r074C = expr(ir_unop_b2i, r074B);
                           ir_expression *const r074D = expr(ir_unop_i2u, r074C);
                           body.emit(assign(r0718, add(r0718, r074D), 0x01));

                           ir_expression *const r074E = equal(r071A, body.constant(0u));
                           ir_expression *const r074F = expr(ir_unop_b2i, r074E);
                           ir_expression *const r0750 = expr(ir_unop_i2u, r074F);
                           ir_expression *const r0751 = add(r071A, r0750);
                           ir_expression *const r0752 = bit_and(r0751, body.constant(1u));
                           ir_expression *const r0753 = expr(ir_unop_bit_not, r0752);
                           body.emit(assign(r0719, bit_and(r074A, r0753), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0749->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0755 = bit_or(r0718, r0719);
                           ir_expression *const r0756 = equal(r0755, body.constant(0u));
                           ir_if *f0754 = new(mem_ctx) ir_if(operand(r0756).val);
                           exec_list *const f0754_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0754->then_instructions;

                              body.emit(assign(r0717, body.constant(int(0)), 0x01));


                           body.instructions = f0754_parent_instructions;
                           body.emit(f0754);

                           /* END IF */


                        body.instructions = f0749_parent_instructions;
                        body.emit(f0749);

                        /* END IF */

                        ir_variable *const r0757 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0757);
                        ir_expression *const r0758 = lshift(r03D3, body.constant(int(31)));
                        ir_expression *const r0759 = expr(ir_unop_i2u, r0717);
                        ir_expression *const r075A = lshift(r0759, body.constant(int(20)));
                        ir_expression *const r075B = add(r0758, r075A);
                        body.emit(assign(r0757, add(r075B, r0718), 0x02));

                        body.emit(assign(r0757, r0719, 0x01));

                        body.emit(assign(r071C, r0757, 0x03));

                        body.emit(assign(r071B, body.constant(false), 0x01));


                     body.instructions = f0748_parent_instructions;
                     body.emit(f0748);

                     /* END IF */

                     body.emit(assign(r03D4, r071C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f06D0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r075D = less(r03DB, r03D9);
                     ir_if *f075C = new(mem_ctx) ir_if(operand(r075D).val);
                     exec_list *const f075C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f075C->then_instructions;

                        ir_variable *const r075E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r075F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r075F, sub(r03D9, r03DB), 0x01));

                        ir_expression *const r0760 = sub(r03D8, r03DA);
                        ir_expression *const r0761 = less(r03D9, r03DB);
                        ir_expression *const r0762 = expr(ir_unop_b2i, r0761);
                        ir_expression *const r0763 = expr(ir_unop_i2u, r0762);
                        body.emit(assign(r075E, sub(r0760, r0763), 0x01));

                        body.emit(assign(r03D3, bit_xor(r03D3, body.constant(1u)), 0x01));

                        body.emit(assign(r03DC, add(r03D6, body.constant(int(-1))), 0x01));

                        ir_variable *const r0764 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0764, add(r03DC, body.constant(int(-10))), 0x01));

                        ir_variable *const r0765 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0765, r075E, 0x01));

                        ir_variable *const r0766 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0766, r075F, 0x01));

                        ir_variable *const r0767 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0767);
                        ir_variable *const r0768 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0768);
                        /* IF CONDITION */
                        ir_expression *const r076A = equal(r075E, body.constant(0u));
                        ir_if *f0769 = new(mem_ctx) ir_if(operand(r076A).val);
                        exec_list *const f0769_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0769->then_instructions;

                           body.emit(assign(r0765, r075F, 0x01));

                           body.emit(assign(r0766, body.constant(0u), 0x01));

                           body.emit(assign(r0764, add(r0764, body.constant(int(-32))), 0x01));


                        body.instructions = f0769_parent_instructions;
                        body.emit(f0769);

                        /* END IF */

                        ir_variable *const r076B = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r076B, r0765, 0x01));

                        ir_variable *const r076C = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r076D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r076D);
                        /* IF CONDITION */
                        ir_expression *const r076F = equal(r0765, body.constant(0u));
                        ir_if *f076E = new(mem_ctx) ir_if(operand(r076F).val);
                        exec_list *const f076E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f076E->then_instructions;

                           body.emit(assign(r076C, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f076E->else_instructions;

                           body.emit(assign(r076D, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0771 = bit_and(r0765, body.constant(4294901760u));
                           ir_expression *const r0772 = equal(r0771, body.constant(0u));
                           ir_if *f0770 = new(mem_ctx) ir_if(operand(r0772).val);
                           exec_list *const f0770_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0770->then_instructions;

                              body.emit(assign(r076D, body.constant(int(16)), 0x01));

                              body.emit(assign(r076B, lshift(r0765, body.constant(int(16))), 0x01));


                           body.instructions = f0770_parent_instructions;
                           body.emit(f0770);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0774 = bit_and(r076B, body.constant(4278190080u));
                           ir_expression *const r0775 = equal(r0774, body.constant(0u));
                           ir_if *f0773 = new(mem_ctx) ir_if(operand(r0775).val);
                           exec_list *const f0773_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0773->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(8))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(8))), 0x01));


                           body.instructions = f0773_parent_instructions;
                           body.emit(f0773);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0777 = bit_and(r076B, body.constant(4026531840u));
                           ir_expression *const r0778 = equal(r0777, body.constant(0u));
                           ir_if *f0776 = new(mem_ctx) ir_if(operand(r0778).val);
                           exec_list *const f0776_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0776->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(4))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(4))), 0x01));


                           body.instructions = f0776_parent_instructions;
                           body.emit(f0776);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r077A = bit_and(r076B, body.constant(3221225472u));
                           ir_expression *const r077B = equal(r077A, body.constant(0u));
                           ir_if *f0779 = new(mem_ctx) ir_if(operand(r077B).val);
                           exec_list *const f0779_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0779->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(2))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(2))), 0x01));


                           body.instructions = f0779_parent_instructions;
                           body.emit(f0779);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r077D = bit_and(r076B, body.constant(2147483648u));
                           ir_expression *const r077E = equal(r077D, body.constant(0u));
                           ir_if *f077C = new(mem_ctx) ir_if(operand(r077E).val);
                           exec_list *const f077C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f077C->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(1))), 0x01));


                           body.instructions = f077C_parent_instructions;
                           body.emit(f077C);

                           /* END IF */

                           body.emit(assign(r076C, r076D, 0x01));


                        body.instructions = f076E_parent_instructions;
                        body.emit(f076E);

                        /* END IF */

                        body.emit(assign(r0768, add(r076C, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0780 = lequal(body.constant(int(0)), r0768);
                        ir_if *f077F = new(mem_ctx) ir_if(operand(r0780).val);
                        exec_list *const f077F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f077F->then_instructions;

                           body.emit(assign(r0767, body.constant(0u), 0x01));

                           ir_variable *const r0781 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0781, lshift(r0766, r0768), 0x01));

                           ir_variable *const r0782 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0784 = equal(r0768, body.constant(int(0)));
                           ir_if *f0783 = new(mem_ctx) ir_if(operand(r0784).val);
                           exec_list *const f0783_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0783->then_instructions;

                              body.emit(assign(r0782, r0765, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0783->else_instructions;

                              ir_expression *const r0785 = lshift(r0765, r0768);
                              ir_expression *const r0786 = neg(r0768);
                              ir_expression *const r0787 = bit_and(r0786, body.constant(int(31)));
                              ir_expression *const r0788 = rshift(r0766, r0787);
                              body.emit(assign(r0782, bit_or(r0785, r0788), 0x01));


                           body.instructions = f0783_parent_instructions;
                           body.emit(f0783);

                           /* END IF */

                           body.emit(assign(r0765, r0782, 0x01));

                           body.emit(assign(r0766, r0781, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f077F->else_instructions;

                           ir_variable *const r0789 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0789, body.constant(0u), 0x01));

                           ir_variable *const r078A = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r078A, neg(r0768), 0x01));

                           ir_variable *const r078B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r078B);
                           ir_variable *const r078C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r078C);
                           ir_variable *const r078D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r078D);
                           ir_variable *const r078E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r078F = neg(r078A);
                           body.emit(assign(r078E, bit_and(r078F, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0791 = equal(r078A, body.constant(int(0)));
                           ir_if *f0790 = new(mem_ctx) ir_if(operand(r0791).val);
                           exec_list *const f0790_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0790->then_instructions;

                              body.emit(assign(r078B, r0789, 0x01));

                              body.emit(assign(r078C, r0766, 0x01));

                              body.emit(assign(r078D, r0765, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0790->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0793 = less(r078A, body.constant(int(32)));
                              ir_if *f0792 = new(mem_ctx) ir_if(operand(r0793).val);
                              exec_list *const f0792_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0792->then_instructions;

                                 body.emit(assign(r078B, lshift(r0766, r078E), 0x01));

                                 ir_expression *const r0794 = lshift(r0765, r078E);
                                 ir_expression *const r0795 = rshift(r0766, r078A);
                                 body.emit(assign(r078C, bit_or(r0794, r0795), 0x01));

                                 body.emit(assign(r078D, rshift(r0765, r078A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0792->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0797 = equal(r078A, body.constant(int(32)));
                                 ir_if *f0796 = new(mem_ctx) ir_if(operand(r0797).val);
                                 exec_list *const f0796_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0796->then_instructions;

                                    body.emit(assign(r078B, r0766, 0x01));

                                    body.emit(assign(r078C, r0765, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0796->else_instructions;

                                    body.emit(assign(r0789, bit_or(body.constant(0u), r0766), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0799 = less(r078A, body.constant(int(64)));
                                    ir_if *f0798 = new(mem_ctx) ir_if(operand(r0799).val);
                                    exec_list *const f0798_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0798->then_instructions;

                                       body.emit(assign(r078B, lshift(r0765, r078E), 0x01));

                                       ir_expression *const r079A = bit_and(r078A, body.constant(int(31)));
                                       body.emit(assign(r078C, rshift(r0765, r079A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0798->else_instructions;

                                       ir_variable *const r079B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r079D = equal(r078A, body.constant(int(64)));
                                       ir_if *f079C = new(mem_ctx) ir_if(operand(r079D).val);
                                       exec_list *const f079C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f079C->then_instructions;

                                          body.emit(assign(r079B, r0765, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f079C->else_instructions;

                                          ir_expression *const r079E = nequal(r0765, body.constant(0u));
                                          ir_expression *const r079F = expr(ir_unop_b2i, r079E);
                                          body.emit(assign(r079B, expr(ir_unop_i2u, r079F), 0x01));


                                       body.instructions = f079C_parent_instructions;
                                       body.emit(f079C);

                                       /* END IF */

                                       body.emit(assign(r078B, r079B, 0x01));

                                       body.emit(assign(r078C, body.constant(0u), 0x01));


                                    body.instructions = f0798_parent_instructions;
                                    body.emit(f0798);

                                    /* END IF */


                                 body.instructions = f0796_parent_instructions;
                                 body.emit(f0796);

                                 /* END IF */

                                 body.emit(assign(r078D, body.constant(0u), 0x01));


                              body.instructions = f0792_parent_instructions;
                              body.emit(f0792);

                              /* END IF */

                              ir_expression *const r07A0 = nequal(r0789, body.constant(0u));
                              ir_expression *const r07A1 = expr(ir_unop_b2i, r07A0);
                              ir_expression *const r07A2 = expr(ir_unop_i2u, r07A1);
                              body.emit(assign(r078B, bit_or(r078B, r07A2), 0x01));


                           body.instructions = f0790_parent_instructions;
                           body.emit(f0790);

                           /* END IF */

                           body.emit(assign(r0765, r078D, 0x01));

                           body.emit(assign(r0766, r078C, 0x01));

                           body.emit(assign(r0767, r078B, 0x01));


                        body.instructions = f077F_parent_instructions;
                        body.emit(f077F);

                        /* END IF */

                        body.emit(assign(r0764, sub(r0764, r0768), 0x01));

                        ir_variable *const r07A3 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r07A3, r0764, 0x01));

                        ir_variable *const r07A4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r07A4, r0765, 0x01));

                        ir_variable *const r07A5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r07A5, r0766, 0x01));

                        ir_variable *const r07A6 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r07A6, r0767, 0x01));

                        ir_variable *const r07A7 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r07A7, body.constant(true), 0x01));

                        ir_variable *const r07A8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r07A9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r07A9);
                        ir_expression *const r07AA = expr(ir_unop_u2i, r0767);
                        body.emit(assign(r07A9, less(r07AA, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r07AC = lequal(body.constant(int(2045)), r0764);
                        ir_if *f07AB = new(mem_ctx) ir_if(operand(r07AC).val);
                        exec_list *const f07AB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07AB->then_instructions;

                           ir_variable *const r07AD = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r07AF = less(body.constant(int(2045)), r0764);
                           ir_if *f07AE = new(mem_ctx) ir_if(operand(r07AF).val);
                           exec_list *const f07AE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07AE->then_instructions;

                              body.emit(assign(r07AD, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07AE->else_instructions;

                              ir_variable *const r07B0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r07B2 = equal(r0764, body.constant(int(2045)));
                              ir_if *f07B1 = new(mem_ctx) ir_if(operand(r07B2).val);
                              exec_list *const f07B1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07B1->then_instructions;

                                 ir_expression *const r07B3 = equal(body.constant(2097151u), r0765);
                                 ir_expression *const r07B4 = equal(body.constant(4294967295u), r0766);
                                 body.emit(assign(r07B0, logic_and(r07B3, r07B4), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f07B1->else_instructions;

                                 body.emit(assign(r07B0, body.constant(false), 0x01));


                              body.instructions = f07B1_parent_instructions;
                              body.emit(f07B1);

                              /* END IF */

                              body.emit(assign(r07AD, logic_and(r07B0, r07A9), 0x01));


                           body.instructions = f07AE_parent_instructions;
                           body.emit(f07AE);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f07B5 = new(mem_ctx) ir_if(operand(r07AD).val);
                           exec_list *const f07B5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07B5->then_instructions;

                              ir_variable *const r07B6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r07B6);
                              ir_expression *const r07B7 = lshift(r03D3, body.constant(int(31)));
                              body.emit(assign(r07B6, add(r07B7, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r07B6, body.constant(0u), 0x01));

                              body.emit(assign(r07A8, r07B6, 0x03));

                              body.emit(assign(r07A7, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07B5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07B9 = less(r0764, body.constant(int(0)));
                              ir_if *f07B8 = new(mem_ctx) ir_if(operand(r07B9).val);
                              exec_list *const f07B8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07B8->then_instructions;

                                 ir_variable *const r07BA = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r07BA, r0767, 0x01));

                                 ir_variable *const r07BB = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r07BB, neg(r0764), 0x01));

                                 ir_variable *const r07BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r07BC);
                                 ir_variable *const r07BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r07BD);
                                 ir_variable *const r07BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r07BE);
                                 ir_variable *const r07BF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r07C0 = neg(r07BB);
                                 body.emit(assign(r07BF, bit_and(r07C0, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r07C2 = equal(r07BB, body.constant(int(0)));
                                 ir_if *f07C1 = new(mem_ctx) ir_if(operand(r07C2).val);
                                 exec_list *const f07C1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f07C1->then_instructions;

                                    body.emit(assign(r07BC, r0767, 0x01));

                                    body.emit(assign(r07BD, r0766, 0x01));

                                    body.emit(assign(r07BE, r0765, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f07C1->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r07C4 = less(r07BB, body.constant(int(32)));
                                    ir_if *f07C3 = new(mem_ctx) ir_if(operand(r07C4).val);
                                    exec_list *const f07C3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f07C3->then_instructions;

                                       body.emit(assign(r07BC, lshift(r0766, r07BF), 0x01));

                                       ir_expression *const r07C5 = lshift(r0765, r07BF);
                                       ir_expression *const r07C6 = rshift(r0766, r07BB);
                                       body.emit(assign(r07BD, bit_or(r07C5, r07C6), 0x01));

                                       body.emit(assign(r07BE, rshift(r0765, r07BB), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f07C3->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r07C8 = equal(r07BB, body.constant(int(32)));
                                       ir_if *f07C7 = new(mem_ctx) ir_if(operand(r07C8).val);
                                       exec_list *const f07C7_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f07C7->then_instructions;

                                          body.emit(assign(r07BC, r0766, 0x01));

                                          body.emit(assign(r07BD, r0765, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f07C7->else_instructions;

                                          body.emit(assign(r07BA, bit_or(r0767, r0766), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r07CA = less(r07BB, body.constant(int(64)));
                                          ir_if *f07C9 = new(mem_ctx) ir_if(operand(r07CA).val);
                                          exec_list *const f07C9_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f07C9->then_instructions;

                                             body.emit(assign(r07BC, lshift(r0765, r07BF), 0x01));

                                             ir_expression *const r07CB = bit_and(r07BB, body.constant(int(31)));
                                             body.emit(assign(r07BD, rshift(r0765, r07CB), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f07C9->else_instructions;

                                             ir_variable *const r07CC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r07CE = equal(r07BB, body.constant(int(64)));
                                             ir_if *f07CD = new(mem_ctx) ir_if(operand(r07CE).val);
                                             exec_list *const f07CD_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f07CD->then_instructions;

                                                body.emit(assign(r07CC, r0765, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f07CD->else_instructions;

                                                ir_expression *const r07CF = nequal(r0765, body.constant(0u));
                                                ir_expression *const r07D0 = expr(ir_unop_b2i, r07CF);
                                                body.emit(assign(r07CC, expr(ir_unop_i2u, r07D0), 0x01));


                                             body.instructions = f07CD_parent_instructions;
                                             body.emit(f07CD);

                                             /* END IF */

                                             body.emit(assign(r07BC, r07CC, 0x01));

                                             body.emit(assign(r07BD, body.constant(0u), 0x01));


                                          body.instructions = f07C9_parent_instructions;
                                          body.emit(f07C9);

                                          /* END IF */


                                       body.instructions = f07C7_parent_instructions;
                                       body.emit(f07C7);

                                       /* END IF */

                                       body.emit(assign(r07BE, body.constant(0u), 0x01));


                                    body.instructions = f07C3_parent_instructions;
                                    body.emit(f07C3);

                                    /* END IF */

                                    ir_expression *const r07D1 = nequal(r07BA, body.constant(0u));
                                    ir_expression *const r07D2 = expr(ir_unop_b2i, r07D1);
                                    ir_expression *const r07D3 = expr(ir_unop_i2u, r07D2);
                                    body.emit(assign(r07BC, bit_or(r07BC, r07D3), 0x01));


                                 body.instructions = f07C1_parent_instructions;
                                 body.emit(f07C1);

                                 /* END IF */

                                 body.emit(assign(r07A4, r07BE, 0x01));

                                 body.emit(assign(r07A5, r07BD, 0x01));

                                 body.emit(assign(r07A6, r07BC, 0x01));

                                 body.emit(assign(r07A3, body.constant(int(0)), 0x01));

                                 body.emit(assign(r07A9, less(r07BC, body.constant(0u)), 0x01));


                              body.instructions = f07B8_parent_instructions;
                              body.emit(f07B8);

                              /* END IF */


                           body.instructions = f07B5_parent_instructions;
                           body.emit(f07B5);

                           /* END IF */


                        body.instructions = f07AB_parent_instructions;
                        body.emit(f07AB);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f07D4 = new(mem_ctx) ir_if(operand(r07A7).val);
                        exec_list *const f07D4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07D4->then_instructions;

                           /* IF CONDITION */
                           ir_if *f07D5 = new(mem_ctx) ir_if(operand(r07A9).val);
                           exec_list *const f07D5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07D5->then_instructions;

                              ir_variable *const r07D6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r07D6, add(r07A5, body.constant(1u)), 0x01));

                              ir_expression *const r07D7 = less(r07D6, r07A5);
                              ir_expression *const r07D8 = expr(ir_unop_b2i, r07D7);
                              ir_expression *const r07D9 = expr(ir_unop_i2u, r07D8);
                              body.emit(assign(r07A4, add(r07A4, r07D9), 0x01));

                              ir_expression *const r07DA = equal(r07A6, body.constant(0u));
                              ir_expression *const r07DB = expr(ir_unop_b2i, r07DA);
                              ir_expression *const r07DC = expr(ir_unop_i2u, r07DB);
                              ir_expression *const r07DD = add(r07A6, r07DC);
                              ir_expression *const r07DE = bit_and(r07DD, body.constant(1u));
                              ir_expression *const r07DF = expr(ir_unop_bit_not, r07DE);
                              body.emit(assign(r07A5, bit_and(r07D6, r07DF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07D5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07E1 = bit_or(r07A4, r07A5);
                              ir_expression *const r07E2 = equal(r07E1, body.constant(0u));
                              ir_if *f07E0 = new(mem_ctx) ir_if(operand(r07E2).val);
                              exec_list *const f07E0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07E0->then_instructions;

                                 body.emit(assign(r07A3, body.constant(int(0)), 0x01));


                              body.instructions = f07E0_parent_instructions;
                              body.emit(f07E0);

                              /* END IF */


                           body.instructions = f07D5_parent_instructions;
                           body.emit(f07D5);

                           /* END IF */

                           ir_variable *const r07E3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r07E3);
                           ir_expression *const r07E4 = lshift(r03D3, body.constant(int(31)));
                           ir_expression *const r07E5 = expr(ir_unop_i2u, r07A3);
                           ir_expression *const r07E6 = lshift(r07E5, body.constant(int(20)));
                           ir_expression *const r07E7 = add(r07E4, r07E6);
                           body.emit(assign(r07E3, add(r07E7, r07A4), 0x02));

                           body.emit(assign(r07E3, r07A5, 0x01));

                           body.emit(assign(r07A8, r07E3, 0x03));

                           body.emit(assign(r07A7, body.constant(false), 0x01));


                        body.instructions = f07D4_parent_instructions;
                        body.emit(f07D4);

                        /* END IF */

                        body.emit(assign(r03D4, r07A8, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f075C->else_instructions;

                        ir_variable *const r07E8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r07E8);
                        body.emit(assign(r07E8, body.constant(0u), 0x02));

                        body.emit(assign(r07E8, body.constant(0u), 0x01));

                        body.emit(assign(r03D4, r07E8, 0x03));


                     body.instructions = f075C_parent_instructions;
                     body.emit(f075C);

                     /* END IF */


                  body.instructions = f06D0_parent_instructions;
                  body.emit(f06D0);

                  /* END IF */


               body.instructions = f0644_parent_instructions;
               body.emit(f0644);

               /* END IF */


            body.instructions = f05B8_parent_instructions;
            body.emit(f05B8);

            /* END IF */


         body.instructions = f0591_parent_instructions;
         body.emit(f0591);

         /* END IF */


      body.instructions = f04BD_parent_instructions;
      body.emit(f04BD);

      /* END IF */


   body.instructions = f03ED_parent_instructions;
   body.emit(f03ED);

   /* END IF */

   body.emit(ret(r03D4));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fadd64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r07E9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r07E9);
   ir_variable *const r07EA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r07EA);
   ir_variable *const r07EB = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r07EC = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07EC, rshift(swizzle_y(r07E9), body.constant(int(31))), 0x01));

   ir_variable *const r07ED = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07ED, rshift(swizzle_y(r07EA), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r07EF = equal(r07EC, r07ED);
   ir_if *f07EE = new(mem_ctx) ir_if(operand(r07EF).val);
   exec_list *const f07EE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f07EE->then_instructions;

      ir_variable *const r07F0 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r07F0, body.constant(true), 0x01));

      ir_variable *const r07F1 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r07F2 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r07F2);
      ir_variable *const r07F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r07F3);
      ir_variable *const r07F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r07F4);
      ir_variable *const r07F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r07F5);
      ir_variable *const r07F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r07F6);
      ir_variable *const r07F7 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r07F7);
      ir_variable *const r07F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r07F8);
      ir_variable *const r07F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r07F9);
      body.emit(assign(r07F9, body.constant(0u), 0x01));

      body.emit(assign(r07F8, body.constant(0u), 0x01));

      ir_variable *const r07FA = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r07FA, swizzle_x(r07E9), 0x01));

      body.emit(assign(r07F6, r07FA, 0x01));

      ir_variable *const r07FB = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r07FB, bit_and(swizzle_y(r07E9), body.constant(1048575u)), 0x01));

      body.emit(assign(r07F5, r07FB, 0x01));

      ir_variable *const r07FC = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r07FC, swizzle_x(r07EA), 0x01));

      body.emit(assign(r07F4, r07FC, 0x01));

      ir_variable *const r07FD = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r07FD, bit_and(swizzle_y(r07EA), body.constant(1048575u)), 0x01));

      body.emit(assign(r07F3, r07FD, 0x01));

      ir_variable *const r07FE = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r07FF = rshift(swizzle_y(r07E9), body.constant(int(20)));
      ir_expression *const r0800 = bit_and(r07FF, body.constant(2047u));
      body.emit(assign(r07FE, expr(ir_unop_u2i, r0800), 0x01));

      ir_variable *const r0801 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r0802 = rshift(swizzle_y(r07EA), body.constant(int(20)));
      ir_expression *const r0803 = bit_and(r0802, body.constant(2047u));
      body.emit(assign(r0801, expr(ir_unop_u2i, r0803), 0x01));

      ir_variable *const r0804 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r0804, sub(r07FE, r0801), 0x01));

      body.emit(assign(r07F2, r0804, 0x01));

      /* IF CONDITION */
      ir_expression *const r0806 = less(body.constant(int(0)), r0804);
      ir_if *f0805 = new(mem_ctx) ir_if(operand(r0806).val);
      exec_list *const f0805_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0805->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0808 = equal(r07FE, body.constant(int(2047)));
         ir_if *f0807 = new(mem_ctx) ir_if(operand(r0808).val);
         exec_list *const f0807_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0807->then_instructions;

            /* IF CONDITION */
            ir_expression *const r080A = bit_or(r07FB, swizzle_x(r07E9));
            ir_expression *const r080B = nequal(r080A, body.constant(0u));
            ir_if *f0809 = new(mem_ctx) ir_if(operand(r080B).val);
            exec_list *const f0809_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0809->then_instructions;

               ir_variable *const r080C = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r080C, swizzle_x(r07E9), 0x01));

               ir_variable *const r080D = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r080D, swizzle_x(r07EA), 0x01));

               ir_variable *const r080E = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r080F = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0810 = rshift(swizzle_y(r07E9), body.constant(int(19)));
               ir_expression *const r0811 = bit_and(r0810, body.constant(4095u));
               ir_expression *const r0812 = equal(r0811, body.constant(4094u));
               ir_expression *const r0813 = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r0814 = bit_and(swizzle_y(r07E9), body.constant(524287u));
               ir_expression *const r0815 = nequal(r0814, body.constant(0u));
               ir_expression *const r0816 = logic_or(r0813, r0815);
               body.emit(assign(r080F, logic_and(r0812, r0816), 0x01));

               ir_variable *const r0817 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r0818 = lshift(swizzle_y(r07EA), body.constant(int(1)));
               ir_expression *const r0819 = lequal(body.constant(4292870144u), r0818);
               ir_expression *const r081A = nequal(swizzle_x(r07EA), body.constant(0u));
               ir_expression *const r081B = bit_and(swizzle_y(r07EA), body.constant(1048575u));
               ir_expression *const r081C = nequal(r081B, body.constant(0u));
               ir_expression *const r081D = logic_or(r081A, r081C);
               body.emit(assign(r0817, logic_and(r0819, r081D), 0x01));

               body.emit(assign(r080C, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

               body.emit(assign(r080D, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r081F = lshift(swizzle_y(r07E9), body.constant(int(1)));
               ir_expression *const r0820 = lequal(body.constant(4292870144u), r081F);
               ir_expression *const r0821 = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r0822 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
               ir_expression *const r0823 = nequal(r0822, body.constant(0u));
               ir_expression *const r0824 = logic_or(r0821, r0823);
               ir_expression *const r0825 = logic_and(r0820, r0824);
               ir_if *f081E = new(mem_ctx) ir_if(operand(r0825).val);
               exec_list *const f081E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f081E->then_instructions;

                  ir_variable *const r0826 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0828 = logic_and(r080F, r0817);
                  ir_if *f0827 = new(mem_ctx) ir_if(operand(r0828).val);
                  exec_list *const f0827_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0827->then_instructions;

                     body.emit(assign(r0826, r080D, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0827->else_instructions;

                     body.emit(assign(r0826, r080C, 0x03));


                  body.instructions = f0827_parent_instructions;
                  body.emit(f0827);

                  /* END IF */

                  body.emit(assign(r080E, r0826, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f081E->else_instructions;

                  body.emit(assign(r080E, r080D, 0x03));


               body.instructions = f081E_parent_instructions;
               body.emit(f081E);

               /* END IF */

               body.emit(assign(r07F1, r080E, 0x03));

               body.emit(assign(r07F0, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0809->else_instructions;

               body.emit(assign(r07F1, r07E9, 0x03));

               body.emit(assign(r07F0, body.constant(false), 0x01));


            body.instructions = f0809_parent_instructions;
            body.emit(f0809);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0807->else_instructions;

            /* IF CONDITION */
            ir_expression *const r082A = equal(r0801, body.constant(int(0)));
            ir_if *f0829 = new(mem_ctx) ir_if(operand(r082A).val);
            exec_list *const f0829_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0829->then_instructions;

               body.emit(assign(r07F2, add(r0804, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0829->else_instructions;

               body.emit(assign(r07F3, bit_or(r07FD, body.constant(1048576u)), 0x01));


            body.instructions = f0829_parent_instructions;
            body.emit(f0829);

            /* END IF */

            ir_variable *const r082B = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r082B, body.constant(0u), 0x01));

            ir_variable *const r082C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r082C);
            ir_variable *const r082D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r082D);
            ir_variable *const r082E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r082E);
            ir_variable *const r082F = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0830 = neg(r07F2);
            body.emit(assign(r082F, bit_and(r0830, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0832 = equal(r07F2, body.constant(int(0)));
            ir_if *f0831 = new(mem_ctx) ir_if(operand(r0832).val);
            exec_list *const f0831_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0831->then_instructions;

               body.emit(assign(r082C, r082B, 0x01));

               body.emit(assign(r082D, r07FC, 0x01));

               body.emit(assign(r082E, r07F3, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0831->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0834 = less(r07F2, body.constant(int(32)));
               ir_if *f0833 = new(mem_ctx) ir_if(operand(r0834).val);
               exec_list *const f0833_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0833->then_instructions;

                  body.emit(assign(r082C, lshift(swizzle_x(r07EA), r082F), 0x01));

                  ir_expression *const r0835 = lshift(r07F3, r082F);
                  ir_expression *const r0836 = rshift(swizzle_x(r07EA), r07F2);
                  body.emit(assign(r082D, bit_or(r0835, r0836), 0x01));

                  body.emit(assign(r082E, rshift(r07F3, r07F2), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0833->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0838 = equal(r07F2, body.constant(int(32)));
                  ir_if *f0837 = new(mem_ctx) ir_if(operand(r0838).val);
                  exec_list *const f0837_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0837->then_instructions;

                     body.emit(assign(r082C, r07FC, 0x01));

                     body.emit(assign(r082D, r07F3, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0837->else_instructions;

                     body.emit(assign(r082B, bit_or(body.constant(0u), swizzle_x(r07EA)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r083A = less(r07F2, body.constant(int(64)));
                     ir_if *f0839 = new(mem_ctx) ir_if(operand(r083A).val);
                     exec_list *const f0839_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0839->then_instructions;

                        body.emit(assign(r082C, lshift(r07F3, r082F), 0x01));

                        ir_expression *const r083B = bit_and(r07F2, body.constant(int(31)));
                        body.emit(assign(r082D, rshift(r07F3, r083B), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0839->else_instructions;

                        ir_variable *const r083C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r083E = equal(r07F2, body.constant(int(64)));
                        ir_if *f083D = new(mem_ctx) ir_if(operand(r083E).val);
                        exec_list *const f083D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f083D->then_instructions;

                           body.emit(assign(r083C, r07F3, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f083D->else_instructions;

                           ir_expression *const r083F = nequal(r07F3, body.constant(0u));
                           ir_expression *const r0840 = expr(ir_unop_b2i, r083F);
                           body.emit(assign(r083C, expr(ir_unop_i2u, r0840), 0x01));


                        body.instructions = f083D_parent_instructions;
                        body.emit(f083D);

                        /* END IF */

                        body.emit(assign(r082C, r083C, 0x01));

                        body.emit(assign(r082D, body.constant(0u), 0x01));


                     body.instructions = f0839_parent_instructions;
                     body.emit(f0839);

                     /* END IF */


                  body.instructions = f0837_parent_instructions;
                  body.emit(f0837);

                  /* END IF */

                  body.emit(assign(r082E, body.constant(0u), 0x01));


               body.instructions = f0833_parent_instructions;
               body.emit(f0833);

               /* END IF */

               ir_expression *const r0841 = nequal(r082B, body.constant(0u));
               ir_expression *const r0842 = expr(ir_unop_b2i, r0841);
               ir_expression *const r0843 = expr(ir_unop_i2u, r0842);
               body.emit(assign(r082C, bit_or(r082C, r0843), 0x01));


            body.instructions = f0831_parent_instructions;
            body.emit(f0831);

            /* END IF */

            body.emit(assign(r07F3, r082E, 0x01));

            body.emit(assign(r07F4, r082D, 0x01));

            body.emit(assign(r07F8, r082C, 0x01));

            body.emit(assign(r07F7, r07FE, 0x01));


         body.instructions = f0807_parent_instructions;
         body.emit(f0807);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0805->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0845 = less(r07F2, body.constant(int(0)));
         ir_if *f0844 = new(mem_ctx) ir_if(operand(r0845).val);
         exec_list *const f0844_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0844->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0847 = equal(r0801, body.constant(int(2047)));
            ir_if *f0846 = new(mem_ctx) ir_if(operand(r0847).val);
            exec_list *const f0846_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0846->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0849 = bit_or(r07F3, r07F4);
               ir_expression *const r084A = nequal(r0849, body.constant(0u));
               ir_if *f0848 = new(mem_ctx) ir_if(operand(r084A).val);
               exec_list *const f0848_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0848->then_instructions;

                  ir_variable *const r084B = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r084B, swizzle_x(r07E9), 0x01));

                  ir_variable *const r084C = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r084C, swizzle_x(r07EA), 0x01));

                  ir_variable *const r084D = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r084E = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r084F = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0850 = bit_and(r084F, body.constant(4095u));
                  ir_expression *const r0851 = equal(r0850, body.constant(4094u));
                  ir_expression *const r0852 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0853 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0854 = nequal(r0853, body.constant(0u));
                  ir_expression *const r0855 = logic_or(r0852, r0854);
                  body.emit(assign(r084E, logic_and(r0851, r0855), 0x01));

                  ir_variable *const r0856 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0857 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0858 = lequal(body.constant(4292870144u), r0857);
                  ir_expression *const r0859 = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r085A = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r085B = nequal(r085A, body.constant(0u));
                  ir_expression *const r085C = logic_or(r0859, r085B);
                  body.emit(assign(r0856, logic_and(r0858, r085C), 0x01));

                  body.emit(assign(r084B, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r084C, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r085E = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r085F = lequal(body.constant(4292870144u), r085E);
                  ir_expression *const r0860 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0861 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0862 = nequal(r0861, body.constant(0u));
                  ir_expression *const r0863 = logic_or(r0860, r0862);
                  ir_expression *const r0864 = logic_and(r085F, r0863);
                  ir_if *f085D = new(mem_ctx) ir_if(operand(r0864).val);
                  exec_list *const f085D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f085D->then_instructions;

                     ir_variable *const r0865 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0867 = logic_and(r084E, r0856);
                     ir_if *f0866 = new(mem_ctx) ir_if(operand(r0867).val);
                     exec_list *const f0866_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0866->then_instructions;

                        body.emit(assign(r0865, r084C, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0866->else_instructions;

                        body.emit(assign(r0865, r084B, 0x03));


                     body.instructions = f0866_parent_instructions;
                     body.emit(f0866);

                     /* END IF */

                     body.emit(assign(r084D, r0865, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f085D->else_instructions;

                     body.emit(assign(r084D, r084C, 0x03));


                  body.instructions = f085D_parent_instructions;
                  body.emit(f085D);

                  /* END IF */

                  body.emit(assign(r07F1, r084D, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0848->else_instructions;

                  ir_variable *const r0868 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0868);
                  ir_expression *const r0869 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0868, add(r0869, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0868, body.constant(0u), 0x01));

                  body.emit(assign(r07F1, r0868, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f0848_parent_instructions;
               body.emit(f0848);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0846->else_instructions;

               /* IF CONDITION */
               ir_expression *const r086B = equal(r07FE, body.constant(int(0)));
               ir_if *f086A = new(mem_ctx) ir_if(operand(r086B).val);
               exec_list *const f086A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f086A->then_instructions;

                  body.emit(assign(r07F2, add(r07F2, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f086A->else_instructions;

                  body.emit(assign(r07F5, bit_or(r07FB, body.constant(1048576u)), 0x01));


               body.instructions = f086A_parent_instructions;
               body.emit(f086A);

               /* END IF */

               ir_variable *const r086C = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r086C, body.constant(0u), 0x01));

               ir_variable *const r086D = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r086D, neg(r07F2), 0x01));

               ir_variable *const r086E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r086E);
               ir_variable *const r086F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r086F);
               ir_variable *const r0870 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0870);
               ir_variable *const r0871 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0872 = neg(r086D);
               body.emit(assign(r0871, bit_and(r0872, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0874 = equal(r086D, body.constant(int(0)));
               ir_if *f0873 = new(mem_ctx) ir_if(operand(r0874).val);
               exec_list *const f0873_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0873->then_instructions;

                  body.emit(assign(r086E, r086C, 0x01));

                  body.emit(assign(r086F, r07FA, 0x01));

                  body.emit(assign(r0870, r07F5, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0873->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0876 = less(r086D, body.constant(int(32)));
                  ir_if *f0875 = new(mem_ctx) ir_if(operand(r0876).val);
                  exec_list *const f0875_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0875->then_instructions;

                     body.emit(assign(r086E, lshift(swizzle_x(r07E9), r0871), 0x01));

                     ir_expression *const r0877 = lshift(r07F5, r0871);
                     ir_expression *const r0878 = rshift(swizzle_x(r07E9), r086D);
                     body.emit(assign(r086F, bit_or(r0877, r0878), 0x01));

                     body.emit(assign(r0870, rshift(r07F5, r086D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0875->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r087A = equal(r086D, body.constant(int(32)));
                     ir_if *f0879 = new(mem_ctx) ir_if(operand(r087A).val);
                     exec_list *const f0879_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0879->then_instructions;

                        body.emit(assign(r086E, r07FA, 0x01));

                        body.emit(assign(r086F, r07F5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0879->else_instructions;

                        body.emit(assign(r086C, bit_or(body.constant(0u), swizzle_x(r07E9)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r087C = less(r086D, body.constant(int(64)));
                        ir_if *f087B = new(mem_ctx) ir_if(operand(r087C).val);
                        exec_list *const f087B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f087B->then_instructions;

                           body.emit(assign(r086E, lshift(r07F5, r0871), 0x01));

                           ir_expression *const r087D = bit_and(r086D, body.constant(int(31)));
                           body.emit(assign(r086F, rshift(r07F5, r087D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f087B->else_instructions;

                           ir_variable *const r087E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0880 = equal(r086D, body.constant(int(64)));
                           ir_if *f087F = new(mem_ctx) ir_if(operand(r0880).val);
                           exec_list *const f087F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f087F->then_instructions;

                              body.emit(assign(r087E, r07F5, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f087F->else_instructions;

                              ir_expression *const r0881 = nequal(r07F5, body.constant(0u));
                              ir_expression *const r0882 = expr(ir_unop_b2i, r0881);
                              body.emit(assign(r087E, expr(ir_unop_i2u, r0882), 0x01));


                           body.instructions = f087F_parent_instructions;
                           body.emit(f087F);

                           /* END IF */

                           body.emit(assign(r086E, r087E, 0x01));

                           body.emit(assign(r086F, body.constant(0u), 0x01));


                        body.instructions = f087B_parent_instructions;
                        body.emit(f087B);

                        /* END IF */


                     body.instructions = f0879_parent_instructions;
                     body.emit(f0879);

                     /* END IF */

                     body.emit(assign(r0870, body.constant(0u), 0x01));


                  body.instructions = f0875_parent_instructions;
                  body.emit(f0875);

                  /* END IF */

                  ir_expression *const r0883 = nequal(r086C, body.constant(0u));
                  ir_expression *const r0884 = expr(ir_unop_b2i, r0883);
                  ir_expression *const r0885 = expr(ir_unop_i2u, r0884);
                  body.emit(assign(r086E, bit_or(r086E, r0885), 0x01));


               body.instructions = f0873_parent_instructions;
               body.emit(f0873);

               /* END IF */

               body.emit(assign(r07F5, r0870, 0x01));

               body.emit(assign(r07F6, r086F, 0x01));

               body.emit(assign(r07F8, r086E, 0x01));

               body.emit(assign(r07F7, r0801, 0x01));


            body.instructions = f0846_parent_instructions;
            body.emit(f0846);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0844->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0887 = equal(r07FE, body.constant(int(2047)));
            ir_if *f0886 = new(mem_ctx) ir_if(operand(r0887).val);
            exec_list *const f0886_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0886->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0889 = bit_or(r07F5, r07F6);
               ir_expression *const r088A = bit_or(r07F3, r07F4);
               ir_expression *const r088B = bit_or(r0889, r088A);
               ir_expression *const r088C = nequal(r088B, body.constant(0u));
               ir_if *f0888 = new(mem_ctx) ir_if(operand(r088C).val);
               exec_list *const f0888_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0888->then_instructions;

                  ir_variable *const r088D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r088D, swizzle_x(r07E9), 0x01));

                  ir_variable *const r088E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r088E, swizzle_x(r07EA), 0x01));

                  ir_variable *const r088F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0890 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0891 = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0892 = bit_and(r0891, body.constant(4095u));
                  ir_expression *const r0893 = equal(r0892, body.constant(4094u));
                  ir_expression *const r0894 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0895 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0896 = nequal(r0895, body.constant(0u));
                  ir_expression *const r0897 = logic_or(r0894, r0896);
                  body.emit(assign(r0890, logic_and(r0893, r0897), 0x01));

                  ir_variable *const r0898 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0899 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r089A = lequal(body.constant(4292870144u), r0899);
                  ir_expression *const r089B = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r089C = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r089D = nequal(r089C, body.constant(0u));
                  ir_expression *const r089E = logic_or(r089B, r089D);
                  body.emit(assign(r0898, logic_and(r089A, r089E), 0x01));

                  body.emit(assign(r088D, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r088E, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r08A0 = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r08A1 = lequal(body.constant(4292870144u), r08A0);
                  ir_expression *const r08A2 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r08A3 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r08A4 = nequal(r08A3, body.constant(0u));
                  ir_expression *const r08A5 = logic_or(r08A2, r08A4);
                  ir_expression *const r08A6 = logic_and(r08A1, r08A5);
                  ir_if *f089F = new(mem_ctx) ir_if(operand(r08A6).val);
                  exec_list *const f089F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f089F->then_instructions;

                     ir_variable *const r08A7 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08A9 = logic_and(r0890, r0898);
                     ir_if *f08A8 = new(mem_ctx) ir_if(operand(r08A9).val);
                     exec_list *const f08A8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08A8->then_instructions;

                        body.emit(assign(r08A7, r088E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08A8->else_instructions;

                        body.emit(assign(r08A7, r088D, 0x03));


                     body.instructions = f08A8_parent_instructions;
                     body.emit(f08A8);

                     /* END IF */

                     body.emit(assign(r088F, r08A7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f089F->else_instructions;

                     body.emit(assign(r088F, r088E, 0x03));


                  body.instructions = f089F_parent_instructions;
                  body.emit(f089F);

                  /* END IF */

                  body.emit(assign(r07F1, r088F, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0888->else_instructions;

                  body.emit(assign(r07F1, r07E9, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f0888_parent_instructions;
               body.emit(f0888);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0886->else_instructions;

               ir_variable *const r08AA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r08AB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r08AB, add(r07F6, r07F4), 0x01));

               ir_expression *const r08AC = add(r07F5, r07F3);
               ir_expression *const r08AD = less(r08AB, r07F6);
               ir_expression *const r08AE = expr(ir_unop_b2i, r08AD);
               ir_expression *const r08AF = expr(ir_unop_i2u, r08AE);
               body.emit(assign(r08AA, add(r08AC, r08AF), 0x01));

               body.emit(assign(r07F9, r08AA, 0x01));

               /* IF CONDITION */
               ir_expression *const r08B1 = equal(r07FE, body.constant(int(0)));
               ir_if *f08B0 = new(mem_ctx) ir_if(operand(r08B1).val);
               exec_list *const f08B0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f08B0->then_instructions;

                  ir_variable *const r08B2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r08B2);
                  ir_expression *const r08B3 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r08B2, add(r08B3, r08AA), 0x02));

                  body.emit(assign(r08B2, r08AB, 0x01));

                  body.emit(assign(r07F1, r08B2, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f08B0->else_instructions;

                  body.emit(assign(r07F9, bit_or(r08AA, body.constant(2097152u)), 0x01));

                  body.emit(assign(r07F7, r07FE, 0x01));

                  ir_variable *const r08B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r08B4);
                  ir_variable *const r08B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r08B5);
                  ir_variable *const r08B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r08B6);
                  body.emit(assign(r08B4, lshift(r08AB, body.constant(int(31))), 0x01));

                  ir_expression *const r08B7 = lshift(r07F9, body.constant(int(31)));
                  ir_expression *const r08B8 = rshift(r08AB, body.constant(int(1)));
                  body.emit(assign(r08B5, bit_or(r08B7, r08B8), 0x01));

                  body.emit(assign(r08B6, rshift(r07F9, body.constant(int(1))), 0x01));

                  body.emit(assign(r08B4, bit_or(r08B4, body.constant(0u)), 0x01));

                  body.emit(assign(r07F9, r08B6, 0x01));

                  body.emit(assign(r07F8, r08B4, 0x01));

                  ir_variable *const r08B9 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r08B9, r07FE, 0x01));

                  ir_variable *const r08BA = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r08BA, r08B6, 0x01));

                  ir_variable *const r08BB = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r08BB, r08B5, 0x01));

                  ir_variable *const r08BC = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r08BC, r08B4, 0x01));

                  ir_variable *const r08BD = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r08BD, body.constant(true), 0x01));

                  ir_variable *const r08BE = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r08BF = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r08BF);
                  ir_expression *const r08C0 = expr(ir_unop_u2i, r08B4);
                  body.emit(assign(r08BF, less(r08C0, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r08C2 = lequal(body.constant(int(2045)), r07FE);
                  ir_if *f08C1 = new(mem_ctx) ir_if(operand(r08C2).val);
                  exec_list *const f08C1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08C1->then_instructions;

                     ir_variable *const r08C3 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08C5 = less(body.constant(int(2045)), r07FE);
                     ir_if *f08C4 = new(mem_ctx) ir_if(operand(r08C5).val);
                     exec_list *const f08C4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08C4->then_instructions;

                        body.emit(assign(r08C3, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08C4->else_instructions;

                        ir_variable *const r08C6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r08C8 = equal(r07FE, body.constant(int(2045)));
                        ir_if *f08C7 = new(mem_ctx) ir_if(operand(r08C8).val);
                        exec_list *const f08C7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08C7->then_instructions;

                           ir_expression *const r08C9 = equal(body.constant(2097151u), r08B6);
                           ir_expression *const r08CA = equal(body.constant(4294967295u), r08B5);
                           body.emit(assign(r08C6, logic_and(r08C9, r08CA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f08C7->else_instructions;

                           body.emit(assign(r08C6, body.constant(false), 0x01));


                        body.instructions = f08C7_parent_instructions;
                        body.emit(f08C7);

                        /* END IF */

                        body.emit(assign(r08C3, logic_and(r08C6, r08BF), 0x01));


                     body.instructions = f08C4_parent_instructions;
                     body.emit(f08C4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f08CB = new(mem_ctx) ir_if(operand(r08C3).val);
                     exec_list *const f08CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08CB->then_instructions;

                        ir_variable *const r08CC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r08CC);
                        ir_expression *const r08CD = lshift(r07EC, body.constant(int(31)));
                        body.emit(assign(r08CC, add(r08CD, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r08CC, body.constant(0u), 0x01));

                        body.emit(assign(r08BE, r08CC, 0x03));

                        body.emit(assign(r08BD, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08CB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08CF = less(r07FE, body.constant(int(0)));
                        ir_if *f08CE = new(mem_ctx) ir_if(operand(r08CF).val);
                        exec_list *const f08CE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08CE->then_instructions;

                           ir_variable *const r08D0 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r08D0, r08B4, 0x01));

                           ir_variable *const r08D1 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r08D1, neg(r07FE), 0x01));

                           ir_variable *const r08D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r08D2);
                           ir_variable *const r08D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r08D3);
                           ir_variable *const r08D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r08D4);
                           ir_variable *const r08D5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r08D6 = neg(r08D1);
                           body.emit(assign(r08D5, bit_and(r08D6, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r08D8 = equal(r08D1, body.constant(int(0)));
                           ir_if *f08D7 = new(mem_ctx) ir_if(operand(r08D8).val);
                           exec_list *const f08D7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f08D7->then_instructions;

                              body.emit(assign(r08D2, r08B4, 0x01));

                              body.emit(assign(r08D3, r08B5, 0x01));

                              body.emit(assign(r08D4, r08B6, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f08D7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r08DA = less(r08D1, body.constant(int(32)));
                              ir_if *f08D9 = new(mem_ctx) ir_if(operand(r08DA).val);
                              exec_list *const f08D9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f08D9->then_instructions;

                                 body.emit(assign(r08D2, lshift(r08B5, r08D5), 0x01));

                                 ir_expression *const r08DB = lshift(r08B6, r08D5);
                                 ir_expression *const r08DC = rshift(r08B5, r08D1);
                                 body.emit(assign(r08D3, bit_or(r08DB, r08DC), 0x01));

                                 body.emit(assign(r08D4, rshift(r08B6, r08D1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f08D9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r08DE = equal(r08D1, body.constant(int(32)));
                                 ir_if *f08DD = new(mem_ctx) ir_if(operand(r08DE).val);
                                 exec_list *const f08DD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f08DD->then_instructions;

                                    body.emit(assign(r08D2, r08B5, 0x01));

                                    body.emit(assign(r08D3, r08B6, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f08DD->else_instructions;

                                    body.emit(assign(r08D0, bit_or(r08B4, r08B5), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r08E0 = less(r08D1, body.constant(int(64)));
                                    ir_if *f08DF = new(mem_ctx) ir_if(operand(r08E0).val);
                                    exec_list *const f08DF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f08DF->then_instructions;

                                       body.emit(assign(r08D2, lshift(r08B6, r08D5), 0x01));

                                       ir_expression *const r08E1 = bit_and(r08D1, body.constant(int(31)));
                                       body.emit(assign(r08D3, rshift(r08B6, r08E1), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f08DF->else_instructions;

                                       ir_variable *const r08E2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r08E4 = equal(r08D1, body.constant(int(64)));
                                       ir_if *f08E3 = new(mem_ctx) ir_if(operand(r08E4).val);
                                       exec_list *const f08E3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f08E3->then_instructions;

                                          body.emit(assign(r08E2, r08B6, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f08E3->else_instructions;

                                          ir_expression *const r08E5 = nequal(r08B6, body.constant(0u));
                                          ir_expression *const r08E6 = expr(ir_unop_b2i, r08E5);
                                          body.emit(assign(r08E2, expr(ir_unop_i2u, r08E6), 0x01));


                                       body.instructions = f08E3_parent_instructions;
                                       body.emit(f08E3);

                                       /* END IF */

                                       body.emit(assign(r08D2, r08E2, 0x01));

                                       body.emit(assign(r08D3, body.constant(0u), 0x01));


                                    body.instructions = f08DF_parent_instructions;
                                    body.emit(f08DF);

                                    /* END IF */


                                 body.instructions = f08DD_parent_instructions;
                                 body.emit(f08DD);

                                 /* END IF */

                                 body.emit(assign(r08D4, body.constant(0u), 0x01));


                              body.instructions = f08D9_parent_instructions;
                              body.emit(f08D9);

                              /* END IF */

                              ir_expression *const r08E7 = nequal(r08D0, body.constant(0u));
                              ir_expression *const r08E8 = expr(ir_unop_b2i, r08E7);
                              ir_expression *const r08E9 = expr(ir_unop_i2u, r08E8);
                              body.emit(assign(r08D2, bit_or(r08D2, r08E9), 0x01));


                           body.instructions = f08D7_parent_instructions;
                           body.emit(f08D7);

                           /* END IF */

                           body.emit(assign(r08BA, r08D4, 0x01));

                           body.emit(assign(r08BB, r08D3, 0x01));

                           body.emit(assign(r08BC, r08D2, 0x01));

                           body.emit(assign(r08B9, body.constant(int(0)), 0x01));

                           body.emit(assign(r08BF, less(r08D2, body.constant(0u)), 0x01));


                        body.instructions = f08CE_parent_instructions;
                        body.emit(f08CE);

                        /* END IF */


                     body.instructions = f08CB_parent_instructions;
                     body.emit(f08CB);

                     /* END IF */


                  body.instructions = f08C1_parent_instructions;
                  body.emit(f08C1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f08EA = new(mem_ctx) ir_if(operand(r08BD).val);
                  exec_list *const f08EA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08EA->then_instructions;

                     /* IF CONDITION */
                     ir_if *f08EB = new(mem_ctx) ir_if(operand(r08BF).val);
                     exec_list *const f08EB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08EB->then_instructions;

                        ir_variable *const r08EC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r08EC, add(r08BB, body.constant(1u)), 0x01));

                        ir_expression *const r08ED = less(r08EC, r08BB);
                        ir_expression *const r08EE = expr(ir_unop_b2i, r08ED);
                        ir_expression *const r08EF = expr(ir_unop_i2u, r08EE);
                        body.emit(assign(r08BA, add(r08BA, r08EF), 0x01));

                        ir_expression *const r08F0 = equal(r08BC, body.constant(0u));
                        ir_expression *const r08F1 = expr(ir_unop_b2i, r08F0);
                        ir_expression *const r08F2 = expr(ir_unop_i2u, r08F1);
                        ir_expression *const r08F3 = add(r08BC, r08F2);
                        ir_expression *const r08F4 = bit_and(r08F3, body.constant(1u));
                        ir_expression *const r08F5 = expr(ir_unop_bit_not, r08F4);
                        body.emit(assign(r08BB, bit_and(r08EC, r08F5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08EB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08F7 = bit_or(r08BA, r08BB);
                        ir_expression *const r08F8 = equal(r08F7, body.constant(0u));
                        ir_if *f08F6 = new(mem_ctx) ir_if(operand(r08F8).val);
                        exec_list *const f08F6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08F6->then_instructions;

                           body.emit(assign(r08B9, body.constant(int(0)), 0x01));


                        body.instructions = f08F6_parent_instructions;
                        body.emit(f08F6);

                        /* END IF */


                     body.instructions = f08EB_parent_instructions;
                     body.emit(f08EB);

                     /* END IF */

                     ir_variable *const r08F9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r08F9);
                     ir_expression *const r08FA = lshift(r07EC, body.constant(int(31)));
                     ir_expression *const r08FB = expr(ir_unop_i2u, r08B9);
                     ir_expression *const r08FC = lshift(r08FB, body.constant(int(20)));
                     ir_expression *const r08FD = add(r08FA, r08FC);
                     body.emit(assign(r08F9, add(r08FD, r08BA), 0x02));

                     body.emit(assign(r08F9, r08BB, 0x01));

                     body.emit(assign(r08BE, r08F9, 0x03));

                     body.emit(assign(r08BD, body.constant(false), 0x01));


                  body.instructions = f08EA_parent_instructions;
                  body.emit(f08EA);

                  /* END IF */

                  body.emit(assign(r07F1, r08BE, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f08B0_parent_instructions;
               body.emit(f08B0);

               /* END IF */


            body.instructions = f0886_parent_instructions;
            body.emit(f0886);

            /* END IF */


         body.instructions = f0844_parent_instructions;
         body.emit(f0844);

         /* END IF */


      body.instructions = f0805_parent_instructions;
      body.emit(f0805);

      /* END IF */

      /* IF CONDITION */
      ir_if *f08FE = new(mem_ctx) ir_if(operand(r07F0).val);
      exec_list *const f08FE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f08FE->then_instructions;

         body.emit(assign(r07F5, bit_or(r07F5, body.constant(1048576u)), 0x01));

         ir_variable *const r08FF = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r0900 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r0900, add(r07F6, r07F4), 0x01));

         ir_expression *const r0901 = add(r07F5, r07F3);
         ir_expression *const r0902 = less(r0900, r07F6);
         ir_expression *const r0903 = expr(ir_unop_b2i, r0902);
         ir_expression *const r0904 = expr(ir_unop_i2u, r0903);
         body.emit(assign(r08FF, add(r0901, r0904), 0x01));

         body.emit(assign(r07F9, r08FF, 0x01));

         body.emit(assign(r07F7, add(r07F7, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0906 = less(r08FF, body.constant(2097152u));
         ir_if *f0905 = new(mem_ctx) ir_if(operand(r0906).val);
         exec_list *const f0905_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0905->then_instructions;

            ir_variable *const r0907 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0907, r07F7, 0x01));

            ir_variable *const r0908 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0908, r08FF, 0x01));

            ir_variable *const r0909 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0909, r0900, 0x01));

            ir_variable *const r090A = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r090A, r07F8, 0x01));

            ir_variable *const r090B = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r090B, body.constant(true), 0x01));

            ir_variable *const r090C = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r090D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r090D);
            ir_expression *const r090E = expr(ir_unop_u2i, r07F8);
            body.emit(assign(r090D, less(r090E, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0910 = lequal(body.constant(int(2045)), r07F7);
            ir_if *f090F = new(mem_ctx) ir_if(operand(r0910).val);
            exec_list *const f090F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f090F->then_instructions;

               ir_variable *const r0911 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0913 = less(body.constant(int(2045)), r07F7);
               ir_if *f0912 = new(mem_ctx) ir_if(operand(r0913).val);
               exec_list *const f0912_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0912->then_instructions;

                  body.emit(assign(r0911, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0912->else_instructions;

                  ir_variable *const r0914 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0916 = equal(r07F7, body.constant(int(2045)));
                  ir_if *f0915 = new(mem_ctx) ir_if(operand(r0916).val);
                  exec_list *const f0915_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0915->then_instructions;

                     ir_expression *const r0917 = equal(body.constant(2097151u), r08FF);
                     ir_expression *const r0918 = equal(body.constant(4294967295u), r0900);
                     body.emit(assign(r0914, logic_and(r0917, r0918), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0915->else_instructions;

                     body.emit(assign(r0914, body.constant(false), 0x01));


                  body.instructions = f0915_parent_instructions;
                  body.emit(f0915);

                  /* END IF */

                  body.emit(assign(r0911, logic_and(r0914, r090D), 0x01));


               body.instructions = f0912_parent_instructions;
               body.emit(f0912);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0919 = new(mem_ctx) ir_if(operand(r0911).val);
               exec_list *const f0919_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0919->then_instructions;

                  ir_variable *const r091A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r091A);
                  ir_expression *const r091B = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r091A, add(r091B, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r091A, body.constant(0u), 0x01));

                  body.emit(assign(r090C, r091A, 0x03));

                  body.emit(assign(r090B, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0919->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r091D = less(r07F7, body.constant(int(0)));
                  ir_if *f091C = new(mem_ctx) ir_if(operand(r091D).val);
                  exec_list *const f091C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f091C->then_instructions;

                     ir_variable *const r091E = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r091E, r07F8, 0x01));

                     ir_variable *const r091F = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r091F, neg(r07F7), 0x01));

                     ir_variable *const r0920 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0920);
                     ir_variable *const r0921 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0921);
                     ir_variable *const r0922 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0922);
                     ir_variable *const r0923 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0924 = neg(r091F);
                     body.emit(assign(r0923, bit_and(r0924, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0926 = equal(r091F, body.constant(int(0)));
                     ir_if *f0925 = new(mem_ctx) ir_if(operand(r0926).val);
                     exec_list *const f0925_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0925->then_instructions;

                        body.emit(assign(r0920, r07F8, 0x01));

                        body.emit(assign(r0921, r0900, 0x01));

                        body.emit(assign(r0922, r08FF, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0925->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0928 = less(r091F, body.constant(int(32)));
                        ir_if *f0927 = new(mem_ctx) ir_if(operand(r0928).val);
                        exec_list *const f0927_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0927->then_instructions;

                           body.emit(assign(r0920, lshift(r0900, r0923), 0x01));

                           ir_expression *const r0929 = lshift(r08FF, r0923);
                           ir_expression *const r092A = rshift(r0900, r091F);
                           body.emit(assign(r0921, bit_or(r0929, r092A), 0x01));

                           body.emit(assign(r0922, rshift(r08FF, r091F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0927->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r092C = equal(r091F, body.constant(int(32)));
                           ir_if *f092B = new(mem_ctx) ir_if(operand(r092C).val);
                           exec_list *const f092B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f092B->then_instructions;

                              body.emit(assign(r0920, r0900, 0x01));

                              body.emit(assign(r0921, r08FF, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f092B->else_instructions;

                              body.emit(assign(r091E, bit_or(r07F8, r0900), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r092E = less(r091F, body.constant(int(64)));
                              ir_if *f092D = new(mem_ctx) ir_if(operand(r092E).val);
                              exec_list *const f092D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f092D->then_instructions;

                                 body.emit(assign(r0920, lshift(r08FF, r0923), 0x01));

                                 ir_expression *const r092F = bit_and(r091F, body.constant(int(31)));
                                 body.emit(assign(r0921, rshift(r08FF, r092F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f092D->else_instructions;

                                 ir_variable *const r0930 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0932 = equal(r091F, body.constant(int(64)));
                                 ir_if *f0931 = new(mem_ctx) ir_if(operand(r0932).val);
                                 exec_list *const f0931_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0931->then_instructions;

                                    body.emit(assign(r0930, r08FF, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0931->else_instructions;

                                    ir_expression *const r0933 = nequal(r08FF, body.constant(0u));
                                    ir_expression *const r0934 = expr(ir_unop_b2i, r0933);
                                    body.emit(assign(r0930, expr(ir_unop_i2u, r0934), 0x01));


                                 body.instructions = f0931_parent_instructions;
                                 body.emit(f0931);

                                 /* END IF */

                                 body.emit(assign(r0920, r0930, 0x01));

                                 body.emit(assign(r0921, body.constant(0u), 0x01));


                              body.instructions = f092D_parent_instructions;
                              body.emit(f092D);

                              /* END IF */


                           body.instructions = f092B_parent_instructions;
                           body.emit(f092B);

                           /* END IF */

                           body.emit(assign(r0922, body.constant(0u), 0x01));


                        body.instructions = f0927_parent_instructions;
                        body.emit(f0927);

                        /* END IF */

                        ir_expression *const r0935 = nequal(r091E, body.constant(0u));
                        ir_expression *const r0936 = expr(ir_unop_b2i, r0935);
                        ir_expression *const r0937 = expr(ir_unop_i2u, r0936);
                        body.emit(assign(r0920, bit_or(r0920, r0937), 0x01));


                     body.instructions = f0925_parent_instructions;
                     body.emit(f0925);

                     /* END IF */

                     body.emit(assign(r0908, r0922, 0x01));

                     body.emit(assign(r0909, r0921, 0x01));

                     body.emit(assign(r090A, r0920, 0x01));

                     body.emit(assign(r0907, body.constant(int(0)), 0x01));

                     body.emit(assign(r090D, less(r0920, body.constant(0u)), 0x01));


                  body.instructions = f091C_parent_instructions;
                  body.emit(f091C);

                  /* END IF */


               body.instructions = f0919_parent_instructions;
               body.emit(f0919);

               /* END IF */


            body.instructions = f090F_parent_instructions;
            body.emit(f090F);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0938 = new(mem_ctx) ir_if(operand(r090B).val);
            exec_list *const f0938_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0938->then_instructions;

               /* IF CONDITION */
               ir_if *f0939 = new(mem_ctx) ir_if(operand(r090D).val);
               exec_list *const f0939_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0939->then_instructions;

                  ir_variable *const r093A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r093A, add(r0909, body.constant(1u)), 0x01));

                  ir_expression *const r093B = less(r093A, r0909);
                  ir_expression *const r093C = expr(ir_unop_b2i, r093B);
                  ir_expression *const r093D = expr(ir_unop_i2u, r093C);
                  body.emit(assign(r0908, add(r0908, r093D), 0x01));

                  ir_expression *const r093E = equal(r090A, body.constant(0u));
                  ir_expression *const r093F = expr(ir_unop_b2i, r093E);
                  ir_expression *const r0940 = expr(ir_unop_i2u, r093F);
                  ir_expression *const r0941 = add(r090A, r0940);
                  ir_expression *const r0942 = bit_and(r0941, body.constant(1u));
                  ir_expression *const r0943 = expr(ir_unop_bit_not, r0942);
                  body.emit(assign(r0909, bit_and(r093A, r0943), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0939->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0945 = bit_or(r0908, r0909);
                  ir_expression *const r0946 = equal(r0945, body.constant(0u));
                  ir_if *f0944 = new(mem_ctx) ir_if(operand(r0946).val);
                  exec_list *const f0944_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0944->then_instructions;

                     body.emit(assign(r0907, body.constant(int(0)), 0x01));


                  body.instructions = f0944_parent_instructions;
                  body.emit(f0944);

                  /* END IF */


               body.instructions = f0939_parent_instructions;
               body.emit(f0939);

               /* END IF */

               ir_variable *const r0947 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0947);
               ir_expression *const r0948 = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0949 = expr(ir_unop_i2u, r0907);
               ir_expression *const r094A = lshift(r0949, body.constant(int(20)));
               ir_expression *const r094B = add(r0948, r094A);
               body.emit(assign(r0947, add(r094B, r0908), 0x02));

               body.emit(assign(r0947, r0909, 0x01));

               body.emit(assign(r090C, r0947, 0x03));

               body.emit(assign(r090B, body.constant(false), 0x01));


            body.instructions = f0938_parent_instructions;
            body.emit(f0938);

            /* END IF */

            body.emit(assign(r07F1, r090C, 0x03));

            body.emit(assign(r07F0, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0905->else_instructions;

            body.emit(assign(r07F7, add(r07F7, body.constant(int(1))), 0x01));

            ir_variable *const r094C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r094C);
            ir_variable *const r094D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r094D);
            ir_variable *const r094E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r094E);
            body.emit(assign(r094C, lshift(r0900, body.constant(int(31))), 0x01));

            ir_expression *const r094F = lshift(r08FF, body.constant(int(31)));
            ir_expression *const r0950 = rshift(r0900, body.constant(int(1)));
            body.emit(assign(r094D, bit_or(r094F, r0950), 0x01));

            body.emit(assign(r094E, rshift(r08FF, body.constant(int(1))), 0x01));

            ir_expression *const r0951 = nequal(r07F8, body.constant(0u));
            ir_expression *const r0952 = expr(ir_unop_b2i, r0951);
            ir_expression *const r0953 = expr(ir_unop_i2u, r0952);
            body.emit(assign(r094C, bit_or(r094C, r0953), 0x01));

            body.emit(assign(r07F9, r094E, 0x01));

            body.emit(assign(r07F8, r094C, 0x01));

            ir_variable *const r0954 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0954, r07F7, 0x01));

            ir_variable *const r0955 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0955, r094E, 0x01));

            ir_variable *const r0956 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0956, r094D, 0x01));

            ir_variable *const r0957 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0957, r094C, 0x01));

            ir_variable *const r0958 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0958, body.constant(true), 0x01));

            ir_variable *const r0959 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r095A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r095A);
            ir_expression *const r095B = expr(ir_unop_u2i, r094C);
            body.emit(assign(r095A, less(r095B, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r095D = lequal(body.constant(int(2045)), r07F7);
            ir_if *f095C = new(mem_ctx) ir_if(operand(r095D).val);
            exec_list *const f095C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f095C->then_instructions;

               ir_variable *const r095E = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0960 = less(body.constant(int(2045)), r07F7);
               ir_if *f095F = new(mem_ctx) ir_if(operand(r0960).val);
               exec_list *const f095F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f095F->then_instructions;

                  body.emit(assign(r095E, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f095F->else_instructions;

                  ir_variable *const r0961 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0963 = equal(r07F7, body.constant(int(2045)));
                  ir_if *f0962 = new(mem_ctx) ir_if(operand(r0963).val);
                  exec_list *const f0962_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0962->then_instructions;

                     ir_expression *const r0964 = equal(body.constant(2097151u), r094E);
                     ir_expression *const r0965 = equal(body.constant(4294967295u), r094D);
                     body.emit(assign(r0961, logic_and(r0964, r0965), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0962->else_instructions;

                     body.emit(assign(r0961, body.constant(false), 0x01));


                  body.instructions = f0962_parent_instructions;
                  body.emit(f0962);

                  /* END IF */

                  body.emit(assign(r095E, logic_and(r0961, r095A), 0x01));


               body.instructions = f095F_parent_instructions;
               body.emit(f095F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0966 = new(mem_ctx) ir_if(operand(r095E).val);
               exec_list *const f0966_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0966->then_instructions;

                  ir_variable *const r0967 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0967);
                  ir_expression *const r0968 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0967, add(r0968, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0967, body.constant(0u), 0x01));

                  body.emit(assign(r0959, r0967, 0x03));

                  body.emit(assign(r0958, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0966->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r096A = less(r07F7, body.constant(int(0)));
                  ir_if *f0969 = new(mem_ctx) ir_if(operand(r096A).val);
                  exec_list *const f0969_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0969->then_instructions;

                     ir_variable *const r096B = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r096B, r094C, 0x01));

                     ir_variable *const r096C = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r096C, neg(r07F7), 0x01));

                     ir_variable *const r096D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r096D);
                     ir_variable *const r096E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r096E);
                     ir_variable *const r096F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r096F);
                     ir_variable *const r0970 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0971 = neg(r096C);
                     body.emit(assign(r0970, bit_and(r0971, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0973 = equal(r096C, body.constant(int(0)));
                     ir_if *f0972 = new(mem_ctx) ir_if(operand(r0973).val);
                     exec_list *const f0972_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0972->then_instructions;

                        body.emit(assign(r096D, r094C, 0x01));

                        body.emit(assign(r096E, r094D, 0x01));

                        body.emit(assign(r096F, r094E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0972->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0975 = less(r096C, body.constant(int(32)));
                        ir_if *f0974 = new(mem_ctx) ir_if(operand(r0975).val);
                        exec_list *const f0974_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0974->then_instructions;

                           body.emit(assign(r096D, lshift(r094D, r0970), 0x01));

                           ir_expression *const r0976 = lshift(r094E, r0970);
                           ir_expression *const r0977 = rshift(r094D, r096C);
                           body.emit(assign(r096E, bit_or(r0976, r0977), 0x01));

                           body.emit(assign(r096F, rshift(r094E, r096C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0974->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0979 = equal(r096C, body.constant(int(32)));
                           ir_if *f0978 = new(mem_ctx) ir_if(operand(r0979).val);
                           exec_list *const f0978_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0978->then_instructions;

                              body.emit(assign(r096D, r094D, 0x01));

                              body.emit(assign(r096E, r094E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0978->else_instructions;

                              body.emit(assign(r096B, bit_or(r094C, r094D), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r097B = less(r096C, body.constant(int(64)));
                              ir_if *f097A = new(mem_ctx) ir_if(operand(r097B).val);
                              exec_list *const f097A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f097A->then_instructions;

                                 body.emit(assign(r096D, lshift(r094E, r0970), 0x01));

                                 ir_expression *const r097C = bit_and(r096C, body.constant(int(31)));
                                 body.emit(assign(r096E, rshift(r094E, r097C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f097A->else_instructions;

                                 ir_variable *const r097D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r097F = equal(r096C, body.constant(int(64)));
                                 ir_if *f097E = new(mem_ctx) ir_if(operand(r097F).val);
                                 exec_list *const f097E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f097E->then_instructions;

                                    body.emit(assign(r097D, r094E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f097E->else_instructions;

                                    ir_expression *const r0980 = nequal(r094E, body.constant(0u));
                                    ir_expression *const r0981 = expr(ir_unop_b2i, r0980);
                                    body.emit(assign(r097D, expr(ir_unop_i2u, r0981), 0x01));


                                 body.instructions = f097E_parent_instructions;
                                 body.emit(f097E);

                                 /* END IF */

                                 body.emit(assign(r096D, r097D, 0x01));

                                 body.emit(assign(r096E, body.constant(0u), 0x01));


                              body.instructions = f097A_parent_instructions;
                              body.emit(f097A);

                              /* END IF */


                           body.instructions = f0978_parent_instructions;
                           body.emit(f0978);

                           /* END IF */

                           body.emit(assign(r096F, body.constant(0u), 0x01));


                        body.instructions = f0974_parent_instructions;
                        body.emit(f0974);

                        /* END IF */

                        ir_expression *const r0982 = nequal(r096B, body.constant(0u));
                        ir_expression *const r0983 = expr(ir_unop_b2i, r0982);
                        ir_expression *const r0984 = expr(ir_unop_i2u, r0983);
                        body.emit(assign(r096D, bit_or(r096D, r0984), 0x01));


                     body.instructions = f0972_parent_instructions;
                     body.emit(f0972);

                     /* END IF */

                     body.emit(assign(r0955, r096F, 0x01));

                     body.emit(assign(r0956, r096E, 0x01));

                     body.emit(assign(r0957, r096D, 0x01));

                     body.emit(assign(r0954, body.constant(int(0)), 0x01));

                     body.emit(assign(r095A, less(r096D, body.constant(0u)), 0x01));


                  body.instructions = f0969_parent_instructions;
                  body.emit(f0969);

                  /* END IF */


               body.instructions = f0966_parent_instructions;
               body.emit(f0966);

               /* END IF */


            body.instructions = f095C_parent_instructions;
            body.emit(f095C);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0985 = new(mem_ctx) ir_if(operand(r0958).val);
            exec_list *const f0985_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0985->then_instructions;

               /* IF CONDITION */
               ir_if *f0986 = new(mem_ctx) ir_if(operand(r095A).val);
               exec_list *const f0986_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0986->then_instructions;

                  ir_variable *const r0987 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0987, add(r0956, body.constant(1u)), 0x01));

                  ir_expression *const r0988 = less(r0987, r0956);
                  ir_expression *const r0989 = expr(ir_unop_b2i, r0988);
                  ir_expression *const r098A = expr(ir_unop_i2u, r0989);
                  body.emit(assign(r0955, add(r0955, r098A), 0x01));

                  ir_expression *const r098B = equal(r0957, body.constant(0u));
                  ir_expression *const r098C = expr(ir_unop_b2i, r098B);
                  ir_expression *const r098D = expr(ir_unop_i2u, r098C);
                  ir_expression *const r098E = add(r0957, r098D);
                  ir_expression *const r098F = bit_and(r098E, body.constant(1u));
                  ir_expression *const r0990 = expr(ir_unop_bit_not, r098F);
                  body.emit(assign(r0956, bit_and(r0987, r0990), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0986->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0992 = bit_or(r0955, r0956);
                  ir_expression *const r0993 = equal(r0992, body.constant(0u));
                  ir_if *f0991 = new(mem_ctx) ir_if(operand(r0993).val);
                  exec_list *const f0991_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0991->then_instructions;

                     body.emit(assign(r0954, body.constant(int(0)), 0x01));


                  body.instructions = f0991_parent_instructions;
                  body.emit(f0991);

                  /* END IF */


               body.instructions = f0986_parent_instructions;
               body.emit(f0986);

               /* END IF */

               ir_variable *const r0994 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0994);
               ir_expression *const r0995 = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0996 = expr(ir_unop_i2u, r0954);
               ir_expression *const r0997 = lshift(r0996, body.constant(int(20)));
               ir_expression *const r0998 = add(r0995, r0997);
               body.emit(assign(r0994, add(r0998, r0955), 0x02));

               body.emit(assign(r0994, r0956, 0x01));

               body.emit(assign(r0959, r0994, 0x03));

               body.emit(assign(r0958, body.constant(false), 0x01));


            body.instructions = f0985_parent_instructions;
            body.emit(f0985);

            /* END IF */

            body.emit(assign(r07F1, r0959, 0x03));

            body.emit(assign(r07F0, body.constant(false), 0x01));


         body.instructions = f0905_parent_instructions;
         body.emit(f0905);

         /* END IF */


      body.instructions = f08FE_parent_instructions;
      body.emit(f08FE);

      /* END IF */

      body.emit(assign(r07EB, r07F1, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f07EE->else_instructions;

      ir_variable *const r0999 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r0999, r07EC, 0x01));

      ir_variable *const r099A = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r099B = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r099B);
      ir_variable *const r099C = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r099C);
      ir_variable *const r099D = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r099D);
      ir_variable *const r099E = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r099E);
      ir_variable *const r099F = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r099F);
      ir_variable *const r09A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r09A0);
      ir_variable *const r09A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r09A1);
      ir_variable *const r09A2 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r09A2);
      ir_variable *const r09A3 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r09A4 = rshift(swizzle_y(r07E9), body.constant(int(20)));
      ir_expression *const r09A5 = bit_and(r09A4, body.constant(2047u));
      body.emit(assign(r09A3, expr(ir_unop_u2i, r09A5), 0x01));

      body.emit(assign(r099D, r09A3, 0x01));

      ir_variable *const r09A6 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r09A7 = rshift(swizzle_y(r07EA), body.constant(int(20)));
      ir_expression *const r09A8 = bit_and(r09A7, body.constant(2047u));
      body.emit(assign(r09A6, expr(ir_unop_u2i, r09A8), 0x01));

      body.emit(assign(r099C, r09A6, 0x01));

      body.emit(assign(r099B, sub(r09A3, r09A6), 0x01));

      ir_variable *const r09A9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09A9, lshift(swizzle_x(r07E9), body.constant(int(10))), 0x01));

      ir_variable *const r09AA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09AB = bit_and(swizzle_y(r07E9), body.constant(1048575u));
      ir_expression *const r09AC = lshift(r09AB, body.constant(int(10)));
      ir_expression *const r09AD = rshift(swizzle_x(r07E9), body.constant(int(22)));
      body.emit(assign(r09AA, bit_or(r09AC, r09AD), 0x01));

      body.emit(assign(r09A0, r09AA, 0x01));

      body.emit(assign(r09A1, r09A9, 0x01));

      ir_variable *const r09AE = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09AE, lshift(swizzle_x(r07EA), body.constant(int(10))), 0x01));

      ir_variable *const r09AF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09B0 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
      ir_expression *const r09B1 = lshift(r09B0, body.constant(int(10)));
      ir_expression *const r09B2 = rshift(swizzle_x(r07EA), body.constant(int(22)));
      body.emit(assign(r09AF, bit_or(r09B1, r09B2), 0x01));

      body.emit(assign(r099E, r09AF, 0x01));

      body.emit(assign(r099F, r09AE, 0x01));

      /* IF CONDITION */
      ir_expression *const r09B4 = less(body.constant(int(0)), r099B);
      ir_if *f09B3 = new(mem_ctx) ir_if(operand(r09B4).val);
      exec_list *const f09B3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f09B3->then_instructions;

         /* IF CONDITION */
         ir_expression *const r09B6 = equal(r09A3, body.constant(int(2047)));
         ir_if *f09B5 = new(mem_ctx) ir_if(operand(r09B6).val);
         exec_list *const f09B5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f09B5->then_instructions;

            /* IF CONDITION */
            ir_expression *const r09B8 = bit_or(r09AA, r09A9);
            ir_expression *const r09B9 = nequal(r09B8, body.constant(0u));
            ir_if *f09B7 = new(mem_ctx) ir_if(operand(r09B9).val);
            exec_list *const f09B7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09B7->then_instructions;

               ir_variable *const r09BA = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r09BA, swizzle_x(r07E9), 0x01));

               ir_variable *const r09BB = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r09BB, swizzle_x(r07EA), 0x01));

               ir_variable *const r09BC = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r09BD = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r09BE = rshift(swizzle_y(r07E9), body.constant(int(19)));
               ir_expression *const r09BF = bit_and(r09BE, body.constant(4095u));
               ir_expression *const r09C0 = equal(r09BF, body.constant(4094u));
               ir_expression *const r09C1 = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r09C2 = bit_and(swizzle_y(r07E9), body.constant(524287u));
               ir_expression *const r09C3 = nequal(r09C2, body.constant(0u));
               ir_expression *const r09C4 = logic_or(r09C1, r09C3);
               body.emit(assign(r09BD, logic_and(r09C0, r09C4), 0x01));

               ir_variable *const r09C5 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r09C6 = lshift(swizzle_y(r07EA), body.constant(int(1)));
               ir_expression *const r09C7 = lequal(body.constant(4292870144u), r09C6);
               ir_expression *const r09C8 = nequal(swizzle_x(r07EA), body.constant(0u));
               ir_expression *const r09C9 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
               ir_expression *const r09CA = nequal(r09C9, body.constant(0u));
               ir_expression *const r09CB = logic_or(r09C8, r09CA);
               body.emit(assign(r09C5, logic_and(r09C7, r09CB), 0x01));

               body.emit(assign(r09BA, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

               body.emit(assign(r09BB, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r09CD = lshift(swizzle_y(r07E9), body.constant(int(1)));
               ir_expression *const r09CE = lequal(body.constant(4292870144u), r09CD);
               ir_expression *const r09CF = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r09D0 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
               ir_expression *const r09D1 = nequal(r09D0, body.constant(0u));
               ir_expression *const r09D2 = logic_or(r09CF, r09D1);
               ir_expression *const r09D3 = logic_and(r09CE, r09D2);
               ir_if *f09CC = new(mem_ctx) ir_if(operand(r09D3).val);
               exec_list *const f09CC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09CC->then_instructions;

                  ir_variable *const r09D4 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r09D6 = logic_and(r09BD, r09C5);
                  ir_if *f09D5 = new(mem_ctx) ir_if(operand(r09D6).val);
                  exec_list *const f09D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09D5->then_instructions;

                     body.emit(assign(r09D4, r09BB, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09D5->else_instructions;

                     body.emit(assign(r09D4, r09BA, 0x03));


                  body.instructions = f09D5_parent_instructions;
                  body.emit(f09D5);

                  /* END IF */

                  body.emit(assign(r09BC, r09D4, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09CC->else_instructions;

                  body.emit(assign(r09BC, r09BB, 0x03));


               body.instructions = f09CC_parent_instructions;
               body.emit(f09CC);

               /* END IF */

               body.emit(assign(r099A, r09BC, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09B7->else_instructions;

               body.emit(assign(r099A, r07E9, 0x03));


            body.instructions = f09B7_parent_instructions;
            body.emit(f09B7);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f09B5->else_instructions;

            /* IF CONDITION */
            ir_expression *const r09D8 = equal(r09A6, body.constant(int(0)));
            ir_if *f09D7 = new(mem_ctx) ir_if(operand(r09D8).val);
            exec_list *const f09D7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09D7->then_instructions;

               body.emit(assign(r099B, add(r099B, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09D7->else_instructions;

               body.emit(assign(r099E, bit_or(r09AF, body.constant(1073741824u)), 0x01));


            body.instructions = f09D7_parent_instructions;
            body.emit(f09D7);

            /* END IF */

            ir_variable *const r09D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r09D9);
            ir_variable *const r09DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r09DA);
            ir_variable *const r09DB = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r09DC = neg(r099B);
            body.emit(assign(r09DB, bit_and(r09DC, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r09DE = equal(r099B, body.constant(int(0)));
            ir_if *f09DD = new(mem_ctx) ir_if(operand(r09DE).val);
            exec_list *const f09DD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09DD->then_instructions;

               body.emit(assign(r09D9, r09AE, 0x01));

               body.emit(assign(r09DA, r099E, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09DD->else_instructions;

               /* IF CONDITION */
               ir_expression *const r09E0 = less(r099B, body.constant(int(32)));
               ir_if *f09DF = new(mem_ctx) ir_if(operand(r09E0).val);
               exec_list *const f09DF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09DF->then_instructions;

                  ir_expression *const r09E1 = lshift(r099E, r09DB);
                  ir_expression *const r09E2 = rshift(r09AE, r099B);
                  ir_expression *const r09E3 = bit_or(r09E1, r09E2);
                  ir_expression *const r09E4 = lshift(r09AE, r09DB);
                  ir_expression *const r09E5 = nequal(r09E4, body.constant(0u));
                  ir_expression *const r09E6 = expr(ir_unop_b2i, r09E5);
                  ir_expression *const r09E7 = expr(ir_unop_i2u, r09E6);
                  body.emit(assign(r09D9, bit_or(r09E3, r09E7), 0x01));

                  body.emit(assign(r09DA, rshift(r099E, r099B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09DF->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r09E9 = equal(r099B, body.constant(int(32)));
                  ir_if *f09E8 = new(mem_ctx) ir_if(operand(r09E9).val);
                  exec_list *const f09E8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09E8->then_instructions;

                     ir_expression *const r09EA = nequal(r09AE, body.constant(0u));
                     ir_expression *const r09EB = expr(ir_unop_b2i, r09EA);
                     ir_expression *const r09EC = expr(ir_unop_i2u, r09EB);
                     body.emit(assign(r09D9, bit_or(r099E, r09EC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09E8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r09EE = less(r099B, body.constant(int(64)));
                     ir_if *f09ED = new(mem_ctx) ir_if(operand(r09EE).val);
                     exec_list *const f09ED_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f09ED->then_instructions;

                        ir_expression *const r09EF = bit_and(r099B, body.constant(int(31)));
                        ir_expression *const r09F0 = rshift(r099E, r09EF);
                        ir_expression *const r09F1 = lshift(r099E, r09DB);
                        ir_expression *const r09F2 = bit_or(r09F1, r09AE);
                        ir_expression *const r09F3 = nequal(r09F2, body.constant(0u));
                        ir_expression *const r09F4 = expr(ir_unop_b2i, r09F3);
                        ir_expression *const r09F5 = expr(ir_unop_i2u, r09F4);
                        body.emit(assign(r09D9, bit_or(r09F0, r09F5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f09ED->else_instructions;

                        ir_expression *const r09F6 = bit_or(r099E, r09AE);
                        ir_expression *const r09F7 = nequal(r09F6, body.constant(0u));
                        ir_expression *const r09F8 = expr(ir_unop_b2i, r09F7);
                        body.emit(assign(r09D9, expr(ir_unop_i2u, r09F8), 0x01));


                     body.instructions = f09ED_parent_instructions;
                     body.emit(f09ED);

                     /* END IF */


                  body.instructions = f09E8_parent_instructions;
                  body.emit(f09E8);

                  /* END IF */

                  body.emit(assign(r09DA, body.constant(0u), 0x01));


               body.instructions = f09DF_parent_instructions;
               body.emit(f09DF);

               /* END IF */


            body.instructions = f09DD_parent_instructions;
            body.emit(f09DD);

            /* END IF */

            body.emit(assign(r099E, r09DA, 0x01));

            body.emit(assign(r099F, r09D9, 0x01));

            body.emit(assign(r09A0, bit_or(r09AA, body.constant(1073741824u)), 0x01));

            ir_variable *const r09F9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r09FA = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r09FA, sub(r09A9, r09D9), 0x01));

            ir_expression *const r09FB = sub(r09A0, r09DA);
            ir_expression *const r09FC = less(r09A9, r09D9);
            ir_expression *const r09FD = expr(ir_unop_b2i, r09FC);
            ir_expression *const r09FE = expr(ir_unop_i2u, r09FD);
            body.emit(assign(r09F9, sub(r09FB, r09FE), 0x01));

            body.emit(assign(r09A2, add(r09A3, body.constant(int(-1))), 0x01));

            ir_variable *const r09FF = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r09FF, add(r09A2, body.constant(int(-10))), 0x01));

            ir_variable *const r0A00 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0A00, r09F9, 0x01));

            ir_variable *const r0A01 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0A01, r09FA, 0x01));

            ir_variable *const r0A02 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0A02);
            ir_variable *const r0A03 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0A03);
            /* IF CONDITION */
            ir_expression *const r0A05 = equal(r09F9, body.constant(0u));
            ir_if *f0A04 = new(mem_ctx) ir_if(operand(r0A05).val);
            exec_list *const f0A04_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A04->then_instructions;

               body.emit(assign(r0A00, r09FA, 0x01));

               body.emit(assign(r0A01, body.constant(0u), 0x01));

               body.emit(assign(r09FF, add(r09FF, body.constant(int(-32))), 0x01));


            body.instructions = f0A04_parent_instructions;
            body.emit(f0A04);

            /* END IF */

            ir_variable *const r0A06 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0A06, r0A00, 0x01));

            ir_variable *const r0A07 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0A08 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0A08);
            /* IF CONDITION */
            ir_expression *const r0A0A = equal(r0A00, body.constant(0u));
            ir_if *f0A09 = new(mem_ctx) ir_if(operand(r0A0A).val);
            exec_list *const f0A09_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A09->then_instructions;

               body.emit(assign(r0A07, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A09->else_instructions;

               body.emit(assign(r0A08, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A0C = bit_and(r0A00, body.constant(4294901760u));
               ir_expression *const r0A0D = equal(r0A0C, body.constant(0u));
               ir_if *f0A0B = new(mem_ctx) ir_if(operand(r0A0D).val);
               exec_list *const f0A0B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0B->then_instructions;

                  body.emit(assign(r0A08, body.constant(int(16)), 0x01));

                  body.emit(assign(r0A06, lshift(r0A00, body.constant(int(16))), 0x01));


               body.instructions = f0A0B_parent_instructions;
               body.emit(f0A0B);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A0F = bit_and(r0A06, body.constant(4278190080u));
               ir_expression *const r0A10 = equal(r0A0F, body.constant(0u));
               ir_if *f0A0E = new(mem_ctx) ir_if(operand(r0A10).val);
               exec_list *const f0A0E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0E->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(8))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(8))), 0x01));


               body.instructions = f0A0E_parent_instructions;
               body.emit(f0A0E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A12 = bit_and(r0A06, body.constant(4026531840u));
               ir_expression *const r0A13 = equal(r0A12, body.constant(0u));
               ir_if *f0A11 = new(mem_ctx) ir_if(operand(r0A13).val);
               exec_list *const f0A11_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A11->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(4))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(4))), 0x01));


               body.instructions = f0A11_parent_instructions;
               body.emit(f0A11);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A15 = bit_and(r0A06, body.constant(3221225472u));
               ir_expression *const r0A16 = equal(r0A15, body.constant(0u));
               ir_if *f0A14 = new(mem_ctx) ir_if(operand(r0A16).val);
               exec_list *const f0A14_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A14->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(2))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(2))), 0x01));


               body.instructions = f0A14_parent_instructions;
               body.emit(f0A14);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A18 = bit_and(r0A06, body.constant(2147483648u));
               ir_expression *const r0A19 = equal(r0A18, body.constant(0u));
               ir_if *f0A17 = new(mem_ctx) ir_if(operand(r0A19).val);
               exec_list *const f0A17_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A17->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(1))), 0x01));


               body.instructions = f0A17_parent_instructions;
               body.emit(f0A17);

               /* END IF */

               body.emit(assign(r0A07, r0A08, 0x01));


            body.instructions = f0A09_parent_instructions;
            body.emit(f0A09);

            /* END IF */

            body.emit(assign(r0A03, add(r0A07, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A1B = lequal(body.constant(int(0)), r0A03);
            ir_if *f0A1A = new(mem_ctx) ir_if(operand(r0A1B).val);
            exec_list *const f0A1A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A1A->then_instructions;

               body.emit(assign(r0A02, body.constant(0u), 0x01));

               ir_variable *const r0A1C = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0A1C, lshift(r0A01, r0A03), 0x01));

               ir_variable *const r0A1D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0A1F = equal(r0A03, body.constant(int(0)));
               ir_if *f0A1E = new(mem_ctx) ir_if(operand(r0A1F).val);
               exec_list *const f0A1E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A1E->then_instructions;

                  body.emit(assign(r0A1D, r0A00, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A1E->else_instructions;

                  ir_expression *const r0A20 = lshift(r0A00, r0A03);
                  ir_expression *const r0A21 = neg(r0A03);
                  ir_expression *const r0A22 = bit_and(r0A21, body.constant(int(31)));
                  ir_expression *const r0A23 = rshift(r0A01, r0A22);
                  body.emit(assign(r0A1D, bit_or(r0A20, r0A23), 0x01));


               body.instructions = f0A1E_parent_instructions;
               body.emit(f0A1E);

               /* END IF */

               body.emit(assign(r0A00, r0A1D, 0x01));

               body.emit(assign(r0A01, r0A1C, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A1A->else_instructions;

               ir_variable *const r0A24 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0A24, body.constant(0u), 0x01));

               ir_variable *const r0A25 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0A25, neg(r0A03), 0x01));

               ir_variable *const r0A26 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0A26);
               ir_variable *const r0A27 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0A27);
               ir_variable *const r0A28 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0A28);
               ir_variable *const r0A29 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0A2A = neg(r0A25);
               body.emit(assign(r0A29, bit_and(r0A2A, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A2C = equal(r0A25, body.constant(int(0)));
               ir_if *f0A2B = new(mem_ctx) ir_if(operand(r0A2C).val);
               exec_list *const f0A2B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A2B->then_instructions;

                  body.emit(assign(r0A26, r0A24, 0x01));

                  body.emit(assign(r0A27, r0A01, 0x01));

                  body.emit(assign(r0A28, r0A00, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A2B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A2E = less(r0A25, body.constant(int(32)));
                  ir_if *f0A2D = new(mem_ctx) ir_if(operand(r0A2E).val);
                  exec_list *const f0A2D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A2D->then_instructions;

                     body.emit(assign(r0A26, lshift(r0A01, r0A29), 0x01));

                     ir_expression *const r0A2F = lshift(r0A00, r0A29);
                     ir_expression *const r0A30 = rshift(r0A01, r0A25);
                     body.emit(assign(r0A27, bit_or(r0A2F, r0A30), 0x01));

                     body.emit(assign(r0A28, rshift(r0A00, r0A25), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A2D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0A32 = equal(r0A25, body.constant(int(32)));
                     ir_if *f0A31 = new(mem_ctx) ir_if(operand(r0A32).val);
                     exec_list *const f0A31_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A31->then_instructions;

                        body.emit(assign(r0A26, r0A01, 0x01));

                        body.emit(assign(r0A27, r0A00, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A31->else_instructions;

                        body.emit(assign(r0A24, bit_or(body.constant(0u), r0A01), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0A34 = less(r0A25, body.constant(int(64)));
                        ir_if *f0A33 = new(mem_ctx) ir_if(operand(r0A34).val);
                        exec_list *const f0A33_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A33->then_instructions;

                           body.emit(assign(r0A26, lshift(r0A00, r0A29), 0x01));

                           ir_expression *const r0A35 = bit_and(r0A25, body.constant(int(31)));
                           body.emit(assign(r0A27, rshift(r0A00, r0A35), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A33->else_instructions;

                           ir_variable *const r0A36 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0A38 = equal(r0A25, body.constant(int(64)));
                           ir_if *f0A37 = new(mem_ctx) ir_if(operand(r0A38).val);
                           exec_list *const f0A37_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A37->then_instructions;

                              body.emit(assign(r0A36, r0A00, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A37->else_instructions;

                              ir_expression *const r0A39 = nequal(r0A00, body.constant(0u));
                              ir_expression *const r0A3A = expr(ir_unop_b2i, r0A39);
                              body.emit(assign(r0A36, expr(ir_unop_i2u, r0A3A), 0x01));


                           body.instructions = f0A37_parent_instructions;
                           body.emit(f0A37);

                           /* END IF */

                           body.emit(assign(r0A26, r0A36, 0x01));

                           body.emit(assign(r0A27, body.constant(0u), 0x01));


                        body.instructions = f0A33_parent_instructions;
                        body.emit(f0A33);

                        /* END IF */


                     body.instructions = f0A31_parent_instructions;
                     body.emit(f0A31);

                     /* END IF */

                     body.emit(assign(r0A28, body.constant(0u), 0x01));


                  body.instructions = f0A2D_parent_instructions;
                  body.emit(f0A2D);

                  /* END IF */

                  ir_expression *const r0A3B = nequal(r0A24, body.constant(0u));
                  ir_expression *const r0A3C = expr(ir_unop_b2i, r0A3B);
                  ir_expression *const r0A3D = expr(ir_unop_i2u, r0A3C);
                  body.emit(assign(r0A26, bit_or(r0A26, r0A3D), 0x01));


               body.instructions = f0A2B_parent_instructions;
               body.emit(f0A2B);

               /* END IF */

               body.emit(assign(r0A00, r0A28, 0x01));

               body.emit(assign(r0A01, r0A27, 0x01));

               body.emit(assign(r0A02, r0A26, 0x01));


            body.instructions = f0A1A_parent_instructions;
            body.emit(f0A1A);

            /* END IF */

            body.emit(assign(r09FF, sub(r09FF, r0A03), 0x01));

            ir_variable *const r0A3E = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0A3E, r09FF, 0x01));

            ir_variable *const r0A3F = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0A3F, r0A00, 0x01));

            ir_variable *const r0A40 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0A40, r0A01, 0x01));

            ir_variable *const r0A41 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0A41, r0A02, 0x01));

            ir_variable *const r0A42 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0A42, body.constant(true), 0x01));

            ir_variable *const r0A43 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0A44 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0A44);
            ir_expression *const r0A45 = expr(ir_unop_u2i, r0A02);
            body.emit(assign(r0A44, less(r0A45, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A47 = lequal(body.constant(int(2045)), r09FF);
            ir_if *f0A46 = new(mem_ctx) ir_if(operand(r0A47).val);
            exec_list *const f0A46_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A46->then_instructions;

               ir_variable *const r0A48 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0A4A = less(body.constant(int(2045)), r09FF);
               ir_if *f0A49 = new(mem_ctx) ir_if(operand(r0A4A).val);
               exec_list *const f0A49_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A49->then_instructions;

                  body.emit(assign(r0A48, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A49->else_instructions;

                  ir_variable *const r0A4B = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0A4D = equal(r09FF, body.constant(int(2045)));
                  ir_if *f0A4C = new(mem_ctx) ir_if(operand(r0A4D).val);
                  exec_list *const f0A4C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A4C->then_instructions;

                     ir_expression *const r0A4E = equal(body.constant(2097151u), r0A00);
                     ir_expression *const r0A4F = equal(body.constant(4294967295u), r0A01);
                     body.emit(assign(r0A4B, logic_and(r0A4E, r0A4F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A4C->else_instructions;

                     body.emit(assign(r0A4B, body.constant(false), 0x01));


                  body.instructions = f0A4C_parent_instructions;
                  body.emit(f0A4C);

                  /* END IF */

                  body.emit(assign(r0A48, logic_and(r0A4B, r0A44), 0x01));


               body.instructions = f0A49_parent_instructions;
               body.emit(f0A49);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0A50 = new(mem_ctx) ir_if(operand(r0A48).val);
               exec_list *const f0A50_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A50->then_instructions;

                  ir_variable *const r0A51 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0A51);
                  ir_expression *const r0A52 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0A51, add(r0A52, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0A51, body.constant(0u), 0x01));

                  body.emit(assign(r0A43, r0A51, 0x03));

                  body.emit(assign(r0A42, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A50->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A54 = less(r09FF, body.constant(int(0)));
                  ir_if *f0A53 = new(mem_ctx) ir_if(operand(r0A54).val);
                  exec_list *const f0A53_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A53->then_instructions;

                     ir_variable *const r0A55 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0A55, r0A02, 0x01));

                     ir_variable *const r0A56 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0A56, neg(r09FF), 0x01));

                     ir_variable *const r0A57 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0A57);
                     ir_variable *const r0A58 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0A58);
                     ir_variable *const r0A59 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0A59);
                     ir_variable *const r0A5A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0A5B = neg(r0A56);
                     body.emit(assign(r0A5A, bit_and(r0A5B, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0A5D = equal(r0A56, body.constant(int(0)));
                     ir_if *f0A5C = new(mem_ctx) ir_if(operand(r0A5D).val);
                     exec_list *const f0A5C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A5C->then_instructions;

                        body.emit(assign(r0A57, r0A02, 0x01));

                        body.emit(assign(r0A58, r0A01, 0x01));

                        body.emit(assign(r0A59, r0A00, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A5C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0A5F = less(r0A56, body.constant(int(32)));
                        ir_if *f0A5E = new(mem_ctx) ir_if(operand(r0A5F).val);
                        exec_list *const f0A5E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A5E->then_instructions;

                           body.emit(assign(r0A57, lshift(r0A01, r0A5A), 0x01));

                           ir_expression *const r0A60 = lshift(r0A00, r0A5A);
                           ir_expression *const r0A61 = rshift(r0A01, r0A56);
                           body.emit(assign(r0A58, bit_or(r0A60, r0A61), 0x01));

                           body.emit(assign(r0A59, rshift(r0A00, r0A56), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A5E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0A63 = equal(r0A56, body.constant(int(32)));
                           ir_if *f0A62 = new(mem_ctx) ir_if(operand(r0A63).val);
                           exec_list *const f0A62_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A62->then_instructions;

                              body.emit(assign(r0A57, r0A01, 0x01));

                              body.emit(assign(r0A58, r0A00, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A62->else_instructions;

                              body.emit(assign(r0A55, bit_or(r0A02, r0A01), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0A65 = less(r0A56, body.constant(int(64)));
                              ir_if *f0A64 = new(mem_ctx) ir_if(operand(r0A65).val);
                              exec_list *const f0A64_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0A64->then_instructions;

                                 body.emit(assign(r0A57, lshift(r0A00, r0A5A), 0x01));

                                 ir_expression *const r0A66 = bit_and(r0A56, body.constant(int(31)));
                                 body.emit(assign(r0A58, rshift(r0A00, r0A66), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0A64->else_instructions;

                                 ir_variable *const r0A67 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0A69 = equal(r0A56, body.constant(int(64)));
                                 ir_if *f0A68 = new(mem_ctx) ir_if(operand(r0A69).val);
                                 exec_list *const f0A68_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0A68->then_instructions;

                                    body.emit(assign(r0A67, r0A00, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0A68->else_instructions;

                                    ir_expression *const r0A6A = nequal(r0A00, body.constant(0u));
                                    ir_expression *const r0A6B = expr(ir_unop_b2i, r0A6A);
                                    body.emit(assign(r0A67, expr(ir_unop_i2u, r0A6B), 0x01));


                                 body.instructions = f0A68_parent_instructions;
                                 body.emit(f0A68);

                                 /* END IF */

                                 body.emit(assign(r0A57, r0A67, 0x01));

                                 body.emit(assign(r0A58, body.constant(0u), 0x01));


                              body.instructions = f0A64_parent_instructions;
                              body.emit(f0A64);

                              /* END IF */


                           body.instructions = f0A62_parent_instructions;
                           body.emit(f0A62);

                           /* END IF */

                           body.emit(assign(r0A59, body.constant(0u), 0x01));


                        body.instructions = f0A5E_parent_instructions;
                        body.emit(f0A5E);

                        /* END IF */

                        ir_expression *const r0A6C = nequal(r0A55, body.constant(0u));
                        ir_expression *const r0A6D = expr(ir_unop_b2i, r0A6C);
                        ir_expression *const r0A6E = expr(ir_unop_i2u, r0A6D);
                        body.emit(assign(r0A57, bit_or(r0A57, r0A6E), 0x01));


                     body.instructions = f0A5C_parent_instructions;
                     body.emit(f0A5C);

                     /* END IF */

                     body.emit(assign(r0A3F, r0A59, 0x01));

                     body.emit(assign(r0A40, r0A58, 0x01));

                     body.emit(assign(r0A41, r0A57, 0x01));

                     body.emit(assign(r0A3E, body.constant(int(0)), 0x01));

                     body.emit(assign(r0A44, less(r0A57, body.constant(0u)), 0x01));


                  body.instructions = f0A53_parent_instructions;
                  body.emit(f0A53);

                  /* END IF */


               body.instructions = f0A50_parent_instructions;
               body.emit(f0A50);

               /* END IF */


            body.instructions = f0A46_parent_instructions;
            body.emit(f0A46);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0A6F = new(mem_ctx) ir_if(operand(r0A42).val);
            exec_list *const f0A6F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A6F->then_instructions;

               /* IF CONDITION */
               ir_if *f0A70 = new(mem_ctx) ir_if(operand(r0A44).val);
               exec_list *const f0A70_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A70->then_instructions;

                  ir_variable *const r0A71 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0A71, add(r0A40, body.constant(1u)), 0x01));

                  ir_expression *const r0A72 = less(r0A71, r0A40);
                  ir_expression *const r0A73 = expr(ir_unop_b2i, r0A72);
                  ir_expression *const r0A74 = expr(ir_unop_i2u, r0A73);
                  body.emit(assign(r0A3F, add(r0A3F, r0A74), 0x01));

                  ir_expression *const r0A75 = equal(r0A41, body.constant(0u));
                  ir_expression *const r0A76 = expr(ir_unop_b2i, r0A75);
                  ir_expression *const r0A77 = expr(ir_unop_i2u, r0A76);
                  ir_expression *const r0A78 = add(r0A41, r0A77);
                  ir_expression *const r0A79 = bit_and(r0A78, body.constant(1u));
                  ir_expression *const r0A7A = expr(ir_unop_bit_not, r0A79);
                  body.emit(assign(r0A40, bit_and(r0A71, r0A7A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A70->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A7C = bit_or(r0A3F, r0A40);
                  ir_expression *const r0A7D = equal(r0A7C, body.constant(0u));
                  ir_if *f0A7B = new(mem_ctx) ir_if(operand(r0A7D).val);
                  exec_list *const f0A7B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A7B->then_instructions;

                     body.emit(assign(r0A3E, body.constant(int(0)), 0x01));


                  body.instructions = f0A7B_parent_instructions;
                  body.emit(f0A7B);

                  /* END IF */


               body.instructions = f0A70_parent_instructions;
               body.emit(f0A70);

               /* END IF */

               ir_variable *const r0A7E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0A7E);
               ir_expression *const r0A7F = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0A80 = expr(ir_unop_i2u, r0A3E);
               ir_expression *const r0A81 = lshift(r0A80, body.constant(int(20)));
               ir_expression *const r0A82 = add(r0A7F, r0A81);
               body.emit(assign(r0A7E, add(r0A82, r0A3F), 0x02));

               body.emit(assign(r0A7E, r0A40, 0x01));

               body.emit(assign(r0A43, r0A7E, 0x03));

               body.emit(assign(r0A42, body.constant(false), 0x01));


            body.instructions = f0A6F_parent_instructions;
            body.emit(f0A6F);

            /* END IF */

            body.emit(assign(r099A, r0A43, 0x03));


         body.instructions = f09B5_parent_instructions;
         body.emit(f09B5);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f09B3->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0A84 = less(r099B, body.constant(int(0)));
         ir_if *f0A83 = new(mem_ctx) ir_if(operand(r0A84).val);
         exec_list *const f0A83_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0A83->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0A86 = equal(r09A6, body.constant(int(2047)));
            ir_if *f0A85 = new(mem_ctx) ir_if(operand(r0A86).val);
            exec_list *const f0A85_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A85->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0A88 = bit_or(r099E, r099F);
               ir_expression *const r0A89 = nequal(r0A88, body.constant(0u));
               ir_if *f0A87 = new(mem_ctx) ir_if(operand(r0A89).val);
               exec_list *const f0A87_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A87->then_instructions;

                  ir_variable *const r0A8A = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0A8A, swizzle_x(r07E9), 0x01));

                  ir_variable *const r0A8B = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0A8B, swizzle_x(r07EA), 0x01));

                  ir_variable *const r0A8C = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0A8D = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0A8E = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0A8F = bit_and(r0A8E, body.constant(4095u));
                  ir_expression *const r0A90 = equal(r0A8F, body.constant(4094u));
                  ir_expression *const r0A91 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0A92 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0A93 = nequal(r0A92, body.constant(0u));
                  ir_expression *const r0A94 = logic_or(r0A91, r0A93);
                  body.emit(assign(r0A8D, logic_and(r0A90, r0A94), 0x01));

                  ir_variable *const r0A95 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0A96 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0A97 = lequal(body.constant(4292870144u), r0A96);
                  ir_expression *const r0A98 = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0A99 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0A9A = nequal(r0A99, body.constant(0u));
                  ir_expression *const r0A9B = logic_or(r0A98, r0A9A);
                  body.emit(assign(r0A95, logic_and(r0A97, r0A9B), 0x01));

                  body.emit(assign(r0A8A, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r0A8B, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0A9D = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r0A9E = lequal(body.constant(4292870144u), r0A9D);
                  ir_expression *const r0A9F = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0AA0 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0AA1 = nequal(r0AA0, body.constant(0u));
                  ir_expression *const r0AA2 = logic_or(r0A9F, r0AA1);
                  ir_expression *const r0AA3 = logic_and(r0A9E, r0AA2);
                  ir_if *f0A9C = new(mem_ctx) ir_if(operand(r0AA3).val);
                  exec_list *const f0A9C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A9C->then_instructions;

                     ir_variable *const r0AA4 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0AA6 = logic_and(r0A8D, r0A95);
                     ir_if *f0AA5 = new(mem_ctx) ir_if(operand(r0AA6).val);
                     exec_list *const f0AA5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0AA5->then_instructions;

                        body.emit(assign(r0AA4, r0A8B, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0AA5->else_instructions;

                        body.emit(assign(r0AA4, r0A8A, 0x03));


                     body.instructions = f0AA5_parent_instructions;
                     body.emit(f0AA5);

                     /* END IF */

                     body.emit(assign(r0A8C, r0AA4, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A9C->else_instructions;

                     body.emit(assign(r0A8C, r0A8B, 0x03));


                  body.instructions = f0A9C_parent_instructions;
                  body.emit(f0A9C);

                  /* END IF */

                  body.emit(assign(r099A, r0A8C, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A87->else_instructions;

                  ir_variable *const r0AA7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0AA7);
                  ir_expression *const r0AA8 = bit_xor(r07EC, body.constant(1u));
                  ir_expression *const r0AA9 = lshift(r0AA8, body.constant(int(31)));
                  body.emit(assign(r0AA7, add(r0AA9, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0AA7, body.constant(0u), 0x01));

                  body.emit(assign(r099A, r0AA7, 0x03));


               body.instructions = f0A87_parent_instructions;
               body.emit(f0A87);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A85->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0AAB = equal(r09A3, body.constant(int(0)));
               ir_if *f0AAA = new(mem_ctx) ir_if(operand(r0AAB).val);
               exec_list *const f0AAA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AAA->then_instructions;

                  body.emit(assign(r099B, add(r099B, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AAA->else_instructions;

                  body.emit(assign(r09A0, bit_or(r09A0, body.constant(1073741824u)), 0x01));


               body.instructions = f0AAA_parent_instructions;
               body.emit(f0AAA);

               /* END IF */

               ir_variable *const r0AAC = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0AAC, neg(r099B), 0x01));

               ir_variable *const r0AAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0AAD);
               ir_variable *const r0AAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0AAE);
               ir_variable *const r0AAF = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0AB0 = neg(r0AAC);
               body.emit(assign(r0AAF, bit_and(r0AB0, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AB2 = equal(r0AAC, body.constant(int(0)));
               ir_if *f0AB1 = new(mem_ctx) ir_if(operand(r0AB2).val);
               exec_list *const f0AB1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AB1->then_instructions;

                  body.emit(assign(r0AAD, r09A9, 0x01));

                  body.emit(assign(r0AAE, r09A0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AB1->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0AB4 = less(r0AAC, body.constant(int(32)));
                  ir_if *f0AB3 = new(mem_ctx) ir_if(operand(r0AB4).val);
                  exec_list *const f0AB3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AB3->then_instructions;

                     ir_expression *const r0AB5 = lshift(r09A0, r0AAF);
                     ir_expression *const r0AB6 = rshift(r09A9, r0AAC);
                     ir_expression *const r0AB7 = bit_or(r0AB5, r0AB6);
                     ir_expression *const r0AB8 = lshift(r09A9, r0AAF);
                     ir_expression *const r0AB9 = nequal(r0AB8, body.constant(0u));
                     ir_expression *const r0ABA = expr(ir_unop_b2i, r0AB9);
                     ir_expression *const r0ABB = expr(ir_unop_i2u, r0ABA);
                     body.emit(assign(r0AAD, bit_or(r0AB7, r0ABB), 0x01));

                     body.emit(assign(r0AAE, rshift(r09A0, r0AAC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AB3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0ABD = equal(r0AAC, body.constant(int(32)));
                     ir_if *f0ABC = new(mem_ctx) ir_if(operand(r0ABD).val);
                     exec_list *const f0ABC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0ABC->then_instructions;

                        ir_expression *const r0ABE = nequal(r09A9, body.constant(0u));
                        ir_expression *const r0ABF = expr(ir_unop_b2i, r0ABE);
                        ir_expression *const r0AC0 = expr(ir_unop_i2u, r0ABF);
                        body.emit(assign(r0AAD, bit_or(r09A0, r0AC0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0ABC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0AC2 = less(r0AAC, body.constant(int(64)));
                        ir_if *f0AC1 = new(mem_ctx) ir_if(operand(r0AC2).val);
                        exec_list *const f0AC1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0AC1->then_instructions;

                           ir_expression *const r0AC3 = bit_and(r0AAC, body.constant(int(31)));
                           ir_expression *const r0AC4 = rshift(r09A0, r0AC3);
                           ir_expression *const r0AC5 = lshift(r09A0, r0AAF);
                           ir_expression *const r0AC6 = bit_or(r0AC5, r09A9);
                           ir_expression *const r0AC7 = nequal(r0AC6, body.constant(0u));
                           ir_expression *const r0AC8 = expr(ir_unop_b2i, r0AC7);
                           ir_expression *const r0AC9 = expr(ir_unop_i2u, r0AC8);
                           body.emit(assign(r0AAD, bit_or(r0AC4, r0AC9), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0AC1->else_instructions;

                           ir_expression *const r0ACA = bit_or(r09A0, r09A9);
                           ir_expression *const r0ACB = nequal(r0ACA, body.constant(0u));
                           ir_expression *const r0ACC = expr(ir_unop_b2i, r0ACB);
                           body.emit(assign(r0AAD, expr(ir_unop_i2u, r0ACC), 0x01));


                        body.instructions = f0AC1_parent_instructions;
                        body.emit(f0AC1);

                        /* END IF */


                     body.instructions = f0ABC_parent_instructions;
                     body.emit(f0ABC);

                     /* END IF */

                     body.emit(assign(r0AAE, body.constant(0u), 0x01));


                  body.instructions = f0AB3_parent_instructions;
                  body.emit(f0AB3);

                  /* END IF */


               body.instructions = f0AB1_parent_instructions;
               body.emit(f0AB1);

               /* END IF */

               body.emit(assign(r09A0, r0AAE, 0x01));

               body.emit(assign(r09A1, r0AAD, 0x01));

               body.emit(assign(r099E, bit_or(r099E, body.constant(1073741824u)), 0x01));

               ir_variable *const r0ACD = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0ACE = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0ACE, sub(r099F, r0AAD), 0x01));

               ir_expression *const r0ACF = sub(r099E, r0AAE);
               ir_expression *const r0AD0 = less(r099F, r0AAD);
               ir_expression *const r0AD1 = expr(ir_unop_b2i, r0AD0);
               ir_expression *const r0AD2 = expr(ir_unop_i2u, r0AD1);
               body.emit(assign(r0ACD, sub(r0ACF, r0AD2), 0x01));

               body.emit(assign(r0999, bit_xor(r07EC, body.constant(1u)), 0x01));

               body.emit(assign(r09A2, add(r09A6, body.constant(int(-1))), 0x01));

               ir_variable *const r0AD3 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0AD3, add(r09A2, body.constant(int(-10))), 0x01));

               ir_variable *const r0AD4 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0AD4, r0ACD, 0x01));

               ir_variable *const r0AD5 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0AD5, r0ACE, 0x01));

               ir_variable *const r0AD6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r0AD6);
               ir_variable *const r0AD7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0AD7);
               /* IF CONDITION */
               ir_expression *const r0AD9 = equal(r0ACD, body.constant(0u));
               ir_if *f0AD8 = new(mem_ctx) ir_if(operand(r0AD9).val);
               exec_list *const f0AD8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AD8->then_instructions;

                  body.emit(assign(r0AD4, r0ACE, 0x01));

                  body.emit(assign(r0AD5, body.constant(0u), 0x01));

                  body.emit(assign(r0AD3, add(r0AD3, body.constant(int(-32))), 0x01));


               body.instructions = f0AD8_parent_instructions;
               body.emit(f0AD8);

               /* END IF */

               ir_variable *const r0ADA = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r0ADA, r0AD4, 0x01));

               ir_variable *const r0ADB = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r0ADC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0ADC);
               /* IF CONDITION */
               ir_expression *const r0ADE = equal(r0AD4, body.constant(0u));
               ir_if *f0ADD = new(mem_ctx) ir_if(operand(r0ADE).val);
               exec_list *const f0ADD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ADD->then_instructions;

                  body.emit(assign(r0ADB, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0ADD->else_instructions;

                  body.emit(assign(r0ADC, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0AE0 = bit_and(r0AD4, body.constant(4294901760u));
                  ir_expression *const r0AE1 = equal(r0AE0, body.constant(0u));
                  ir_if *f0ADF = new(mem_ctx) ir_if(operand(r0AE1).val);
                  exec_list *const f0ADF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0ADF->then_instructions;

                     body.emit(assign(r0ADC, body.constant(int(16)), 0x01));

                     body.emit(assign(r0ADA, lshift(r0AD4, body.constant(int(16))), 0x01));


                  body.instructions = f0ADF_parent_instructions;
                  body.emit(f0ADF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE3 = bit_and(r0ADA, body.constant(4278190080u));
                  ir_expression *const r0AE4 = equal(r0AE3, body.constant(0u));
                  ir_if *f0AE2 = new(mem_ctx) ir_if(operand(r0AE4).val);
                  exec_list *const f0AE2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE2->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(8))), 0x01));

                     body.emit(assign(r0ADA, lshift(r0ADA, body.constant(int(8))), 0x01));


                  body.instructions = f0AE2_parent_instructions;
                  body.emit(f0AE2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE6 = bit_and(r0ADA, body.constant(4026531840u));
                  ir_expression *const r0AE7 = equal(r0AE6, body.constant(0u));
                  ir_if *f0AE5 = new(mem_ctx) ir_if(operand(r0AE7).val);
                  exec_list *const f0AE5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE5->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(4))), 0x01));

                     body.emit(assign(r0ADA, lshift(r0ADA, body.constant(int(4))), 0x01));


                  body.instructions = f0AE5_parent_instructions;
                  body.emit(f0AE5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE9 = bit_and(r0ADA, body.constant(3221225472u));
                  ir_expression *const r0AEA = equal(r0AE9, body.constant(0u));
                  ir_if *f0AE8 = new(mem_ctx) ir_if(operand(r0AEA).val);
                  exec_list *const f0AE8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE8->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(2))), 0x01));

                     body.emit(assign(r0ADA, lshift(r0ADA, body.constant(int(2))), 0x01));


                  body.instructions = f0AE8_parent_instructions;
                  body.emit(f0AE8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AEC = bit_and(r0ADA, body.constant(2147483648u));
                  ir_expression *const r0AED = equal(r0AEC, body.constant(0u));
                  ir_if *f0AEB = new(mem_ctx) ir_if(operand(r0AED).val);
                  exec_list *const f0AEB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AEB->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(1))), 0x01));


                  body.instructions = f0AEB_parent_instructions;
                  body.emit(f0AEB);

                  /* END IF */

                  body.emit(assign(r0ADB, r0ADC, 0x01));


               body.instructions = f0ADD_parent_instructions;
               body.emit(f0ADD);

               /* END IF */

               body.emit(assign(r0AD7, add(r0ADB, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AEF = lequal(body.constant(int(0)), r0AD7);
               ir_if *f0AEE = new(mem_ctx) ir_if(operand(r0AEF).val);
               exec_list *const f0AEE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AEE->then_instructions;

                  body.emit(assign(r0AD6, body.constant(0u), 0x01));

                  ir_variable *const r0AF0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0AF0, lshift(r0AD5, r0AD7), 0x01));

                  ir_variable *const r0AF1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0AF3 = equal(r0AD7, body.constant(int(0)));
                  ir_if *f0AF2 = new(mem_ctx) ir_if(operand(r0AF3).val);
                  exec_list *const f0AF2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AF2->then_instructions;

                     body.emit(assign(r0AF1, r0AD4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AF2->else_instructions;

                     ir_expression *const r0AF4 = lshift(r0AD4, r0AD7);
                     ir_expression *const r0AF5 = neg(r0AD7);
                     ir_expression *const r0AF6 = bit_and(r0AF5, body.constant(int(31)));
                     ir_expression *const r0AF7 = rshift(r0AD5, r0AF6);
                     body.emit(assign(r0AF1, bit_or(r0AF4, r0AF7), 0x01));


                  body.instructions = f0AF2_parent_instructions;
                  body.emit(f0AF2);

                  /* END IF */

                  body.emit(assign(r0AD4, r0AF1, 0x01));

                  body.emit(assign(r0AD5, r0AF0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AEE->else_instructions;

                  ir_variable *const r0AF8 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0AF8, body.constant(0u), 0x01));

                  ir_variable *const r0AF9 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0AF9, neg(r0AD7), 0x01));

                  ir_variable *const r0AFA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0AFA);
                  ir_variable *const r0AFB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0AFB);
                  ir_variable *const r0AFC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0AFC);
                  ir_variable *const r0AFD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0AFE = neg(r0AF9);
                  body.emit(assign(r0AFD, bit_and(r0AFE, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0B00 = equal(r0AF9, body.constant(int(0)));
                  ir_if *f0AFF = new(mem_ctx) ir_if(operand(r0B00).val);
                  exec_list *const f0AFF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AFF->then_instructions;

                     body.emit(assign(r0AFA, r0AF8, 0x01));

                     body.emit(assign(r0AFB, r0AD5, 0x01));

                     body.emit(assign(r0AFC, r0AD4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AFF->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B02 = less(r0AF9, body.constant(int(32)));
                     ir_if *f0B01 = new(mem_ctx) ir_if(operand(r0B02).val);
                     exec_list *const f0B01_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B01->then_instructions;

                        body.emit(assign(r0AFA, lshift(r0AD5, r0AFD), 0x01));

                        ir_expression *const r0B03 = lshift(r0AD4, r0AFD);
                        ir_expression *const r0B04 = rshift(r0AD5, r0AF9);
                        body.emit(assign(r0AFB, bit_or(r0B03, r0B04), 0x01));

                        body.emit(assign(r0AFC, rshift(r0AD4, r0AF9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B01->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0B06 = equal(r0AF9, body.constant(int(32)));
                        ir_if *f0B05 = new(mem_ctx) ir_if(operand(r0B06).val);
                        exec_list *const f0B05_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0B05->then_instructions;

                           body.emit(assign(r0AFA, r0AD5, 0x01));

                           body.emit(assign(r0AFB, r0AD4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0B05->else_instructions;

                           body.emit(assign(r0AF8, bit_or(body.constant(0u), r0AD5), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0B08 = less(r0AF9, body.constant(int(64)));
                           ir_if *f0B07 = new(mem_ctx) ir_if(operand(r0B08).val);
                           exec_list *const f0B07_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B07->then_instructions;

                              body.emit(assign(r0AFA, lshift(r0AD4, r0AFD), 0x01));

                              ir_expression *const r0B09 = bit_and(r0AF9, body.constant(int(31)));
                              body.emit(assign(r0AFB, rshift(r0AD4, r0B09), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B07->else_instructions;

                              ir_variable *const r0B0A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0B0C = equal(r0AF9, body.constant(int(64)));
                              ir_if *f0B0B = new(mem_ctx) ir_if(operand(r0B0C).val);
                              exec_list *const f0B0B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B0B->then_instructions;

                                 body.emit(assign(r0B0A, r0AD4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B0B->else_instructions;

                                 ir_expression *const r0B0D = nequal(r0AD4, body.constant(0u));
                                 ir_expression *const r0B0E = expr(ir_unop_b2i, r0B0D);
                                 body.emit(assign(r0B0A, expr(ir_unop_i2u, r0B0E), 0x01));


                              body.instructions = f0B0B_parent_instructions;
                              body.emit(f0B0B);

                              /* END IF */

                              body.emit(assign(r0AFA, r0B0A, 0x01));

                              body.emit(assign(r0AFB, body.constant(0u), 0x01));


                           body.instructions = f0B07_parent_instructions;
                           body.emit(f0B07);

                           /* END IF */


                        body.instructions = f0B05_parent_instructions;
                        body.emit(f0B05);

                        /* END IF */

                        body.emit(assign(r0AFC, body.constant(0u), 0x01));


                     body.instructions = f0B01_parent_instructions;
                     body.emit(f0B01);

                     /* END IF */

                     ir_expression *const r0B0F = nequal(r0AF8, body.constant(0u));
                     ir_expression *const r0B10 = expr(ir_unop_b2i, r0B0F);
                     ir_expression *const r0B11 = expr(ir_unop_i2u, r0B10);
                     body.emit(assign(r0AFA, bit_or(r0AFA, r0B11), 0x01));


                  body.instructions = f0AFF_parent_instructions;
                  body.emit(f0AFF);

                  /* END IF */

                  body.emit(assign(r0AD4, r0AFC, 0x01));

                  body.emit(assign(r0AD5, r0AFB, 0x01));

                  body.emit(assign(r0AD6, r0AFA, 0x01));


               body.instructions = f0AEE_parent_instructions;
               body.emit(f0AEE);

               /* END IF */

               body.emit(assign(r0AD3, sub(r0AD3, r0AD7), 0x01));

               ir_variable *const r0B12 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0B12, r0AD3, 0x01));

               ir_variable *const r0B13 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0B13, r0AD4, 0x01));

               ir_variable *const r0B14 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0B14, r0AD5, 0x01));

               ir_variable *const r0B15 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0B15, r0AD6, 0x01));

               ir_variable *const r0B16 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0B16, body.constant(true), 0x01));

               ir_variable *const r0B17 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0B18 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0B18);
               ir_expression *const r0B19 = expr(ir_unop_u2i, r0AD6);
               body.emit(assign(r0B18, less(r0B19, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0B1B = lequal(body.constant(int(2045)), r0AD3);
               ir_if *f0B1A = new(mem_ctx) ir_if(operand(r0B1B).val);
               exec_list *const f0B1A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B1A->then_instructions;

                  ir_variable *const r0B1C = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0B1E = less(body.constant(int(2045)), r0AD3);
                  ir_if *f0B1D = new(mem_ctx) ir_if(operand(r0B1E).val);
                  exec_list *const f0B1D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B1D->then_instructions;

                     body.emit(assign(r0B1C, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B1D->else_instructions;

                     ir_variable *const r0B1F = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B21 = equal(r0AD3, body.constant(int(2045)));
                     ir_if *f0B20 = new(mem_ctx) ir_if(operand(r0B21).val);
                     exec_list *const f0B20_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B20->then_instructions;

                        ir_expression *const r0B22 = equal(body.constant(2097151u), r0AD4);
                        ir_expression *const r0B23 = equal(body.constant(4294967295u), r0AD5);
                        body.emit(assign(r0B1F, logic_and(r0B22, r0B23), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B20->else_instructions;

                        body.emit(assign(r0B1F, body.constant(false), 0x01));


                     body.instructions = f0B20_parent_instructions;
                     body.emit(f0B20);

                     /* END IF */

                     body.emit(assign(r0B1C, logic_and(r0B1F, r0B18), 0x01));


                  body.instructions = f0B1D_parent_instructions;
                  body.emit(f0B1D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0B24 = new(mem_ctx) ir_if(operand(r0B1C).val);
                  exec_list *const f0B24_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B24->then_instructions;

                     ir_variable *const r0B25 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0B25);
                     ir_expression *const r0B26 = lshift(r0999, body.constant(int(31)));
                     body.emit(assign(r0B25, add(r0B26, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0B25, body.constant(0u), 0x01));

                     body.emit(assign(r0B17, r0B25, 0x03));

                     body.emit(assign(r0B16, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B24->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B28 = less(r0AD3, body.constant(int(0)));
                     ir_if *f0B27 = new(mem_ctx) ir_if(operand(r0B28).val);
                     exec_list *const f0B27_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B27->then_instructions;

                        ir_variable *const r0B29 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0B29, r0AD6, 0x01));

                        ir_variable *const r0B2A = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0B2A, neg(r0AD3), 0x01));

                        ir_variable *const r0B2B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0B2B);
                        ir_variable *const r0B2C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0B2C);
                        ir_variable *const r0B2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0B2D);
                        ir_variable *const r0B2E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0B2F = neg(r0B2A);
                        body.emit(assign(r0B2E, bit_and(r0B2F, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0B31 = equal(r0B2A, body.constant(int(0)));
                        ir_if *f0B30 = new(mem_ctx) ir_if(operand(r0B31).val);
                        exec_list *const f0B30_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0B30->then_instructions;

                           body.emit(assign(r0B2B, r0AD6, 0x01));

                           body.emit(assign(r0B2C, r0AD5, 0x01));

                           body.emit(assign(r0B2D, r0AD4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0B30->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0B33 = less(r0B2A, body.constant(int(32)));
                           ir_if *f0B32 = new(mem_ctx) ir_if(operand(r0B33).val);
                           exec_list *const f0B32_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B32->then_instructions;

                              body.emit(assign(r0B2B, lshift(r0AD5, r0B2E), 0x01));

                              ir_expression *const r0B34 = lshift(r0AD4, r0B2E);
                              ir_expression *const r0B35 = rshift(r0AD5, r0B2A);
                              body.emit(assign(r0B2C, bit_or(r0B34, r0B35), 0x01));

                              body.emit(assign(r0B2D, rshift(r0AD4, r0B2A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B32->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0B37 = equal(r0B2A, body.constant(int(32)));
                              ir_if *f0B36 = new(mem_ctx) ir_if(operand(r0B37).val);
                              exec_list *const f0B36_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B36->then_instructions;

                                 body.emit(assign(r0B2B, r0AD5, 0x01));

                                 body.emit(assign(r0B2C, r0AD4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B36->else_instructions;

                                 body.emit(assign(r0B29, bit_or(r0AD6, r0AD5), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0B39 = less(r0B2A, body.constant(int(64)));
                                 ir_if *f0B38 = new(mem_ctx) ir_if(operand(r0B39).val);
                                 exec_list *const f0B38_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0B38->then_instructions;

                                    body.emit(assign(r0B2B, lshift(r0AD4, r0B2E), 0x01));

                                    ir_expression *const r0B3A = bit_and(r0B2A, body.constant(int(31)));
                                    body.emit(assign(r0B2C, rshift(r0AD4, r0B3A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0B38->else_instructions;

                                    ir_variable *const r0B3B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0B3D = equal(r0B2A, body.constant(int(64)));
                                    ir_if *f0B3C = new(mem_ctx) ir_if(operand(r0B3D).val);
                                    exec_list *const f0B3C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0B3C->then_instructions;

                                       body.emit(assign(r0B3B, r0AD4, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0B3C->else_instructions;

                                       ir_expression *const r0B3E = nequal(r0AD4, body.constant(0u));
                                       ir_expression *const r0B3F = expr(ir_unop_b2i, r0B3E);
                                       body.emit(assign(r0B3B, expr(ir_unop_i2u, r0B3F), 0x01));


                                    body.instructions = f0B3C_parent_instructions;
                                    body.emit(f0B3C);

                                    /* END IF */

                                    body.emit(assign(r0B2B, r0B3B, 0x01));

                                    body.emit(assign(r0B2C, body.constant(0u), 0x01));


                                 body.instructions = f0B38_parent_instructions;
                                 body.emit(f0B38);

                                 /* END IF */


                              body.instructions = f0B36_parent_instructions;
                              body.emit(f0B36);

                              /* END IF */

                              body.emit(assign(r0B2D, body.constant(0u), 0x01));


                           body.instructions = f0B32_parent_instructions;
                           body.emit(f0B32);

                           /* END IF */

                           ir_expression *const r0B40 = nequal(r0B29, body.constant(0u));
                           ir_expression *const r0B41 = expr(ir_unop_b2i, r0B40);
                           ir_expression *const r0B42 = expr(ir_unop_i2u, r0B41);
                           body.emit(assign(r0B2B, bit_or(r0B2B, r0B42), 0x01));


                        body.instructions = f0B30_parent_instructions;
                        body.emit(f0B30);

                        /* END IF */

                        body.emit(assign(r0B13, r0B2D, 0x01));

                        body.emit(assign(r0B14, r0B2C, 0x01));

                        body.emit(assign(r0B15, r0B2B, 0x01));

                        body.emit(assign(r0B12, body.constant(int(0)), 0x01));

                        body.emit(assign(r0B18, less(r0B2B, body.constant(0u)), 0x01));


                     body.instructions = f0B27_parent_instructions;
                     body.emit(f0B27);

                     /* END IF */


                  body.instructions = f0B24_parent_instructions;
                  body.emit(f0B24);

                  /* END IF */


               body.instructions = f0B1A_parent_instructions;
               body.emit(f0B1A);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0B43 = new(mem_ctx) ir_if(operand(r0B16).val);
               exec_list *const f0B43_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B43->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0B44 = new(mem_ctx) ir_if(operand(r0B18).val);
                  exec_list *const f0B44_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B44->then_instructions;

                     ir_variable *const r0B45 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0B45, add(r0B14, body.constant(1u)), 0x01));

                     ir_expression *const r0B46 = less(r0B45, r0B14);
                     ir_expression *const r0B47 = expr(ir_unop_b2i, r0B46);
                     ir_expression *const r0B48 = expr(ir_unop_i2u, r0B47);
                     body.emit(assign(r0B13, add(r0B13, r0B48), 0x01));

                     ir_expression *const r0B49 = equal(r0B15, body.constant(0u));
                     ir_expression *const r0B4A = expr(ir_unop_b2i, r0B49);
                     ir_expression *const r0B4B = expr(ir_unop_i2u, r0B4A);
                     ir_expression *const r0B4C = add(r0B15, r0B4B);
                     ir_expression *const r0B4D = bit_and(r0B4C, body.constant(1u));
                     ir_expression *const r0B4E = expr(ir_unop_bit_not, r0B4D);
                     body.emit(assign(r0B14, bit_and(r0B45, r0B4E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B44->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B50 = bit_or(r0B13, r0B14);
                     ir_expression *const r0B51 = equal(r0B50, body.constant(0u));
                     ir_if *f0B4F = new(mem_ctx) ir_if(operand(r0B51).val);
                     exec_list *const f0B4F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B4F->then_instructions;

                        body.emit(assign(r0B12, body.constant(int(0)), 0x01));


                     body.instructions = f0B4F_parent_instructions;
                     body.emit(f0B4F);

                     /* END IF */


                  body.instructions = f0B44_parent_instructions;
                  body.emit(f0B44);

                  /* END IF */

                  ir_variable *const r0B52 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0B52);
                  ir_expression *const r0B53 = lshift(r0999, body.constant(int(31)));
                  ir_expression *const r0B54 = expr(ir_unop_i2u, r0B12);
                  ir_expression *const r0B55 = lshift(r0B54, body.constant(int(20)));
                  ir_expression *const r0B56 = add(r0B53, r0B55);
                  body.emit(assign(r0B52, add(r0B56, r0B13), 0x02));

                  body.emit(assign(r0B52, r0B14, 0x01));

                  body.emit(assign(r0B17, r0B52, 0x03));

                  body.emit(assign(r0B16, body.constant(false), 0x01));


               body.instructions = f0B43_parent_instructions;
               body.emit(f0B43);

               /* END IF */

               body.emit(assign(r099A, r0B17, 0x03));


            body.instructions = f0A85_parent_instructions;
            body.emit(f0A85);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0A83->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0B58 = equal(r09A3, body.constant(int(2047)));
            ir_if *f0B57 = new(mem_ctx) ir_if(operand(r0B58).val);
            exec_list *const f0B57_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0B57->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0B5A = bit_or(r09A0, r09A1);
               ir_expression *const r0B5B = bit_or(r099E, r099F);
               ir_expression *const r0B5C = bit_or(r0B5A, r0B5B);
               ir_expression *const r0B5D = nequal(r0B5C, body.constant(0u));
               ir_if *f0B59 = new(mem_ctx) ir_if(operand(r0B5D).val);
               exec_list *const f0B59_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B59->then_instructions;

                  ir_variable *const r0B5E = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0B5E, swizzle_x(r07E9), 0x01));

                  ir_variable *const r0B5F = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0B5F, swizzle_x(r07EA), 0x01));

                  ir_variable *const r0B60 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0B61 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0B62 = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0B63 = bit_and(r0B62, body.constant(4095u));
                  ir_expression *const r0B64 = equal(r0B63, body.constant(4094u));
                  ir_expression *const r0B65 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0B66 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0B67 = nequal(r0B66, body.constant(0u));
                  ir_expression *const r0B68 = logic_or(r0B65, r0B67);
                  body.emit(assign(r0B61, logic_and(r0B64, r0B68), 0x01));

                  ir_variable *const r0B69 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0B6A = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0B6B = lequal(body.constant(4292870144u), r0B6A);
                  ir_expression *const r0B6C = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0B6D = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0B6E = nequal(r0B6D, body.constant(0u));
                  ir_expression *const r0B6F = logic_or(r0B6C, r0B6E);
                  body.emit(assign(r0B69, logic_and(r0B6B, r0B6F), 0x01));

                  body.emit(assign(r0B5E, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r0B5F, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0B71 = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r0B72 = lequal(body.constant(4292870144u), r0B71);
                  ir_expression *const r0B73 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0B74 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0B75 = nequal(r0B74, body.constant(0u));
                  ir_expression *const r0B76 = logic_or(r0B73, r0B75);
                  ir_expression *const r0B77 = logic_and(r0B72, r0B76);
                  ir_if *f0B70 = new(mem_ctx) ir_if(operand(r0B77).val);
                  exec_list *const f0B70_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B70->then_instructions;

                     ir_variable *const r0B78 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B7A = logic_and(r0B61, r0B69);
                     ir_if *f0B79 = new(mem_ctx) ir_if(operand(r0B7A).val);
                     exec_list *const f0B79_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B79->then_instructions;

                        body.emit(assign(r0B78, r0B5F, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B79->else_instructions;

                        body.emit(assign(r0B78, r0B5E, 0x03));


                     body.instructions = f0B79_parent_instructions;
                     body.emit(f0B79);

                     /* END IF */

                     body.emit(assign(r0B60, r0B78, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B70->else_instructions;

                     body.emit(assign(r0B60, r0B5F, 0x03));


                  body.instructions = f0B70_parent_instructions;
                  body.emit(f0B70);

                  /* END IF */

                  body.emit(assign(r099A, r0B60, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B59->else_instructions;

                  ir_constant_data r0B7B_data;
                  memset(&r0B7B_data, 0, sizeof(ir_constant_data));
                  r0B7B_data.u[0] = 4294967295;
                  r0B7B_data.u[1] = 4294967295;
                  ir_constant *const r0B7B = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0B7B_data);
                  body.emit(assign(r099A, r0B7B, 0x03));


               body.instructions = f0B59_parent_instructions;
               body.emit(f0B59);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0B57->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0B7D = equal(r09A3, body.constant(int(0)));
               ir_if *f0B7C = new(mem_ctx) ir_if(operand(r0B7D).val);
               exec_list *const f0B7C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B7C->then_instructions;

                  body.emit(assign(r099D, body.constant(int(1)), 0x01));

                  body.emit(assign(r099C, body.constant(int(1)), 0x01));


               body.instructions = f0B7C_parent_instructions;
               body.emit(f0B7C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0B7F = less(r099E, r09A0);
               ir_if *f0B7E = new(mem_ctx) ir_if(operand(r0B7F).val);
               exec_list *const f0B7E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B7E->then_instructions;

                  ir_variable *const r0B80 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0B81 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0B81, sub(r09A1, r099F), 0x01));

                  ir_expression *const r0B82 = sub(r09A0, r099E);
                  ir_expression *const r0B83 = less(r09A1, r099F);
                  ir_expression *const r0B84 = expr(ir_unop_b2i, r0B83);
                  ir_expression *const r0B85 = expr(ir_unop_i2u, r0B84);
                  body.emit(assign(r0B80, sub(r0B82, r0B85), 0x01));

                  body.emit(assign(r09A2, add(r099D, body.constant(int(-1))), 0x01));

                  ir_variable *const r0B86 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0B86, add(r09A2, body.constant(int(-10))), 0x01));

                  ir_variable *const r0B87 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0B87, r0B80, 0x01));

                  ir_variable *const r0B88 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0B88, r0B81, 0x01));

                  ir_variable *const r0B89 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r0B89);
                  ir_variable *const r0B8A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B8A);
                  /* IF CONDITION */
                  ir_expression *const r0B8C = equal(r0B80, body.constant(0u));
                  ir_if *f0B8B = new(mem_ctx) ir_if(operand(r0B8C).val);
                  exec_list *const f0B8B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B8B->then_instructions;

                     body.emit(assign(r0B87, r0B81, 0x01));

                     body.emit(assign(r0B88, body.constant(0u), 0x01));

                     body.emit(assign(r0B86, add(r0B86, body.constant(int(-32))), 0x01));


                  body.instructions = f0B8B_parent_instructions;
                  body.emit(f0B8B);

                  /* END IF */

                  ir_variable *const r0B8D = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0B8D, r0B87, 0x01));

                  ir_variable *const r0B8E = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0B8F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B8F);
                  /* IF CONDITION */
                  ir_expression *const r0B91 = equal(r0B87, body.constant(0u));
                  ir_if *f0B90 = new(mem_ctx) ir_if(operand(r0B91).val);
                  exec_list *const f0B90_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B90->then_instructions;

                     body.emit(assign(r0B8E, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B90->else_instructions;

                     body.emit(assign(r0B8F, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0B93 = bit_and(r0B87, body.constant(4294901760u));
                     ir_expression *const r0B94 = equal(r0B93, body.constant(0u));
                     ir_if *f0B92 = new(mem_ctx) ir_if(operand(r0B94).val);
                     exec_list *const f0B92_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B92->then_instructions;

                        body.emit(assign(r0B8F, body.constant(int(16)), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B87, body.constant(int(16))), 0x01));


                     body.instructions = f0B92_parent_instructions;
                     body.emit(f0B92);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B96 = bit_and(r0B8D, body.constant(4278190080u));
                     ir_expression *const r0B97 = equal(r0B96, body.constant(0u));
                     ir_if *f0B95 = new(mem_ctx) ir_if(operand(r0B97).val);
                     exec_list *const f0B95_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B95->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(8))), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B8D, body.constant(int(8))), 0x01));


                     body.instructions = f0B95_parent_instructions;
                     body.emit(f0B95);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B99 = bit_and(r0B8D, body.constant(4026531840u));
                     ir_expression *const r0B9A = equal(r0B99, body.constant(0u));
                     ir_if *f0B98 = new(mem_ctx) ir_if(operand(r0B9A).val);
                     exec_list *const f0B98_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B98->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(4))), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B8D, body.constant(int(4))), 0x01));


                     body.instructions = f0B98_parent_instructions;
                     body.emit(f0B98);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B9C = bit_and(r0B8D, body.constant(3221225472u));
                     ir_expression *const r0B9D = equal(r0B9C, body.constant(0u));
                     ir_if *f0B9B = new(mem_ctx) ir_if(operand(r0B9D).val);
                     exec_list *const f0B9B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B9B->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(2))), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B8D, body.constant(int(2))), 0x01));


                     body.instructions = f0B9B_parent_instructions;
                     body.emit(f0B9B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B9F = bit_and(r0B8D, body.constant(2147483648u));
                     ir_expression *const r0BA0 = equal(r0B9F, body.constant(0u));
                     ir_if *f0B9E = new(mem_ctx) ir_if(operand(r0BA0).val);
                     exec_list *const f0B9E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B9E->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(1))), 0x01));


                     body.instructions = f0B9E_parent_instructions;
                     body.emit(f0B9E);

                     /* END IF */

                     body.emit(assign(r0B8E, r0B8F, 0x01));


                  body.instructions = f0B90_parent_instructions;
                  body.emit(f0B90);

                  /* END IF */

                  body.emit(assign(r0B8A, add(r0B8E, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0BA2 = lequal(body.constant(int(0)), r0B8A);
                  ir_if *f0BA1 = new(mem_ctx) ir_if(operand(r0BA2).val);
                  exec_list *const f0BA1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BA1->then_instructions;

                     body.emit(assign(r0B89, body.constant(0u), 0x01));

                     ir_variable *const r0BA3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0BA3, lshift(r0B88, r0B8A), 0x01));

                     ir_variable *const r0BA4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0BA6 = equal(r0B8A, body.constant(int(0)));
                     ir_if *f0BA5 = new(mem_ctx) ir_if(operand(r0BA6).val);
                     exec_list *const f0BA5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BA5->then_instructions;

                        body.emit(assign(r0BA4, r0B87, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BA5->else_instructions;

                        ir_expression *const r0BA7 = lshift(r0B87, r0B8A);
                        ir_expression *const r0BA8 = neg(r0B8A);
                        ir_expression *const r0BA9 = bit_and(r0BA8, body.constant(int(31)));
                        ir_expression *const r0BAA = rshift(r0B88, r0BA9);
                        body.emit(assign(r0BA4, bit_or(r0BA7, r0BAA), 0x01));


                     body.instructions = f0BA5_parent_instructions;
                     body.emit(f0BA5);

                     /* END IF */

                     body.emit(assign(r0B87, r0BA4, 0x01));

                     body.emit(assign(r0B88, r0BA3, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0BA1->else_instructions;

                     ir_variable *const r0BAB = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0BAB, body.constant(0u), 0x01));

                     ir_variable *const r0BAC = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0BAC, neg(r0B8A), 0x01));

                     ir_variable *const r0BAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0BAD);
                     ir_variable *const r0BAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0BAE);
                     ir_variable *const r0BAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0BAF);
                     ir_variable *const r0BB0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0BB1 = neg(r0BAC);
                     body.emit(assign(r0BB0, bit_and(r0BB1, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0BB3 = equal(r0BAC, body.constant(int(0)));
                     ir_if *f0BB2 = new(mem_ctx) ir_if(operand(r0BB3).val);
                     exec_list *const f0BB2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BB2->then_instructions;

                        body.emit(assign(r0BAD, r0BAB, 0x01));

                        body.emit(assign(r0BAE, r0B88, 0x01));

                        body.emit(assign(r0BAF, r0B87, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BB2->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BB5 = less(r0BAC, body.constant(int(32)));
                        ir_if *f0BB4 = new(mem_ctx) ir_if(operand(r0BB5).val);
                        exec_list *const f0BB4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BB4->then_instructions;

                           body.emit(assign(r0BAD, lshift(r0B88, r0BB0), 0x01));

                           ir_expression *const r0BB6 = lshift(r0B87, r0BB0);
                           ir_expression *const r0BB7 = rshift(r0B88, r0BAC);
                           body.emit(assign(r0BAE, bit_or(r0BB6, r0BB7), 0x01));

                           body.emit(assign(r0BAF, rshift(r0B87, r0BAC), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BB4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0BB9 = equal(r0BAC, body.constant(int(32)));
                           ir_if *f0BB8 = new(mem_ctx) ir_if(operand(r0BB9).val);
                           exec_list *const f0BB8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BB8->then_instructions;

                              body.emit(assign(r0BAD, r0B88, 0x01));

                              body.emit(assign(r0BAE, r0B87, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BB8->else_instructions;

                              body.emit(assign(r0BAB, bit_or(body.constant(0u), r0B88), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0BBB = less(r0BAC, body.constant(int(64)));
                              ir_if *f0BBA = new(mem_ctx) ir_if(operand(r0BBB).val);
                              exec_list *const f0BBA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BBA->then_instructions;

                                 body.emit(assign(r0BAD, lshift(r0B87, r0BB0), 0x01));

                                 ir_expression *const r0BBC = bit_and(r0BAC, body.constant(int(31)));
                                 body.emit(assign(r0BAE, rshift(r0B87, r0BBC), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BBA->else_instructions;

                                 ir_variable *const r0BBD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0BBF = equal(r0BAC, body.constant(int(64)));
                                 ir_if *f0BBE = new(mem_ctx) ir_if(operand(r0BBF).val);
                                 exec_list *const f0BBE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BBE->then_instructions;

                                    body.emit(assign(r0BBD, r0B87, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BBE->else_instructions;

                                    ir_expression *const r0BC0 = nequal(r0B87, body.constant(0u));
                                    ir_expression *const r0BC1 = expr(ir_unop_b2i, r0BC0);
                                    body.emit(assign(r0BBD, expr(ir_unop_i2u, r0BC1), 0x01));


                                 body.instructions = f0BBE_parent_instructions;
                                 body.emit(f0BBE);

                                 /* END IF */

                                 body.emit(assign(r0BAD, r0BBD, 0x01));

                                 body.emit(assign(r0BAE, body.constant(0u), 0x01));


                              body.instructions = f0BBA_parent_instructions;
                              body.emit(f0BBA);

                              /* END IF */


                           body.instructions = f0BB8_parent_instructions;
                           body.emit(f0BB8);

                           /* END IF */

                           body.emit(assign(r0BAF, body.constant(0u), 0x01));


                        body.instructions = f0BB4_parent_instructions;
                        body.emit(f0BB4);

                        /* END IF */

                        ir_expression *const r0BC2 = nequal(r0BAB, body.constant(0u));
                        ir_expression *const r0BC3 = expr(ir_unop_b2i, r0BC2);
                        ir_expression *const r0BC4 = expr(ir_unop_i2u, r0BC3);
                        body.emit(assign(r0BAD, bit_or(r0BAD, r0BC4), 0x01));


                     body.instructions = f0BB2_parent_instructions;
                     body.emit(f0BB2);

                     /* END IF */

                     body.emit(assign(r0B87, r0BAF, 0x01));

                     body.emit(assign(r0B88, r0BAE, 0x01));

                     body.emit(assign(r0B89, r0BAD, 0x01));


                  body.instructions = f0BA1_parent_instructions;
                  body.emit(f0BA1);

                  /* END IF */

                  body.emit(assign(r0B86, sub(r0B86, r0B8A), 0x01));

                  ir_variable *const r0BC5 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0BC5, r0B86, 0x01));

                  ir_variable *const r0BC6 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0BC6, r0B87, 0x01));

                  ir_variable *const r0BC7 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0BC7, r0B88, 0x01));

                  ir_variable *const r0BC8 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r0BC8, r0B89, 0x01));

                  ir_variable *const r0BC9 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r0BC9, body.constant(true), 0x01));

                  ir_variable *const r0BCA = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0BCB = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0BCB);
                  ir_expression *const r0BCC = expr(ir_unop_u2i, r0B89);
                  body.emit(assign(r0BCB, less(r0BCC, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0BCE = lequal(body.constant(int(2045)), r0B86);
                  ir_if *f0BCD = new(mem_ctx) ir_if(operand(r0BCE).val);
                  exec_list *const f0BCD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BCD->then_instructions;

                     ir_variable *const r0BCF = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0BD1 = less(body.constant(int(2045)), r0B86);
                     ir_if *f0BD0 = new(mem_ctx) ir_if(operand(r0BD1).val);
                     exec_list *const f0BD0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BD0->then_instructions;

                        body.emit(assign(r0BCF, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BD0->else_instructions;

                        ir_variable *const r0BD2 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0BD4 = equal(r0B86, body.constant(int(2045)));
                        ir_if *f0BD3 = new(mem_ctx) ir_if(operand(r0BD4).val);
                        exec_list *const f0BD3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BD3->then_instructions;

                           ir_expression *const r0BD5 = equal(body.constant(2097151u), r0B87);
                           ir_expression *const r0BD6 = equal(body.constant(4294967295u), r0B88);
                           body.emit(assign(r0BD2, logic_and(r0BD5, r0BD6), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BD3->else_instructions;

                           body.emit(assign(r0BD2, body.constant(false), 0x01));


                        body.instructions = f0BD3_parent_instructions;
                        body.emit(f0BD3);

                        /* END IF */

                        body.emit(assign(r0BCF, logic_and(r0BD2, r0BCB), 0x01));


                     body.instructions = f0BD0_parent_instructions;
                     body.emit(f0BD0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0BD7 = new(mem_ctx) ir_if(operand(r0BCF).val);
                     exec_list *const f0BD7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BD7->then_instructions;

                        ir_variable *const r0BD8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0BD8);
                        ir_expression *const r0BD9 = lshift(r0999, body.constant(int(31)));
                        body.emit(assign(r0BD8, add(r0BD9, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r0BD8, body.constant(0u), 0x01));

                        body.emit(assign(r0BCA, r0BD8, 0x03));

                        body.emit(assign(r0BC9, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BD7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BDB = less(r0B86, body.constant(int(0)));
                        ir_if *f0BDA = new(mem_ctx) ir_if(operand(r0BDB).val);
                        exec_list *const f0BDA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BDA->then_instructions;

                           ir_variable *const r0BDC = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0BDC, r0B89, 0x01));

                           ir_variable *const r0BDD = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0BDD, neg(r0B86), 0x01));

                           ir_variable *const r0BDE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0BDE);
                           ir_variable *const r0BDF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0BDF);
                           ir_variable *const r0BE0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0BE0);
                           ir_variable *const r0BE1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0BE2 = neg(r0BDD);
                           body.emit(assign(r0BE1, bit_and(r0BE2, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0BE4 = equal(r0BDD, body.constant(int(0)));
                           ir_if *f0BE3 = new(mem_ctx) ir_if(operand(r0BE4).val);
                           exec_list *const f0BE3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BE3->then_instructions;

                              body.emit(assign(r0BDE, r0B89, 0x01));

                              body.emit(assign(r0BDF, r0B88, 0x01));

                              body.emit(assign(r0BE0, r0B87, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BE3->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0BE6 = less(r0BDD, body.constant(int(32)));
                              ir_if *f0BE5 = new(mem_ctx) ir_if(operand(r0BE6).val);
                              exec_list *const f0BE5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BE5->then_instructions;

                                 body.emit(assign(r0BDE, lshift(r0B88, r0BE1), 0x01));

                                 ir_expression *const r0BE7 = lshift(r0B87, r0BE1);
                                 ir_expression *const r0BE8 = rshift(r0B88, r0BDD);
                                 body.emit(assign(r0BDF, bit_or(r0BE7, r0BE8), 0x01));

                                 body.emit(assign(r0BE0, rshift(r0B87, r0BDD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BE5->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0BEA = equal(r0BDD, body.constant(int(32)));
                                 ir_if *f0BE9 = new(mem_ctx) ir_if(operand(r0BEA).val);
                                 exec_list *const f0BE9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BE9->then_instructions;

                                    body.emit(assign(r0BDE, r0B88, 0x01));

                                    body.emit(assign(r0BDF, r0B87, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BE9->else_instructions;

                                    body.emit(assign(r0BDC, bit_or(r0B89, r0B88), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0BEC = less(r0BDD, body.constant(int(64)));
                                    ir_if *f0BEB = new(mem_ctx) ir_if(operand(r0BEC).val);
                                    exec_list *const f0BEB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0BEB->then_instructions;

                                       body.emit(assign(r0BDE, lshift(r0B87, r0BE1), 0x01));

                                       ir_expression *const r0BED = bit_and(r0BDD, body.constant(int(31)));
                                       body.emit(assign(r0BDF, rshift(r0B87, r0BED), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0BEB->else_instructions;

                                       ir_variable *const r0BEE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0BF0 = equal(r0BDD, body.constant(int(64)));
                                       ir_if *f0BEF = new(mem_ctx) ir_if(operand(r0BF0).val);
                                       exec_list *const f0BEF_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0BEF->then_instructions;

                                          body.emit(assign(r0BEE, r0B87, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0BEF->else_instructions;

                                          ir_expression *const r0BF1 = nequal(r0B87, body.constant(0u));
                                          ir_expression *const r0BF2 = expr(ir_unop_b2i, r0BF1);
                                          body.emit(assign(r0BEE, expr(ir_unop_i2u, r0BF2), 0x01));


                                       body.instructions = f0BEF_parent_instructions;
                                       body.emit(f0BEF);

                                       /* END IF */

                                       body.emit(assign(r0BDE, r0BEE, 0x01));

                                       body.emit(assign(r0BDF, body.constant(0u), 0x01));


                                    body.instructions = f0BEB_parent_instructions;
                                    body.emit(f0BEB);

                                    /* END IF */


                                 body.instructions = f0BE9_parent_instructions;
                                 body.emit(f0BE9);

                                 /* END IF */

                                 body.emit(assign(r0BE0, body.constant(0u), 0x01));


                              body.instructions = f0BE5_parent_instructions;
                              body.emit(f0BE5);

                              /* END IF */

                              ir_expression *const r0BF3 = nequal(r0BDC, body.constant(0u));
                              ir_expression *const r0BF4 = expr(ir_unop_b2i, r0BF3);
                              ir_expression *const r0BF5 = expr(ir_unop_i2u, r0BF4);
                              body.emit(assign(r0BDE, bit_or(r0BDE, r0BF5), 0x01));


                           body.instructions = f0BE3_parent_instructions;
                           body.emit(f0BE3);

                           /* END IF */

                           body.emit(assign(r0BC6, r0BE0, 0x01));

                           body.emit(assign(r0BC7, r0BDF, 0x01));

                           body.emit(assign(r0BC8, r0BDE, 0x01));

                           body.emit(assign(r0BC5, body.constant(int(0)), 0x01));

                           body.emit(assign(r0BCB, less(r0BDE, body.constant(0u)), 0x01));


                        body.instructions = f0BDA_parent_instructions;
                        body.emit(f0BDA);

                        /* END IF */


                     body.instructions = f0BD7_parent_instructions;
                     body.emit(f0BD7);

                     /* END IF */


                  body.instructions = f0BCD_parent_instructions;
                  body.emit(f0BCD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0BF6 = new(mem_ctx) ir_if(operand(r0BC9).val);
                  exec_list *const f0BF6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BF6->then_instructions;

                     /* IF CONDITION */
                     ir_if *f0BF7 = new(mem_ctx) ir_if(operand(r0BCB).val);
                     exec_list *const f0BF7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BF7->then_instructions;

                        ir_variable *const r0BF8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r0BF8, add(r0BC7, body.constant(1u)), 0x01));

                        ir_expression *const r0BF9 = less(r0BF8, r0BC7);
                        ir_expression *const r0BFA = expr(ir_unop_b2i, r0BF9);
                        ir_expression *const r0BFB = expr(ir_unop_i2u, r0BFA);
                        body.emit(assign(r0BC6, add(r0BC6, r0BFB), 0x01));

                        ir_expression *const r0BFC = equal(r0BC8, body.constant(0u));
                        ir_expression *const r0BFD = expr(ir_unop_b2i, r0BFC);
                        ir_expression *const r0BFE = expr(ir_unop_i2u, r0BFD);
                        ir_expression *const r0BFF = add(r0BC8, r0BFE);
                        ir_expression *const r0C00 = bit_and(r0BFF, body.constant(1u));
                        ir_expression *const r0C01 = expr(ir_unop_bit_not, r0C00);
                        body.emit(assign(r0BC7, bit_and(r0BF8, r0C01), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BF7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0C03 = bit_or(r0BC6, r0BC7);
                        ir_expression *const r0C04 = equal(r0C03, body.constant(0u));
                        ir_if *f0C02 = new(mem_ctx) ir_if(operand(r0C04).val);
                        exec_list *const f0C02_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C02->then_instructions;

                           body.emit(assign(r0BC5, body.constant(int(0)), 0x01));


                        body.instructions = f0C02_parent_instructions;
                        body.emit(f0C02);

                        /* END IF */


                     body.instructions = f0BF7_parent_instructions;
                     body.emit(f0BF7);

                     /* END IF */

                     ir_variable *const r0C05 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0C05);
                     ir_expression *const r0C06 = lshift(r0999, body.constant(int(31)));
                     ir_expression *const r0C07 = expr(ir_unop_i2u, r0BC5);
                     ir_expression *const r0C08 = lshift(r0C07, body.constant(int(20)));
                     ir_expression *const r0C09 = add(r0C06, r0C08);
                     body.emit(assign(r0C05, add(r0C09, r0BC6), 0x02));

                     body.emit(assign(r0C05, r0BC7, 0x01));

                     body.emit(assign(r0BCA, r0C05, 0x03));

                     body.emit(assign(r0BC9, body.constant(false), 0x01));


                  body.instructions = f0BF6_parent_instructions;
                  body.emit(f0BF6);

                  /* END IF */

                  body.emit(assign(r099A, r0BCA, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B7E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0C0B = less(r09A0, r099E);
                  ir_if *f0C0A = new(mem_ctx) ir_if(operand(r0C0B).val);
                  exec_list *const f0C0A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0C0A->then_instructions;

                     ir_variable *const r0C0C = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r0C0D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0C0D, sub(r099F, r09A1), 0x01));

                     ir_expression *const r0C0E = sub(r099E, r09A0);
                     ir_expression *const r0C0F = less(r099F, r09A1);
                     ir_expression *const r0C10 = expr(ir_unop_b2i, r0C0F);
                     ir_expression *const r0C11 = expr(ir_unop_i2u, r0C10);
                     body.emit(assign(r0C0C, sub(r0C0E, r0C11), 0x01));

                     body.emit(assign(r0999, bit_xor(r0999, body.constant(1u)), 0x01));

                     body.emit(assign(r09A2, add(r099C, body.constant(int(-1))), 0x01));

                     ir_variable *const r0C12 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C12, add(r09A2, body.constant(int(-10))), 0x01));

                     ir_variable *const r0C13 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C13, r0C0C, 0x01));

                     ir_variable *const r0C14 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C14, r0C0D, 0x01));

                     ir_variable *const r0C15 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r0C15);
                     ir_variable *const r0C16 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C16);
                     /* IF CONDITION */
                     ir_expression *const r0C18 = equal(r0C0C, body.constant(0u));
                     ir_if *f0C17 = new(mem_ctx) ir_if(operand(r0C18).val);
                     exec_list *const f0C17_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C17->then_instructions;

                        body.emit(assign(r0C13, r0C0D, 0x01));

                        body.emit(assign(r0C14, body.constant(0u), 0x01));

                        body.emit(assign(r0C12, add(r0C12, body.constant(int(-32))), 0x01));


                     body.instructions = f0C17_parent_instructions;
                     body.emit(f0C17);

                     /* END IF */

                     ir_variable *const r0C19 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r0C19, r0C13, 0x01));

                     ir_variable *const r0C1A = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r0C1B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C1B);
                     /* IF CONDITION */
                     ir_expression *const r0C1D = equal(r0C13, body.constant(0u));
                     ir_if *f0C1C = new(mem_ctx) ir_if(operand(r0C1D).val);
                     exec_list *const f0C1C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C1C->then_instructions;

                        body.emit(assign(r0C1A, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C1C->else_instructions;

                        body.emit(assign(r0C1B, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C1F = bit_and(r0C13, body.constant(4294901760u));
                        ir_expression *const r0C20 = equal(r0C1F, body.constant(0u));
                        ir_if *f0C1E = new(mem_ctx) ir_if(operand(r0C20).val);
                        exec_list *const f0C1E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C1E->then_instructions;

                           body.emit(assign(r0C1B, body.constant(int(16)), 0x01));

                           body.emit(assign(r0C19, lshift(r0C13, body.constant(int(16))), 0x01));


                        body.instructions = f0C1E_parent_instructions;
                        body.emit(f0C1E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C22 = bit_and(r0C19, body.constant(4278190080u));
                        ir_expression *const r0C23 = equal(r0C22, body.constant(0u));
                        ir_if *f0C21 = new(mem_ctx) ir_if(operand(r0C23).val);
                        exec_list *const f0C21_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C21->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(8))), 0x01));

                           body.emit(assign(r0C19, lshift(r0C19, body.constant(int(8))), 0x01));


                        body.instructions = f0C21_parent_instructions;
                        body.emit(f0C21);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C25 = bit_and(r0C19, body.constant(4026531840u));
                        ir_expression *const r0C26 = equal(r0C25, body.constant(0u));
                        ir_if *f0C24 = new(mem_ctx) ir_if(operand(r0C26).val);
                        exec_list *const f0C24_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C24->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(4))), 0x01));

                           body.emit(assign(r0C19, lshift(r0C19, body.constant(int(4))), 0x01));


                        body.instructions = f0C24_parent_instructions;
                        body.emit(f0C24);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C28 = bit_and(r0C19, body.constant(3221225472u));
                        ir_expression *const r0C29 = equal(r0C28, body.constant(0u));
                        ir_if *f0C27 = new(mem_ctx) ir_if(operand(r0C29).val);
                        exec_list *const f0C27_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C27->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(2))), 0x01));

                           body.emit(assign(r0C19, lshift(r0C19, body.constant(int(2))), 0x01));


                        body.instructions = f0C27_parent_instructions;
                        body.emit(f0C27);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C2B = bit_and(r0C19, body.constant(2147483648u));
                        ir_expression *const r0C2C = equal(r0C2B, body.constant(0u));
                        ir_if *f0C2A = new(mem_ctx) ir_if(operand(r0C2C).val);
                        exec_list *const f0C2A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C2A->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(1))), 0x01));


                        body.instructions = f0C2A_parent_instructions;
                        body.emit(f0C2A);

                        /* END IF */

                        body.emit(assign(r0C1A, r0C1B, 0x01));


                     body.instructions = f0C1C_parent_instructions;
                     body.emit(f0C1C);

                     /* END IF */

                     body.emit(assign(r0C16, add(r0C1A, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C2E = lequal(body.constant(int(0)), r0C16);
                     ir_if *f0C2D = new(mem_ctx) ir_if(operand(r0C2E).val);
                     exec_list *const f0C2D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C2D->then_instructions;

                        body.emit(assign(r0C15, body.constant(0u), 0x01));

                        ir_variable *const r0C2F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C2F, lshift(r0C14, r0C16), 0x01));

                        ir_variable *const r0C30 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C32 = equal(r0C16, body.constant(int(0)));
                        ir_if *f0C31 = new(mem_ctx) ir_if(operand(r0C32).val);
                        exec_list *const f0C31_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C31->then_instructions;

                           body.emit(assign(r0C30, r0C13, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C31->else_instructions;

                           ir_expression *const r0C33 = lshift(r0C13, r0C16);
                           ir_expression *const r0C34 = neg(r0C16);
                           ir_expression *const r0C35 = bit_and(r0C34, body.constant(int(31)));
                           ir_expression *const r0C36 = rshift(r0C14, r0C35);
                           body.emit(assign(r0C30, bit_or(r0C33, r0C36), 0x01));


                        body.instructions = f0C31_parent_instructions;
                        body.emit(f0C31);

                        /* END IF */

                        body.emit(assign(r0C13, r0C30, 0x01));

                        body.emit(assign(r0C14, r0C2F, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C2D->else_instructions;

                        ir_variable *const r0C37 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0C37, body.constant(0u), 0x01));

                        ir_variable *const r0C38 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0C38, neg(r0C16), 0x01));

                        ir_variable *const r0C39 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0C39);
                        ir_variable *const r0C3A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0C3A);
                        ir_variable *const r0C3B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0C3B);
                        ir_variable *const r0C3C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0C3D = neg(r0C38);
                        body.emit(assign(r0C3C, bit_and(r0C3D, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C3F = equal(r0C38, body.constant(int(0)));
                        ir_if *f0C3E = new(mem_ctx) ir_if(operand(r0C3F).val);
                        exec_list *const f0C3E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C3E->then_instructions;

                           body.emit(assign(r0C39, r0C37, 0x01));

                           body.emit(assign(r0C3A, r0C14, 0x01));

                           body.emit(assign(r0C3B, r0C13, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C3E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C41 = less(r0C38, body.constant(int(32)));
                           ir_if *f0C40 = new(mem_ctx) ir_if(operand(r0C41).val);
                           exec_list *const f0C40_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C40->then_instructions;

                              body.emit(assign(r0C39, lshift(r0C14, r0C3C), 0x01));

                              ir_expression *const r0C42 = lshift(r0C13, r0C3C);
                              ir_expression *const r0C43 = rshift(r0C14, r0C38);
                              body.emit(assign(r0C3A, bit_or(r0C42, r0C43), 0x01));

                              body.emit(assign(r0C3B, rshift(r0C13, r0C38), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C40->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0C45 = equal(r0C38, body.constant(int(32)));
                              ir_if *f0C44 = new(mem_ctx) ir_if(operand(r0C45).val);
                              exec_list *const f0C44_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C44->then_instructions;

                                 body.emit(assign(r0C39, r0C14, 0x01));

                                 body.emit(assign(r0C3A, r0C13, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C44->else_instructions;

                                 body.emit(assign(r0C37, bit_or(body.constant(0u), r0C14), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0C47 = less(r0C38, body.constant(int(64)));
                                 ir_if *f0C46 = new(mem_ctx) ir_if(operand(r0C47).val);
                                 exec_list *const f0C46_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C46->then_instructions;

                                    body.emit(assign(r0C39, lshift(r0C13, r0C3C), 0x01));

                                    ir_expression *const r0C48 = bit_and(r0C38, body.constant(int(31)));
                                    body.emit(assign(r0C3A, rshift(r0C13, r0C48), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C46->else_instructions;

                                    ir_variable *const r0C49 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0C4B = equal(r0C38, body.constant(int(64)));
                                    ir_if *f0C4A = new(mem_ctx) ir_if(operand(r0C4B).val);
                                    exec_list *const f0C4A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C4A->then_instructions;

                                       body.emit(assign(r0C49, r0C13, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C4A->else_instructions;

                                       ir_expression *const r0C4C = nequal(r0C13, body.constant(0u));
                                       ir_expression *const r0C4D = expr(ir_unop_b2i, r0C4C);
                                       body.emit(assign(r0C49, expr(ir_unop_i2u, r0C4D), 0x01));


                                    body.instructions = f0C4A_parent_instructions;
                                    body.emit(f0C4A);

                                    /* END IF */

                                    body.emit(assign(r0C39, r0C49, 0x01));

                                    body.emit(assign(r0C3A, body.constant(0u), 0x01));


                                 body.instructions = f0C46_parent_instructions;
                                 body.emit(f0C46);

                                 /* END IF */


                              body.instructions = f0C44_parent_instructions;
                              body.emit(f0C44);

                              /* END IF */

                              body.emit(assign(r0C3B, body.constant(0u), 0x01));


                           body.instructions = f0C40_parent_instructions;
                           body.emit(f0C40);

                           /* END IF */

                           ir_expression *const r0C4E = nequal(r0C37, body.constant(0u));
                           ir_expression *const r0C4F = expr(ir_unop_b2i, r0C4E);
                           ir_expression *const r0C50 = expr(ir_unop_i2u, r0C4F);
                           body.emit(assign(r0C39, bit_or(r0C39, r0C50), 0x01));


                        body.instructions = f0C3E_parent_instructions;
                        body.emit(f0C3E);

                        /* END IF */

                        body.emit(assign(r0C13, r0C3B, 0x01));

                        body.emit(assign(r0C14, r0C3A, 0x01));

                        body.emit(assign(r0C15, r0C39, 0x01));


                     body.instructions = f0C2D_parent_instructions;
                     body.emit(f0C2D);

                     /* END IF */

                     body.emit(assign(r0C12, sub(r0C12, r0C16), 0x01));

                     ir_variable *const r0C51 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C51, r0C12, 0x01));

                     ir_variable *const r0C52 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C52, r0C13, 0x01));

                     ir_variable *const r0C53 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C53, r0C14, 0x01));

                     ir_variable *const r0C54 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r0C54, r0C15, 0x01));

                     ir_variable *const r0C55 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r0C55, body.constant(true), 0x01));

                     ir_variable *const r0C56 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r0C57 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r0C57);
                     ir_expression *const r0C58 = expr(ir_unop_u2i, r0C15);
                     body.emit(assign(r0C57, less(r0C58, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C5A = lequal(body.constant(int(2045)), r0C12);
                     ir_if *f0C59 = new(mem_ctx) ir_if(operand(r0C5A).val);
                     exec_list *const f0C59_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C59->then_instructions;

                        ir_variable *const r0C5B = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C5D = less(body.constant(int(2045)), r0C12);
                        ir_if *f0C5C = new(mem_ctx) ir_if(operand(r0C5D).val);
                        exec_list *const f0C5C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C5C->then_instructions;

                           body.emit(assign(r0C5B, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C5C->else_instructions;

                           ir_variable *const r0C5E = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0C60 = equal(r0C12, body.constant(int(2045)));
                           ir_if *f0C5F = new(mem_ctx) ir_if(operand(r0C60).val);
                           exec_list *const f0C5F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C5F->then_instructions;

                              ir_expression *const r0C61 = equal(body.constant(2097151u), r0C13);
                              ir_expression *const r0C62 = equal(body.constant(4294967295u), r0C14);
                              body.emit(assign(r0C5E, logic_and(r0C61, r0C62), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C5F->else_instructions;

                              body.emit(assign(r0C5E, body.constant(false), 0x01));


                           body.instructions = f0C5F_parent_instructions;
                           body.emit(f0C5F);

                           /* END IF */

                           body.emit(assign(r0C5B, logic_and(r0C5E, r0C57), 0x01));


                        body.instructions = f0C5C_parent_instructions;
                        body.emit(f0C5C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0C63 = new(mem_ctx) ir_if(operand(r0C5B).val);
                        exec_list *const f0C63_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C63->then_instructions;

                           ir_variable *const r0C64 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0C64);
                           ir_expression *const r0C65 = lshift(r0999, body.constant(int(31)));
                           body.emit(assign(r0C64, add(r0C65, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r0C64, body.constant(0u), 0x01));

                           body.emit(assign(r0C56, r0C64, 0x03));

                           body.emit(assign(r0C55, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C63->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C67 = less(r0C12, body.constant(int(0)));
                           ir_if *f0C66 = new(mem_ctx) ir_if(operand(r0C67).val);
                           exec_list *const f0C66_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C66->then_instructions;

                              ir_variable *const r0C68 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0C68, r0C15, 0x01));

                              ir_variable *const r0C69 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0C69, neg(r0C12), 0x01));

                              ir_variable *const r0C6A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0C6A);
                              ir_variable *const r0C6B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0C6B);
                              ir_variable *const r0C6C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0C6C);
                              ir_variable *const r0C6D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0C6E = neg(r0C69);
                              body.emit(assign(r0C6D, bit_and(r0C6E, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0C70 = equal(r0C69, body.constant(int(0)));
                              ir_if *f0C6F = new(mem_ctx) ir_if(operand(r0C70).val);
                              exec_list *const f0C6F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C6F->then_instructions;

                                 body.emit(assign(r0C6A, r0C15, 0x01));

                                 body.emit(assign(r0C6B, r0C14, 0x01));

                                 body.emit(assign(r0C6C, r0C13, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C6F->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0C72 = less(r0C69, body.constant(int(32)));
                                 ir_if *f0C71 = new(mem_ctx) ir_if(operand(r0C72).val);
                                 exec_list *const f0C71_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C71->then_instructions;

                                    body.emit(assign(r0C6A, lshift(r0C14, r0C6D), 0x01));

                                    ir_expression *const r0C73 = lshift(r0C13, r0C6D);
                                    ir_expression *const r0C74 = rshift(r0C14, r0C69);
                                    body.emit(assign(r0C6B, bit_or(r0C73, r0C74), 0x01));

                                    body.emit(assign(r0C6C, rshift(r0C13, r0C69), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C71->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0C76 = equal(r0C69, body.constant(int(32)));
                                    ir_if *f0C75 = new(mem_ctx) ir_if(operand(r0C76).val);
                                    exec_list *const f0C75_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C75->then_instructions;

                                       body.emit(assign(r0C6A, r0C14, 0x01));

                                       body.emit(assign(r0C6B, r0C13, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C75->else_instructions;

                                       body.emit(assign(r0C68, bit_or(r0C15, r0C14), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0C78 = less(r0C69, body.constant(int(64)));
                                       ir_if *f0C77 = new(mem_ctx) ir_if(operand(r0C78).val);
                                       exec_list *const f0C77_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0C77->then_instructions;

                                          body.emit(assign(r0C6A, lshift(r0C13, r0C6D), 0x01));

                                          ir_expression *const r0C79 = bit_and(r0C69, body.constant(int(31)));
                                          body.emit(assign(r0C6B, rshift(r0C13, r0C79), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0C77->else_instructions;

                                          ir_variable *const r0C7A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0C7C = equal(r0C69, body.constant(int(64)));
                                          ir_if *f0C7B = new(mem_ctx) ir_if(operand(r0C7C).val);
                                          exec_list *const f0C7B_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0C7B->then_instructions;

                                             body.emit(assign(r0C7A, r0C13, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0C7B->else_instructions;

                                             ir_expression *const r0C7D = nequal(r0C13, body.constant(0u));
                                             ir_expression *const r0C7E = expr(ir_unop_b2i, r0C7D);
                                             body.emit(assign(r0C7A, expr(ir_unop_i2u, r0C7E), 0x01));


                                          body.instructions = f0C7B_parent_instructions;
                                          body.emit(f0C7B);

                                          /* END IF */

                                          body.emit(assign(r0C6A, r0C7A, 0x01));

                                          body.emit(assign(r0C6B, body.constant(0u), 0x01));


                                       body.instructions = f0C77_parent_instructions;
                                       body.emit(f0C77);

                                       /* END IF */


                                    body.instructions = f0C75_parent_instructions;
                                    body.emit(f0C75);

                                    /* END IF */

                                    body.emit(assign(r0C6C, body.constant(0u), 0x01));


                                 body.instructions = f0C71_parent_instructions;
                                 body.emit(f0C71);

                                 /* END IF */

                                 ir_expression *const r0C7F = nequal(r0C68, body.constant(0u));
                                 ir_expression *const r0C80 = expr(ir_unop_b2i, r0C7F);
                                 ir_expression *const r0C81 = expr(ir_unop_i2u, r0C80);
                                 body.emit(assign(r0C6A, bit_or(r0C6A, r0C81), 0x01));


                              body.instructions = f0C6F_parent_instructions;
                              body.emit(f0C6F);

                              /* END IF */

                              body.emit(assign(r0C52, r0C6C, 0x01));

                              body.emit(assign(r0C53, r0C6B, 0x01));

                              body.emit(assign(r0C54, r0C6A, 0x01));

                              body.emit(assign(r0C51, body.constant(int(0)), 0x01));

                              body.emit(assign(r0C57, less(r0C6A, body.constant(0u)), 0x01));


                           body.instructions = f0C66_parent_instructions;
                           body.emit(f0C66);

                           /* END IF */


                        body.instructions = f0C63_parent_instructions;
                        body.emit(f0C63);

                        /* END IF */


                     body.instructions = f0C59_parent_instructions;
                     body.emit(f0C59);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0C82 = new(mem_ctx) ir_if(operand(r0C55).val);
                     exec_list *const f0C82_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C82->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0C83 = new(mem_ctx) ir_if(operand(r0C57).val);
                        exec_list *const f0C83_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C83->then_instructions;

                           ir_variable *const r0C84 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r0C84, add(r0C53, body.constant(1u)), 0x01));

                           ir_expression *const r0C85 = less(r0C84, r0C53);
                           ir_expression *const r0C86 = expr(ir_unop_b2i, r0C85);
                           ir_expression *const r0C87 = expr(ir_unop_i2u, r0C86);
                           body.emit(assign(r0C52, add(r0C52, r0C87), 0x01));

                           ir_expression *const r0C88 = equal(r0C54, body.constant(0u));
                           ir_expression *const r0C89 = expr(ir_unop_b2i, r0C88);
                           ir_expression *const r0C8A = expr(ir_unop_i2u, r0C89);
                           ir_expression *const r0C8B = add(r0C54, r0C8A);
                           ir_expression *const r0C8C = bit_and(r0C8B, body.constant(1u));
                           ir_expression *const r0C8D = expr(ir_unop_bit_not, r0C8C);
                           body.emit(assign(r0C53, bit_and(r0C84, r0C8D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C83->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C8F = bit_or(r0C52, r0C53);
                           ir_expression *const r0C90 = equal(r0C8F, body.constant(0u));
                           ir_if *f0C8E = new(mem_ctx) ir_if(operand(r0C90).val);
                           exec_list *const f0C8E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C8E->then_instructions;

                              body.emit(assign(r0C51, body.constant(int(0)), 0x01));


                           body.instructions = f0C8E_parent_instructions;
                           body.emit(f0C8E);

                           /* END IF */


                        body.instructions = f0C83_parent_instructions;
                        body.emit(f0C83);

                        /* END IF */

                        ir_variable *const r0C91 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0C91);
                        ir_expression *const r0C92 = lshift(r0999, body.constant(int(31)));
                        ir_expression *const r0C93 = expr(ir_unop_i2u, r0C51);
                        ir_expression *const r0C94 = lshift(r0C93, body.constant(int(20)));
                        ir_expression *const r0C95 = add(r0C92, r0C94);
                        body.emit(assign(r0C91, add(r0C95, r0C52), 0x02));

                        body.emit(assign(r0C91, r0C53, 0x01));

                        body.emit(assign(r0C56, r0C91, 0x03));

                        body.emit(assign(r0C55, body.constant(false), 0x01));


                     body.instructions = f0C82_parent_instructions;
                     body.emit(f0C82);

                     /* END IF */

                     body.emit(assign(r099A, r0C56, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0C0A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0C97 = less(r099F, r09A1);
                     ir_if *f0C96 = new(mem_ctx) ir_if(operand(r0C97).val);
                     exec_list *const f0C96_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C96->then_instructions;

                        ir_variable *const r0C98 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r0C99 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C99, sub(r09A1, r099F), 0x01));

                        ir_expression *const r0C9A = sub(r09A0, r099E);
                        ir_expression *const r0C9B = less(r09A1, r099F);
                        ir_expression *const r0C9C = expr(ir_unop_b2i, r0C9B);
                        ir_expression *const r0C9D = expr(ir_unop_i2u, r0C9C);
                        body.emit(assign(r0C98, sub(r0C9A, r0C9D), 0x01));

                        body.emit(assign(r09A2, add(r099D, body.constant(int(-1))), 0x01));

                        ir_variable *const r0C9E = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0C9E, add(r09A2, body.constant(int(-10))), 0x01));

                        ir_variable *const r0C9F = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0C9F, r0C98, 0x01));

                        ir_variable *const r0CA0 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0CA0, r0C99, 0x01));

                        ir_variable *const r0CA1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0CA1);
                        ir_variable *const r0CA2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0CA2);
                        /* IF CONDITION */
                        ir_expression *const r0CA4 = equal(r0C98, body.constant(0u));
                        ir_if *f0CA3 = new(mem_ctx) ir_if(operand(r0CA4).val);
                        exec_list *const f0CA3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CA3->then_instructions;

                           body.emit(assign(r0C9F, r0C99, 0x01));

                           body.emit(assign(r0CA0, body.constant(0u), 0x01));

                           body.emit(assign(r0C9E, add(r0C9E, body.constant(int(-32))), 0x01));


                        body.instructions = f0CA3_parent_instructions;
                        body.emit(f0CA3);

                        /* END IF */

                        ir_variable *const r0CA5 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r0CA5, r0C9F, 0x01));

                        ir_variable *const r0CA6 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r0CA7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0CA7);
                        /* IF CONDITION */
                        ir_expression *const r0CA9 = equal(r0C9F, body.constant(0u));
                        ir_if *f0CA8 = new(mem_ctx) ir_if(operand(r0CA9).val);
                        exec_list *const f0CA8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CA8->then_instructions;

                           body.emit(assign(r0CA6, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CA8->else_instructions;

                           body.emit(assign(r0CA7, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CAB = bit_and(r0C9F, body.constant(4294901760u));
                           ir_expression *const r0CAC = equal(r0CAB, body.constant(0u));
                           ir_if *f0CAA = new(mem_ctx) ir_if(operand(r0CAC).val);
                           exec_list *const f0CAA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAA->then_instructions;

                              body.emit(assign(r0CA7, body.constant(int(16)), 0x01));

                              body.emit(assign(r0CA5, lshift(r0C9F, body.constant(int(16))), 0x01));


                           body.instructions = f0CAA_parent_instructions;
                           body.emit(f0CAA);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CAE = bit_and(r0CA5, body.constant(4278190080u));
                           ir_expression *const r0CAF = equal(r0CAE, body.constant(0u));
                           ir_if *f0CAD = new(mem_ctx) ir_if(operand(r0CAF).val);
                           exec_list *const f0CAD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAD->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(8))), 0x01));

                              body.emit(assign(r0CA5, lshift(r0CA5, body.constant(int(8))), 0x01));


                           body.instructions = f0CAD_parent_instructions;
                           body.emit(f0CAD);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB1 = bit_and(r0CA5, body.constant(4026531840u));
                           ir_expression *const r0CB2 = equal(r0CB1, body.constant(0u));
                           ir_if *f0CB0 = new(mem_ctx) ir_if(operand(r0CB2).val);
                           exec_list *const f0CB0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB0->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(4))), 0x01));

                              body.emit(assign(r0CA5, lshift(r0CA5, body.constant(int(4))), 0x01));


                           body.instructions = f0CB0_parent_instructions;
                           body.emit(f0CB0);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB4 = bit_and(r0CA5, body.constant(3221225472u));
                           ir_expression *const r0CB5 = equal(r0CB4, body.constant(0u));
                           ir_if *f0CB3 = new(mem_ctx) ir_if(operand(r0CB5).val);
                           exec_list *const f0CB3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB3->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(2))), 0x01));

                              body.emit(assign(r0CA5, lshift(r0CA5, body.constant(int(2))), 0x01));


                           body.instructions = f0CB3_parent_instructions;
                           body.emit(f0CB3);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB7 = bit_and(r0CA5, body.constant(2147483648u));
                           ir_expression *const r0CB8 = equal(r0CB7, body.constant(0u));
                           ir_if *f0CB6 = new(mem_ctx) ir_if(operand(r0CB8).val);
                           exec_list *const f0CB6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB6->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(1))), 0x01));


                           body.instructions = f0CB6_parent_instructions;
                           body.emit(f0CB6);

                           /* END IF */

                           body.emit(assign(r0CA6, r0CA7, 0x01));


                        body.instructions = f0CA8_parent_instructions;
                        body.emit(f0CA8);

                        /* END IF */

                        body.emit(assign(r0CA2, add(r0CA6, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CBA = lequal(body.constant(int(0)), r0CA2);
                        ir_if *f0CB9 = new(mem_ctx) ir_if(operand(r0CBA).val);
                        exec_list *const f0CB9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CB9->then_instructions;

                           body.emit(assign(r0CA1, body.constant(0u), 0x01));

                           ir_variable *const r0CBB = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0CBB, lshift(r0CA0, r0CA2), 0x01));

                           ir_variable *const r0CBC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CBE = equal(r0CA2, body.constant(int(0)));
                           ir_if *f0CBD = new(mem_ctx) ir_if(operand(r0CBE).val);
                           exec_list *const f0CBD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CBD->then_instructions;

                              body.emit(assign(r0CBC, r0C9F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CBD->else_instructions;

                              ir_expression *const r0CBF = lshift(r0C9F, r0CA2);
                              ir_expression *const r0CC0 = neg(r0CA2);
                              ir_expression *const r0CC1 = bit_and(r0CC0, body.constant(int(31)));
                              ir_expression *const r0CC2 = rshift(r0CA0, r0CC1);
                              body.emit(assign(r0CBC, bit_or(r0CBF, r0CC2), 0x01));


                           body.instructions = f0CBD_parent_instructions;
                           body.emit(f0CBD);

                           /* END IF */

                           body.emit(assign(r0C9F, r0CBC, 0x01));

                           body.emit(assign(r0CA0, r0CBB, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CB9->else_instructions;

                           ir_variable *const r0CC3 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0CC3, body.constant(0u), 0x01));

                           ir_variable *const r0CC4 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0CC4, neg(r0CA2), 0x01));

                           ir_variable *const r0CC5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0CC5);
                           ir_variable *const r0CC6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0CC6);
                           ir_variable *const r0CC7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0CC7);
                           ir_variable *const r0CC8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0CC9 = neg(r0CC4);
                           body.emit(assign(r0CC8, bit_and(r0CC9, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CCB = equal(r0CC4, body.constant(int(0)));
                           ir_if *f0CCA = new(mem_ctx) ir_if(operand(r0CCB).val);
                           exec_list *const f0CCA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CCA->then_instructions;

                              body.emit(assign(r0CC5, r0CC3, 0x01));

                              body.emit(assign(r0CC6, r0CA0, 0x01));

                              body.emit(assign(r0CC7, r0C9F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CCA->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CCD = less(r0CC4, body.constant(int(32)));
                              ir_if *f0CCC = new(mem_ctx) ir_if(operand(r0CCD).val);
                              exec_list *const f0CCC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CCC->then_instructions;

                                 body.emit(assign(r0CC5, lshift(r0CA0, r0CC8), 0x01));

                                 ir_expression *const r0CCE = lshift(r0C9F, r0CC8);
                                 ir_expression *const r0CCF = rshift(r0CA0, r0CC4);
                                 body.emit(assign(r0CC6, bit_or(r0CCE, r0CCF), 0x01));

                                 body.emit(assign(r0CC7, rshift(r0C9F, r0CC4), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CCC->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0CD1 = equal(r0CC4, body.constant(int(32)));
                                 ir_if *f0CD0 = new(mem_ctx) ir_if(operand(r0CD1).val);
                                 exec_list *const f0CD0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CD0->then_instructions;

                                    body.emit(assign(r0CC5, r0CA0, 0x01));

                                    body.emit(assign(r0CC6, r0C9F, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CD0->else_instructions;

                                    body.emit(assign(r0CC3, bit_or(body.constant(0u), r0CA0), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0CD3 = less(r0CC4, body.constant(int(64)));
                                    ir_if *f0CD2 = new(mem_ctx) ir_if(operand(r0CD3).val);
                                    exec_list *const f0CD2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CD2->then_instructions;

                                       body.emit(assign(r0CC5, lshift(r0C9F, r0CC8), 0x01));

                                       ir_expression *const r0CD4 = bit_and(r0CC4, body.constant(int(31)));
                                       body.emit(assign(r0CC6, rshift(r0C9F, r0CD4), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CD2->else_instructions;

                                       ir_variable *const r0CD5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0CD7 = equal(r0CC4, body.constant(int(64)));
                                       ir_if *f0CD6 = new(mem_ctx) ir_if(operand(r0CD7).val);
                                       exec_list *const f0CD6_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0CD6->then_instructions;

                                          body.emit(assign(r0CD5, r0C9F, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0CD6->else_instructions;

                                          ir_expression *const r0CD8 = nequal(r0C9F, body.constant(0u));
                                          ir_expression *const r0CD9 = expr(ir_unop_b2i, r0CD8);
                                          body.emit(assign(r0CD5, expr(ir_unop_i2u, r0CD9), 0x01));


                                       body.instructions = f0CD6_parent_instructions;
                                       body.emit(f0CD6);

                                       /* END IF */

                                       body.emit(assign(r0CC5, r0CD5, 0x01));

                                       body.emit(assign(r0CC6, body.constant(0u), 0x01));


                                    body.instructions = f0CD2_parent_instructions;
                                    body.emit(f0CD2);

                                    /* END IF */


                                 body.instructions = f0CD0_parent_instructions;
                                 body.emit(f0CD0);

                                 /* END IF */

                                 body.emit(assign(r0CC7, body.constant(0u), 0x01));


                              body.instructions = f0CCC_parent_instructions;
                              body.emit(f0CCC);

                              /* END IF */

                              ir_expression *const r0CDA = nequal(r0CC3, body.constant(0u));
                              ir_expression *const r0CDB = expr(ir_unop_b2i, r0CDA);
                              ir_expression *const r0CDC = expr(ir_unop_i2u, r0CDB);
                              body.emit(assign(r0CC5, bit_or(r0CC5, r0CDC), 0x01));


                           body.instructions = f0CCA_parent_instructions;
                           body.emit(f0CCA);

                           /* END IF */

                           body.emit(assign(r0C9F, r0CC7, 0x01));

                           body.emit(assign(r0CA0, r0CC6, 0x01));

                           body.emit(assign(r0CA1, r0CC5, 0x01));


                        body.instructions = f0CB9_parent_instructions;
                        body.emit(f0CB9);

                        /* END IF */

                        body.emit(assign(r0C9E, sub(r0C9E, r0CA2), 0x01));

                        ir_variable *const r0CDD = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0CDD, r0C9E, 0x01));

                        ir_variable *const r0CDE = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0CDE, r0C9F, 0x01));

                        ir_variable *const r0CDF = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0CDF, r0CA0, 0x01));

                        ir_variable *const r0CE0 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r0CE0, r0CA1, 0x01));

                        ir_variable *const r0CE1 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r0CE1, body.constant(true), 0x01));

                        ir_variable *const r0CE2 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r0CE3 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r0CE3);
                        ir_expression *const r0CE4 = expr(ir_unop_u2i, r0CA1);
                        body.emit(assign(r0CE3, less(r0CE4, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CE6 = lequal(body.constant(int(2045)), r0C9E);
                        ir_if *f0CE5 = new(mem_ctx) ir_if(operand(r0CE6).val);
                        exec_list *const f0CE5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CE5->then_instructions;

                           ir_variable *const r0CE7 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CE9 = less(body.constant(int(2045)), r0C9E);
                           ir_if *f0CE8 = new(mem_ctx) ir_if(operand(r0CE9).val);
                           exec_list *const f0CE8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CE8->then_instructions;

                              body.emit(assign(r0CE7, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CE8->else_instructions;

                              ir_variable *const r0CEA = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0CEC = equal(r0C9E, body.constant(int(2045)));
                              ir_if *f0CEB = new(mem_ctx) ir_if(operand(r0CEC).val);
                              exec_list *const f0CEB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CEB->then_instructions;

                                 ir_expression *const r0CED = equal(body.constant(2097151u), r0C9F);
                                 ir_expression *const r0CEE = equal(body.constant(4294967295u), r0CA0);
                                 body.emit(assign(r0CEA, logic_and(r0CED, r0CEE), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CEB->else_instructions;

                                 body.emit(assign(r0CEA, body.constant(false), 0x01));


                              body.instructions = f0CEB_parent_instructions;
                              body.emit(f0CEB);

                              /* END IF */

                              body.emit(assign(r0CE7, logic_and(r0CEA, r0CE3), 0x01));


                           body.instructions = f0CE8_parent_instructions;
                           body.emit(f0CE8);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0CEF = new(mem_ctx) ir_if(operand(r0CE7).val);
                           exec_list *const f0CEF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CEF->then_instructions;

                              ir_variable *const r0CF0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0CF0);
                              ir_expression *const r0CF1 = lshift(r0999, body.constant(int(31)));
                              body.emit(assign(r0CF0, add(r0CF1, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r0CF0, body.constant(0u), 0x01));

                              body.emit(assign(r0CE2, r0CF0, 0x03));

                              body.emit(assign(r0CE1, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CEF->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CF3 = less(r0C9E, body.constant(int(0)));
                              ir_if *f0CF2 = new(mem_ctx) ir_if(operand(r0CF3).val);
                              exec_list *const f0CF2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CF2->then_instructions;

                                 ir_variable *const r0CF4 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r0CF4, r0CA1, 0x01));

                                 ir_variable *const r0CF5 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r0CF5, neg(r0C9E), 0x01));

                                 ir_variable *const r0CF6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r0CF6);
                                 ir_variable *const r0CF7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r0CF7);
                                 ir_variable *const r0CF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r0CF8);
                                 ir_variable *const r0CF9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r0CFA = neg(r0CF5);
                                 body.emit(assign(r0CF9, bit_and(r0CFA, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0CFC = equal(r0CF5, body.constant(int(0)));
                                 ir_if *f0CFB = new(mem_ctx) ir_if(operand(r0CFC).val);
                                 exec_list *const f0CFB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CFB->then_instructions;

                                    body.emit(assign(r0CF6, r0CA1, 0x01));

                                    body.emit(assign(r0CF7, r0CA0, 0x01));

                                    body.emit(assign(r0CF8, r0C9F, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CFB->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0CFE = less(r0CF5, body.constant(int(32)));
                                    ir_if *f0CFD = new(mem_ctx) ir_if(operand(r0CFE).val);
                                    exec_list *const f0CFD_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CFD->then_instructions;

                                       body.emit(assign(r0CF6, lshift(r0CA0, r0CF9), 0x01));

                                       ir_expression *const r0CFF = lshift(r0C9F, r0CF9);
                                       ir_expression *const r0D00 = rshift(r0CA0, r0CF5);
                                       body.emit(assign(r0CF7, bit_or(r0CFF, r0D00), 0x01));

                                       body.emit(assign(r0CF8, rshift(r0C9F, r0CF5), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CFD->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0D02 = equal(r0CF5, body.constant(int(32)));
                                       ir_if *f0D01 = new(mem_ctx) ir_if(operand(r0D02).val);
                                       exec_list *const f0D01_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D01->then_instructions;

                                          body.emit(assign(r0CF6, r0CA0, 0x01));

                                          body.emit(assign(r0CF7, r0C9F, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D01->else_instructions;

                                          body.emit(assign(r0CF4, bit_or(r0CA1, r0CA0), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r0D04 = less(r0CF5, body.constant(int(64)));
                                          ir_if *f0D03 = new(mem_ctx) ir_if(operand(r0D04).val);
                                          exec_list *const f0D03_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D03->then_instructions;

                                             body.emit(assign(r0CF6, lshift(r0C9F, r0CF9), 0x01));

                                             ir_expression *const r0D05 = bit_and(r0CF5, body.constant(int(31)));
                                             body.emit(assign(r0CF7, rshift(r0C9F, r0D05), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D03->else_instructions;

                                             ir_variable *const r0D06 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r0D08 = equal(r0CF5, body.constant(int(64)));
                                             ir_if *f0D07 = new(mem_ctx) ir_if(operand(r0D08).val);
                                             exec_list *const f0D07_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D07->then_instructions;

                                                body.emit(assign(r0D06, r0C9F, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D07->else_instructions;

                                                ir_expression *const r0D09 = nequal(r0C9F, body.constant(0u));
                                                ir_expression *const r0D0A = expr(ir_unop_b2i, r0D09);
                                                body.emit(assign(r0D06, expr(ir_unop_i2u, r0D0A), 0x01));


                                             body.instructions = f0D07_parent_instructions;
                                             body.emit(f0D07);

                                             /* END IF */

                                             body.emit(assign(r0CF6, r0D06, 0x01));

                                             body.emit(assign(r0CF7, body.constant(0u), 0x01));


                                          body.instructions = f0D03_parent_instructions;
                                          body.emit(f0D03);

                                          /* END IF */


                                       body.instructions = f0D01_parent_instructions;
                                       body.emit(f0D01);

                                       /* END IF */

                                       body.emit(assign(r0CF8, body.constant(0u), 0x01));


                                    body.instructions = f0CFD_parent_instructions;
                                    body.emit(f0CFD);

                                    /* END IF */

                                    ir_expression *const r0D0B = nequal(r0CF4, body.constant(0u));
                                    ir_expression *const r0D0C = expr(ir_unop_b2i, r0D0B);
                                    ir_expression *const r0D0D = expr(ir_unop_i2u, r0D0C);
                                    body.emit(assign(r0CF6, bit_or(r0CF6, r0D0D), 0x01));


                                 body.instructions = f0CFB_parent_instructions;
                                 body.emit(f0CFB);

                                 /* END IF */

                                 body.emit(assign(r0CDE, r0CF8, 0x01));

                                 body.emit(assign(r0CDF, r0CF7, 0x01));

                                 body.emit(assign(r0CE0, r0CF6, 0x01));

                                 body.emit(assign(r0CDD, body.constant(int(0)), 0x01));

                                 body.emit(assign(r0CE3, less(r0CF6, body.constant(0u)), 0x01));


                              body.instructions = f0CF2_parent_instructions;
                              body.emit(f0CF2);

                              /* END IF */


                           body.instructions = f0CEF_parent_instructions;
                           body.emit(f0CEF);

                           /* END IF */


                        body.instructions = f0CE5_parent_instructions;
                        body.emit(f0CE5);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0D0E = new(mem_ctx) ir_if(operand(r0CE1).val);
                        exec_list *const f0D0E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D0E->then_instructions;

                           /* IF CONDITION */
                           ir_if *f0D0F = new(mem_ctx) ir_if(operand(r0CE3).val);
                           exec_list *const f0D0F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D0F->then_instructions;

                              ir_variable *const r0D10 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r0D10, add(r0CDF, body.constant(1u)), 0x01));

                              ir_expression *const r0D11 = less(r0D10, r0CDF);
                              ir_expression *const r0D12 = expr(ir_unop_b2i, r0D11);
                              ir_expression *const r0D13 = expr(ir_unop_i2u, r0D12);
                              body.emit(assign(r0CDE, add(r0CDE, r0D13), 0x01));

                              ir_expression *const r0D14 = equal(r0CE0, body.constant(0u));
                              ir_expression *const r0D15 = expr(ir_unop_b2i, r0D14);
                              ir_expression *const r0D16 = expr(ir_unop_i2u, r0D15);
                              ir_expression *const r0D17 = add(r0CE0, r0D16);
                              ir_expression *const r0D18 = bit_and(r0D17, body.constant(1u));
                              ir_expression *const r0D19 = expr(ir_unop_bit_not, r0D18);
                              body.emit(assign(r0CDF, bit_and(r0D10, r0D19), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D0F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0D1B = bit_or(r0CDE, r0CDF);
                              ir_expression *const r0D1C = equal(r0D1B, body.constant(0u));
                              ir_if *f0D1A = new(mem_ctx) ir_if(operand(r0D1C).val);
                              exec_list *const f0D1A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D1A->then_instructions;

                                 body.emit(assign(r0CDD, body.constant(int(0)), 0x01));


                              body.instructions = f0D1A_parent_instructions;
                              body.emit(f0D1A);

                              /* END IF */


                           body.instructions = f0D0F_parent_instructions;
                           body.emit(f0D0F);

                           /* END IF */

                           ir_variable *const r0D1D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0D1D);
                           ir_expression *const r0D1E = lshift(r0999, body.constant(int(31)));
                           ir_expression *const r0D1F = expr(ir_unop_i2u, r0CDD);
                           ir_expression *const r0D20 = lshift(r0D1F, body.constant(int(20)));
                           ir_expression *const r0D21 = add(r0D1E, r0D20);
                           body.emit(assign(r0D1D, add(r0D21, r0CDE), 0x02));

                           body.emit(assign(r0D1D, r0CDF, 0x01));

                           body.emit(assign(r0CE2, r0D1D, 0x03));

                           body.emit(assign(r0CE1, body.constant(false), 0x01));


                        body.instructions = f0D0E_parent_instructions;
                        body.emit(f0D0E);

                        /* END IF */

                        body.emit(assign(r099A, r0CE2, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C96->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0D23 = less(r09A1, r099F);
                        ir_if *f0D22 = new(mem_ctx) ir_if(operand(r0D23).val);
                        exec_list *const f0D22_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D22->then_instructions;

                           ir_variable *const r0D24 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r0D25 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0D25, sub(r099F, r09A1), 0x01));

                           ir_expression *const r0D26 = sub(r099E, r09A0);
                           ir_expression *const r0D27 = less(r099F, r09A1);
                           ir_expression *const r0D28 = expr(ir_unop_b2i, r0D27);
                           ir_expression *const r0D29 = expr(ir_unop_i2u, r0D28);
                           body.emit(assign(r0D24, sub(r0D26, r0D29), 0x01));

                           body.emit(assign(r0999, bit_xor(r0999, body.constant(1u)), 0x01));

                           body.emit(assign(r09A2, add(r099C, body.constant(int(-1))), 0x01));

                           ir_variable *const r0D2A = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D2A, add(r09A2, body.constant(int(-10))), 0x01));

                           ir_variable *const r0D2B = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D2B, r0D24, 0x01));

                           ir_variable *const r0D2C = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D2C, r0D25, 0x01));

                           ir_variable *const r0D2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r0D2D);
                           ir_variable *const r0D2E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D2E);
                           /* IF CONDITION */
                           ir_expression *const r0D30 = equal(r0D24, body.constant(0u));
                           ir_if *f0D2F = new(mem_ctx) ir_if(operand(r0D30).val);
                           exec_list *const f0D2F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D2F->then_instructions;

                              body.emit(assign(r0D2B, r0D25, 0x01));

                              body.emit(assign(r0D2C, body.constant(0u), 0x01));

                              body.emit(assign(r0D2A, add(r0D2A, body.constant(int(-32))), 0x01));


                           body.instructions = f0D2F_parent_instructions;
                           body.emit(f0D2F);

                           /* END IF */

                           ir_variable *const r0D31 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r0D31, r0D2B, 0x01));

                           ir_variable *const r0D32 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r0D33 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D33);
                           /* IF CONDITION */
                           ir_expression *const r0D35 = equal(r0D2B, body.constant(0u));
                           ir_if *f0D34 = new(mem_ctx) ir_if(operand(r0D35).val);
                           exec_list *const f0D34_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D34->then_instructions;

                              body.emit(assign(r0D32, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D34->else_instructions;

                              body.emit(assign(r0D33, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D37 = bit_and(r0D2B, body.constant(4294901760u));
                              ir_expression *const r0D38 = equal(r0D37, body.constant(0u));
                              ir_if *f0D36 = new(mem_ctx) ir_if(operand(r0D38).val);
                              exec_list *const f0D36_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D36->then_instructions;

                                 body.emit(assign(r0D33, body.constant(int(16)), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D2B, body.constant(int(16))), 0x01));


                              body.instructions = f0D36_parent_instructions;
                              body.emit(f0D36);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D3A = bit_and(r0D31, body.constant(4278190080u));
                              ir_expression *const r0D3B = equal(r0D3A, body.constant(0u));
                              ir_if *f0D39 = new(mem_ctx) ir_if(operand(r0D3B).val);
                              exec_list *const f0D39_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D39->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(8))), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D31, body.constant(int(8))), 0x01));


                              body.instructions = f0D39_parent_instructions;
                              body.emit(f0D39);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D3D = bit_and(r0D31, body.constant(4026531840u));
                              ir_expression *const r0D3E = equal(r0D3D, body.constant(0u));
                              ir_if *f0D3C = new(mem_ctx) ir_if(operand(r0D3E).val);
                              exec_list *const f0D3C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D3C->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(4))), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D31, body.constant(int(4))), 0x01));


                              body.instructions = f0D3C_parent_instructions;
                              body.emit(f0D3C);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D40 = bit_and(r0D31, body.constant(3221225472u));
                              ir_expression *const r0D41 = equal(r0D40, body.constant(0u));
                              ir_if *f0D3F = new(mem_ctx) ir_if(operand(r0D41).val);
                              exec_list *const f0D3F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D3F->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(2))), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D31, body.constant(int(2))), 0x01));


                              body.instructions = f0D3F_parent_instructions;
                              body.emit(f0D3F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D43 = bit_and(r0D31, body.constant(2147483648u));
                              ir_expression *const r0D44 = equal(r0D43, body.constant(0u));
                              ir_if *f0D42 = new(mem_ctx) ir_if(operand(r0D44).val);
                              exec_list *const f0D42_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D42->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(1))), 0x01));


                              body.instructions = f0D42_parent_instructions;
                              body.emit(f0D42);

                              /* END IF */

                              body.emit(assign(r0D32, r0D33, 0x01));


                           body.instructions = f0D34_parent_instructions;
                           body.emit(f0D34);

                           /* END IF */

                           body.emit(assign(r0D2E, add(r0D32, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D46 = lequal(body.constant(int(0)), r0D2E);
                           ir_if *f0D45 = new(mem_ctx) ir_if(operand(r0D46).val);
                           exec_list *const f0D45_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D45->then_instructions;

                              body.emit(assign(r0D2D, body.constant(0u), 0x01));

                              ir_variable *const r0D47 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r0D47, lshift(r0D2C, r0D2E), 0x01));

                              ir_variable *const r0D48 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D4A = equal(r0D2E, body.constant(int(0)));
                              ir_if *f0D49 = new(mem_ctx) ir_if(operand(r0D4A).val);
                              exec_list *const f0D49_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D49->then_instructions;

                                 body.emit(assign(r0D48, r0D2B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D49->else_instructions;

                                 ir_expression *const r0D4B = lshift(r0D2B, r0D2E);
                                 ir_expression *const r0D4C = neg(r0D2E);
                                 ir_expression *const r0D4D = bit_and(r0D4C, body.constant(int(31)));
                                 ir_expression *const r0D4E = rshift(r0D2C, r0D4D);
                                 body.emit(assign(r0D48, bit_or(r0D4B, r0D4E), 0x01));


                              body.instructions = f0D49_parent_instructions;
                              body.emit(f0D49);

                              /* END IF */

                              body.emit(assign(r0D2B, r0D48, 0x01));

                              body.emit(assign(r0D2C, r0D47, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D45->else_instructions;

                              ir_variable *const r0D4F = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0D4F, body.constant(0u), 0x01));

                              ir_variable *const r0D50 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0D50, neg(r0D2E), 0x01));

                              ir_variable *const r0D51 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0D51);
                              ir_variable *const r0D52 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0D52);
                              ir_variable *const r0D53 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0D53);
                              ir_variable *const r0D54 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0D55 = neg(r0D50);
                              body.emit(assign(r0D54, bit_and(r0D55, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D57 = equal(r0D50, body.constant(int(0)));
                              ir_if *f0D56 = new(mem_ctx) ir_if(operand(r0D57).val);
                              exec_list *const f0D56_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D56->then_instructions;

                                 body.emit(assign(r0D51, r0D4F, 0x01));

                                 body.emit(assign(r0D52, r0D2C, 0x01));

                                 body.emit(assign(r0D53, r0D2B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D56->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D59 = less(r0D50, body.constant(int(32)));
                                 ir_if *f0D58 = new(mem_ctx) ir_if(operand(r0D59).val);
                                 exec_list *const f0D58_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D58->then_instructions;

                                    body.emit(assign(r0D51, lshift(r0D2C, r0D54), 0x01));

                                    ir_expression *const r0D5A = lshift(r0D2B, r0D54);
                                    ir_expression *const r0D5B = rshift(r0D2C, r0D50);
                                    body.emit(assign(r0D52, bit_or(r0D5A, r0D5B), 0x01));

                                    body.emit(assign(r0D53, rshift(r0D2B, r0D50), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D58->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0D5D = equal(r0D50, body.constant(int(32)));
                                    ir_if *f0D5C = new(mem_ctx) ir_if(operand(r0D5D).val);
                                    exec_list *const f0D5C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D5C->then_instructions;

                                       body.emit(assign(r0D51, r0D2C, 0x01));

                                       body.emit(assign(r0D52, r0D2B, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D5C->else_instructions;

                                       body.emit(assign(r0D4F, bit_or(body.constant(0u), r0D2C), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0D5F = less(r0D50, body.constant(int(64)));
                                       ir_if *f0D5E = new(mem_ctx) ir_if(operand(r0D5F).val);
                                       exec_list *const f0D5E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D5E->then_instructions;

                                          body.emit(assign(r0D51, lshift(r0D2B, r0D54), 0x01));

                                          ir_expression *const r0D60 = bit_and(r0D50, body.constant(int(31)));
                                          body.emit(assign(r0D52, rshift(r0D2B, r0D60), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D5E->else_instructions;

                                          ir_variable *const r0D61 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0D63 = equal(r0D50, body.constant(int(64)));
                                          ir_if *f0D62 = new(mem_ctx) ir_if(operand(r0D63).val);
                                          exec_list *const f0D62_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D62->then_instructions;

                                             body.emit(assign(r0D61, r0D2B, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D62->else_instructions;

                                             ir_expression *const r0D64 = nequal(r0D2B, body.constant(0u));
                                             ir_expression *const r0D65 = expr(ir_unop_b2i, r0D64);
                                             body.emit(assign(r0D61, expr(ir_unop_i2u, r0D65), 0x01));


                                          body.instructions = f0D62_parent_instructions;
                                          body.emit(f0D62);

                                          /* END IF */

                                          body.emit(assign(r0D51, r0D61, 0x01));

                                          body.emit(assign(r0D52, body.constant(0u), 0x01));


                                       body.instructions = f0D5E_parent_instructions;
                                       body.emit(f0D5E);

                                       /* END IF */


                                    body.instructions = f0D5C_parent_instructions;
                                    body.emit(f0D5C);

                                    /* END IF */

                                    body.emit(assign(r0D53, body.constant(0u), 0x01));


                                 body.instructions = f0D58_parent_instructions;
                                 body.emit(f0D58);

                                 /* END IF */

                                 ir_expression *const r0D66 = nequal(r0D4F, body.constant(0u));
                                 ir_expression *const r0D67 = expr(ir_unop_b2i, r0D66);
                                 ir_expression *const r0D68 = expr(ir_unop_i2u, r0D67);
                                 body.emit(assign(r0D51, bit_or(r0D51, r0D68), 0x01));


                              body.instructions = f0D56_parent_instructions;
                              body.emit(f0D56);

                              /* END IF */

                              body.emit(assign(r0D2B, r0D53, 0x01));

                              body.emit(assign(r0D2C, r0D52, 0x01));

                              body.emit(assign(r0D2D, r0D51, 0x01));


                           body.instructions = f0D45_parent_instructions;
                           body.emit(f0D45);

                           /* END IF */

                           body.emit(assign(r0D2A, sub(r0D2A, r0D2E), 0x01));

                           ir_variable *const r0D69 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D69, r0D2A, 0x01));

                           ir_variable *const r0D6A = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D6A, r0D2B, 0x01));

                           ir_variable *const r0D6B = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D6B, r0D2C, 0x01));

                           ir_variable *const r0D6C = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r0D6C, r0D2D, 0x01));

                           ir_variable *const r0D6D = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r0D6D, body.constant(true), 0x01));

                           ir_variable *const r0D6E = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r0D6F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r0D6F);
                           ir_expression *const r0D70 = expr(ir_unop_u2i, r0D2D);
                           body.emit(assign(r0D6F, less(r0D70, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D72 = lequal(body.constant(int(2045)), r0D2A);
                           ir_if *f0D71 = new(mem_ctx) ir_if(operand(r0D72).val);
                           exec_list *const f0D71_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D71->then_instructions;

                              ir_variable *const r0D73 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D75 = less(body.constant(int(2045)), r0D2A);
                              ir_if *f0D74 = new(mem_ctx) ir_if(operand(r0D75).val);
                              exec_list *const f0D74_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D74->then_instructions;

                                 body.emit(assign(r0D73, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D74->else_instructions;

                                 ir_variable *const r0D76 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0D78 = equal(r0D2A, body.constant(int(2045)));
                                 ir_if *f0D77 = new(mem_ctx) ir_if(operand(r0D78).val);
                                 exec_list *const f0D77_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D77->then_instructions;

                                    ir_expression *const r0D79 = equal(body.constant(2097151u), r0D2B);
                                    ir_expression *const r0D7A = equal(body.constant(4294967295u), r0D2C);
                                    body.emit(assign(r0D76, logic_and(r0D79, r0D7A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D77->else_instructions;

                                    body.emit(assign(r0D76, body.constant(false), 0x01));


                                 body.instructions = f0D77_parent_instructions;
                                 body.emit(f0D77);

                                 /* END IF */

                                 body.emit(assign(r0D73, logic_and(r0D76, r0D6F), 0x01));


                              body.instructions = f0D74_parent_instructions;
                              body.emit(f0D74);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f0D7B = new(mem_ctx) ir_if(operand(r0D73).val);
                              exec_list *const f0D7B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D7B->then_instructions;

                                 ir_variable *const r0D7C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r0D7C);
                                 ir_expression *const r0D7D = lshift(r0999, body.constant(int(31)));
                                 body.emit(assign(r0D7C, add(r0D7D, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r0D7C, body.constant(0u), 0x01));

                                 body.emit(assign(r0D6E, r0D7C, 0x03));

                                 body.emit(assign(r0D6D, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D7B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D7F = less(r0D2A, body.constant(int(0)));
                                 ir_if *f0D7E = new(mem_ctx) ir_if(operand(r0D7F).val);
                                 exec_list *const f0D7E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D7E->then_instructions;

                                    ir_variable *const r0D80 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r0D80, r0D2D, 0x01));

                                    ir_variable *const r0D81 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r0D81, neg(r0D2A), 0x01));

                                    ir_variable *const r0D82 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r0D82);
                                    ir_variable *const r0D83 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r0D83);
                                    ir_variable *const r0D84 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r0D84);
                                    ir_variable *const r0D85 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r0D86 = neg(r0D81);
                                    body.emit(assign(r0D85, bit_and(r0D86, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0D88 = equal(r0D81, body.constant(int(0)));
                                    ir_if *f0D87 = new(mem_ctx) ir_if(operand(r0D88).val);
                                    exec_list *const f0D87_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D87->then_instructions;

                                       body.emit(assign(r0D82, r0D2D, 0x01));

                                       body.emit(assign(r0D83, r0D2C, 0x01));

                                       body.emit(assign(r0D84, r0D2B, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D87->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0D8A = less(r0D81, body.constant(int(32)));
                                       ir_if *f0D89 = new(mem_ctx) ir_if(operand(r0D8A).val);
                                       exec_list *const f0D89_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D89->then_instructions;

                                          body.emit(assign(r0D82, lshift(r0D2C, r0D85), 0x01));

                                          ir_expression *const r0D8B = lshift(r0D2B, r0D85);
                                          ir_expression *const r0D8C = rshift(r0D2C, r0D81);
                                          body.emit(assign(r0D83, bit_or(r0D8B, r0D8C), 0x01));

                                          body.emit(assign(r0D84, rshift(r0D2B, r0D81), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D89->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r0D8E = equal(r0D81, body.constant(int(32)));
                                          ir_if *f0D8D = new(mem_ctx) ir_if(operand(r0D8E).val);
                                          exec_list *const f0D8D_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D8D->then_instructions;

                                             body.emit(assign(r0D82, r0D2C, 0x01));

                                             body.emit(assign(r0D83, r0D2B, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D8D->else_instructions;

                                             body.emit(assign(r0D80, bit_or(r0D2D, r0D2C), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r0D90 = less(r0D81, body.constant(int(64)));
                                             ir_if *f0D8F = new(mem_ctx) ir_if(operand(r0D90).val);
                                             exec_list *const f0D8F_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D8F->then_instructions;

                                                body.emit(assign(r0D82, lshift(r0D2B, r0D85), 0x01));

                                                ir_expression *const r0D91 = bit_and(r0D81, body.constant(int(31)));
                                                body.emit(assign(r0D83, rshift(r0D2B, r0D91), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D8F->else_instructions;

                                                ir_variable *const r0D92 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r0D94 = equal(r0D81, body.constant(int(64)));
                                                ir_if *f0D93 = new(mem_ctx) ir_if(operand(r0D94).val);
                                                exec_list *const f0D93_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f0D93->then_instructions;

                                                   body.emit(assign(r0D92, r0D2B, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f0D93->else_instructions;

                                                   ir_expression *const r0D95 = nequal(r0D2B, body.constant(0u));
                                                   ir_expression *const r0D96 = expr(ir_unop_b2i, r0D95);
                                                   body.emit(assign(r0D92, expr(ir_unop_i2u, r0D96), 0x01));


                                                body.instructions = f0D93_parent_instructions;
                                                body.emit(f0D93);

                                                /* END IF */

                                                body.emit(assign(r0D82, r0D92, 0x01));

                                                body.emit(assign(r0D83, body.constant(0u), 0x01));


                                             body.instructions = f0D8F_parent_instructions;
                                             body.emit(f0D8F);

                                             /* END IF */


                                          body.instructions = f0D8D_parent_instructions;
                                          body.emit(f0D8D);

                                          /* END IF */

                                          body.emit(assign(r0D84, body.constant(0u), 0x01));


                                       body.instructions = f0D89_parent_instructions;
                                       body.emit(f0D89);

                                       /* END IF */

                                       ir_expression *const r0D97 = nequal(r0D80, body.constant(0u));
                                       ir_expression *const r0D98 = expr(ir_unop_b2i, r0D97);
                                       ir_expression *const r0D99 = expr(ir_unop_i2u, r0D98);
                                       body.emit(assign(r0D82, bit_or(r0D82, r0D99), 0x01));


                                    body.instructions = f0D87_parent_instructions;
                                    body.emit(f0D87);

                                    /* END IF */

                                    body.emit(assign(r0D6A, r0D84, 0x01));

                                    body.emit(assign(r0D6B, r0D83, 0x01));

                                    body.emit(assign(r0D6C, r0D82, 0x01));

                                    body.emit(assign(r0D69, body.constant(int(0)), 0x01));

                                    body.emit(assign(r0D6F, less(r0D82, body.constant(0u)), 0x01));


                                 body.instructions = f0D7E_parent_instructions;
                                 body.emit(f0D7E);

                                 /* END IF */


                              body.instructions = f0D7B_parent_instructions;
                              body.emit(f0D7B);

                              /* END IF */


                           body.instructions = f0D71_parent_instructions;
                           body.emit(f0D71);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0D9A = new(mem_ctx) ir_if(operand(r0D6D).val);
                           exec_list *const f0D9A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D9A->then_instructions;

                              /* IF CONDITION */
                              ir_if *f0D9B = new(mem_ctx) ir_if(operand(r0D6F).val);
                              exec_list *const f0D9B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D9B->then_instructions;

                                 ir_variable *const r0D9C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r0D9C, add(r0D6B, body.constant(1u)), 0x01));

                                 ir_expression *const r0D9D = less(r0D9C, r0D6B);
                                 ir_expression *const r0D9E = expr(ir_unop_b2i, r0D9D);
                                 ir_expression *const r0D9F = expr(ir_unop_i2u, r0D9E);
                                 body.emit(assign(r0D6A, add(r0D6A, r0D9F), 0x01));

                                 ir_expression *const r0DA0 = equal(r0D6C, body.constant(0u));
                                 ir_expression *const r0DA1 = expr(ir_unop_b2i, r0DA0);
                                 ir_expression *const r0DA2 = expr(ir_unop_i2u, r0DA1);
                                 ir_expression *const r0DA3 = add(r0D6C, r0DA2);
                                 ir_expression *const r0DA4 = bit_and(r0DA3, body.constant(1u));
                                 ir_expression *const r0DA5 = expr(ir_unop_bit_not, r0DA4);
                                 body.emit(assign(r0D6B, bit_and(r0D9C, r0DA5), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D9B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0DA7 = bit_or(r0D6A, r0D6B);
                                 ir_expression *const r0DA8 = equal(r0DA7, body.constant(0u));
                                 ir_if *f0DA6 = new(mem_ctx) ir_if(operand(r0DA8).val);
                                 exec_list *const f0DA6_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0DA6->then_instructions;

                                    body.emit(assign(r0D69, body.constant(int(0)), 0x01));


                                 body.instructions = f0DA6_parent_instructions;
                                 body.emit(f0DA6);

                                 /* END IF */


                              body.instructions = f0D9B_parent_instructions;
                              body.emit(f0D9B);

                              /* END IF */

                              ir_variable *const r0DA9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0DA9);
                              ir_expression *const r0DAA = lshift(r0999, body.constant(int(31)));
                              ir_expression *const r0DAB = expr(ir_unop_i2u, r0D69);
                              ir_expression *const r0DAC = lshift(r0DAB, body.constant(int(20)));
                              ir_expression *const r0DAD = add(r0DAA, r0DAC);
                              body.emit(assign(r0DA9, add(r0DAD, r0D6A), 0x02));

                              body.emit(assign(r0DA9, r0D6B, 0x01));

                              body.emit(assign(r0D6E, r0DA9, 0x03));

                              body.emit(assign(r0D6D, body.constant(false), 0x01));


                           body.instructions = f0D9A_parent_instructions;
                           body.emit(f0D9A);

                           /* END IF */

                           body.emit(assign(r099A, r0D6E, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0D22->else_instructions;

                           ir_variable *const r0DAE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0DAE);
                           body.emit(assign(r0DAE, body.constant(0u), 0x02));

                           body.emit(assign(r0DAE, body.constant(0u), 0x01));

                           body.emit(assign(r099A, r0DAE, 0x03));


                        body.instructions = f0D22_parent_instructions;
                        body.emit(f0D22);

                        /* END IF */


                     body.instructions = f0C96_parent_instructions;
                     body.emit(f0C96);

                     /* END IF */


                  body.instructions = f0C0A_parent_instructions;
                  body.emit(f0C0A);

                  /* END IF */


               body.instructions = f0B7E_parent_instructions;
               body.emit(f0B7E);

               /* END IF */


            body.instructions = f0B57_parent_instructions;
            body.emit(f0B57);

            /* END IF */


         body.instructions = f0A83_parent_instructions;
         body.emit(f0A83);

         /* END IF */


      body.instructions = f09B3_parent_instructions;
      body.emit(f09B3);

      /* END IF */

      body.emit(assign(r07EB, r099A, 0x03));


   body.instructions = f07EE_parent_instructions;
   body.emit(f07EE);

   /* END IF */

   body.emit(ret(r07EB));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fsub64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0DAF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0DAF);
   ir_variable *const r0DB0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0DB0);
   ir_variable *const r0DB1 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0DB2 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r0DB2, rshift(swizzle_y(r0DAF), body.constant(int(31))), 0x01));

   ir_variable *const r0DB3 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r0DB3, rshift(swizzle_y(r0DB0), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0DB5 = equal(r0DB2, r0DB3);
   ir_if *f0DB4 = new(mem_ctx) ir_if(operand(r0DB5).val);
   exec_list *const f0DB4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0DB4->then_instructions;

      ir_variable *const r0DB6 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r0DB6, r0DB2, 0x01));

      ir_variable *const r0DB7 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r0DB8 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r0DB8);
      ir_variable *const r0DB9 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r0DB9);
      ir_variable *const r0DBA = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r0DBA);
      ir_variable *const r0DBB = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r0DBB);
      ir_variable *const r0DBC = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r0DBC);
      ir_variable *const r0DBD = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r0DBD);
      ir_variable *const r0DBE = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r0DBE);
      ir_variable *const r0DBF = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r0DBF);
      ir_variable *const r0DC0 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r0DC1 = rshift(swizzle_y(r0DAF), body.constant(int(20)));
      ir_expression *const r0DC2 = bit_and(r0DC1, body.constant(2047u));
      body.emit(assign(r0DC0, expr(ir_unop_u2i, r0DC2), 0x01));

      body.emit(assign(r0DBA, r0DC0, 0x01));

      ir_variable *const r0DC3 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r0DC4 = rshift(swizzle_y(r0DB0), body.constant(int(20)));
      ir_expression *const r0DC5 = bit_and(r0DC4, body.constant(2047u));
      body.emit(assign(r0DC3, expr(ir_unop_u2i, r0DC5), 0x01));

      body.emit(assign(r0DB9, r0DC3, 0x01));

      body.emit(assign(r0DB8, sub(r0DC0, r0DC3), 0x01));

      ir_variable *const r0DC6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r0DC6, lshift(swizzle_x(r0DAF), body.constant(int(10))), 0x01));

      ir_variable *const r0DC7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r0DC8 = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
      ir_expression *const r0DC9 = lshift(r0DC8, body.constant(int(10)));
      ir_expression *const r0DCA = rshift(swizzle_x(r0DAF), body.constant(int(22)));
      body.emit(assign(r0DC7, bit_or(r0DC9, r0DCA), 0x01));

      body.emit(assign(r0DBD, r0DC7, 0x01));

      body.emit(assign(r0DBE, r0DC6, 0x01));

      ir_variable *const r0DCB = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r0DCB, lshift(swizzle_x(r0DB0), body.constant(int(10))), 0x01));

      ir_variable *const r0DCC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r0DCD = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
      ir_expression *const r0DCE = lshift(r0DCD, body.constant(int(10)));
      ir_expression *const r0DCF = rshift(swizzle_x(r0DB0), body.constant(int(22)));
      body.emit(assign(r0DCC, bit_or(r0DCE, r0DCF), 0x01));

      body.emit(assign(r0DBB, r0DCC, 0x01));

      body.emit(assign(r0DBC, r0DCB, 0x01));

      /* IF CONDITION */
      ir_expression *const r0DD1 = less(body.constant(int(0)), r0DB8);
      ir_if *f0DD0 = new(mem_ctx) ir_if(operand(r0DD1).val);
      exec_list *const f0DD0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0DD0->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0DD3 = equal(r0DC0, body.constant(int(2047)));
         ir_if *f0DD2 = new(mem_ctx) ir_if(operand(r0DD3).val);
         exec_list *const f0DD2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0DD2->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0DD5 = bit_or(r0DC7, r0DC6);
            ir_expression *const r0DD6 = nequal(r0DD5, body.constant(0u));
            ir_if *f0DD4 = new(mem_ctx) ir_if(operand(r0DD6).val);
            exec_list *const f0DD4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DD4->then_instructions;

               ir_variable *const r0DD7 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0DD7, swizzle_x(r0DAF), 0x01));

               ir_variable *const r0DD8 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0DD8, swizzle_x(r0DB0), 0x01));

               ir_variable *const r0DD9 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0DDA = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0DDB = rshift(swizzle_y(r0DAF), body.constant(int(19)));
               ir_expression *const r0DDC = bit_and(r0DDB, body.constant(4095u));
               ir_expression *const r0DDD = equal(r0DDC, body.constant(4094u));
               ir_expression *const r0DDE = nequal(swizzle_x(r0DAF), body.constant(0u));
               ir_expression *const r0DDF = bit_and(swizzle_y(r0DAF), body.constant(524287u));
               ir_expression *const r0DE0 = nequal(r0DDF, body.constant(0u));
               ir_expression *const r0DE1 = logic_or(r0DDE, r0DE0);
               body.emit(assign(r0DDA, logic_and(r0DDD, r0DE1), 0x01));

               ir_variable *const r0DE2 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r0DE3 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
               ir_expression *const r0DE4 = lequal(body.constant(4292870144u), r0DE3);
               ir_expression *const r0DE5 = nequal(swizzle_x(r0DB0), body.constant(0u));
               ir_expression *const r0DE6 = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
               ir_expression *const r0DE7 = nequal(r0DE6, body.constant(0u));
               ir_expression *const r0DE8 = logic_or(r0DE5, r0DE7);
               body.emit(assign(r0DE2, logic_and(r0DE4, r0DE8), 0x01));

               body.emit(assign(r0DD7, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

               body.emit(assign(r0DD8, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r0DEA = lshift(swizzle_y(r0DAF), body.constant(int(1)));
               ir_expression *const r0DEB = lequal(body.constant(4292870144u), r0DEA);
               ir_expression *const r0DEC = nequal(swizzle_x(r0DAF), body.constant(0u));
               ir_expression *const r0DED = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
               ir_expression *const r0DEE = nequal(r0DED, body.constant(0u));
               ir_expression *const r0DEF = logic_or(r0DEC, r0DEE);
               ir_expression *const r0DF0 = logic_and(r0DEB, r0DEF);
               ir_if *f0DE9 = new(mem_ctx) ir_if(operand(r0DF0).val);
               exec_list *const f0DE9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0DE9->then_instructions;

                  ir_variable *const r0DF1 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0DF3 = logic_and(r0DDA, r0DE2);
                  ir_if *f0DF2 = new(mem_ctx) ir_if(operand(r0DF3).val);
                  exec_list *const f0DF2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0DF2->then_instructions;

                     body.emit(assign(r0DF1, r0DD8, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0DF2->else_instructions;

                     body.emit(assign(r0DF1, r0DD7, 0x03));


                  body.instructions = f0DF2_parent_instructions;
                  body.emit(f0DF2);

                  /* END IF */

                  body.emit(assign(r0DD9, r0DF1, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0DE9->else_instructions;

                  body.emit(assign(r0DD9, r0DD8, 0x03));


               body.instructions = f0DE9_parent_instructions;
               body.emit(f0DE9);

               /* END IF */

               body.emit(assign(r0DB7, r0DD9, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DD4->else_instructions;

               body.emit(assign(r0DB7, r0DAF, 0x03));


            body.instructions = f0DD4_parent_instructions;
            body.emit(f0DD4);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0DD2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0DF5 = equal(r0DC3, body.constant(int(0)));
            ir_if *f0DF4 = new(mem_ctx) ir_if(operand(r0DF5).val);
            exec_list *const f0DF4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DF4->then_instructions;

               body.emit(assign(r0DB8, add(r0DB8, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DF4->else_instructions;

               body.emit(assign(r0DBB, bit_or(r0DCC, body.constant(1073741824u)), 0x01));


            body.instructions = f0DF4_parent_instructions;
            body.emit(f0DF4);

            /* END IF */

            ir_variable *const r0DF6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0DF6);
            ir_variable *const r0DF7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0DF7);
            ir_variable *const r0DF8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0DF9 = neg(r0DB8);
            body.emit(assign(r0DF8, bit_and(r0DF9, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0DFB = equal(r0DB8, body.constant(int(0)));
            ir_if *f0DFA = new(mem_ctx) ir_if(operand(r0DFB).val);
            exec_list *const f0DFA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DFA->then_instructions;

               body.emit(assign(r0DF6, r0DCB, 0x01));

               body.emit(assign(r0DF7, r0DBB, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DFA->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0DFD = less(r0DB8, body.constant(int(32)));
               ir_if *f0DFC = new(mem_ctx) ir_if(operand(r0DFD).val);
               exec_list *const f0DFC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0DFC->then_instructions;

                  ir_expression *const r0DFE = lshift(r0DBB, r0DF8);
                  ir_expression *const r0DFF = rshift(r0DCB, r0DB8);
                  ir_expression *const r0E00 = bit_or(r0DFE, r0DFF);
                  ir_expression *const r0E01 = lshift(r0DCB, r0DF8);
                  ir_expression *const r0E02 = nequal(r0E01, body.constant(0u));
                  ir_expression *const r0E03 = expr(ir_unop_b2i, r0E02);
                  ir_expression *const r0E04 = expr(ir_unop_i2u, r0E03);
                  body.emit(assign(r0DF6, bit_or(r0E00, r0E04), 0x01));

                  body.emit(assign(r0DF7, rshift(r0DBB, r0DB8), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0DFC->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E06 = equal(r0DB8, body.constant(int(32)));
                  ir_if *f0E05 = new(mem_ctx) ir_if(operand(r0E06).val);
                  exec_list *const f0E05_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E05->then_instructions;

                     ir_expression *const r0E07 = nequal(r0DCB, body.constant(0u));
                     ir_expression *const r0E08 = expr(ir_unop_b2i, r0E07);
                     ir_expression *const r0E09 = expr(ir_unop_i2u, r0E08);
                     body.emit(assign(r0DF6, bit_or(r0DBB, r0E09), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E05->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0E0B = less(r0DB8, body.constant(int(64)));
                     ir_if *f0E0A = new(mem_ctx) ir_if(operand(r0E0B).val);
                     exec_list *const f0E0A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E0A->then_instructions;

                        ir_expression *const r0E0C = bit_and(r0DB8, body.constant(int(31)));
                        ir_expression *const r0E0D = rshift(r0DBB, r0E0C);
                        ir_expression *const r0E0E = lshift(r0DBB, r0DF8);
                        ir_expression *const r0E0F = bit_or(r0E0E, r0DCB);
                        ir_expression *const r0E10 = nequal(r0E0F, body.constant(0u));
                        ir_expression *const r0E11 = expr(ir_unop_b2i, r0E10);
                        ir_expression *const r0E12 = expr(ir_unop_i2u, r0E11);
                        body.emit(assign(r0DF6, bit_or(r0E0D, r0E12), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E0A->else_instructions;

                        ir_expression *const r0E13 = bit_or(r0DBB, r0DCB);
                        ir_expression *const r0E14 = nequal(r0E13, body.constant(0u));
                        ir_expression *const r0E15 = expr(ir_unop_b2i, r0E14);
                        body.emit(assign(r0DF6, expr(ir_unop_i2u, r0E15), 0x01));


                     body.instructions = f0E0A_parent_instructions;
                     body.emit(f0E0A);

                     /* END IF */


                  body.instructions = f0E05_parent_instructions;
                  body.emit(f0E05);

                  /* END IF */

                  body.emit(assign(r0DF7, body.constant(0u), 0x01));


               body.instructions = f0DFC_parent_instructions;
               body.emit(f0DFC);

               /* END IF */


            body.instructions = f0DFA_parent_instructions;
            body.emit(f0DFA);

            /* END IF */

            body.emit(assign(r0DBB, r0DF7, 0x01));

            body.emit(assign(r0DBC, r0DF6, 0x01));

            body.emit(assign(r0DBD, bit_or(r0DC7, body.constant(1073741824u)), 0x01));

            ir_variable *const r0E16 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r0E17 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0E17, sub(r0DC6, r0DF6), 0x01));

            ir_expression *const r0E18 = sub(r0DBD, r0DF7);
            ir_expression *const r0E19 = less(r0DC6, r0DF6);
            ir_expression *const r0E1A = expr(ir_unop_b2i, r0E19);
            ir_expression *const r0E1B = expr(ir_unop_i2u, r0E1A);
            body.emit(assign(r0E16, sub(r0E18, r0E1B), 0x01));

            body.emit(assign(r0DBF, add(r0DC0, body.constant(int(-1))), 0x01));

            ir_variable *const r0E1C = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0E1C, add(r0DBF, body.constant(int(-10))), 0x01));

            ir_variable *const r0E1D = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0E1D, r0E16, 0x01));

            ir_variable *const r0E1E = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0E1E, r0E17, 0x01));

            ir_variable *const r0E1F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0E1F);
            ir_variable *const r0E20 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0E20);
            /* IF CONDITION */
            ir_expression *const r0E22 = equal(r0E16, body.constant(0u));
            ir_if *f0E21 = new(mem_ctx) ir_if(operand(r0E22).val);
            exec_list *const f0E21_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E21->then_instructions;

               body.emit(assign(r0E1D, r0E17, 0x01));

               body.emit(assign(r0E1E, body.constant(0u), 0x01));

               body.emit(assign(r0E1C, add(r0E1C, body.constant(int(-32))), 0x01));


            body.instructions = f0E21_parent_instructions;
            body.emit(f0E21);

            /* END IF */

            ir_variable *const r0E23 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0E23, r0E1D, 0x01));

            ir_variable *const r0E24 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0E25 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0E25);
            /* IF CONDITION */
            ir_expression *const r0E27 = equal(r0E1D, body.constant(0u));
            ir_if *f0E26 = new(mem_ctx) ir_if(operand(r0E27).val);
            exec_list *const f0E26_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E26->then_instructions;

               body.emit(assign(r0E24, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0E26->else_instructions;

               body.emit(assign(r0E25, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0E29 = bit_and(r0E1D, body.constant(4294901760u));
               ir_expression *const r0E2A = equal(r0E29, body.constant(0u));
               ir_if *f0E28 = new(mem_ctx) ir_if(operand(r0E2A).val);
               exec_list *const f0E28_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E28->then_instructions;

                  body.emit(assign(r0E25, body.constant(int(16)), 0x01));

                  body.emit(assign(r0E23, lshift(r0E1D, body.constant(int(16))), 0x01));


               body.instructions = f0E28_parent_instructions;
               body.emit(f0E28);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E2C = bit_and(r0E23, body.constant(4278190080u));
               ir_expression *const r0E2D = equal(r0E2C, body.constant(0u));
               ir_if *f0E2B = new(mem_ctx) ir_if(operand(r0E2D).val);
               exec_list *const f0E2B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E2B->then_instructions;

                  body.emit(assign(r0E25, add(r0E25, body.constant(int(8))), 0x01));

                  body.emit(assign(r0E23, lshift(r0E23, body.constant(int(8))), 0x01));


               body.instructions = f0E2B_parent_instructions;
               body.emit(f0E2B);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E2F = bit_and(r0E23, body.constant(4026531840u));
               ir_expression *const r0E30 = equal(r0E2F, body.constant(0u));
               ir_if *f0E2E = new(mem_ctx) ir_if(operand(r0E30).val);
               exec_list *const f0E2E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E2E->then_instructions;

                  body.emit(assign(r0E25, add(r0E25, body.constant(int(4))), 0x01));

                  body.emit(assign(r0E23, lshift(r0E23, body.constant(int(4))), 0x01));


               body.instructions = f0E2E_parent_instructions;
               body.emit(f0E2E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E32 = bit_and(r0E23, body.constant(3221225472u));
               ir_expression *const r0E33 = equal(r0E32, body.constant(0u));
               ir_if *f0E31 = new(mem_ctx) ir_if(operand(r0E33).val);
               exec_list *const f0E31_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E31->then_instructions;

                  body.emit(assign(r0E25, add(r0E25, body.constant(int(2))), 0x01));

                  body.emit(assign(r0E23, lshift(r0E23, body.constant(int(2))), 0x01));


               body.instructions = f0E31_parent_instructions;
               body.emit(f0E31);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E35 = bit_and(r0E23, body.constant(2147483648u));
               ir_expression *const r0E36 = equal(r0E35, body.constant(0u));
               ir_if *f0E34 = new(mem_ctx) ir_if(operand(r0E36).val);
               exec_list *const f0E34_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E34->then_instructions;

                  body.emit(assign(r0E25, add(r0E25, body.constant(int(1))), 0x01));


               body.instructions = f0E34_parent_instructions;
               body.emit(f0E34);

               /* END IF */

               body.emit(assign(r0E24, r0E25, 0x01));


            body.instructions = f0E26_parent_instructions;
            body.emit(f0E26);

            /* END IF */

            body.emit(assign(r0E20, add(r0E24, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0E38 = lequal(body.constant(int(0)), r0E20);
            ir_if *f0E37 = new(mem_ctx) ir_if(operand(r0E38).val);
            exec_list *const f0E37_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E37->then_instructions;

               body.emit(assign(r0E1F, body.constant(0u), 0x01));

               ir_variable *const r0E39 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0E39, lshift(r0E1E, r0E20), 0x01));

               ir_variable *const r0E3A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0E3C = equal(r0E20, body.constant(int(0)));
               ir_if *f0E3B = new(mem_ctx) ir_if(operand(r0E3C).val);
               exec_list *const f0E3B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E3B->then_instructions;

                  body.emit(assign(r0E3A, r0E1D, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E3B->else_instructions;

                  ir_expression *const r0E3D = lshift(r0E1D, r0E20);
                  ir_expression *const r0E3E = neg(r0E20);
                  ir_expression *const r0E3F = bit_and(r0E3E, body.constant(int(31)));
                  ir_expression *const r0E40 = rshift(r0E1E, r0E3F);
                  body.emit(assign(r0E3A, bit_or(r0E3D, r0E40), 0x01));


               body.instructions = f0E3B_parent_instructions;
               body.emit(f0E3B);

               /* END IF */

               body.emit(assign(r0E1D, r0E3A, 0x01));

               body.emit(assign(r0E1E, r0E39, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0E37->else_instructions;

               ir_variable *const r0E41 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0E41, body.constant(0u), 0x01));

               ir_variable *const r0E42 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0E42, neg(r0E20), 0x01));

               ir_variable *const r0E43 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0E43);
               ir_variable *const r0E44 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0E44);
               ir_variable *const r0E45 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0E45);
               ir_variable *const r0E46 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0E47 = neg(r0E42);
               body.emit(assign(r0E46, bit_and(r0E47, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0E49 = equal(r0E42, body.constant(int(0)));
               ir_if *f0E48 = new(mem_ctx) ir_if(operand(r0E49).val);
               exec_list *const f0E48_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E48->then_instructions;

                  body.emit(assign(r0E43, r0E41, 0x01));

                  body.emit(assign(r0E44, r0E1E, 0x01));

                  body.emit(assign(r0E45, r0E1D, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E48->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E4B = less(r0E42, body.constant(int(32)));
                  ir_if *f0E4A = new(mem_ctx) ir_if(operand(r0E4B).val);
                  exec_list *const f0E4A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E4A->then_instructions;

                     body.emit(assign(r0E43, lshift(r0E1E, r0E46), 0x01));

                     ir_expression *const r0E4C = lshift(r0E1D, r0E46);
                     ir_expression *const r0E4D = rshift(r0E1E, r0E42);
                     body.emit(assign(r0E44, bit_or(r0E4C, r0E4D), 0x01));

                     body.emit(assign(r0E45, rshift(r0E1D, r0E42), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E4A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0E4F = equal(r0E42, body.constant(int(32)));
                     ir_if *f0E4E = new(mem_ctx) ir_if(operand(r0E4F).val);
                     exec_list *const f0E4E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E4E->then_instructions;

                        body.emit(assign(r0E43, r0E1E, 0x01));

                        body.emit(assign(r0E44, r0E1D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E4E->else_instructions;

                        body.emit(assign(r0E41, bit_or(body.constant(0u), r0E1E), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0E51 = less(r0E42, body.constant(int(64)));
                        ir_if *f0E50 = new(mem_ctx) ir_if(operand(r0E51).val);
                        exec_list *const f0E50_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0E50->then_instructions;

                           body.emit(assign(r0E43, lshift(r0E1D, r0E46), 0x01));

                           ir_expression *const r0E52 = bit_and(r0E42, body.constant(int(31)));
                           body.emit(assign(r0E44, rshift(r0E1D, r0E52), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0E50->else_instructions;

                           ir_variable *const r0E53 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0E55 = equal(r0E42, body.constant(int(64)));
                           ir_if *f0E54 = new(mem_ctx) ir_if(operand(r0E55).val);
                           exec_list *const f0E54_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0E54->then_instructions;

                              body.emit(assign(r0E53, r0E1D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0E54->else_instructions;

                              ir_expression *const r0E56 = nequal(r0E1D, body.constant(0u));
                              ir_expression *const r0E57 = expr(ir_unop_b2i, r0E56);
                              body.emit(assign(r0E53, expr(ir_unop_i2u, r0E57), 0x01));


                           body.instructions = f0E54_parent_instructions;
                           body.emit(f0E54);

                           /* END IF */

                           body.emit(assign(r0E43, r0E53, 0x01));

                           body.emit(assign(r0E44, body.constant(0u), 0x01));


                        body.instructions = f0E50_parent_instructions;
                        body.emit(f0E50);

                        /* END IF */


                     body.instructions = f0E4E_parent_instructions;
                     body.emit(f0E4E);

                     /* END IF */

                     body.emit(assign(r0E45, body.constant(0u), 0x01));


                  body.instructions = f0E4A_parent_instructions;
                  body.emit(f0E4A);

                  /* END IF */

                  ir_expression *const r0E58 = nequal(r0E41, body.constant(0u));
                  ir_expression *const r0E59 = expr(ir_unop_b2i, r0E58);
                  ir_expression *const r0E5A = expr(ir_unop_i2u, r0E59);
                  body.emit(assign(r0E43, bit_or(r0E43, r0E5A), 0x01));


               body.instructions = f0E48_parent_instructions;
               body.emit(f0E48);

               /* END IF */

               body.emit(assign(r0E1D, r0E45, 0x01));

               body.emit(assign(r0E1E, r0E44, 0x01));

               body.emit(assign(r0E1F, r0E43, 0x01));


            body.instructions = f0E37_parent_instructions;
            body.emit(f0E37);

            /* END IF */

            body.emit(assign(r0E1C, sub(r0E1C, r0E20), 0x01));

            ir_variable *const r0E5B = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0E5B, r0E1C, 0x01));

            ir_variable *const r0E5C = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0E5C, r0E1D, 0x01));

            ir_variable *const r0E5D = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0E5D, r0E1E, 0x01));

            ir_variable *const r0E5E = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0E5E, r0E1F, 0x01));

            ir_variable *const r0E5F = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0E5F, body.constant(true), 0x01));

            ir_variable *const r0E60 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0E61 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0E61);
            ir_expression *const r0E62 = expr(ir_unop_u2i, r0E1F);
            body.emit(assign(r0E61, less(r0E62, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0E64 = lequal(body.constant(int(2045)), r0E1C);
            ir_if *f0E63 = new(mem_ctx) ir_if(operand(r0E64).val);
            exec_list *const f0E63_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E63->then_instructions;

               ir_variable *const r0E65 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0E67 = less(body.constant(int(2045)), r0E1C);
               ir_if *f0E66 = new(mem_ctx) ir_if(operand(r0E67).val);
               exec_list *const f0E66_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E66->then_instructions;

                  body.emit(assign(r0E65, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E66->else_instructions;

                  ir_variable *const r0E68 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0E6A = equal(r0E1C, body.constant(int(2045)));
                  ir_if *f0E69 = new(mem_ctx) ir_if(operand(r0E6A).val);
                  exec_list *const f0E69_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E69->then_instructions;

                     ir_expression *const r0E6B = equal(body.constant(2097151u), r0E1D);
                     ir_expression *const r0E6C = equal(body.constant(4294967295u), r0E1E);
                     body.emit(assign(r0E68, logic_and(r0E6B, r0E6C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E69->else_instructions;

                     body.emit(assign(r0E68, body.constant(false), 0x01));


                  body.instructions = f0E69_parent_instructions;
                  body.emit(f0E69);

                  /* END IF */

                  body.emit(assign(r0E65, logic_and(r0E68, r0E61), 0x01));


               body.instructions = f0E66_parent_instructions;
               body.emit(f0E66);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0E6D = new(mem_ctx) ir_if(operand(r0E65).val);
               exec_list *const f0E6D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E6D->then_instructions;

                  ir_variable *const r0E6E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0E6E);
                  ir_expression *const r0E6F = lshift(r0DB2, body.constant(int(31)));
                  body.emit(assign(r0E6E, add(r0E6F, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0E6E, body.constant(0u), 0x01));

                  body.emit(assign(r0E60, r0E6E, 0x03));

                  body.emit(assign(r0E5F, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E6D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E71 = less(r0E1C, body.constant(int(0)));
                  ir_if *f0E70 = new(mem_ctx) ir_if(operand(r0E71).val);
                  exec_list *const f0E70_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E70->then_instructions;

                     ir_variable *const r0E72 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0E72, r0E1F, 0x01));

                     ir_variable *const r0E73 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0E73, neg(r0E1C), 0x01));

                     ir_variable *const r0E74 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0E74);
                     ir_variable *const r0E75 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0E75);
                     ir_variable *const r0E76 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0E76);
                     ir_variable *const r0E77 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0E78 = neg(r0E73);
                     body.emit(assign(r0E77, bit_and(r0E78, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0E7A = equal(r0E73, body.constant(int(0)));
                     ir_if *f0E79 = new(mem_ctx) ir_if(operand(r0E7A).val);
                     exec_list *const f0E79_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E79->then_instructions;

                        body.emit(assign(r0E74, r0E1F, 0x01));

                        body.emit(assign(r0E75, r0E1E, 0x01));

                        body.emit(assign(r0E76, r0E1D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E79->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0E7C = less(r0E73, body.constant(int(32)));
                        ir_if *f0E7B = new(mem_ctx) ir_if(operand(r0E7C).val);
                        exec_list *const f0E7B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0E7B->then_instructions;

                           body.emit(assign(r0E74, lshift(r0E1E, r0E77), 0x01));

                           ir_expression *const r0E7D = lshift(r0E1D, r0E77);
                           ir_expression *const r0E7E = rshift(r0E1E, r0E73);
                           body.emit(assign(r0E75, bit_or(r0E7D, r0E7E), 0x01));

                           body.emit(assign(r0E76, rshift(r0E1D, r0E73), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0E7B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0E80 = equal(r0E73, body.constant(int(32)));
                           ir_if *f0E7F = new(mem_ctx) ir_if(operand(r0E80).val);
                           exec_list *const f0E7F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0E7F->then_instructions;

                              body.emit(assign(r0E74, r0E1E, 0x01));

                              body.emit(assign(r0E75, r0E1D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0E7F->else_instructions;

                              body.emit(assign(r0E72, bit_or(r0E1F, r0E1E), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0E82 = less(r0E73, body.constant(int(64)));
                              ir_if *f0E81 = new(mem_ctx) ir_if(operand(r0E82).val);
                              exec_list *const f0E81_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0E81->then_instructions;

                                 body.emit(assign(r0E74, lshift(r0E1D, r0E77), 0x01));

                                 ir_expression *const r0E83 = bit_and(r0E73, body.constant(int(31)));
                                 body.emit(assign(r0E75, rshift(r0E1D, r0E83), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0E81->else_instructions;

                                 ir_variable *const r0E84 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0E86 = equal(r0E73, body.constant(int(64)));
                                 ir_if *f0E85 = new(mem_ctx) ir_if(operand(r0E86).val);
                                 exec_list *const f0E85_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0E85->then_instructions;

                                    body.emit(assign(r0E84, r0E1D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0E85->else_instructions;

                                    ir_expression *const r0E87 = nequal(r0E1D, body.constant(0u));
                                    ir_expression *const r0E88 = expr(ir_unop_b2i, r0E87);
                                    body.emit(assign(r0E84, expr(ir_unop_i2u, r0E88), 0x01));


                                 body.instructions = f0E85_parent_instructions;
                                 body.emit(f0E85);

                                 /* END IF */

                                 body.emit(assign(r0E74, r0E84, 0x01));

                                 body.emit(assign(r0E75, body.constant(0u), 0x01));


                              body.instructions = f0E81_parent_instructions;
                              body.emit(f0E81);

                              /* END IF */


                           body.instructions = f0E7F_parent_instructions;
                           body.emit(f0E7F);

                           /* END IF */

                           body.emit(assign(r0E76, body.constant(0u), 0x01));


                        body.instructions = f0E7B_parent_instructions;
                        body.emit(f0E7B);

                        /* END IF */

                        ir_expression *const r0E89 = nequal(r0E72, body.constant(0u));
                        ir_expression *const r0E8A = expr(ir_unop_b2i, r0E89);
                        ir_expression *const r0E8B = expr(ir_unop_i2u, r0E8A);
                        body.emit(assign(r0E74, bit_or(r0E74, r0E8B), 0x01));


                     body.instructions = f0E79_parent_instructions;
                     body.emit(f0E79);

                     /* END IF */

                     body.emit(assign(r0E5C, r0E76, 0x01));

                     body.emit(assign(r0E5D, r0E75, 0x01));

                     body.emit(assign(r0E5E, r0E74, 0x01));

                     body.emit(assign(r0E5B, body.constant(int(0)), 0x01));

                     body.emit(assign(r0E61, less(r0E74, body.constant(0u)), 0x01));


                  body.instructions = f0E70_parent_instructions;
                  body.emit(f0E70);

                  /* END IF */


               body.instructions = f0E6D_parent_instructions;
               body.emit(f0E6D);

               /* END IF */


            body.instructions = f0E63_parent_instructions;
            body.emit(f0E63);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0E8C = new(mem_ctx) ir_if(operand(r0E5F).val);
            exec_list *const f0E8C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E8C->then_instructions;

               /* IF CONDITION */
               ir_if *f0E8D = new(mem_ctx) ir_if(operand(r0E61).val);
               exec_list *const f0E8D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E8D->then_instructions;

                  ir_variable *const r0E8E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0E8E, add(r0E5D, body.constant(1u)), 0x01));

                  ir_expression *const r0E8F = less(r0E8E, r0E5D);
                  ir_expression *const r0E90 = expr(ir_unop_b2i, r0E8F);
                  ir_expression *const r0E91 = expr(ir_unop_i2u, r0E90);
                  body.emit(assign(r0E5C, add(r0E5C, r0E91), 0x01));

                  ir_expression *const r0E92 = equal(r0E5E, body.constant(0u));
                  ir_expression *const r0E93 = expr(ir_unop_b2i, r0E92);
                  ir_expression *const r0E94 = expr(ir_unop_i2u, r0E93);
                  ir_expression *const r0E95 = add(r0E5E, r0E94);
                  ir_expression *const r0E96 = bit_and(r0E95, body.constant(1u));
                  ir_expression *const r0E97 = expr(ir_unop_bit_not, r0E96);
                  body.emit(assign(r0E5D, bit_and(r0E8E, r0E97), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E8D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E99 = bit_or(r0E5C, r0E5D);
                  ir_expression *const r0E9A = equal(r0E99, body.constant(0u));
                  ir_if *f0E98 = new(mem_ctx) ir_if(operand(r0E9A).val);
                  exec_list *const f0E98_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E98->then_instructions;

                     body.emit(assign(r0E5B, body.constant(int(0)), 0x01));


                  body.instructions = f0E98_parent_instructions;
                  body.emit(f0E98);

                  /* END IF */


               body.instructions = f0E8D_parent_instructions;
               body.emit(f0E8D);

               /* END IF */

               ir_variable *const r0E9B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0E9B);
               ir_expression *const r0E9C = lshift(r0DB2, body.constant(int(31)));
               ir_expression *const r0E9D = expr(ir_unop_i2u, r0E5B);
               ir_expression *const r0E9E = lshift(r0E9D, body.constant(int(20)));
               ir_expression *const r0E9F = add(r0E9C, r0E9E);
               body.emit(assign(r0E9B, add(r0E9F, r0E5C), 0x02));

               body.emit(assign(r0E9B, r0E5D, 0x01));

               body.emit(assign(r0E60, r0E9B, 0x03));

               body.emit(assign(r0E5F, body.constant(false), 0x01));


            body.instructions = f0E8C_parent_instructions;
            body.emit(f0E8C);

            /* END IF */

            body.emit(assign(r0DB7, r0E60, 0x03));


         body.instructions = f0DD2_parent_instructions;
         body.emit(f0DD2);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0DD0->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0EA1 = less(r0DB8, body.constant(int(0)));
         ir_if *f0EA0 = new(mem_ctx) ir_if(operand(r0EA1).val);
         exec_list *const f0EA0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0EA0->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0EA3 = equal(r0DC3, body.constant(int(2047)));
            ir_if *f0EA2 = new(mem_ctx) ir_if(operand(r0EA3).val);
            exec_list *const f0EA2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0EA2->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0EA5 = bit_or(r0DBB, r0DBC);
               ir_expression *const r0EA6 = nequal(r0EA5, body.constant(0u));
               ir_if *f0EA4 = new(mem_ctx) ir_if(operand(r0EA6).val);
               exec_list *const f0EA4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EA4->then_instructions;

                  ir_variable *const r0EA7 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0EA7, swizzle_x(r0DAF), 0x01));

                  ir_variable *const r0EA8 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0EA8, swizzle_x(r0DB0), 0x01));

                  ir_variable *const r0EA9 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0EAA = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0EAB = rshift(swizzle_y(r0DAF), body.constant(int(19)));
                  ir_expression *const r0EAC = bit_and(r0EAB, body.constant(4095u));
                  ir_expression *const r0EAD = equal(r0EAC, body.constant(4094u));
                  ir_expression *const r0EAE = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r0EAF = bit_and(swizzle_y(r0DAF), body.constant(524287u));
                  ir_expression *const r0EB0 = nequal(r0EAF, body.constant(0u));
                  ir_expression *const r0EB1 = logic_or(r0EAE, r0EB0);
                  body.emit(assign(r0EAA, logic_and(r0EAD, r0EB1), 0x01));

                  ir_variable *const r0EB2 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0EB3 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
                  ir_expression *const r0EB4 = lequal(body.constant(4292870144u), r0EB3);
                  ir_expression *const r0EB5 = nequal(swizzle_x(r0DB0), body.constant(0u));
                  ir_expression *const r0EB6 = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
                  ir_expression *const r0EB7 = nequal(r0EB6, body.constant(0u));
                  ir_expression *const r0EB8 = logic_or(r0EB5, r0EB7);
                  body.emit(assign(r0EB2, logic_and(r0EB4, r0EB8), 0x01));

                  body.emit(assign(r0EA7, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

                  body.emit(assign(r0EA8, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0EBA = lshift(swizzle_y(r0DAF), body.constant(int(1)));
                  ir_expression *const r0EBB = lequal(body.constant(4292870144u), r0EBA);
                  ir_expression *const r0EBC = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r0EBD = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
                  ir_expression *const r0EBE = nequal(r0EBD, body.constant(0u));
                  ir_expression *const r0EBF = logic_or(r0EBC, r0EBE);
                  ir_expression *const r0EC0 = logic_and(r0EBB, r0EBF);
                  ir_if *f0EB9 = new(mem_ctx) ir_if(operand(r0EC0).val);
                  exec_list *const f0EB9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0EB9->then_instructions;

                     ir_variable *const r0EC1 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0EC3 = logic_and(r0EAA, r0EB2);
                     ir_if *f0EC2 = new(mem_ctx) ir_if(operand(r0EC3).val);
                     exec_list *const f0EC2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EC2->then_instructions;

                        body.emit(assign(r0EC1, r0EA8, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0EC2->else_instructions;

                        body.emit(assign(r0EC1, r0EA7, 0x03));


                     body.instructions = f0EC2_parent_instructions;
                     body.emit(f0EC2);

                     /* END IF */

                     body.emit(assign(r0EA9, r0EC1, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0EB9->else_instructions;

                     body.emit(assign(r0EA9, r0EA8, 0x03));


                  body.instructions = f0EB9_parent_instructions;
                  body.emit(f0EB9);

                  /* END IF */

                  body.emit(assign(r0DB7, r0EA9, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EA4->else_instructions;

                  ir_variable *const r0EC4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0EC4);
                  ir_expression *const r0EC5 = bit_xor(r0DB2, body.constant(1u));
                  ir_expression *const r0EC6 = lshift(r0EC5, body.constant(int(31)));
                  body.emit(assign(r0EC4, add(r0EC6, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0EC4, body.constant(0u), 0x01));

                  body.emit(assign(r0DB7, r0EC4, 0x03));


               body.instructions = f0EA4_parent_instructions;
               body.emit(f0EA4);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0EA2->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0EC8 = equal(r0DC0, body.constant(int(0)));
               ir_if *f0EC7 = new(mem_ctx) ir_if(operand(r0EC8).val);
               exec_list *const f0EC7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EC7->then_instructions;

                  body.emit(assign(r0DB8, add(r0DB8, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EC7->else_instructions;

                  body.emit(assign(r0DBD, bit_or(r0DBD, body.constant(1073741824u)), 0x01));


               body.instructions = f0EC7_parent_instructions;
               body.emit(f0EC7);

               /* END IF */

               ir_variable *const r0EC9 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0EC9, neg(r0DB8), 0x01));

               ir_variable *const r0ECA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0ECA);
               ir_variable *const r0ECB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0ECB);
               ir_variable *const r0ECC = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0ECD = neg(r0EC9);
               body.emit(assign(r0ECC, bit_and(r0ECD, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0ECF = equal(r0EC9, body.constant(int(0)));
               ir_if *f0ECE = new(mem_ctx) ir_if(operand(r0ECF).val);
               exec_list *const f0ECE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ECE->then_instructions;

                  body.emit(assign(r0ECA, r0DC6, 0x01));

                  body.emit(assign(r0ECB, r0DBD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0ECE->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0ED1 = less(r0EC9, body.constant(int(32)));
                  ir_if *f0ED0 = new(mem_ctx) ir_if(operand(r0ED1).val);
                  exec_list *const f0ED0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0ED0->then_instructions;

                     ir_expression *const r0ED2 = lshift(r0DBD, r0ECC);
                     ir_expression *const r0ED3 = rshift(r0DC6, r0EC9);
                     ir_expression *const r0ED4 = bit_or(r0ED2, r0ED3);
                     ir_expression *const r0ED5 = lshift(r0DC6, r0ECC);
                     ir_expression *const r0ED6 = nequal(r0ED5, body.constant(0u));
                     ir_expression *const r0ED7 = expr(ir_unop_b2i, r0ED6);
                     ir_expression *const r0ED8 = expr(ir_unop_i2u, r0ED7);
                     body.emit(assign(r0ECA, bit_or(r0ED4, r0ED8), 0x01));

                     body.emit(assign(r0ECB, rshift(r0DBD, r0EC9), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0ED0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0EDA = equal(r0EC9, body.constant(int(32)));
                     ir_if *f0ED9 = new(mem_ctx) ir_if(operand(r0EDA).val);
                     exec_list *const f0ED9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0ED9->then_instructions;

                        ir_expression *const r0EDB = nequal(r0DC6, body.constant(0u));
                        ir_expression *const r0EDC = expr(ir_unop_b2i, r0EDB);
                        ir_expression *const r0EDD = expr(ir_unop_i2u, r0EDC);
                        body.emit(assign(r0ECA, bit_or(r0DBD, r0EDD), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0ED9->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0EDF = less(r0EC9, body.constant(int(64)));
                        ir_if *f0EDE = new(mem_ctx) ir_if(operand(r0EDF).val);
                        exec_list *const f0EDE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0EDE->then_instructions;

                           ir_expression *const r0EE0 = bit_and(r0EC9, body.constant(int(31)));
                           ir_expression *const r0EE1 = rshift(r0DBD, r0EE0);
                           ir_expression *const r0EE2 = lshift(r0DBD, r0ECC);
                           ir_expression *const r0EE3 = bit_or(r0EE2, r0DC6);
                           ir_expression *const r0EE4 = nequal(r0EE3, body.constant(0u));
                           ir_expression *const r0EE5 = expr(ir_unop_b2i, r0EE4);
                           ir_expression *const r0EE6 = expr(ir_unop_i2u, r0EE5);
                           body.emit(assign(r0ECA, bit_or(r0EE1, r0EE6), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0EDE->else_instructions;

                           ir_expression *const r0EE7 = bit_or(r0DBD, r0DC6);
                           ir_expression *const r0EE8 = nequal(r0EE7, body.constant(0u));
                           ir_expression *const r0EE9 = expr(ir_unop_b2i, r0EE8);
                           body.emit(assign(r0ECA, expr(ir_unop_i2u, r0EE9), 0x01));


                        body.instructions = f0EDE_parent_instructions;
                        body.emit(f0EDE);

                        /* END IF */


                     body.instructions = f0ED9_parent_instructions;
                     body.emit(f0ED9);

                     /* END IF */

                     body.emit(assign(r0ECB, body.constant(0u), 0x01));


                  body.instructions = f0ED0_parent_instructions;
                  body.emit(f0ED0);

                  /* END IF */


               body.instructions = f0ECE_parent_instructions;
               body.emit(f0ECE);

               /* END IF */

               body.emit(assign(r0DBD, r0ECB, 0x01));

               body.emit(assign(r0DBE, r0ECA, 0x01));

               body.emit(assign(r0DBB, bit_or(r0DBB, body.constant(1073741824u)), 0x01));

               ir_variable *const r0EEA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0EEB = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0EEB, sub(r0DBC, r0ECA), 0x01));

               ir_expression *const r0EEC = sub(r0DBB, r0ECB);
               ir_expression *const r0EED = less(r0DBC, r0ECA);
               ir_expression *const r0EEE = expr(ir_unop_b2i, r0EED);
               ir_expression *const r0EEF = expr(ir_unop_i2u, r0EEE);
               body.emit(assign(r0EEA, sub(r0EEC, r0EEF), 0x01));

               body.emit(assign(r0DB6, bit_xor(r0DB2, body.constant(1u)), 0x01));

               body.emit(assign(r0DBF, add(r0DC3, body.constant(int(-1))), 0x01));

               ir_variable *const r0EF0 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0EF0, add(r0DBF, body.constant(int(-10))), 0x01));

               ir_variable *const r0EF1 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0EF1, r0EEA, 0x01));

               ir_variable *const r0EF2 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0EF2, r0EEB, 0x01));

               ir_variable *const r0EF3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r0EF3);
               ir_variable *const r0EF4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0EF4);
               /* IF CONDITION */
               ir_expression *const r0EF6 = equal(r0EEA, body.constant(0u));
               ir_if *f0EF5 = new(mem_ctx) ir_if(operand(r0EF6).val);
               exec_list *const f0EF5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EF5->then_instructions;

                  body.emit(assign(r0EF1, r0EEB, 0x01));

                  body.emit(assign(r0EF2, body.constant(0u), 0x01));

                  body.emit(assign(r0EF0, add(r0EF0, body.constant(int(-32))), 0x01));


               body.instructions = f0EF5_parent_instructions;
               body.emit(f0EF5);

               /* END IF */

               ir_variable *const r0EF7 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r0EF7, r0EF1, 0x01));

               ir_variable *const r0EF8 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r0EF9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0EF9);
               /* IF CONDITION */
               ir_expression *const r0EFB = equal(r0EF1, body.constant(0u));
               ir_if *f0EFA = new(mem_ctx) ir_if(operand(r0EFB).val);
               exec_list *const f0EFA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EFA->then_instructions;

                  body.emit(assign(r0EF8, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EFA->else_instructions;

                  body.emit(assign(r0EF9, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0EFD = bit_and(r0EF1, body.constant(4294901760u));
                  ir_expression *const r0EFE = equal(r0EFD, body.constant(0u));
                  ir_if *f0EFC = new(mem_ctx) ir_if(operand(r0EFE).val);
                  exec_list *const f0EFC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0EFC->then_instructions;

                     body.emit(assign(r0EF9, body.constant(int(16)), 0x01));

                     body.emit(assign(r0EF7, lshift(r0EF1, body.constant(int(16))), 0x01));


                  body.instructions = f0EFC_parent_instructions;
                  body.emit(f0EFC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F00 = bit_and(r0EF7, body.constant(4278190080u));
                  ir_expression *const r0F01 = equal(r0F00, body.constant(0u));
                  ir_if *f0EFF = new(mem_ctx) ir_if(operand(r0F01).val);
                  exec_list *const f0EFF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0EFF->then_instructions;

                     body.emit(assign(r0EF9, add(r0EF9, body.constant(int(8))), 0x01));

                     body.emit(assign(r0EF7, lshift(r0EF7, body.constant(int(8))), 0x01));


                  body.instructions = f0EFF_parent_instructions;
                  body.emit(f0EFF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F03 = bit_and(r0EF7, body.constant(4026531840u));
                  ir_expression *const r0F04 = equal(r0F03, body.constant(0u));
                  ir_if *f0F02 = new(mem_ctx) ir_if(operand(r0F04).val);
                  exec_list *const f0F02_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F02->then_instructions;

                     body.emit(assign(r0EF9, add(r0EF9, body.constant(int(4))), 0x01));

                     body.emit(assign(r0EF7, lshift(r0EF7, body.constant(int(4))), 0x01));


                  body.instructions = f0F02_parent_instructions;
                  body.emit(f0F02);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F06 = bit_and(r0EF7, body.constant(3221225472u));
                  ir_expression *const r0F07 = equal(r0F06, body.constant(0u));
                  ir_if *f0F05 = new(mem_ctx) ir_if(operand(r0F07).val);
                  exec_list *const f0F05_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F05->then_instructions;

                     body.emit(assign(r0EF9, add(r0EF9, body.constant(int(2))), 0x01));

                     body.emit(assign(r0EF7, lshift(r0EF7, body.constant(int(2))), 0x01));


                  body.instructions = f0F05_parent_instructions;
                  body.emit(f0F05);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F09 = bit_and(r0EF7, body.constant(2147483648u));
                  ir_expression *const r0F0A = equal(r0F09, body.constant(0u));
                  ir_if *f0F08 = new(mem_ctx) ir_if(operand(r0F0A).val);
                  exec_list *const f0F08_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F08->then_instructions;

                     body.emit(assign(r0EF9, add(r0EF9, body.constant(int(1))), 0x01));


                  body.instructions = f0F08_parent_instructions;
                  body.emit(f0F08);

                  /* END IF */

                  body.emit(assign(r0EF8, r0EF9, 0x01));


               body.instructions = f0EFA_parent_instructions;
               body.emit(f0EFA);

               /* END IF */

               body.emit(assign(r0EF4, add(r0EF8, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0F0C = lequal(body.constant(int(0)), r0EF4);
               ir_if *f0F0B = new(mem_ctx) ir_if(operand(r0F0C).val);
               exec_list *const f0F0B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F0B->then_instructions;

                  body.emit(assign(r0EF3, body.constant(0u), 0x01));

                  ir_variable *const r0F0D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0F0D, lshift(r0EF2, r0EF4), 0x01));

                  ir_variable *const r0F0E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0F10 = equal(r0EF4, body.constant(int(0)));
                  ir_if *f0F0F = new(mem_ctx) ir_if(operand(r0F10).val);
                  exec_list *const f0F0F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F0F->then_instructions;

                     body.emit(assign(r0F0E, r0EF1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F0F->else_instructions;

                     ir_expression *const r0F11 = lshift(r0EF1, r0EF4);
                     ir_expression *const r0F12 = neg(r0EF4);
                     ir_expression *const r0F13 = bit_and(r0F12, body.constant(int(31)));
                     ir_expression *const r0F14 = rshift(r0EF2, r0F13);
                     body.emit(assign(r0F0E, bit_or(r0F11, r0F14), 0x01));


                  body.instructions = f0F0F_parent_instructions;
                  body.emit(f0F0F);

                  /* END IF */

                  body.emit(assign(r0EF1, r0F0E, 0x01));

                  body.emit(assign(r0EF2, r0F0D, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F0B->else_instructions;

                  ir_variable *const r0F15 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0F15, body.constant(0u), 0x01));

                  ir_variable *const r0F16 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0F16, neg(r0EF4), 0x01));

                  ir_variable *const r0F17 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0F17);
                  ir_variable *const r0F18 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0F18);
                  ir_variable *const r0F19 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0F19);
                  ir_variable *const r0F1A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0F1B = neg(r0F16);
                  body.emit(assign(r0F1A, bit_and(r0F1B, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0F1D = equal(r0F16, body.constant(int(0)));
                  ir_if *f0F1C = new(mem_ctx) ir_if(operand(r0F1D).val);
                  exec_list *const f0F1C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F1C->then_instructions;

                     body.emit(assign(r0F17, r0F15, 0x01));

                     body.emit(assign(r0F18, r0EF2, 0x01));

                     body.emit(assign(r0F19, r0EF1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F1C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F1F = less(r0F16, body.constant(int(32)));
                     ir_if *f0F1E = new(mem_ctx) ir_if(operand(r0F1F).val);
                     exec_list *const f0F1E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F1E->then_instructions;

                        body.emit(assign(r0F17, lshift(r0EF2, r0F1A), 0x01));

                        ir_expression *const r0F20 = lshift(r0EF1, r0F1A);
                        ir_expression *const r0F21 = rshift(r0EF2, r0F16);
                        body.emit(assign(r0F18, bit_or(r0F20, r0F21), 0x01));

                        body.emit(assign(r0F19, rshift(r0EF1, r0F16), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F1E->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0F23 = equal(r0F16, body.constant(int(32)));
                        ir_if *f0F22 = new(mem_ctx) ir_if(operand(r0F23).val);
                        exec_list *const f0F22_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F22->then_instructions;

                           body.emit(assign(r0F17, r0EF2, 0x01));

                           body.emit(assign(r0F18, r0EF1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0F22->else_instructions;

                           body.emit(assign(r0F15, bit_or(body.constant(0u), r0EF2), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0F25 = less(r0F16, body.constant(int(64)));
                           ir_if *f0F24 = new(mem_ctx) ir_if(operand(r0F25).val);
                           exec_list *const f0F24_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0F24->then_instructions;

                              body.emit(assign(r0F17, lshift(r0EF1, r0F1A), 0x01));

                              ir_expression *const r0F26 = bit_and(r0F16, body.constant(int(31)));
                              body.emit(assign(r0F18, rshift(r0EF1, r0F26), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0F24->else_instructions;

                              ir_variable *const r0F27 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0F29 = equal(r0F16, body.constant(int(64)));
                              ir_if *f0F28 = new(mem_ctx) ir_if(operand(r0F29).val);
                              exec_list *const f0F28_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0F28->then_instructions;

                                 body.emit(assign(r0F27, r0EF1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0F28->else_instructions;

                                 ir_expression *const r0F2A = nequal(r0EF1, body.constant(0u));
                                 ir_expression *const r0F2B = expr(ir_unop_b2i, r0F2A);
                                 body.emit(assign(r0F27, expr(ir_unop_i2u, r0F2B), 0x01));


                              body.instructions = f0F28_parent_instructions;
                              body.emit(f0F28);

                              /* END IF */

                              body.emit(assign(r0F17, r0F27, 0x01));

                              body.emit(assign(r0F18, body.constant(0u), 0x01));


                           body.instructions = f0F24_parent_instructions;
                           body.emit(f0F24);

                           /* END IF */


                        body.instructions = f0F22_parent_instructions;
                        body.emit(f0F22);

                        /* END IF */

                        body.emit(assign(r0F19, body.constant(0u), 0x01));


                     body.instructions = f0F1E_parent_instructions;
                     body.emit(f0F1E);

                     /* END IF */

                     ir_expression *const r0F2C = nequal(r0F15, body.constant(0u));
                     ir_expression *const r0F2D = expr(ir_unop_b2i, r0F2C);
                     ir_expression *const r0F2E = expr(ir_unop_i2u, r0F2D);
                     body.emit(assign(r0F17, bit_or(r0F17, r0F2E), 0x01));


                  body.instructions = f0F1C_parent_instructions;
                  body.emit(f0F1C);

                  /* END IF */

                  body.emit(assign(r0EF1, r0F19, 0x01));

                  body.emit(assign(r0EF2, r0F18, 0x01));

                  body.emit(assign(r0EF3, r0F17, 0x01));


               body.instructions = f0F0B_parent_instructions;
               body.emit(f0F0B);

               /* END IF */

               body.emit(assign(r0EF0, sub(r0EF0, r0EF4), 0x01));

               ir_variable *const r0F2F = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0F2F, r0EF0, 0x01));

               ir_variable *const r0F30 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0F30, r0EF1, 0x01));

               ir_variable *const r0F31 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0F31, r0EF2, 0x01));

               ir_variable *const r0F32 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0F32, r0EF3, 0x01));

               ir_variable *const r0F33 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0F33, body.constant(true), 0x01));

               ir_variable *const r0F34 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0F35 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0F35);
               ir_expression *const r0F36 = expr(ir_unop_u2i, r0EF3);
               body.emit(assign(r0F35, less(r0F36, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0F38 = lequal(body.constant(int(2045)), r0EF0);
               ir_if *f0F37 = new(mem_ctx) ir_if(operand(r0F38).val);
               exec_list *const f0F37_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F37->then_instructions;

                  ir_variable *const r0F39 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0F3B = less(body.constant(int(2045)), r0EF0);
                  ir_if *f0F3A = new(mem_ctx) ir_if(operand(r0F3B).val);
                  exec_list *const f0F3A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F3A->then_instructions;

                     body.emit(assign(r0F39, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F3A->else_instructions;

                     ir_variable *const r0F3C = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0F3E = equal(r0EF0, body.constant(int(2045)));
                     ir_if *f0F3D = new(mem_ctx) ir_if(operand(r0F3E).val);
                     exec_list *const f0F3D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F3D->then_instructions;

                        ir_expression *const r0F3F = equal(body.constant(2097151u), r0EF1);
                        ir_expression *const r0F40 = equal(body.constant(4294967295u), r0EF2);
                        body.emit(assign(r0F3C, logic_and(r0F3F, r0F40), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F3D->else_instructions;

                        body.emit(assign(r0F3C, body.constant(false), 0x01));


                     body.instructions = f0F3D_parent_instructions;
                     body.emit(f0F3D);

                     /* END IF */

                     body.emit(assign(r0F39, logic_and(r0F3C, r0F35), 0x01));


                  body.instructions = f0F3A_parent_instructions;
                  body.emit(f0F3A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0F41 = new(mem_ctx) ir_if(operand(r0F39).val);
                  exec_list *const f0F41_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F41->then_instructions;

                     ir_variable *const r0F42 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0F42);
                     ir_expression *const r0F43 = lshift(r0DB6, body.constant(int(31)));
                     body.emit(assign(r0F42, add(r0F43, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0F42, body.constant(0u), 0x01));

                     body.emit(assign(r0F34, r0F42, 0x03));

                     body.emit(assign(r0F33, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F41->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F45 = less(r0EF0, body.constant(int(0)));
                     ir_if *f0F44 = new(mem_ctx) ir_if(operand(r0F45).val);
                     exec_list *const f0F44_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F44->then_instructions;

                        ir_variable *const r0F46 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0F46, r0EF3, 0x01));

                        ir_variable *const r0F47 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0F47, neg(r0EF0), 0x01));

                        ir_variable *const r0F48 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0F48);
                        ir_variable *const r0F49 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0F49);
                        ir_variable *const r0F4A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0F4A);
                        ir_variable *const r0F4B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0F4C = neg(r0F47);
                        body.emit(assign(r0F4B, bit_and(r0F4C, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0F4E = equal(r0F47, body.constant(int(0)));
                        ir_if *f0F4D = new(mem_ctx) ir_if(operand(r0F4E).val);
                        exec_list *const f0F4D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F4D->then_instructions;

                           body.emit(assign(r0F48, r0EF3, 0x01));

                           body.emit(assign(r0F49, r0EF2, 0x01));

                           body.emit(assign(r0F4A, r0EF1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0F4D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0F50 = less(r0F47, body.constant(int(32)));
                           ir_if *f0F4F = new(mem_ctx) ir_if(operand(r0F50).val);
                           exec_list *const f0F4F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0F4F->then_instructions;

                              body.emit(assign(r0F48, lshift(r0EF2, r0F4B), 0x01));

                              ir_expression *const r0F51 = lshift(r0EF1, r0F4B);
                              ir_expression *const r0F52 = rshift(r0EF2, r0F47);
                              body.emit(assign(r0F49, bit_or(r0F51, r0F52), 0x01));

                              body.emit(assign(r0F4A, rshift(r0EF1, r0F47), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0F4F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0F54 = equal(r0F47, body.constant(int(32)));
                              ir_if *f0F53 = new(mem_ctx) ir_if(operand(r0F54).val);
                              exec_list *const f0F53_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0F53->then_instructions;

                                 body.emit(assign(r0F48, r0EF2, 0x01));

                                 body.emit(assign(r0F49, r0EF1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0F53->else_instructions;

                                 body.emit(assign(r0F46, bit_or(r0EF3, r0EF2), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0F56 = less(r0F47, body.constant(int(64)));
                                 ir_if *f0F55 = new(mem_ctx) ir_if(operand(r0F56).val);
                                 exec_list *const f0F55_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0F55->then_instructions;

                                    body.emit(assign(r0F48, lshift(r0EF1, r0F4B), 0x01));

                                    ir_expression *const r0F57 = bit_and(r0F47, body.constant(int(31)));
                                    body.emit(assign(r0F49, rshift(r0EF1, r0F57), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0F55->else_instructions;

                                    ir_variable *const r0F58 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0F5A = equal(r0F47, body.constant(int(64)));
                                    ir_if *f0F59 = new(mem_ctx) ir_if(operand(r0F5A).val);
                                    exec_list *const f0F59_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0F59->then_instructions;

                                       body.emit(assign(r0F58, r0EF1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0F59->else_instructions;

                                       ir_expression *const r0F5B = nequal(r0EF1, body.constant(0u));
                                       ir_expression *const r0F5C = expr(ir_unop_b2i, r0F5B);
                                       body.emit(assign(r0F58, expr(ir_unop_i2u, r0F5C), 0x01));


                                    body.instructions = f0F59_parent_instructions;
                                    body.emit(f0F59);

                                    /* END IF */

                                    body.emit(assign(r0F48, r0F58, 0x01));

                                    body.emit(assign(r0F49, body.constant(0u), 0x01));


                                 body.instructions = f0F55_parent_instructions;
                                 body.emit(f0F55);

                                 /* END IF */


                              body.instructions = f0F53_parent_instructions;
                              body.emit(f0F53);

                              /* END IF */

                              body.emit(assign(r0F4A, body.constant(0u), 0x01));


                           body.instructions = f0F4F_parent_instructions;
                           body.emit(f0F4F);

                           /* END IF */

                           ir_expression *const r0F5D = nequal(r0F46, body.constant(0u));
                           ir_expression *const r0F5E = expr(ir_unop_b2i, r0F5D);
                           ir_expression *const r0F5F = expr(ir_unop_i2u, r0F5E);
                           body.emit(assign(r0F48, bit_or(r0F48, r0F5F), 0x01));


                        body.instructions = f0F4D_parent_instructions;
                        body.emit(f0F4D);

                        /* END IF */

                        body.emit(assign(r0F30, r0F4A, 0x01));

                        body.emit(assign(r0F31, r0F49, 0x01));

                        body.emit(assign(r0F32, r0F48, 0x01));

                        body.emit(assign(r0F2F, body.constant(int(0)), 0x01));

                        body.emit(assign(r0F35, less(r0F48, body.constant(0u)), 0x01));


                     body.instructions = f0F44_parent_instructions;
                     body.emit(f0F44);

                     /* END IF */


                  body.instructions = f0F41_parent_instructions;
                  body.emit(f0F41);

                  /* END IF */


               body.instructions = f0F37_parent_instructions;
               body.emit(f0F37);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0F60 = new(mem_ctx) ir_if(operand(r0F33).val);
               exec_list *const f0F60_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F60->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0F61 = new(mem_ctx) ir_if(operand(r0F35).val);
                  exec_list *const f0F61_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F61->then_instructions;

                     ir_variable *const r0F62 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0F62, add(r0F31, body.constant(1u)), 0x01));

                     ir_expression *const r0F63 = less(r0F62, r0F31);
                     ir_expression *const r0F64 = expr(ir_unop_b2i, r0F63);
                     ir_expression *const r0F65 = expr(ir_unop_i2u, r0F64);
                     body.emit(assign(r0F30, add(r0F30, r0F65), 0x01));

                     ir_expression *const r0F66 = equal(r0F32, body.constant(0u));
                     ir_expression *const r0F67 = expr(ir_unop_b2i, r0F66);
                     ir_expression *const r0F68 = expr(ir_unop_i2u, r0F67);
                     ir_expression *const r0F69 = add(r0F32, r0F68);
                     ir_expression *const r0F6A = bit_and(r0F69, body.constant(1u));
                     ir_expression *const r0F6B = expr(ir_unop_bit_not, r0F6A);
                     body.emit(assign(r0F31, bit_and(r0F62, r0F6B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F61->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F6D = bit_or(r0F30, r0F31);
                     ir_expression *const r0F6E = equal(r0F6D, body.constant(0u));
                     ir_if *f0F6C = new(mem_ctx) ir_if(operand(r0F6E).val);
                     exec_list *const f0F6C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F6C->then_instructions;

                        body.emit(assign(r0F2F, body.constant(int(0)), 0x01));


                     body.instructions = f0F6C_parent_instructions;
                     body.emit(f0F6C);

                     /* END IF */


                  body.instructions = f0F61_parent_instructions;
                  body.emit(f0F61);

                  /* END IF */

                  ir_variable *const r0F6F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0F6F);
                  ir_expression *const r0F70 = lshift(r0DB6, body.constant(int(31)));
                  ir_expression *const r0F71 = expr(ir_unop_i2u, r0F2F);
                  ir_expression *const r0F72 = lshift(r0F71, body.constant(int(20)));
                  ir_expression *const r0F73 = add(r0F70, r0F72);
                  body.emit(assign(r0F6F, add(r0F73, r0F30), 0x02));

                  body.emit(assign(r0F6F, r0F31, 0x01));

                  body.emit(assign(r0F34, r0F6F, 0x03));

                  body.emit(assign(r0F33, body.constant(false), 0x01));


               body.instructions = f0F60_parent_instructions;
               body.emit(f0F60);

               /* END IF */

               body.emit(assign(r0DB7, r0F34, 0x03));


            body.instructions = f0EA2_parent_instructions;
            body.emit(f0EA2);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0EA0->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0F75 = equal(r0DC0, body.constant(int(2047)));
            ir_if *f0F74 = new(mem_ctx) ir_if(operand(r0F75).val);
            exec_list *const f0F74_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0F74->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0F77 = bit_or(r0DBD, r0DBE);
               ir_expression *const r0F78 = bit_or(r0DBB, r0DBC);
               ir_expression *const r0F79 = bit_or(r0F77, r0F78);
               ir_expression *const r0F7A = nequal(r0F79, body.constant(0u));
               ir_if *f0F76 = new(mem_ctx) ir_if(operand(r0F7A).val);
               exec_list *const f0F76_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F76->then_instructions;

                  ir_variable *const r0F7B = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0F7B, swizzle_x(r0DAF), 0x01));

                  ir_variable *const r0F7C = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0F7C, swizzle_x(r0DB0), 0x01));

                  ir_variable *const r0F7D = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0F7E = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0F7F = rshift(swizzle_y(r0DAF), body.constant(int(19)));
                  ir_expression *const r0F80 = bit_and(r0F7F, body.constant(4095u));
                  ir_expression *const r0F81 = equal(r0F80, body.constant(4094u));
                  ir_expression *const r0F82 = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r0F83 = bit_and(swizzle_y(r0DAF), body.constant(524287u));
                  ir_expression *const r0F84 = nequal(r0F83, body.constant(0u));
                  ir_expression *const r0F85 = logic_or(r0F82, r0F84);
                  body.emit(assign(r0F7E, logic_and(r0F81, r0F85), 0x01));

                  ir_variable *const r0F86 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0F87 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
                  ir_expression *const r0F88 = lequal(body.constant(4292870144u), r0F87);
                  ir_expression *const r0F89 = nequal(swizzle_x(r0DB0), body.constant(0u));
                  ir_expression *const r0F8A = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
                  ir_expression *const r0F8B = nequal(r0F8A, body.constant(0u));
                  ir_expression *const r0F8C = logic_or(r0F89, r0F8B);
                  body.emit(assign(r0F86, logic_and(r0F88, r0F8C), 0x01));

                  body.emit(assign(r0F7B, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

                  body.emit(assign(r0F7C, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0F8E = lshift(swizzle_y(r0DAF), body.constant(int(1)));
                  ir_expression *const r0F8F = lequal(body.constant(4292870144u), r0F8E);
                  ir_expression *const r0F90 = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r0F91 = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
                  ir_expression *const r0F92 = nequal(r0F91, body.constant(0u));
                  ir_expression *const r0F93 = logic_or(r0F90, r0F92);
                  ir_expression *const r0F94 = logic_and(r0F8F, r0F93);
                  ir_if *f0F8D = new(mem_ctx) ir_if(operand(r0F94).val);
                  exec_list *const f0F8D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F8D->then_instructions;

                     ir_variable *const r0F95 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0F97 = logic_and(r0F7E, r0F86);
                     ir_if *f0F96 = new(mem_ctx) ir_if(operand(r0F97).val);
                     exec_list *const f0F96_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F96->then_instructions;

                        body.emit(assign(r0F95, r0F7C, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F96->else_instructions;

                        body.emit(assign(r0F95, r0F7B, 0x03));


                     body.instructions = f0F96_parent_instructions;
                     body.emit(f0F96);

                     /* END IF */

                     body.emit(assign(r0F7D, r0F95, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F8D->else_instructions;

                     body.emit(assign(r0F7D, r0F7C, 0x03));


                  body.instructions = f0F8D_parent_instructions;
                  body.emit(f0F8D);

                  /* END IF */

                  body.emit(assign(r0DB7, r0F7D, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F76->else_instructions;

                  ir_constant_data r0F98_data;
                  memset(&r0F98_data, 0, sizeof(ir_constant_data));
                  r0F98_data.u[0] = 4294967295;
                  r0F98_data.u[1] = 4294967295;
                  ir_constant *const r0F98 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0F98_data);
                  body.emit(assign(r0DB7, r0F98, 0x03));


               body.instructions = f0F76_parent_instructions;
               body.emit(f0F76);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0F74->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0F9A = equal(r0DC0, body.constant(int(0)));
               ir_if *f0F99 = new(mem_ctx) ir_if(operand(r0F9A).val);
               exec_list *const f0F99_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F99->then_instructions;

                  body.emit(assign(r0DBA, body.constant(int(1)), 0x01));

                  body.emit(assign(r0DB9, body.constant(int(1)), 0x01));


               body.instructions = f0F99_parent_instructions;
               body.emit(f0F99);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0F9C = less(r0DBB, r0DBD);
               ir_if *f0F9B = new(mem_ctx) ir_if(operand(r0F9C).val);
               exec_list *const f0F9B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F9B->then_instructions;

                  ir_variable *const r0F9D = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0F9E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0F9E, sub(r0DBE, r0DBC), 0x01));

                  ir_expression *const r0F9F = sub(r0DBD, r0DBB);
                  ir_expression *const r0FA0 = less(r0DBE, r0DBC);
                  ir_expression *const r0FA1 = expr(ir_unop_b2i, r0FA0);
                  ir_expression *const r0FA2 = expr(ir_unop_i2u, r0FA1);
                  body.emit(assign(r0F9D, sub(r0F9F, r0FA2), 0x01));

                  body.emit(assign(r0DBF, add(r0DBA, body.constant(int(-1))), 0x01));

                  ir_variable *const r0FA3 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0FA3, add(r0DBF, body.constant(int(-10))), 0x01));

                  ir_variable *const r0FA4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0FA4, r0F9D, 0x01));

                  ir_variable *const r0FA5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0FA5, r0F9E, 0x01));

                  ir_variable *const r0FA6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r0FA6);
                  ir_variable *const r0FA7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0FA7);
                  /* IF CONDITION */
                  ir_expression *const r0FA9 = equal(r0F9D, body.constant(0u));
                  ir_if *f0FA8 = new(mem_ctx) ir_if(operand(r0FA9).val);
                  exec_list *const f0FA8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FA8->then_instructions;

                     body.emit(assign(r0FA4, r0F9E, 0x01));

                     body.emit(assign(r0FA5, body.constant(0u), 0x01));

                     body.emit(assign(r0FA3, add(r0FA3, body.constant(int(-32))), 0x01));


                  body.instructions = f0FA8_parent_instructions;
                  body.emit(f0FA8);

                  /* END IF */

                  ir_variable *const r0FAA = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0FAA, r0FA4, 0x01));

                  ir_variable *const r0FAB = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0FAC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0FAC);
                  /* IF CONDITION */
                  ir_expression *const r0FAE = equal(r0FA4, body.constant(0u));
                  ir_if *f0FAD = new(mem_ctx) ir_if(operand(r0FAE).val);
                  exec_list *const f0FAD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FAD->then_instructions;

                     body.emit(assign(r0FAB, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FAD->else_instructions;

                     body.emit(assign(r0FAC, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0FB0 = bit_and(r0FA4, body.constant(4294901760u));
                     ir_expression *const r0FB1 = equal(r0FB0, body.constant(0u));
                     ir_if *f0FAF = new(mem_ctx) ir_if(operand(r0FB1).val);
                     exec_list *const f0FAF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FAF->then_instructions;

                        body.emit(assign(r0FAC, body.constant(int(16)), 0x01));

                        body.emit(assign(r0FAA, lshift(r0FA4, body.constant(int(16))), 0x01));


                     body.instructions = f0FAF_parent_instructions;
                     body.emit(f0FAF);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FB3 = bit_and(r0FAA, body.constant(4278190080u));
                     ir_expression *const r0FB4 = equal(r0FB3, body.constant(0u));
                     ir_if *f0FB2 = new(mem_ctx) ir_if(operand(r0FB4).val);
                     exec_list *const f0FB2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB2->then_instructions;

                        body.emit(assign(r0FAC, add(r0FAC, body.constant(int(8))), 0x01));

                        body.emit(assign(r0FAA, lshift(r0FAA, body.constant(int(8))), 0x01));


                     body.instructions = f0FB2_parent_instructions;
                     body.emit(f0FB2);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FB6 = bit_and(r0FAA, body.constant(4026531840u));
                     ir_expression *const r0FB7 = equal(r0FB6, body.constant(0u));
                     ir_if *f0FB5 = new(mem_ctx) ir_if(operand(r0FB7).val);
                     exec_list *const f0FB5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB5->then_instructions;

                        body.emit(assign(r0FAC, add(r0FAC, body.constant(int(4))), 0x01));

                        body.emit(assign(r0FAA, lshift(r0FAA, body.constant(int(4))), 0x01));


                     body.instructions = f0FB5_parent_instructions;
                     body.emit(f0FB5);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FB9 = bit_and(r0FAA, body.constant(3221225472u));
                     ir_expression *const r0FBA = equal(r0FB9, body.constant(0u));
                     ir_if *f0FB8 = new(mem_ctx) ir_if(operand(r0FBA).val);
                     exec_list *const f0FB8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB8->then_instructions;

                        body.emit(assign(r0FAC, add(r0FAC, body.constant(int(2))), 0x01));

                        body.emit(assign(r0FAA, lshift(r0FAA, body.constant(int(2))), 0x01));


                     body.instructions = f0FB8_parent_instructions;
                     body.emit(f0FB8);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FBC = bit_and(r0FAA, body.constant(2147483648u));
                     ir_expression *const r0FBD = equal(r0FBC, body.constant(0u));
                     ir_if *f0FBB = new(mem_ctx) ir_if(operand(r0FBD).val);
                     exec_list *const f0FBB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FBB->then_instructions;

                        body.emit(assign(r0FAC, add(r0FAC, body.constant(int(1))), 0x01));


                     body.instructions = f0FBB_parent_instructions;
                     body.emit(f0FBB);

                     /* END IF */

                     body.emit(assign(r0FAB, r0FAC, 0x01));


                  body.instructions = f0FAD_parent_instructions;
                  body.emit(f0FAD);

                  /* END IF */

                  body.emit(assign(r0FA7, add(r0FAB, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0FBF = lequal(body.constant(int(0)), r0FA7);
                  ir_if *f0FBE = new(mem_ctx) ir_if(operand(r0FBF).val);
                  exec_list *const f0FBE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FBE->then_instructions;

                     body.emit(assign(r0FA6, body.constant(0u), 0x01));

                     ir_variable *const r0FC0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0FC0, lshift(r0FA5, r0FA7), 0x01));

                     ir_variable *const r0FC1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0FC3 = equal(r0FA7, body.constant(int(0)));
                     ir_if *f0FC2 = new(mem_ctx) ir_if(operand(r0FC3).val);
                     exec_list *const f0FC2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FC2->then_instructions;

                        body.emit(assign(r0FC1, r0FA4, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FC2->else_instructions;

                        ir_expression *const r0FC4 = lshift(r0FA4, r0FA7);
                        ir_expression *const r0FC5 = neg(r0FA7);
                        ir_expression *const r0FC6 = bit_and(r0FC5, body.constant(int(31)));
                        ir_expression *const r0FC7 = rshift(r0FA5, r0FC6);
                        body.emit(assign(r0FC1, bit_or(r0FC4, r0FC7), 0x01));


                     body.instructions = f0FC2_parent_instructions;
                     body.emit(f0FC2);

                     /* END IF */

                     body.emit(assign(r0FA4, r0FC1, 0x01));

                     body.emit(assign(r0FA5, r0FC0, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FBE->else_instructions;

                     ir_variable *const r0FC8 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0FC8, body.constant(0u), 0x01));

                     ir_variable *const r0FC9 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0FC9, neg(r0FA7), 0x01));

                     ir_variable *const r0FCA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0FCA);
                     ir_variable *const r0FCB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0FCB);
                     ir_variable *const r0FCC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0FCC);
                     ir_variable *const r0FCD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0FCE = neg(r0FC9);
                     body.emit(assign(r0FCD, bit_and(r0FCE, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0FD0 = equal(r0FC9, body.constant(int(0)));
                     ir_if *f0FCF = new(mem_ctx) ir_if(operand(r0FD0).val);
                     exec_list *const f0FCF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FCF->then_instructions;

                        body.emit(assign(r0FCA, r0FC8, 0x01));

                        body.emit(assign(r0FCB, r0FA5, 0x01));

                        body.emit(assign(r0FCC, r0FA4, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FCF->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0FD2 = less(r0FC9, body.constant(int(32)));
                        ir_if *f0FD1 = new(mem_ctx) ir_if(operand(r0FD2).val);
                        exec_list *const f0FD1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FD1->then_instructions;

                           body.emit(assign(r0FCA, lshift(r0FA5, r0FCD), 0x01));

                           ir_expression *const r0FD3 = lshift(r0FA4, r0FCD);
                           ir_expression *const r0FD4 = rshift(r0FA5, r0FC9);
                           body.emit(assign(r0FCB, bit_or(r0FD3, r0FD4), 0x01));

                           body.emit(assign(r0FCC, rshift(r0FA4, r0FC9), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0FD1->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0FD6 = equal(r0FC9, body.constant(int(32)));
                           ir_if *f0FD5 = new(mem_ctx) ir_if(operand(r0FD6).val);
                           exec_list *const f0FD5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0FD5->then_instructions;

                              body.emit(assign(r0FCA, r0FA5, 0x01));

                              body.emit(assign(r0FCB, r0FA4, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0FD5->else_instructions;

                              body.emit(assign(r0FC8, bit_or(body.constant(0u), r0FA5), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0FD8 = less(r0FC9, body.constant(int(64)));
                              ir_if *f0FD7 = new(mem_ctx) ir_if(operand(r0FD8).val);
                              exec_list *const f0FD7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0FD7->then_instructions;

                                 body.emit(assign(r0FCA, lshift(r0FA4, r0FCD), 0x01));

                                 ir_expression *const r0FD9 = bit_and(r0FC9, body.constant(int(31)));
                                 body.emit(assign(r0FCB, rshift(r0FA4, r0FD9), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0FD7->else_instructions;

                                 ir_variable *const r0FDA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0FDC = equal(r0FC9, body.constant(int(64)));
                                 ir_if *f0FDB = new(mem_ctx) ir_if(operand(r0FDC).val);
                                 exec_list *const f0FDB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0FDB->then_instructions;

                                    body.emit(assign(r0FDA, r0FA4, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0FDB->else_instructions;

                                    ir_expression *const r0FDD = nequal(r0FA4, body.constant(0u));
                                    ir_expression *const r0FDE = expr(ir_unop_b2i, r0FDD);
                                    body.emit(assign(r0FDA, expr(ir_unop_i2u, r0FDE), 0x01));


                                 body.instructions = f0FDB_parent_instructions;
                                 body.emit(f0FDB);

                                 /* END IF */

                                 body.emit(assign(r0FCA, r0FDA, 0x01));

                                 body.emit(assign(r0FCB, body.constant(0u), 0x01));


                              body.instructions = f0FD7_parent_instructions;
                              body.emit(f0FD7);

                              /* END IF */


                           body.instructions = f0FD5_parent_instructions;
                           body.emit(f0FD5);

                           /* END IF */

                           body.emit(assign(r0FCC, body.constant(0u), 0x01));


                        body.instructions = f0FD1_parent_instructions;
                        body.emit(f0FD1);

                        /* END IF */

                        ir_expression *const r0FDF = nequal(r0FC8, body.constant(0u));
                        ir_expression *const r0FE0 = expr(ir_unop_b2i, r0FDF);
                        ir_expression *const r0FE1 = expr(ir_unop_i2u, r0FE0);
                        body.emit(assign(r0FCA, bit_or(r0FCA, r0FE1), 0x01));


                     body.instructions = f0FCF_parent_instructions;
                     body.emit(f0FCF);

                     /* END IF */

                     body.emit(assign(r0FA4, r0FCC, 0x01));

                     body.emit(assign(r0FA5, r0FCB, 0x01));

                     body.emit(assign(r0FA6, r0FCA, 0x01));


                  body.instructions = f0FBE_parent_instructions;
                  body.emit(f0FBE);

                  /* END IF */

                  body.emit(assign(r0FA3, sub(r0FA3, r0FA7), 0x01));

                  ir_variable *const r0FE2 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0FE2, r0FA3, 0x01));

                  ir_variable *const r0FE3 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0FE3, r0FA4, 0x01));

                  ir_variable *const r0FE4 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0FE4, r0FA5, 0x01));

                  ir_variable *const r0FE5 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r0FE5, r0FA6, 0x01));

                  ir_variable *const r0FE6 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r0FE6, body.constant(true), 0x01));

                  ir_variable *const r0FE7 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0FE8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0FE8);
                  ir_expression *const r0FE9 = expr(ir_unop_u2i, r0FA6);
                  body.emit(assign(r0FE8, less(r0FE9, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0FEB = lequal(body.constant(int(2045)), r0FA3);
                  ir_if *f0FEA = new(mem_ctx) ir_if(operand(r0FEB).val);
                  exec_list *const f0FEA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FEA->then_instructions;

                     ir_variable *const r0FEC = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0FEE = less(body.constant(int(2045)), r0FA3);
                     ir_if *f0FED = new(mem_ctx) ir_if(operand(r0FEE).val);
                     exec_list *const f0FED_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FED->then_instructions;

                        body.emit(assign(r0FEC, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FED->else_instructions;

                        ir_variable *const r0FEF = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0FF1 = equal(r0FA3, body.constant(int(2045)));
                        ir_if *f0FF0 = new(mem_ctx) ir_if(operand(r0FF1).val);
                        exec_list *const f0FF0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FF0->then_instructions;

                           ir_expression *const r0FF2 = equal(body.constant(2097151u), r0FA4);
                           ir_expression *const r0FF3 = equal(body.constant(4294967295u), r0FA5);
                           body.emit(assign(r0FEF, logic_and(r0FF2, r0FF3), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0FF0->else_instructions;

                           body.emit(assign(r0FEF, body.constant(false), 0x01));


                        body.instructions = f0FF0_parent_instructions;
                        body.emit(f0FF0);

                        /* END IF */

                        body.emit(assign(r0FEC, logic_and(r0FEF, r0FE8), 0x01));


                     body.instructions = f0FED_parent_instructions;
                     body.emit(f0FED);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0FF4 = new(mem_ctx) ir_if(operand(r0FEC).val);
                     exec_list *const f0FF4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FF4->then_instructions;

                        ir_variable *const r0FF5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0FF5);
                        ir_expression *const r0FF6 = lshift(r0DB6, body.constant(int(31)));
                        body.emit(assign(r0FF5, add(r0FF6, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r0FF5, body.constant(0u), 0x01));

                        body.emit(assign(r0FE7, r0FF5, 0x03));

                        body.emit(assign(r0FE6, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FF4->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0FF8 = less(r0FA3, body.constant(int(0)));
                        ir_if *f0FF7 = new(mem_ctx) ir_if(operand(r0FF8).val);
                        exec_list *const f0FF7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FF7->then_instructions;

                           ir_variable *const r0FF9 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0FF9, r0FA6, 0x01));

                           ir_variable *const r0FFA = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0FFA, neg(r0FA3), 0x01));

                           ir_variable *const r0FFB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0FFB);
                           ir_variable *const r0FFC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0FFC);
                           ir_variable *const r0FFD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0FFD);
                           ir_variable *const r0FFE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0FFF = neg(r0FFA);
                           body.emit(assign(r0FFE, bit_and(r0FFF, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1001 = equal(r0FFA, body.constant(int(0)));
                           ir_if *f1000 = new(mem_ctx) ir_if(operand(r1001).val);
                           exec_list *const f1000_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1000->then_instructions;

                              body.emit(assign(r0FFB, r0FA6, 0x01));

                              body.emit(assign(r0FFC, r0FA5, 0x01));

                              body.emit(assign(r0FFD, r0FA4, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1000->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1003 = less(r0FFA, body.constant(int(32)));
                              ir_if *f1002 = new(mem_ctx) ir_if(operand(r1003).val);
                              exec_list *const f1002_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1002->then_instructions;

                                 body.emit(assign(r0FFB, lshift(r0FA5, r0FFE), 0x01));

                                 ir_expression *const r1004 = lshift(r0FA4, r0FFE);
                                 ir_expression *const r1005 = rshift(r0FA5, r0FFA);
                                 body.emit(assign(r0FFC, bit_or(r1004, r1005), 0x01));

                                 body.emit(assign(r0FFD, rshift(r0FA4, r0FFA), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1002->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1007 = equal(r0FFA, body.constant(int(32)));
                                 ir_if *f1006 = new(mem_ctx) ir_if(operand(r1007).val);
                                 exec_list *const f1006_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1006->then_instructions;

                                    body.emit(assign(r0FFB, r0FA5, 0x01));

                                    body.emit(assign(r0FFC, r0FA4, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1006->else_instructions;

                                    body.emit(assign(r0FF9, bit_or(r0FA6, r0FA5), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r1009 = less(r0FFA, body.constant(int(64)));
                                    ir_if *f1008 = new(mem_ctx) ir_if(operand(r1009).val);
                                    exec_list *const f1008_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1008->then_instructions;

                                       body.emit(assign(r0FFB, lshift(r0FA4, r0FFE), 0x01));

                                       ir_expression *const r100A = bit_and(r0FFA, body.constant(int(31)));
                                       body.emit(assign(r0FFC, rshift(r0FA4, r100A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1008->else_instructions;

                                       ir_variable *const r100B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r100D = equal(r0FFA, body.constant(int(64)));
                                       ir_if *f100C = new(mem_ctx) ir_if(operand(r100D).val);
                                       exec_list *const f100C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f100C->then_instructions;

                                          body.emit(assign(r100B, r0FA4, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f100C->else_instructions;

                                          ir_expression *const r100E = nequal(r0FA4, body.constant(0u));
                                          ir_expression *const r100F = expr(ir_unop_b2i, r100E);
                                          body.emit(assign(r100B, expr(ir_unop_i2u, r100F), 0x01));


                                       body.instructions = f100C_parent_instructions;
                                       body.emit(f100C);

                                       /* END IF */

                                       body.emit(assign(r0FFB, r100B, 0x01));

                                       body.emit(assign(r0FFC, body.constant(0u), 0x01));


                                    body.instructions = f1008_parent_instructions;
                                    body.emit(f1008);

                                    /* END IF */


                                 body.instructions = f1006_parent_instructions;
                                 body.emit(f1006);

                                 /* END IF */

                                 body.emit(assign(r0FFD, body.constant(0u), 0x01));


                              body.instructions = f1002_parent_instructions;
                              body.emit(f1002);

                              /* END IF */

                              ir_expression *const r1010 = nequal(r0FF9, body.constant(0u));
                              ir_expression *const r1011 = expr(ir_unop_b2i, r1010);
                              ir_expression *const r1012 = expr(ir_unop_i2u, r1011);
                              body.emit(assign(r0FFB, bit_or(r0FFB, r1012), 0x01));


                           body.instructions = f1000_parent_instructions;
                           body.emit(f1000);

                           /* END IF */

                           body.emit(assign(r0FE3, r0FFD, 0x01));

                           body.emit(assign(r0FE4, r0FFC, 0x01));

                           body.emit(assign(r0FE5, r0FFB, 0x01));

                           body.emit(assign(r0FE2, body.constant(int(0)), 0x01));

                           body.emit(assign(r0FE8, less(r0FFB, body.constant(0u)), 0x01));


                        body.instructions = f0FF7_parent_instructions;
                        body.emit(f0FF7);

                        /* END IF */


                     body.instructions = f0FF4_parent_instructions;
                     body.emit(f0FF4);

                     /* END IF */


                  body.instructions = f0FEA_parent_instructions;
                  body.emit(f0FEA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1013 = new(mem_ctx) ir_if(operand(r0FE6).val);
                  exec_list *const f1013_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1013->then_instructions;

                     /* IF CONDITION */
                     ir_if *f1014 = new(mem_ctx) ir_if(operand(r0FE8).val);
                     exec_list *const f1014_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1014->then_instructions;

                        ir_variable *const r1015 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r1015, add(r0FE4, body.constant(1u)), 0x01));

                        ir_expression *const r1016 = less(r1015, r0FE4);
                        ir_expression *const r1017 = expr(ir_unop_b2i, r1016);
                        ir_expression *const r1018 = expr(ir_unop_i2u, r1017);
                        body.emit(assign(r0FE3, add(r0FE3, r1018), 0x01));

                        ir_expression *const r1019 = equal(r0FE5, body.constant(0u));
                        ir_expression *const r101A = expr(ir_unop_b2i, r1019);
                        ir_expression *const r101B = expr(ir_unop_i2u, r101A);
                        ir_expression *const r101C = add(r0FE5, r101B);
                        ir_expression *const r101D = bit_and(r101C, body.constant(1u));
                        ir_expression *const r101E = expr(ir_unop_bit_not, r101D);
                        body.emit(assign(r0FE4, bit_and(r1015, r101E), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1014->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1020 = bit_or(r0FE3, r0FE4);
                        ir_expression *const r1021 = equal(r1020, body.constant(0u));
                        ir_if *f101F = new(mem_ctx) ir_if(operand(r1021).val);
                        exec_list *const f101F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f101F->then_instructions;

                           body.emit(assign(r0FE2, body.constant(int(0)), 0x01));


                        body.instructions = f101F_parent_instructions;
                        body.emit(f101F);

                        /* END IF */


                     body.instructions = f1014_parent_instructions;
                     body.emit(f1014);

                     /* END IF */

                     ir_variable *const r1022 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1022);
                     ir_expression *const r1023 = lshift(r0DB6, body.constant(int(31)));
                     ir_expression *const r1024 = expr(ir_unop_i2u, r0FE2);
                     ir_expression *const r1025 = lshift(r1024, body.constant(int(20)));
                     ir_expression *const r1026 = add(r1023, r1025);
                     body.emit(assign(r1022, add(r1026, r0FE3), 0x02));

                     body.emit(assign(r1022, r0FE4, 0x01));

                     body.emit(assign(r0FE7, r1022, 0x03));

                     body.emit(assign(r0FE6, body.constant(false), 0x01));


                  body.instructions = f1013_parent_instructions;
                  body.emit(f1013);

                  /* END IF */

                  body.emit(assign(r0DB7, r0FE7, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F9B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1028 = less(r0DBD, r0DBB);
                  ir_if *f1027 = new(mem_ctx) ir_if(operand(r1028).val);
                  exec_list *const f1027_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1027->then_instructions;

                     ir_variable *const r1029 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r102A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r102A, sub(r0DBC, r0DBE), 0x01));

                     ir_expression *const r102B = sub(r0DBB, r0DBD);
                     ir_expression *const r102C = less(r0DBC, r0DBE);
                     ir_expression *const r102D = expr(ir_unop_b2i, r102C);
                     ir_expression *const r102E = expr(ir_unop_i2u, r102D);
                     body.emit(assign(r1029, sub(r102B, r102E), 0x01));

                     body.emit(assign(r0DB6, bit_xor(r0DB6, body.constant(1u)), 0x01));

                     body.emit(assign(r0DBF, add(r0DB9, body.constant(int(-1))), 0x01));

                     ir_variable *const r102F = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r102F, add(r0DBF, body.constant(int(-10))), 0x01));

                     ir_variable *const r1030 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1030, r1029, 0x01));

                     ir_variable *const r1031 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1031, r102A, 0x01));

                     ir_variable *const r1032 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r1032);
                     ir_variable *const r1033 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1033);
                     /* IF CONDITION */
                     ir_expression *const r1035 = equal(r1029, body.constant(0u));
                     ir_if *f1034 = new(mem_ctx) ir_if(operand(r1035).val);
                     exec_list *const f1034_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1034->then_instructions;

                        body.emit(assign(r1030, r102A, 0x01));

                        body.emit(assign(r1031, body.constant(0u), 0x01));

                        body.emit(assign(r102F, add(r102F, body.constant(int(-32))), 0x01));


                     body.instructions = f1034_parent_instructions;
                     body.emit(f1034);

                     /* END IF */

                     ir_variable *const r1036 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1036, r1030, 0x01));

                     ir_variable *const r1037 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1038 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1038);
                     /* IF CONDITION */
                     ir_expression *const r103A = equal(r1030, body.constant(0u));
                     ir_if *f1039 = new(mem_ctx) ir_if(operand(r103A).val);
                     exec_list *const f1039_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1039->then_instructions;

                        body.emit(assign(r1037, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1039->else_instructions;

                        body.emit(assign(r1038, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r103C = bit_and(r1030, body.constant(4294901760u));
                        ir_expression *const r103D = equal(r103C, body.constant(0u));
                        ir_if *f103B = new(mem_ctx) ir_if(operand(r103D).val);
                        exec_list *const f103B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f103B->then_instructions;

                           body.emit(assign(r1038, body.constant(int(16)), 0x01));

                           body.emit(assign(r1036, lshift(r1030, body.constant(int(16))), 0x01));


                        body.instructions = f103B_parent_instructions;
                        body.emit(f103B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r103F = bit_and(r1036, body.constant(4278190080u));
                        ir_expression *const r1040 = equal(r103F, body.constant(0u));
                        ir_if *f103E = new(mem_ctx) ir_if(operand(r1040).val);
                        exec_list *const f103E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f103E->then_instructions;

                           body.emit(assign(r1038, add(r1038, body.constant(int(8))), 0x01));

                           body.emit(assign(r1036, lshift(r1036, body.constant(int(8))), 0x01));


                        body.instructions = f103E_parent_instructions;
                        body.emit(f103E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1042 = bit_and(r1036, body.constant(4026531840u));
                        ir_expression *const r1043 = equal(r1042, body.constant(0u));
                        ir_if *f1041 = new(mem_ctx) ir_if(operand(r1043).val);
                        exec_list *const f1041_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1041->then_instructions;

                           body.emit(assign(r1038, add(r1038, body.constant(int(4))), 0x01));

                           body.emit(assign(r1036, lshift(r1036, body.constant(int(4))), 0x01));


                        body.instructions = f1041_parent_instructions;
                        body.emit(f1041);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1045 = bit_and(r1036, body.constant(3221225472u));
                        ir_expression *const r1046 = equal(r1045, body.constant(0u));
                        ir_if *f1044 = new(mem_ctx) ir_if(operand(r1046).val);
                        exec_list *const f1044_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1044->then_instructions;

                           body.emit(assign(r1038, add(r1038, body.constant(int(2))), 0x01));

                           body.emit(assign(r1036, lshift(r1036, body.constant(int(2))), 0x01));


                        body.instructions = f1044_parent_instructions;
                        body.emit(f1044);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1048 = bit_and(r1036, body.constant(2147483648u));
                        ir_expression *const r1049 = equal(r1048, body.constant(0u));
                        ir_if *f1047 = new(mem_ctx) ir_if(operand(r1049).val);
                        exec_list *const f1047_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1047->then_instructions;

                           body.emit(assign(r1038, add(r1038, body.constant(int(1))), 0x01));


                        body.instructions = f1047_parent_instructions;
                        body.emit(f1047);

                        /* END IF */

                        body.emit(assign(r1037, r1038, 0x01));


                     body.instructions = f1039_parent_instructions;
                     body.emit(f1039);

                     /* END IF */

                     body.emit(assign(r1033, add(r1037, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r104B = lequal(body.constant(int(0)), r1033);
                     ir_if *f104A = new(mem_ctx) ir_if(operand(r104B).val);
                     exec_list *const f104A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f104A->then_instructions;

                        body.emit(assign(r1032, body.constant(0u), 0x01));

                        ir_variable *const r104C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r104C, lshift(r1031, r1033), 0x01));

                        ir_variable *const r104D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r104F = equal(r1033, body.constant(int(0)));
                        ir_if *f104E = new(mem_ctx) ir_if(operand(r104F).val);
                        exec_list *const f104E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f104E->then_instructions;

                           body.emit(assign(r104D, r1030, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f104E->else_instructions;

                           ir_expression *const r1050 = lshift(r1030, r1033);
                           ir_expression *const r1051 = neg(r1033);
                           ir_expression *const r1052 = bit_and(r1051, body.constant(int(31)));
                           ir_expression *const r1053 = rshift(r1031, r1052);
                           body.emit(assign(r104D, bit_or(r1050, r1053), 0x01));


                        body.instructions = f104E_parent_instructions;
                        body.emit(f104E);

                        /* END IF */

                        body.emit(assign(r1030, r104D, 0x01));

                        body.emit(assign(r1031, r104C, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f104A->else_instructions;

                        ir_variable *const r1054 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1054, body.constant(0u), 0x01));

                        ir_variable *const r1055 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1055, neg(r1033), 0x01));

                        ir_variable *const r1056 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1056);
                        ir_variable *const r1057 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1057);
                        ir_variable *const r1058 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1058);
                        ir_variable *const r1059 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r105A = neg(r1055);
                        body.emit(assign(r1059, bit_and(r105A, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r105C = equal(r1055, body.constant(int(0)));
                        ir_if *f105B = new(mem_ctx) ir_if(operand(r105C).val);
                        exec_list *const f105B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f105B->then_instructions;

                           body.emit(assign(r1056, r1054, 0x01));

                           body.emit(assign(r1057, r1031, 0x01));

                           body.emit(assign(r1058, r1030, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f105B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r105E = less(r1055, body.constant(int(32)));
                           ir_if *f105D = new(mem_ctx) ir_if(operand(r105E).val);
                           exec_list *const f105D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f105D->then_instructions;

                              body.emit(assign(r1056, lshift(r1031, r1059), 0x01));

                              ir_expression *const r105F = lshift(r1030, r1059);
                              ir_expression *const r1060 = rshift(r1031, r1055);
                              body.emit(assign(r1057, bit_or(r105F, r1060), 0x01));

                              body.emit(assign(r1058, rshift(r1030, r1055), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f105D->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1062 = equal(r1055, body.constant(int(32)));
                              ir_if *f1061 = new(mem_ctx) ir_if(operand(r1062).val);
                              exec_list *const f1061_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1061->then_instructions;

                                 body.emit(assign(r1056, r1031, 0x01));

                                 body.emit(assign(r1057, r1030, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1061->else_instructions;

                                 body.emit(assign(r1054, bit_or(body.constant(0u), r1031), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1064 = less(r1055, body.constant(int(64)));
                                 ir_if *f1063 = new(mem_ctx) ir_if(operand(r1064).val);
                                 exec_list *const f1063_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1063->then_instructions;

                                    body.emit(assign(r1056, lshift(r1030, r1059), 0x01));

                                    ir_expression *const r1065 = bit_and(r1055, body.constant(int(31)));
                                    body.emit(assign(r1057, rshift(r1030, r1065), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1063->else_instructions;

                                    ir_variable *const r1066 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1068 = equal(r1055, body.constant(int(64)));
                                    ir_if *f1067 = new(mem_ctx) ir_if(operand(r1068).val);
                                    exec_list *const f1067_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1067->then_instructions;

                                       body.emit(assign(r1066, r1030, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1067->else_instructions;

                                       ir_expression *const r1069 = nequal(r1030, body.constant(0u));
                                       ir_expression *const r106A = expr(ir_unop_b2i, r1069);
                                       body.emit(assign(r1066, expr(ir_unop_i2u, r106A), 0x01));


                                    body.instructions = f1067_parent_instructions;
                                    body.emit(f1067);

                                    /* END IF */

                                    body.emit(assign(r1056, r1066, 0x01));

                                    body.emit(assign(r1057, body.constant(0u), 0x01));


                                 body.instructions = f1063_parent_instructions;
                                 body.emit(f1063);

                                 /* END IF */


                              body.instructions = f1061_parent_instructions;
                              body.emit(f1061);

                              /* END IF */

                              body.emit(assign(r1058, body.constant(0u), 0x01));


                           body.instructions = f105D_parent_instructions;
                           body.emit(f105D);

                           /* END IF */

                           ir_expression *const r106B = nequal(r1054, body.constant(0u));
                           ir_expression *const r106C = expr(ir_unop_b2i, r106B);
                           ir_expression *const r106D = expr(ir_unop_i2u, r106C);
                           body.emit(assign(r1056, bit_or(r1056, r106D), 0x01));


                        body.instructions = f105B_parent_instructions;
                        body.emit(f105B);

                        /* END IF */

                        body.emit(assign(r1030, r1058, 0x01));

                        body.emit(assign(r1031, r1057, 0x01));

                        body.emit(assign(r1032, r1056, 0x01));


                     body.instructions = f104A_parent_instructions;
                     body.emit(f104A);

                     /* END IF */

                     body.emit(assign(r102F, sub(r102F, r1033), 0x01));

                     ir_variable *const r106E = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r106E, r102F, 0x01));

                     ir_variable *const r106F = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r106F, r1030, 0x01));

                     ir_variable *const r1070 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1070, r1031, 0x01));

                     ir_variable *const r1071 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r1071, r1032, 0x01));

                     ir_variable *const r1072 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r1072, body.constant(true), 0x01));

                     ir_variable *const r1073 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1074 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r1074);
                     ir_expression *const r1075 = expr(ir_unop_u2i, r1032);
                     body.emit(assign(r1074, less(r1075, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1077 = lequal(body.constant(int(2045)), r102F);
                     ir_if *f1076 = new(mem_ctx) ir_if(operand(r1077).val);
                     exec_list *const f1076_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1076->then_instructions;

                        ir_variable *const r1078 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r107A = less(body.constant(int(2045)), r102F);
                        ir_if *f1079 = new(mem_ctx) ir_if(operand(r107A).val);
                        exec_list *const f1079_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1079->then_instructions;

                           body.emit(assign(r1078, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1079->else_instructions;

                           ir_variable *const r107B = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r107D = equal(r102F, body.constant(int(2045)));
                           ir_if *f107C = new(mem_ctx) ir_if(operand(r107D).val);
                           exec_list *const f107C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f107C->then_instructions;

                              ir_expression *const r107E = equal(body.constant(2097151u), r1030);
                              ir_expression *const r107F = equal(body.constant(4294967295u), r1031);
                              body.emit(assign(r107B, logic_and(r107E, r107F), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f107C->else_instructions;

                              body.emit(assign(r107B, body.constant(false), 0x01));


                           body.instructions = f107C_parent_instructions;
                           body.emit(f107C);

                           /* END IF */

                           body.emit(assign(r1078, logic_and(r107B, r1074), 0x01));


                        body.instructions = f1079_parent_instructions;
                        body.emit(f1079);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1080 = new(mem_ctx) ir_if(operand(r1078).val);
                        exec_list *const f1080_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1080->then_instructions;

                           ir_variable *const r1081 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1081);
                           ir_expression *const r1082 = lshift(r0DB6, body.constant(int(31)));
                           body.emit(assign(r1081, add(r1082, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r1081, body.constant(0u), 0x01));

                           body.emit(assign(r1073, r1081, 0x03));

                           body.emit(assign(r1072, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1080->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1084 = less(r102F, body.constant(int(0)));
                           ir_if *f1083 = new(mem_ctx) ir_if(operand(r1084).val);
                           exec_list *const f1083_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1083->then_instructions;

                              ir_variable *const r1085 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1085, r1032, 0x01));

                              ir_variable *const r1086 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1086, neg(r102F), 0x01));

                              ir_variable *const r1087 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1087);
                              ir_variable *const r1088 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1088);
                              ir_variable *const r1089 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1089);
                              ir_variable *const r108A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r108B = neg(r1086);
                              body.emit(assign(r108A, bit_and(r108B, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r108D = equal(r1086, body.constant(int(0)));
                              ir_if *f108C = new(mem_ctx) ir_if(operand(r108D).val);
                              exec_list *const f108C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f108C->then_instructions;

                                 body.emit(assign(r1087, r1032, 0x01));

                                 body.emit(assign(r1088, r1031, 0x01));

                                 body.emit(assign(r1089, r1030, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f108C->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r108F = less(r1086, body.constant(int(32)));
                                 ir_if *f108E = new(mem_ctx) ir_if(operand(r108F).val);
                                 exec_list *const f108E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f108E->then_instructions;

                                    body.emit(assign(r1087, lshift(r1031, r108A), 0x01));

                                    ir_expression *const r1090 = lshift(r1030, r108A);
                                    ir_expression *const r1091 = rshift(r1031, r1086);
                                    body.emit(assign(r1088, bit_or(r1090, r1091), 0x01));

                                    body.emit(assign(r1089, rshift(r1030, r1086), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f108E->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1093 = equal(r1086, body.constant(int(32)));
                                    ir_if *f1092 = new(mem_ctx) ir_if(operand(r1093).val);
                                    exec_list *const f1092_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1092->then_instructions;

                                       body.emit(assign(r1087, r1031, 0x01));

                                       body.emit(assign(r1088, r1030, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1092->else_instructions;

                                       body.emit(assign(r1085, bit_or(r1032, r1031), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1095 = less(r1086, body.constant(int(64)));
                                       ir_if *f1094 = new(mem_ctx) ir_if(operand(r1095).val);
                                       exec_list *const f1094_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1094->then_instructions;

                                          body.emit(assign(r1087, lshift(r1030, r108A), 0x01));

                                          ir_expression *const r1096 = bit_and(r1086, body.constant(int(31)));
                                          body.emit(assign(r1088, rshift(r1030, r1096), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1094->else_instructions;

                                          ir_variable *const r1097 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1099 = equal(r1086, body.constant(int(64)));
                                          ir_if *f1098 = new(mem_ctx) ir_if(operand(r1099).val);
                                          exec_list *const f1098_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1098->then_instructions;

                                             body.emit(assign(r1097, r1030, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1098->else_instructions;

                                             ir_expression *const r109A = nequal(r1030, body.constant(0u));
                                             ir_expression *const r109B = expr(ir_unop_b2i, r109A);
                                             body.emit(assign(r1097, expr(ir_unop_i2u, r109B), 0x01));


                                          body.instructions = f1098_parent_instructions;
                                          body.emit(f1098);

                                          /* END IF */

                                          body.emit(assign(r1087, r1097, 0x01));

                                          body.emit(assign(r1088, body.constant(0u), 0x01));


                                       body.instructions = f1094_parent_instructions;
                                       body.emit(f1094);

                                       /* END IF */


                                    body.instructions = f1092_parent_instructions;
                                    body.emit(f1092);

                                    /* END IF */

                                    body.emit(assign(r1089, body.constant(0u), 0x01));


                                 body.instructions = f108E_parent_instructions;
                                 body.emit(f108E);

                                 /* END IF */

                                 ir_expression *const r109C = nequal(r1085, body.constant(0u));
                                 ir_expression *const r109D = expr(ir_unop_b2i, r109C);
                                 ir_expression *const r109E = expr(ir_unop_i2u, r109D);
                                 body.emit(assign(r1087, bit_or(r1087, r109E), 0x01));


                              body.instructions = f108C_parent_instructions;
                              body.emit(f108C);

                              /* END IF */

                              body.emit(assign(r106F, r1089, 0x01));

                              body.emit(assign(r1070, r1088, 0x01));

                              body.emit(assign(r1071, r1087, 0x01));

                              body.emit(assign(r106E, body.constant(int(0)), 0x01));

                              body.emit(assign(r1074, less(r1087, body.constant(0u)), 0x01));


                           body.instructions = f1083_parent_instructions;
                           body.emit(f1083);

                           /* END IF */


                        body.instructions = f1080_parent_instructions;
                        body.emit(f1080);

                        /* END IF */


                     body.instructions = f1076_parent_instructions;
                     body.emit(f1076);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f109F = new(mem_ctx) ir_if(operand(r1072).val);
                     exec_list *const f109F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f109F->then_instructions;

                        /* IF CONDITION */
                        ir_if *f10A0 = new(mem_ctx) ir_if(operand(r1074).val);
                        exec_list *const f10A0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10A0->then_instructions;

                           ir_variable *const r10A1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r10A1, add(r1070, body.constant(1u)), 0x01));

                           ir_expression *const r10A2 = less(r10A1, r1070);
                           ir_expression *const r10A3 = expr(ir_unop_b2i, r10A2);
                           ir_expression *const r10A4 = expr(ir_unop_i2u, r10A3);
                           body.emit(assign(r106F, add(r106F, r10A4), 0x01));

                           ir_expression *const r10A5 = equal(r1071, body.constant(0u));
                           ir_expression *const r10A6 = expr(ir_unop_b2i, r10A5);
                           ir_expression *const r10A7 = expr(ir_unop_i2u, r10A6);
                           ir_expression *const r10A8 = add(r1071, r10A7);
                           ir_expression *const r10A9 = bit_and(r10A8, body.constant(1u));
                           ir_expression *const r10AA = expr(ir_unop_bit_not, r10A9);
                           body.emit(assign(r1070, bit_and(r10A1, r10AA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10A0->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r10AC = bit_or(r106F, r1070);
                           ir_expression *const r10AD = equal(r10AC, body.constant(0u));
                           ir_if *f10AB = new(mem_ctx) ir_if(operand(r10AD).val);
                           exec_list *const f10AB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10AB->then_instructions;

                              body.emit(assign(r106E, body.constant(int(0)), 0x01));


                           body.instructions = f10AB_parent_instructions;
                           body.emit(f10AB);

                           /* END IF */


                        body.instructions = f10A0_parent_instructions;
                        body.emit(f10A0);

                        /* END IF */

                        ir_variable *const r10AE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r10AE);
                        ir_expression *const r10AF = lshift(r0DB6, body.constant(int(31)));
                        ir_expression *const r10B0 = expr(ir_unop_i2u, r106E);
                        ir_expression *const r10B1 = lshift(r10B0, body.constant(int(20)));
                        ir_expression *const r10B2 = add(r10AF, r10B1);
                        body.emit(assign(r10AE, add(r10B2, r106F), 0x02));

                        body.emit(assign(r10AE, r1070, 0x01));

                        body.emit(assign(r1073, r10AE, 0x03));

                        body.emit(assign(r1072, body.constant(false), 0x01));


                     body.instructions = f109F_parent_instructions;
                     body.emit(f109F);

                     /* END IF */

                     body.emit(assign(r0DB7, r1073, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1027->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r10B4 = less(r0DBC, r0DBE);
                     ir_if *f10B3 = new(mem_ctx) ir_if(operand(r10B4).val);
                     exec_list *const f10B3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f10B3->then_instructions;

                        ir_variable *const r10B5 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r10B6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r10B6, sub(r0DBE, r0DBC), 0x01));

                        ir_expression *const r10B7 = sub(r0DBD, r0DBB);
                        ir_expression *const r10B8 = less(r0DBE, r0DBC);
                        ir_expression *const r10B9 = expr(ir_unop_b2i, r10B8);
                        ir_expression *const r10BA = expr(ir_unop_i2u, r10B9);
                        body.emit(assign(r10B5, sub(r10B7, r10BA), 0x01));

                        body.emit(assign(r0DBF, add(r0DBA, body.constant(int(-1))), 0x01));

                        ir_variable *const r10BB = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r10BB, add(r0DBF, body.constant(int(-10))), 0x01));

                        ir_variable *const r10BC = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r10BC, r10B5, 0x01));

                        ir_variable *const r10BD = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r10BD, r10B6, 0x01));

                        ir_variable *const r10BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r10BE);
                        ir_variable *const r10BF = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r10BF);
                        /* IF CONDITION */
                        ir_expression *const r10C1 = equal(r10B5, body.constant(0u));
                        ir_if *f10C0 = new(mem_ctx) ir_if(operand(r10C1).val);
                        exec_list *const f10C0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10C0->then_instructions;

                           body.emit(assign(r10BC, r10B6, 0x01));

                           body.emit(assign(r10BD, body.constant(0u), 0x01));

                           body.emit(assign(r10BB, add(r10BB, body.constant(int(-32))), 0x01));


                        body.instructions = f10C0_parent_instructions;
                        body.emit(f10C0);

                        /* END IF */

                        ir_variable *const r10C2 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r10C2, r10BC, 0x01));

                        ir_variable *const r10C3 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r10C4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r10C4);
                        /* IF CONDITION */
                        ir_expression *const r10C6 = equal(r10BC, body.constant(0u));
                        ir_if *f10C5 = new(mem_ctx) ir_if(operand(r10C6).val);
                        exec_list *const f10C5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10C5->then_instructions;

                           body.emit(assign(r10C3, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10C5->else_instructions;

                           body.emit(assign(r10C4, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r10C8 = bit_and(r10BC, body.constant(4294901760u));
                           ir_expression *const r10C9 = equal(r10C8, body.constant(0u));
                           ir_if *f10C7 = new(mem_ctx) ir_if(operand(r10C9).val);
                           exec_list *const f10C7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10C7->then_instructions;

                              body.emit(assign(r10C4, body.constant(int(16)), 0x01));

                              body.emit(assign(r10C2, lshift(r10BC, body.constant(int(16))), 0x01));


                           body.instructions = f10C7_parent_instructions;
                           body.emit(f10C7);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10CB = bit_and(r10C2, body.constant(4278190080u));
                           ir_expression *const r10CC = equal(r10CB, body.constant(0u));
                           ir_if *f10CA = new(mem_ctx) ir_if(operand(r10CC).val);
                           exec_list *const f10CA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10CA->then_instructions;

                              body.emit(assign(r10C4, add(r10C4, body.constant(int(8))), 0x01));

                              body.emit(assign(r10C2, lshift(r10C2, body.constant(int(8))), 0x01));


                           body.instructions = f10CA_parent_instructions;
                           body.emit(f10CA);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10CE = bit_and(r10C2, body.constant(4026531840u));
                           ir_expression *const r10CF = equal(r10CE, body.constant(0u));
                           ir_if *f10CD = new(mem_ctx) ir_if(operand(r10CF).val);
                           exec_list *const f10CD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10CD->then_instructions;

                              body.emit(assign(r10C4, add(r10C4, body.constant(int(4))), 0x01));

                              body.emit(assign(r10C2, lshift(r10C2, body.constant(int(4))), 0x01));


                           body.instructions = f10CD_parent_instructions;
                           body.emit(f10CD);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10D1 = bit_and(r10C2, body.constant(3221225472u));
                           ir_expression *const r10D2 = equal(r10D1, body.constant(0u));
                           ir_if *f10D0 = new(mem_ctx) ir_if(operand(r10D2).val);
                           exec_list *const f10D0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10D0->then_instructions;

                              body.emit(assign(r10C4, add(r10C4, body.constant(int(2))), 0x01));

                              body.emit(assign(r10C2, lshift(r10C2, body.constant(int(2))), 0x01));


                           body.instructions = f10D0_parent_instructions;
                           body.emit(f10D0);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10D4 = bit_and(r10C2, body.constant(2147483648u));
                           ir_expression *const r10D5 = equal(r10D4, body.constant(0u));
                           ir_if *f10D3 = new(mem_ctx) ir_if(operand(r10D5).val);
                           exec_list *const f10D3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10D3->then_instructions;

                              body.emit(assign(r10C4, add(r10C4, body.constant(int(1))), 0x01));


                           body.instructions = f10D3_parent_instructions;
                           body.emit(f10D3);

                           /* END IF */

                           body.emit(assign(r10C3, r10C4, 0x01));


                        body.instructions = f10C5_parent_instructions;
                        body.emit(f10C5);

                        /* END IF */

                        body.emit(assign(r10BF, add(r10C3, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r10D7 = lequal(body.constant(int(0)), r10BF);
                        ir_if *f10D6 = new(mem_ctx) ir_if(operand(r10D7).val);
                        exec_list *const f10D6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10D6->then_instructions;

                           body.emit(assign(r10BE, body.constant(0u), 0x01));

                           ir_variable *const r10D8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r10D8, lshift(r10BD, r10BF), 0x01));

                           ir_variable *const r10D9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r10DB = equal(r10BF, body.constant(int(0)));
                           ir_if *f10DA = new(mem_ctx) ir_if(operand(r10DB).val);
                           exec_list *const f10DA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10DA->then_instructions;

                              body.emit(assign(r10D9, r10BC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f10DA->else_instructions;

                              ir_expression *const r10DC = lshift(r10BC, r10BF);
                              ir_expression *const r10DD = neg(r10BF);
                              ir_expression *const r10DE = bit_and(r10DD, body.constant(int(31)));
                              ir_expression *const r10DF = rshift(r10BD, r10DE);
                              body.emit(assign(r10D9, bit_or(r10DC, r10DF), 0x01));


                           body.instructions = f10DA_parent_instructions;
                           body.emit(f10DA);

                           /* END IF */

                           body.emit(assign(r10BC, r10D9, 0x01));

                           body.emit(assign(r10BD, r10D8, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10D6->else_instructions;

                           ir_variable *const r10E0 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r10E0, body.constant(0u), 0x01));

                           ir_variable *const r10E1 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r10E1, neg(r10BF), 0x01));

                           ir_variable *const r10E2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r10E2);
                           ir_variable *const r10E3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r10E3);
                           ir_variable *const r10E4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r10E4);
                           ir_variable *const r10E5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r10E6 = neg(r10E1);
                           body.emit(assign(r10E5, bit_and(r10E6, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r10E8 = equal(r10E1, body.constant(int(0)));
                           ir_if *f10E7 = new(mem_ctx) ir_if(operand(r10E8).val);
                           exec_list *const f10E7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10E7->then_instructions;

                              body.emit(assign(r10E2, r10E0, 0x01));

                              body.emit(assign(r10E3, r10BD, 0x01));

                              body.emit(assign(r10E4, r10BC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f10E7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r10EA = less(r10E1, body.constant(int(32)));
                              ir_if *f10E9 = new(mem_ctx) ir_if(operand(r10EA).val);
                              exec_list *const f10E9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f10E9->then_instructions;

                                 body.emit(assign(r10E2, lshift(r10BD, r10E5), 0x01));

                                 ir_expression *const r10EB = lshift(r10BC, r10E5);
                                 ir_expression *const r10EC = rshift(r10BD, r10E1);
                                 body.emit(assign(r10E3, bit_or(r10EB, r10EC), 0x01));

                                 body.emit(assign(r10E4, rshift(r10BC, r10E1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f10E9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r10EE = equal(r10E1, body.constant(int(32)));
                                 ir_if *f10ED = new(mem_ctx) ir_if(operand(r10EE).val);
                                 exec_list *const f10ED_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f10ED->then_instructions;

                                    body.emit(assign(r10E2, r10BD, 0x01));

                                    body.emit(assign(r10E3, r10BC, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f10ED->else_instructions;

                                    body.emit(assign(r10E0, bit_or(body.constant(0u), r10BD), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r10F0 = less(r10E1, body.constant(int(64)));
                                    ir_if *f10EF = new(mem_ctx) ir_if(operand(r10F0).val);
                                    exec_list *const f10EF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f10EF->then_instructions;

                                       body.emit(assign(r10E2, lshift(r10BC, r10E5), 0x01));

                                       ir_expression *const r10F1 = bit_and(r10E1, body.constant(int(31)));
                                       body.emit(assign(r10E3, rshift(r10BC, r10F1), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f10EF->else_instructions;

                                       ir_variable *const r10F2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r10F4 = equal(r10E1, body.constant(int(64)));
                                       ir_if *f10F3 = new(mem_ctx) ir_if(operand(r10F4).val);
                                       exec_list *const f10F3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f10F3->then_instructions;

                                          body.emit(assign(r10F2, r10BC, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f10F3->else_instructions;

                                          ir_expression *const r10F5 = nequal(r10BC, body.constant(0u));
                                          ir_expression *const r10F6 = expr(ir_unop_b2i, r10F5);
                                          body.emit(assign(r10F2, expr(ir_unop_i2u, r10F6), 0x01));


                                       body.instructions = f10F3_parent_instructions;
                                       body.emit(f10F3);

                                       /* END IF */

                                       body.emit(assign(r10E2, r10F2, 0x01));

                                       body.emit(assign(r10E3, body.constant(0u), 0x01));


                                    body.instructions = f10EF_parent_instructions;
                                    body.emit(f10EF);

                                    /* END IF */


                                 body.instructions = f10ED_parent_instructions;
                                 body.emit(f10ED);

                                 /* END IF */

                                 body.emit(assign(r10E4, body.constant(0u), 0x01));


                              body.instructions = f10E9_parent_instructions;
                              body.emit(f10E9);

                              /* END IF */

                              ir_expression *const r10F7 = nequal(r10E0, body.constant(0u));
                              ir_expression *const r10F8 = expr(ir_unop_b2i, r10F7);
                              ir_expression *const r10F9 = expr(ir_unop_i2u, r10F8);
                              body.emit(assign(r10E2, bit_or(r10E2, r10F9), 0x01));


                           body.instructions = f10E7_parent_instructions;
                           body.emit(f10E7);

                           /* END IF */

                           body.emit(assign(r10BC, r10E4, 0x01));

                           body.emit(assign(r10BD, r10E3, 0x01));

                           body.emit(assign(r10BE, r10E2, 0x01));


                        body.instructions = f10D6_parent_instructions;
                        body.emit(f10D6);

                        /* END IF */

                        body.emit(assign(r10BB, sub(r10BB, r10BF), 0x01));

                        ir_variable *const r10FA = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r10FA, r10BB, 0x01));

                        ir_variable *const r10FB = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r10FB, r10BC, 0x01));

                        ir_variable *const r10FC = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r10FC, r10BD, 0x01));

                        ir_variable *const r10FD = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r10FD, r10BE, 0x01));

                        ir_variable *const r10FE = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r10FE, body.constant(true), 0x01));

                        ir_variable *const r10FF = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r1100 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r1100);
                        ir_expression *const r1101 = expr(ir_unop_u2i, r10BE);
                        body.emit(assign(r1100, less(r1101, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1103 = lequal(body.constant(int(2045)), r10BB);
                        ir_if *f1102 = new(mem_ctx) ir_if(operand(r1103).val);
                        exec_list *const f1102_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1102->then_instructions;

                           ir_variable *const r1104 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1106 = less(body.constant(int(2045)), r10BB);
                           ir_if *f1105 = new(mem_ctx) ir_if(operand(r1106).val);
                           exec_list *const f1105_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1105->then_instructions;

                              body.emit(assign(r1104, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1105->else_instructions;

                              ir_variable *const r1107 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1109 = equal(r10BB, body.constant(int(2045)));
                              ir_if *f1108 = new(mem_ctx) ir_if(operand(r1109).val);
                              exec_list *const f1108_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1108->then_instructions;

                                 ir_expression *const r110A = equal(body.constant(2097151u), r10BC);
                                 ir_expression *const r110B = equal(body.constant(4294967295u), r10BD);
                                 body.emit(assign(r1107, logic_and(r110A, r110B), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1108->else_instructions;

                                 body.emit(assign(r1107, body.constant(false), 0x01));


                              body.instructions = f1108_parent_instructions;
                              body.emit(f1108);

                              /* END IF */

                              body.emit(assign(r1104, logic_and(r1107, r1100), 0x01));


                           body.instructions = f1105_parent_instructions;
                           body.emit(f1105);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f110C = new(mem_ctx) ir_if(operand(r1104).val);
                           exec_list *const f110C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f110C->then_instructions;

                              ir_variable *const r110D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r110D);
                              ir_expression *const r110E = lshift(r0DB6, body.constant(int(31)));
                              body.emit(assign(r110D, add(r110E, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r110D, body.constant(0u), 0x01));

                              body.emit(assign(r10FF, r110D, 0x03));

                              body.emit(assign(r10FE, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f110C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1110 = less(r10BB, body.constant(int(0)));
                              ir_if *f110F = new(mem_ctx) ir_if(operand(r1110).val);
                              exec_list *const f110F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f110F->then_instructions;

                                 ir_variable *const r1111 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r1111, r10BE, 0x01));

                                 ir_variable *const r1112 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r1112, neg(r10BB), 0x01));

                                 ir_variable *const r1113 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r1113);
                                 ir_variable *const r1114 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r1114);
                                 ir_variable *const r1115 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r1115);
                                 ir_variable *const r1116 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r1117 = neg(r1112);
                                 body.emit(assign(r1116, bit_and(r1117, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1119 = equal(r1112, body.constant(int(0)));
                                 ir_if *f1118 = new(mem_ctx) ir_if(operand(r1119).val);
                                 exec_list *const f1118_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1118->then_instructions;

                                    body.emit(assign(r1113, r10BE, 0x01));

                                    body.emit(assign(r1114, r10BD, 0x01));

                                    body.emit(assign(r1115, r10BC, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1118->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r111B = less(r1112, body.constant(int(32)));
                                    ir_if *f111A = new(mem_ctx) ir_if(operand(r111B).val);
                                    exec_list *const f111A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f111A->then_instructions;

                                       body.emit(assign(r1113, lshift(r10BD, r1116), 0x01));

                                       ir_expression *const r111C = lshift(r10BC, r1116);
                                       ir_expression *const r111D = rshift(r10BD, r1112);
                                       body.emit(assign(r1114, bit_or(r111C, r111D), 0x01));

                                       body.emit(assign(r1115, rshift(r10BC, r1112), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f111A->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r111F = equal(r1112, body.constant(int(32)));
                                       ir_if *f111E = new(mem_ctx) ir_if(operand(r111F).val);
                                       exec_list *const f111E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f111E->then_instructions;

                                          body.emit(assign(r1113, r10BD, 0x01));

                                          body.emit(assign(r1114, r10BC, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f111E->else_instructions;

                                          body.emit(assign(r1111, bit_or(r10BE, r10BD), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r1121 = less(r1112, body.constant(int(64)));
                                          ir_if *f1120 = new(mem_ctx) ir_if(operand(r1121).val);
                                          exec_list *const f1120_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1120->then_instructions;

                                             body.emit(assign(r1113, lshift(r10BC, r1116), 0x01));

                                             ir_expression *const r1122 = bit_and(r1112, body.constant(int(31)));
                                             body.emit(assign(r1114, rshift(r10BC, r1122), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1120->else_instructions;

                                             ir_variable *const r1123 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r1125 = equal(r1112, body.constant(int(64)));
                                             ir_if *f1124 = new(mem_ctx) ir_if(operand(r1125).val);
                                             exec_list *const f1124_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1124->then_instructions;

                                                body.emit(assign(r1123, r10BC, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1124->else_instructions;

                                                ir_expression *const r1126 = nequal(r10BC, body.constant(0u));
                                                ir_expression *const r1127 = expr(ir_unop_b2i, r1126);
                                                body.emit(assign(r1123, expr(ir_unop_i2u, r1127), 0x01));


                                             body.instructions = f1124_parent_instructions;
                                             body.emit(f1124);

                                             /* END IF */

                                             body.emit(assign(r1113, r1123, 0x01));

                                             body.emit(assign(r1114, body.constant(0u), 0x01));


                                          body.instructions = f1120_parent_instructions;
                                          body.emit(f1120);

                                          /* END IF */


                                       body.instructions = f111E_parent_instructions;
                                       body.emit(f111E);

                                       /* END IF */

                                       body.emit(assign(r1115, body.constant(0u), 0x01));


                                    body.instructions = f111A_parent_instructions;
                                    body.emit(f111A);

                                    /* END IF */

                                    ir_expression *const r1128 = nequal(r1111, body.constant(0u));
                                    ir_expression *const r1129 = expr(ir_unop_b2i, r1128);
                                    ir_expression *const r112A = expr(ir_unop_i2u, r1129);
                                    body.emit(assign(r1113, bit_or(r1113, r112A), 0x01));


                                 body.instructions = f1118_parent_instructions;
                                 body.emit(f1118);

                                 /* END IF */

                                 body.emit(assign(r10FB, r1115, 0x01));

                                 body.emit(assign(r10FC, r1114, 0x01));

                                 body.emit(assign(r10FD, r1113, 0x01));

                                 body.emit(assign(r10FA, body.constant(int(0)), 0x01));

                                 body.emit(assign(r1100, less(r1113, body.constant(0u)), 0x01));


                              body.instructions = f110F_parent_instructions;
                              body.emit(f110F);

                              /* END IF */


                           body.instructions = f110C_parent_instructions;
                           body.emit(f110C);

                           /* END IF */


                        body.instructions = f1102_parent_instructions;
                        body.emit(f1102);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f112B = new(mem_ctx) ir_if(operand(r10FE).val);
                        exec_list *const f112B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f112B->then_instructions;

                           /* IF CONDITION */
                           ir_if *f112C = new(mem_ctx) ir_if(operand(r1100).val);
                           exec_list *const f112C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f112C->then_instructions;

                              ir_variable *const r112D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r112D, add(r10FC, body.constant(1u)), 0x01));

                              ir_expression *const r112E = less(r112D, r10FC);
                              ir_expression *const r112F = expr(ir_unop_b2i, r112E);
                              ir_expression *const r1130 = expr(ir_unop_i2u, r112F);
                              body.emit(assign(r10FB, add(r10FB, r1130), 0x01));

                              ir_expression *const r1131 = equal(r10FD, body.constant(0u));
                              ir_expression *const r1132 = expr(ir_unop_b2i, r1131);
                              ir_expression *const r1133 = expr(ir_unop_i2u, r1132);
                              ir_expression *const r1134 = add(r10FD, r1133);
                              ir_expression *const r1135 = bit_and(r1134, body.constant(1u));
                              ir_expression *const r1136 = expr(ir_unop_bit_not, r1135);
                              body.emit(assign(r10FC, bit_and(r112D, r1136), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f112C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1138 = bit_or(r10FB, r10FC);
                              ir_expression *const r1139 = equal(r1138, body.constant(0u));
                              ir_if *f1137 = new(mem_ctx) ir_if(operand(r1139).val);
                              exec_list *const f1137_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1137->then_instructions;

                                 body.emit(assign(r10FA, body.constant(int(0)), 0x01));


                              body.instructions = f1137_parent_instructions;
                              body.emit(f1137);

                              /* END IF */


                           body.instructions = f112C_parent_instructions;
                           body.emit(f112C);

                           /* END IF */

                           ir_variable *const r113A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r113A);
                           ir_expression *const r113B = lshift(r0DB6, body.constant(int(31)));
                           ir_expression *const r113C = expr(ir_unop_i2u, r10FA);
                           ir_expression *const r113D = lshift(r113C, body.constant(int(20)));
                           ir_expression *const r113E = add(r113B, r113D);
                           body.emit(assign(r113A, add(r113E, r10FB), 0x02));

                           body.emit(assign(r113A, r10FC, 0x01));

                           body.emit(assign(r10FF, r113A, 0x03));

                           body.emit(assign(r10FE, body.constant(false), 0x01));


                        body.instructions = f112B_parent_instructions;
                        body.emit(f112B);

                        /* END IF */

                        body.emit(assign(r0DB7, r10FF, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f10B3->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1140 = less(r0DBE, r0DBC);
                        ir_if *f113F = new(mem_ctx) ir_if(operand(r1140).val);
                        exec_list *const f113F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f113F->then_instructions;

                           ir_variable *const r1141 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r1142 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r1142, sub(r0DBC, r0DBE), 0x01));

                           ir_expression *const r1143 = sub(r0DBB, r0DBD);
                           ir_expression *const r1144 = less(r0DBC, r0DBE);
                           ir_expression *const r1145 = expr(ir_unop_b2i, r1144);
                           ir_expression *const r1146 = expr(ir_unop_i2u, r1145);
                           body.emit(assign(r1141, sub(r1143, r1146), 0x01));

                           body.emit(assign(r0DB6, bit_xor(r0DB6, body.constant(1u)), 0x01));

                           body.emit(assign(r0DBF, add(r0DB9, body.constant(int(-1))), 0x01));

                           ir_variable *const r1147 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r1147, add(r0DBF, body.constant(int(-10))), 0x01));

                           ir_variable *const r1148 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r1148, r1141, 0x01));

                           ir_variable *const r1149 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r1149, r1142, 0x01));

                           ir_variable *const r114A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r114A);
                           ir_variable *const r114B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r114B);
                           /* IF CONDITION */
                           ir_expression *const r114D = equal(r1141, body.constant(0u));
                           ir_if *f114C = new(mem_ctx) ir_if(operand(r114D).val);
                           exec_list *const f114C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f114C->then_instructions;

                              body.emit(assign(r1148, r1142, 0x01));

                              body.emit(assign(r1149, body.constant(0u), 0x01));

                              body.emit(assign(r1147, add(r1147, body.constant(int(-32))), 0x01));


                           body.instructions = f114C_parent_instructions;
                           body.emit(f114C);

                           /* END IF */

                           ir_variable *const r114E = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r114E, r1148, 0x01));

                           ir_variable *const r114F = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r1150 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r1150);
                           /* IF CONDITION */
                           ir_expression *const r1152 = equal(r1148, body.constant(0u));
                           ir_if *f1151 = new(mem_ctx) ir_if(operand(r1152).val);
                           exec_list *const f1151_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1151->then_instructions;

                              body.emit(assign(r114F, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1151->else_instructions;

                              body.emit(assign(r1150, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1154 = bit_and(r1148, body.constant(4294901760u));
                              ir_expression *const r1155 = equal(r1154, body.constant(0u));
                              ir_if *f1153 = new(mem_ctx) ir_if(operand(r1155).val);
                              exec_list *const f1153_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1153->then_instructions;

                                 body.emit(assign(r1150, body.constant(int(16)), 0x01));

                                 body.emit(assign(r114E, lshift(r1148, body.constant(int(16))), 0x01));


                              body.instructions = f1153_parent_instructions;
                              body.emit(f1153);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1157 = bit_and(r114E, body.constant(4278190080u));
                              ir_expression *const r1158 = equal(r1157, body.constant(0u));
                              ir_if *f1156 = new(mem_ctx) ir_if(operand(r1158).val);
                              exec_list *const f1156_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1156->then_instructions;

                                 body.emit(assign(r1150, add(r1150, body.constant(int(8))), 0x01));

                                 body.emit(assign(r114E, lshift(r114E, body.constant(int(8))), 0x01));


                              body.instructions = f1156_parent_instructions;
                              body.emit(f1156);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r115A = bit_and(r114E, body.constant(4026531840u));
                              ir_expression *const r115B = equal(r115A, body.constant(0u));
                              ir_if *f1159 = new(mem_ctx) ir_if(operand(r115B).val);
                              exec_list *const f1159_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1159->then_instructions;

                                 body.emit(assign(r1150, add(r1150, body.constant(int(4))), 0x01));

                                 body.emit(assign(r114E, lshift(r114E, body.constant(int(4))), 0x01));


                              body.instructions = f1159_parent_instructions;
                              body.emit(f1159);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r115D = bit_and(r114E, body.constant(3221225472u));
                              ir_expression *const r115E = equal(r115D, body.constant(0u));
                              ir_if *f115C = new(mem_ctx) ir_if(operand(r115E).val);
                              exec_list *const f115C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f115C->then_instructions;

                                 body.emit(assign(r1150, add(r1150, body.constant(int(2))), 0x01));

                                 body.emit(assign(r114E, lshift(r114E, body.constant(int(2))), 0x01));


                              body.instructions = f115C_parent_instructions;
                              body.emit(f115C);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1160 = bit_and(r114E, body.constant(2147483648u));
                              ir_expression *const r1161 = equal(r1160, body.constant(0u));
                              ir_if *f115F = new(mem_ctx) ir_if(operand(r1161).val);
                              exec_list *const f115F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f115F->then_instructions;

                                 body.emit(assign(r1150, add(r1150, body.constant(int(1))), 0x01));


                              body.instructions = f115F_parent_instructions;
                              body.emit(f115F);

                              /* END IF */

                              body.emit(assign(r114F, r1150, 0x01));


                           body.instructions = f1151_parent_instructions;
                           body.emit(f1151);

                           /* END IF */

                           body.emit(assign(r114B, add(r114F, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1163 = lequal(body.constant(int(0)), r114B);
                           ir_if *f1162 = new(mem_ctx) ir_if(operand(r1163).val);
                           exec_list *const f1162_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1162->then_instructions;

                              body.emit(assign(r114A, body.constant(0u), 0x01));

                              ir_variable *const r1164 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r1164, lshift(r1149, r114B), 0x01));

                              ir_variable *const r1165 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1167 = equal(r114B, body.constant(int(0)));
                              ir_if *f1166 = new(mem_ctx) ir_if(operand(r1167).val);
                              exec_list *const f1166_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1166->then_instructions;

                                 body.emit(assign(r1165, r1148, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1166->else_instructions;

                                 ir_expression *const r1168 = lshift(r1148, r114B);
                                 ir_expression *const r1169 = neg(r114B);
                                 ir_expression *const r116A = bit_and(r1169, body.constant(int(31)));
                                 ir_expression *const r116B = rshift(r1149, r116A);
                                 body.emit(assign(r1165, bit_or(r1168, r116B), 0x01));


                              body.instructions = f1166_parent_instructions;
                              body.emit(f1166);

                              /* END IF */

                              body.emit(assign(r1148, r1165, 0x01));

                              body.emit(assign(r1149, r1164, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1162->else_instructions;

                              ir_variable *const r116C = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r116C, body.constant(0u), 0x01));

                              ir_variable *const r116D = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r116D, neg(r114B), 0x01));

                              ir_variable *const r116E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r116E);
                              ir_variable *const r116F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r116F);
                              ir_variable *const r1170 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1170);
                              ir_variable *const r1171 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1172 = neg(r116D);
                              body.emit(assign(r1171, bit_and(r1172, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1174 = equal(r116D, body.constant(int(0)));
                              ir_if *f1173 = new(mem_ctx) ir_if(operand(r1174).val);
                              exec_list *const f1173_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1173->then_instructions;

                                 body.emit(assign(r116E, r116C, 0x01));

                                 body.emit(assign(r116F, r1149, 0x01));

                                 body.emit(assign(r1170, r1148, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1173->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1176 = less(r116D, body.constant(int(32)));
                                 ir_if *f1175 = new(mem_ctx) ir_if(operand(r1176).val);
                                 exec_list *const f1175_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1175->then_instructions;

                                    body.emit(assign(r116E, lshift(r1149, r1171), 0x01));

                                    ir_expression *const r1177 = lshift(r1148, r1171);
                                    ir_expression *const r1178 = rshift(r1149, r116D);
                                    body.emit(assign(r116F, bit_or(r1177, r1178), 0x01));

                                    body.emit(assign(r1170, rshift(r1148, r116D), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1175->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r117A = equal(r116D, body.constant(int(32)));
                                    ir_if *f1179 = new(mem_ctx) ir_if(operand(r117A).val);
                                    exec_list *const f1179_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1179->then_instructions;

                                       body.emit(assign(r116E, r1149, 0x01));

                                       body.emit(assign(r116F, r1148, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1179->else_instructions;

                                       body.emit(assign(r116C, bit_or(body.constant(0u), r1149), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r117C = less(r116D, body.constant(int(64)));
                                       ir_if *f117B = new(mem_ctx) ir_if(operand(r117C).val);
                                       exec_list *const f117B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f117B->then_instructions;

                                          body.emit(assign(r116E, lshift(r1148, r1171), 0x01));

                                          ir_expression *const r117D = bit_and(r116D, body.constant(int(31)));
                                          body.emit(assign(r116F, rshift(r1148, r117D), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f117B->else_instructions;

                                          ir_variable *const r117E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1180 = equal(r116D, body.constant(int(64)));
                                          ir_if *f117F = new(mem_ctx) ir_if(operand(r1180).val);
                                          exec_list *const f117F_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f117F->then_instructions;

                                             body.emit(assign(r117E, r1148, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f117F->else_instructions;

                                             ir_expression *const r1181 = nequal(r1148, body.constant(0u));
                                             ir_expression *const r1182 = expr(ir_unop_b2i, r1181);
                                             body.emit(assign(r117E, expr(ir_unop_i2u, r1182), 0x01));


                                          body.instructions = f117F_parent_instructions;
                                          body.emit(f117F);

                                          /* END IF */

                                          body.emit(assign(r116E, r117E, 0x01));

                                          body.emit(assign(r116F, body.constant(0u), 0x01));


                                       body.instructions = f117B_parent_instructions;
                                       body.emit(f117B);

                                       /* END IF */


                                    body.instructions = f1179_parent_instructions;
                                    body.emit(f1179);

                                    /* END IF */

                                    body.emit(assign(r1170, body.constant(0u), 0x01));


                                 body.instructions = f1175_parent_instructions;
                                 body.emit(f1175);

                                 /* END IF */

                                 ir_expression *const r1183 = nequal(r116C, body.constant(0u));
                                 ir_expression *const r1184 = expr(ir_unop_b2i, r1183);
                                 ir_expression *const r1185 = expr(ir_unop_i2u, r1184);
                                 body.emit(assign(r116E, bit_or(r116E, r1185), 0x01));


                              body.instructions = f1173_parent_instructions;
                              body.emit(f1173);

                              /* END IF */

                              body.emit(assign(r1148, r1170, 0x01));

                              body.emit(assign(r1149, r116F, 0x01));

                              body.emit(assign(r114A, r116E, 0x01));


                           body.instructions = f1162_parent_instructions;
                           body.emit(f1162);

                           /* END IF */

                           body.emit(assign(r1147, sub(r1147, r114B), 0x01));

                           ir_variable *const r1186 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r1186, r1147, 0x01));

                           ir_variable *const r1187 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r1187, r1148, 0x01));

                           ir_variable *const r1188 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r1188, r1149, 0x01));

                           ir_variable *const r1189 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r1189, r114A, 0x01));

                           ir_variable *const r118A = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r118A, body.constant(true), 0x01));

                           ir_variable *const r118B = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r118C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r118C);
                           ir_expression *const r118D = expr(ir_unop_u2i, r114A);
                           body.emit(assign(r118C, less(r118D, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r118F = lequal(body.constant(int(2045)), r1147);
                           ir_if *f118E = new(mem_ctx) ir_if(operand(r118F).val);
                           exec_list *const f118E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f118E->then_instructions;

                              ir_variable *const r1190 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1192 = less(body.constant(int(2045)), r1147);
                              ir_if *f1191 = new(mem_ctx) ir_if(operand(r1192).val);
                              exec_list *const f1191_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1191->then_instructions;

                                 body.emit(assign(r1190, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1191->else_instructions;

                                 ir_variable *const r1193 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1195 = equal(r1147, body.constant(int(2045)));
                                 ir_if *f1194 = new(mem_ctx) ir_if(operand(r1195).val);
                                 exec_list *const f1194_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1194->then_instructions;

                                    ir_expression *const r1196 = equal(body.constant(2097151u), r1148);
                                    ir_expression *const r1197 = equal(body.constant(4294967295u), r1149);
                                    body.emit(assign(r1193, logic_and(r1196, r1197), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1194->else_instructions;

                                    body.emit(assign(r1193, body.constant(false), 0x01));


                                 body.instructions = f1194_parent_instructions;
                                 body.emit(f1194);

                                 /* END IF */

                                 body.emit(assign(r1190, logic_and(r1193, r118C), 0x01));


                              body.instructions = f1191_parent_instructions;
                              body.emit(f1191);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f1198 = new(mem_ctx) ir_if(operand(r1190).val);
                              exec_list *const f1198_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1198->then_instructions;

                                 ir_variable *const r1199 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r1199);
                                 ir_expression *const r119A = lshift(r0DB6, body.constant(int(31)));
                                 body.emit(assign(r1199, add(r119A, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r1199, body.constant(0u), 0x01));

                                 body.emit(assign(r118B, r1199, 0x03));

                                 body.emit(assign(r118A, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1198->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r119C = less(r1147, body.constant(int(0)));
                                 ir_if *f119B = new(mem_ctx) ir_if(operand(r119C).val);
                                 exec_list *const f119B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f119B->then_instructions;

                                    ir_variable *const r119D = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r119D, r114A, 0x01));

                                    ir_variable *const r119E = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r119E, neg(r1147), 0x01));

                                    ir_variable *const r119F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r119F);
                                    ir_variable *const r11A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r11A0);
                                    ir_variable *const r11A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r11A1);
                                    ir_variable *const r11A2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r11A3 = neg(r119E);
                                    body.emit(assign(r11A2, bit_and(r11A3, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r11A5 = equal(r119E, body.constant(int(0)));
                                    ir_if *f11A4 = new(mem_ctx) ir_if(operand(r11A5).val);
                                    exec_list *const f11A4_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f11A4->then_instructions;

                                       body.emit(assign(r119F, r114A, 0x01));

                                       body.emit(assign(r11A0, r1149, 0x01));

                                       body.emit(assign(r11A1, r1148, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f11A4->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r11A7 = less(r119E, body.constant(int(32)));
                                       ir_if *f11A6 = new(mem_ctx) ir_if(operand(r11A7).val);
                                       exec_list *const f11A6_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f11A6->then_instructions;

                                          body.emit(assign(r119F, lshift(r1149, r11A2), 0x01));

                                          ir_expression *const r11A8 = lshift(r1148, r11A2);
                                          ir_expression *const r11A9 = rshift(r1149, r119E);
                                          body.emit(assign(r11A0, bit_or(r11A8, r11A9), 0x01));

                                          body.emit(assign(r11A1, rshift(r1148, r119E), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f11A6->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r11AB = equal(r119E, body.constant(int(32)));
                                          ir_if *f11AA = new(mem_ctx) ir_if(operand(r11AB).val);
                                          exec_list *const f11AA_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f11AA->then_instructions;

                                             body.emit(assign(r119F, r1149, 0x01));

                                             body.emit(assign(r11A0, r1148, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f11AA->else_instructions;

                                             body.emit(assign(r119D, bit_or(r114A, r1149), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r11AD = less(r119E, body.constant(int(64)));
                                             ir_if *f11AC = new(mem_ctx) ir_if(operand(r11AD).val);
                                             exec_list *const f11AC_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f11AC->then_instructions;

                                                body.emit(assign(r119F, lshift(r1148, r11A2), 0x01));

                                                ir_expression *const r11AE = bit_and(r119E, body.constant(int(31)));
                                                body.emit(assign(r11A0, rshift(r1148, r11AE), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f11AC->else_instructions;

                                                ir_variable *const r11AF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r11B1 = equal(r119E, body.constant(int(64)));
                                                ir_if *f11B0 = new(mem_ctx) ir_if(operand(r11B1).val);
                                                exec_list *const f11B0_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f11B0->then_instructions;

                                                   body.emit(assign(r11AF, r1148, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f11B0->else_instructions;

                                                   ir_expression *const r11B2 = nequal(r1148, body.constant(0u));
                                                   ir_expression *const r11B3 = expr(ir_unop_b2i, r11B2);
                                                   body.emit(assign(r11AF, expr(ir_unop_i2u, r11B3), 0x01));


                                                body.instructions = f11B0_parent_instructions;
                                                body.emit(f11B0);

                                                /* END IF */

                                                body.emit(assign(r119F, r11AF, 0x01));

                                                body.emit(assign(r11A0, body.constant(0u), 0x01));


                                             body.instructions = f11AC_parent_instructions;
                                             body.emit(f11AC);

                                             /* END IF */


                                          body.instructions = f11AA_parent_instructions;
                                          body.emit(f11AA);

                                          /* END IF */

                                          body.emit(assign(r11A1, body.constant(0u), 0x01));


                                       body.instructions = f11A6_parent_instructions;
                                       body.emit(f11A6);

                                       /* END IF */

                                       ir_expression *const r11B4 = nequal(r119D, body.constant(0u));
                                       ir_expression *const r11B5 = expr(ir_unop_b2i, r11B4);
                                       ir_expression *const r11B6 = expr(ir_unop_i2u, r11B5);
                                       body.emit(assign(r119F, bit_or(r119F, r11B6), 0x01));


                                    body.instructions = f11A4_parent_instructions;
                                    body.emit(f11A4);

                                    /* END IF */

                                    body.emit(assign(r1187, r11A1, 0x01));

                                    body.emit(assign(r1188, r11A0, 0x01));

                                    body.emit(assign(r1189, r119F, 0x01));

                                    body.emit(assign(r1186, body.constant(int(0)), 0x01));

                                    body.emit(assign(r118C, less(r119F, body.constant(0u)), 0x01));


                                 body.instructions = f119B_parent_instructions;
                                 body.emit(f119B);

                                 /* END IF */


                              body.instructions = f1198_parent_instructions;
                              body.emit(f1198);

                              /* END IF */


                           body.instructions = f118E_parent_instructions;
                           body.emit(f118E);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f11B7 = new(mem_ctx) ir_if(operand(r118A).val);
                           exec_list *const f11B7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f11B7->then_instructions;

                              /* IF CONDITION */
                              ir_if *f11B8 = new(mem_ctx) ir_if(operand(r118C).val);
                              exec_list *const f11B8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f11B8->then_instructions;

                                 ir_variable *const r11B9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r11B9, add(r1188, body.constant(1u)), 0x01));

                                 ir_expression *const r11BA = less(r11B9, r1188);
                                 ir_expression *const r11BB = expr(ir_unop_b2i, r11BA);
                                 ir_expression *const r11BC = expr(ir_unop_i2u, r11BB);
                                 body.emit(assign(r1187, add(r1187, r11BC), 0x01));

                                 ir_expression *const r11BD = equal(r1189, body.constant(0u));
                                 ir_expression *const r11BE = expr(ir_unop_b2i, r11BD);
                                 ir_expression *const r11BF = expr(ir_unop_i2u, r11BE);
                                 ir_expression *const r11C0 = add(r1189, r11BF);
                                 ir_expression *const r11C1 = bit_and(r11C0, body.constant(1u));
                                 ir_expression *const r11C2 = expr(ir_unop_bit_not, r11C1);
                                 body.emit(assign(r1188, bit_and(r11B9, r11C2), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f11B8->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r11C4 = bit_or(r1187, r1188);
                                 ir_expression *const r11C5 = equal(r11C4, body.constant(0u));
                                 ir_if *f11C3 = new(mem_ctx) ir_if(operand(r11C5).val);
                                 exec_list *const f11C3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f11C3->then_instructions;

                                    body.emit(assign(r1186, body.constant(int(0)), 0x01));


                                 body.instructions = f11C3_parent_instructions;
                                 body.emit(f11C3);

                                 /* END IF */


                              body.instructions = f11B8_parent_instructions;
                              body.emit(f11B8);

                              /* END IF */

                              ir_variable *const r11C6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r11C6);
                              ir_expression *const r11C7 = lshift(r0DB6, body.constant(int(31)));
                              ir_expression *const r11C8 = expr(ir_unop_i2u, r1186);
                              ir_expression *const r11C9 = lshift(r11C8, body.constant(int(20)));
                              ir_expression *const r11CA = add(r11C7, r11C9);
                              body.emit(assign(r11C6, add(r11CA, r1187), 0x02));

                              body.emit(assign(r11C6, r1188, 0x01));

                              body.emit(assign(r118B, r11C6, 0x03));

                              body.emit(assign(r118A, body.constant(false), 0x01));


                           body.instructions = f11B7_parent_instructions;
                           body.emit(f11B7);

                           /* END IF */

                           body.emit(assign(r0DB7, r118B, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f113F->else_instructions;

                           ir_variable *const r11CB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r11CB);
                           body.emit(assign(r11CB, body.constant(0u), 0x02));

                           body.emit(assign(r11CB, body.constant(0u), 0x01));

                           body.emit(assign(r0DB7, r11CB, 0x03));


                        body.instructions = f113F_parent_instructions;
                        body.emit(f113F);

                        /* END IF */


                     body.instructions = f10B3_parent_instructions;
                     body.emit(f10B3);

                     /* END IF */


                  body.instructions = f1027_parent_instructions;
                  body.emit(f1027);

                  /* END IF */


               body.instructions = f0F9B_parent_instructions;
               body.emit(f0F9B);

               /* END IF */


            body.instructions = f0F74_parent_instructions;
            body.emit(f0F74);

            /* END IF */


         body.instructions = f0EA0_parent_instructions;
         body.emit(f0EA0);

         /* END IF */


      body.instructions = f0DD0_parent_instructions;
      body.emit(f0DD0);

      /* END IF */

      body.emit(assign(r0DB1, r0DB7, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0DB4->else_instructions;

      ir_variable *const r11CC = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r11CC, body.constant(true), 0x01));

      ir_variable *const r11CD = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r11CE = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r11CE);
      ir_variable *const r11CF = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r11CF);
      ir_variable *const r11D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r11D0);
      ir_variable *const r11D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r11D1);
      ir_variable *const r11D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r11D2);
      ir_variable *const r11D3 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r11D3);
      ir_variable *const r11D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r11D4);
      ir_variable *const r11D5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r11D5);
      body.emit(assign(r11D5, body.constant(0u), 0x01));

      body.emit(assign(r11D4, body.constant(0u), 0x01));

      ir_variable *const r11D6 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r11D6, swizzle_x(r0DAF), 0x01));

      body.emit(assign(r11D2, r11D6, 0x01));

      ir_variable *const r11D7 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r11D7, bit_and(swizzle_y(r0DAF), body.constant(1048575u)), 0x01));

      body.emit(assign(r11D1, r11D7, 0x01));

      ir_variable *const r11D8 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r11D8, swizzle_x(r0DB0), 0x01));

      body.emit(assign(r11D0, r11D8, 0x01));

      ir_variable *const r11D9 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r11D9, bit_and(swizzle_y(r0DB0), body.constant(1048575u)), 0x01));

      body.emit(assign(r11CF, r11D9, 0x01));

      ir_variable *const r11DA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r11DB = rshift(swizzle_y(r0DAF), body.constant(int(20)));
      ir_expression *const r11DC = bit_and(r11DB, body.constant(2047u));
      body.emit(assign(r11DA, expr(ir_unop_u2i, r11DC), 0x01));

      ir_variable *const r11DD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r11DE = rshift(swizzle_y(r0DB0), body.constant(int(20)));
      ir_expression *const r11DF = bit_and(r11DE, body.constant(2047u));
      body.emit(assign(r11DD, expr(ir_unop_u2i, r11DF), 0x01));

      ir_variable *const r11E0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r11E0, sub(r11DA, r11DD), 0x01));

      body.emit(assign(r11CE, r11E0, 0x01));

      /* IF CONDITION */
      ir_expression *const r11E2 = less(body.constant(int(0)), r11E0);
      ir_if *f11E1 = new(mem_ctx) ir_if(operand(r11E2).val);
      exec_list *const f11E1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f11E1->then_instructions;

         /* IF CONDITION */
         ir_expression *const r11E4 = equal(r11DA, body.constant(int(2047)));
         ir_if *f11E3 = new(mem_ctx) ir_if(operand(r11E4).val);
         exec_list *const f11E3_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f11E3->then_instructions;

            /* IF CONDITION */
            ir_expression *const r11E6 = bit_or(r11D7, swizzle_x(r0DAF));
            ir_expression *const r11E7 = nequal(r11E6, body.constant(0u));
            ir_if *f11E5 = new(mem_ctx) ir_if(operand(r11E7).val);
            exec_list *const f11E5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f11E5->then_instructions;

               ir_variable *const r11E8 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r11E8, swizzle_x(r0DAF), 0x01));

               ir_variable *const r11E9 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r11E9, swizzle_x(r0DB0), 0x01));

               ir_variable *const r11EA = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r11EB = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r11EC = rshift(swizzle_y(r0DAF), body.constant(int(19)));
               ir_expression *const r11ED = bit_and(r11EC, body.constant(4095u));
               ir_expression *const r11EE = equal(r11ED, body.constant(4094u));
               ir_expression *const r11EF = nequal(swizzle_x(r0DAF), body.constant(0u));
               ir_expression *const r11F0 = bit_and(swizzle_y(r0DAF), body.constant(524287u));
               ir_expression *const r11F1 = nequal(r11F0, body.constant(0u));
               ir_expression *const r11F2 = logic_or(r11EF, r11F1);
               body.emit(assign(r11EB, logic_and(r11EE, r11F2), 0x01));

               ir_variable *const r11F3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r11F4 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
               ir_expression *const r11F5 = lequal(body.constant(4292870144u), r11F4);
               ir_expression *const r11F6 = nequal(swizzle_x(r0DB0), body.constant(0u));
               ir_expression *const r11F7 = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
               ir_expression *const r11F8 = nequal(r11F7, body.constant(0u));
               ir_expression *const r11F9 = logic_or(r11F6, r11F8);
               body.emit(assign(r11F3, logic_and(r11F5, r11F9), 0x01));

               body.emit(assign(r11E8, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

               body.emit(assign(r11E9, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r11FB = lshift(swizzle_y(r0DAF), body.constant(int(1)));
               ir_expression *const r11FC = lequal(body.constant(4292870144u), r11FB);
               ir_expression *const r11FD = nequal(swizzle_x(r0DAF), body.constant(0u));
               ir_expression *const r11FE = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
               ir_expression *const r11FF = nequal(r11FE, body.constant(0u));
               ir_expression *const r1200 = logic_or(r11FD, r11FF);
               ir_expression *const r1201 = logic_and(r11FC, r1200);
               ir_if *f11FA = new(mem_ctx) ir_if(operand(r1201).val);
               exec_list *const f11FA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f11FA->then_instructions;

                  ir_variable *const r1202 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1204 = logic_and(r11EB, r11F3);
                  ir_if *f1203 = new(mem_ctx) ir_if(operand(r1204).val);
                  exec_list *const f1203_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1203->then_instructions;

                     body.emit(assign(r1202, r11E9, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1203->else_instructions;

                     body.emit(assign(r1202, r11E8, 0x03));


                  body.instructions = f1203_parent_instructions;
                  body.emit(f1203);

                  /* END IF */

                  body.emit(assign(r11EA, r1202, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f11FA->else_instructions;

                  body.emit(assign(r11EA, r11E9, 0x03));


               body.instructions = f11FA_parent_instructions;
               body.emit(f11FA);

               /* END IF */

               body.emit(assign(r11CD, r11EA, 0x03));

               body.emit(assign(r11CC, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f11E5->else_instructions;

               body.emit(assign(r11CD, r0DAF, 0x03));

               body.emit(assign(r11CC, body.constant(false), 0x01));


            body.instructions = f11E5_parent_instructions;
            body.emit(f11E5);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f11E3->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1206 = equal(r11DD, body.constant(int(0)));
            ir_if *f1205 = new(mem_ctx) ir_if(operand(r1206).val);
            exec_list *const f1205_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1205->then_instructions;

               body.emit(assign(r11CE, add(r11E0, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1205->else_instructions;

               body.emit(assign(r11CF, bit_or(r11D9, body.constant(1048576u)), 0x01));


            body.instructions = f1205_parent_instructions;
            body.emit(f1205);

            /* END IF */

            ir_variable *const r1207 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r1207, body.constant(0u), 0x01));

            ir_variable *const r1208 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r1208);
            ir_variable *const r1209 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1209);
            ir_variable *const r120A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r120A);
            ir_variable *const r120B = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r120C = neg(r11CE);
            body.emit(assign(r120B, bit_and(r120C, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r120E = equal(r11CE, body.constant(int(0)));
            ir_if *f120D = new(mem_ctx) ir_if(operand(r120E).val);
            exec_list *const f120D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f120D->then_instructions;

               body.emit(assign(r1208, r1207, 0x01));

               body.emit(assign(r1209, r11D8, 0x01));

               body.emit(assign(r120A, r11CF, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f120D->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1210 = less(r11CE, body.constant(int(32)));
               ir_if *f120F = new(mem_ctx) ir_if(operand(r1210).val);
               exec_list *const f120F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f120F->then_instructions;

                  body.emit(assign(r1208, lshift(swizzle_x(r0DB0), r120B), 0x01));

                  ir_expression *const r1211 = lshift(r11CF, r120B);
                  ir_expression *const r1212 = rshift(swizzle_x(r0DB0), r11CE);
                  body.emit(assign(r1209, bit_or(r1211, r1212), 0x01));

                  body.emit(assign(r120A, rshift(r11CF, r11CE), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f120F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1214 = equal(r11CE, body.constant(int(32)));
                  ir_if *f1213 = new(mem_ctx) ir_if(operand(r1214).val);
                  exec_list *const f1213_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1213->then_instructions;

                     body.emit(assign(r1208, r11D8, 0x01));

                     body.emit(assign(r1209, r11CF, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1213->else_instructions;

                     body.emit(assign(r1207, bit_or(body.constant(0u), swizzle_x(r0DB0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1216 = less(r11CE, body.constant(int(64)));
                     ir_if *f1215 = new(mem_ctx) ir_if(operand(r1216).val);
                     exec_list *const f1215_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1215->then_instructions;

                        body.emit(assign(r1208, lshift(r11CF, r120B), 0x01));

                        ir_expression *const r1217 = bit_and(r11CE, body.constant(int(31)));
                        body.emit(assign(r1209, rshift(r11CF, r1217), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1215->else_instructions;

                        ir_variable *const r1218 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r121A = equal(r11CE, body.constant(int(64)));
                        ir_if *f1219 = new(mem_ctx) ir_if(operand(r121A).val);
                        exec_list *const f1219_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1219->then_instructions;

                           body.emit(assign(r1218, r11CF, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1219->else_instructions;

                           ir_expression *const r121B = nequal(r11CF, body.constant(0u));
                           ir_expression *const r121C = expr(ir_unop_b2i, r121B);
                           body.emit(assign(r1218, expr(ir_unop_i2u, r121C), 0x01));


                        body.instructions = f1219_parent_instructions;
                        body.emit(f1219);

                        /* END IF */

                        body.emit(assign(r1208, r1218, 0x01));

                        body.emit(assign(r1209, body.constant(0u), 0x01));


                     body.instructions = f1215_parent_instructions;
                     body.emit(f1215);

                     /* END IF */


                  body.instructions = f1213_parent_instructions;
                  body.emit(f1213);

                  /* END IF */

                  body.emit(assign(r120A, body.constant(0u), 0x01));


               body.instructions = f120F_parent_instructions;
               body.emit(f120F);

               /* END IF */

               ir_expression *const r121D = nequal(r1207, body.constant(0u));
               ir_expression *const r121E = expr(ir_unop_b2i, r121D);
               ir_expression *const r121F = expr(ir_unop_i2u, r121E);
               body.emit(assign(r1208, bit_or(r1208, r121F), 0x01));


            body.instructions = f120D_parent_instructions;
            body.emit(f120D);

            /* END IF */

            body.emit(assign(r11CF, r120A, 0x01));

            body.emit(assign(r11D0, r1209, 0x01));

            body.emit(assign(r11D4, r1208, 0x01));

            body.emit(assign(r11D3, r11DA, 0x01));


         body.instructions = f11E3_parent_instructions;
         body.emit(f11E3);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f11E1->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1221 = less(r11CE, body.constant(int(0)));
         ir_if *f1220 = new(mem_ctx) ir_if(operand(r1221).val);
         exec_list *const f1220_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1220->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1223 = equal(r11DD, body.constant(int(2047)));
            ir_if *f1222 = new(mem_ctx) ir_if(operand(r1223).val);
            exec_list *const f1222_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1222->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1225 = bit_or(r11CF, r11D0);
               ir_expression *const r1226 = nequal(r1225, body.constant(0u));
               ir_if *f1224 = new(mem_ctx) ir_if(operand(r1226).val);
               exec_list *const f1224_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1224->then_instructions;

                  ir_variable *const r1227 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1227, swizzle_x(r0DAF), 0x01));

                  ir_variable *const r1228 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r1228, swizzle_x(r0DB0), 0x01));

                  ir_variable *const r1229 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r122A = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r122B = rshift(swizzle_y(r0DAF), body.constant(int(19)));
                  ir_expression *const r122C = bit_and(r122B, body.constant(4095u));
                  ir_expression *const r122D = equal(r122C, body.constant(4094u));
                  ir_expression *const r122E = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r122F = bit_and(swizzle_y(r0DAF), body.constant(524287u));
                  ir_expression *const r1230 = nequal(r122F, body.constant(0u));
                  ir_expression *const r1231 = logic_or(r122E, r1230);
                  body.emit(assign(r122A, logic_and(r122D, r1231), 0x01));

                  ir_variable *const r1232 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r1233 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
                  ir_expression *const r1234 = lequal(body.constant(4292870144u), r1233);
                  ir_expression *const r1235 = nequal(swizzle_x(r0DB0), body.constant(0u));
                  ir_expression *const r1236 = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
                  ir_expression *const r1237 = nequal(r1236, body.constant(0u));
                  ir_expression *const r1238 = logic_or(r1235, r1237);
                  body.emit(assign(r1232, logic_and(r1234, r1238), 0x01));

                  body.emit(assign(r1227, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

                  body.emit(assign(r1228, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r123A = lshift(swizzle_y(r0DAF), body.constant(int(1)));
                  ir_expression *const r123B = lequal(body.constant(4292870144u), r123A);
                  ir_expression *const r123C = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r123D = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
                  ir_expression *const r123E = nequal(r123D, body.constant(0u));
                  ir_expression *const r123F = logic_or(r123C, r123E);
                  ir_expression *const r1240 = logic_and(r123B, r123F);
                  ir_if *f1239 = new(mem_ctx) ir_if(operand(r1240).val);
                  exec_list *const f1239_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1239->then_instructions;

                     ir_variable *const r1241 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1243 = logic_and(r122A, r1232);
                     ir_if *f1242 = new(mem_ctx) ir_if(operand(r1243).val);
                     exec_list *const f1242_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1242->then_instructions;

                        body.emit(assign(r1241, r1228, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1242->else_instructions;

                        body.emit(assign(r1241, r1227, 0x03));


                     body.instructions = f1242_parent_instructions;
                     body.emit(f1242);

                     /* END IF */

                     body.emit(assign(r1229, r1241, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1239->else_instructions;

                     body.emit(assign(r1229, r1228, 0x03));


                  body.instructions = f1239_parent_instructions;
                  body.emit(f1239);

                  /* END IF */

                  body.emit(assign(r11CD, r1229, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1224->else_instructions;

                  ir_variable *const r1244 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1244);
                  ir_expression *const r1245 = lshift(r0DB2, body.constant(int(31)));
                  body.emit(assign(r1244, add(r1245, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1244, body.constant(0u), 0x01));

                  body.emit(assign(r11CD, r1244, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


               body.instructions = f1224_parent_instructions;
               body.emit(f1224);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1222->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1247 = equal(r11DA, body.constant(int(0)));
               ir_if *f1246 = new(mem_ctx) ir_if(operand(r1247).val);
               exec_list *const f1246_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1246->then_instructions;

                  body.emit(assign(r11CE, add(r11CE, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1246->else_instructions;

                  body.emit(assign(r11D1, bit_or(r11D7, body.constant(1048576u)), 0x01));


               body.instructions = f1246_parent_instructions;
               body.emit(f1246);

               /* END IF */

               ir_variable *const r1248 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r1248, body.constant(0u), 0x01));

               ir_variable *const r1249 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r1249, neg(r11CE), 0x01));

               ir_variable *const r124A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r124A);
               ir_variable *const r124B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r124B);
               ir_variable *const r124C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r124C);
               ir_variable *const r124D = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r124E = neg(r1249);
               body.emit(assign(r124D, bit_and(r124E, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1250 = equal(r1249, body.constant(int(0)));
               ir_if *f124F = new(mem_ctx) ir_if(operand(r1250).val);
               exec_list *const f124F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f124F->then_instructions;

                  body.emit(assign(r124A, r1248, 0x01));

                  body.emit(assign(r124B, r11D6, 0x01));

                  body.emit(assign(r124C, r11D1, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f124F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1252 = less(r1249, body.constant(int(32)));
                  ir_if *f1251 = new(mem_ctx) ir_if(operand(r1252).val);
                  exec_list *const f1251_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1251->then_instructions;

                     body.emit(assign(r124A, lshift(swizzle_x(r0DAF), r124D), 0x01));

                     ir_expression *const r1253 = lshift(r11D1, r124D);
                     ir_expression *const r1254 = rshift(swizzle_x(r0DAF), r1249);
                     body.emit(assign(r124B, bit_or(r1253, r1254), 0x01));

                     body.emit(assign(r124C, rshift(r11D1, r1249), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1251->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1256 = equal(r1249, body.constant(int(32)));
                     ir_if *f1255 = new(mem_ctx) ir_if(operand(r1256).val);
                     exec_list *const f1255_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1255->then_instructions;

                        body.emit(assign(r124A, r11D6, 0x01));

                        body.emit(assign(r124B, r11D1, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1255->else_instructions;

                        body.emit(assign(r1248, bit_or(body.constant(0u), swizzle_x(r0DAF)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1258 = less(r1249, body.constant(int(64)));
                        ir_if *f1257 = new(mem_ctx) ir_if(operand(r1258).val);
                        exec_list *const f1257_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1257->then_instructions;

                           body.emit(assign(r124A, lshift(r11D1, r124D), 0x01));

                           ir_expression *const r1259 = bit_and(r1249, body.constant(int(31)));
                           body.emit(assign(r124B, rshift(r11D1, r1259), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1257->else_instructions;

                           ir_variable *const r125A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r125C = equal(r1249, body.constant(int(64)));
                           ir_if *f125B = new(mem_ctx) ir_if(operand(r125C).val);
                           exec_list *const f125B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f125B->then_instructions;

                              body.emit(assign(r125A, r11D1, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f125B->else_instructions;

                              ir_expression *const r125D = nequal(r11D1, body.constant(0u));
                              ir_expression *const r125E = expr(ir_unop_b2i, r125D);
                              body.emit(assign(r125A, expr(ir_unop_i2u, r125E), 0x01));


                           body.instructions = f125B_parent_instructions;
                           body.emit(f125B);

                           /* END IF */

                           body.emit(assign(r124A, r125A, 0x01));

                           body.emit(assign(r124B, body.constant(0u), 0x01));


                        body.instructions = f1257_parent_instructions;
                        body.emit(f1257);

                        /* END IF */


                     body.instructions = f1255_parent_instructions;
                     body.emit(f1255);

                     /* END IF */

                     body.emit(assign(r124C, body.constant(0u), 0x01));


                  body.instructions = f1251_parent_instructions;
                  body.emit(f1251);

                  /* END IF */

                  ir_expression *const r125F = nequal(r1248, body.constant(0u));
                  ir_expression *const r1260 = expr(ir_unop_b2i, r125F);
                  ir_expression *const r1261 = expr(ir_unop_i2u, r1260);
                  body.emit(assign(r124A, bit_or(r124A, r1261), 0x01));


               body.instructions = f124F_parent_instructions;
               body.emit(f124F);

               /* END IF */

               body.emit(assign(r11D1, r124C, 0x01));

               body.emit(assign(r11D2, r124B, 0x01));

               body.emit(assign(r11D4, r124A, 0x01));

               body.emit(assign(r11D3, r11DD, 0x01));


            body.instructions = f1222_parent_instructions;
            body.emit(f1222);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1220->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1263 = equal(r11DA, body.constant(int(2047)));
            ir_if *f1262 = new(mem_ctx) ir_if(operand(r1263).val);
            exec_list *const f1262_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1262->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1265 = bit_or(r11D1, r11D2);
               ir_expression *const r1266 = bit_or(r11CF, r11D0);
               ir_expression *const r1267 = bit_or(r1265, r1266);
               ir_expression *const r1268 = nequal(r1267, body.constant(0u));
               ir_if *f1264 = new(mem_ctx) ir_if(operand(r1268).val);
               exec_list *const f1264_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1264->then_instructions;

                  ir_variable *const r1269 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1269, swizzle_x(r0DAF), 0x01));

                  ir_variable *const r126A = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r126A, swizzle_x(r0DB0), 0x01));

                  ir_variable *const r126B = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r126C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r126D = rshift(swizzle_y(r0DAF), body.constant(int(19)));
                  ir_expression *const r126E = bit_and(r126D, body.constant(4095u));
                  ir_expression *const r126F = equal(r126E, body.constant(4094u));
                  ir_expression *const r1270 = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r1271 = bit_and(swizzle_y(r0DAF), body.constant(524287u));
                  ir_expression *const r1272 = nequal(r1271, body.constant(0u));
                  ir_expression *const r1273 = logic_or(r1270, r1272);
                  body.emit(assign(r126C, logic_and(r126F, r1273), 0x01));

                  ir_variable *const r1274 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r1275 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
                  ir_expression *const r1276 = lequal(body.constant(4292870144u), r1275);
                  ir_expression *const r1277 = nequal(swizzle_x(r0DB0), body.constant(0u));
                  ir_expression *const r1278 = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
                  ir_expression *const r1279 = nequal(r1278, body.constant(0u));
                  ir_expression *const r127A = logic_or(r1277, r1279);
                  body.emit(assign(r1274, logic_and(r1276, r127A), 0x01));

                  body.emit(assign(r1269, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

                  body.emit(assign(r126A, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r127C = lshift(swizzle_y(r0DAF), body.constant(int(1)));
                  ir_expression *const r127D = lequal(body.constant(4292870144u), r127C);
                  ir_expression *const r127E = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r127F = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
                  ir_expression *const r1280 = nequal(r127F, body.constant(0u));
                  ir_expression *const r1281 = logic_or(r127E, r1280);
                  ir_expression *const r1282 = logic_and(r127D, r1281);
                  ir_if *f127B = new(mem_ctx) ir_if(operand(r1282).val);
                  exec_list *const f127B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f127B->then_instructions;

                     ir_variable *const r1283 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1285 = logic_and(r126C, r1274);
                     ir_if *f1284 = new(mem_ctx) ir_if(operand(r1285).val);
                     exec_list *const f1284_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1284->then_instructions;

                        body.emit(assign(r1283, r126A, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1284->else_instructions;

                        body.emit(assign(r1283, r1269, 0x03));


                     body.instructions = f1284_parent_instructions;
                     body.emit(f1284);

                     /* END IF */

                     body.emit(assign(r126B, r1283, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f127B->else_instructions;

                     body.emit(assign(r126B, r126A, 0x03));


                  body.instructions = f127B_parent_instructions;
                  body.emit(f127B);

                  /* END IF */

                  body.emit(assign(r11CD, r126B, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1264->else_instructions;

                  body.emit(assign(r11CD, r0DAF, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


               body.instructions = f1264_parent_instructions;
               body.emit(f1264);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1262->else_instructions;

               ir_variable *const r1286 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1287 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1287, add(r11D2, r11D0), 0x01));

               ir_expression *const r1288 = add(r11D1, r11CF);
               ir_expression *const r1289 = less(r1287, r11D2);
               ir_expression *const r128A = expr(ir_unop_b2i, r1289);
               ir_expression *const r128B = expr(ir_unop_i2u, r128A);
               body.emit(assign(r1286, add(r1288, r128B), 0x01));

               body.emit(assign(r11D5, r1286, 0x01));

               /* IF CONDITION */
               ir_expression *const r128D = equal(r11DA, body.constant(int(0)));
               ir_if *f128C = new(mem_ctx) ir_if(operand(r128D).val);
               exec_list *const f128C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f128C->then_instructions;

                  ir_variable *const r128E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r128E);
                  ir_expression *const r128F = lshift(r0DB2, body.constant(int(31)));
                  body.emit(assign(r128E, add(r128F, r1286), 0x02));

                  body.emit(assign(r128E, r1287, 0x01));

                  body.emit(assign(r11CD, r128E, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f128C->else_instructions;

                  body.emit(assign(r11D5, bit_or(r1286, body.constant(2097152u)), 0x01));

                  body.emit(assign(r11D3, r11DA, 0x01));

                  ir_variable *const r1290 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1290);
                  ir_variable *const r1291 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1291);
                  ir_variable *const r1292 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1292);
                  body.emit(assign(r1290, lshift(r1287, body.constant(int(31))), 0x01));

                  ir_expression *const r1293 = lshift(r11D5, body.constant(int(31)));
                  ir_expression *const r1294 = rshift(r1287, body.constant(int(1)));
                  body.emit(assign(r1291, bit_or(r1293, r1294), 0x01));

                  body.emit(assign(r1292, rshift(r11D5, body.constant(int(1))), 0x01));

                  body.emit(assign(r1290, bit_or(r1290, body.constant(0u)), 0x01));

                  body.emit(assign(r11D5, r1292, 0x01));

                  body.emit(assign(r11D4, r1290, 0x01));

                  ir_variable *const r1295 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r1295, r11DA, 0x01));

                  ir_variable *const r1296 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r1296, r1292, 0x01));

                  ir_variable *const r1297 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r1297, r1291, 0x01));

                  ir_variable *const r1298 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r1298, r1290, 0x01));

                  ir_variable *const r1299 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r1299, body.constant(true), 0x01));

                  ir_variable *const r129A = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r129B = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r129B);
                  ir_expression *const r129C = expr(ir_unop_u2i, r1290);
                  body.emit(assign(r129B, less(r129C, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r129E = lequal(body.constant(int(2045)), r11DA);
                  ir_if *f129D = new(mem_ctx) ir_if(operand(r129E).val);
                  exec_list *const f129D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f129D->then_instructions;

                     ir_variable *const r129F = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r12A1 = less(body.constant(int(2045)), r11DA);
                     ir_if *f12A0 = new(mem_ctx) ir_if(operand(r12A1).val);
                     exec_list *const f12A0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12A0->then_instructions;

                        body.emit(assign(r129F, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12A0->else_instructions;

                        ir_variable *const r12A2 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r12A4 = equal(r11DA, body.constant(int(2045)));
                        ir_if *f12A3 = new(mem_ctx) ir_if(operand(r12A4).val);
                        exec_list *const f12A3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12A3->then_instructions;

                           ir_expression *const r12A5 = equal(body.constant(2097151u), r1292);
                           ir_expression *const r12A6 = equal(body.constant(4294967295u), r1291);
                           body.emit(assign(r12A2, logic_and(r12A5, r12A6), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f12A3->else_instructions;

                           body.emit(assign(r12A2, body.constant(false), 0x01));


                        body.instructions = f12A3_parent_instructions;
                        body.emit(f12A3);

                        /* END IF */

                        body.emit(assign(r129F, logic_and(r12A2, r129B), 0x01));


                     body.instructions = f12A0_parent_instructions;
                     body.emit(f12A0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f12A7 = new(mem_ctx) ir_if(operand(r129F).val);
                     exec_list *const f12A7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12A7->then_instructions;

                        ir_variable *const r12A8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r12A8);
                        ir_expression *const r12A9 = lshift(r0DB2, body.constant(int(31)));
                        body.emit(assign(r12A8, add(r12A9, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r12A8, body.constant(0u), 0x01));

                        body.emit(assign(r129A, r12A8, 0x03));

                        body.emit(assign(r1299, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12A7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r12AB = less(r11DA, body.constant(int(0)));
                        ir_if *f12AA = new(mem_ctx) ir_if(operand(r12AB).val);
                        exec_list *const f12AA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12AA->then_instructions;

                           ir_variable *const r12AC = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r12AC, r1290, 0x01));

                           ir_variable *const r12AD = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r12AD, neg(r11DA), 0x01));

                           ir_variable *const r12AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r12AE);
                           ir_variable *const r12AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r12AF);
                           ir_variable *const r12B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r12B0);
                           ir_variable *const r12B1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r12B2 = neg(r12AD);
                           body.emit(assign(r12B1, bit_and(r12B2, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r12B4 = equal(r12AD, body.constant(int(0)));
                           ir_if *f12B3 = new(mem_ctx) ir_if(operand(r12B4).val);
                           exec_list *const f12B3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f12B3->then_instructions;

                              body.emit(assign(r12AE, r1290, 0x01));

                              body.emit(assign(r12AF, r1291, 0x01));

                              body.emit(assign(r12B0, r1292, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f12B3->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r12B6 = less(r12AD, body.constant(int(32)));
                              ir_if *f12B5 = new(mem_ctx) ir_if(operand(r12B6).val);
                              exec_list *const f12B5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f12B5->then_instructions;

                                 body.emit(assign(r12AE, lshift(r1291, r12B1), 0x01));

                                 ir_expression *const r12B7 = lshift(r1292, r12B1);
                                 ir_expression *const r12B8 = rshift(r1291, r12AD);
                                 body.emit(assign(r12AF, bit_or(r12B7, r12B8), 0x01));

                                 body.emit(assign(r12B0, rshift(r1292, r12AD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f12B5->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r12BA = equal(r12AD, body.constant(int(32)));
                                 ir_if *f12B9 = new(mem_ctx) ir_if(operand(r12BA).val);
                                 exec_list *const f12B9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f12B9->then_instructions;

                                    body.emit(assign(r12AE, r1291, 0x01));

                                    body.emit(assign(r12AF, r1292, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f12B9->else_instructions;

                                    body.emit(assign(r12AC, bit_or(r1290, r1291), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r12BC = less(r12AD, body.constant(int(64)));
                                    ir_if *f12BB = new(mem_ctx) ir_if(operand(r12BC).val);
                                    exec_list *const f12BB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f12BB->then_instructions;

                                       body.emit(assign(r12AE, lshift(r1292, r12B1), 0x01));

                                       ir_expression *const r12BD = bit_and(r12AD, body.constant(int(31)));
                                       body.emit(assign(r12AF, rshift(r1292, r12BD), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f12BB->else_instructions;

                                       ir_variable *const r12BE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r12C0 = equal(r12AD, body.constant(int(64)));
                                       ir_if *f12BF = new(mem_ctx) ir_if(operand(r12C0).val);
                                       exec_list *const f12BF_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f12BF->then_instructions;

                                          body.emit(assign(r12BE, r1292, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f12BF->else_instructions;

                                          ir_expression *const r12C1 = nequal(r1292, body.constant(0u));
                                          ir_expression *const r12C2 = expr(ir_unop_b2i, r12C1);
                                          body.emit(assign(r12BE, expr(ir_unop_i2u, r12C2), 0x01));


                                       body.instructions = f12BF_parent_instructions;
                                       body.emit(f12BF);

                                       /* END IF */

                                       body.emit(assign(r12AE, r12BE, 0x01));

                                       body.emit(assign(r12AF, body.constant(0u), 0x01));


                                    body.instructions = f12BB_parent_instructions;
                                    body.emit(f12BB);

                                    /* END IF */


                                 body.instructions = f12B9_parent_instructions;
                                 body.emit(f12B9);

                                 /* END IF */

                                 body.emit(assign(r12B0, body.constant(0u), 0x01));


                              body.instructions = f12B5_parent_instructions;
                              body.emit(f12B5);

                              /* END IF */

                              ir_expression *const r12C3 = nequal(r12AC, body.constant(0u));
                              ir_expression *const r12C4 = expr(ir_unop_b2i, r12C3);
                              ir_expression *const r12C5 = expr(ir_unop_i2u, r12C4);
                              body.emit(assign(r12AE, bit_or(r12AE, r12C5), 0x01));


                           body.instructions = f12B3_parent_instructions;
                           body.emit(f12B3);

                           /* END IF */

                           body.emit(assign(r1296, r12B0, 0x01));

                           body.emit(assign(r1297, r12AF, 0x01));

                           body.emit(assign(r1298, r12AE, 0x01));

                           body.emit(assign(r1295, body.constant(int(0)), 0x01));

                           body.emit(assign(r129B, less(r12AE, body.constant(0u)), 0x01));


                        body.instructions = f12AA_parent_instructions;
                        body.emit(f12AA);

                        /* END IF */


                     body.instructions = f12A7_parent_instructions;
                     body.emit(f12A7);

                     /* END IF */


                  body.instructions = f129D_parent_instructions;
                  body.emit(f129D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f12C6 = new(mem_ctx) ir_if(operand(r1299).val);
                  exec_list *const f12C6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12C6->then_instructions;

                     /* IF CONDITION */
                     ir_if *f12C7 = new(mem_ctx) ir_if(operand(r129B).val);
                     exec_list *const f12C7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12C7->then_instructions;

                        ir_variable *const r12C8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r12C8, add(r1297, body.constant(1u)), 0x01));

                        ir_expression *const r12C9 = less(r12C8, r1297);
                        ir_expression *const r12CA = expr(ir_unop_b2i, r12C9);
                        ir_expression *const r12CB = expr(ir_unop_i2u, r12CA);
                        body.emit(assign(r1296, add(r1296, r12CB), 0x01));

                        ir_expression *const r12CC = equal(r1298, body.constant(0u));
                        ir_expression *const r12CD = expr(ir_unop_b2i, r12CC);
                        ir_expression *const r12CE = expr(ir_unop_i2u, r12CD);
                        ir_expression *const r12CF = add(r1298, r12CE);
                        ir_expression *const r12D0 = bit_and(r12CF, body.constant(1u));
                        ir_expression *const r12D1 = expr(ir_unop_bit_not, r12D0);
                        body.emit(assign(r1297, bit_and(r12C8, r12D1), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12C7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r12D3 = bit_or(r1296, r1297);
                        ir_expression *const r12D4 = equal(r12D3, body.constant(0u));
                        ir_if *f12D2 = new(mem_ctx) ir_if(operand(r12D4).val);
                        exec_list *const f12D2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12D2->then_instructions;

                           body.emit(assign(r1295, body.constant(int(0)), 0x01));


                        body.instructions = f12D2_parent_instructions;
                        body.emit(f12D2);

                        /* END IF */


                     body.instructions = f12C7_parent_instructions;
                     body.emit(f12C7);

                     /* END IF */

                     ir_variable *const r12D5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r12D5);
                     ir_expression *const r12D6 = lshift(r0DB2, body.constant(int(31)));
                     ir_expression *const r12D7 = expr(ir_unop_i2u, r1295);
                     ir_expression *const r12D8 = lshift(r12D7, body.constant(int(20)));
                     ir_expression *const r12D9 = add(r12D6, r12D8);
                     body.emit(assign(r12D5, add(r12D9, r1296), 0x02));

                     body.emit(assign(r12D5, r1297, 0x01));

                     body.emit(assign(r129A, r12D5, 0x03));

                     body.emit(assign(r1299, body.constant(false), 0x01));


                  body.instructions = f12C6_parent_instructions;
                  body.emit(f12C6);

                  /* END IF */

                  body.emit(assign(r11CD, r129A, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


               body.instructions = f128C_parent_instructions;
               body.emit(f128C);

               /* END IF */


            body.instructions = f1262_parent_instructions;
            body.emit(f1262);

            /* END IF */


         body.instructions = f1220_parent_instructions;
         body.emit(f1220);

         /* END IF */


      body.instructions = f11E1_parent_instructions;
      body.emit(f11E1);

      /* END IF */

      /* IF CONDITION */
      ir_if *f12DA = new(mem_ctx) ir_if(operand(r11CC).val);
      exec_list *const f12DA_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f12DA->then_instructions;

         body.emit(assign(r11D1, bit_or(r11D1, body.constant(1048576u)), 0x01));

         ir_variable *const r12DB = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r12DC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r12DC, add(r11D2, r11D0), 0x01));

         ir_expression *const r12DD = add(r11D1, r11CF);
         ir_expression *const r12DE = less(r12DC, r11D2);
         ir_expression *const r12DF = expr(ir_unop_b2i, r12DE);
         ir_expression *const r12E0 = expr(ir_unop_i2u, r12DF);
         body.emit(assign(r12DB, add(r12DD, r12E0), 0x01));

         body.emit(assign(r11D5, r12DB, 0x01));

         body.emit(assign(r11D3, add(r11D3, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r12E2 = less(r12DB, body.constant(2097152u));
         ir_if *f12E1 = new(mem_ctx) ir_if(operand(r12E2).val);
         exec_list *const f12E1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f12E1->then_instructions;

            ir_variable *const r12E3 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r12E3, r11D3, 0x01));

            ir_variable *const r12E4 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r12E4, r12DB, 0x01));

            ir_variable *const r12E5 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r12E5, r12DC, 0x01));

            ir_variable *const r12E6 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r12E6, r11D4, 0x01));

            ir_variable *const r12E7 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r12E7, body.constant(true), 0x01));

            ir_variable *const r12E8 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r12E9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r12E9);
            ir_expression *const r12EA = expr(ir_unop_u2i, r11D4);
            body.emit(assign(r12E9, less(r12EA, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r12EC = lequal(body.constant(int(2045)), r11D3);
            ir_if *f12EB = new(mem_ctx) ir_if(operand(r12EC).val);
            exec_list *const f12EB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f12EB->then_instructions;

               ir_variable *const r12ED = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r12EF = less(body.constant(int(2045)), r11D3);
               ir_if *f12EE = new(mem_ctx) ir_if(operand(r12EF).val);
               exec_list *const f12EE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f12EE->then_instructions;

                  body.emit(assign(r12ED, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f12EE->else_instructions;

                  ir_variable *const r12F0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r12F2 = equal(r11D3, body.constant(int(2045)));
                  ir_if *f12F1 = new(mem_ctx) ir_if(operand(r12F2).val);
                  exec_list *const f12F1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12F1->then_instructions;

                     ir_expression *const r12F3 = equal(body.constant(2097151u), r12DB);
                     ir_expression *const r12F4 = equal(body.constant(4294967295u), r12DC);
                     body.emit(assign(r12F0, logic_and(r12F3, r12F4), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f12F1->else_instructions;

                     body.emit(assign(r12F0, body.constant(false), 0x01));


                  body.instructions = f12F1_parent_instructions;
                  body.emit(f12F1);

                  /* END IF */

                  body.emit(assign(r12ED, logic_and(r12F0, r12E9), 0x01));


               body.instructions = f12EE_parent_instructions;
               body.emit(f12EE);

               /* END IF */

               /* IF CONDITION */
               ir_if *f12F5 = new(mem_ctx) ir_if(operand(r12ED).val);
               exec_list *const f12F5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f12F5->then_instructions;

                  ir_variable *const r12F6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r12F6);
                  ir_expression *const r12F7 = lshift(r0DB2, body.constant(int(31)));
                  body.emit(assign(r12F6, add(r12F7, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r12F6, body.constant(0u), 0x01));

                  body.emit(assign(r12E8, r12F6, 0x03));

                  body.emit(assign(r12E7, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f12F5->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r12F9 = less(r11D3, body.constant(int(0)));
                  ir_if *f12F8 = new(mem_ctx) ir_if(operand(r12F9).val);
                  exec_list *const f12F8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12F8->then_instructions;

                     ir_variable *const r12FA = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r12FA, r11D4, 0x01));

                     ir_variable *const r12FB = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r12FB, neg(r11D3), 0x01));

                     ir_variable *const r12FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r12FC);
                     ir_variable *const r12FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r12FD);
                     ir_variable *const r12FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r12FE);
                     ir_variable *const r12FF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r1300 = neg(r12FB);
                     body.emit(assign(r12FF, bit_and(r1300, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1302 = equal(r12FB, body.constant(int(0)));
                     ir_if *f1301 = new(mem_ctx) ir_if(operand(r1302).val);
                     exec_list *const f1301_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1301->then_instructions;

                        body.emit(assign(r12FC, r11D4, 0x01));

                        body.emit(assign(r12FD, r12DC, 0x01));

                        body.emit(assign(r12FE, r12DB, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1301->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1304 = less(r12FB, body.constant(int(32)));
                        ir_if *f1303 = new(mem_ctx) ir_if(operand(r1304).val);
                        exec_list *const f1303_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1303->then_instructions;

                           body.emit(assign(r12FC, lshift(r12DC, r12FF), 0x01));

                           ir_expression *const r1305 = lshift(r12DB, r12FF);
                           ir_expression *const r1306 = rshift(r12DC, r12FB);
                           body.emit(assign(r12FD, bit_or(r1305, r1306), 0x01));

                           body.emit(assign(r12FE, rshift(r12DB, r12FB), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1303->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1308 = equal(r12FB, body.constant(int(32)));
                           ir_if *f1307 = new(mem_ctx) ir_if(operand(r1308).val);
                           exec_list *const f1307_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1307->then_instructions;

                              body.emit(assign(r12FC, r12DC, 0x01));

                              body.emit(assign(r12FD, r12DB, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1307->else_instructions;

                              body.emit(assign(r12FA, bit_or(r11D4, r12DC), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r130A = less(r12FB, body.constant(int(64)));
                              ir_if *f1309 = new(mem_ctx) ir_if(operand(r130A).val);
                              exec_list *const f1309_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1309->then_instructions;

                                 body.emit(assign(r12FC, lshift(r12DB, r12FF), 0x01));

                                 ir_expression *const r130B = bit_and(r12FB, body.constant(int(31)));
                                 body.emit(assign(r12FD, rshift(r12DB, r130B), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1309->else_instructions;

                                 ir_variable *const r130C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r130E = equal(r12FB, body.constant(int(64)));
                                 ir_if *f130D = new(mem_ctx) ir_if(operand(r130E).val);
                                 exec_list *const f130D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f130D->then_instructions;

                                    body.emit(assign(r130C, r12DB, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f130D->else_instructions;

                                    ir_expression *const r130F = nequal(r12DB, body.constant(0u));
                                    ir_expression *const r1310 = expr(ir_unop_b2i, r130F);
                                    body.emit(assign(r130C, expr(ir_unop_i2u, r1310), 0x01));


                                 body.instructions = f130D_parent_instructions;
                                 body.emit(f130D);

                                 /* END IF */

                                 body.emit(assign(r12FC, r130C, 0x01));

                                 body.emit(assign(r12FD, body.constant(0u), 0x01));


                              body.instructions = f1309_parent_instructions;
                              body.emit(f1309);

                              /* END IF */


                           body.instructions = f1307_parent_instructions;
                           body.emit(f1307);

                           /* END IF */

                           body.emit(assign(r12FE, body.constant(0u), 0x01));


                        body.instructions = f1303_parent_instructions;
                        body.emit(f1303);

                        /* END IF */

                        ir_expression *const r1311 = nequal(r12FA, body.constant(0u));
                        ir_expression *const r1312 = expr(ir_unop_b2i, r1311);
                        ir_expression *const r1313 = expr(ir_unop_i2u, r1312);
                        body.emit(assign(r12FC, bit_or(r12FC, r1313), 0x01));


                     body.instructions = f1301_parent_instructions;
                     body.emit(f1301);

                     /* END IF */

                     body.emit(assign(r12E4, r12FE, 0x01));

                     body.emit(assign(r12E5, r12FD, 0x01));

                     body.emit(assign(r12E6, r12FC, 0x01));

                     body.emit(assign(r12E3, body.constant(int(0)), 0x01));

                     body.emit(assign(r12E9, less(r12FC, body.constant(0u)), 0x01));


                  body.instructions = f12F8_parent_instructions;
                  body.emit(f12F8);

                  /* END IF */


               body.instructions = f12F5_parent_instructions;
               body.emit(f12F5);

               /* END IF */


            body.instructions = f12EB_parent_instructions;
            body.emit(f12EB);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1314 = new(mem_ctx) ir_if(operand(r12E7).val);
            exec_list *const f1314_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1314->then_instructions;

               /* IF CONDITION */
               ir_if *f1315 = new(mem_ctx) ir_if(operand(r12E9).val);
               exec_list *const f1315_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1315->then_instructions;

                  ir_variable *const r1316 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1316, add(r12E5, body.constant(1u)), 0x01));

                  ir_expression *const r1317 = less(r1316, r12E5);
                  ir_expression *const r1318 = expr(ir_unop_b2i, r1317);
                  ir_expression *const r1319 = expr(ir_unop_i2u, r1318);
                  body.emit(assign(r12E4, add(r12E4, r1319), 0x01));

                  ir_expression *const r131A = equal(r12E6, body.constant(0u));
                  ir_expression *const r131B = expr(ir_unop_b2i, r131A);
                  ir_expression *const r131C = expr(ir_unop_i2u, r131B);
                  ir_expression *const r131D = add(r12E6, r131C);
                  ir_expression *const r131E = bit_and(r131D, body.constant(1u));
                  ir_expression *const r131F = expr(ir_unop_bit_not, r131E);
                  body.emit(assign(r12E5, bit_and(r1316, r131F), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1315->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1321 = bit_or(r12E4, r12E5);
                  ir_expression *const r1322 = equal(r1321, body.constant(0u));
                  ir_if *f1320 = new(mem_ctx) ir_if(operand(r1322).val);
                  exec_list *const f1320_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1320->then_instructions;

                     body.emit(assign(r12E3, body.constant(int(0)), 0x01));


                  body.instructions = f1320_parent_instructions;
                  body.emit(f1320);

                  /* END IF */


               body.instructions = f1315_parent_instructions;
               body.emit(f1315);

               /* END IF */

               ir_variable *const r1323 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r1323);
               ir_expression *const r1324 = lshift(r0DB2, body.constant(int(31)));
               ir_expression *const r1325 = expr(ir_unop_i2u, r12E3);
               ir_expression *const r1326 = lshift(r1325, body.constant(int(20)));
               ir_expression *const r1327 = add(r1324, r1326);
               body.emit(assign(r1323, add(r1327, r12E4), 0x02));

               body.emit(assign(r1323, r12E5, 0x01));

               body.emit(assign(r12E8, r1323, 0x03));

               body.emit(assign(r12E7, body.constant(false), 0x01));


            body.instructions = f1314_parent_instructions;
            body.emit(f1314);

            /* END IF */

            body.emit(assign(r11CD, r12E8, 0x03));

            body.emit(assign(r11CC, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f12E1->else_instructions;

            body.emit(assign(r11D3, add(r11D3, body.constant(int(1))), 0x01));

            ir_variable *const r1328 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r1328);
            ir_variable *const r1329 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1329);
            ir_variable *const r132A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r132A);
            body.emit(assign(r1328, lshift(r12DC, body.constant(int(31))), 0x01));

            ir_expression *const r132B = lshift(r12DB, body.constant(int(31)));
            ir_expression *const r132C = rshift(r12DC, body.constant(int(1)));
            body.emit(assign(r1329, bit_or(r132B, r132C), 0x01));

            body.emit(assign(r132A, rshift(r12DB, body.constant(int(1))), 0x01));

            ir_expression *const r132D = nequal(r11D4, body.constant(0u));
            ir_expression *const r132E = expr(ir_unop_b2i, r132D);
            ir_expression *const r132F = expr(ir_unop_i2u, r132E);
            body.emit(assign(r1328, bit_or(r1328, r132F), 0x01));

            body.emit(assign(r11D5, r132A, 0x01));

            body.emit(assign(r11D4, r1328, 0x01));

            ir_variable *const r1330 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r1330, r11D3, 0x01));

            ir_variable *const r1331 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r1331, r132A, 0x01));

            ir_variable *const r1332 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r1332, r1329, 0x01));

            ir_variable *const r1333 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r1333, r1328, 0x01));

            ir_variable *const r1334 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r1334, body.constant(true), 0x01));

            ir_variable *const r1335 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r1336 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r1336);
            ir_expression *const r1337 = expr(ir_unop_u2i, r1328);
            body.emit(assign(r1336, less(r1337, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1339 = lequal(body.constant(int(2045)), r11D3);
            ir_if *f1338 = new(mem_ctx) ir_if(operand(r1339).val);
            exec_list *const f1338_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1338->then_instructions;

               ir_variable *const r133A = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r133C = less(body.constant(int(2045)), r11D3);
               ir_if *f133B = new(mem_ctx) ir_if(operand(r133C).val);
               exec_list *const f133B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f133B->then_instructions;

                  body.emit(assign(r133A, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f133B->else_instructions;

                  ir_variable *const r133D = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r133F = equal(r11D3, body.constant(int(2045)));
                  ir_if *f133E = new(mem_ctx) ir_if(operand(r133F).val);
                  exec_list *const f133E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f133E->then_instructions;

                     ir_expression *const r1340 = equal(body.constant(2097151u), r132A);
                     ir_expression *const r1341 = equal(body.constant(4294967295u), r1329);
                     body.emit(assign(r133D, logic_and(r1340, r1341), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f133E->else_instructions;

                     body.emit(assign(r133D, body.constant(false), 0x01));


                  body.instructions = f133E_parent_instructions;
                  body.emit(f133E);

                  /* END IF */

                  body.emit(assign(r133A, logic_and(r133D, r1336), 0x01));


               body.instructions = f133B_parent_instructions;
               body.emit(f133B);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1342 = new(mem_ctx) ir_if(operand(r133A).val);
               exec_list *const f1342_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1342->then_instructions;

                  ir_variable *const r1343 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1343);
                  ir_expression *const r1344 = lshift(r0DB2, body.constant(int(31)));
                  body.emit(assign(r1343, add(r1344, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1343, body.constant(0u), 0x01));

                  body.emit(assign(r1335, r1343, 0x03));

                  body.emit(assign(r1334, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1342->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1346 = less(r11D3, body.constant(int(0)));
                  ir_if *f1345 = new(mem_ctx) ir_if(operand(r1346).val);
                  exec_list *const f1345_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1345->then_instructions;

                     ir_variable *const r1347 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r1347, r1328, 0x01));

                     ir_variable *const r1348 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r1348, neg(r11D3), 0x01));

                     ir_variable *const r1349 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r1349);
                     ir_variable *const r134A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r134A);
                     ir_variable *const r134B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r134B);
                     ir_variable *const r134C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r134D = neg(r1348);
                     body.emit(assign(r134C, bit_and(r134D, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r134F = equal(r1348, body.constant(int(0)));
                     ir_if *f134E = new(mem_ctx) ir_if(operand(r134F).val);
                     exec_list *const f134E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f134E->then_instructions;

                        body.emit(assign(r1349, r1328, 0x01));

                        body.emit(assign(r134A, r1329, 0x01));

                        body.emit(assign(r134B, r132A, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f134E->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1351 = less(r1348, body.constant(int(32)));
                        ir_if *f1350 = new(mem_ctx) ir_if(operand(r1351).val);
                        exec_list *const f1350_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1350->then_instructions;

                           body.emit(assign(r1349, lshift(r1329, r134C), 0x01));

                           ir_expression *const r1352 = lshift(r132A, r134C);
                           ir_expression *const r1353 = rshift(r1329, r1348);
                           body.emit(assign(r134A, bit_or(r1352, r1353), 0x01));

                           body.emit(assign(r134B, rshift(r132A, r1348), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1350->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1355 = equal(r1348, body.constant(int(32)));
                           ir_if *f1354 = new(mem_ctx) ir_if(operand(r1355).val);
                           exec_list *const f1354_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1354->then_instructions;

                              body.emit(assign(r1349, r1329, 0x01));

                              body.emit(assign(r134A, r132A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1354->else_instructions;

                              body.emit(assign(r1347, bit_or(r1328, r1329), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1357 = less(r1348, body.constant(int(64)));
                              ir_if *f1356 = new(mem_ctx) ir_if(operand(r1357).val);
                              exec_list *const f1356_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1356->then_instructions;

                                 body.emit(assign(r1349, lshift(r132A, r134C), 0x01));

                                 ir_expression *const r1358 = bit_and(r1348, body.constant(int(31)));
                                 body.emit(assign(r134A, rshift(r132A, r1358), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1356->else_instructions;

                                 ir_variable *const r1359 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r135B = equal(r1348, body.constant(int(64)));
                                 ir_if *f135A = new(mem_ctx) ir_if(operand(r135B).val);
                                 exec_list *const f135A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f135A->then_instructions;

                                    body.emit(assign(r1359, r132A, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f135A->else_instructions;

                                    ir_expression *const r135C = nequal(r132A, body.constant(0u));
                                    ir_expression *const r135D = expr(ir_unop_b2i, r135C);
                                    body.emit(assign(r1359, expr(ir_unop_i2u, r135D), 0x01));


                                 body.instructions = f135A_parent_instructions;
                                 body.emit(f135A);

                                 /* END IF */

                                 body.emit(assign(r1349, r1359, 0x01));

                                 body.emit(assign(r134A, body.constant(0u), 0x01));


                              body.instructions = f1356_parent_instructions;
                              body.emit(f1356);

                              /* END IF */


                           body.instructions = f1354_parent_instructions;
                           body.emit(f1354);

                           /* END IF */

                           body.emit(assign(r134B, body.constant(0u), 0x01));


                        body.instructions = f1350_parent_instructions;
                        body.emit(f1350);

                        /* END IF */

                        ir_expression *const r135E = nequal(r1347, body.constant(0u));
                        ir_expression *const r135F = expr(ir_unop_b2i, r135E);
                        ir_expression *const r1360 = expr(ir_unop_i2u, r135F);
                        body.emit(assign(r1349, bit_or(r1349, r1360), 0x01));


                     body.instructions = f134E_parent_instructions;
                     body.emit(f134E);

                     /* END IF */

                     body.emit(assign(r1331, r134B, 0x01));

                     body.emit(assign(r1332, r134A, 0x01));

                     body.emit(assign(r1333, r1349, 0x01));

                     body.emit(assign(r1330, body.constant(int(0)), 0x01));

                     body.emit(assign(r1336, less(r1349, body.constant(0u)), 0x01));


                  body.instructions = f1345_parent_instructions;
                  body.emit(f1345);

                  /* END IF */


               body.instructions = f1342_parent_instructions;
               body.emit(f1342);

               /* END IF */


            body.instructions = f1338_parent_instructions;
            body.emit(f1338);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1361 = new(mem_ctx) ir_if(operand(r1334).val);
            exec_list *const f1361_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1361->then_instructions;

               /* IF CONDITION */
               ir_if *f1362 = new(mem_ctx) ir_if(operand(r1336).val);
               exec_list *const f1362_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1362->then_instructions;

                  ir_variable *const r1363 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1363, add(r1332, body.constant(1u)), 0x01));

                  ir_expression *const r1364 = less(r1363, r1332);
                  ir_expression *const r1365 = expr(ir_unop_b2i, r1364);
                  ir_expression *const r1366 = expr(ir_unop_i2u, r1365);
                  body.emit(assign(r1331, add(r1331, r1366), 0x01));

                  ir_expression *const r1367 = equal(r1333, body.constant(0u));
                  ir_expression *const r1368 = expr(ir_unop_b2i, r1367);
                  ir_expression *const r1369 = expr(ir_unop_i2u, r1368);
                  ir_expression *const r136A = add(r1333, r1369);
                  ir_expression *const r136B = bit_and(r136A, body.constant(1u));
                  ir_expression *const r136C = expr(ir_unop_bit_not, r136B);
                  body.emit(assign(r1332, bit_and(r1363, r136C), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1362->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r136E = bit_or(r1331, r1332);
                  ir_expression *const r136F = equal(r136E, body.constant(0u));
                  ir_if *f136D = new(mem_ctx) ir_if(operand(r136F).val);
                  exec_list *const f136D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f136D->then_instructions;

                     body.emit(assign(r1330, body.constant(int(0)), 0x01));


                  body.instructions = f136D_parent_instructions;
                  body.emit(f136D);

                  /* END IF */


               body.instructions = f1362_parent_instructions;
               body.emit(f1362);

               /* END IF */

               ir_variable *const r1370 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r1370);
               ir_expression *const r1371 = lshift(r0DB2, body.constant(int(31)));
               ir_expression *const r1372 = expr(ir_unop_i2u, r1330);
               ir_expression *const r1373 = lshift(r1372, body.constant(int(20)));
               ir_expression *const r1374 = add(r1371, r1373);
               body.emit(assign(r1370, add(r1374, r1331), 0x02));

               body.emit(assign(r1370, r1332, 0x01));

               body.emit(assign(r1335, r1370, 0x03));

               body.emit(assign(r1334, body.constant(false), 0x01));


            body.instructions = f1361_parent_instructions;
            body.emit(f1361);

            /* END IF */

            body.emit(assign(r11CD, r1335, 0x03));

            body.emit(assign(r11CC, body.constant(false), 0x01));


         body.instructions = f12E1_parent_instructions;
         body.emit(f12E1);

         /* END IF */


      body.instructions = f12DA_parent_instructions;
      body.emit(f12DA);

      /* END IF */

      body.emit(assign(r0DB1, r11CD, 0x03));


   body.instructions = f0DB4_parent_instructions;
   body.emit(f0DB4);

   /* END IF */

   body.emit(ret(r0DB1));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul32To64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1375 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1375);
   ir_variable *const r1376 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1376);
   ir_variable *const r1377 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1377);
   ir_variable *const r1378 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1378);
   ir_variable *const r1379 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1379);
   ir_variable *const r137A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r137A);
   ir_variable *const r137B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r137B);
   ir_variable *const r137C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r137C, bit_and(r1375, body.constant(65535u)), 0x01));

   ir_variable *const r137D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r137D, rshift(r1375, body.constant(int(16))), 0x01));

   ir_variable *const r137E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r137E, bit_and(r1376, body.constant(65535u)), 0x01));

   ir_variable *const r137F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r137F, rshift(r1376, body.constant(int(16))), 0x01));

   ir_variable *const r1380 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1380, mul(r137D, r137E), 0x01));

   ir_expression *const r1381 = mul(r137C, r137F);
   body.emit(assign(r137A, add(r1381, r1380), 0x01));

   ir_expression *const r1382 = mul(r137D, r137F);
   ir_expression *const r1383 = less(r137A, r1380);
   ir_expression *const r1384 = expr(ir_unop_b2i, r1383);
   ir_expression *const r1385 = expr(ir_unop_i2u, r1384);
   ir_expression *const r1386 = lshift(r1385, body.constant(int(16)));
   ir_expression *const r1387 = rshift(r137A, body.constant(int(16)));
   ir_expression *const r1388 = add(r1386, r1387);
   body.emit(assign(r1379, add(r1382, r1388), 0x01));

   body.emit(assign(r137A, lshift(r137A, body.constant(int(16))), 0x01));

   ir_expression *const r1389 = mul(r137C, r137E);
   body.emit(assign(r137B, add(r1389, r137A), 0x01));

   ir_expression *const r138A = less(r137B, r137A);
   ir_expression *const r138B = expr(ir_unop_b2i, r138A);
   ir_expression *const r138C = expr(ir_unop_i2u, r138B);
   body.emit(assign(r1379, add(r1379, r138C), 0x01));

   body.emit(assign(r1378, r137B, 0x01));

   body.emit(assign(r1377, r1379, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul64To128(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r138D = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r138D);
   ir_variable *const r138E = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r138E);
   ir_variable *const r138F = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r138F);
   ir_variable *const r1390 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r1390);
   ir_variable *const r1391 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1391);
   ir_variable *const r1392 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1392);
   ir_variable *const r1393 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1393);
   ir_variable *const r1394 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z3Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1394);
   ir_variable *const r1395 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1395);
   ir_variable *const r1396 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r1396);
   ir_variable *const r1397 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1397);
   ir_variable *const r1398 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1398, bit_and(r138E, body.constant(65535u)), 0x01));

   ir_variable *const r1399 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1399, rshift(r138E, body.constant(int(16))), 0x01));

   ir_variable *const r139A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139A, bit_and(r1390, body.constant(65535u)), 0x01));

   ir_variable *const r139B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139B, rshift(r1390, body.constant(int(16))), 0x01));

   ir_variable *const r139C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139C, mul(r1399, r139A), 0x01));

   ir_expression *const r139D = mul(r1398, r139B);
   body.emit(assign(r1396, add(r139D, r139C), 0x01));

   ir_expression *const r139E = mul(r1399, r139B);
   ir_expression *const r139F = less(r1396, r139C);
   ir_expression *const r13A0 = expr(ir_unop_b2i, r139F);
   ir_expression *const r13A1 = expr(ir_unop_i2u, r13A0);
   ir_expression *const r13A2 = lshift(r13A1, body.constant(int(16)));
   ir_expression *const r13A3 = rshift(r1396, body.constant(int(16)));
   ir_expression *const r13A4 = add(r13A2, r13A3);
   body.emit(assign(r1395, add(r139E, r13A4), 0x01));

   body.emit(assign(r1396, lshift(r1396, body.constant(int(16))), 0x01));

   ir_expression *const r13A5 = mul(r1398, r139A);
   body.emit(assign(r1397, add(r13A5, r1396), 0x01));

   ir_expression *const r13A6 = less(r1397, r1396);
   ir_expression *const r13A7 = expr(ir_unop_b2i, r13A6);
   ir_expression *const r13A8 = expr(ir_unop_i2u, r13A7);
   body.emit(assign(r1395, add(r1395, r13A8), 0x01));

   ir_variable *const r13A9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13A9);
   ir_variable *const r13AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13AA);
   ir_variable *const r13AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13AB);
   ir_variable *const r13AC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13AC, bit_and(r138E, body.constant(65535u)), 0x01));

   ir_variable *const r13AD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13AD, rshift(r138E, body.constant(int(16))), 0x01));

   ir_variable *const r13AE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13AE, bit_and(r138F, body.constant(65535u)), 0x01));

   ir_variable *const r13AF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13AF, rshift(r138F, body.constant(int(16))), 0x01));

   ir_variable *const r13B0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B0, mul(r13AD, r13AE), 0x01));

   ir_expression *const r13B1 = mul(r13AC, r13AF);
   body.emit(assign(r13AA, add(r13B1, r13B0), 0x01));

   ir_expression *const r13B2 = mul(r13AD, r13AF);
   ir_expression *const r13B3 = less(r13AA, r13B0);
   ir_expression *const r13B4 = expr(ir_unop_b2i, r13B3);
   ir_expression *const r13B5 = expr(ir_unop_i2u, r13B4);
   ir_expression *const r13B6 = lshift(r13B5, body.constant(int(16)));
   ir_expression *const r13B7 = rshift(r13AA, body.constant(int(16)));
   ir_expression *const r13B8 = add(r13B6, r13B7);
   body.emit(assign(r13A9, add(r13B2, r13B8), 0x01));

   body.emit(assign(r13AA, lshift(r13AA, body.constant(int(16))), 0x01));

   ir_expression *const r13B9 = mul(r13AC, r13AE);
   body.emit(assign(r13AB, add(r13B9, r13AA), 0x01));

   ir_expression *const r13BA = less(r13AB, r13AA);
   ir_expression *const r13BB = expr(ir_unop_b2i, r13BA);
   ir_expression *const r13BC = expr(ir_unop_i2u, r13BB);
   body.emit(assign(r13A9, add(r13A9, r13BC), 0x01));

   ir_variable *const r13BD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13BD, add(r13AB, r1395), 0x01));

   ir_variable *const r13BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13BE);
   ir_variable *const r13BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13BF);
   ir_variable *const r13C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13C0);
   ir_variable *const r13C1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C1, bit_and(r138D, body.constant(65535u)), 0x01));

   ir_variable *const r13C2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C2, rshift(r138D, body.constant(int(16))), 0x01));

   ir_variable *const r13C3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C3, bit_and(r138F, body.constant(65535u)), 0x01));

   ir_variable *const r13C4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C4, rshift(r138F, body.constant(int(16))), 0x01));

   ir_variable *const r13C5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C5, mul(r13C2, r13C3), 0x01));

   ir_expression *const r13C6 = mul(r13C1, r13C4);
   body.emit(assign(r13BF, add(r13C6, r13C5), 0x01));

   ir_expression *const r13C7 = mul(r13C2, r13C4);
   ir_expression *const r13C8 = less(r13BF, r13C5);
   ir_expression *const r13C9 = expr(ir_unop_b2i, r13C8);
   ir_expression *const r13CA = expr(ir_unop_i2u, r13C9);
   ir_expression *const r13CB = lshift(r13CA, body.constant(int(16)));
   ir_expression *const r13CC = rshift(r13BF, body.constant(int(16)));
   ir_expression *const r13CD = add(r13CB, r13CC);
   body.emit(assign(r13BE, add(r13C7, r13CD), 0x01));

   body.emit(assign(r13BF, lshift(r13BF, body.constant(int(16))), 0x01));

   ir_expression *const r13CE = mul(r13C1, r13C3);
   body.emit(assign(r13C0, add(r13CE, r13BF), 0x01));

   ir_expression *const r13CF = less(r13C0, r13BF);
   ir_expression *const r13D0 = expr(ir_unop_b2i, r13CF);
   ir_expression *const r13D1 = expr(ir_unop_i2u, r13D0);
   body.emit(assign(r13BE, add(r13BE, r13D1), 0x01));

   ir_variable *const r13D2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r13D3 = less(r13BD, r13AB);
   ir_expression *const r13D4 = expr(ir_unop_b2i, r13D3);
   ir_expression *const r13D5 = expr(ir_unop_i2u, r13D4);
   ir_expression *const r13D6 = add(r13A9, r13D5);
   body.emit(assign(r13D2, add(r13C0, r13D6), 0x01));

   ir_variable *const r13D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13D7);
   ir_variable *const r13D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13D8);
   ir_variable *const r13D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13D9);
   ir_variable *const r13DA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DA, bit_and(r138D, body.constant(65535u)), 0x01));

   ir_variable *const r13DB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DB, rshift(r138D, body.constant(int(16))), 0x01));

   ir_variable *const r13DC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DC, bit_and(r1390, body.constant(65535u)), 0x01));

   ir_variable *const r13DD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DD, rshift(r1390, body.constant(int(16))), 0x01));

   ir_variable *const r13DE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DE, mul(r13DB, r13DC), 0x01));

   ir_expression *const r13DF = mul(r13DA, r13DD);
   body.emit(assign(r13D8, add(r13DF, r13DE), 0x01));

   ir_expression *const r13E0 = mul(r13DB, r13DD);
   ir_expression *const r13E1 = less(r13D8, r13DE);
   ir_expression *const r13E2 = expr(ir_unop_b2i, r13E1);
   ir_expression *const r13E3 = expr(ir_unop_i2u, r13E2);
   ir_expression *const r13E4 = lshift(r13E3, body.constant(int(16)));
   ir_expression *const r13E5 = rshift(r13D8, body.constant(int(16)));
   ir_expression *const r13E6 = add(r13E4, r13E5);
   body.emit(assign(r13D7, add(r13E0, r13E6), 0x01));

   body.emit(assign(r13D8, lshift(r13D8, body.constant(int(16))), 0x01));

   ir_expression *const r13E7 = mul(r13DA, r13DC);
   body.emit(assign(r13D9, add(r13E7, r13D8), 0x01));

   ir_expression *const r13E8 = less(r13D9, r13D8);
   ir_expression *const r13E9 = expr(ir_unop_b2i, r13E8);
   ir_expression *const r13EA = expr(ir_unop_i2u, r13E9);
   body.emit(assign(r13D7, add(r13D7, r13EA), 0x01));

   ir_variable *const r13EB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13EB, add(r13D9, r13BD), 0x01));

   ir_variable *const r13EC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r13ED = less(r13EB, r13D9);
   ir_expression *const r13EE = expr(ir_unop_b2i, r13ED);
   ir_expression *const r13EF = expr(ir_unop_i2u, r13EE);
   ir_expression *const r13F0 = add(r13D7, r13EF);
   body.emit(assign(r13EC, add(r13D2, r13F0), 0x01));

   body.emit(assign(r1394, r1397, 0x01));

   body.emit(assign(r1393, r13EB, 0x01));

   body.emit(assign(r1392, r13EC, 0x01));

   ir_expression *const r13F1 = less(r13D2, r13C0);
   ir_expression *const r13F2 = expr(ir_unop_b2i, r13F1);
   ir_expression *const r13F3 = expr(ir_unop_i2u, r13F2);
   ir_expression *const r13F4 = add(r13BE, r13F3);
   ir_expression *const r13F5 = less(r13EC, r13D2);
   ir_expression *const r13F6 = expr(ir_unop_b2i, r13F5);
   ir_expression *const r13F7 = expr(ir_unop_i2u, r13F6);
   body.emit(assign(r1391, add(r13F4, r13F7), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat64Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r13F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac0", ir_var_function_in);
   sig_parameters.push_tail(r13F8);
   ir_variable *const r13F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac1", ir_var_function_in);
   sig_parameters.push_tail(r13F9);
   ir_variable *const r13FA = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r13FA);
   ir_variable *const r13FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r13FB);
   ir_variable *const r13FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r13FC);
   ir_variable *const r13FD = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r13FD);
   /* IF CONDITION */
   ir_expression *const r13FF = equal(r13F8, body.constant(0u));
   ir_if *f13FE = new(mem_ctx) ir_if(operand(r13FF).val);
   exec_list *const f13FE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f13FE->then_instructions;

      ir_variable *const r1400 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1400, r13F9, 0x01));

      ir_variable *const r1401 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1402 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1402);
      /* IF CONDITION */
      ir_expression *const r1404 = equal(r13F9, body.constant(0u));
      ir_if *f1403 = new(mem_ctx) ir_if(operand(r1404).val);
      exec_list *const f1403_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1403->then_instructions;

         body.emit(assign(r1401, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1403->else_instructions;

         body.emit(assign(r1402, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1406 = bit_and(r13F9, body.constant(4294901760u));
         ir_expression *const r1407 = equal(r1406, body.constant(0u));
         ir_if *f1405 = new(mem_ctx) ir_if(operand(r1407).val);
         exec_list *const f1405_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1405->then_instructions;

            body.emit(assign(r1402, body.constant(int(16)), 0x01));

            body.emit(assign(r1400, lshift(r13F9, body.constant(int(16))), 0x01));


         body.instructions = f1405_parent_instructions;
         body.emit(f1405);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1409 = bit_and(r1400, body.constant(4278190080u));
         ir_expression *const r140A = equal(r1409, body.constant(0u));
         ir_if *f1408 = new(mem_ctx) ir_if(operand(r140A).val);
         exec_list *const f1408_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1408->then_instructions;

            body.emit(assign(r1402, add(r1402, body.constant(int(8))), 0x01));

            body.emit(assign(r1400, lshift(r1400, body.constant(int(8))), 0x01));


         body.instructions = f1408_parent_instructions;
         body.emit(f1408);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r140C = bit_and(r1400, body.constant(4026531840u));
         ir_expression *const r140D = equal(r140C, body.constant(0u));
         ir_if *f140B = new(mem_ctx) ir_if(operand(r140D).val);
         exec_list *const f140B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f140B->then_instructions;

            body.emit(assign(r1402, add(r1402, body.constant(int(4))), 0x01));

            body.emit(assign(r1400, lshift(r1400, body.constant(int(4))), 0x01));


         body.instructions = f140B_parent_instructions;
         body.emit(f140B);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r140F = bit_and(r1400, body.constant(3221225472u));
         ir_expression *const r1410 = equal(r140F, body.constant(0u));
         ir_if *f140E = new(mem_ctx) ir_if(operand(r1410).val);
         exec_list *const f140E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f140E->then_instructions;

            body.emit(assign(r1402, add(r1402, body.constant(int(2))), 0x01));

            body.emit(assign(r1400, lshift(r1400, body.constant(int(2))), 0x01));


         body.instructions = f140E_parent_instructions;
         body.emit(f140E);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1412 = bit_and(r1400, body.constant(2147483648u));
         ir_expression *const r1413 = equal(r1412, body.constant(0u));
         ir_if *f1411 = new(mem_ctx) ir_if(operand(r1413).val);
         exec_list *const f1411_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1411->then_instructions;

            body.emit(assign(r1402, add(r1402, body.constant(int(1))), 0x01));


         body.instructions = f1411_parent_instructions;
         body.emit(f1411);

         /* END IF */

         body.emit(assign(r1401, r1402, 0x01));


      body.instructions = f1403_parent_instructions;
      body.emit(f1403);

      /* END IF */

      body.emit(assign(r13FD, add(r1401, body.constant(int(-11))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1415 = less(r13FD, body.constant(int(0)));
      ir_if *f1414 = new(mem_ctx) ir_if(operand(r1415).val);
      exec_list *const f1414_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1414->then_instructions;

         ir_expression *const r1416 = neg(r13FD);
         body.emit(assign(r13FB, rshift(r13F9, r1416), 0x01));

         ir_expression *const r1417 = bit_and(r13FD, body.constant(int(31)));
         body.emit(assign(r13FC, lshift(r13F9, r1417), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1414->else_instructions;

         body.emit(assign(r13FB, lshift(r13F9, r13FD), 0x01));

         body.emit(assign(r13FC, body.constant(0u), 0x01));


      body.instructions = f1414_parent_instructions;
      body.emit(f1414);

      /* END IF */

      body.emit(assign(r13FA, sub(body.constant(int(-31)), r13FD), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f13FE->else_instructions;

      ir_variable *const r1418 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1418, r13F8, 0x01));

      ir_variable *const r1419 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r141A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r141A);
      /* IF CONDITION */
      ir_expression *const r141C = equal(r13F8, body.constant(0u));
      ir_if *f141B = new(mem_ctx) ir_if(operand(r141C).val);
      exec_list *const f141B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f141B->then_instructions;

         body.emit(assign(r1419, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f141B->else_instructions;

         body.emit(assign(r141A, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r141E = bit_and(r13F8, body.constant(4294901760u));
         ir_expression *const r141F = equal(r141E, body.constant(0u));
         ir_if *f141D = new(mem_ctx) ir_if(operand(r141F).val);
         exec_list *const f141D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f141D->then_instructions;

            body.emit(assign(r141A, body.constant(int(16)), 0x01));

            body.emit(assign(r1418, lshift(r13F8, body.constant(int(16))), 0x01));


         body.instructions = f141D_parent_instructions;
         body.emit(f141D);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1421 = bit_and(r1418, body.constant(4278190080u));
         ir_expression *const r1422 = equal(r1421, body.constant(0u));
         ir_if *f1420 = new(mem_ctx) ir_if(operand(r1422).val);
         exec_list *const f1420_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1420->then_instructions;

            body.emit(assign(r141A, add(r141A, body.constant(int(8))), 0x01));

            body.emit(assign(r1418, lshift(r1418, body.constant(int(8))), 0x01));


         body.instructions = f1420_parent_instructions;
         body.emit(f1420);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1424 = bit_and(r1418, body.constant(4026531840u));
         ir_expression *const r1425 = equal(r1424, body.constant(0u));
         ir_if *f1423 = new(mem_ctx) ir_if(operand(r1425).val);
         exec_list *const f1423_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1423->then_instructions;

            body.emit(assign(r141A, add(r141A, body.constant(int(4))), 0x01));

            body.emit(assign(r1418, lshift(r1418, body.constant(int(4))), 0x01));


         body.instructions = f1423_parent_instructions;
         body.emit(f1423);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1427 = bit_and(r1418, body.constant(3221225472u));
         ir_expression *const r1428 = equal(r1427, body.constant(0u));
         ir_if *f1426 = new(mem_ctx) ir_if(operand(r1428).val);
         exec_list *const f1426_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1426->then_instructions;

            body.emit(assign(r141A, add(r141A, body.constant(int(2))), 0x01));

            body.emit(assign(r1418, lshift(r1418, body.constant(int(2))), 0x01));


         body.instructions = f1426_parent_instructions;
         body.emit(f1426);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r142A = bit_and(r1418, body.constant(2147483648u));
         ir_expression *const r142B = equal(r142A, body.constant(0u));
         ir_if *f1429 = new(mem_ctx) ir_if(operand(r142B).val);
         exec_list *const f1429_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1429->then_instructions;

            body.emit(assign(r141A, add(r141A, body.constant(int(1))), 0x01));


         body.instructions = f1429_parent_instructions;
         body.emit(f1429);

         /* END IF */

         body.emit(assign(r1419, r141A, 0x01));


      body.instructions = f141B_parent_instructions;
      body.emit(f141B);

      /* END IF */

      body.emit(assign(r13FD, add(r1419, body.constant(int(-11))), 0x01));

      ir_variable *const r142C = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r142C, lshift(r13F9, r13FD), 0x01));

      ir_variable *const r142D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r142F = equal(r13FD, body.constant(int(0)));
      ir_if *f142E = new(mem_ctx) ir_if(operand(r142F).val);
      exec_list *const f142E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f142E->then_instructions;

         body.emit(assign(r142D, r13F8, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f142E->else_instructions;

         ir_expression *const r1430 = lshift(r13F8, r13FD);
         ir_expression *const r1431 = neg(r13FD);
         ir_expression *const r1432 = bit_and(r1431, body.constant(int(31)));
         ir_expression *const r1433 = rshift(r13F9, r1432);
         body.emit(assign(r142D, bit_or(r1430, r1433), 0x01));


      body.instructions = f142E_parent_instructions;
      body.emit(f142E);

      /* END IF */

      body.emit(assign(r13FB, r142D, 0x01));

      body.emit(assign(r13FC, r142C, 0x01));

      body.emit(assign(r13FA, sub(body.constant(int(1)), r13FD), 0x01));


   body.instructions = f13FE_parent_instructions;
   body.emit(f13FE);

   /* END IF */

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fmul64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1434 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1434);
   ir_variable *const r1435 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1435);
   ir_variable *const r1436 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1436, body.constant(true), 0x01));

   ir_variable *const r1437 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1438 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r1438);
   ir_variable *const r1439 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r1439);
   ir_variable *const r143A = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r143A);
   ir_variable *const r143B = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r143B);
   ir_variable *const r143C = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r143C);
   ir_variable *const r143D = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r143D);
   ir_variable *const r143E = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r143E);
   ir_variable *const r143F = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r143F);
   ir_variable *const r1440 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r1440);
   ir_variable *const r1441 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r1441);
   ir_variable *const r1442 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r1442);
   body.emit(assign(r1442, body.constant(0u), 0x01));

   body.emit(assign(r1441, body.constant(0u), 0x01));

   body.emit(assign(r1440, body.constant(0u), 0x01));

   ir_variable *const r1443 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r1443, swizzle_x(r1434), 0x01));

   body.emit(assign(r143E, r1443, 0x01));

   ir_variable *const r1444 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1444, bit_and(swizzle_y(r1434), body.constant(1048575u)), 0x01));

   body.emit(assign(r143D, r1444, 0x01));

   ir_variable *const r1445 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r1445, swizzle_x(r1435), 0x01));

   body.emit(assign(r143C, r1445, 0x01));

   ir_variable *const r1446 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1446, bit_and(swizzle_y(r1435), body.constant(1048575u)), 0x01));

   body.emit(assign(r143B, r1446, 0x01));

   ir_variable *const r1447 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1448 = rshift(swizzle_y(r1434), body.constant(int(20)));
   ir_expression *const r1449 = bit_and(r1448, body.constant(2047u));
   body.emit(assign(r1447, expr(ir_unop_u2i, r1449), 0x01));

   body.emit(assign(r143A, r1447, 0x01));

   ir_variable *const r144A = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r144B = rshift(swizzle_y(r1435), body.constant(int(20)));
   ir_expression *const r144C = bit_and(r144B, body.constant(2047u));
   body.emit(assign(r144A, expr(ir_unop_u2i, r144C), 0x01));

   body.emit(assign(r1439, r144A, 0x01));

   ir_expression *const r144D = rshift(swizzle_y(r1434), body.constant(int(31)));
   ir_expression *const r144E = rshift(swizzle_y(r1435), body.constant(int(31)));
   body.emit(assign(r1438, bit_xor(r144D, r144E), 0x01));

   /* IF CONDITION */
   ir_expression *const r1450 = equal(r1447, body.constant(int(2047)));
   ir_if *f144F = new(mem_ctx) ir_if(operand(r1450).val);
   exec_list *const f144F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f144F->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1452 = bit_or(r1444, swizzle_x(r1434));
      ir_expression *const r1453 = nequal(r1452, body.constant(0u));
      ir_expression *const r1454 = equal(r144A, body.constant(int(2047)));
      ir_expression *const r1455 = bit_or(r1446, swizzle_x(r1435));
      ir_expression *const r1456 = nequal(r1455, body.constant(0u));
      ir_expression *const r1457 = logic_and(r1454, r1456);
      ir_expression *const r1458 = logic_or(r1453, r1457);
      ir_if *f1451 = new(mem_ctx) ir_if(operand(r1458).val);
      exec_list *const f1451_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1451->then_instructions;

         ir_variable *const r1459 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r1459, swizzle_x(r1434), 0x01));

         ir_variable *const r145A = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r145A, swizzle_x(r1435), 0x01));

         ir_variable *const r145B = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r145C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r145D = rshift(swizzle_y(r1434), body.constant(int(19)));
         ir_expression *const r145E = bit_and(r145D, body.constant(4095u));
         ir_expression *const r145F = equal(r145E, body.constant(4094u));
         ir_expression *const r1460 = nequal(swizzle_x(r1434), body.constant(0u));
         ir_expression *const r1461 = bit_and(swizzle_y(r1434), body.constant(524287u));
         ir_expression *const r1462 = nequal(r1461, body.constant(0u));
         ir_expression *const r1463 = logic_or(r1460, r1462);
         body.emit(assign(r145C, logic_and(r145F, r1463), 0x01));

         ir_variable *const r1464 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r1465 = lshift(swizzle_y(r1435), body.constant(int(1)));
         ir_expression *const r1466 = lequal(body.constant(4292870144u), r1465);
         ir_expression *const r1467 = nequal(swizzle_x(r1435), body.constant(0u));
         ir_expression *const r1468 = bit_and(swizzle_y(r1435), body.constant(1048575u));
         ir_expression *const r1469 = nequal(r1468, body.constant(0u));
         ir_expression *const r146A = logic_or(r1467, r1469);
         body.emit(assign(r1464, logic_and(r1466, r146A), 0x01));

         body.emit(assign(r1459, bit_or(swizzle_y(r1434), body.constant(524288u)), 0x02));

         body.emit(assign(r145A, bit_or(swizzle_y(r1435), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r146C = lshift(swizzle_y(r1434), body.constant(int(1)));
         ir_expression *const r146D = lequal(body.constant(4292870144u), r146C);
         ir_expression *const r146E = nequal(swizzle_x(r1434), body.constant(0u));
         ir_expression *const r146F = bit_and(swizzle_y(r1434), body.constant(1048575u));
         ir_expression *const r1470 = nequal(r146F, body.constant(0u));
         ir_expression *const r1471 = logic_or(r146E, r1470);
         ir_expression *const r1472 = logic_and(r146D, r1471);
         ir_if *f146B = new(mem_ctx) ir_if(operand(r1472).val);
         exec_list *const f146B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f146B->then_instructions;

            ir_variable *const r1473 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1475 = logic_and(r145C, r1464);
            ir_if *f1474 = new(mem_ctx) ir_if(operand(r1475).val);
            exec_list *const f1474_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1474->then_instructions;

               body.emit(assign(r1473, r145A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1474->else_instructions;

               body.emit(assign(r1473, r1459, 0x03));


            body.instructions = f1474_parent_instructions;
            body.emit(f1474);

            /* END IF */

            body.emit(assign(r145B, r1473, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f146B->else_instructions;

            body.emit(assign(r145B, r145A, 0x03));


         body.instructions = f146B_parent_instructions;
         body.emit(f146B);

         /* END IF */

         body.emit(assign(r1437, r145B, 0x03));

         body.emit(assign(r1436, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1451->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1477 = expr(ir_unop_i2u, r144A);
         ir_expression *const r1478 = bit_or(r1477, r1446);
         ir_expression *const r1479 = bit_or(r1478, swizzle_x(r1435));
         ir_expression *const r147A = equal(r1479, body.constant(0u));
         ir_if *f1476 = new(mem_ctx) ir_if(operand(r147A).val);
         exec_list *const f1476_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1476->then_instructions;

            ir_constant_data r147B_data;
            memset(&r147B_data, 0, sizeof(ir_constant_data));
            r147B_data.u[0] = 4294967295;
            r147B_data.u[1] = 4294967295;
            ir_constant *const r147B = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r147B_data);
            body.emit(assign(r1437, r147B, 0x03));

            body.emit(assign(r1436, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1476->else_instructions;

            ir_variable *const r147C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r147C);
            ir_expression *const r147D = lshift(r1438, body.constant(int(31)));
            body.emit(assign(r147C, add(r147D, body.constant(2146435072u)), 0x02));

            body.emit(assign(r147C, body.constant(0u), 0x01));

            body.emit(assign(r1437, r147C, 0x03));

            body.emit(assign(r1436, body.constant(false), 0x01));


         body.instructions = f1476_parent_instructions;
         body.emit(f1476);

         /* END IF */


      body.instructions = f1451_parent_instructions;
      body.emit(f1451);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f144F->else_instructions;

      /* IF CONDITION */
      ir_expression *const r147F = equal(r144A, body.constant(int(2047)));
      ir_if *f147E = new(mem_ctx) ir_if(operand(r147F).val);
      exec_list *const f147E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f147E->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1481 = bit_or(r1446, swizzle_x(r1435));
         ir_expression *const r1482 = nequal(r1481, body.constant(0u));
         ir_if *f1480 = new(mem_ctx) ir_if(operand(r1482).val);
         exec_list *const f1480_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1480->then_instructions;

            ir_variable *const r1483 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r1483, swizzle_x(r1434), 0x01));

            ir_variable *const r1484 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r1484, swizzle_x(r1435), 0x01));

            ir_variable *const r1485 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r1486 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r1487 = rshift(swizzle_y(r1434), body.constant(int(19)));
            ir_expression *const r1488 = bit_and(r1487, body.constant(4095u));
            ir_expression *const r1489 = equal(r1488, body.constant(4094u));
            ir_expression *const r148A = nequal(swizzle_x(r1434), body.constant(0u));
            ir_expression *const r148B = bit_and(swizzle_y(r1434), body.constant(524287u));
            ir_expression *const r148C = nequal(r148B, body.constant(0u));
            ir_expression *const r148D = logic_or(r148A, r148C);
            body.emit(assign(r1486, logic_and(r1489, r148D), 0x01));

            ir_variable *const r148E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r148F = lshift(swizzle_y(r1435), body.constant(int(1)));
            ir_expression *const r1490 = lequal(body.constant(4292870144u), r148F);
            ir_expression *const r1491 = nequal(swizzle_x(r1435), body.constant(0u));
            ir_expression *const r1492 = bit_and(swizzle_y(r1435), body.constant(1048575u));
            ir_expression *const r1493 = nequal(r1492, body.constant(0u));
            ir_expression *const r1494 = logic_or(r1491, r1493);
            body.emit(assign(r148E, logic_and(r1490, r1494), 0x01));

            body.emit(assign(r1483, bit_or(swizzle_y(r1434), body.constant(524288u)), 0x02));

            body.emit(assign(r1484, bit_or(swizzle_y(r1435), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r1496 = lshift(swizzle_y(r1434), body.constant(int(1)));
            ir_expression *const r1497 = lequal(body.constant(4292870144u), r1496);
            ir_expression *const r1498 = nequal(swizzle_x(r1434), body.constant(0u));
            ir_expression *const r1499 = bit_and(swizzle_y(r1434), body.constant(1048575u));
            ir_expression *const r149A = nequal(r1499, body.constant(0u));
            ir_expression *const r149B = logic_or(r1498, r149A);
            ir_expression *const r149C = logic_and(r1497, r149B);
            ir_if *f1495 = new(mem_ctx) ir_if(operand(r149C).val);
            exec_list *const f1495_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1495->then_instructions;

               ir_variable *const r149D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r149F = logic_and(r1486, r148E);
               ir_if *f149E = new(mem_ctx) ir_if(operand(r149F).val);
               exec_list *const f149E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f149E->then_instructions;

                  body.emit(assign(r149D, r1484, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f149E->else_instructions;

                  body.emit(assign(r149D, r1483, 0x03));


               body.instructions = f149E_parent_instructions;
               body.emit(f149E);

               /* END IF */

               body.emit(assign(r1485, r149D, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1495->else_instructions;

               body.emit(assign(r1485, r1484, 0x03));


            body.instructions = f1495_parent_instructions;
            body.emit(f1495);

            /* END IF */

            body.emit(assign(r1437, r1485, 0x03));

            body.emit(assign(r1436, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1480->else_instructions;

            /* IF CONDITION */
            ir_expression *const r14A1 = expr(ir_unop_i2u, r1447);
            ir_expression *const r14A2 = bit_or(r14A1, r1444);
            ir_expression *const r14A3 = bit_or(r14A2, swizzle_x(r1434));
            ir_expression *const r14A4 = equal(r14A3, body.constant(0u));
            ir_if *f14A0 = new(mem_ctx) ir_if(operand(r14A4).val);
            exec_list *const f14A0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14A0->then_instructions;

               ir_constant_data r14A5_data;
               memset(&r14A5_data, 0, sizeof(ir_constant_data));
               r14A5_data.u[0] = 4294967295;
               r14A5_data.u[1] = 4294967295;
               ir_constant *const r14A5 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r14A5_data);
               body.emit(assign(r1437, r14A5, 0x03));

               body.emit(assign(r1436, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f14A0->else_instructions;

               ir_variable *const r14A6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r14A6);
               ir_expression *const r14A7 = lshift(r1438, body.constant(int(31)));
               body.emit(assign(r14A6, add(r14A7, body.constant(2146435072u)), 0x02));

               body.emit(assign(r14A6, body.constant(0u), 0x01));

               body.emit(assign(r1437, r14A6, 0x03));

               body.emit(assign(r1436, body.constant(false), 0x01));


            body.instructions = f14A0_parent_instructions;
            body.emit(f14A0);

            /* END IF */


         body.instructions = f1480_parent_instructions;
         body.emit(f1480);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f147E->else_instructions;

         /* IF CONDITION */
         ir_expression *const r14A9 = equal(r1447, body.constant(int(0)));
         ir_if *f14A8 = new(mem_ctx) ir_if(operand(r14A9).val);
         exec_list *const f14A8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f14A8->then_instructions;

            /* IF CONDITION */
            ir_expression *const r14AB = bit_or(r1444, swizzle_x(r1434));
            ir_expression *const r14AC = equal(r14AB, body.constant(0u));
            ir_if *f14AA = new(mem_ctx) ir_if(operand(r14AC).val);
            exec_list *const f14AA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14AA->then_instructions;

               ir_variable *const r14AD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r14AD);
               body.emit(assign(r14AD, lshift(r1438, body.constant(int(31))), 0x02));

               body.emit(assign(r14AD, body.constant(0u), 0x01));

               body.emit(assign(r1437, r14AD, 0x03));

               body.emit(assign(r1436, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f14AA->else_instructions;

               ir_variable *const r14AE = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r14AE, r1447, 0x01));

               ir_variable *const r14AF = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r14AF, r1444, 0x01));

               ir_variable *const r14B0 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r14B0, r1443, 0x01));

               ir_variable *const r14B1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r14B1);
               /* IF CONDITION */
               ir_expression *const r14B3 = equal(r1444, body.constant(0u));
               ir_if *f14B2 = new(mem_ctx) ir_if(operand(r14B3).val);
               exec_list *const f14B2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f14B2->then_instructions;

                  ir_variable *const r14B4 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r14B4, r1443, 0x01));

                  ir_variable *const r14B5 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r14B6 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14B6);
                  /* IF CONDITION */
                  ir_expression *const r14B8 = equal(swizzle_x(r1434), body.constant(0u));
                  ir_if *f14B7 = new(mem_ctx) ir_if(operand(r14B8).val);
                  exec_list *const f14B7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14B7->then_instructions;

                     body.emit(assign(r14B5, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14B7->else_instructions;

                     body.emit(assign(r14B6, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r14BA = bit_and(swizzle_x(r1434), body.constant(4294901760u));
                     ir_expression *const r14BB = equal(r14BA, body.constant(0u));
                     ir_if *f14B9 = new(mem_ctx) ir_if(operand(r14BB).val);
                     exec_list *const f14B9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14B9->then_instructions;

                        body.emit(assign(r14B6, body.constant(int(16)), 0x01));

                        body.emit(assign(r14B4, lshift(swizzle_x(r1434), body.constant(int(16))), 0x01));


                     body.instructions = f14B9_parent_instructions;
                     body.emit(f14B9);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14BD = bit_and(r14B4, body.constant(4278190080u));
                     ir_expression *const r14BE = equal(r14BD, body.constant(0u));
                     ir_if *f14BC = new(mem_ctx) ir_if(operand(r14BE).val);
                     exec_list *const f14BC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14BC->then_instructions;

                        body.emit(assign(r14B6, add(r14B6, body.constant(int(8))), 0x01));

                        body.emit(assign(r14B4, lshift(r14B4, body.constant(int(8))), 0x01));


                     body.instructions = f14BC_parent_instructions;
                     body.emit(f14BC);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C0 = bit_and(r14B4, body.constant(4026531840u));
                     ir_expression *const r14C1 = equal(r14C0, body.constant(0u));
                     ir_if *f14BF = new(mem_ctx) ir_if(operand(r14C1).val);
                     exec_list *const f14BF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14BF->then_instructions;

                        body.emit(assign(r14B6, add(r14B6, body.constant(int(4))), 0x01));

                        body.emit(assign(r14B4, lshift(r14B4, body.constant(int(4))), 0x01));


                     body.instructions = f14BF_parent_instructions;
                     body.emit(f14BF);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C3 = bit_and(r14B4, body.constant(3221225472u));
                     ir_expression *const r14C4 = equal(r14C3, body.constant(0u));
                     ir_if *f14C2 = new(mem_ctx) ir_if(operand(r14C4).val);
                     exec_list *const f14C2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14C2->then_instructions;

                        body.emit(assign(r14B6, add(r14B6, body.constant(int(2))), 0x01));

                        body.emit(assign(r14B4, lshift(r14B4, body.constant(int(2))), 0x01));


                     body.instructions = f14C2_parent_instructions;
                     body.emit(f14C2);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C6 = bit_and(r14B4, body.constant(2147483648u));
                     ir_expression *const r14C7 = equal(r14C6, body.constant(0u));
                     ir_if *f14C5 = new(mem_ctx) ir_if(operand(r14C7).val);
                     exec_list *const f14C5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14C5->then_instructions;

                        body.emit(assign(r14B6, add(r14B6, body.constant(int(1))), 0x01));


                     body.instructions = f14C5_parent_instructions;
                     body.emit(f14C5);

                     /* END IF */

                     body.emit(assign(r14B5, r14B6, 0x01));


                  body.instructions = f14B7_parent_instructions;
                  body.emit(f14B7);

                  /* END IF */

                  body.emit(assign(r14B1, add(r14B5, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r14C9 = less(r14B1, body.constant(int(0)));
                  ir_if *f14C8 = new(mem_ctx) ir_if(operand(r14C9).val);
                  exec_list *const f14C8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14C8->then_instructions;

                     ir_expression *const r14CA = neg(r14B1);
                     body.emit(assign(r14AF, rshift(swizzle_x(r1434), r14CA), 0x01));

                     ir_expression *const r14CB = bit_and(r14B1, body.constant(int(31)));
                     body.emit(assign(r14B0, lshift(swizzle_x(r1434), r14CB), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14C8->else_instructions;

                     body.emit(assign(r14AF, lshift(swizzle_x(r1434), r14B1), 0x01));

                     body.emit(assign(r14B0, body.constant(0u), 0x01));


                  body.instructions = f14C8_parent_instructions;
                  body.emit(f14C8);

                  /* END IF */

                  body.emit(assign(r14AE, sub(body.constant(int(-31)), r14B1), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f14B2->else_instructions;

                  ir_variable *const r14CC = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r14CC, r1444, 0x01));

                  ir_variable *const r14CD = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r14CE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14CE);
                  /* IF CONDITION */
                  ir_expression *const r14D0 = equal(r1444, body.constant(0u));
                  ir_if *f14CF = new(mem_ctx) ir_if(operand(r14D0).val);
                  exec_list *const f14CF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14CF->then_instructions;

                     body.emit(assign(r14CD, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14CF->else_instructions;

                     body.emit(assign(r14CE, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r14D2 = bit_and(r1444, body.constant(4294901760u));
                     ir_expression *const r14D3 = equal(r14D2, body.constant(0u));
                     ir_if *f14D1 = new(mem_ctx) ir_if(operand(r14D3).val);
                     exec_list *const f14D1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D1->then_instructions;

                        body.emit(assign(r14CE, body.constant(int(16)), 0x01));

                        body.emit(assign(r14CC, lshift(r1444, body.constant(int(16))), 0x01));


                     body.instructions = f14D1_parent_instructions;
                     body.emit(f14D1);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14D5 = bit_and(r14CC, body.constant(4278190080u));
                     ir_expression *const r14D6 = equal(r14D5, body.constant(0u));
                     ir_if *f14D4 = new(mem_ctx) ir_if(operand(r14D6).val);
                     exec_list *const f14D4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D4->then_instructions;

                        body.emit(assign(r14CE, add(r14CE, body.constant(int(8))), 0x01));

                        body.emit(assign(r14CC, lshift(r14CC, body.constant(int(8))), 0x01));


                     body.instructions = f14D4_parent_instructions;
                     body.emit(f14D4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14D8 = bit_and(r14CC, body.constant(4026531840u));
                     ir_expression *const r14D9 = equal(r14D8, body.constant(0u));
                     ir_if *f14D7 = new(mem_ctx) ir_if(operand(r14D9).val);
                     exec_list *const f14D7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D7->then_instructions;

                        body.emit(assign(r14CE, add(r14CE, body.constant(int(4))), 0x01));

                        body.emit(assign(r14CC, lshift(r14CC, body.constant(int(4))), 0x01));


                     body.instructions = f14D7_parent_instructions;
                     body.emit(f14D7);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14DB = bit_and(r14CC, body.constant(3221225472u));
                     ir_expression *const r14DC = equal(r14DB, body.constant(0u));
                     ir_if *f14DA = new(mem_ctx) ir_if(operand(r14DC).val);
                     exec_list *const f14DA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14DA->then_instructions;

                        body.emit(assign(r14CE, add(r14CE, body.constant(int(2))), 0x01));

                        body.emit(assign(r14CC, lshift(r14CC, body.constant(int(2))), 0x01));


                     body.instructions = f14DA_parent_instructions;
                     body.emit(f14DA);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14DE = bit_and(r14CC, body.constant(2147483648u));
                     ir_expression *const r14DF = equal(r14DE, body.constant(0u));
                     ir_if *f14DD = new(mem_ctx) ir_if(operand(r14DF).val);
                     exec_list *const f14DD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14DD->then_instructions;

                        body.emit(assign(r14CE, add(r14CE, body.constant(int(1))), 0x01));


                     body.instructions = f14DD_parent_instructions;
                     body.emit(f14DD);

                     /* END IF */

                     body.emit(assign(r14CD, r14CE, 0x01));


                  body.instructions = f14CF_parent_instructions;
                  body.emit(f14CF);

                  /* END IF */

                  body.emit(assign(r14B1, add(r14CD, body.constant(int(-11))), 0x01));

                  ir_variable *const r14E0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r14E0, lshift(swizzle_x(r1434), r14B1), 0x01));

                  ir_variable *const r14E1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r14E3 = equal(r14B1, body.constant(int(0)));
                  ir_if *f14E2 = new(mem_ctx) ir_if(operand(r14E3).val);
                  exec_list *const f14E2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14E2->then_instructions;

                     body.emit(assign(r14E1, r1444, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14E2->else_instructions;

                     ir_expression *const r14E4 = lshift(r1444, r14B1);
                     ir_expression *const r14E5 = neg(r14B1);
                     ir_expression *const r14E6 = bit_and(r14E5, body.constant(int(31)));
                     ir_expression *const r14E7 = rshift(swizzle_x(r1434), r14E6);
                     body.emit(assign(r14E1, bit_or(r14E4, r14E7), 0x01));


                  body.instructions = f14E2_parent_instructions;
                  body.emit(f14E2);

                  /* END IF */

                  body.emit(assign(r14AF, r14E1, 0x01));

                  body.emit(assign(r14B0, r14E0, 0x01));

                  body.emit(assign(r14AE, sub(body.constant(int(1)), r14B1), 0x01));


               body.instructions = f14B2_parent_instructions;
               body.emit(f14B2);

               /* END IF */

               body.emit(assign(r143A, r14AE, 0x01));

               body.emit(assign(r143D, r14AF, 0x01));

               body.emit(assign(r143E, r14B0, 0x01));


            body.instructions = f14AA_parent_instructions;
            body.emit(f14AA);

            /* END IF */


         body.instructions = f14A8_parent_instructions;
         body.emit(f14A8);

         /* END IF */

         /* IF CONDITION */
         ir_if *f14E8 = new(mem_ctx) ir_if(operand(r1436).val);
         exec_list *const f14E8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f14E8->then_instructions;

            /* IF CONDITION */
            ir_expression *const r14EA = equal(r144A, body.constant(int(0)));
            ir_if *f14E9 = new(mem_ctx) ir_if(operand(r14EA).val);
            exec_list *const f14E9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14E9->then_instructions;

               /* IF CONDITION */
               ir_expression *const r14EC = bit_or(r1446, swizzle_x(r1435));
               ir_expression *const r14ED = equal(r14EC, body.constant(0u));
               ir_if *f14EB = new(mem_ctx) ir_if(operand(r14ED).val);
               exec_list *const f14EB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f14EB->then_instructions;

                  ir_variable *const r14EE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r14EE);
                  body.emit(assign(r14EE, lshift(r1438, body.constant(int(31))), 0x02));

                  body.emit(assign(r14EE, body.constant(0u), 0x01));

                  body.emit(assign(r1437, r14EE, 0x03));

                  body.emit(assign(r1436, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f14EB->else_instructions;

                  ir_variable *const r14EF = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r14EF, r144A, 0x01));

                  ir_variable *const r14F0 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r14F0, r1446, 0x01));

                  ir_variable *const r14F1 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r14F1, r1445, 0x01));

                  ir_variable *const r14F2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14F2);
                  /* IF CONDITION */
                  ir_expression *const r14F4 = equal(r1446, body.constant(0u));
                  ir_if *f14F3 = new(mem_ctx) ir_if(operand(r14F4).val);
                  exec_list *const f14F3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14F3->then_instructions;

                     ir_variable *const r14F5 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r14F5, r1445, 0x01));

                     ir_variable *const r14F6 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r14F7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r14F7);
                     /* IF CONDITION */
                     ir_expression *const r14F9 = equal(swizzle_x(r1435), body.constant(0u));
                     ir_if *f14F8 = new(mem_ctx) ir_if(operand(r14F9).val);
                     exec_list *const f14F8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14F8->then_instructions;

                        body.emit(assign(r14F6, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f14F8->else_instructions;

                        body.emit(assign(r14F7, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r14FB = bit_and(swizzle_x(r1435), body.constant(4294901760u));
                        ir_expression *const r14FC = equal(r14FB, body.constant(0u));
                        ir_if *f14FA = new(mem_ctx) ir_if(operand(r14FC).val);
                        exec_list *const f14FA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f14FA->then_instructions;

                           body.emit(assign(r14F7, body.constant(int(16)), 0x01));

                           body.emit(assign(r14F5, lshift(swizzle_x(r1435), body.constant(int(16))), 0x01));


                        body.instructions = f14FA_parent_instructions;
                        body.emit(f14FA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r14FE = bit_and(r14F5, body.constant(4278190080u));
                        ir_expression *const r14FF = equal(r14FE, body.constant(0u));
                        ir_if *f14FD = new(mem_ctx) ir_if(operand(r14FF).val);
                        exec_list *const f14FD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f14FD->then_instructions;

                           body.emit(assign(r14F7, add(r14F7, body.constant(int(8))), 0x01));

                           body.emit(assign(r14F5, lshift(r14F5, body.constant(int(8))), 0x01));


                        body.instructions = f14FD_parent_instructions;
                        body.emit(f14FD);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1501 = bit_and(r14F5, body.constant(4026531840u));
                        ir_expression *const r1502 = equal(r1501, body.constant(0u));
                        ir_if *f1500 = new(mem_ctx) ir_if(operand(r1502).val);
                        exec_list *const f1500_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1500->then_instructions;

                           body.emit(assign(r14F7, add(r14F7, body.constant(int(4))), 0x01));

                           body.emit(assign(r14F5, lshift(r14F5, body.constant(int(4))), 0x01));


                        body.instructions = f1500_parent_instructions;
                        body.emit(f1500);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1504 = bit_and(r14F5, body.constant(3221225472u));
                        ir_expression *const r1505 = equal(r1504, body.constant(0u));
                        ir_if *f1503 = new(mem_ctx) ir_if(operand(r1505).val);
                        exec_list *const f1503_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1503->then_instructions;

                           body.emit(assign(r14F7, add(r14F7, body.constant(int(2))), 0x01));

                           body.emit(assign(r14F5, lshift(r14F5, body.constant(int(2))), 0x01));


                        body.instructions = f1503_parent_instructions;
                        body.emit(f1503);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1507 = bit_and(r14F5, body.constant(2147483648u));
                        ir_expression *const r1508 = equal(r1507, body.constant(0u));
                        ir_if *f1506 = new(mem_ctx) ir_if(operand(r1508).val);
                        exec_list *const f1506_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1506->then_instructions;

                           body.emit(assign(r14F7, add(r14F7, body.constant(int(1))), 0x01));


                        body.instructions = f1506_parent_instructions;
                        body.emit(f1506);

                        /* END IF */

                        body.emit(assign(r14F6, r14F7, 0x01));


                     body.instructions = f14F8_parent_instructions;
                     body.emit(f14F8);

                     /* END IF */

                     body.emit(assign(r14F2, add(r14F6, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r150A = less(r14F2, body.constant(int(0)));
                     ir_if *f1509 = new(mem_ctx) ir_if(operand(r150A).val);
                     exec_list *const f1509_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1509->then_instructions;

                        ir_expression *const r150B = neg(r14F2);
                        body.emit(assign(r14F0, rshift(swizzle_x(r1435), r150B), 0x01));

                        ir_expression *const r150C = bit_and(r14F2, body.constant(int(31)));
                        body.emit(assign(r14F1, lshift(swizzle_x(r1435), r150C), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1509->else_instructions;

                        body.emit(assign(r14F0, lshift(swizzle_x(r1435), r14F2), 0x01));

                        body.emit(assign(r14F1, body.constant(0u), 0x01));


                     body.instructions = f1509_parent_instructions;
                     body.emit(f1509);

                     /* END IF */

                     body.emit(assign(r14EF, sub(body.constant(int(-31)), r14F2), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14F3->else_instructions;

                     ir_variable *const r150D = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r150D, r1446, 0x01));

                     ir_variable *const r150E = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r150F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r150F);
                     /* IF CONDITION */
                     ir_expression *const r1511 = equal(r1446, body.constant(0u));
                     ir_if *f1510 = new(mem_ctx) ir_if(operand(r1511).val);
                     exec_list *const f1510_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1510->then_instructions;

                        body.emit(assign(r150E, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1510->else_instructions;

                        body.emit(assign(r150F, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1513 = bit_and(r1446, body.constant(4294901760u));
                        ir_expression *const r1514 = equal(r1513, body.constant(0u));
                        ir_if *f1512 = new(mem_ctx) ir_if(operand(r1514).val);
                        exec_list *const f1512_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1512->then_instructions;

                           body.emit(assign(r150F, body.constant(int(16)), 0x01));

                           body.emit(assign(r150D, lshift(r1446, body.constant(int(16))), 0x01));


                        body.instructions = f1512_parent_instructions;
                        body.emit(f1512);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1516 = bit_and(r150D, body.constant(4278190080u));
                        ir_expression *const r1517 = equal(r1516, body.constant(0u));
                        ir_if *f1515 = new(mem_ctx) ir_if(operand(r1517).val);
                        exec_list *const f1515_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1515->then_instructions;

                           body.emit(assign(r150F, add(r150F, body.constant(int(8))), 0x01));

                           body.emit(assign(r150D, lshift(r150D, body.constant(int(8))), 0x01));


                        body.instructions = f1515_parent_instructions;
                        body.emit(f1515);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1519 = bit_and(r150D, body.constant(4026531840u));
                        ir_expression *const r151A = equal(r1519, body.constant(0u));
                        ir_if *f1518 = new(mem_ctx) ir_if(operand(r151A).val);
                        exec_list *const f1518_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1518->then_instructions;

                           body.emit(assign(r150F, add(r150F, body.constant(int(4))), 0x01));

                           body.emit(assign(r150D, lshift(r150D, body.constant(int(4))), 0x01));


                        body.instructions = f1518_parent_instructions;
                        body.emit(f1518);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r151C = bit_and(r150D, body.constant(3221225472u));
                        ir_expression *const r151D = equal(r151C, body.constant(0u));
                        ir_if *f151B = new(mem_ctx) ir_if(operand(r151D).val);
                        exec_list *const f151B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f151B->then_instructions;

                           body.emit(assign(r150F, add(r150F, body.constant(int(2))), 0x01));

                           body.emit(assign(r150D, lshift(r150D, body.constant(int(2))), 0x01));


                        body.instructions = f151B_parent_instructions;
                        body.emit(f151B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r151F = bit_and(r150D, body.constant(2147483648u));
                        ir_expression *const r1520 = equal(r151F, body.constant(0u));
                        ir_if *f151E = new(mem_ctx) ir_if(operand(r1520).val);
                        exec_list *const f151E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f151E->then_instructions;

                           body.emit(assign(r150F, add(r150F, body.constant(int(1))), 0x01));


                        body.instructions = f151E_parent_instructions;
                        body.emit(f151E);

                        /* END IF */

                        body.emit(assign(r150E, r150F, 0x01));


                     body.instructions = f1510_parent_instructions;
                     body.emit(f1510);

                     /* END IF */

                     body.emit(assign(r14F2, add(r150E, body.constant(int(-11))), 0x01));

                     ir_variable *const r1521 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r1521, lshift(swizzle_x(r1435), r14F2), 0x01));

                     ir_variable *const r1522 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1524 = equal(r14F2, body.constant(int(0)));
                     ir_if *f1523 = new(mem_ctx) ir_if(operand(r1524).val);
                     exec_list *const f1523_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1523->then_instructions;

                        body.emit(assign(r1522, r1446, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1523->else_instructions;

                        ir_expression *const r1525 = lshift(r1446, r14F2);
                        ir_expression *const r1526 = neg(r14F2);
                        ir_expression *const r1527 = bit_and(r1526, body.constant(int(31)));
                        ir_expression *const r1528 = rshift(swizzle_x(r1435), r1527);
                        body.emit(assign(r1522, bit_or(r1525, r1528), 0x01));


                     body.instructions = f1523_parent_instructions;
                     body.emit(f1523);

                     /* END IF */

                     body.emit(assign(r14F0, r1522, 0x01));

                     body.emit(assign(r14F1, r1521, 0x01));

                     body.emit(assign(r14EF, sub(body.constant(int(1)), r14F2), 0x01));


                  body.instructions = f14F3_parent_instructions;
                  body.emit(f14F3);

                  /* END IF */

                  body.emit(assign(r1439, r14EF, 0x01));

                  body.emit(assign(r143B, r14F0, 0x01));

                  body.emit(assign(r143C, r14F1, 0x01));


               body.instructions = f14EB_parent_instructions;
               body.emit(f14EB);

               /* END IF */


            body.instructions = f14E9_parent_instructions;
            body.emit(f14E9);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1529 = new(mem_ctx) ir_if(operand(r1436).val);
            exec_list *const f1529_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1529->then_instructions;

               ir_expression *const r152A = add(r143A, r1439);
               body.emit(assign(r143F, add(r152A, body.constant(int(-1024))), 0x01));

               body.emit(assign(r143D, bit_or(r143D, body.constant(1048576u)), 0x01));

               ir_variable *const r152B = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r152B, lshift(r143C, body.constant(int(12))), 0x01));

               ir_variable *const r152C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r152D = lshift(r143B, body.constant(int(12)));
               ir_expression *const r152E = rshift(r143C, body.constant(int(20)));
               body.emit(assign(r152C, bit_or(r152D, r152E), 0x01));

               body.emit(assign(r143B, r152C, 0x01));

               body.emit(assign(r143C, r152B, 0x01));

               ir_variable *const r152F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r152F);
               ir_variable *const r1530 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1530);
               ir_variable *const r1531 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1531);
               ir_variable *const r1532 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1532, bit_and(r143E, body.constant(65535u)), 0x01));

               ir_variable *const r1533 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1533, rshift(r143E, body.constant(int(16))), 0x01));

               ir_variable *const r1534 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1534, bit_and(r152B, body.constant(65535u)), 0x01));

               ir_variable *const r1535 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1535, rshift(r152B, body.constant(int(16))), 0x01));

               ir_variable *const r1536 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1536, mul(r1533, r1534), 0x01));

               ir_expression *const r1537 = mul(r1532, r1535);
               body.emit(assign(r1530, add(r1537, r1536), 0x01));

               ir_expression *const r1538 = mul(r1533, r1535);
               ir_expression *const r1539 = less(r1530, r1536);
               ir_expression *const r153A = expr(ir_unop_b2i, r1539);
               ir_expression *const r153B = expr(ir_unop_i2u, r153A);
               ir_expression *const r153C = lshift(r153B, body.constant(int(16)));
               ir_expression *const r153D = rshift(r1530, body.constant(int(16)));
               ir_expression *const r153E = add(r153C, r153D);
               body.emit(assign(r152F, add(r1538, r153E), 0x01));

               body.emit(assign(r1530, lshift(r1530, body.constant(int(16))), 0x01));

               ir_expression *const r153F = mul(r1532, r1534);
               body.emit(assign(r1531, add(r153F, r1530), 0x01));

               ir_expression *const r1540 = less(r1531, r1530);
               ir_expression *const r1541 = expr(ir_unop_b2i, r1540);
               ir_expression *const r1542 = expr(ir_unop_i2u, r1541);
               body.emit(assign(r152F, add(r152F, r1542), 0x01));

               ir_variable *const r1543 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1543);
               ir_variable *const r1544 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1544);
               ir_variable *const r1545 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1545);
               ir_variable *const r1546 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1546, bit_and(r143E, body.constant(65535u)), 0x01));

               ir_variable *const r1547 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1547, rshift(r143E, body.constant(int(16))), 0x01));

               ir_variable *const r1548 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1548, bit_and(r152C, body.constant(65535u)), 0x01));

               ir_variable *const r1549 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1549, rshift(r152C, body.constant(int(16))), 0x01));

               ir_variable *const r154A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154A, mul(r1547, r1548), 0x01));

               ir_expression *const r154B = mul(r1546, r1549);
               body.emit(assign(r1544, add(r154B, r154A), 0x01));

               ir_expression *const r154C = mul(r1547, r1549);
               ir_expression *const r154D = less(r1544, r154A);
               ir_expression *const r154E = expr(ir_unop_b2i, r154D);
               ir_expression *const r154F = expr(ir_unop_i2u, r154E);
               ir_expression *const r1550 = lshift(r154F, body.constant(int(16)));
               ir_expression *const r1551 = rshift(r1544, body.constant(int(16)));
               ir_expression *const r1552 = add(r1550, r1551);
               body.emit(assign(r1543, add(r154C, r1552), 0x01));

               body.emit(assign(r1544, lshift(r1544, body.constant(int(16))), 0x01));

               ir_expression *const r1553 = mul(r1546, r1548);
               body.emit(assign(r1545, add(r1553, r1544), 0x01));

               ir_expression *const r1554 = less(r1545, r1544);
               ir_expression *const r1555 = expr(ir_unop_b2i, r1554);
               ir_expression *const r1556 = expr(ir_unop_i2u, r1555);
               body.emit(assign(r1543, add(r1543, r1556), 0x01));

               ir_variable *const r1557 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1557, add(r1545, r152F), 0x01));

               ir_variable *const r1558 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1558);
               ir_variable *const r1559 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1559);
               ir_variable *const r155A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r155A);
               ir_variable *const r155B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155B, bit_and(r143D, body.constant(65535u)), 0x01));

               ir_variable *const r155C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155C, rshift(r143D, body.constant(int(16))), 0x01));

               ir_variable *const r155D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155D, bit_and(r152C, body.constant(65535u)), 0x01));

               ir_variable *const r155E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155E, rshift(r152C, body.constant(int(16))), 0x01));

               ir_variable *const r155F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155F, mul(r155C, r155D), 0x01));

               ir_expression *const r1560 = mul(r155B, r155E);
               body.emit(assign(r1559, add(r1560, r155F), 0x01));

               ir_expression *const r1561 = mul(r155C, r155E);
               ir_expression *const r1562 = less(r1559, r155F);
               ir_expression *const r1563 = expr(ir_unop_b2i, r1562);
               ir_expression *const r1564 = expr(ir_unop_i2u, r1563);
               ir_expression *const r1565 = lshift(r1564, body.constant(int(16)));
               ir_expression *const r1566 = rshift(r1559, body.constant(int(16)));
               ir_expression *const r1567 = add(r1565, r1566);
               body.emit(assign(r1558, add(r1561, r1567), 0x01));

               body.emit(assign(r1559, lshift(r1559, body.constant(int(16))), 0x01));

               ir_expression *const r1568 = mul(r155B, r155D);
               body.emit(assign(r155A, add(r1568, r1559), 0x01));

               ir_expression *const r1569 = less(r155A, r1559);
               ir_expression *const r156A = expr(ir_unop_b2i, r1569);
               ir_expression *const r156B = expr(ir_unop_i2u, r156A);
               body.emit(assign(r1558, add(r1558, r156B), 0x01));

               ir_variable *const r156C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r156D = less(r1557, r1545);
               ir_expression *const r156E = expr(ir_unop_b2i, r156D);
               ir_expression *const r156F = expr(ir_unop_i2u, r156E);
               ir_expression *const r1570 = add(r1543, r156F);
               body.emit(assign(r156C, add(r155A, r1570), 0x01));

               ir_variable *const r1571 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1571);
               ir_variable *const r1572 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1572);
               ir_variable *const r1573 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1573);
               ir_variable *const r1574 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1574, bit_and(r143D, body.constant(65535u)), 0x01));

               ir_variable *const r1575 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1575, rshift(r143D, body.constant(int(16))), 0x01));

               ir_variable *const r1576 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1576, bit_and(r152B, body.constant(65535u)), 0x01));

               ir_variable *const r1577 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1577, rshift(r152B, body.constant(int(16))), 0x01));

               ir_variable *const r1578 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1578, mul(r1575, r1576), 0x01));

               ir_expression *const r1579 = mul(r1574, r1577);
               body.emit(assign(r1572, add(r1579, r1578), 0x01));

               ir_expression *const r157A = mul(r1575, r1577);
               ir_expression *const r157B = less(r1572, r1578);
               ir_expression *const r157C = expr(ir_unop_b2i, r157B);
               ir_expression *const r157D = expr(ir_unop_i2u, r157C);
               ir_expression *const r157E = lshift(r157D, body.constant(int(16)));
               ir_expression *const r157F = rshift(r1572, body.constant(int(16)));
               ir_expression *const r1580 = add(r157E, r157F);
               body.emit(assign(r1571, add(r157A, r1580), 0x01));

               body.emit(assign(r1572, lshift(r1572, body.constant(int(16))), 0x01));

               ir_expression *const r1581 = mul(r1574, r1576);
               body.emit(assign(r1573, add(r1581, r1572), 0x01));

               ir_expression *const r1582 = less(r1573, r1572);
               ir_expression *const r1583 = expr(ir_unop_b2i, r1582);
               ir_expression *const r1584 = expr(ir_unop_i2u, r1583);
               body.emit(assign(r1571, add(r1571, r1584), 0x01));

               ir_variable *const r1585 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1585, add(r1573, r1557), 0x01));

               ir_variable *const r1586 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r1587 = less(r1585, r1573);
               ir_expression *const r1588 = expr(ir_unop_b2i, r1587);
               ir_expression *const r1589 = expr(ir_unop_i2u, r1588);
               ir_expression *const r158A = add(r1571, r1589);
               body.emit(assign(r1586, add(r156C, r158A), 0x01));

               ir_variable *const r158B = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r158C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r158C, add(r1586, r143E), 0x01));

               ir_expression *const r158D = less(r156C, r155A);
               ir_expression *const r158E = expr(ir_unop_b2i, r158D);
               ir_expression *const r158F = expr(ir_unop_i2u, r158E);
               ir_expression *const r1590 = add(r1558, r158F);
               ir_expression *const r1591 = less(r1586, r156C);
               ir_expression *const r1592 = expr(ir_unop_b2i, r1591);
               ir_expression *const r1593 = expr(ir_unop_i2u, r1592);
               ir_expression *const r1594 = add(r1590, r1593);
               ir_expression *const r1595 = add(r1594, r143D);
               ir_expression *const r1596 = less(r158C, r1586);
               ir_expression *const r1597 = expr(ir_unop_b2i, r1596);
               ir_expression *const r1598 = expr(ir_unop_i2u, r1597);
               body.emit(assign(r158B, add(r1595, r1598), 0x01));

               body.emit(assign(r1442, r158B, 0x01));

               body.emit(assign(r1441, r158C, 0x01));

               ir_expression *const r1599 = nequal(r1531, body.constant(0u));
               ir_expression *const r159A = expr(ir_unop_b2i, r1599);
               ir_expression *const r159B = expr(ir_unop_i2u, r159A);
               body.emit(assign(r1440, bit_or(r1585, r159B), 0x01));

               /* IF CONDITION */
               ir_expression *const r159D = lequal(body.constant(2097152u), r158B);
               ir_if *f159C = new(mem_ctx) ir_if(operand(r159D).val);
               exec_list *const f159C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f159C->then_instructions;

                  ir_variable *const r159E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r159E);
                  body.emit(assign(r159E, lshift(r158C, body.constant(int(31))), 0x01));

                  ir_expression *const r159F = nequal(r1440, body.constant(0u));
                  ir_expression *const r15A0 = expr(ir_unop_b2i, r159F);
                  ir_expression *const r15A1 = expr(ir_unop_i2u, r15A0);
                  body.emit(assign(r159E, bit_or(r159E, r15A1), 0x01));

                  body.emit(assign(r1442, rshift(r158B, body.constant(int(1))), 0x01));

                  ir_expression *const r15A2 = lshift(r158B, body.constant(int(31)));
                  ir_expression *const r15A3 = rshift(r158C, body.constant(int(1)));
                  body.emit(assign(r1441, bit_or(r15A2, r15A3), 0x01));

                  body.emit(assign(r1440, r159E, 0x01));

                  body.emit(assign(r143F, add(r143F, body.constant(int(1))), 0x01));


               body.instructions = f159C_parent_instructions;
               body.emit(f159C);

               /* END IF */

               ir_variable *const r15A4 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r15A4, r143F, 0x01));

               ir_variable *const r15A5 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r15A5, r1442, 0x01));

               ir_variable *const r15A6 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r15A6, r1441, 0x01));

               ir_variable *const r15A7 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r15A7, r1440, 0x01));

               ir_variable *const r15A8 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r15A8, body.constant(true), 0x01));

               ir_variable *const r15A9 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r15AA = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r15AA);
               ir_expression *const r15AB = expr(ir_unop_u2i, r1440);
               body.emit(assign(r15AA, less(r15AB, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r15AD = lequal(body.constant(int(2045)), r143F);
               ir_if *f15AC = new(mem_ctx) ir_if(operand(r15AD).val);
               exec_list *const f15AC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15AC->then_instructions;

                  ir_variable *const r15AE = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r15B0 = less(body.constant(int(2045)), r143F);
                  ir_if *f15AF = new(mem_ctx) ir_if(operand(r15B0).val);
                  exec_list *const f15AF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15AF->then_instructions;

                     body.emit(assign(r15AE, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15AF->else_instructions;

                     ir_variable *const r15B1 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r15B3 = equal(r143F, body.constant(int(2045)));
                     ir_if *f15B2 = new(mem_ctx) ir_if(operand(r15B3).val);
                     exec_list *const f15B2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15B2->then_instructions;

                        ir_expression *const r15B4 = equal(body.constant(2097151u), r1442);
                        ir_expression *const r15B5 = equal(body.constant(4294967295u), r1441);
                        body.emit(assign(r15B1, logic_and(r15B4, r15B5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f15B2->else_instructions;

                        body.emit(assign(r15B1, body.constant(false), 0x01));


                     body.instructions = f15B2_parent_instructions;
                     body.emit(f15B2);

                     /* END IF */

                     body.emit(assign(r15AE, logic_and(r15B1, r15AA), 0x01));


                  body.instructions = f15AF_parent_instructions;
                  body.emit(f15AF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f15B6 = new(mem_ctx) ir_if(operand(r15AE).val);
                  exec_list *const f15B6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15B6->then_instructions;

                     ir_variable *const r15B7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r15B7);
                     ir_expression *const r15B8 = lshift(r1438, body.constant(int(31)));
                     body.emit(assign(r15B7, add(r15B8, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r15B7, body.constant(0u), 0x01));

                     body.emit(assign(r15A9, r15B7, 0x03));

                     body.emit(assign(r15A8, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15B6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r15BA = less(r143F, body.constant(int(0)));
                     ir_if *f15B9 = new(mem_ctx) ir_if(operand(r15BA).val);
                     exec_list *const f15B9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15B9->then_instructions;

                        ir_variable *const r15BB = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r15BB, r1440, 0x01));

                        ir_variable *const r15BC = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r15BC, neg(r143F), 0x01));

                        ir_variable *const r15BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r15BD);
                        ir_variable *const r15BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r15BE);
                        ir_variable *const r15BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r15BF);
                        ir_variable *const r15C0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r15C1 = neg(r15BC);
                        body.emit(assign(r15C0, bit_and(r15C1, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r15C3 = equal(r15BC, body.constant(int(0)));
                        ir_if *f15C2 = new(mem_ctx) ir_if(operand(r15C3).val);
                        exec_list *const f15C2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f15C2->then_instructions;

                           body.emit(assign(r15BD, r1440, 0x01));

                           body.emit(assign(r15BE, r1441, 0x01));

                           body.emit(assign(r15BF, r1442, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f15C2->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r15C5 = less(r15BC, body.constant(int(32)));
                           ir_if *f15C4 = new(mem_ctx) ir_if(operand(r15C5).val);
                           exec_list *const f15C4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f15C4->then_instructions;

                              body.emit(assign(r15BD, lshift(r1441, r15C0), 0x01));

                              ir_expression *const r15C6 = lshift(r1442, r15C0);
                              ir_expression *const r15C7 = rshift(r1441, r15BC);
                              body.emit(assign(r15BE, bit_or(r15C6, r15C7), 0x01));

                              body.emit(assign(r15BF, rshift(r1442, r15BC), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f15C4->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r15C9 = equal(r15BC, body.constant(int(32)));
                              ir_if *f15C8 = new(mem_ctx) ir_if(operand(r15C9).val);
                              exec_list *const f15C8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f15C8->then_instructions;

                                 body.emit(assign(r15BD, r1441, 0x01));

                                 body.emit(assign(r15BE, r1442, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f15C8->else_instructions;

                                 body.emit(assign(r15BB, bit_or(r1440, r1441), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r15CB = less(r15BC, body.constant(int(64)));
                                 ir_if *f15CA = new(mem_ctx) ir_if(operand(r15CB).val);
                                 exec_list *const f15CA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f15CA->then_instructions;

                                    body.emit(assign(r15BD, lshift(r1442, r15C0), 0x01));

                                    ir_expression *const r15CC = bit_and(r15BC, body.constant(int(31)));
                                    body.emit(assign(r15BE, rshift(r1442, r15CC), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f15CA->else_instructions;

                                    ir_variable *const r15CD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r15CF = equal(r15BC, body.constant(int(64)));
                                    ir_if *f15CE = new(mem_ctx) ir_if(operand(r15CF).val);
                                    exec_list *const f15CE_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f15CE->then_instructions;

                                       body.emit(assign(r15CD, r1442, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f15CE->else_instructions;

                                       ir_expression *const r15D0 = nequal(r1442, body.constant(0u));
                                       ir_expression *const r15D1 = expr(ir_unop_b2i, r15D0);
                                       body.emit(assign(r15CD, expr(ir_unop_i2u, r15D1), 0x01));


                                    body.instructions = f15CE_parent_instructions;
                                    body.emit(f15CE);

                                    /* END IF */

                                    body.emit(assign(r15BD, r15CD, 0x01));

                                    body.emit(assign(r15BE, body.constant(0u), 0x01));


                                 body.instructions = f15CA_parent_instructions;
                                 body.emit(f15CA);

                                 /* END IF */


                              body.instructions = f15C8_parent_instructions;
                              body.emit(f15C8);

                              /* END IF */

                              body.emit(assign(r15BF, body.constant(0u), 0x01));


                           body.instructions = f15C4_parent_instructions;
                           body.emit(f15C4);

                           /* END IF */

                           ir_expression *const r15D2 = nequal(r15BB, body.constant(0u));
                           ir_expression *const r15D3 = expr(ir_unop_b2i, r15D2);
                           ir_expression *const r15D4 = expr(ir_unop_i2u, r15D3);
                           body.emit(assign(r15BD, bit_or(r15BD, r15D4), 0x01));


                        body.instructions = f15C2_parent_instructions;
                        body.emit(f15C2);

                        /* END IF */

                        body.emit(assign(r15A5, r15BF, 0x01));

                        body.emit(assign(r15A6, r15BE, 0x01));

                        body.emit(assign(r15A7, r15BD, 0x01));

                        body.emit(assign(r15A4, body.constant(int(0)), 0x01));

                        body.emit(assign(r15AA, less(r15BD, body.constant(0u)), 0x01));


                     body.instructions = f15B9_parent_instructions;
                     body.emit(f15B9);

                     /* END IF */


                  body.instructions = f15B6_parent_instructions;
                  body.emit(f15B6);

                  /* END IF */


               body.instructions = f15AC_parent_instructions;
               body.emit(f15AC);

               /* END IF */

               /* IF CONDITION */
               ir_if *f15D5 = new(mem_ctx) ir_if(operand(r15A8).val);
               exec_list *const f15D5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15D5->then_instructions;

                  /* IF CONDITION */
                  ir_if *f15D6 = new(mem_ctx) ir_if(operand(r15AA).val);
                  exec_list *const f15D6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15D6->then_instructions;

                     ir_variable *const r15D7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r15D7, add(r15A6, body.constant(1u)), 0x01));

                     ir_expression *const r15D8 = less(r15D7, r15A6);
                     ir_expression *const r15D9 = expr(ir_unop_b2i, r15D8);
                     ir_expression *const r15DA = expr(ir_unop_i2u, r15D9);
                     body.emit(assign(r15A5, add(r15A5, r15DA), 0x01));

                     ir_expression *const r15DB = equal(r15A7, body.constant(0u));
                     ir_expression *const r15DC = expr(ir_unop_b2i, r15DB);
                     ir_expression *const r15DD = expr(ir_unop_i2u, r15DC);
                     ir_expression *const r15DE = add(r15A7, r15DD);
                     ir_expression *const r15DF = bit_and(r15DE, body.constant(1u));
                     ir_expression *const r15E0 = expr(ir_unop_bit_not, r15DF);
                     body.emit(assign(r15A6, bit_and(r15D7, r15E0), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15D6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r15E2 = bit_or(r15A5, r15A6);
                     ir_expression *const r15E3 = equal(r15E2, body.constant(0u));
                     ir_if *f15E1 = new(mem_ctx) ir_if(operand(r15E3).val);
                     exec_list *const f15E1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15E1->then_instructions;

                        body.emit(assign(r15A4, body.constant(int(0)), 0x01));


                     body.instructions = f15E1_parent_instructions;
                     body.emit(f15E1);

                     /* END IF */


                  body.instructions = f15D6_parent_instructions;
                  body.emit(f15D6);

                  /* END IF */

                  ir_variable *const r15E4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r15E4);
                  ir_expression *const r15E5 = lshift(r1438, body.constant(int(31)));
                  ir_expression *const r15E6 = expr(ir_unop_i2u, r15A4);
                  ir_expression *const r15E7 = lshift(r15E6, body.constant(int(20)));
                  ir_expression *const r15E8 = add(r15E5, r15E7);
                  body.emit(assign(r15E4, add(r15E8, r15A5), 0x02));

                  body.emit(assign(r15E4, r15A6, 0x01));

                  body.emit(assign(r15A9, r15E4, 0x03));

                  body.emit(assign(r15A8, body.constant(false), 0x01));


               body.instructions = f15D5_parent_instructions;
               body.emit(f15D5);

               /* END IF */

               body.emit(assign(r1437, r15A9, 0x03));

               body.emit(assign(r1436, body.constant(false), 0x01));


            body.instructions = f1529_parent_instructions;
            body.emit(f1529);

            /* END IF */


         body.instructions = f14E8_parent_instructions;
         body.emit(f14E8);

         /* END IF */


      body.instructions = f147E_parent_instructions;
      body.emit(f147E);

      /* END IF */


   body.instructions = f144F_parent_instructions;
   body.emit(f144F);

   /* END IF */

   body.emit(ret(r1437));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r15E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r15E9);
   ir_variable *const r15EA = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r15EA);
   ir_variable *const r15EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r15EB);
   ir_variable *const r15EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r15EC);
   ir_variable *const r15ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r15ED);
   ir_variable *const r15EE = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r15EE);
   ir_variable *const r15EF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15EF);
   ir_variable *const r15F0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15F0);
   ir_variable *const r15F1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15F1);
   ir_variable *const r15F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r15F2);
   ir_variable *const r15F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r15F3);
   ir_variable *const r15F4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r15F4, add(r15EB, r15EE), 0x01));

   ir_variable *const r15F5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r15F6 = less(r15F4, r15EB);
   ir_expression *const r15F7 = expr(ir_unop_b2i, r15F6);
   body.emit(assign(r15F5, expr(ir_unop_i2u, r15F7), 0x01));

   ir_variable *const r15F8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r15F8, add(r15EA, r15ED), 0x01));

   body.emit(assign(r15F3, add(r15F8, r15F5), 0x01));

   ir_expression *const r15F9 = add(r15E9, r15EC);
   ir_expression *const r15FA = less(r15F3, r15F5);
   ir_expression *const r15FB = expr(ir_unop_b2i, r15FA);
   ir_expression *const r15FC = expr(ir_unop_i2u, r15FB);
   body.emit(assign(r15F2, add(r15F9, r15FC), 0x01));

   ir_expression *const r15FD = less(r15F8, r15EA);
   ir_expression *const r15FE = expr(ir_unop_b2i, r15FD);
   ir_expression *const r15FF = expr(ir_unop_i2u, r15FE);
   body.emit(assign(r15F2, add(r15F2, r15FF), 0x01));

   body.emit(assign(r15F1, r15F4, 0x01));

   body.emit(assign(r15F0, r15F3, 0x01));

   body.emit(assign(r15EF, r15F2, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1600 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1600);
   ir_variable *const r1601 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1601);
   ir_variable *const r1602 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r1602);
   ir_variable *const r1603 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r1603);
   ir_variable *const r1604 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r1604);
   ir_variable *const r1605 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r1605);
   ir_variable *const r1606 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1606);
   ir_variable *const r1607 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1607);
   ir_variable *const r1608 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1608);
   ir_variable *const r1609 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1609);
   ir_variable *const r160A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r160B = less(r1602, r1605);
   ir_expression *const r160C = expr(ir_unop_b2i, r160B);
   body.emit(assign(r160A, expr(ir_unop_i2u, r160C), 0x01));

   ir_variable *const r160D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r160D, sub(r1601, r1604), 0x01));

   ir_expression *const r160E = sub(r1600, r1603);
   ir_expression *const r160F = less(r160D, r160A);
   ir_expression *const r1610 = expr(ir_unop_b2i, r160F);
   ir_expression *const r1611 = expr(ir_unop_i2u, r1610);
   body.emit(assign(r1609, sub(r160E, r1611), 0x01));

   ir_expression *const r1612 = less(r1601, r1604);
   ir_expression *const r1613 = expr(ir_unop_b2i, r1612);
   ir_expression *const r1614 = expr(ir_unop_i2u, r1613);
   body.emit(assign(r1609, sub(r1609, r1614), 0x01));

   body.emit(assign(r1608, sub(r1602, r1605), 0x01));

   body.emit(assign(r1607, sub(r160D, r160A), 0x01));

   body.emit(assign(r1606, r1609, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64Right(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1615 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1615);
   ir_variable *const r1616 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1616);
   ir_variable *const r1617 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r1617);
   ir_variable *const r1618 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1618);
   ir_variable *const r1619 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1619);
   ir_variable *const r161A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r161A);
   ir_variable *const r161B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r161B);
   ir_variable *const r161C = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r161D = neg(r1617);
   body.emit(assign(r161C, bit_and(r161D, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r161F = equal(r1617, body.constant(int(0)));
   ir_if *f161E = new(mem_ctx) ir_if(operand(r161F).val);
   exec_list *const f161E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f161E->then_instructions;

      body.emit(assign(r161A, r1616, 0x01));

      body.emit(assign(r161B, r1615, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f161E->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1621 = less(r1617, body.constant(int(32)));
      ir_if *f1620 = new(mem_ctx) ir_if(operand(r1621).val);
      exec_list *const f1620_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1620->then_instructions;

         ir_expression *const r1622 = lshift(r1615, r161C);
         ir_expression *const r1623 = rshift(r1616, r1617);
         body.emit(assign(r161A, bit_or(r1622, r1623), 0x01));

         body.emit(assign(r161B, rshift(r1615, r1617), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1620->else_instructions;

         ir_variable *const r1624 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1626 = less(r1617, body.constant(int(64)));
         ir_if *f1625 = new(mem_ctx) ir_if(operand(r1626).val);
         exec_list *const f1625_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1625->then_instructions;

            ir_expression *const r1627 = bit_and(r1617, body.constant(int(31)));
            body.emit(assign(r1624, rshift(r1615, r1627), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1625->else_instructions;

            body.emit(assign(r1624, body.constant(0u), 0x01));


         body.instructions = f1625_parent_instructions;
         body.emit(f1625);

         /* END IF */

         body.emit(assign(r161A, r1624, 0x01));

         body.emit(assign(r161B, body.constant(0u), 0x01));


      body.instructions = f1620_parent_instructions;
      body.emit(f1620);

      /* END IF */


   body.instructions = f161E_parent_instructions;
   body.emit(f161E);

   /* END IF */

   body.emit(assign(r1619, r161A, 0x01));

   body.emit(assign(r1618, r161B, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
estimateDiv64To32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1628 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1628);
   ir_variable *const r1629 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1629);
   ir_variable *const r162A = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r162A);
   ir_variable *const r162B = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r162C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r162C);
   ir_variable *const r162D = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r162D);
   ir_variable *const r162E = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r162E);
   ir_variable *const r162F = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
   body.emit(r162F);
   body.emit(assign(r162E, body.constant(0u), 0x01));

   body.emit(assign(r162D, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1631 = lequal(r162A, r1628);
   ir_if *f1630 = new(mem_ctx) ir_if(operand(r1631).val);
   exec_list *const f1630_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1630->then_instructions;

      body.emit(assign(r162B, body.constant(4294967295u), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1630->else_instructions;

      body.emit(assign(r162F, rshift(r162A, body.constant(int(16))), 0x01));

      ir_variable *const r1632 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1634 = lshift(r162F, body.constant(int(16)));
      ir_expression *const r1635 = lequal(r1634, r1628);
      ir_if *f1633 = new(mem_ctx) ir_if(operand(r1635).val);
      exec_list *const f1633_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1633->then_instructions;

         body.emit(assign(r1632, body.constant(4294901760u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1633->else_instructions;

         ir_expression *const r1636 = expr(ir_binop_div, r1628, r162F);
         body.emit(assign(r1632, lshift(r1636, body.constant(int(16))), 0x01));


      body.instructions = f1633_parent_instructions;
      body.emit(f1633);

      /* END IF */

      body.emit(assign(r162C, r1632, 0x01));

      ir_variable *const r1637 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r1637);
      ir_variable *const r1638 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
      body.emit(r1638);
      ir_variable *const r1639 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r1639);
      ir_variable *const r163A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163A, bit_and(r162A, body.constant(65535u)), 0x01));

      ir_variable *const r163B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163B, rshift(r162A, body.constant(int(16))), 0x01));

      ir_variable *const r163C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163C, bit_and(r1632, body.constant(65535u)), 0x01));

      ir_variable *const r163D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163D, rshift(r1632, body.constant(int(16))), 0x01));

      ir_variable *const r163E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163E, mul(r163B, r163C), 0x01));

      ir_expression *const r163F = mul(r163A, r163D);
      body.emit(assign(r1638, add(r163F, r163E), 0x01));

      ir_expression *const r1640 = mul(r163B, r163D);
      ir_expression *const r1641 = less(r1638, r163E);
      ir_expression *const r1642 = expr(ir_unop_b2i, r1641);
      ir_expression *const r1643 = expr(ir_unop_i2u, r1642);
      ir_expression *const r1644 = lshift(r1643, body.constant(int(16)));
      ir_expression *const r1645 = rshift(r1638, body.constant(int(16)));
      ir_expression *const r1646 = add(r1644, r1645);
      body.emit(assign(r1637, add(r1640, r1646), 0x01));

      body.emit(assign(r1638, lshift(r1638, body.constant(int(16))), 0x01));

      ir_expression *const r1647 = mul(r163A, r163C);
      body.emit(assign(r1639, add(r1647, r1638), 0x01));

      ir_expression *const r1648 = less(r1639, r1638);
      ir_expression *const r1649 = expr(ir_unop_b2i, r1648);
      ir_expression *const r164A = expr(ir_unop_i2u, r1649);
      body.emit(assign(r1637, add(r1637, r164A), 0x01));

      ir_expression *const r164B = sub(r1628, r1637);
      ir_expression *const r164C = less(r1629, r1639);
      ir_expression *const r164D = expr(ir_unop_b2i, r164C);
      ir_expression *const r164E = expr(ir_unop_i2u, r164D);
      body.emit(assign(r162E, sub(r164B, r164E), 0x01));

      body.emit(assign(r162D, sub(r1629, r1639), 0x01));

      /* LOOP BEGIN */
      ir_loop *f164F = new(mem_ctx) ir_loop();
      exec_list *const f164F_parent_instructions = body.instructions;

         body.instructions = &f164F->body_instructions;

         /* IF CONDITION */
         ir_expression *const r1651 = expr(ir_unop_u2i, r162E);
         ir_expression *const r1652 = gequal(r1651, body.constant(int(0)));
         ir_if *f1650 = new(mem_ctx) ir_if(operand(r1652).val);
         exec_list *const f1650_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1650->then_instructions;

            body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


         body.instructions = f1650_parent_instructions;
         body.emit(f1650);

         /* END IF */

         body.emit(assign(r162C, add(r162C, body.constant(4294901760u)), 0x01));

         ir_variable *const r1653 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         ir_expression *const r1654 = lshift(r162A, body.constant(int(16)));
         body.emit(assign(r1653, add(r162D, r1654), 0x01));

         ir_expression *const r1655 = add(r162E, r162F);
         ir_expression *const r1656 = less(r1653, r162D);
         ir_expression *const r1657 = expr(ir_unop_b2i, r1656);
         ir_expression *const r1658 = expr(ir_unop_i2u, r1657);
         body.emit(assign(r162E, add(r1655, r1658), 0x01));

         body.emit(assign(r162D, r1653, 0x01));

      /* LOOP END */

      body.instructions = f164F_parent_instructions;
      body.emit(f164F);

      ir_expression *const r1659 = lshift(r162E, body.constant(int(16)));
      ir_expression *const r165A = rshift(r162D, body.constant(int(16)));
      body.emit(assign(r162E, bit_or(r1659, r165A), 0x01));

      ir_variable *const r165B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r165D = lshift(r162F, body.constant(int(16)));
      ir_expression *const r165E = lequal(r165D, r162E);
      ir_if *f165C = new(mem_ctx) ir_if(operand(r165E).val);
      exec_list *const f165C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f165C->then_instructions;

         body.emit(assign(r165B, body.constant(65535u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f165C->else_instructions;

         body.emit(assign(r165B, expr(ir_binop_div, r162E, r162F), 0x01));


      body.instructions = f165C_parent_instructions;
      body.emit(f165C);

      /* END IF */

      body.emit(assign(r162C, bit_or(r162C, r165B), 0x01));

      body.emit(assign(r162B, r162C, 0x01));


   body.instructions = f1630_parent_instructions;
   body.emit(f1630);

   /* END IF */

   body.emit(ret(r162B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul64By32To96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r165F = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r165F);
   ir_variable *const r1660 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1660);
   ir_variable *const r1661 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1661);
   ir_variable *const r1662 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1662);
   ir_variable *const r1663 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1663);
   ir_variable *const r1664 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1664);
   ir_variable *const r1665 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1665);
   ir_variable *const r1666 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r1666);
   ir_variable *const r1667 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1667);
   ir_variable *const r1668 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1668, bit_and(r1660, body.constant(65535u)), 0x01));

   ir_variable *const r1669 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1669, rshift(r1660, body.constant(int(16))), 0x01));

   ir_variable *const r166A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166A, bit_and(r1661, body.constant(65535u)), 0x01));

   ir_variable *const r166B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166B, rshift(r1661, body.constant(int(16))), 0x01));

   ir_variable *const r166C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166C, mul(r1669, r166A), 0x01));

   ir_expression *const r166D = mul(r1668, r166B);
   body.emit(assign(r1666, add(r166D, r166C), 0x01));

   ir_expression *const r166E = mul(r1669, r166B);
   ir_expression *const r166F = less(r1666, r166C);
   ir_expression *const r1670 = expr(ir_unop_b2i, r166F);
   ir_expression *const r1671 = expr(ir_unop_i2u, r1670);
   ir_expression *const r1672 = lshift(r1671, body.constant(int(16)));
   ir_expression *const r1673 = rshift(r1666, body.constant(int(16)));
   ir_expression *const r1674 = add(r1672, r1673);
   body.emit(assign(r1665, add(r166E, r1674), 0x01));

   body.emit(assign(r1666, lshift(r1666, body.constant(int(16))), 0x01));

   ir_expression *const r1675 = mul(r1668, r166A);
   body.emit(assign(r1667, add(r1675, r1666), 0x01));

   ir_expression *const r1676 = less(r1667, r1666);
   ir_expression *const r1677 = expr(ir_unop_b2i, r1676);
   ir_expression *const r1678 = expr(ir_unop_i2u, r1677);
   body.emit(assign(r1665, add(r1665, r1678), 0x01));

   ir_variable *const r1679 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1679);
   ir_variable *const r167A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r167A);
   ir_variable *const r167B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r167B);
   ir_variable *const r167C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r167C, bit_and(r165F, body.constant(65535u)), 0x01));

   ir_variable *const r167D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r167D, rshift(r165F, body.constant(int(16))), 0x01));

   ir_variable *const r167E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r167E, bit_and(r1661, body.constant(65535u)), 0x01));

   ir_variable *const r167F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r167F, rshift(r1661, body.constant(int(16))), 0x01));

   ir_variable *const r1680 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1680, mul(r167D, r167E), 0x01));

   ir_expression *const r1681 = mul(r167C, r167F);
   body.emit(assign(r167A, add(r1681, r1680), 0x01));

   ir_expression *const r1682 = mul(r167D, r167F);
   ir_expression *const r1683 = less(r167A, r1680);
   ir_expression *const r1684 = expr(ir_unop_b2i, r1683);
   ir_expression *const r1685 = expr(ir_unop_i2u, r1684);
   ir_expression *const r1686 = lshift(r1685, body.constant(int(16)));
   ir_expression *const r1687 = rshift(r167A, body.constant(int(16)));
   ir_expression *const r1688 = add(r1686, r1687);
   body.emit(assign(r1679, add(r1682, r1688), 0x01));

   body.emit(assign(r167A, lshift(r167A, body.constant(int(16))), 0x01));

   ir_expression *const r1689 = mul(r167C, r167E);
   body.emit(assign(r167B, add(r1689, r167A), 0x01));

   ir_expression *const r168A = less(r167B, r167A);
   ir_expression *const r168B = expr(ir_unop_b2i, r168A);
   ir_expression *const r168C = expr(ir_unop_i2u, r168B);
   body.emit(assign(r1679, add(r1679, r168C), 0x01));

   ir_variable *const r168D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r168D, add(r167B, r1665), 0x01));

   body.emit(assign(r1664, r1667, 0x01));

   body.emit(assign(r1663, r168D, 0x01));

   ir_expression *const r168E = less(r168D, r167B);
   ir_expression *const r168F = expr(ir_unop_b2i, r168E);
   ir_expression *const r1690 = expr(ir_unop_i2u, r168F);
   body.emit(assign(r1662, add(r1679, r1690), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fdiv64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1691 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1691);
   ir_variable *const r1692 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1692);
   ir_variable *const r1693 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1693, body.constant(true), 0x01));

   ir_variable *const r1694 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1695 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r1695);
   ir_variable *const r1696 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r1696);
   ir_variable *const r1697 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r1697);
   ir_variable *const r1698 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r1698);
   ir_variable *const r1699 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r1699);
   ir_variable *const r169A = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r169A);
   ir_variable *const r169B = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r169B);
   ir_variable *const r169C = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem3", ir_var_auto);
   body.emit(r169C);
   ir_variable *const r169D = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem2", ir_var_auto);
   body.emit(r169D);
   ir_variable *const r169E = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r169E);
   ir_variable *const r169F = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r169F);
   ir_variable *const r16A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r16A0);
   ir_variable *const r16A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r16A1);
   ir_variable *const r16A2 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r16A2);
   body.emit(assign(r16A1, body.constant(0u), 0x01));

   body.emit(assign(r16A0, body.constant(0u), 0x01));

   body.emit(assign(r169F, body.constant(0u), 0x01));

   body.emit(assign(r169E, body.constant(0u), 0x01));

   body.emit(assign(r169D, body.constant(0u), 0x01));

   body.emit(assign(r169C, body.constant(0u), 0x01));

   ir_variable *const r16A3 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r16A3, swizzle_x(r1691), 0x01));

   body.emit(assign(r169B, r16A3, 0x01));

   ir_variable *const r16A4 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r16A4, bit_and(swizzle_y(r1691), body.constant(1048575u)), 0x01));

   body.emit(assign(r169A, r16A4, 0x01));

   ir_variable *const r16A5 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r16A5, swizzle_x(r1692), 0x01));

   body.emit(assign(r1699, r16A5, 0x01));

   ir_variable *const r16A6 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r16A6, bit_and(swizzle_y(r1692), body.constant(1048575u)), 0x01));

   body.emit(assign(r1698, r16A6, 0x01));

   ir_variable *const r16A7 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r16A8 = rshift(swizzle_y(r1691), body.constant(int(20)));
   ir_expression *const r16A9 = bit_and(r16A8, body.constant(2047u));
   body.emit(assign(r16A7, expr(ir_unop_u2i, r16A9), 0x01));

   body.emit(assign(r1697, r16A7, 0x01));

   ir_variable *const r16AA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r16AB = rshift(swizzle_y(r1692), body.constant(int(20)));
   ir_expression *const r16AC = bit_and(r16AB, body.constant(2047u));
   body.emit(assign(r16AA, expr(ir_unop_u2i, r16AC), 0x01));

   body.emit(assign(r1696, r16AA, 0x01));

   ir_expression *const r16AD = rshift(swizzle_y(r1691), body.constant(int(31)));
   ir_expression *const r16AE = rshift(swizzle_y(r1692), body.constant(int(31)));
   body.emit(assign(r1695, bit_xor(r16AD, r16AE), 0x01));

   /* IF CONDITION */
   ir_expression *const r16B0 = equal(r16A7, body.constant(int(2047)));
   ir_if *f16AF = new(mem_ctx) ir_if(operand(r16B0).val);
   exec_list *const f16AF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f16AF->then_instructions;

      /* IF CONDITION */
      ir_expression *const r16B2 = bit_or(r16A4, swizzle_x(r1691));
      ir_expression *const r16B3 = nequal(r16B2, body.constant(0u));
      ir_if *f16B1 = new(mem_ctx) ir_if(operand(r16B3).val);
      exec_list *const f16B1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f16B1->then_instructions;

         ir_variable *const r16B4 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r16B4, swizzle_x(r1691), 0x01));

         ir_variable *const r16B5 = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r16B5, swizzle_x(r1692), 0x01));

         ir_variable *const r16B6 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r16B7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r16B8 = rshift(swizzle_y(r1691), body.constant(int(19)));
         ir_expression *const r16B9 = bit_and(r16B8, body.constant(4095u));
         ir_expression *const r16BA = equal(r16B9, body.constant(4094u));
         ir_expression *const r16BB = nequal(swizzle_x(r1691), body.constant(0u));
         ir_expression *const r16BC = bit_and(swizzle_y(r1691), body.constant(524287u));
         ir_expression *const r16BD = nequal(r16BC, body.constant(0u));
         ir_expression *const r16BE = logic_or(r16BB, r16BD);
         body.emit(assign(r16B7, logic_and(r16BA, r16BE), 0x01));

         ir_variable *const r16BF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r16C0 = lshift(swizzle_y(r1692), body.constant(int(1)));
         ir_expression *const r16C1 = lequal(body.constant(4292870144u), r16C0);
         ir_expression *const r16C2 = nequal(swizzle_x(r1692), body.constant(0u));
         ir_expression *const r16C3 = bit_and(swizzle_y(r1692), body.constant(1048575u));
         ir_expression *const r16C4 = nequal(r16C3, body.constant(0u));
         ir_expression *const r16C5 = logic_or(r16C2, r16C4);
         body.emit(assign(r16BF, logic_and(r16C1, r16C5), 0x01));

         body.emit(assign(r16B4, bit_or(swizzle_y(r1691), body.constant(524288u)), 0x02));

         body.emit(assign(r16B5, bit_or(swizzle_y(r1692), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r16C7 = lshift(swizzle_y(r1691), body.constant(int(1)));
         ir_expression *const r16C8 = lequal(body.constant(4292870144u), r16C7);
         ir_expression *const r16C9 = nequal(swizzle_x(r1691), body.constant(0u));
         ir_expression *const r16CA = bit_and(swizzle_y(r1691), body.constant(1048575u));
         ir_expression *const r16CB = nequal(r16CA, body.constant(0u));
         ir_expression *const r16CC = logic_or(r16C9, r16CB);
         ir_expression *const r16CD = logic_and(r16C8, r16CC);
         ir_if *f16C6 = new(mem_ctx) ir_if(operand(r16CD).val);
         exec_list *const f16C6_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16C6->then_instructions;

            ir_variable *const r16CE = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r16D0 = logic_and(r16B7, r16BF);
            ir_if *f16CF = new(mem_ctx) ir_if(operand(r16D0).val);
            exec_list *const f16CF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f16CF->then_instructions;

               body.emit(assign(r16CE, r16B5, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f16CF->else_instructions;

               body.emit(assign(r16CE, r16B4, 0x03));


            body.instructions = f16CF_parent_instructions;
            body.emit(f16CF);

            /* END IF */

            body.emit(assign(r16B6, r16CE, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16C6->else_instructions;

            body.emit(assign(r16B6, r16B5, 0x03));


         body.instructions = f16C6_parent_instructions;
         body.emit(f16C6);

         /* END IF */

         body.emit(assign(r1694, r16B6, 0x03));

         body.emit(assign(r1693, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f16B1->else_instructions;

         /* IF CONDITION */
         ir_expression *const r16D2 = equal(r16AA, body.constant(int(2047)));
         ir_if *f16D1 = new(mem_ctx) ir_if(operand(r16D2).val);
         exec_list *const f16D1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16D1->then_instructions;

            /* IF CONDITION */
            ir_expression *const r16D4 = bit_or(r16A6, swizzle_x(r1692));
            ir_expression *const r16D5 = nequal(r16D4, body.constant(0u));
            ir_if *f16D3 = new(mem_ctx) ir_if(operand(r16D5).val);
            exec_list *const f16D3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f16D3->then_instructions;

               ir_variable *const r16D6 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r16D6, swizzle_x(r1691), 0x01));

               ir_variable *const r16D7 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r16D7, swizzle_x(r1692), 0x01));

               ir_variable *const r16D8 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r16D9 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r16DA = rshift(swizzle_y(r1691), body.constant(int(19)));
               ir_expression *const r16DB = bit_and(r16DA, body.constant(4095u));
               ir_expression *const r16DC = equal(r16DB, body.constant(4094u));
               ir_expression *const r16DD = nequal(swizzle_x(r1691), body.constant(0u));
               ir_expression *const r16DE = bit_and(swizzle_y(r1691), body.constant(524287u));
               ir_expression *const r16DF = nequal(r16DE, body.constant(0u));
               ir_expression *const r16E0 = logic_or(r16DD, r16DF);
               body.emit(assign(r16D9, logic_and(r16DC, r16E0), 0x01));

               ir_variable *const r16E1 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r16E2 = lshift(swizzle_y(r1692), body.constant(int(1)));
               ir_expression *const r16E3 = lequal(body.constant(4292870144u), r16E2);
               ir_expression *const r16E4 = nequal(swizzle_x(r1692), body.constant(0u));
               ir_expression *const r16E5 = bit_and(swizzle_y(r1692), body.constant(1048575u));
               ir_expression *const r16E6 = nequal(r16E5, body.constant(0u));
               ir_expression *const r16E7 = logic_or(r16E4, r16E6);
               body.emit(assign(r16E1, logic_and(r16E3, r16E7), 0x01));

               body.emit(assign(r16D6, bit_or(swizzle_y(r1691), body.constant(524288u)), 0x02));

               body.emit(assign(r16D7, bit_or(swizzle_y(r1692), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r16E9 = lshift(swizzle_y(r1691), body.constant(int(1)));
               ir_expression *const r16EA = lequal(body.constant(4292870144u), r16E9);
               ir_expression *const r16EB = nequal(swizzle_x(r1691), body.constant(0u));
               ir_expression *const r16EC = bit_and(swizzle_y(r1691), body.constant(1048575u));
               ir_expression *const r16ED = nequal(r16EC, body.constant(0u));
               ir_expression *const r16EE = logic_or(r16EB, r16ED);
               ir_expression *const r16EF = logic_and(r16EA, r16EE);
               ir_if *f16E8 = new(mem_ctx) ir_if(operand(r16EF).val);
               exec_list *const f16E8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f16E8->then_instructions;

                  ir_variable *const r16F0 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r16F2 = logic_and(r16D9, r16E1);
                  ir_if *f16F1 = new(mem_ctx) ir_if(operand(r16F2).val);
                  exec_list *const f16F1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f16F1->then_instructions;

                     body.emit(assign(r16F0, r16D7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f16F1->else_instructions;

                     body.emit(assign(r16F0, r16D6, 0x03));


                  body.instructions = f16F1_parent_instructions;
                  body.emit(f16F1);

                  /* END IF */

                  body.emit(assign(r16D8, r16F0, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f16E8->else_instructions;

                  body.emit(assign(r16D8, r16D7, 0x03));


               body.instructions = f16E8_parent_instructions;
               body.emit(f16E8);

               /* END IF */

               body.emit(assign(r1694, r16D8, 0x03));

               body.emit(assign(r1693, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f16D3->else_instructions;

               ir_constant_data r16F3_data;
               memset(&r16F3_data, 0, sizeof(ir_constant_data));
               r16F3_data.u[0] = 4294967295;
               r16F3_data.u[1] = 4294967295;
               ir_constant *const r16F3 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r16F3_data);
               body.emit(assign(r1694, r16F3, 0x03));

               body.emit(assign(r1693, body.constant(false), 0x01));


            body.instructions = f16D3_parent_instructions;
            body.emit(f16D3);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16D1->else_instructions;

            ir_variable *const r16F4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r16F4);
            ir_expression *const r16F5 = lshift(r1695, body.constant(int(31)));
            body.emit(assign(r16F4, add(r16F5, body.constant(2146435072u)), 0x02));

            body.emit(assign(r16F4, body.constant(0u), 0x01));

            body.emit(assign(r1694, r16F4, 0x03));

            body.emit(assign(r1693, body.constant(false), 0x01));


         body.instructions = f16D1_parent_instructions;
         body.emit(f16D1);

         /* END IF */


      body.instructions = f16B1_parent_instructions;
      body.emit(f16B1);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f16AF->else_instructions;

      /* IF CONDITION */
      ir_expression *const r16F7 = equal(r16AA, body.constant(int(2047)));
      ir_if *f16F6 = new(mem_ctx) ir_if(operand(r16F7).val);
      exec_list *const f16F6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f16F6->then_instructions;

         /* IF CONDITION */
         ir_expression *const r16F9 = bit_or(r16A6, swizzle_x(r1692));
         ir_expression *const r16FA = nequal(r16F9, body.constant(0u));
         ir_if *f16F8 = new(mem_ctx) ir_if(operand(r16FA).val);
         exec_list *const f16F8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16F8->then_instructions;

            ir_variable *const r16FB = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r16FB, swizzle_x(r1691), 0x01));

            ir_variable *const r16FC = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r16FC, swizzle_x(r1692), 0x01));

            ir_variable *const r16FD = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r16FE = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r16FF = rshift(swizzle_y(r1691), body.constant(int(19)));
            ir_expression *const r1700 = bit_and(r16FF, body.constant(4095u));
            ir_expression *const r1701 = equal(r1700, body.constant(4094u));
            ir_expression *const r1702 = nequal(swizzle_x(r1691), body.constant(0u));
            ir_expression *const r1703 = bit_and(swizzle_y(r1691), body.constant(524287u));
            ir_expression *const r1704 = nequal(r1703, body.constant(0u));
            ir_expression *const r1705 = logic_or(r1702, r1704);
            body.emit(assign(r16FE, logic_and(r1701, r1705), 0x01));

            ir_variable *const r1706 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r1707 = lshift(swizzle_y(r1692), body.constant(int(1)));
            ir_expression *const r1708 = lequal(body.constant(4292870144u), r1707);
            ir_expression *const r1709 = nequal(swizzle_x(r1692), body.constant(0u));
            ir_expression *const r170A = bit_and(swizzle_y(r1692), body.constant(1048575u));
            ir_expression *const r170B = nequal(r170A, body.constant(0u));
            ir_expression *const r170C = logic_or(r1709, r170B);
            body.emit(assign(r1706, logic_and(r1708, r170C), 0x01));

            body.emit(assign(r16FB, bit_or(swizzle_y(r1691), body.constant(524288u)), 0x02));

            body.emit(assign(r16FC, bit_or(swizzle_y(r1692), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r170E = lshift(swizzle_y(r1691), body.constant(int(1)));
            ir_expression *const r170F = lequal(body.constant(4292870144u), r170E);
            ir_expression *const r1710 = nequal(swizzle_x(r1691), body.constant(0u));
            ir_expression *const r1711 = bit_and(swizzle_y(r1691), body.constant(1048575u));
            ir_expression *const r1712 = nequal(r1711, body.constant(0u));
            ir_expression *const r1713 = logic_or(r1710, r1712);
            ir_expression *const r1714 = logic_and(r170F, r1713);
            ir_if *f170D = new(mem_ctx) ir_if(operand(r1714).val);
            exec_list *const f170D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f170D->then_instructions;

               ir_variable *const r1715 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1717 = logic_and(r16FE, r1706);
               ir_if *f1716 = new(mem_ctx) ir_if(operand(r1717).val);
               exec_list *const f1716_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1716->then_instructions;

                  body.emit(assign(r1715, r16FC, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1716->else_instructions;

                  body.emit(assign(r1715, r16FB, 0x03));


               body.instructions = f1716_parent_instructions;
               body.emit(f1716);

               /* END IF */

               body.emit(assign(r16FD, r1715, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f170D->else_instructions;

               body.emit(assign(r16FD, r16FC, 0x03));


            body.instructions = f170D_parent_instructions;
            body.emit(f170D);

            /* END IF */

            body.emit(assign(r1694, r16FD, 0x03));

            body.emit(assign(r1693, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16F8->else_instructions;

            ir_variable *const r1718 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r1718);
            body.emit(assign(r1718, lshift(r1695, body.constant(int(31))), 0x02));

            body.emit(assign(r1718, body.constant(0u), 0x01));

            body.emit(assign(r1694, r1718, 0x03));

            body.emit(assign(r1693, body.constant(false), 0x01));


         body.instructions = f16F8_parent_instructions;
         body.emit(f16F8);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f16F6->else_instructions;

         /* IF CONDITION */
         ir_expression *const r171A = equal(r16AA, body.constant(int(0)));
         ir_if *f1719 = new(mem_ctx) ir_if(operand(r171A).val);
         exec_list *const f1719_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1719->then_instructions;

            /* IF CONDITION */
            ir_expression *const r171C = bit_or(r16A6, swizzle_x(r1692));
            ir_expression *const r171D = equal(r171C, body.constant(0u));
            ir_if *f171B = new(mem_ctx) ir_if(operand(r171D).val);
            exec_list *const f171B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f171B->then_instructions;

               /* IF CONDITION */
               ir_expression *const r171F = expr(ir_unop_i2u, r16A7);
               ir_expression *const r1720 = bit_or(r171F, r16A4);
               ir_expression *const r1721 = bit_or(r1720, swizzle_x(r1691));
               ir_expression *const r1722 = equal(r1721, body.constant(0u));
               ir_if *f171E = new(mem_ctx) ir_if(operand(r1722).val);
               exec_list *const f171E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f171E->then_instructions;

                  ir_constant_data r1723_data;
                  memset(&r1723_data, 0, sizeof(ir_constant_data));
                  r1723_data.u[0] = 4294967295;
                  r1723_data.u[1] = 4294967295;
                  ir_constant *const r1723 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r1723_data);
                  body.emit(assign(r1694, r1723, 0x03));

                  body.emit(assign(r1693, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f171E->else_instructions;

                  ir_variable *const r1724 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1724);
                  ir_expression *const r1725 = lshift(r1695, body.constant(int(31)));
                  body.emit(assign(r1724, add(r1725, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1724, body.constant(0u), 0x01));

                  body.emit(assign(r1694, r1724, 0x03));

                  body.emit(assign(r1693, body.constant(false), 0x01));


               body.instructions = f171E_parent_instructions;
               body.emit(f171E);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f171B->else_instructions;

               ir_variable *const r1726 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r1726, r16AA, 0x01));

               ir_variable *const r1727 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r1727, r16A6, 0x01));

               ir_variable *const r1728 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r1728, r16A5, 0x01));

               ir_variable *const r1729 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1729);
               /* IF CONDITION */
               ir_expression *const r172B = equal(r16A6, body.constant(0u));
               ir_if *f172A = new(mem_ctx) ir_if(operand(r172B).val);
               exec_list *const f172A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f172A->then_instructions;

                  ir_variable *const r172C = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r172C, r16A5, 0x01));

                  ir_variable *const r172D = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r172E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r172E);
                  /* IF CONDITION */
                  ir_expression *const r1730 = equal(swizzle_x(r1692), body.constant(0u));
                  ir_if *f172F = new(mem_ctx) ir_if(operand(r1730).val);
                  exec_list *const f172F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f172F->then_instructions;

                     body.emit(assign(r172D, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f172F->else_instructions;

                     body.emit(assign(r172E, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1732 = bit_and(swizzle_x(r1692), body.constant(4294901760u));
                     ir_expression *const r1733 = equal(r1732, body.constant(0u));
                     ir_if *f1731 = new(mem_ctx) ir_if(operand(r1733).val);
                     exec_list *const f1731_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1731->then_instructions;

                        body.emit(assign(r172E, body.constant(int(16)), 0x01));

                        body.emit(assign(r172C, lshift(swizzle_x(r1692), body.constant(int(16))), 0x01));


                     body.instructions = f1731_parent_instructions;
                     body.emit(f1731);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1735 = bit_and(r172C, body.constant(4278190080u));
                     ir_expression *const r1736 = equal(r1735, body.constant(0u));
                     ir_if *f1734 = new(mem_ctx) ir_if(operand(r1736).val);
                     exec_list *const f1734_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1734->then_instructions;

                        body.emit(assign(r172E, add(r172E, body.constant(int(8))), 0x01));

                        body.emit(assign(r172C, lshift(r172C, body.constant(int(8))), 0x01));


                     body.instructions = f1734_parent_instructions;
                     body.emit(f1734);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1738 = bit_and(r172C, body.constant(4026531840u));
                     ir_expression *const r1739 = equal(r1738, body.constant(0u));
                     ir_if *f1737 = new(mem_ctx) ir_if(operand(r1739).val);
                     exec_list *const f1737_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1737->then_instructions;

                        body.emit(assign(r172E, add(r172E, body.constant(int(4))), 0x01));

                        body.emit(assign(r172C, lshift(r172C, body.constant(int(4))), 0x01));


                     body.instructions = f1737_parent_instructions;
                     body.emit(f1737);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r173B = bit_and(r172C, body.constant(3221225472u));
                     ir_expression *const r173C = equal(r173B, body.constant(0u));
                     ir_if *f173A = new(mem_ctx) ir_if(operand(r173C).val);
                     exec_list *const f173A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f173A->then_instructions;

                        body.emit(assign(r172E, add(r172E, body.constant(int(2))), 0x01));

                        body.emit(assign(r172C, lshift(r172C, body.constant(int(2))), 0x01));


                     body.instructions = f173A_parent_instructions;
                     body.emit(f173A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r173E = bit_and(r172C, body.constant(2147483648u));
                     ir_expression *const r173F = equal(r173E, body.constant(0u));
                     ir_if *f173D = new(mem_ctx) ir_if(operand(r173F).val);
                     exec_list *const f173D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f173D->then_instructions;

                        body.emit(assign(r172E, add(r172E, body.constant(int(1))), 0x01));


                     body.instructions = f173D_parent_instructions;
                     body.emit(f173D);

                     /* END IF */

                     body.emit(assign(r172D, r172E, 0x01));


                  body.instructions = f172F_parent_instructions;
                  body.emit(f172F);

                  /* END IF */

                  body.emit(assign(r1729, add(r172D, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1741 = less(r1729, body.constant(int(0)));
                  ir_if *f1740 = new(mem_ctx) ir_if(operand(r1741).val);
                  exec_list *const f1740_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1740->then_instructions;

                     ir_expression *const r1742 = neg(r1729);
                     body.emit(assign(r1727, rshift(swizzle_x(r1692), r1742), 0x01));

                     ir_expression *const r1743 = bit_and(r1729, body.constant(int(31)));
                     body.emit(assign(r1728, lshift(swizzle_x(r1692), r1743), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1740->else_instructions;

                     body.emit(assign(r1727, lshift(swizzle_x(r1692), r1729), 0x01));

                     body.emit(assign(r1728, body.constant(0u), 0x01));


                  body.instructions = f1740_parent_instructions;
                  body.emit(f1740);

                  /* END IF */

                  body.emit(assign(r1726, sub(body.constant(int(-31)), r1729), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f172A->else_instructions;

                  ir_variable *const r1744 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r1744, r16A6, 0x01));

                  ir_variable *const r1745 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r1746 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1746);
                  /* IF CONDITION */
                  ir_expression *const r1748 = equal(r16A6, body.constant(0u));
                  ir_if *f1747 = new(mem_ctx) ir_if(operand(r1748).val);
                  exec_list *const f1747_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1747->then_instructions;

                     body.emit(assign(r1745, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1747->else_instructions;

                     body.emit(assign(r1746, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r174A = bit_and(r16A6, body.constant(4294901760u));
                     ir_expression *const r174B = equal(r174A, body.constant(0u));
                     ir_if *f1749 = new(mem_ctx) ir_if(operand(r174B).val);
                     exec_list *const f1749_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1749->then_instructions;

                        body.emit(assign(r1746, body.constant(int(16)), 0x01));

                        body.emit(assign(r1744, lshift(r16A6, body.constant(int(16))), 0x01));


                     body.instructions = f1749_parent_instructions;
                     body.emit(f1749);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r174D = bit_and(r1744, body.constant(4278190080u));
                     ir_expression *const r174E = equal(r174D, body.constant(0u));
                     ir_if *f174C = new(mem_ctx) ir_if(operand(r174E).val);
                     exec_list *const f174C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f174C->then_instructions;

                        body.emit(assign(r1746, add(r1746, body.constant(int(8))), 0x01));

                        body.emit(assign(r1744, lshift(r1744, body.constant(int(8))), 0x01));


                     body.instructions = f174C_parent_instructions;
                     body.emit(f174C);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1750 = bit_and(r1744, body.constant(4026531840u));
                     ir_expression *const r1751 = equal(r1750, body.constant(0u));
                     ir_if *f174F = new(mem_ctx) ir_if(operand(r1751).val);
                     exec_list *const f174F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f174F->then_instructions;

                        body.emit(assign(r1746, add(r1746, body.constant(int(4))), 0x01));

                        body.emit(assign(r1744, lshift(r1744, body.constant(int(4))), 0x01));


                     body.instructions = f174F_parent_instructions;
                     body.emit(f174F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1753 = bit_and(r1744, body.constant(3221225472u));
                     ir_expression *const r1754 = equal(r1753, body.constant(0u));
                     ir_if *f1752 = new(mem_ctx) ir_if(operand(r1754).val);
                     exec_list *const f1752_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1752->then_instructions;

                        body.emit(assign(r1746, add(r1746, body.constant(int(2))), 0x01));

                        body.emit(assign(r1744, lshift(r1744, body.constant(int(2))), 0x01));


                     body.instructions = f1752_parent_instructions;
                     body.emit(f1752);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1756 = bit_and(r1744, body.constant(2147483648u));
                     ir_expression *const r1757 = equal(r1756, body.constant(0u));
                     ir_if *f1755 = new(mem_ctx) ir_if(operand(r1757).val);
                     exec_list *const f1755_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1755->then_instructions;

                        body.emit(assign(r1746, add(r1746, body.constant(int(1))), 0x01));


                     body.instructions = f1755_parent_instructions;
                     body.emit(f1755);

                     /* END IF */

                     body.emit(assign(r1745, r1746, 0x01));


                  body.instructions = f1747_parent_instructions;
                  body.emit(f1747);

                  /* END IF */

                  body.emit(assign(r1729, add(r1745, body.constant(int(-11))), 0x01));

                  ir_variable *const r1758 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1758, lshift(swizzle_x(r1692), r1729), 0x01));

                  ir_variable *const r1759 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r175B = equal(r1729, body.constant(int(0)));
                  ir_if *f175A = new(mem_ctx) ir_if(operand(r175B).val);
                  exec_list *const f175A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f175A->then_instructions;

                     body.emit(assign(r1759, r16A6, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f175A->else_instructions;

                     ir_expression *const r175C = lshift(r16A6, r1729);
                     ir_expression *const r175D = neg(r1729);
                     ir_expression *const r175E = bit_and(r175D, body.constant(int(31)));
                     ir_expression *const r175F = rshift(swizzle_x(r1692), r175E);
                     body.emit(assign(r1759, bit_or(r175C, r175F), 0x01));


                  body.instructions = f175A_parent_instructions;
                  body.emit(f175A);

                  /* END IF */

                  body.emit(assign(r1727, r1759, 0x01));

                  body.emit(assign(r1728, r1758, 0x01));

                  body.emit(assign(r1726, sub(body.constant(int(1)), r1729), 0x01));


               body.instructions = f172A_parent_instructions;
               body.emit(f172A);

               /* END IF */

               body.emit(assign(r1696, r1726, 0x01));

               body.emit(assign(r1698, r1727, 0x01));

               body.emit(assign(r1699, r1728, 0x01));


            body.instructions = f171B_parent_instructions;
            body.emit(f171B);

            /* END IF */


         body.instructions = f1719_parent_instructions;
         body.emit(f1719);

         /* END IF */

         /* IF CONDITION */
         ir_if *f1760 = new(mem_ctx) ir_if(operand(r1693).val);
         exec_list *const f1760_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1760->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1762 = equal(r16A7, body.constant(int(0)));
            ir_if *f1761 = new(mem_ctx) ir_if(operand(r1762).val);
            exec_list *const f1761_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1761->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1764 = bit_or(r16A4, swizzle_x(r1691));
               ir_expression *const r1765 = equal(r1764, body.constant(0u));
               ir_if *f1763 = new(mem_ctx) ir_if(operand(r1765).val);
               exec_list *const f1763_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1763->then_instructions;

                  ir_variable *const r1766 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1766);
                  body.emit(assign(r1766, lshift(r1695, body.constant(int(31))), 0x02));

                  body.emit(assign(r1766, body.constant(0u), 0x01));

                  body.emit(assign(r1694, r1766, 0x03));

                  body.emit(assign(r1693, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1763->else_instructions;

                  ir_variable *const r1767 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r1767, r16A7, 0x01));

                  ir_variable *const r1768 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r1768, r16A4, 0x01));

                  ir_variable *const r1769 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r1769, r16A3, 0x01));

                  ir_variable *const r176A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r176A);
                  /* IF CONDITION */
                  ir_expression *const r176C = equal(r16A4, body.constant(0u));
                  ir_if *f176B = new(mem_ctx) ir_if(operand(r176C).val);
                  exec_list *const f176B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f176B->then_instructions;

                     ir_variable *const r176D = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r176D, r16A3, 0x01));

                     ir_variable *const r176E = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r176F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r176F);
                     /* IF CONDITION */
                     ir_expression *const r1771 = equal(swizzle_x(r1691), body.constant(0u));
                     ir_if *f1770 = new(mem_ctx) ir_if(operand(r1771).val);
                     exec_list *const f1770_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1770->then_instructions;

                        body.emit(assign(r176E, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1770->else_instructions;

                        body.emit(assign(r176F, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1773 = bit_and(swizzle_x(r1691), body.constant(4294901760u));
                        ir_expression *const r1774 = equal(r1773, body.constant(0u));
                        ir_if *f1772 = new(mem_ctx) ir_if(operand(r1774).val);
                        exec_list *const f1772_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1772->then_instructions;

                           body.emit(assign(r176F, body.constant(int(16)), 0x01));

                           body.emit(assign(r176D, lshift(swizzle_x(r1691), body.constant(int(16))), 0x01));


                        body.instructions = f1772_parent_instructions;
                        body.emit(f1772);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1776 = bit_and(r176D, body.constant(4278190080u));
                        ir_expression *const r1777 = equal(r1776, body.constant(0u));
                        ir_if *f1775 = new(mem_ctx) ir_if(operand(r1777).val);
                        exec_list *const f1775_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1775->then_instructions;

                           body.emit(assign(r176F, add(r176F, body.constant(int(8))), 0x01));

                           body.emit(assign(r176D, lshift(r176D, body.constant(int(8))), 0x01));


                        body.instructions = f1775_parent_instructions;
                        body.emit(f1775);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1779 = bit_and(r176D, body.constant(4026531840u));
                        ir_expression *const r177A = equal(r1779, body.constant(0u));
                        ir_if *f1778 = new(mem_ctx) ir_if(operand(r177A).val);
                        exec_list *const f1778_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1778->then_instructions;

                           body.emit(assign(r176F, add(r176F, body.constant(int(4))), 0x01));

                           body.emit(assign(r176D, lshift(r176D, body.constant(int(4))), 0x01));


                        body.instructions = f1778_parent_instructions;
                        body.emit(f1778);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r177C = bit_and(r176D, body.constant(3221225472u));
                        ir_expression *const r177D = equal(r177C, body.constant(0u));
                        ir_if *f177B = new(mem_ctx) ir_if(operand(r177D).val);
                        exec_list *const f177B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f177B->then_instructions;

                           body.emit(assign(r176F, add(r176F, body.constant(int(2))), 0x01));

                           body.emit(assign(r176D, lshift(r176D, body.constant(int(2))), 0x01));


                        body.instructions = f177B_parent_instructions;
                        body.emit(f177B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r177F = bit_and(r176D, body.constant(2147483648u));
                        ir_expression *const r1780 = equal(r177F, body.constant(0u));
                        ir_if *f177E = new(mem_ctx) ir_if(operand(r1780).val);
                        exec_list *const f177E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f177E->then_instructions;

                           body.emit(assign(r176F, add(r176F, body.constant(int(1))), 0x01));


                        body.instructions = f177E_parent_instructions;
                        body.emit(f177E);

                        /* END IF */

                        body.emit(assign(r176E, r176F, 0x01));


                     body.instructions = f1770_parent_instructions;
                     body.emit(f1770);

                     /* END IF */

                     body.emit(assign(r176A, add(r176E, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1782 = less(r176A, body.constant(int(0)));
                     ir_if *f1781 = new(mem_ctx) ir_if(operand(r1782).val);
                     exec_list *const f1781_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1781->then_instructions;

                        ir_expression *const r1783 = neg(r176A);
                        body.emit(assign(r1768, rshift(swizzle_x(r1691), r1783), 0x01));

                        ir_expression *const r1784 = bit_and(r176A, body.constant(int(31)));
                        body.emit(assign(r1769, lshift(swizzle_x(r1691), r1784), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1781->else_instructions;

                        body.emit(assign(r1768, lshift(swizzle_x(r1691), r176A), 0x01));

                        body.emit(assign(r1769, body.constant(0u), 0x01));


                     body.instructions = f1781_parent_instructions;
                     body.emit(f1781);

                     /* END IF */

                     body.emit(assign(r1767, sub(body.constant(int(-31)), r176A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f176B->else_instructions;

                     ir_variable *const r1785 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1785, r16A4, 0x01));

                     ir_variable *const r1786 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1787 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1787);
                     /* IF CONDITION */
                     ir_expression *const r1789 = equal(r16A4, body.constant(0u));
                     ir_if *f1788 = new(mem_ctx) ir_if(operand(r1789).val);
                     exec_list *const f1788_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1788->then_instructions;

                        body.emit(assign(r1786, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1788->else_instructions;

                        body.emit(assign(r1787, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r178B = bit_and(r16A4, body.constant(4294901760u));
                        ir_expression *const r178C = equal(r178B, body.constant(0u));
                        ir_if *f178A = new(mem_ctx) ir_if(operand(r178C).val);
                        exec_list *const f178A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f178A->then_instructions;

                           body.emit(assign(r1787, body.constant(int(16)), 0x01));

                           body.emit(assign(r1785, lshift(r16A4, body.constant(int(16))), 0x01));


                        body.instructions = f178A_parent_instructions;
                        body.emit(f178A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r178E = bit_and(r1785, body.constant(4278190080u));
                        ir_expression *const r178F = equal(r178E, body.constant(0u));
                        ir_if *f178D = new(mem_ctx) ir_if(operand(r178F).val);
                        exec_list *const f178D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f178D->then_instructions;

                           body.emit(assign(r1787, add(r1787, body.constant(int(8))), 0x01));

                           body.emit(assign(r1785, lshift(r1785, body.constant(int(8))), 0x01));


                        body.instructions = f178D_parent_instructions;
                        body.emit(f178D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1791 = bit_and(r1785, body.constant(4026531840u));
                        ir_expression *const r1792 = equal(r1791, body.constant(0u));
                        ir_if *f1790 = new(mem_ctx) ir_if(operand(r1792).val);
                        exec_list *const f1790_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1790->then_instructions;

                           body.emit(assign(r1787, add(r1787, body.constant(int(4))), 0x01));

                           body.emit(assign(r1785, lshift(r1785, body.constant(int(4))), 0x01));


                        body.instructions = f1790_parent_instructions;
                        body.emit(f1790);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1794 = bit_and(r1785, body.constant(3221225472u));
                        ir_expression *const r1795 = equal(r1794, body.constant(0u));
                        ir_if *f1793 = new(mem_ctx) ir_if(operand(r1795).val);
                        exec_list *const f1793_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1793->then_instructions;

                           body.emit(assign(r1787, add(r1787, body.constant(int(2))), 0x01));

                           body.emit(assign(r1785, lshift(r1785, body.constant(int(2))), 0x01));


                        body.instructions = f1793_parent_instructions;
                        body.emit(f1793);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1797 = bit_and(r1785, body.constant(2147483648u));
                        ir_expression *const r1798 = equal(r1797, body.constant(0u));
                        ir_if *f1796 = new(mem_ctx) ir_if(operand(r1798).val);
                        exec_list *const f1796_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1796->then_instructions;

                           body.emit(assign(r1787, add(r1787, body.constant(int(1))), 0x01));


                        body.instructions = f1796_parent_instructions;
                        body.emit(f1796);

                        /* END IF */

                        body.emit(assign(r1786, r1787, 0x01));


                     body.instructions = f1788_parent_instructions;
                     body.emit(f1788);

                     /* END IF */

                     body.emit(assign(r176A, add(r1786, body.constant(int(-11))), 0x01));

                     ir_variable *const r1799 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r1799, lshift(swizzle_x(r1691), r176A), 0x01));

                     ir_variable *const r179A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r179C = equal(r176A, body.constant(int(0)));
                     ir_if *f179B = new(mem_ctx) ir_if(operand(r179C).val);
                     exec_list *const f179B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f179B->then_instructions;

                        body.emit(assign(r179A, r16A4, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f179B->else_instructions;

                        ir_expression *const r179D = lshift(r16A4, r176A);
                        ir_expression *const r179E = neg(r176A);
                        ir_expression *const r179F = bit_and(r179E, body.constant(int(31)));
                        ir_expression *const r17A0 = rshift(swizzle_x(r1691), r179F);
                        body.emit(assign(r179A, bit_or(r179D, r17A0), 0x01));


                     body.instructions = f179B_parent_instructions;
                     body.emit(f179B);

                     /* END IF */

                     body.emit(assign(r1768, r179A, 0x01));

                     body.emit(assign(r1769, r1799, 0x01));

                     body.emit(assign(r1767, sub(body.constant(int(1)), r176A), 0x01));


                  body.instructions = f176B_parent_instructions;
                  body.emit(f176B);

                  /* END IF */

                  body.emit(assign(r1697, r1767, 0x01));

                  body.emit(assign(r169A, r1768, 0x01));

                  body.emit(assign(r169B, r1769, 0x01));


               body.instructions = f1763_parent_instructions;
               body.emit(f1763);

               /* END IF */


            body.instructions = f1761_parent_instructions;
            body.emit(f1761);

            /* END IF */

            /* IF CONDITION */
            ir_if *f17A1 = new(mem_ctx) ir_if(operand(r1693).val);
            exec_list *const f17A1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f17A1->then_instructions;

               ir_expression *const r17A2 = sub(r1697, r1696);
               body.emit(assign(r16A2, add(r17A2, body.constant(int(1021))), 0x01));

               ir_variable *const r17A3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r17A3, lshift(r169B, body.constant(int(11))), 0x01));

               ir_variable *const r17A4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r17A5 = bit_or(r169A, body.constant(1048576u));
               ir_expression *const r17A6 = lshift(r17A5, body.constant(int(11)));
               ir_expression *const r17A7 = rshift(r169B, body.constant(int(21)));
               body.emit(assign(r17A4, bit_or(r17A6, r17A7), 0x01));

               body.emit(assign(r169A, r17A4, 0x01));

               body.emit(assign(r169B, r17A3, 0x01));

               ir_variable *const r17A8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r17A8, lshift(r1699, body.constant(int(11))), 0x01));

               ir_variable *const r17A9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r17AA = bit_or(r1698, body.constant(1048576u));
               ir_expression *const r17AB = lshift(r17AA, body.constant(int(11)));
               ir_expression *const r17AC = rshift(r1699, body.constant(int(21)));
               body.emit(assign(r17A9, bit_or(r17AB, r17AC), 0x01));

               body.emit(assign(r1698, r17A9, 0x01));

               body.emit(assign(r1699, r17A8, 0x01));

               /* IF CONDITION */
               ir_expression *const r17AE = less(r17A9, r17A4);
               ir_expression *const r17AF = equal(r17A9, r17A4);
               ir_expression *const r17B0 = lequal(r17A8, r17A3);
               ir_expression *const r17B1 = logic_and(r17AF, r17B0);
               ir_expression *const r17B2 = logic_or(r17AE, r17B1);
               ir_if *f17AD = new(mem_ctx) ir_if(operand(r17B2).val);
               exec_list *const f17AD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f17AD->then_instructions;

                  body.emit(assign(r169A, rshift(r17A4, body.constant(int(1))), 0x01));

                  ir_expression *const r17B3 = lshift(r17A4, body.constant(int(31)));
                  ir_expression *const r17B4 = rshift(r17A3, body.constant(int(1)));
                  body.emit(assign(r169B, bit_or(r17B3, r17B4), 0x01));

                  body.emit(assign(r16A2, add(r16A2, body.constant(int(1))), 0x01));


               body.instructions = f17AD_parent_instructions;
               body.emit(f17AD);

               /* END IF */

               ir_variable *const r17B5 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r17B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r17B6);
               ir_variable *const r17B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r17B7);
               ir_variable *const r17B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r17B8);
               ir_variable *const r17B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r17B9);
               body.emit(assign(r17B8, body.constant(0u), 0x01));

               body.emit(assign(r17B7, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r17BB = lequal(r17A9, r169A);
               ir_if *f17BA = new(mem_ctx) ir_if(operand(r17BB).val);
               exec_list *const f17BA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f17BA->then_instructions;

                  body.emit(assign(r17B5, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f17BA->else_instructions;

                  body.emit(assign(r17B9, rshift(r17A9, body.constant(int(16))), 0x01));

                  ir_variable *const r17BC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r17BE = lshift(r17B9, body.constant(int(16)));
                  ir_expression *const r17BF = lequal(r17BE, r169A);
                  ir_if *f17BD = new(mem_ctx) ir_if(operand(r17BF).val);
                  exec_list *const f17BD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f17BD->then_instructions;

                     body.emit(assign(r17BC, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f17BD->else_instructions;

                     ir_expression *const r17C0 = expr(ir_binop_div, r169A, r17B9);
                     body.emit(assign(r17BC, lshift(r17C0, body.constant(int(16))), 0x01));


                  body.instructions = f17BD_parent_instructions;
                  body.emit(f17BD);

                  /* END IF */

                  body.emit(assign(r17B6, r17BC, 0x01));

                  ir_variable *const r17C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r17C1);
                  ir_variable *const r17C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r17C2);
                  ir_variable *const r17C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r17C3);
                  ir_variable *const r17C4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C4, bit_and(r17A9, body.constant(65535u)), 0x01));

                  ir_variable *const r17C5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C5, rshift(r17A9, body.constant(int(16))), 0x01));

                  ir_variable *const r17C6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C6, bit_and(r17BC, body.constant(65535u)), 0x01));

                  ir_variable *const r17C7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C7, rshift(r17BC, body.constant(int(16))), 0x01));

                  ir_variable *const r17C8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C8, mul(r17C5, r17C6), 0x01));

                  ir_expression *const r17C9 = mul(r17C4, r17C7);
                  body.emit(assign(r17C2, add(r17C9, r17C8), 0x01));

                  ir_expression *const r17CA = mul(r17C5, r17C7);
                  ir_expression *const r17CB = less(r17C2, r17C8);
                  ir_expression *const r17CC = expr(ir_unop_b2i, r17CB);
                  ir_expression *const r17CD = expr(ir_unop_i2u, r17CC);
                  ir_expression *const r17CE = lshift(r17CD, body.constant(int(16)));
                  ir_expression *const r17CF = rshift(r17C2, body.constant(int(16)));
                  ir_expression *const r17D0 = add(r17CE, r17CF);
                  body.emit(assign(r17C1, add(r17CA, r17D0), 0x01));

                  body.emit(assign(r17C2, lshift(r17C2, body.constant(int(16))), 0x01));

                  ir_expression *const r17D1 = mul(r17C4, r17C6);
                  body.emit(assign(r17C3, add(r17D1, r17C2), 0x01));

                  ir_expression *const r17D2 = less(r17C3, r17C2);
                  ir_expression *const r17D3 = expr(ir_unop_b2i, r17D2);
                  ir_expression *const r17D4 = expr(ir_unop_i2u, r17D3);
                  body.emit(assign(r17C1, add(r17C1, r17D4), 0x01));

                  ir_expression *const r17D5 = sub(r169A, r17C1);
                  ir_expression *const r17D6 = less(r169B, r17C3);
                  ir_expression *const r17D7 = expr(ir_unop_b2i, r17D6);
                  ir_expression *const r17D8 = expr(ir_unop_i2u, r17D7);
                  body.emit(assign(r17B8, sub(r17D5, r17D8), 0x01));

                  body.emit(assign(r17B7, sub(r169B, r17C3), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f17D9 = new(mem_ctx) ir_loop();
                  exec_list *const f17D9_parent_instructions = body.instructions;

                     body.instructions = &f17D9->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r17DB = expr(ir_unop_u2i, r17B8);
                     ir_expression *const r17DC = gequal(r17DB, body.constant(int(0)));
                     ir_if *f17DA = new(mem_ctx) ir_if(operand(r17DC).val);
                     exec_list *const f17DA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f17DA->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f17DA_parent_instructions;
                     body.emit(f17DA);

                     /* END IF */

                     body.emit(assign(r17B6, add(r17B6, body.constant(4294901760u)), 0x01));

                     ir_variable *const r17DD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r17DE = lshift(r17A9, body.constant(int(16)));
                     body.emit(assign(r17DD, add(r17B7, r17DE), 0x01));

                     ir_expression *const r17DF = add(r17B8, r17B9);
                     ir_expression *const r17E0 = less(r17DD, r17B7);
                     ir_expression *const r17E1 = expr(ir_unop_b2i, r17E0);
                     ir_expression *const r17E2 = expr(ir_unop_i2u, r17E1);
                     body.emit(assign(r17B8, add(r17DF, r17E2), 0x01));

                     body.emit(assign(r17B7, r17DD, 0x01));

                  /* LOOP END */

                  body.instructions = f17D9_parent_instructions;
                  body.emit(f17D9);

                  ir_expression *const r17E3 = lshift(r17B8, body.constant(int(16)));
                  ir_expression *const r17E4 = rshift(r17B7, body.constant(int(16)));
                  body.emit(assign(r17B8, bit_or(r17E3, r17E4), 0x01));

                  ir_variable *const r17E5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r17E7 = lshift(r17B9, body.constant(int(16)));
                  ir_expression *const r17E8 = lequal(r17E7, r17B8);
                  ir_if *f17E6 = new(mem_ctx) ir_if(operand(r17E8).val);
                  exec_list *const f17E6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f17E6->then_instructions;

                     body.emit(assign(r17E5, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f17E6->else_instructions;

                     body.emit(assign(r17E5, expr(ir_binop_div, r17B8, r17B9), 0x01));


                  body.instructions = f17E6_parent_instructions;
                  body.emit(f17E6);

                  /* END IF */

                  body.emit(assign(r17B6, bit_or(r17B6, r17E5), 0x01));

                  body.emit(assign(r17B5, r17B6, 0x01));


               body.instructions = f17BA_parent_instructions;
               body.emit(f17BA);

               /* END IF */

               body.emit(assign(r16A1, r17B5, 0x01));

               ir_variable *const r17E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r17E9);
               ir_variable *const r17EA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r17EA);
               ir_variable *const r17EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r17EB);
               ir_variable *const r17EC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17EC, bit_and(r17A8, body.constant(65535u)), 0x01));

               ir_variable *const r17ED = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17ED, rshift(r17A8, body.constant(int(16))), 0x01));

               ir_variable *const r17EE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17EE, bit_and(r17B5, body.constant(65535u)), 0x01));

               ir_variable *const r17EF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17EF, rshift(r17B5, body.constant(int(16))), 0x01));

               ir_variable *const r17F0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F0, mul(r17ED, r17EE), 0x01));

               ir_expression *const r17F1 = mul(r17EC, r17EF);
               body.emit(assign(r17EA, add(r17F1, r17F0), 0x01));

               ir_expression *const r17F2 = mul(r17ED, r17EF);
               ir_expression *const r17F3 = less(r17EA, r17F0);
               ir_expression *const r17F4 = expr(ir_unop_b2i, r17F3);
               ir_expression *const r17F5 = expr(ir_unop_i2u, r17F4);
               ir_expression *const r17F6 = lshift(r17F5, body.constant(int(16)));
               ir_expression *const r17F7 = rshift(r17EA, body.constant(int(16)));
               ir_expression *const r17F8 = add(r17F6, r17F7);
               body.emit(assign(r17E9, add(r17F2, r17F8), 0x01));

               body.emit(assign(r17EA, lshift(r17EA, body.constant(int(16))), 0x01));

               ir_expression *const r17F9 = mul(r17EC, r17EE);
               body.emit(assign(r17EB, add(r17F9, r17EA), 0x01));

               ir_expression *const r17FA = less(r17EB, r17EA);
               ir_expression *const r17FB = expr(ir_unop_b2i, r17FA);
               ir_expression *const r17FC = expr(ir_unop_i2u, r17FB);
               body.emit(assign(r17E9, add(r17E9, r17FC), 0x01));

               ir_variable *const r17FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r17FD);
               ir_variable *const r17FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r17FE);
               ir_variable *const r17FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r17FF);
               ir_variable *const r1800 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1800, bit_and(r17A9, body.constant(65535u)), 0x01));

               ir_variable *const r1801 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1801, rshift(r17A9, body.constant(int(16))), 0x01));

               ir_variable *const r1802 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1802, bit_and(r17B5, body.constant(65535u)), 0x01));

               ir_variable *const r1803 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1803, rshift(r17B5, body.constant(int(16))), 0x01));

               ir_variable *const r1804 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1804, mul(r1801, r1802), 0x01));

               ir_expression *const r1805 = mul(r1800, r1803);
               body.emit(assign(r17FE, add(r1805, r1804), 0x01));

               ir_expression *const r1806 = mul(r1801, r1803);
               ir_expression *const r1807 = less(r17FE, r1804);
               ir_expression *const r1808 = expr(ir_unop_b2i, r1807);
               ir_expression *const r1809 = expr(ir_unop_i2u, r1808);
               ir_expression *const r180A = lshift(r1809, body.constant(int(16)));
               ir_expression *const r180B = rshift(r17FE, body.constant(int(16)));
               ir_expression *const r180C = add(r180A, r180B);
               body.emit(assign(r17FD, add(r1806, r180C), 0x01));

               body.emit(assign(r17FE, lshift(r17FE, body.constant(int(16))), 0x01));

               ir_expression *const r180D = mul(r1800, r1802);
               body.emit(assign(r17FF, add(r180D, r17FE), 0x01));

               ir_expression *const r180E = less(r17FF, r17FE);
               ir_expression *const r180F = expr(ir_unop_b2i, r180E);
               ir_expression *const r1810 = expr(ir_unop_i2u, r180F);
               body.emit(assign(r17FD, add(r17FD, r1810), 0x01));

               ir_variable *const r1811 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1811, add(r17FF, r17E9), 0x01));

               ir_variable *const r1812 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1812);
               ir_variable *const r1813 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r1814 = less(body.constant(0u), r17EB);
               ir_expression *const r1815 = expr(ir_unop_b2i, r1814);
               body.emit(assign(r1813, expr(ir_unop_i2u, r1815), 0x01));

               ir_variable *const r1816 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1816, sub(r169B, r1811), 0x01));

               ir_expression *const r1817 = less(r1811, r17FF);
               ir_expression *const r1818 = expr(ir_unop_b2i, r1817);
               ir_expression *const r1819 = expr(ir_unop_i2u, r1818);
               ir_expression *const r181A = add(r17FD, r1819);
               ir_expression *const r181B = sub(r169A, r181A);
               ir_expression *const r181C = less(r1816, r1813);
               ir_expression *const r181D = expr(ir_unop_b2i, r181C);
               ir_expression *const r181E = expr(ir_unop_i2u, r181D);
               body.emit(assign(r1812, sub(r181B, r181E), 0x01));

               ir_expression *const r181F = less(r169B, r1811);
               ir_expression *const r1820 = expr(ir_unop_b2i, r181F);
               ir_expression *const r1821 = expr(ir_unop_i2u, r1820);
               body.emit(assign(r1812, sub(r1812, r1821), 0x01));

               body.emit(assign(r169F, r1812, 0x01));

               body.emit(assign(r169E, sub(r1816, r1813), 0x01));

               body.emit(assign(r169D, neg(r17EB), 0x01));

               /* LOOP BEGIN */
               ir_loop *f1822 = new(mem_ctx) ir_loop();
               exec_list *const f1822_parent_instructions = body.instructions;

                  body.instructions = &f1822->body_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1824 = expr(ir_unop_u2i, r169F);
                  ir_expression *const r1825 = gequal(r1824, body.constant(int(0)));
                  ir_if *f1823 = new(mem_ctx) ir_if(operand(r1825).val);
                  exec_list *const f1823_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1823->then_instructions;

                     body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                  body.instructions = f1823_parent_instructions;
                  body.emit(f1823);

                  /* END IF */

                  body.emit(assign(r16A1, add(r16A1, body.constant(4294967295u)), 0x01));

                  ir_variable *const r1826 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1826);
                  ir_variable *const r1827 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1827);
                  ir_variable *const r1828 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1828, add(r169D, r17A8), 0x01));

                  ir_variable *const r1829 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r182A = less(r1828, r169D);
                  ir_expression *const r182B = expr(ir_unop_b2i, r182A);
                  body.emit(assign(r1829, expr(ir_unop_i2u, r182B), 0x01));

                  ir_variable *const r182C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r182C, add(r169E, r17A9), 0x01));

                  body.emit(assign(r1827, add(r182C, r1829), 0x01));

                  ir_expression *const r182D = less(r1827, r1829);
                  ir_expression *const r182E = expr(ir_unop_b2i, r182D);
                  ir_expression *const r182F = expr(ir_unop_i2u, r182E);
                  body.emit(assign(r1826, add(r169F, r182F), 0x01));

                  ir_expression *const r1830 = less(r182C, r169E);
                  ir_expression *const r1831 = expr(ir_unop_b2i, r1830);
                  ir_expression *const r1832 = expr(ir_unop_i2u, r1831);
                  body.emit(assign(r1826, add(r1826, r1832), 0x01));

                  body.emit(assign(r169F, r1826, 0x01));

                  body.emit(assign(r169E, r1827, 0x01));

                  body.emit(assign(r169D, r1828, 0x01));

               /* LOOP END */

               body.instructions = f1822_parent_instructions;
               body.emit(f1822);

               ir_variable *const r1833 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r1834 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r1834);
               ir_variable *const r1835 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r1835);
               ir_variable *const r1836 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r1836);
               ir_variable *const r1837 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r1837);
               body.emit(assign(r1836, body.constant(0u), 0x01));

               body.emit(assign(r1835, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r1839 = lequal(r17A9, r169E);
               ir_if *f1838 = new(mem_ctx) ir_if(operand(r1839).val);
               exec_list *const f1838_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1838->then_instructions;

                  body.emit(assign(r1833, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1838->else_instructions;

                  body.emit(assign(r1837, rshift(r17A9, body.constant(int(16))), 0x01));

                  ir_variable *const r183A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r183C = lshift(r1837, body.constant(int(16)));
                  ir_expression *const r183D = lequal(r183C, r169E);
                  ir_if *f183B = new(mem_ctx) ir_if(operand(r183D).val);
                  exec_list *const f183B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f183B->then_instructions;

                     body.emit(assign(r183A, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f183B->else_instructions;

                     ir_expression *const r183E = expr(ir_binop_div, r169E, r1837);
                     body.emit(assign(r183A, lshift(r183E, body.constant(int(16))), 0x01));


                  body.instructions = f183B_parent_instructions;
                  body.emit(f183B);

                  /* END IF */

                  body.emit(assign(r1834, r183A, 0x01));

                  ir_variable *const r183F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r183F);
                  ir_variable *const r1840 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r1840);
                  ir_variable *const r1841 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1841);
                  ir_variable *const r1842 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1842, bit_and(r17A9, body.constant(65535u)), 0x01));

                  ir_variable *const r1843 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1843, rshift(r17A9, body.constant(int(16))), 0x01));

                  ir_variable *const r1844 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1844, bit_and(r183A, body.constant(65535u)), 0x01));

                  ir_variable *const r1845 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1845, rshift(r183A, body.constant(int(16))), 0x01));

                  ir_variable *const r1846 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1846, mul(r1843, r1844), 0x01));

                  ir_expression *const r1847 = mul(r1842, r1845);
                  body.emit(assign(r1840, add(r1847, r1846), 0x01));

                  ir_expression *const r1848 = mul(r1843, r1845);
                  ir_expression *const r1849 = less(r1840, r1846);
                  ir_expression *const r184A = expr(ir_unop_b2i, r1849);
                  ir_expression *const r184B = expr(ir_unop_i2u, r184A);
                  ir_expression *const r184C = lshift(r184B, body.constant(int(16)));
                  ir_expression *const r184D = rshift(r1840, body.constant(int(16)));
                  ir_expression *const r184E = add(r184C, r184D);
                  body.emit(assign(r183F, add(r1848, r184E), 0x01));

                  body.emit(assign(r1840, lshift(r1840, body.constant(int(16))), 0x01));

                  ir_expression *const r184F = mul(r1842, r1844);
                  body.emit(assign(r1841, add(r184F, r1840), 0x01));

                  ir_expression *const r1850 = less(r1841, r1840);
                  ir_expression *const r1851 = expr(ir_unop_b2i, r1850);
                  ir_expression *const r1852 = expr(ir_unop_i2u, r1851);
                  body.emit(assign(r183F, add(r183F, r1852), 0x01));

                  ir_expression *const r1853 = sub(r169E, r183F);
                  ir_expression *const r1854 = less(r169D, r1841);
                  ir_expression *const r1855 = expr(ir_unop_b2i, r1854);
                  ir_expression *const r1856 = expr(ir_unop_i2u, r1855);
                  body.emit(assign(r1836, sub(r1853, r1856), 0x01));

                  body.emit(assign(r1835, sub(r169D, r1841), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f1857 = new(mem_ctx) ir_loop();
                  exec_list *const f1857_parent_instructions = body.instructions;

                     body.instructions = &f1857->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1859 = expr(ir_unop_u2i, r1836);
                     ir_expression *const r185A = gequal(r1859, body.constant(int(0)));
                     ir_if *f1858 = new(mem_ctx) ir_if(operand(r185A).val);
                     exec_list *const f1858_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1858->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f1858_parent_instructions;
                     body.emit(f1858);

                     /* END IF */

                     body.emit(assign(r1834, add(r1834, body.constant(4294901760u)), 0x01));

                     ir_variable *const r185B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r185C = lshift(r17A9, body.constant(int(16)));
                     body.emit(assign(r185B, add(r1835, r185C), 0x01));

                     ir_expression *const r185D = add(r1836, r1837);
                     ir_expression *const r185E = less(r185B, r1835);
                     ir_expression *const r185F = expr(ir_unop_b2i, r185E);
                     ir_expression *const r1860 = expr(ir_unop_i2u, r185F);
                     body.emit(assign(r1836, add(r185D, r1860), 0x01));

                     body.emit(assign(r1835, r185B, 0x01));

                  /* LOOP END */

                  body.instructions = f1857_parent_instructions;
                  body.emit(f1857);

                  ir_expression *const r1861 = lshift(r1836, body.constant(int(16)));
                  ir_expression *const r1862 = rshift(r1835, body.constant(int(16)));
                  body.emit(assign(r1836, bit_or(r1861, r1862), 0x01));

                  ir_variable *const r1863 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1865 = lshift(r1837, body.constant(int(16)));
                  ir_expression *const r1866 = lequal(r1865, r1836);
                  ir_if *f1864 = new(mem_ctx) ir_if(operand(r1866).val);
                  exec_list *const f1864_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1864->then_instructions;

                     body.emit(assign(r1863, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1864->else_instructions;

                     body.emit(assign(r1863, expr(ir_binop_div, r1836, r1837), 0x01));


                  body.instructions = f1864_parent_instructions;
                  body.emit(f1864);

                  /* END IF */

                  body.emit(assign(r1834, bit_or(r1834, r1863), 0x01));

                  body.emit(assign(r1833, r1834, 0x01));


               body.instructions = f1838_parent_instructions;
               body.emit(f1838);

               /* END IF */

               body.emit(assign(r16A0, r1833, 0x01));

               /* IF CONDITION */
               ir_expression *const r1868 = bit_and(r1833, body.constant(1023u));
               ir_expression *const r1869 = lequal(r1868, body.constant(4u));
               ir_if *f1867 = new(mem_ctx) ir_if(operand(r1869).val);
               exec_list *const f1867_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1867->then_instructions;

                  ir_variable *const r186A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r186A);
                  ir_variable *const r186B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r186B);
                  ir_variable *const r186C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r186C);
                  ir_variable *const r186D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r186D, bit_and(r17A8, body.constant(65535u)), 0x01));

                  ir_variable *const r186E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r186E, rshift(r17A8, body.constant(int(16))), 0x01));

                  ir_variable *const r186F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r186F, bit_and(r1833, body.constant(65535u)), 0x01));

                  ir_variable *const r1870 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1870, rshift(r1833, body.constant(int(16))), 0x01));

                  ir_variable *const r1871 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1871, mul(r186E, r186F), 0x01));

                  ir_expression *const r1872 = mul(r186D, r1870);
                  body.emit(assign(r186B, add(r1872, r1871), 0x01));

                  ir_expression *const r1873 = mul(r186E, r1870);
                  ir_expression *const r1874 = less(r186B, r1871);
                  ir_expression *const r1875 = expr(ir_unop_b2i, r1874);
                  ir_expression *const r1876 = expr(ir_unop_i2u, r1875);
                  ir_expression *const r1877 = lshift(r1876, body.constant(int(16)));
                  ir_expression *const r1878 = rshift(r186B, body.constant(int(16)));
                  ir_expression *const r1879 = add(r1877, r1878);
                  body.emit(assign(r186A, add(r1873, r1879), 0x01));

                  body.emit(assign(r186B, lshift(r186B, body.constant(int(16))), 0x01));

                  ir_expression *const r187A = mul(r186D, r186F);
                  body.emit(assign(r186C, add(r187A, r186B), 0x01));

                  ir_expression *const r187B = less(r186C, r186B);
                  ir_expression *const r187C = expr(ir_unop_b2i, r187B);
                  ir_expression *const r187D = expr(ir_unop_i2u, r187C);
                  body.emit(assign(r186A, add(r186A, r187D), 0x01));

                  ir_variable *const r187E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r187E);
                  ir_variable *const r187F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r187F);
                  ir_variable *const r1880 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1880);
                  ir_variable *const r1881 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1881, bit_and(r17A9, body.constant(65535u)), 0x01));

                  ir_variable *const r1882 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1882, rshift(r17A9, body.constant(int(16))), 0x01));

                  ir_variable *const r1883 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1883, bit_and(r1833, body.constant(65535u)), 0x01));

                  ir_variable *const r1884 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1884, rshift(r1833, body.constant(int(16))), 0x01));

                  ir_variable *const r1885 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1885, mul(r1882, r1883), 0x01));

                  ir_expression *const r1886 = mul(r1881, r1884);
                  body.emit(assign(r187F, add(r1886, r1885), 0x01));

                  ir_expression *const r1887 = mul(r1882, r1884);
                  ir_expression *const r1888 = less(r187F, r1885);
                  ir_expression *const r1889 = expr(ir_unop_b2i, r1888);
                  ir_expression *const r188A = expr(ir_unop_i2u, r1889);
                  ir_expression *const r188B = lshift(r188A, body.constant(int(16)));
                  ir_expression *const r188C = rshift(r187F, body.constant(int(16)));
                  ir_expression *const r188D = add(r188B, r188C);
                  body.emit(assign(r187E, add(r1887, r188D), 0x01));

                  body.emit(assign(r187F, lshift(r187F, body.constant(int(16))), 0x01));

                  ir_expression *const r188E = mul(r1881, r1883);
                  body.emit(assign(r1880, add(r188E, r187F), 0x01));

                  ir_expression *const r188F = less(r1880, r187F);
                  ir_expression *const r1890 = expr(ir_unop_b2i, r188F);
                  ir_expression *const r1891 = expr(ir_unop_i2u, r1890);
                  body.emit(assign(r187E, add(r187E, r1891), 0x01));

                  ir_variable *const r1892 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1892, add(r1880, r186A), 0x01));

                  ir_variable *const r1893 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1893);
                  ir_variable *const r1894 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r1895 = less(body.constant(0u), r186C);
                  ir_expression *const r1896 = expr(ir_unop_b2i, r1895);
                  body.emit(assign(r1894, expr(ir_unop_i2u, r1896), 0x01));

                  ir_variable *const r1897 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1897, sub(r169D, r1892), 0x01));

                  ir_expression *const r1898 = less(r1892, r1880);
                  ir_expression *const r1899 = expr(ir_unop_b2i, r1898);
                  ir_expression *const r189A = expr(ir_unop_i2u, r1899);
                  ir_expression *const r189B = add(r187E, r189A);
                  ir_expression *const r189C = sub(r169E, r189B);
                  ir_expression *const r189D = less(r1897, r1894);
                  ir_expression *const r189E = expr(ir_unop_b2i, r189D);
                  ir_expression *const r189F = expr(ir_unop_i2u, r189E);
                  body.emit(assign(r1893, sub(r189C, r189F), 0x01));

                  ir_expression *const r18A0 = less(r169D, r1892);
                  ir_expression *const r18A1 = expr(ir_unop_b2i, r18A0);
                  ir_expression *const r18A2 = expr(ir_unop_i2u, r18A1);
                  body.emit(assign(r1893, sub(r1893, r18A2), 0x01));

                  body.emit(assign(r169E, r1893, 0x01));

                  body.emit(assign(r169D, sub(r1897, r1894), 0x01));

                  body.emit(assign(r169C, neg(r186C), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f18A3 = new(mem_ctx) ir_loop();
                  exec_list *const f18A3_parent_instructions = body.instructions;

                     body.instructions = &f18A3->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r18A5 = expr(ir_unop_u2i, r169E);
                     ir_expression *const r18A6 = gequal(r18A5, body.constant(int(0)));
                     ir_if *f18A4 = new(mem_ctx) ir_if(operand(r18A6).val);
                     exec_list *const f18A4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18A4->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f18A4_parent_instructions;
                     body.emit(f18A4);

                     /* END IF */

                     body.emit(assign(r16A0, add(r16A0, body.constant(4294967295u)), 0x01));

                     ir_variable *const r18A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r18A7);
                     ir_variable *const r18A8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r18A8);
                     ir_variable *const r18A9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18A9, add(r169C, r17A8), 0x01));

                     ir_variable *const r18AA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r18AB = less(r18A9, r169C);
                     ir_expression *const r18AC = expr(ir_unop_b2i, r18AB);
                     body.emit(assign(r18AA, expr(ir_unop_i2u, r18AC), 0x01));

                     ir_variable *const r18AD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18AD, add(r169D, r17A9), 0x01));

                     body.emit(assign(r18A8, add(r18AD, r18AA), 0x01));

                     ir_expression *const r18AE = less(r18A8, r18AA);
                     ir_expression *const r18AF = expr(ir_unop_b2i, r18AE);
                     ir_expression *const r18B0 = expr(ir_unop_i2u, r18AF);
                     body.emit(assign(r18A7, add(r169E, r18B0), 0x01));

                     ir_expression *const r18B1 = less(r18AD, r169D);
                     ir_expression *const r18B2 = expr(ir_unop_b2i, r18B1);
                     ir_expression *const r18B3 = expr(ir_unop_i2u, r18B2);
                     body.emit(assign(r18A7, add(r18A7, r18B3), 0x01));

                     body.emit(assign(r169E, r18A7, 0x01));

                     body.emit(assign(r169D, r18A8, 0x01));

                     body.emit(assign(r169C, r18A9, 0x01));

                  /* LOOP END */

                  body.instructions = f18A3_parent_instructions;
                  body.emit(f18A3);

                  ir_expression *const r18B4 = bit_or(r169E, r169D);
                  ir_expression *const r18B5 = bit_or(r18B4, r169C);
                  ir_expression *const r18B6 = nequal(r18B5, body.constant(0u));
                  ir_expression *const r18B7 = expr(ir_unop_b2i, r18B6);
                  ir_expression *const r18B8 = expr(ir_unop_i2u, r18B7);
                  body.emit(assign(r16A0, bit_or(r16A0, r18B8), 0x01));


               body.instructions = f1867_parent_instructions;
               body.emit(f1867);

               /* END IF */

               ir_variable *const r18B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r18B9);
               ir_variable *const r18BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r18BA);
               ir_variable *const r18BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r18BB);
               body.emit(assign(r18B9, lshift(r16A0, body.constant(int(21))), 0x01));

               ir_expression *const r18BC = lshift(r16A1, body.constant(int(21)));
               ir_expression *const r18BD = rshift(r16A0, body.constant(int(11)));
               body.emit(assign(r18BA, bit_or(r18BC, r18BD), 0x01));

               body.emit(assign(r18BB, rshift(r16A1, body.constant(int(11))), 0x01));

               body.emit(assign(r18B9, bit_or(r18B9, body.constant(0u)), 0x01));

               body.emit(assign(r16A1, r18BB, 0x01));

               body.emit(assign(r16A0, r18BA, 0x01));

               ir_variable *const r18BE = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r18BE, r16A2, 0x01));

               ir_variable *const r18BF = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r18BF, r18BB, 0x01));

               ir_variable *const r18C0 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r18C0, r18BA, 0x01));

               ir_variable *const r18C1 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r18C1, r18B9, 0x01));

               ir_variable *const r18C2 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r18C2, body.constant(true), 0x01));

               ir_variable *const r18C3 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r18C4 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r18C4);
               ir_expression *const r18C5 = expr(ir_unop_u2i, r18B9);
               body.emit(assign(r18C4, less(r18C5, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r18C7 = lequal(body.constant(int(2045)), r16A2);
               ir_if *f18C6 = new(mem_ctx) ir_if(operand(r18C7).val);
               exec_list *const f18C6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f18C6->then_instructions;

                  ir_variable *const r18C8 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r18CA = less(body.constant(int(2045)), r16A2);
                  ir_if *f18C9 = new(mem_ctx) ir_if(operand(r18CA).val);
                  exec_list *const f18C9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18C9->then_instructions;

                     body.emit(assign(r18C8, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18C9->else_instructions;

                     ir_variable *const r18CB = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r18CD = equal(r16A2, body.constant(int(2045)));
                     ir_if *f18CC = new(mem_ctx) ir_if(operand(r18CD).val);
                     exec_list *const f18CC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18CC->then_instructions;

                        ir_expression *const r18CE = equal(body.constant(2097151u), r18BB);
                        ir_expression *const r18CF = equal(body.constant(4294967295u), r18BA);
                        body.emit(assign(r18CB, logic_and(r18CE, r18CF), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f18CC->else_instructions;

                        body.emit(assign(r18CB, body.constant(false), 0x01));


                     body.instructions = f18CC_parent_instructions;
                     body.emit(f18CC);

                     /* END IF */

                     body.emit(assign(r18C8, logic_and(r18CB, r18C4), 0x01));


                  body.instructions = f18C9_parent_instructions;
                  body.emit(f18C9);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f18D0 = new(mem_ctx) ir_if(operand(r18C8).val);
                  exec_list *const f18D0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18D0->then_instructions;

                     ir_variable *const r18D1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r18D1);
                     ir_expression *const r18D2 = lshift(r1695, body.constant(int(31)));
                     body.emit(assign(r18D1, add(r18D2, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r18D1, body.constant(0u), 0x01));

                     body.emit(assign(r18C3, r18D1, 0x03));

                     body.emit(assign(r18C2, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18D0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r18D4 = less(r16A2, body.constant(int(0)));
                     ir_if *f18D3 = new(mem_ctx) ir_if(operand(r18D4).val);
                     exec_list *const f18D3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18D3->then_instructions;

                        ir_variable *const r18D5 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r18D5, r18B9, 0x01));

                        ir_variable *const r18D6 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r18D6, neg(r16A2), 0x01));

                        ir_variable *const r18D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r18D7);
                        ir_variable *const r18D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r18D8);
                        ir_variable *const r18D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r18D9);
                        ir_variable *const r18DA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r18DB = neg(r18D6);
                        body.emit(assign(r18DA, bit_and(r18DB, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r18DD = equal(r18D6, body.constant(int(0)));
                        ir_if *f18DC = new(mem_ctx) ir_if(operand(r18DD).val);
                        exec_list *const f18DC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f18DC->then_instructions;

                           body.emit(assign(r18D7, r18B9, 0x01));

                           body.emit(assign(r18D8, r18BA, 0x01));

                           body.emit(assign(r18D9, r18BB, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f18DC->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r18DF = less(r18D6, body.constant(int(32)));
                           ir_if *f18DE = new(mem_ctx) ir_if(operand(r18DF).val);
                           exec_list *const f18DE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f18DE->then_instructions;

                              body.emit(assign(r18D7, lshift(r18BA, r18DA), 0x01));

                              ir_expression *const r18E0 = lshift(r18BB, r18DA);
                              ir_expression *const r18E1 = rshift(r18BA, r18D6);
                              body.emit(assign(r18D8, bit_or(r18E0, r18E1), 0x01));

                              body.emit(assign(r18D9, rshift(r18BB, r18D6), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f18DE->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r18E3 = equal(r18D6, body.constant(int(32)));
                              ir_if *f18E2 = new(mem_ctx) ir_if(operand(r18E3).val);
                              exec_list *const f18E2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f18E2->then_instructions;

                                 body.emit(assign(r18D7, r18BA, 0x01));

                                 body.emit(assign(r18D8, r18BB, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f18E2->else_instructions;

                                 body.emit(assign(r18D5, bit_or(r18B9, r18BA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r18E5 = less(r18D6, body.constant(int(64)));
                                 ir_if *f18E4 = new(mem_ctx) ir_if(operand(r18E5).val);
                                 exec_list *const f18E4_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f18E4->then_instructions;

                                    body.emit(assign(r18D7, lshift(r18BB, r18DA), 0x01));

                                    ir_expression *const r18E6 = bit_and(r18D6, body.constant(int(31)));
                                    body.emit(assign(r18D8, rshift(r18BB, r18E6), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f18E4->else_instructions;

                                    ir_variable *const r18E7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r18E9 = equal(r18D6, body.constant(int(64)));
                                    ir_if *f18E8 = new(mem_ctx) ir_if(operand(r18E9).val);
                                    exec_list *const f18E8_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f18E8->then_instructions;

                                       body.emit(assign(r18E7, r18BB, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f18E8->else_instructions;

                                       ir_expression *const r18EA = nequal(r18BB, body.constant(0u));
                                       ir_expression *const r18EB = expr(ir_unop_b2i, r18EA);
                                       body.emit(assign(r18E7, expr(ir_unop_i2u, r18EB), 0x01));


                                    body.instructions = f18E8_parent_instructions;
                                    body.emit(f18E8);

                                    /* END IF */

                                    body.emit(assign(r18D7, r18E7, 0x01));

                                    body.emit(assign(r18D8, body.constant(0u), 0x01));


                                 body.instructions = f18E4_parent_instructions;
                                 body.emit(f18E4);

                                 /* END IF */


                              body.instructions = f18E2_parent_instructions;
                              body.emit(f18E2);

                              /* END IF */

                              body.emit(assign(r18D9, body.constant(0u), 0x01));


                           body.instructions = f18DE_parent_instructions;
                           body.emit(f18DE);

                           /* END IF */

                           ir_expression *const r18EC = nequal(r18D5, body.constant(0u));
                           ir_expression *const r18ED = expr(ir_unop_b2i, r18EC);
                           ir_expression *const r18EE = expr(ir_unop_i2u, r18ED);
                           body.emit(assign(r18D7, bit_or(r18D7, r18EE), 0x01));


                        body.instructions = f18DC_parent_instructions;
                        body.emit(f18DC);

                        /* END IF */

                        body.emit(assign(r18BF, r18D9, 0x01));

                        body.emit(assign(r18C0, r18D8, 0x01));

                        body.emit(assign(r18C1, r18D7, 0x01));

                        body.emit(assign(r18BE, body.constant(int(0)), 0x01));

                        body.emit(assign(r18C4, less(r18D7, body.constant(0u)), 0x01));


                     body.instructions = f18D3_parent_instructions;
                     body.emit(f18D3);

                     /* END IF */


                  body.instructions = f18D0_parent_instructions;
                  body.emit(f18D0);

                  /* END IF */


               body.instructions = f18C6_parent_instructions;
               body.emit(f18C6);

               /* END IF */

               /* IF CONDITION */
               ir_if *f18EF = new(mem_ctx) ir_if(operand(r18C2).val);
               exec_list *const f18EF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f18EF->then_instructions;

                  /* IF CONDITION */
                  ir_if *f18F0 = new(mem_ctx) ir_if(operand(r18C4).val);
                  exec_list *const f18F0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18F0->then_instructions;

                     ir_variable *const r18F1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18F1, add(r18C0, body.constant(1u)), 0x01));

                     ir_expression *const r18F2 = less(r18F1, r18C0);
                     ir_expression *const r18F3 = expr(ir_unop_b2i, r18F2);
                     ir_expression *const r18F4 = expr(ir_unop_i2u, r18F3);
                     body.emit(assign(r18BF, add(r18BF, r18F4), 0x01));

                     ir_expression *const r18F5 = equal(r18C1, body.constant(0u));
                     ir_expression *const r18F6 = expr(ir_unop_b2i, r18F5);
                     ir_expression *const r18F7 = expr(ir_unop_i2u, r18F6);
                     ir_expression *const r18F8 = add(r18C1, r18F7);
                     ir_expression *const r18F9 = bit_and(r18F8, body.constant(1u));
                     ir_expression *const r18FA = expr(ir_unop_bit_not, r18F9);
                     body.emit(assign(r18C0, bit_and(r18F1, r18FA), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18F0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r18FC = bit_or(r18BF, r18C0);
                     ir_expression *const r18FD = equal(r18FC, body.constant(0u));
                     ir_if *f18FB = new(mem_ctx) ir_if(operand(r18FD).val);
                     exec_list *const f18FB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18FB->then_instructions;

                        body.emit(assign(r18BE, body.constant(int(0)), 0x01));


                     body.instructions = f18FB_parent_instructions;
                     body.emit(f18FB);

                     /* END IF */


                  body.instructions = f18F0_parent_instructions;
                  body.emit(f18F0);

                  /* END IF */

                  ir_variable *const r18FE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r18FE);
                  ir_expression *const r18FF = lshift(r1695, body.constant(int(31)));
                  ir_expression *const r1900 = expr(ir_unop_i2u, r18BE);
                  ir_expression *const r1901 = lshift(r1900, body.constant(int(20)));
                  ir_expression *const r1902 = add(r18FF, r1901);
                  body.emit(assign(r18FE, add(r1902, r18BF), 0x02));

                  body.emit(assign(r18FE, r18C0, 0x01));

                  body.emit(assign(r18C3, r18FE, 0x03));

                  body.emit(assign(r18C2, body.constant(false), 0x01));


               body.instructions = f18EF_parent_instructions;
               body.emit(f18EF);

               /* END IF */

               body.emit(assign(r1694, r18C3, 0x03));

               body.emit(assign(r1693, body.constant(false), 0x01));


            body.instructions = f17A1_parent_instructions;
            body.emit(f17A1);

            /* END IF */


         body.instructions = f1760_parent_instructions;
         body.emit(f1760);

         /* END IF */


      body.instructions = f16F6_parent_instructions;
      body.emit(f16F6);

      /* END IF */


   body.instructions = f16AF_parent_instructions;
   body.emit(f16AF);

   /* END IF */

   body.emit(ret(r1694));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat32Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1903 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_function_in);
   sig_parameters.push_tail(r1903);
   ir_variable *const r1904 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r1904);
   ir_variable *const r1905 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFracPtr", ir_var_function_inout);
   sig_parameters.push_tail(r1905);
   ir_variable *const r1906 = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r1906, r1903, 0x01));

   ir_variable *const r1907 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r1908 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r1908);
   /* IF CONDITION */
   ir_expression *const r190A = equal(r1903, body.constant(0u));
   ir_if *f1909 = new(mem_ctx) ir_if(operand(r190A).val);
   exec_list *const f1909_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1909->then_instructions;

      body.emit(assign(r1907, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1909->else_instructions;

      body.emit(assign(r1908, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r190C = bit_and(r1903, body.constant(4294901760u));
      ir_expression *const r190D = equal(r190C, body.constant(0u));
      ir_if *f190B = new(mem_ctx) ir_if(operand(r190D).val);
      exec_list *const f190B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f190B->then_instructions;

         body.emit(assign(r1908, body.constant(int(16)), 0x01));

         body.emit(assign(r1906, lshift(r1903, body.constant(int(16))), 0x01));


      body.instructions = f190B_parent_instructions;
      body.emit(f190B);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r190F = bit_and(r1906, body.constant(4278190080u));
      ir_expression *const r1910 = equal(r190F, body.constant(0u));
      ir_if *f190E = new(mem_ctx) ir_if(operand(r1910).val);
      exec_list *const f190E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f190E->then_instructions;

         body.emit(assign(r1908, add(r1908, body.constant(int(8))), 0x01));

         body.emit(assign(r1906, lshift(r1906, body.constant(int(8))), 0x01));


      body.instructions = f190E_parent_instructions;
      body.emit(f190E);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1912 = bit_and(r1906, body.constant(4026531840u));
      ir_expression *const r1913 = equal(r1912, body.constant(0u));
      ir_if *f1911 = new(mem_ctx) ir_if(operand(r1913).val);
      exec_list *const f1911_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1911->then_instructions;

         body.emit(assign(r1908, add(r1908, body.constant(int(4))), 0x01));

         body.emit(assign(r1906, lshift(r1906, body.constant(int(4))), 0x01));


      body.instructions = f1911_parent_instructions;
      body.emit(f1911);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1915 = bit_and(r1906, body.constant(3221225472u));
      ir_expression *const r1916 = equal(r1915, body.constant(0u));
      ir_if *f1914 = new(mem_ctx) ir_if(operand(r1916).val);
      exec_list *const f1914_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1914->then_instructions;

         body.emit(assign(r1908, add(r1908, body.constant(int(2))), 0x01));

         body.emit(assign(r1906, lshift(r1906, body.constant(int(2))), 0x01));


      body.instructions = f1914_parent_instructions;
      body.emit(f1914);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1918 = bit_and(r1906, body.constant(2147483648u));
      ir_expression *const r1919 = equal(r1918, body.constant(0u));
      ir_if *f1917 = new(mem_ctx) ir_if(operand(r1919).val);
      exec_list *const f1917_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1917->then_instructions;

         body.emit(assign(r1908, add(r1908, body.constant(int(1))), 0x01));


      body.instructions = f1917_parent_instructions;
      body.emit(f1917);

      /* END IF */

      body.emit(assign(r1907, r1908, 0x01));


   body.instructions = f1909_parent_instructions;
   body.emit(f1909);

   /* END IF */

   ir_variable *const r191A = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r191A, add(r1907, body.constant(int(-8))), 0x01));

   body.emit(assign(r1905, lshift(r1903, r191A), 0x01));

   body.emit(assign(r1904, sub(body.constant(int(1)), r191A), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Frac(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r191B = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r191B);
   ir_expression *const r191C = bit_and(r191B, body.constant(8388607u));
   body.emit(ret(r191C));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r191D = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r191D);
   ir_expression *const r191E = rshift(r191D, body.constant(int(23)));
   ir_expression *const r191F = bit_and(r191E, body.constant(255u));
   ir_expression *const r1920 = expr(ir_unop_u2i, r191F);
   body.emit(ret(r1920));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1921 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1921);
   ir_expression *const r1922 = rshift(r1921, body.constant(int(31)));
   body.emit(ret(r1922));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp32_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1923 = new(mem_ctx) ir_variable(glsl_type::float_type, "f", ir_var_function_in);
   sig_parameters.push_tail(r1923);
   ir_variable *const r1924 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1924, body.constant(true), 0x01));

   ir_variable *const r1925 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1926 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r1926);
   ir_variable *const r1927 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_auto);
   body.emit(r1927);
   ir_variable *const r1928 = body.make_temp(glsl_type::uint_type, "floatBitsToUint_retval");
   body.emit(assign(r1928, expr(ir_unop_bitcast_f2u, r1923), 0x01));

   ir_variable *const r1929 = body.make_temp(glsl_type::uint_type, "extractFloat32Frac_retval");
   body.emit(assign(r1929, bit_and(r1928, body.constant(8388607u)), 0x01));

   body.emit(assign(r1927, r1929, 0x01));

   ir_variable *const r192A = body.make_temp(glsl_type::int_type, "extractFloat32Exp_retval");
   ir_expression *const r192B = rshift(r1928, body.constant(int(23)));
   ir_expression *const r192C = bit_and(r192B, body.constant(255u));
   body.emit(assign(r192A, expr(ir_unop_u2i, r192C), 0x01));

   body.emit(assign(r1926, r192A, 0x01));

   ir_variable *const r192D = body.make_temp(glsl_type::uint_type, "extractFloat32Sign_retval");
   body.emit(assign(r192D, rshift(r1928, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r192F = equal(r192A, body.constant(int(255)));
   ir_if *f192E = new(mem_ctx) ir_if(operand(r192F).val);
   exec_list *const f192E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f192E->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1931 = nequal(r1929, body.constant(0u));
      ir_if *f1930 = new(mem_ctx) ir_if(operand(r1931).val);
      exec_list *const f1930_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1930->then_instructions;

         ir_variable *const r1932 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1932, lshift(r1928, body.constant(int(9))), 0x01));

         ir_variable *const r1933 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         ir_expression *const r1934 = lshift(r1932, body.constant(int(20)));
         body.emit(assign(r1933, bit_or(r1934, body.constant(0u)), 0x01));

         ir_expression *const r1935 = rshift(r1932, body.constant(int(12)));
         ir_expression *const r1936 = lshift(r192D, body.constant(int(31)));
         ir_expression *const r1937 = bit_or(r1936, body.constant(2146959360u));
         body.emit(assign(r1933, bit_or(r1935, r1937), 0x02));

         body.emit(assign(r1925, r1933, 0x03));

         body.emit(assign(r1924, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1930->else_instructions;

         ir_variable *const r1938 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1938);
         ir_expression *const r1939 = lshift(r192D, body.constant(int(31)));
         body.emit(assign(r1938, add(r1939, body.constant(2146435072u)), 0x02));

         body.emit(assign(r1938, body.constant(0u), 0x01));

         body.emit(assign(r1925, r1938, 0x03));

         body.emit(assign(r1924, body.constant(false), 0x01));


      body.instructions = f1930_parent_instructions;
      body.emit(f1930);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f192E->else_instructions;

      /* IF CONDITION */
      ir_expression *const r193B = equal(r192A, body.constant(int(0)));
      ir_if *f193A = new(mem_ctx) ir_if(operand(r193B).val);
      exec_list *const f193A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f193A->then_instructions;

         /* IF CONDITION */
         ir_expression *const r193D = equal(r1929, body.constant(0u));
         ir_if *f193C = new(mem_ctx) ir_if(operand(r193D).val);
         exec_list *const f193C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f193C->then_instructions;

            ir_variable *const r193E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r193E);
            body.emit(assign(r193E, lshift(r192D, body.constant(int(31))), 0x02));

            body.emit(assign(r193E, body.constant(0u), 0x01));

            body.emit(assign(r1925, r193E, 0x03));

            body.emit(assign(r1924, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f193C->else_instructions;

            ir_variable *const r193F = body.make_temp(glsl_type::int_type, "zExpPtr");
            body.emit(assign(r193F, r192A, 0x01));

            ir_variable *const r1940 = body.make_temp(glsl_type::uint_type, "zFracPtr");
            body.emit(assign(r1940, r1929, 0x01));

            ir_variable *const r1941 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r1941, r1929, 0x01));

            ir_variable *const r1942 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r1943 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r1943);
            /* IF CONDITION */
            ir_expression *const r1945 = equal(r1929, body.constant(0u));
            ir_if *f1944 = new(mem_ctx) ir_if(operand(r1945).val);
            exec_list *const f1944_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1944->then_instructions;

               body.emit(assign(r1942, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1944->else_instructions;

               body.emit(assign(r1943, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r1947 = bit_and(r1929, body.constant(4294901760u));
               ir_expression *const r1948 = equal(r1947, body.constant(0u));
               ir_if *f1946 = new(mem_ctx) ir_if(operand(r1948).val);
               exec_list *const f1946_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1946->then_instructions;

                  body.emit(assign(r1943, body.constant(int(16)), 0x01));

                  body.emit(assign(r1941, lshift(r1929, body.constant(int(16))), 0x01));


               body.instructions = f1946_parent_instructions;
               body.emit(f1946);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r194A = bit_and(r1941, body.constant(4278190080u));
               ir_expression *const r194B = equal(r194A, body.constant(0u));
               ir_if *f1949 = new(mem_ctx) ir_if(operand(r194B).val);
               exec_list *const f1949_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1949->then_instructions;

                  body.emit(assign(r1943, add(r1943, body.constant(int(8))), 0x01));

                  body.emit(assign(r1941, lshift(r1941, body.constant(int(8))), 0x01));


               body.instructions = f1949_parent_instructions;
               body.emit(f1949);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r194D = bit_and(r1941, body.constant(4026531840u));
               ir_expression *const r194E = equal(r194D, body.constant(0u));
               ir_if *f194C = new(mem_ctx) ir_if(operand(r194E).val);
               exec_list *const f194C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f194C->then_instructions;

                  body.emit(assign(r1943, add(r1943, body.constant(int(4))), 0x01));

                  body.emit(assign(r1941, lshift(r1941, body.constant(int(4))), 0x01));


               body.instructions = f194C_parent_instructions;
               body.emit(f194C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1950 = bit_and(r1941, body.constant(3221225472u));
               ir_expression *const r1951 = equal(r1950, body.constant(0u));
               ir_if *f194F = new(mem_ctx) ir_if(operand(r1951).val);
               exec_list *const f194F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f194F->then_instructions;

                  body.emit(assign(r1943, add(r1943, body.constant(int(2))), 0x01));

                  body.emit(assign(r1941, lshift(r1941, body.constant(int(2))), 0x01));


               body.instructions = f194F_parent_instructions;
               body.emit(f194F);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1953 = bit_and(r1941, body.constant(2147483648u));
               ir_expression *const r1954 = equal(r1953, body.constant(0u));
               ir_if *f1952 = new(mem_ctx) ir_if(operand(r1954).val);
               exec_list *const f1952_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1952->then_instructions;

                  body.emit(assign(r1943, add(r1943, body.constant(int(1))), 0x01));


               body.instructions = f1952_parent_instructions;
               body.emit(f1952);

               /* END IF */

               body.emit(assign(r1942, r1943, 0x01));


            body.instructions = f1944_parent_instructions;
            body.emit(f1944);

            /* END IF */

            ir_variable *const r1955 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            body.emit(assign(r1955, add(r1942, body.constant(int(-8))), 0x01));

            body.emit(assign(r1940, lshift(r1929, r1955), 0x01));

            body.emit(assign(r193F, sub(body.constant(int(1)), r1955), 0x01));

            body.emit(assign(r1927, r1940, 0x01));

            body.emit(assign(r1926, add(r193F, body.constant(int(-1))), 0x01));


         body.instructions = f193C_parent_instructions;
         body.emit(f193C);

         /* END IF */


      body.instructions = f193A_parent_instructions;
      body.emit(f193A);

      /* END IF */

      /* IF CONDITION */
      ir_if *f1956 = new(mem_ctx) ir_if(operand(r1924).val);
      exec_list *const f1956_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1956->then_instructions;

         ir_variable *const r1957 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1957);
         ir_expression *const r1958 = lshift(r192D, body.constant(int(31)));
         ir_expression *const r1959 = add(r1926, body.constant(int(896)));
         ir_expression *const r195A = expr(ir_unop_i2u, r1959);
         ir_expression *const r195B = lshift(r195A, body.constant(int(20)));
         ir_expression *const r195C = add(r1958, r195B);
         ir_expression *const r195D = rshift(r1927, body.constant(int(3)));
         body.emit(assign(r1957, add(r195C, r195D), 0x02));

         ir_expression *const r195E = lshift(r1927, body.constant(int(29)));
         body.emit(assign(r1957, bit_or(r195E, body.constant(0u)), 0x01));

         body.emit(assign(r1925, r1957, 0x03));

         body.emit(assign(r1924, body.constant(false), 0x01));


      body.instructions = f1956_parent_instructions;
      body.emit(f1956);

      /* END IF */


   body.instructions = f192E_parent_instructions;
   body.emit(f192E);

   /* END IF */

   body.emit(ret(r1925));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r195F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r195F);
   ir_variable *const r1960 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r1960);
   ir_variable *const r1961 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r1961);
   ir_expression *const r1962 = lshift(r195F, body.constant(int(31)));
   ir_expression *const r1963 = expr(ir_unop_i2u, r1960);
   ir_expression *const r1964 = lshift(r1963, body.constant(int(23)));
   ir_expression *const r1965 = add(r1962, r1964);
   ir_expression *const r1966 = add(r1965, r1961);
   body.emit(ret(r1966));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift32RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1967 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1967);
   ir_variable *const r1968 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r1968);
   ir_variable *const r1969 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zPtr", ir_var_function_inout);
   sig_parameters.push_tail(r1969);
   ir_variable *const r196A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r196A);
   /* IF CONDITION */
   ir_expression *const r196C = equal(r1968, body.constant(int(0)));
   ir_if *f196B = new(mem_ctx) ir_if(operand(r196C).val);
   exec_list *const f196B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f196B->then_instructions;

      body.emit(assign(r196A, r1967, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f196B->else_instructions;

      /* IF CONDITION */
      ir_expression *const r196E = less(r1968, body.constant(int(32)));
      ir_if *f196D = new(mem_ctx) ir_if(operand(r196E).val);
      exec_list *const f196D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f196D->then_instructions;

         ir_expression *const r196F = rshift(r1967, r1968);
         ir_expression *const r1970 = neg(r1968);
         ir_expression *const r1971 = bit_and(r1970, body.constant(int(31)));
         ir_expression *const r1972 = lshift(r1967, r1971);
         ir_expression *const r1973 = nequal(r1972, body.constant(0u));
         ir_expression *const r1974 = expr(ir_unop_b2i, r1973);
         ir_expression *const r1975 = expr(ir_unop_i2u, r1974);
         body.emit(assign(r196A, bit_or(r196F, r1975), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f196D->else_instructions;

         ir_expression *const r1976 = nequal(r1967, body.constant(0u));
         ir_expression *const r1977 = expr(ir_unop_b2i, r1976);
         body.emit(assign(r196A, expr(ir_unop_i2u, r1977), 0x01));


      body.instructions = f196D_parent_instructions;
      body.emit(f196D);

      /* END IF */


   body.instructions = f196B_parent_instructions;
   body.emit(f196B);

   /* END IF */

   body.emit(assign(r1969, r196A, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1978 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r1978);
   ir_variable *const r1979 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r1979);
   ir_variable *const r197A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r197A);
   ir_variable *const r197B = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r197B, body.constant(true), 0x01));

   ir_variable *const r197C = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r197D = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
   body.emit(r197D);
   ir_expression *const r197E = expr(ir_unop_u2i, r197A);
   body.emit(assign(r197D, bit_and(r197E, body.constant(int(127))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1980 = expr(ir_unop_i2u, r1979);
   ir_expression *const r1981 = lequal(body.constant(253u), r1980);
   ir_if *f197F = new(mem_ctx) ir_if(operand(r1981).val);
   exec_list *const f197F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f197F->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1983 = less(body.constant(int(253)), r1979);
      ir_expression *const r1984 = equal(r1979, body.constant(int(253)));
      ir_expression *const r1985 = add(r197A, body.constant(64u));
      ir_expression *const r1986 = expr(ir_unop_u2i, r1985);
      ir_expression *const r1987 = less(r1986, body.constant(int(0)));
      ir_expression *const r1988 = logic_and(r1984, r1987);
      ir_expression *const r1989 = logic_or(r1983, r1988);
      ir_if *f1982 = new(mem_ctx) ir_if(operand(r1989).val);
      exec_list *const f1982_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1982->then_instructions;

         ir_expression *const r198A = lshift(r1978, body.constant(int(31)));
         body.emit(assign(r197C, add(r198A, body.constant(2139095040u)), 0x01));

         body.emit(assign(r197B, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1982->else_instructions;

         /* IF CONDITION */
         ir_expression *const r198C = less(r1979, body.constant(int(0)));
         ir_if *f198B = new(mem_ctx) ir_if(operand(r198C).val);
         exec_list *const f198B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f198B->then_instructions;

            ir_variable *const r198D = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r198D, neg(r1979), 0x01));

            ir_variable *const r198E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
            body.emit(r198E);
            /* IF CONDITION */
            ir_expression *const r1990 = equal(r198D, body.constant(int(0)));
            ir_if *f198F = new(mem_ctx) ir_if(operand(r1990).val);
            exec_list *const f198F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f198F->then_instructions;

               body.emit(assign(r198E, r197A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f198F->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1992 = less(r198D, body.constant(int(32)));
               ir_if *f1991 = new(mem_ctx) ir_if(operand(r1992).val);
               exec_list *const f1991_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1991->then_instructions;

                  ir_expression *const r1993 = rshift(r197A, r198D);
                  ir_expression *const r1994 = neg(r198D);
                  ir_expression *const r1995 = bit_and(r1994, body.constant(int(31)));
                  ir_expression *const r1996 = lshift(r197A, r1995);
                  ir_expression *const r1997 = nequal(r1996, body.constant(0u));
                  ir_expression *const r1998 = expr(ir_unop_b2i, r1997);
                  ir_expression *const r1999 = expr(ir_unop_i2u, r1998);
                  body.emit(assign(r198E, bit_or(r1993, r1999), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1991->else_instructions;

                  ir_expression *const r199A = nequal(r197A, body.constant(0u));
                  ir_expression *const r199B = expr(ir_unop_b2i, r199A);
                  body.emit(assign(r198E, expr(ir_unop_i2u, r199B), 0x01));


               body.instructions = f1991_parent_instructions;
               body.emit(f1991);

               /* END IF */


            body.instructions = f198F_parent_instructions;
            body.emit(f198F);

            /* END IF */

            body.emit(assign(r197A, r198E, 0x01));

            body.emit(assign(r1979, body.constant(int(0)), 0x01));

            ir_expression *const r199C = expr(ir_unop_u2i, r198E);
            body.emit(assign(r197D, bit_and(r199C, body.constant(int(127))), 0x01));


         body.instructions = f198B_parent_instructions;
         body.emit(f198B);

         /* END IF */


      body.instructions = f1982_parent_instructions;
      body.emit(f1982);

      /* END IF */


   body.instructions = f197F_parent_instructions;
   body.emit(f197F);

   /* END IF */

   /* IF CONDITION */
   ir_if *f199D = new(mem_ctx) ir_if(operand(r197B).val);
   exec_list *const f199D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f199D->then_instructions;

      ir_expression *const r199E = add(r197A, body.constant(64u));
      body.emit(assign(r197A, rshift(r199E, body.constant(int(7))), 0x01));

      ir_expression *const r199F = bit_xor(r197D, body.constant(int(64)));
      ir_expression *const r19A0 = equal(r199F, body.constant(int(0)));
      ir_expression *const r19A1 = expr(ir_unop_b2i, r19A0);
      ir_expression *const r19A2 = expr(ir_unop_i2u, r19A1);
      ir_expression *const r19A3 = bit_and(r19A2, body.constant(1u));
      ir_expression *const r19A4 = expr(ir_unop_bit_not, r19A3);
      body.emit(assign(r197A, bit_and(r197A, r19A4), 0x01));

      /* IF CONDITION */
      ir_expression *const r19A6 = equal(r197A, body.constant(0u));
      ir_if *f19A5 = new(mem_ctx) ir_if(operand(r19A6).val);
      exec_list *const f19A5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19A5->then_instructions;

         body.emit(assign(r1979, body.constant(int(0)), 0x01));


      body.instructions = f19A5_parent_instructions;
      body.emit(f19A5);

      /* END IF */

      ir_expression *const r19A7 = lshift(r1978, body.constant(int(31)));
      ir_expression *const r19A8 = expr(ir_unop_i2u, r1979);
      ir_expression *const r19A9 = lshift(r19A8, body.constant(int(23)));
      ir_expression *const r19AA = add(r19A7, r19A9);
      body.emit(assign(r197C, add(r19AA, r197A), 0x01));

      body.emit(assign(r197B, body.constant(false), 0x01));


   body.instructions = f199D_parent_instructions;
   body.emit(f199D);

   /* END IF */

   body.emit(ret(r197C));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_fp32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::float_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r19AB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r19AB);
   ir_variable *const r19AC = body.make_temp(glsl_type::float_type, "return_value");
   ir_variable *const r19AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_auto);
   body.emit(r19AD);
   body.emit(assign(r19AD, body.constant(0u), 0x01));

   ir_variable *const r19AE = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r19AE, swizzle_x(r19AB), 0x01));

   ir_variable *const r19AF = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r19AF, bit_and(swizzle_y(r19AB), body.constant(1048575u)), 0x01));

   ir_variable *const r19B0 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r19B1 = rshift(swizzle_y(r19AB), body.constant(int(20)));
   ir_expression *const r19B2 = bit_and(r19B1, body.constant(2047u));
   body.emit(assign(r19B0, expr(ir_unop_u2i, r19B2), 0x01));

   ir_variable *const r19B3 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r19B3, rshift(swizzle_y(r19AB), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r19B5 = equal(r19B0, body.constant(int(2047)));
   ir_if *f19B4 = new(mem_ctx) ir_if(operand(r19B5).val);
   exec_list *const f19B4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f19B4->then_instructions;

      /* IF CONDITION */
      ir_expression *const r19B7 = bit_or(r19AF, swizzle_x(r19AB));
      ir_expression *const r19B8 = nequal(r19B7, body.constant(0u));
      ir_if *f19B6 = new(mem_ctx) ir_if(operand(r19B8).val);
      exec_list *const f19B6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19B6->then_instructions;

         ir_variable *const r19B9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r19B9, lshift(swizzle_x(r19AB), body.constant(int(12))), 0x01));

         ir_variable *const r19BA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r19BB = lshift(swizzle_y(r19AB), body.constant(int(12)));
         ir_expression *const r19BC = rshift(swizzle_x(r19AB), body.constant(int(20)));
         body.emit(assign(r19BA, bit_or(r19BB, r19BC), 0x01));

         body.emit(assign(r19AB, r19BA, 0x02));

         body.emit(assign(r19AB, r19B9, 0x01));

         ir_expression *const r19BD = lshift(r19B3, body.constant(int(31)));
         ir_expression *const r19BE = bit_or(r19BD, body.constant(2143289344u));
         ir_expression *const r19BF = rshift(r19BA, body.constant(int(9)));
         ir_expression *const r19C0 = bit_or(r19BE, r19BF);
         body.emit(assign(r19AC, expr(ir_unop_bitcast_u2f, r19C0), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f19B6->else_instructions;

         ir_expression *const r19C1 = lshift(r19B3, body.constant(int(31)));
         ir_expression *const r19C2 = add(r19C1, body.constant(2139095040u));
         body.emit(assign(r19AC, expr(ir_unop_bitcast_u2f, r19C2), 0x01));


      body.instructions = f19B6_parent_instructions;
      body.emit(f19B6);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f19B4->else_instructions;

      ir_variable *const r19C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r19C3);
      ir_variable *const r19C4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r19C4);
      ir_expression *const r19C5 = lshift(r19AF, body.constant(int(10)));
      ir_expression *const r19C6 = rshift(r19AE, body.constant(int(22)));
      ir_expression *const r19C7 = bit_or(r19C5, r19C6);
      ir_expression *const r19C8 = lshift(r19AE, body.constant(int(10)));
      ir_expression *const r19C9 = nequal(r19C8, body.constant(0u));
      ir_expression *const r19CA = expr(ir_unop_b2i, r19C9);
      ir_expression *const r19CB = expr(ir_unop_i2u, r19CA);
      body.emit(assign(r19C3, bit_or(r19C7, r19CB), 0x01));

      body.emit(assign(r19C4, rshift(r19AF, body.constant(int(22))), 0x01));

      body.emit(assign(r19AD, r19C3, 0x01));

      /* IF CONDITION */
      ir_expression *const r19CD = nequal(r19B0, body.constant(int(0)));
      ir_if *f19CC = new(mem_ctx) ir_if(operand(r19CD).val);
      exec_list *const f19CC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19CC->then_instructions;

         body.emit(assign(r19AD, bit_or(r19C3, body.constant(1073741824u)), 0x01));


      body.instructions = f19CC_parent_instructions;
      body.emit(f19CC);

      /* END IF */

      ir_variable *const r19CE = body.make_temp(glsl_type::int_type, "zExp");
      body.emit(assign(r19CE, add(r19B0, body.constant(int(-897))), 0x01));

      ir_variable *const r19CF = body.make_temp(glsl_type::uint_type, "zFrac");
      body.emit(assign(r19CF, r19AD, 0x01));

      ir_variable *const r19D0 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r19D0, body.constant(true), 0x01));

      ir_variable *const r19D1 = body.make_temp(glsl_type::uint_type, "return_value");
      ir_variable *const r19D2 = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
      body.emit(r19D2);
      ir_expression *const r19D3 = expr(ir_unop_u2i, r19AD);
      body.emit(assign(r19D2, bit_and(r19D3, body.constant(int(127))), 0x01));

      /* IF CONDITION */
      ir_expression *const r19D5 = expr(ir_unop_i2u, r19CE);
      ir_expression *const r19D6 = lequal(body.constant(253u), r19D5);
      ir_if *f19D4 = new(mem_ctx) ir_if(operand(r19D6).val);
      exec_list *const f19D4_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19D4->then_instructions;

         /* IF CONDITION */
         ir_expression *const r19D8 = less(body.constant(int(253)), r19CE);
         ir_expression *const r19D9 = equal(r19CE, body.constant(int(253)));
         ir_expression *const r19DA = add(r19AD, body.constant(64u));
         ir_expression *const r19DB = expr(ir_unop_u2i, r19DA);
         ir_expression *const r19DC = less(r19DB, body.constant(int(0)));
         ir_expression *const r19DD = logic_and(r19D9, r19DC);
         ir_expression *const r19DE = logic_or(r19D8, r19DD);
         ir_if *f19D7 = new(mem_ctx) ir_if(operand(r19DE).val);
         exec_list *const f19D7_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f19D7->then_instructions;

            ir_expression *const r19DF = lshift(r19B3, body.constant(int(31)));
            body.emit(assign(r19D1, add(r19DF, body.constant(2139095040u)), 0x01));

            body.emit(assign(r19D0, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f19D7->else_instructions;

            /* IF CONDITION */
            ir_expression *const r19E1 = less(r19CE, body.constant(int(0)));
            ir_if *f19E0 = new(mem_ctx) ir_if(operand(r19E1).val);
            exec_list *const f19E0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f19E0->then_instructions;

               ir_variable *const r19E2 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r19E2, neg(r19CE), 0x01));

               ir_variable *const r19E3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r19E3);
               /* IF CONDITION */
               ir_expression *const r19E5 = equal(r19E2, body.constant(int(0)));
               ir_if *f19E4 = new(mem_ctx) ir_if(operand(r19E5).val);
               exec_list *const f19E4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f19E4->then_instructions;

                  body.emit(assign(r19E3, r19AD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f19E4->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r19E7 = less(r19E2, body.constant(int(32)));
                  ir_if *f19E6 = new(mem_ctx) ir_if(operand(r19E7).val);
                  exec_list *const f19E6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f19E6->then_instructions;

                     ir_expression *const r19E8 = rshift(r19AD, r19E2);
                     ir_expression *const r19E9 = neg(r19E2);
                     ir_expression *const r19EA = bit_and(r19E9, body.constant(int(31)));
                     ir_expression *const r19EB = lshift(r19AD, r19EA);
                     ir_expression *const r19EC = nequal(r19EB, body.constant(0u));
                     ir_expression *const r19ED = expr(ir_unop_b2i, r19EC);
                     ir_expression *const r19EE = expr(ir_unop_i2u, r19ED);
                     body.emit(assign(r19E3, bit_or(r19E8, r19EE), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f19E6->else_instructions;

                     ir_expression *const r19EF = nequal(r19AD, body.constant(0u));
                     ir_expression *const r19F0 = expr(ir_unop_b2i, r19EF);
                     body.emit(assign(r19E3, expr(ir_unop_i2u, r19F0), 0x01));


                  body.instructions = f19E6_parent_instructions;
                  body.emit(f19E6);

                  /* END IF */


               body.instructions = f19E4_parent_instructions;
               body.emit(f19E4);

               /* END IF */

               body.emit(assign(r19CF, r19E3, 0x01));

               body.emit(assign(r19CE, body.constant(int(0)), 0x01));

               ir_expression *const r19F1 = expr(ir_unop_u2i, r19E3);
               body.emit(assign(r19D2, bit_and(r19F1, body.constant(int(127))), 0x01));


            body.instructions = f19E0_parent_instructions;
            body.emit(f19E0);

            /* END IF */


         body.instructions = f19D7_parent_instructions;
         body.emit(f19D7);

         /* END IF */


      body.instructions = f19D4_parent_instructions;
      body.emit(f19D4);

      /* END IF */

      /* IF CONDITION */
      ir_if *f19F2 = new(mem_ctx) ir_if(operand(r19D0).val);
      exec_list *const f19F2_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19F2->then_instructions;

         ir_expression *const r19F3 = add(r19CF, body.constant(64u));
         body.emit(assign(r19CF, rshift(r19F3, body.constant(int(7))), 0x01));

         ir_expression *const r19F4 = bit_xor(r19D2, body.constant(int(64)));
         ir_expression *const r19F5 = equal(r19F4, body.constant(int(0)));
         ir_expression *const r19F6 = expr(ir_unop_b2i, r19F5);
         ir_expression *const r19F7 = expr(ir_unop_i2u, r19F6);
         ir_expression *const r19F8 = bit_and(r19F7, body.constant(1u));
         ir_expression *const r19F9 = expr(ir_unop_bit_not, r19F8);
         body.emit(assign(r19CF, bit_and(r19CF, r19F9), 0x01));

         /* IF CONDITION */
         ir_expression *const r19FB = equal(r19CF, body.constant(0u));
         ir_if *f19FA = new(mem_ctx) ir_if(operand(r19FB).val);
         exec_list *const f19FA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f19FA->then_instructions;

            body.emit(assign(r19CE, body.constant(int(0)), 0x01));


         body.instructions = f19FA_parent_instructions;
         body.emit(f19FA);

         /* END IF */

         ir_expression *const r19FC = lshift(r19B3, body.constant(int(31)));
         ir_expression *const r19FD = expr(ir_unop_i2u, r19CE);
         ir_expression *const r19FE = lshift(r19FD, body.constant(int(23)));
         ir_expression *const r19FF = add(r19FC, r19FE);
         body.emit(assign(r19D1, add(r19FF, r19CF), 0x01));

         body.emit(assign(r19D0, body.constant(false), 0x01));


      body.instructions = f19F2_parent_instructions;
      body.emit(f19F2);

      /* END IF */

      body.emit(assign(r19AC, expr(ir_unop_bitcast_u2f, r19D1), 0x01));


   body.instructions = f19B4_parent_instructions;
   body.emit(f19B4);

   /* END IF */

   body.emit(ret(r19AC));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_int(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A00 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1A00);
   ir_variable *const r1A01 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1A01, body.constant(true), 0x01));

   ir_variable *const r1A02 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r1A03 = new(mem_ctx) ir_variable(glsl_type::uint_type, "absZ", ir_var_auto);
   body.emit(r1A03);
   ir_variable *const r1A04 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aSign", ir_var_auto);
   body.emit(r1A04);
   ir_variable *const r1A05 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r1A05);
   ir_variable *const r1A06 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1A06, bit_and(swizzle_y(r1A00), body.constant(1048575u)), 0x01));

   body.emit(assign(r1A05, r1A06, 0x01));

   ir_variable *const r1A07 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1A08 = rshift(swizzle_y(r1A00), body.constant(int(20)));
   ir_expression *const r1A09 = bit_and(r1A08, body.constant(2047u));
   body.emit(assign(r1A07, expr(ir_unop_u2i, r1A09), 0x01));

   body.emit(assign(r1A04, rshift(swizzle_y(r1A00), body.constant(int(31))), 0x01));

   body.emit(assign(r1A03, body.constant(0u), 0x01));

   ir_variable *const r1A0A = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r1A0A, add(r1A07, body.constant(int(-1043))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A0C = lequal(body.constant(int(0)), r1A0A);
   ir_if *f1A0B = new(mem_ctx) ir_if(operand(r1A0C).val);
   exec_list *const f1A0B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A0B->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1A0E = less(body.constant(int(1054)), r1A07);
      ir_if *f1A0D = new(mem_ctx) ir_if(operand(r1A0E).val);
      exec_list *const f1A0D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A0D->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1A10 = equal(r1A07, body.constant(int(2047)));
         ir_expression *const r1A11 = bit_or(r1A06, swizzle_x(r1A00));
         ir_expression *const r1A12 = expr(ir_unop_u2i, r1A11);
         ir_expression *const r1A13 = expr(ir_unop_i2b, r1A12);
         ir_expression *const r1A14 = logic_and(r1A10, r1A13);
         ir_if *f1A0F = new(mem_ctx) ir_if(operand(r1A14).val);
         exec_list *const f1A0F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A0F->then_instructions;

            body.emit(assign(r1A04, body.constant(0u), 0x01));


         body.instructions = f1A0F_parent_instructions;
         body.emit(f1A0F);

         /* END IF */

         ir_variable *const r1A15 = body.make_temp(glsl_type::int_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A17 = expr(ir_unop_u2i, r1A04);
         ir_expression *const r1A18 = expr(ir_unop_i2b, r1A17);
         ir_if *f1A16 = new(mem_ctx) ir_if(operand(r1A18).val);
         exec_list *const f1A16_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A16->then_instructions;

            body.emit(assign(r1A15, body.constant(int(-2147483648)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A16->else_instructions;

            body.emit(assign(r1A15, body.constant(int(2147483647)), 0x01));


         body.instructions = f1A16_parent_instructions;
         body.emit(f1A16);

         /* END IF */

         body.emit(assign(r1A02, r1A15, 0x01));

         body.emit(assign(r1A01, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A0D->else_instructions;

         ir_variable *const r1A19 = body.make_temp(glsl_type::uint_type, "a0");
         body.emit(assign(r1A19, bit_or(r1A06, body.constant(1048576u)), 0x01));

         ir_variable *const r1A1A = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1A1A, lshift(swizzle_x(r1A00), r1A0A), 0x01));

         ir_variable *const r1A1B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A1D = equal(r1A0A, body.constant(int(0)));
         ir_if *f1A1C = new(mem_ctx) ir_if(operand(r1A1D).val);
         exec_list *const f1A1C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A1C->then_instructions;

            body.emit(assign(r1A1B, r1A19, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A1C->else_instructions;

            ir_expression *const r1A1E = lshift(r1A19, r1A0A);
            ir_expression *const r1A1F = neg(r1A0A);
            ir_expression *const r1A20 = bit_and(r1A1F, body.constant(int(31)));
            ir_expression *const r1A21 = rshift(swizzle_x(r1A00), r1A20);
            body.emit(assign(r1A1B, bit_or(r1A1E, r1A21), 0x01));


         body.instructions = f1A1C_parent_instructions;
         body.emit(f1A1C);

         /* END IF */

         body.emit(assign(r1A03, r1A1B, 0x01));


      body.instructions = f1A0D_parent_instructions;
      body.emit(f1A0D);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1A0B->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1A23 = less(r1A07, body.constant(int(1023)));
      ir_if *f1A22 = new(mem_ctx) ir_if(operand(r1A23).val);
      exec_list *const f1A22_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A22->then_instructions;

         body.emit(assign(r1A02, body.constant(int(0)), 0x01));

         body.emit(assign(r1A01, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A22->else_instructions;

         body.emit(assign(r1A05, bit_or(r1A06, body.constant(1048576u)), 0x01));

         ir_expression *const r1A24 = neg(r1A0A);
         body.emit(assign(r1A03, rshift(r1A05, r1A24), 0x01));


      body.instructions = f1A22_parent_instructions;
      body.emit(f1A22);

      /* END IF */


   body.instructions = f1A0B_parent_instructions;
   body.emit(f1A0B);

   /* END IF */

   /* IF CONDITION */
   ir_if *f1A25 = new(mem_ctx) ir_if(operand(r1A01).val);
   exec_list *const f1A25_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A25->then_instructions;

      ir_variable *const r1A26 = body.make_temp(glsl_type::int_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1A28 = nequal(r1A04, body.constant(0u));
      ir_if *f1A27 = new(mem_ctx) ir_if(operand(r1A28).val);
      exec_list *const f1A27_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A27->then_instructions;

         ir_expression *const r1A29 = expr(ir_unop_u2i, r1A03);
         body.emit(assign(r1A26, neg(r1A29), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A27->else_instructions;

         body.emit(assign(r1A26, expr(ir_unop_u2i, r1A03), 0x01));


      body.instructions = f1A27_parent_instructions;
      body.emit(f1A27);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1A2B = less(r1A26, body.constant(int(0)));
      ir_expression *const r1A2C = expr(ir_unop_b2i, r1A2B);
      ir_expression *const r1A2D = expr(ir_unop_i2u, r1A2C);
      ir_expression *const r1A2E = bit_xor(r1A04, r1A2D);
      ir_expression *const r1A2F = expr(ir_unop_u2i, r1A2E);
      ir_expression *const r1A30 = expr(ir_unop_i2b, r1A2F);
      ir_expression *const r1A31 = expr(ir_unop_i2b, r1A26);
      ir_expression *const r1A32 = logic_and(r1A30, r1A31);
      ir_if *f1A2A = new(mem_ctx) ir_if(operand(r1A32).val);
      exec_list *const f1A2A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A2A->then_instructions;

         ir_variable *const r1A33 = body.make_temp(glsl_type::int_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A35 = expr(ir_unop_u2i, r1A04);
         ir_expression *const r1A36 = expr(ir_unop_i2b, r1A35);
         ir_if *f1A34 = new(mem_ctx) ir_if(operand(r1A36).val);
         exec_list *const f1A34_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A34->then_instructions;

            body.emit(assign(r1A33, body.constant(int(-2147483648)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A34->else_instructions;

            body.emit(assign(r1A33, body.constant(int(2147483647)), 0x01));


         body.instructions = f1A34_parent_instructions;
         body.emit(f1A34);

         /* END IF */

         body.emit(assign(r1A02, r1A33, 0x01));

         body.emit(assign(r1A01, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A2A->else_instructions;

         body.emit(assign(r1A02, r1A26, 0x01));

         body.emit(assign(r1A01, body.constant(false), 0x01));


      body.instructions = f1A2A_parent_instructions;
      body.emit(f1A2A);

      /* END IF */


   body.instructions = f1A25_parent_instructions;
   body.emit(f1A25);

   /* END IF */

   body.emit(ret(r1A02));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
int_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A37 = new(mem_ctx) ir_variable(glsl_type::int_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1A37);
   ir_variable *const r1A38 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1A39 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r1A39);
   ir_variable *const r1A3A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r1A3A);
   ir_variable *const r1A3B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r1A3B);
   body.emit(assign(r1A3B, body.constant(0u), 0x01));

   body.emit(assign(r1A3A, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A3D = equal(r1A37, body.constant(int(0)));
   ir_if *f1A3C = new(mem_ctx) ir_if(operand(r1A3D).val);
   exec_list *const f1A3C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A3C->then_instructions;

      ir_variable *const r1A3E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1A3E);
      body.emit(assign(r1A3E, body.constant(0u), 0x02));

      body.emit(assign(r1A3E, body.constant(0u), 0x01));

      body.emit(assign(r1A38, r1A3E, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1A3C->else_instructions;

      ir_expression *const r1A3F = less(r1A37, body.constant(int(0)));
      ir_expression *const r1A40 = expr(ir_unop_b2i, r1A3F);
      body.emit(assign(r1A39, expr(ir_unop_i2u, r1A40), 0x01));

      ir_variable *const r1A41 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1A43 = less(r1A37, body.constant(int(0)));
      ir_if *f1A42 = new(mem_ctx) ir_if(operand(r1A43).val);
      exec_list *const f1A42_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A42->then_instructions;

         ir_expression *const r1A44 = neg(r1A37);
         body.emit(assign(r1A41, expr(ir_unop_i2u, r1A44), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A42->else_instructions;

         body.emit(assign(r1A41, expr(ir_unop_i2u, r1A37), 0x01));


      body.instructions = f1A42_parent_instructions;
      body.emit(f1A42);

      /* END IF */

      ir_variable *const r1A45 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1A45, r1A41, 0x01));

      ir_variable *const r1A46 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1A47 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1A47);
      /* IF CONDITION */
      ir_expression *const r1A49 = equal(r1A41, body.constant(0u));
      ir_if *f1A48 = new(mem_ctx) ir_if(operand(r1A49).val);
      exec_list *const f1A48_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A48->then_instructions;

         body.emit(assign(r1A46, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A48->else_instructions;

         body.emit(assign(r1A47, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1A4B = bit_and(r1A41, body.constant(4294901760u));
         ir_expression *const r1A4C = equal(r1A4B, body.constant(0u));
         ir_if *f1A4A = new(mem_ctx) ir_if(operand(r1A4C).val);
         exec_list *const f1A4A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A4A->then_instructions;

            body.emit(assign(r1A47, body.constant(int(16)), 0x01));

            body.emit(assign(r1A45, lshift(r1A41, body.constant(int(16))), 0x01));


         body.instructions = f1A4A_parent_instructions;
         body.emit(f1A4A);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A4E = bit_and(r1A45, body.constant(4278190080u));
         ir_expression *const r1A4F = equal(r1A4E, body.constant(0u));
         ir_if *f1A4D = new(mem_ctx) ir_if(operand(r1A4F).val);
         exec_list *const f1A4D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A4D->then_instructions;

            body.emit(assign(r1A47, add(r1A47, body.constant(int(8))), 0x01));

            body.emit(assign(r1A45, lshift(r1A45, body.constant(int(8))), 0x01));


         body.instructions = f1A4D_parent_instructions;
         body.emit(f1A4D);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A51 = bit_and(r1A45, body.constant(4026531840u));
         ir_expression *const r1A52 = equal(r1A51, body.constant(0u));
         ir_if *f1A50 = new(mem_ctx) ir_if(operand(r1A52).val);
         exec_list *const f1A50_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A50->then_instructions;

            body.emit(assign(r1A47, add(r1A47, body.constant(int(4))), 0x01));

            body.emit(assign(r1A45, lshift(r1A45, body.constant(int(4))), 0x01));


         body.instructions = f1A50_parent_instructions;
         body.emit(f1A50);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A54 = bit_and(r1A45, body.constant(3221225472u));
         ir_expression *const r1A55 = equal(r1A54, body.constant(0u));
         ir_if *f1A53 = new(mem_ctx) ir_if(operand(r1A55).val);
         exec_list *const f1A53_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A53->then_instructions;

            body.emit(assign(r1A47, add(r1A47, body.constant(int(2))), 0x01));

            body.emit(assign(r1A45, lshift(r1A45, body.constant(int(2))), 0x01));


         body.instructions = f1A53_parent_instructions;
         body.emit(f1A53);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A57 = bit_and(r1A45, body.constant(2147483648u));
         ir_expression *const r1A58 = equal(r1A57, body.constant(0u));
         ir_if *f1A56 = new(mem_ctx) ir_if(operand(r1A58).val);
         exec_list *const f1A56_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A56->then_instructions;

            body.emit(assign(r1A47, add(r1A47, body.constant(int(1))), 0x01));


         body.instructions = f1A56_parent_instructions;
         body.emit(f1A56);

         /* END IF */

         body.emit(assign(r1A46, r1A47, 0x01));


      body.instructions = f1A48_parent_instructions;
      body.emit(f1A48);

      /* END IF */

      ir_variable *const r1A59 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r1A59, add(r1A46, body.constant(int(-11))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1A5B = lequal(body.constant(int(0)), r1A59);
      ir_if *f1A5A = new(mem_ctx) ir_if(operand(r1A5B).val);
      exec_list *const f1A5A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A5A->then_instructions;

         body.emit(assign(r1A3B, lshift(r1A41, r1A59), 0x01));

         body.emit(assign(r1A3A, body.constant(0u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A5A->else_instructions;

         ir_variable *const r1A5C = body.make_temp(glsl_type::uint_type, "a1");
         body.emit(assign(r1A5C, body.constant(0u), 0x01));

         ir_variable *const r1A5D = body.make_temp(glsl_type::int_type, "count");
         body.emit(assign(r1A5D, neg(r1A59), 0x01));

         ir_variable *const r1A5E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r1A5E);
         ir_variable *const r1A5F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r1A5F);
         ir_variable *const r1A60 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r1A61 = neg(r1A5D);
         body.emit(assign(r1A60, bit_and(r1A61, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r1A63 = equal(r1A5D, body.constant(int(0)));
         ir_if *f1A62 = new(mem_ctx) ir_if(operand(r1A63).val);
         exec_list *const f1A62_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A62->then_instructions;

            body.emit(assign(r1A5E, body.constant(0u), 0x01));

            body.emit(assign(r1A5F, r1A41, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A62->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1A65 = less(r1A5D, body.constant(int(32)));
            ir_if *f1A64 = new(mem_ctx) ir_if(operand(r1A65).val);
            exec_list *const f1A64_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1A64->then_instructions;

               ir_expression *const r1A66 = lshift(r1A41, r1A60);
               body.emit(assign(r1A5E, bit_or(r1A66, body.constant(0u)), 0x01));

               body.emit(assign(r1A5F, rshift(r1A41, r1A5D), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1A64->else_instructions;

               ir_variable *const r1A67 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1A69 = less(r1A5D, body.constant(int(64)));
               ir_if *f1A68 = new(mem_ctx) ir_if(operand(r1A69).val);
               exec_list *const f1A68_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1A68->then_instructions;

                  ir_expression *const r1A6A = bit_and(r1A5D, body.constant(int(31)));
                  body.emit(assign(r1A67, rshift(r1A41, r1A6A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1A68->else_instructions;

                  body.emit(assign(r1A67, body.constant(0u), 0x01));


               body.instructions = f1A68_parent_instructions;
               body.emit(f1A68);

               /* END IF */

               body.emit(assign(r1A5E, r1A67, 0x01));

               body.emit(assign(r1A5F, body.constant(0u), 0x01));


            body.instructions = f1A64_parent_instructions;
            body.emit(f1A64);

            /* END IF */


         body.instructions = f1A62_parent_instructions;
         body.emit(f1A62);

         /* END IF */

         body.emit(assign(r1A3B, r1A5F, 0x01));

         body.emit(assign(r1A3A, r1A5E, 0x01));


      body.instructions = f1A5A_parent_instructions;
      body.emit(f1A5A);

      /* END IF */

      ir_variable *const r1A6B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1A6B);
      ir_expression *const r1A6C = lshift(r1A39, body.constant(int(31)));
      ir_expression *const r1A6D = sub(body.constant(int(1042)), r1A59);
      ir_expression *const r1A6E = expr(ir_unop_i2u, r1A6D);
      ir_expression *const r1A6F = lshift(r1A6E, body.constant(int(20)));
      ir_expression *const r1A70 = add(r1A6C, r1A6F);
      body.emit(assign(r1A6B, add(r1A70, r1A3B), 0x02));

      body.emit(assign(r1A6B, r1A3A, 0x01));

      body.emit(assign(r1A38, r1A6B, 0x03));


   body.instructions = f1A3C_parent_instructions;
   body.emit(f1A3C);

   /* END IF */

   body.emit(ret(r1A38));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fgt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A71 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1A71);
   ir_variable *const r1A72 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1A72);
   ir_variable *const r1A73 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r1A74 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r1A74);
   ir_variable *const r1A75 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r1A75);
   ir_expression *const r1A76 = rshift(swizzle_y(r1A72), body.constant(int(20)));
   ir_expression *const r1A77 = bit_and(r1A76, body.constant(2047u));
   ir_expression *const r1A78 = expr(ir_unop_u2i, r1A77);
   ir_expression *const r1A79 = equal(r1A78, body.constant(int(2047)));
   ir_expression *const r1A7A = bit_and(swizzle_y(r1A72), body.constant(1048575u));
   ir_expression *const r1A7B = bit_or(r1A7A, swizzle_x(r1A72));
   ir_expression *const r1A7C = nequal(r1A7B, body.constant(0u));
   body.emit(assign(r1A75, logic_and(r1A79, r1A7C), 0x01));

   ir_expression *const r1A7D = rshift(swizzle_y(r1A71), body.constant(int(20)));
   ir_expression *const r1A7E = bit_and(r1A7D, body.constant(2047u));
   ir_expression *const r1A7F = expr(ir_unop_u2i, r1A7E);
   ir_expression *const r1A80 = equal(r1A7F, body.constant(int(2047)));
   ir_expression *const r1A81 = bit_and(swizzle_y(r1A71), body.constant(1048575u));
   ir_expression *const r1A82 = bit_or(r1A81, swizzle_x(r1A71));
   ir_expression *const r1A83 = nequal(r1A82, body.constant(0u));
   body.emit(assign(r1A74, logic_and(r1A80, r1A83), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A85 = logic_or(r1A75, r1A74);
   ir_if *f1A84 = new(mem_ctx) ir_if(operand(r1A85).val);
   exec_list *const f1A84_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A84->then_instructions;

      body.emit(assign(r1A73, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1A84->else_instructions;

      ir_variable *const r1A86 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1A86, rshift(swizzle_y(r1A72), body.constant(int(31))), 0x01));

      ir_variable *const r1A87 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1A87, rshift(swizzle_y(r1A71), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1A89 = nequal(r1A86, r1A87);
      ir_if *f1A88 = new(mem_ctx) ir_if(operand(r1A89).val);
      exec_list *const f1A88_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A88->then_instructions;

         ir_expression *const r1A8A = nequal(r1A86, body.constant(0u));
         ir_expression *const r1A8B = bit_or(swizzle_y(r1A72), swizzle_y(r1A71));
         ir_expression *const r1A8C = lshift(r1A8B, body.constant(int(1)));
         ir_expression *const r1A8D = bit_or(r1A8C, swizzle_x(r1A72));
         ir_expression *const r1A8E = bit_or(r1A8D, swizzle_x(r1A71));
         ir_expression *const r1A8F = nequal(r1A8E, body.constant(0u));
         body.emit(assign(r1A73, logic_and(r1A8A, r1A8F), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A88->else_instructions;

         ir_variable *const r1A90 = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A92 = nequal(r1A86, body.constant(0u));
         ir_if *f1A91 = new(mem_ctx) ir_if(operand(r1A92).val);
         exec_list *const f1A91_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A91->then_instructions;

            ir_expression *const r1A93 = less(swizzle_y(r1A71), swizzle_y(r1A72));
            ir_expression *const r1A94 = equal(swizzle_y(r1A71), swizzle_y(r1A72));
            ir_expression *const r1A95 = less(swizzle_x(r1A71), swizzle_x(r1A72));
            ir_expression *const r1A96 = logic_and(r1A94, r1A95);
            body.emit(assign(r1A90, logic_or(r1A93, r1A96), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A91->else_instructions;

            ir_expression *const r1A97 = less(swizzle_y(r1A72), swizzle_y(r1A71));
            ir_expression *const r1A98 = equal(swizzle_y(r1A72), swizzle_y(r1A71));
            ir_expression *const r1A99 = less(swizzle_x(r1A72), swizzle_x(r1A71));
            ir_expression *const r1A9A = logic_and(r1A98, r1A99);
            body.emit(assign(r1A90, logic_or(r1A97, r1A9A), 0x01));


         body.instructions = f1A91_parent_instructions;
         body.emit(f1A91);

         /* END IF */

         body.emit(assign(r1A73, r1A90, 0x01));


      body.instructions = f1A88_parent_instructions;
      body.emit(f1A88);

      /* END IF */


   body.instructions = f1A84_parent_instructions;
   body.emit(f1A84);

   /* END IF */

   body.emit(ret(r1A73));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sqrtOddAdjustments(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A9B = new(mem_ctx) ir_variable(glsl_type::int_type, "index", ir_var_function_in);
   sig_parameters.push_tail(r1A9B);
   ir_variable *const r1A9C = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
   body.emit(r1A9C);
   body.emit(assign(r1A9C, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A9E = equal(r1A9B, body.constant(int(0)));
   ir_if *f1A9D = new(mem_ctx) ir_if(operand(r1A9E).val);
   exec_list *const f1A9D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A9D->then_instructions;

      body.emit(assign(r1A9C, body.constant(4u), 0x01));


   body.instructions = f1A9D_parent_instructions;
   body.emit(f1A9D);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA0 = equal(r1A9B, body.constant(int(1)));
   ir_if *f1A9F = new(mem_ctx) ir_if(operand(r1AA0).val);
   exec_list *const f1A9F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A9F->then_instructions;

      body.emit(assign(r1A9C, body.constant(34u), 0x01));


   body.instructions = f1A9F_parent_instructions;
   body.emit(f1A9F);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA2 = equal(r1A9B, body.constant(int(2)));
   ir_if *f1AA1 = new(mem_ctx) ir_if(operand(r1AA2).val);
   exec_list *const f1AA1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA1->then_instructions;

      body.emit(assign(r1A9C, body.constant(93u), 0x01));


   body.instructions = f1AA1_parent_instructions;
   body.emit(f1AA1);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA4 = equal(r1A9B, body.constant(int(3)));
   ir_if *f1AA3 = new(mem_ctx) ir_if(operand(r1AA4).val);
   exec_list *const f1AA3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA3->then_instructions;

      body.emit(assign(r1A9C, body.constant(177u), 0x01));


   body.instructions = f1AA3_parent_instructions;
   body.emit(f1AA3);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA6 = equal(r1A9B, body.constant(int(4)));
   ir_if *f1AA5 = new(mem_ctx) ir_if(operand(r1AA6).val);
   exec_list *const f1AA5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA5->then_instructions;

      body.emit(assign(r1A9C, body.constant(285u), 0x01));


   body.instructions = f1AA5_parent_instructions;
   body.emit(f1AA5);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA8 = equal(r1A9B, body.constant(int(5)));
   ir_if *f1AA7 = new(mem_ctx) ir_if(operand(r1AA8).val);
   exec_list *const f1AA7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA7->then_instructions;

      body.emit(assign(r1A9C, body.constant(415u), 0x01));


   body.instructions = f1AA7_parent_instructions;
   body.emit(f1AA7);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AAA = equal(r1A9B, body.constant(int(6)));
   ir_if *f1AA9 = new(mem_ctx) ir_if(operand(r1AAA).val);
   exec_list *const f1AA9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA9->then_instructions;

      body.emit(assign(r1A9C, body.constant(566u), 0x01));


   body.instructions = f1AA9_parent_instructions;
   body.emit(f1AA9);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AAC = equal(r1A9B, body.constant(int(7)));
   ir_if *f1AAB = new(mem_ctx) ir_if(operand(r1AAC).val);
   exec_list *const f1AAB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AAB->then_instructions;

      body.emit(assign(r1A9C, body.constant(736u), 0x01));


   body.instructions = f1AAB_parent_instructions;
   body.emit(f1AAB);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AAE = equal(r1A9B, body.constant(int(8)));
   ir_if *f1AAD = new(mem_ctx) ir_if(operand(r1AAE).val);
   exec_list *const f1AAD_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AAD->then_instructions;

      body.emit(assign(r1A9C, body.constant(924u), 0x01));


   body.instructions = f1AAD_parent_instructions;
   body.emit(f1AAD);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB0 = equal(r1A9B, body.constant(int(9)));
   ir_if *f1AAF = new(mem_ctx) ir_if(operand(r1AB0).val);
   exec_list *const f1AAF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AAF->then_instructions;

      body.emit(assign(r1A9C, body.constant(1128u), 0x01));


   body.instructions = f1AAF_parent_instructions;
   body.emit(f1AAF);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB2 = equal(r1A9B, body.constant(int(10)));
   ir_if *f1AB1 = new(mem_ctx) ir_if(operand(r1AB2).val);
   exec_list *const f1AB1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB1->then_instructions;

      body.emit(assign(r1A9C, body.constant(1349u), 0x01));


   body.instructions = f1AB1_parent_instructions;
   body.emit(f1AB1);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB4 = equal(r1A9B, body.constant(int(11)));
   ir_if *f1AB3 = new(mem_ctx) ir_if(operand(r1AB4).val);
   exec_list *const f1AB3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB3->then_instructions;

      body.emit(assign(r1A9C, body.constant(1585u), 0x01));


   body.instructions = f1AB3_parent_instructions;
   body.emit(f1AB3);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB6 = equal(r1A9B, body.constant(int(12)));
   ir_if *f1AB5 = new(mem_ctx) ir_if(operand(r1AB6).val);
   exec_list *const f1AB5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB5->then_instructions;

      body.emit(assign(r1A9C, body.constant(1835u), 0x01));


   body.instructions = f1AB5_parent_instructions;
   body.emit(f1AB5);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB8 = equal(r1A9B, body.constant(int(13)));
   ir_if *f1AB7 = new(mem_ctx) ir_if(operand(r1AB8).val);
   exec_list *const f1AB7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB7->then_instructions;

      body.emit(assign(r1A9C, body.constant(2098u), 0x01));


   body.instructions = f1AB7_parent_instructions;
   body.emit(f1AB7);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ABA = equal(r1A9B, body.constant(int(14)));
   ir_if *f1AB9 = new(mem_ctx) ir_if(operand(r1ABA).val);
   exec_list *const f1AB9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB9->then_instructions;

      body.emit(assign(r1A9C, body.constant(2374u), 0x01));


   body.instructions = f1AB9_parent_instructions;
   body.emit(f1AB9);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ABC = equal(r1A9B, body.constant(int(15)));
   ir_if *f1ABB = new(mem_ctx) ir_if(operand(r1ABC).val);
   exec_list *const f1ABB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ABB->then_instructions;

      body.emit(assign(r1A9C, body.constant(2663u), 0x01));


   body.instructions = f1ABB_parent_instructions;
   body.emit(f1ABB);

   /* END IF */

   body.emit(ret(r1A9C));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sqrtEvenAdjustments(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1ABD = new(mem_ctx) ir_variable(glsl_type::int_type, "index", ir_var_function_in);
   sig_parameters.push_tail(r1ABD);
   ir_variable *const r1ABE = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
   body.emit(r1ABE);
   body.emit(assign(r1ABE, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1AC0 = equal(r1ABD, body.constant(int(0)));
   ir_if *f1ABF = new(mem_ctx) ir_if(operand(r1AC0).val);
   exec_list *const f1ABF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ABF->then_instructions;

      body.emit(assign(r1ABE, body.constant(2605u), 0x01));


   body.instructions = f1ABF_parent_instructions;
   body.emit(f1ABF);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AC2 = equal(r1ABD, body.constant(int(1)));
   ir_if *f1AC1 = new(mem_ctx) ir_if(operand(r1AC2).val);
   exec_list *const f1AC1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AC1->then_instructions;

      body.emit(assign(r1ABE, body.constant(2223u), 0x01));


   body.instructions = f1AC1_parent_instructions;
   body.emit(f1AC1);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AC4 = equal(r1ABD, body.constant(int(2)));
   ir_if *f1AC3 = new(mem_ctx) ir_if(operand(r1AC4).val);
   exec_list *const f1AC3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AC3->then_instructions;

      body.emit(assign(r1ABE, body.constant(1882u), 0x01));


   body.instructions = f1AC3_parent_instructions;
   body.emit(f1AC3);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AC6 = equal(r1ABD, body.constant(int(3)));
   ir_if *f1AC5 = new(mem_ctx) ir_if(operand(r1AC6).val);
   exec_list *const f1AC5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AC5->then_instructions;

      body.emit(assign(r1ABE, body.constant(1577u), 0x01));


   body.instructions = f1AC5_parent_instructions;
   body.emit(f1AC5);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AC8 = equal(r1ABD, body.constant(int(4)));
   ir_if *f1AC7 = new(mem_ctx) ir_if(operand(r1AC8).val);
   exec_list *const f1AC7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AC7->then_instructions;

      body.emit(assign(r1ABE, body.constant(1306u), 0x01));


   body.instructions = f1AC7_parent_instructions;
   body.emit(f1AC7);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ACA = equal(r1ABD, body.constant(int(5)));
   ir_if *f1AC9 = new(mem_ctx) ir_if(operand(r1ACA).val);
   exec_list *const f1AC9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AC9->then_instructions;

      body.emit(assign(r1ABE, body.constant(1065u), 0x01));


   body.instructions = f1AC9_parent_instructions;
   body.emit(f1AC9);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ACC = equal(r1ABD, body.constant(int(6)));
   ir_if *f1ACB = new(mem_ctx) ir_if(operand(r1ACC).val);
   exec_list *const f1ACB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ACB->then_instructions;

      body.emit(assign(r1ABE, body.constant(854u), 0x01));


   body.instructions = f1ACB_parent_instructions;
   body.emit(f1ACB);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ACE = equal(r1ABD, body.constant(int(7)));
   ir_if *f1ACD = new(mem_ctx) ir_if(operand(r1ACE).val);
   exec_list *const f1ACD_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ACD->then_instructions;

      body.emit(assign(r1ABE, body.constant(670u), 0x01));


   body.instructions = f1ACD_parent_instructions;
   body.emit(f1ACD);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AD0 = equal(r1ABD, body.constant(int(8)));
   ir_if *f1ACF = new(mem_ctx) ir_if(operand(r1AD0).val);
   exec_list *const f1ACF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ACF->then_instructions;

      body.emit(assign(r1ABE, body.constant(512u), 0x01));


   body.instructions = f1ACF_parent_instructions;
   body.emit(f1ACF);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AD2 = equal(r1ABD, body.constant(int(9)));
   ir_if *f1AD1 = new(mem_ctx) ir_if(operand(r1AD2).val);
   exec_list *const f1AD1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AD1->then_instructions;

      body.emit(assign(r1ABE, body.constant(377u), 0x01));


   body.instructions = f1AD1_parent_instructions;
   body.emit(f1AD1);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AD4 = equal(r1ABD, body.constant(int(10)));
   ir_if *f1AD3 = new(mem_ctx) ir_if(operand(r1AD4).val);
   exec_list *const f1AD3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AD3->then_instructions;

      body.emit(assign(r1ABE, body.constant(265u), 0x01));


   body.instructions = f1AD3_parent_instructions;
   body.emit(f1AD3);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AD6 = equal(r1ABD, body.constant(int(11)));
   ir_if *f1AD5 = new(mem_ctx) ir_if(operand(r1AD6).val);
   exec_list *const f1AD5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AD5->then_instructions;

      body.emit(assign(r1ABE, body.constant(175u), 0x01));


   body.instructions = f1AD5_parent_instructions;
   body.emit(f1AD5);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AD8 = equal(r1ABD, body.constant(int(12)));
   ir_if *f1AD7 = new(mem_ctx) ir_if(operand(r1AD8).val);
   exec_list *const f1AD7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AD7->then_instructions;

      body.emit(assign(r1ABE, body.constant(104u), 0x01));


   body.instructions = f1AD7_parent_instructions;
   body.emit(f1AD7);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ADA = equal(r1ABD, body.constant(int(13)));
   ir_if *f1AD9 = new(mem_ctx) ir_if(operand(r1ADA).val);
   exec_list *const f1AD9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AD9->then_instructions;

      body.emit(assign(r1ABE, body.constant(52u), 0x01));


   body.instructions = f1AD9_parent_instructions;
   body.emit(f1AD9);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ADC = equal(r1ABD, body.constant(int(14)));
   ir_if *f1ADB = new(mem_ctx) ir_if(operand(r1ADC).val);
   exec_list *const f1ADB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ADB->then_instructions;

      body.emit(assign(r1ABE, body.constant(18u), 0x01));


   body.instructions = f1ADB_parent_instructions;
   body.emit(f1ADB);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ADE = equal(r1ABD, body.constant(int(15)));
   ir_if *f1ADD = new(mem_ctx) ir_if(operand(r1ADE).val);
   exec_list *const f1ADD_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ADD->then_instructions;

      body.emit(assign(r1ABE, body.constant(2u), 0x01));


   body.instructions = f1ADD_parent_instructions;
   body.emit(f1ADD);

   /* END IF */

   body.emit(ret(r1ABE));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
estimateSqrt32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1ADF = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_function_in);
   sig_parameters.push_tail(r1ADF);
   ir_variable *const r1AE0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1AE0);
   ir_variable *const r1AE1 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1AE1, body.constant(true), 0x01));

   ir_variable *const r1AE2 = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1AE3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r1AE3);
   ir_variable *const r1AE4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1AE5 = rshift(r1AE0, body.constant(int(27)));
   ir_expression *const r1AE6 = bit_and(r1AE5, body.constant(15u));
   body.emit(assign(r1AE4, expr(ir_unop_u2i, r1AE6), 0x01));

   /* IF CONDITION */
   ir_expression *const r1AE8 = bit_and(r1ADF, body.constant(int(1)));
   ir_expression *const r1AE9 = nequal(r1AE8, body.constant(int(0)));
   ir_if *f1AE7 = new(mem_ctx) ir_if(operand(r1AE9).val);
   exec_list *const f1AE7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AE7->then_instructions;

      ir_variable *const r1AEA = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
      body.emit(r1AEA);
      body.emit(assign(r1AEA, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1AEC = equal(r1AE4, body.constant(int(0)));
      ir_if *f1AEB = new(mem_ctx) ir_if(operand(r1AEC).val);
      exec_list *const f1AEB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AEB->then_instructions;

         body.emit(assign(r1AEA, body.constant(4u), 0x01));


      body.instructions = f1AEB_parent_instructions;
      body.emit(f1AEB);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AEE = equal(r1AE4, body.constant(int(1)));
      ir_if *f1AED = new(mem_ctx) ir_if(operand(r1AEE).val);
      exec_list *const f1AED_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AED->then_instructions;

         body.emit(assign(r1AEA, body.constant(34u), 0x01));


      body.instructions = f1AED_parent_instructions;
      body.emit(f1AED);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF0 = equal(r1AE4, body.constant(int(2)));
      ir_if *f1AEF = new(mem_ctx) ir_if(operand(r1AF0).val);
      exec_list *const f1AEF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AEF->then_instructions;

         body.emit(assign(r1AEA, body.constant(93u), 0x01));


      body.instructions = f1AEF_parent_instructions;
      body.emit(f1AEF);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF2 = equal(r1AE4, body.constant(int(3)));
      ir_if *f1AF1 = new(mem_ctx) ir_if(operand(r1AF2).val);
      exec_list *const f1AF1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF1->then_instructions;

         body.emit(assign(r1AEA, body.constant(177u), 0x01));


      body.instructions = f1AF1_parent_instructions;
      body.emit(f1AF1);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF4 = equal(r1AE4, body.constant(int(4)));
      ir_if *f1AF3 = new(mem_ctx) ir_if(operand(r1AF4).val);
      exec_list *const f1AF3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF3->then_instructions;

         body.emit(assign(r1AEA, body.constant(285u), 0x01));


      body.instructions = f1AF3_parent_instructions;
      body.emit(f1AF3);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF6 = equal(r1AE4, body.constant(int(5)));
      ir_if *f1AF5 = new(mem_ctx) ir_if(operand(r1AF6).val);
      exec_list *const f1AF5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF5->then_instructions;

         body.emit(assign(r1AEA, body.constant(415u), 0x01));


      body.instructions = f1AF5_parent_instructions;
      body.emit(f1AF5);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF8 = equal(r1AE4, body.constant(int(6)));
      ir_if *f1AF7 = new(mem_ctx) ir_if(operand(r1AF8).val);
      exec_list *const f1AF7_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF7->then_instructions;

         body.emit(assign(r1AEA, body.constant(566u), 0x01));


      body.instructions = f1AF7_parent_instructions;
      body.emit(f1AF7);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AFA = equal(r1AE4, body.constant(int(7)));
      ir_if *f1AF9 = new(mem_ctx) ir_if(operand(r1AFA).val);
      exec_list *const f1AF9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF9->then_instructions;

         body.emit(assign(r1AEA, body.constant(736u), 0x01));


      body.instructions = f1AF9_parent_instructions;
      body.emit(f1AF9);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AFC = equal(r1AE4, body.constant(int(8)));
      ir_if *f1AFB = new(mem_ctx) ir_if(operand(r1AFC).val);
      exec_list *const f1AFB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AFB->then_instructions;

         body.emit(assign(r1AEA, body.constant(924u), 0x01));


      body.instructions = f1AFB_parent_instructions;
      body.emit(f1AFB);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AFE = equal(r1AE4, body.constant(int(9)));
      ir_if *f1AFD = new(mem_ctx) ir_if(operand(r1AFE).val);
      exec_list *const f1AFD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AFD->then_instructions;

         body.emit(assign(r1AEA, body.constant(1128u), 0x01));


      body.instructions = f1AFD_parent_instructions;
      body.emit(f1AFD);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B00 = equal(r1AE4, body.constant(int(10)));
      ir_if *f1AFF = new(mem_ctx) ir_if(operand(r1B00).val);
      exec_list *const f1AFF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AFF->then_instructions;

         body.emit(assign(r1AEA, body.constant(1349u), 0x01));


      body.instructions = f1AFF_parent_instructions;
      body.emit(f1AFF);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B02 = equal(r1AE4, body.constant(int(11)));
      ir_if *f1B01 = new(mem_ctx) ir_if(operand(r1B02).val);
      exec_list *const f1B01_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B01->then_instructions;

         body.emit(assign(r1AEA, body.constant(1585u), 0x01));


      body.instructions = f1B01_parent_instructions;
      body.emit(f1B01);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B04 = equal(r1AE4, body.constant(int(12)));
      ir_if *f1B03 = new(mem_ctx) ir_if(operand(r1B04).val);
      exec_list *const f1B03_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B03->then_instructions;

         body.emit(assign(r1AEA, body.constant(1835u), 0x01));


      body.instructions = f1B03_parent_instructions;
      body.emit(f1B03);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B06 = equal(r1AE4, body.constant(int(13)));
      ir_if *f1B05 = new(mem_ctx) ir_if(operand(r1B06).val);
      exec_list *const f1B05_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B05->then_instructions;

         body.emit(assign(r1AEA, body.constant(2098u), 0x01));


      body.instructions = f1B05_parent_instructions;
      body.emit(f1B05);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B08 = equal(r1AE4, body.constant(int(14)));
      ir_if *f1B07 = new(mem_ctx) ir_if(operand(r1B08).val);
      exec_list *const f1B07_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B07->then_instructions;

         body.emit(assign(r1AEA, body.constant(2374u), 0x01));


      body.instructions = f1B07_parent_instructions;
      body.emit(f1B07);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B0A = equal(r1AE4, body.constant(int(15)));
      ir_if *f1B09 = new(mem_ctx) ir_if(operand(r1B0A).val);
      exec_list *const f1B09_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B09->then_instructions;

         body.emit(assign(r1AEA, body.constant(2663u), 0x01));


      body.instructions = f1B09_parent_instructions;
      body.emit(f1B09);

      /* END IF */

      ir_expression *const r1B0B = rshift(r1AE0, body.constant(int(17)));
      ir_expression *const r1B0C = add(body.constant(16384u), r1B0B);
      body.emit(assign(r1AE3, sub(r1B0C, r1AEA), 0x01));

      ir_expression *const r1B0D = expr(ir_binop_div, r1AE0, r1AE3);
      ir_expression *const r1B0E = lshift(r1B0D, body.constant(int(14)));
      ir_expression *const r1B0F = lshift(r1AE3, body.constant(int(15)));
      body.emit(assign(r1AE3, add(r1B0E, r1B0F), 0x01));

      body.emit(assign(r1AE0, rshift(r1AE0, body.constant(int(1))), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1AE7->else_instructions;

      ir_variable *const r1B10 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
      body.emit(r1B10);
      body.emit(assign(r1B10, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1B12 = equal(r1AE4, body.constant(int(0)));
      ir_if *f1B11 = new(mem_ctx) ir_if(operand(r1B12).val);
      exec_list *const f1B11_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B11->then_instructions;

         body.emit(assign(r1B10, body.constant(2605u), 0x01));


      body.instructions = f1B11_parent_instructions;
      body.emit(f1B11);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B14 = equal(r1AE4, body.constant(int(1)));
      ir_if *f1B13 = new(mem_ctx) ir_if(operand(r1B14).val);
      exec_list *const f1B13_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B13->then_instructions;

         body.emit(assign(r1B10, body.constant(2223u), 0x01));


      body.instructions = f1B13_parent_instructions;
      body.emit(f1B13);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B16 = equal(r1AE4, body.constant(int(2)));
      ir_if *f1B15 = new(mem_ctx) ir_if(operand(r1B16).val);
      exec_list *const f1B15_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B15->then_instructions;

         body.emit(assign(r1B10, body.constant(1882u), 0x01));


      body.instructions = f1B15_parent_instructions;
      body.emit(f1B15);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B18 = equal(r1AE4, body.constant(int(3)));
      ir_if *f1B17 = new(mem_ctx) ir_if(operand(r1B18).val);
      exec_list *const f1B17_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B17->then_instructions;

         body.emit(assign(r1B10, body.constant(1577u), 0x01));


      body.instructions = f1B17_parent_instructions;
      body.emit(f1B17);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B1A = equal(r1AE4, body.constant(int(4)));
      ir_if *f1B19 = new(mem_ctx) ir_if(operand(r1B1A).val);
      exec_list *const f1B19_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B19->then_instructions;

         body.emit(assign(r1B10, body.constant(1306u), 0x01));


      body.instructions = f1B19_parent_instructions;
      body.emit(f1B19);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B1C = equal(r1AE4, body.constant(int(5)));
      ir_if *f1B1B = new(mem_ctx) ir_if(operand(r1B1C).val);
      exec_list *const f1B1B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B1B->then_instructions;

         body.emit(assign(r1B10, body.constant(1065u), 0x01));


      body.instructions = f1B1B_parent_instructions;
      body.emit(f1B1B);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B1E = equal(r1AE4, body.constant(int(6)));
      ir_if *f1B1D = new(mem_ctx) ir_if(operand(r1B1E).val);
      exec_list *const f1B1D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B1D->then_instructions;

         body.emit(assign(r1B10, body.constant(854u), 0x01));


      body.instructions = f1B1D_parent_instructions;
      body.emit(f1B1D);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B20 = equal(r1AE4, body.constant(int(7)));
      ir_if *f1B1F = new(mem_ctx) ir_if(operand(r1B20).val);
      exec_list *const f1B1F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B1F->then_instructions;

         body.emit(assign(r1B10, body.constant(670u), 0x01));


      body.instructions = f1B1F_parent_instructions;
      body.emit(f1B1F);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B22 = equal(r1AE4, body.constant(int(8)));
      ir_if *f1B21 = new(mem_ctx) ir_if(operand(r1B22).val);
      exec_list *const f1B21_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B21->then_instructions;

         body.emit(assign(r1B10, body.constant(512u), 0x01));


      body.instructions = f1B21_parent_instructions;
      body.emit(f1B21);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B24 = equal(r1AE4, body.constant(int(9)));
      ir_if *f1B23 = new(mem_ctx) ir_if(operand(r1B24).val);
      exec_list *const f1B23_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B23->then_instructions;

         body.emit(assign(r1B10, body.constant(377u), 0x01));


      body.instructions = f1B23_parent_instructions;
      body.emit(f1B23);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B26 = equal(r1AE4, body.constant(int(10)));
      ir_if *f1B25 = new(mem_ctx) ir_if(operand(r1B26).val);
      exec_list *const f1B25_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B25->then_instructions;

         body.emit(assign(r1B10, body.constant(265u), 0x01));


      body.instructions = f1B25_parent_instructions;
      body.emit(f1B25);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B28 = equal(r1AE4, body.constant(int(11)));
      ir_if *f1B27 = new(mem_ctx) ir_if(operand(r1B28).val);
      exec_list *const f1B27_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B27->then_instructions;

         body.emit(assign(r1B10, body.constant(175u), 0x01));


      body.instructions = f1B27_parent_instructions;
      body.emit(f1B27);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B2A = equal(r1AE4, body.constant(int(12)));
      ir_if *f1B29 = new(mem_ctx) ir_if(operand(r1B2A).val);
      exec_list *const f1B29_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B29->then_instructions;

         body.emit(assign(r1B10, body.constant(104u), 0x01));


      body.instructions = f1B29_parent_instructions;
      body.emit(f1B29);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B2C = equal(r1AE4, body.constant(int(13)));
      ir_if *f1B2B = new(mem_ctx) ir_if(operand(r1B2C).val);
      exec_list *const f1B2B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B2B->then_instructions;

         body.emit(assign(r1B10, body.constant(52u), 0x01));


      body.instructions = f1B2B_parent_instructions;
      body.emit(f1B2B);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B2E = equal(r1AE4, body.constant(int(14)));
      ir_if *f1B2D = new(mem_ctx) ir_if(operand(r1B2E).val);
      exec_list *const f1B2D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B2D->then_instructions;

         body.emit(assign(r1B10, body.constant(18u), 0x01));


      body.instructions = f1B2D_parent_instructions;
      body.emit(f1B2D);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B30 = equal(r1AE4, body.constant(int(15)));
      ir_if *f1B2F = new(mem_ctx) ir_if(operand(r1B30).val);
      exec_list *const f1B2F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B2F->then_instructions;

         body.emit(assign(r1B10, body.constant(2u), 0x01));


      body.instructions = f1B2F_parent_instructions;
      body.emit(f1B2F);

      /* END IF */

      ir_expression *const r1B31 = rshift(r1AE0, body.constant(int(17)));
      ir_expression *const r1B32 = add(body.constant(32768u), r1B31);
      body.emit(assign(r1AE3, sub(r1B32, r1B10), 0x01));

      ir_expression *const r1B33 = expr(ir_binop_div, r1AE0, r1AE3);
      body.emit(assign(r1AE3, add(r1B33, r1AE3), 0x01));

      ir_variable *const r1B34 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1B36 = lequal(body.constant(131072u), r1AE3);
      ir_if *f1B35 = new(mem_ctx) ir_if(operand(r1B36).val);
      exec_list *const f1B35_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B35->then_instructions;

         body.emit(assign(r1B34, body.constant(4294934528u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1B35->else_instructions;

         body.emit(assign(r1B34, lshift(r1AE3, body.constant(int(15))), 0x01));


      body.instructions = f1B35_parent_instructions;
      body.emit(f1B35);

      /* END IF */

      body.emit(assign(r1AE3, r1B34, 0x01));

      /* IF CONDITION */
      ir_expression *const r1B38 = lequal(r1B34, r1AE0);
      ir_if *f1B37 = new(mem_ctx) ir_if(operand(r1B38).val);
      exec_list *const f1B37_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B37->then_instructions;

         ir_expression *const r1B39 = expr(ir_unop_u2i, r1AE0);
         ir_expression *const r1B3A = rshift(r1B39, body.constant(int(1)));
         body.emit(assign(r1AE2, expr(ir_unop_i2u, r1B3A), 0x01));

         body.emit(assign(r1AE1, body.constant(false), 0x01));


      body.instructions = f1B37_parent_instructions;
      body.emit(f1B37);

      /* END IF */


   body.instructions = f1AE7_parent_instructions;
   body.emit(f1AE7);

   /* END IF */

   /* IF CONDITION */
   ir_if *f1B3B = new(mem_ctx) ir_if(operand(r1AE1).val);
   exec_list *const f1B3B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1B3B->then_instructions;

      ir_variable *const r1B3C = body.make_temp(glsl_type::uint_type, "return_value");
      ir_variable *const r1B3D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
      body.emit(r1B3D);
      ir_variable *const r1B3E = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
      body.emit(r1B3E);
      ir_variable *const r1B3F = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
      body.emit(r1B3F);
      ir_variable *const r1B40 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
      body.emit(r1B40);
      body.emit(assign(r1B3F, body.constant(0u), 0x01));

      body.emit(assign(r1B3E, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1B42 = lequal(r1AE3, r1AE0);
      ir_if *f1B41 = new(mem_ctx) ir_if(operand(r1B42).val);
      exec_list *const f1B41_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B41->then_instructions;

         body.emit(assign(r1B3C, body.constant(4294967295u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1B41->else_instructions;

         body.emit(assign(r1B40, rshift(r1AE3, body.constant(int(16))), 0x01));

         ir_variable *const r1B43 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1B45 = lshift(r1B40, body.constant(int(16)));
         ir_expression *const r1B46 = lequal(r1B45, r1AE0);
         ir_if *f1B44 = new(mem_ctx) ir_if(operand(r1B46).val);
         exec_list *const f1B44_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1B44->then_instructions;

            body.emit(assign(r1B43, body.constant(4294901760u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1B44->else_instructions;

            ir_expression *const r1B47 = expr(ir_binop_div, r1AE0, r1B40);
            body.emit(assign(r1B43, lshift(r1B47, body.constant(int(16))), 0x01));


         body.instructions = f1B44_parent_instructions;
         body.emit(f1B44);

         /* END IF */

         body.emit(assign(r1B3D, r1B43, 0x01));

         ir_variable *const r1B48 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r1B48);
         ir_variable *const r1B49 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
         body.emit(r1B49);
         ir_variable *const r1B4A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r1B4A);
         ir_variable *const r1B4B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B4B, bit_and(r1AE3, body.constant(65535u)), 0x01));

         ir_variable *const r1B4C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B4C, rshift(r1AE3, body.constant(int(16))), 0x01));

         ir_variable *const r1B4D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B4D, bit_and(r1B43, body.constant(65535u)), 0x01));

         ir_variable *const r1B4E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B4E, rshift(r1B43, body.constant(int(16))), 0x01));

         ir_variable *const r1B4F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B4F, mul(r1B4C, r1B4D), 0x01));

         ir_expression *const r1B50 = mul(r1B4B, r1B4E);
         body.emit(assign(r1B49, add(r1B50, r1B4F), 0x01));

         ir_expression *const r1B51 = mul(r1B4C, r1B4E);
         ir_expression *const r1B52 = less(r1B49, r1B4F);
         ir_expression *const r1B53 = expr(ir_unop_b2i, r1B52);
         ir_expression *const r1B54 = expr(ir_unop_i2u, r1B53);
         ir_expression *const r1B55 = lshift(r1B54, body.constant(int(16)));
         ir_expression *const r1B56 = rshift(r1B49, body.constant(int(16)));
         ir_expression *const r1B57 = add(r1B55, r1B56);
         body.emit(assign(r1B48, add(r1B51, r1B57), 0x01));

         body.emit(assign(r1B49, lshift(r1B49, body.constant(int(16))), 0x01));

         ir_expression *const r1B58 = mul(r1B4B, r1B4D);
         body.emit(assign(r1B4A, add(r1B58, r1B49), 0x01));

         ir_expression *const r1B59 = less(r1B4A, r1B49);
         ir_expression *const r1B5A = expr(ir_unop_b2i, r1B59);
         ir_expression *const r1B5B = expr(ir_unop_i2u, r1B5A);
         body.emit(assign(r1B48, add(r1B48, r1B5B), 0x01));

         ir_expression *const r1B5C = sub(r1AE0, r1B48);
         ir_expression *const r1B5D = less(body.constant(0u), r1B4A);
         ir_expression *const r1B5E = expr(ir_unop_b2i, r1B5D);
         ir_expression *const r1B5F = expr(ir_unop_i2u, r1B5E);
         body.emit(assign(r1B3F, sub(r1B5C, r1B5F), 0x01));

         body.emit(assign(r1B3E, neg(r1B4A), 0x01));

         /* LOOP BEGIN */
         ir_loop *f1B60 = new(mem_ctx) ir_loop();
         exec_list *const f1B60_parent_instructions = body.instructions;

            body.instructions = &f1B60->body_instructions;

            /* IF CONDITION */
            ir_expression *const r1B62 = expr(ir_unop_u2i, r1B3F);
            ir_expression *const r1B63 = gequal(r1B62, body.constant(int(0)));
            ir_if *f1B61 = new(mem_ctx) ir_if(operand(r1B63).val);
            exec_list *const f1B61_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1B61->then_instructions;

               body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


            body.instructions = f1B61_parent_instructions;
            body.emit(f1B61);

            /* END IF */

            body.emit(assign(r1B3D, add(r1B3D, body.constant(4294901760u)), 0x01));

            ir_variable *const r1B64 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            ir_expression *const r1B65 = lshift(r1AE3, body.constant(int(16)));
            body.emit(assign(r1B64, add(r1B3E, r1B65), 0x01));

            ir_expression *const r1B66 = add(r1B3F, r1B40);
            ir_expression *const r1B67 = less(r1B64, r1B3E);
            ir_expression *const r1B68 = expr(ir_unop_b2i, r1B67);
            ir_expression *const r1B69 = expr(ir_unop_i2u, r1B68);
            body.emit(assign(r1B3F, add(r1B66, r1B69), 0x01));

            body.emit(assign(r1B3E, r1B64, 0x01));

         /* LOOP END */

         body.instructions = f1B60_parent_instructions;
         body.emit(f1B60);

         ir_expression *const r1B6A = lshift(r1B3F, body.constant(int(16)));
         ir_expression *const r1B6B = rshift(r1B3E, body.constant(int(16)));
         body.emit(assign(r1B3F, bit_or(r1B6A, r1B6B), 0x01));

         ir_variable *const r1B6C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1B6E = lshift(r1B40, body.constant(int(16)));
         ir_expression *const r1B6F = lequal(r1B6E, r1B3F);
         ir_if *f1B6D = new(mem_ctx) ir_if(operand(r1B6F).val);
         exec_list *const f1B6D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1B6D->then_instructions;

            body.emit(assign(r1B6C, body.constant(65535u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1B6D->else_instructions;

            body.emit(assign(r1B6C, expr(ir_binop_div, r1B3F, r1B40), 0x01));


         body.instructions = f1B6D_parent_instructions;
         body.emit(f1B6D);

         /* END IF */

         body.emit(assign(r1B3D, bit_or(r1B3D, r1B6C), 0x01));

         body.emit(assign(r1B3C, r1B3D, 0x01));


      body.instructions = f1B41_parent_instructions;
      body.emit(f1B41);

      /* END IF */

      ir_expression *const r1B70 = rshift(r1B3C, body.constant(int(1)));
      ir_expression *const r1B71 = rshift(r1AE3, body.constant(int(1)));
      body.emit(assign(r1AE2, add(r1B70, r1B71), 0x01));

      body.emit(assign(r1AE1, body.constant(false), 0x01));


   body.instructions = f1B3B_parent_instructions;
   body.emit(f1B3B);

   /* END IF */

   body.emit(ret(r1AE2));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fsqrt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1B72 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1B72);
   ir_variable *const r1B73 = body.make_temp(glsl_type::float_type, "return_value");
   ir_variable *const r1B74 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_auto);
   body.emit(r1B74);
   body.emit(assign(r1B74, body.constant(0u), 0x01));

   ir_variable *const r1B75 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1B75, bit_and(swizzle_y(r1B72), body.constant(1048575u)), 0x01));

   ir_variable *const r1B76 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1B77 = rshift(swizzle_y(r1B72), body.constant(int(20)));
   ir_expression *const r1B78 = bit_and(r1B77, body.constant(2047u));
   body.emit(assign(r1B76, expr(ir_unop_u2i, r1B78), 0x01));

   ir_variable *const r1B79 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r1B79, rshift(swizzle_y(r1B72), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1B7B = equal(r1B76, body.constant(int(2047)));
   ir_if *f1B7A = new(mem_ctx) ir_if(operand(r1B7B).val);
   exec_list *const f1B7A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1B7A->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1B7D = bit_or(r1B75, swizzle_x(r1B72));
      ir_expression *const r1B7E = nequal(r1B7D, body.constant(0u));
      ir_if *f1B7C = new(mem_ctx) ir_if(operand(r1B7E).val);
      exec_list *const f1B7C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B7C->then_instructions;

         ir_variable *const r1B7F = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1B7F, lshift(swizzle_x(r1B72), body.constant(int(12))), 0x01));

         ir_expression *const r1B80 = lshift(r1B79, body.constant(int(31)));
         ir_expression *const r1B81 = bit_or(r1B80, body.constant(2143289344u));
         ir_expression *const r1B82 = lshift(swizzle_y(r1B72), body.constant(int(12)));
         ir_expression *const r1B83 = rshift(swizzle_x(r1B72), body.constant(int(20)));
         ir_expression *const r1B84 = bit_or(r1B82, r1B83);
         ir_expression *const r1B85 = rshift(r1B84, body.constant(int(9)));
         ir_expression *const r1B86 = bit_or(r1B81, r1B85);
         body.emit(assign(r1B73, expr(ir_unop_bitcast_u2f, r1B86), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1B7C->else_instructions;

         ir_expression *const r1B87 = lshift(r1B79, body.constant(int(31)));
         ir_expression *const r1B88 = add(r1B87, body.constant(2139095040u));
         body.emit(assign(r1B73, expr(ir_unop_bitcast_u2f, r1B88), 0x01));


      body.instructions = f1B7C_parent_instructions;
      body.emit(f1B7C);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1B7A->else_instructions;

      ir_variable *const r1B89 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r1B89);
      ir_variable *const r1B8A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r1B8A);
      ir_expression *const r1B8B = lshift(r1B75, body.constant(int(10)));
      ir_expression *const r1B8C = rshift(swizzle_x(r1B72), body.constant(int(22)));
      ir_expression *const r1B8D = bit_or(r1B8B, r1B8C);
      ir_expression *const r1B8E = lshift(swizzle_x(r1B72), body.constant(int(10)));
      ir_expression *const r1B8F = nequal(r1B8E, body.constant(0u));
      ir_expression *const r1B90 = expr(ir_unop_b2i, r1B8F);
      ir_expression *const r1B91 = expr(ir_unop_i2u, r1B90);
      body.emit(assign(r1B89, bit_or(r1B8D, r1B91), 0x01));

      body.emit(assign(r1B8A, rshift(r1B75, body.constant(int(22))), 0x01));

      body.emit(assign(r1B74, r1B89, 0x01));

      /* IF CONDITION */
      ir_expression *const r1B93 = nequal(r1B76, body.constant(int(0)));
      ir_if *f1B92 = new(mem_ctx) ir_if(operand(r1B93).val);
      exec_list *const f1B92_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B92->then_instructions;

         body.emit(assign(r1B74, bit_or(r1B89, body.constant(1073741824u)), 0x01));


      body.instructions = f1B92_parent_instructions;
      body.emit(f1B92);

      /* END IF */

      ir_variable *const r1B94 = body.make_temp(glsl_type::int_type, "zExp");
      body.emit(assign(r1B94, add(r1B76, body.constant(int(-897))), 0x01));

      ir_variable *const r1B95 = body.make_temp(glsl_type::uint_type, "zFrac");
      body.emit(assign(r1B95, r1B74, 0x01));

      ir_variable *const r1B96 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r1B96, body.constant(true), 0x01));

      ir_variable *const r1B97 = body.make_temp(glsl_type::uint_type, "return_value");
      ir_variable *const r1B98 = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
      body.emit(r1B98);
      ir_expression *const r1B99 = expr(ir_unop_u2i, r1B74);
      body.emit(assign(r1B98, bit_and(r1B99, body.constant(int(127))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1B9B = expr(ir_unop_i2u, r1B94);
      ir_expression *const r1B9C = lequal(body.constant(253u), r1B9B);
      ir_if *f1B9A = new(mem_ctx) ir_if(operand(r1B9C).val);
      exec_list *const f1B9A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B9A->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1B9E = less(body.constant(int(253)), r1B94);
         ir_expression *const r1B9F = equal(r1B94, body.constant(int(253)));
         ir_expression *const r1BA0 = add(r1B74, body.constant(64u));
         ir_expression *const r1BA1 = expr(ir_unop_u2i, r1BA0);
         ir_expression *const r1BA2 = less(r1BA1, body.constant(int(0)));
         ir_expression *const r1BA3 = logic_and(r1B9F, r1BA2);
         ir_expression *const r1BA4 = logic_or(r1B9E, r1BA3);
         ir_if *f1B9D = new(mem_ctx) ir_if(operand(r1BA4).val);
         exec_list *const f1B9D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1B9D->then_instructions;

            ir_expression *const r1BA5 = lshift(r1B79, body.constant(int(31)));
            body.emit(assign(r1B97, add(r1BA5, body.constant(2139095040u)), 0x01));

            body.emit(assign(r1B96, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1B9D->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1BA7 = less(r1B94, body.constant(int(0)));
            ir_if *f1BA6 = new(mem_ctx) ir_if(operand(r1BA7).val);
            exec_list *const f1BA6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1BA6->then_instructions;

               ir_variable *const r1BA8 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r1BA8, neg(r1B94), 0x01));

               ir_variable *const r1BA9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r1BA9);
               /* IF CONDITION */
               ir_expression *const r1BAB = equal(r1BA8, body.constant(int(0)));
               ir_if *f1BAA = new(mem_ctx) ir_if(operand(r1BAB).val);
               exec_list *const f1BAA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BAA->then_instructions;

                  body.emit(assign(r1BA9, r1B74, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1BAA->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1BAD = less(r1BA8, body.constant(int(32)));
                  ir_if *f1BAC = new(mem_ctx) ir_if(operand(r1BAD).val);
                  exec_list *const f1BAC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1BAC->then_instructions;

                     ir_expression *const r1BAE = rshift(r1B74, r1BA8);
                     ir_expression *const r1BAF = neg(r1BA8);
                     ir_expression *const r1BB0 = bit_and(r1BAF, body.constant(int(31)));
                     ir_expression *const r1BB1 = lshift(r1B74, r1BB0);
                     ir_expression *const r1BB2 = nequal(r1BB1, body.constant(0u));
                     ir_expression *const r1BB3 = expr(ir_unop_b2i, r1BB2);
                     ir_expression *const r1BB4 = expr(ir_unop_i2u, r1BB3);
                     body.emit(assign(r1BA9, bit_or(r1BAE, r1BB4), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1BAC->else_instructions;

                     ir_expression *const r1BB5 = nequal(r1B74, body.constant(0u));
                     ir_expression *const r1BB6 = expr(ir_unop_b2i, r1BB5);
                     body.emit(assign(r1BA9, expr(ir_unop_i2u, r1BB6), 0x01));


                  body.instructions = f1BAC_parent_instructions;
                  body.emit(f1BAC);

                  /* END IF */


               body.instructions = f1BAA_parent_instructions;
               body.emit(f1BAA);

               /* END IF */

               body.emit(assign(r1B95, r1BA9, 0x01));

               body.emit(assign(r1B94, body.constant(int(0)), 0x01));

               ir_expression *const r1BB7 = expr(ir_unop_u2i, r1BA9);
               body.emit(assign(r1B98, bit_and(r1BB7, body.constant(int(127))), 0x01));


            body.instructions = f1BA6_parent_instructions;
            body.emit(f1BA6);

            /* END IF */


         body.instructions = f1B9D_parent_instructions;
         body.emit(f1B9D);

         /* END IF */


      body.instructions = f1B9A_parent_instructions;
      body.emit(f1B9A);

      /* END IF */

      /* IF CONDITION */
      ir_if *f1BB8 = new(mem_ctx) ir_if(operand(r1B96).val);
      exec_list *const f1BB8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1BB8->then_instructions;

         ir_expression *const r1BB9 = add(r1B95, body.constant(64u));
         body.emit(assign(r1B95, rshift(r1BB9, body.constant(int(7))), 0x01));

         ir_expression *const r1BBA = bit_xor(r1B98, body.constant(int(64)));
         ir_expression *const r1BBB = equal(r1BBA, body.constant(int(0)));
         ir_expression *const r1BBC = expr(ir_unop_b2i, r1BBB);
         ir_expression *const r1BBD = expr(ir_unop_i2u, r1BBC);
         ir_expression *const r1BBE = bit_and(r1BBD, body.constant(1u));
         ir_expression *const r1BBF = expr(ir_unop_bit_not, r1BBE);
         body.emit(assign(r1B95, bit_and(r1B95, r1BBF), 0x01));

         /* IF CONDITION */
         ir_expression *const r1BC1 = equal(r1B95, body.constant(0u));
         ir_if *f1BC0 = new(mem_ctx) ir_if(operand(r1BC1).val);
         exec_list *const f1BC0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BC0->then_instructions;

            body.emit(assign(r1B94, body.constant(int(0)), 0x01));


         body.instructions = f1BC0_parent_instructions;
         body.emit(f1BC0);

         /* END IF */

         ir_expression *const r1BC2 = lshift(r1B79, body.constant(int(31)));
         ir_expression *const r1BC3 = expr(ir_unop_i2u, r1B94);
         ir_expression *const r1BC4 = lshift(r1BC3, body.constant(int(23)));
         ir_expression *const r1BC5 = add(r1BC2, r1BC4);
         body.emit(assign(r1B97, add(r1BC5, r1B95), 0x01));

         body.emit(assign(r1B96, body.constant(false), 0x01));


      body.instructions = f1BB8_parent_instructions;
      body.emit(f1BB8);

      /* END IF */

      body.emit(assign(r1B73, expr(ir_unop_bitcast_u2f, r1B97), 0x01));


   body.instructions = f1B7A_parent_instructions;
   body.emit(f1B7A);

   /* END IF */

   ir_variable *const r1BC6 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1BC6, body.constant(true), 0x01));

   ir_variable *const r1BC7 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1BC8 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r1BC8);
   ir_variable *const r1BC9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_auto);
   body.emit(r1BC9);
   ir_variable *const r1BCA = body.make_temp(glsl_type::uint_type, "floatBitsToUint_retval");
   ir_expression *const r1BCB = expr(ir_unop_sqrt, r1B73);
   body.emit(assign(r1BCA, expr(ir_unop_bitcast_f2u, r1BCB), 0x01));

   ir_variable *const r1BCC = body.make_temp(glsl_type::uint_type, "extractFloat32Frac_retval");
   body.emit(assign(r1BCC, bit_and(r1BCA, body.constant(8388607u)), 0x01));

   body.emit(assign(r1BC9, r1BCC, 0x01));

   ir_variable *const r1BCD = body.make_temp(glsl_type::int_type, "extractFloat32Exp_retval");
   ir_expression *const r1BCE = rshift(r1BCA, body.constant(int(23)));
   ir_expression *const r1BCF = bit_and(r1BCE, body.constant(255u));
   body.emit(assign(r1BCD, expr(ir_unop_u2i, r1BCF), 0x01));

   body.emit(assign(r1BC8, r1BCD, 0x01));

   ir_variable *const r1BD0 = body.make_temp(glsl_type::uint_type, "extractFloat32Sign_retval");
   body.emit(assign(r1BD0, rshift(r1BCA, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1BD2 = equal(r1BCD, body.constant(int(255)));
   ir_if *f1BD1 = new(mem_ctx) ir_if(operand(r1BD2).val);
   exec_list *const f1BD1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1BD1->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1BD4 = nequal(r1BCC, body.constant(0u));
      ir_if *f1BD3 = new(mem_ctx) ir_if(operand(r1BD4).val);
      exec_list *const f1BD3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1BD3->then_instructions;

         ir_variable *const r1BD5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1BD5, lshift(r1BCA, body.constant(int(9))), 0x01));

         ir_variable *const r1BD6 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         ir_expression *const r1BD7 = lshift(r1BD5, body.constant(int(20)));
         body.emit(assign(r1BD6, bit_or(r1BD7, body.constant(0u)), 0x01));

         ir_expression *const r1BD8 = rshift(r1BD5, body.constant(int(12)));
         ir_expression *const r1BD9 = lshift(r1BD0, body.constant(int(31)));
         ir_expression *const r1BDA = bit_or(r1BD9, body.constant(2146959360u));
         body.emit(assign(r1BD6, bit_or(r1BD8, r1BDA), 0x02));

         body.emit(assign(r1BC7, r1BD6, 0x03));

         body.emit(assign(r1BC6, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1BD3->else_instructions;

         ir_variable *const r1BDB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1BDB);
         ir_expression *const r1BDC = lshift(r1BD0, body.constant(int(31)));
         body.emit(assign(r1BDB, add(r1BDC, body.constant(2146435072u)), 0x02));

         body.emit(assign(r1BDB, body.constant(0u), 0x01));

         body.emit(assign(r1BC7, r1BDB, 0x03));

         body.emit(assign(r1BC6, body.constant(false), 0x01));


      body.instructions = f1BD3_parent_instructions;
      body.emit(f1BD3);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1BD1->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1BDE = equal(r1BCD, body.constant(int(0)));
      ir_if *f1BDD = new(mem_ctx) ir_if(operand(r1BDE).val);
      exec_list *const f1BDD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1BDD->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1BE0 = equal(r1BCC, body.constant(0u));
         ir_if *f1BDF = new(mem_ctx) ir_if(operand(r1BE0).val);
         exec_list *const f1BDF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BDF->then_instructions;

            ir_variable *const r1BE1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r1BE1);
            body.emit(assign(r1BE1, lshift(r1BD0, body.constant(int(31))), 0x02));

            body.emit(assign(r1BE1, body.constant(0u), 0x01));

            body.emit(assign(r1BC7, r1BE1, 0x03));

            body.emit(assign(r1BC6, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1BDF->else_instructions;

            ir_variable *const r1BE2 = body.make_temp(glsl_type::int_type, "zExpPtr");
            body.emit(assign(r1BE2, r1BCD, 0x01));

            ir_variable *const r1BE3 = body.make_temp(glsl_type::uint_type, "zFracPtr");
            body.emit(assign(r1BE3, r1BCC, 0x01));

            ir_variable *const r1BE4 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r1BE4, r1BCC, 0x01));

            ir_variable *const r1BE5 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r1BE6 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r1BE6);
            /* IF CONDITION */
            ir_expression *const r1BE8 = equal(r1BCC, body.constant(0u));
            ir_if *f1BE7 = new(mem_ctx) ir_if(operand(r1BE8).val);
            exec_list *const f1BE7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1BE7->then_instructions;

               body.emit(assign(r1BE5, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1BE7->else_instructions;

               body.emit(assign(r1BE6, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r1BEA = bit_and(r1BCC, body.constant(4294901760u));
               ir_expression *const r1BEB = equal(r1BEA, body.constant(0u));
               ir_if *f1BE9 = new(mem_ctx) ir_if(operand(r1BEB).val);
               exec_list *const f1BE9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BE9->then_instructions;

                  body.emit(assign(r1BE6, body.constant(int(16)), 0x01));

                  body.emit(assign(r1BE4, lshift(r1BCC, body.constant(int(16))), 0x01));


               body.instructions = f1BE9_parent_instructions;
               body.emit(f1BE9);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1BED = bit_and(r1BE4, body.constant(4278190080u));
               ir_expression *const r1BEE = equal(r1BED, body.constant(0u));
               ir_if *f1BEC = new(mem_ctx) ir_if(operand(r1BEE).val);
               exec_list *const f1BEC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BEC->then_instructions;

                  body.emit(assign(r1BE6, add(r1BE6, body.constant(int(8))), 0x01));

                  body.emit(assign(r1BE4, lshift(r1BE4, body.constant(int(8))), 0x01));


               body.instructions = f1BEC_parent_instructions;
               body.emit(f1BEC);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1BF0 = bit_and(r1BE4, body.constant(4026531840u));
               ir_expression *const r1BF1 = equal(r1BF0, body.constant(0u));
               ir_if *f1BEF = new(mem_ctx) ir_if(operand(r1BF1).val);
               exec_list *const f1BEF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BEF->then_instructions;

                  body.emit(assign(r1BE6, add(r1BE6, body.constant(int(4))), 0x01));

                  body.emit(assign(r1BE4, lshift(r1BE4, body.constant(int(4))), 0x01));


               body.instructions = f1BEF_parent_instructions;
               body.emit(f1BEF);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1BF3 = bit_and(r1BE4, body.constant(3221225472u));
               ir_expression *const r1BF4 = equal(r1BF3, body.constant(0u));
               ir_if *f1BF2 = new(mem_ctx) ir_if(operand(r1BF4).val);
               exec_list *const f1BF2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BF2->then_instructions;

                  body.emit(assign(r1BE6, add(r1BE6, body.constant(int(2))), 0x01));

                  body.emit(assign(r1BE4, lshift(r1BE4, body.constant(int(2))), 0x01));


               body.instructions = f1BF2_parent_instructions;
               body.emit(f1BF2);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1BF6 = bit_and(r1BE4, body.constant(2147483648u));
               ir_expression *const r1BF7 = equal(r1BF6, body.constant(0u));
               ir_if *f1BF5 = new(mem_ctx) ir_if(operand(r1BF7).val);
               exec_list *const f1BF5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BF5->then_instructions;

                  body.emit(assign(r1BE6, add(r1BE6, body.constant(int(1))), 0x01));


               body.instructions = f1BF5_parent_instructions;
               body.emit(f1BF5);

               /* END IF */

               body.emit(assign(r1BE5, r1BE6, 0x01));


            body.instructions = f1BE7_parent_instructions;
            body.emit(f1BE7);

            /* END IF */

            ir_variable *const r1BF8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            body.emit(assign(r1BF8, add(r1BE5, body.constant(int(-8))), 0x01));

            body.emit(assign(r1BE3, lshift(r1BCC, r1BF8), 0x01));

            body.emit(assign(r1BE2, sub(body.constant(int(1)), r1BF8), 0x01));

            body.emit(assign(r1BC9, r1BE3, 0x01));

            body.emit(assign(r1BC8, add(r1BE2, body.constant(int(-1))), 0x01));


         body.instructions = f1BDF_parent_instructions;
         body.emit(f1BDF);

         /* END IF */


      body.instructions = f1BDD_parent_instructions;
      body.emit(f1BDD);

      /* END IF */

      /* IF CONDITION */
      ir_if *f1BF9 = new(mem_ctx) ir_if(operand(r1BC6).val);
      exec_list *const f1BF9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1BF9->then_instructions;

         ir_variable *const r1BFA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1BFA);
         ir_expression *const r1BFB = lshift(r1BD0, body.constant(int(31)));
         ir_expression *const r1BFC = add(r1BC8, body.constant(int(896)));
         ir_expression *const r1BFD = expr(ir_unop_i2u, r1BFC);
         ir_expression *const r1BFE = lshift(r1BFD, body.constant(int(20)));
         ir_expression *const r1BFF = add(r1BFB, r1BFE);
         ir_expression *const r1C00 = rshift(r1BC9, body.constant(int(3)));
         body.emit(assign(r1BFA, add(r1BFF, r1C00), 0x02));

         ir_expression *const r1C01 = lshift(r1BC9, body.constant(int(29)));
         body.emit(assign(r1BFA, bit_or(r1C01, body.constant(0u)), 0x01));

         body.emit(assign(r1BC7, r1BFA, 0x03));

         body.emit(assign(r1BC6, body.constant(false), 0x01));


      body.instructions = f1BF9_parent_instructions;
      body.emit(f1BF9);

      /* END IF */


   body.instructions = f1BD1_parent_instructions;
   body.emit(f1BD1);

   /* END IF */

   body.emit(ret(r1BC7));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64Left(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1C02 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1C02);
   ir_variable *const r1C03 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1C03);
   ir_variable *const r1C04 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r1C04);
   ir_variable *const r1C05 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1C05);
   ir_variable *const r1C06 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1C06);
   ir_variable *const r1C07 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1C07);
   ir_variable *const r1C08 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1C08);
   ir_variable *const r1C09 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1C0A = neg(r1C04);
   body.emit(assign(r1C09, bit_and(r1C0A, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1C0C = equal(r1C04, body.constant(int(0)));
   ir_if *f1C0B = new(mem_ctx) ir_if(operand(r1C0C).val);
   exec_list *const f1C0B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1C0B->then_instructions;

      body.emit(assign(r1C08, r1C02, 0x01));

      body.emit(assign(r1C07, r1C03, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1C0B->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1C0E = less(r1C04, body.constant(int(32)));
      ir_if *f1C0D = new(mem_ctx) ir_if(operand(r1C0E).val);
      exec_list *const f1C0D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1C0D->then_instructions;

         ir_expression *const r1C0F = lshift(r1C02, r1C04);
         ir_expression *const r1C10 = rshift(r1C03, r1C09);
         body.emit(assign(r1C08, bit_or(r1C0F, r1C10), 0x01));

         body.emit(assign(r1C07, lshift(r1C03, r1C04), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1C0D->else_instructions;

         ir_variable *const r1C11 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1C13 = less(r1C04, body.constant(int(64)));
         ir_if *f1C12 = new(mem_ctx) ir_if(operand(r1C13).val);
         exec_list *const f1C12_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C12->then_instructions;

            ir_expression *const r1C14 = add(r1C04, body.constant(int(-32)));
            body.emit(assign(r1C11, lshift(r1C03, r1C14), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C12->else_instructions;

            body.emit(assign(r1C11, body.constant(0u), 0x01));


         body.instructions = f1C12_parent_instructions;
         body.emit(f1C12);

         /* END IF */

         body.emit(assign(r1C08, r1C11, 0x01));

         body.emit(assign(r1C07, body.constant(0u), 0x01));


      body.instructions = f1C0D_parent_instructions;
      body.emit(f1C0D);

      /* END IF */


   body.instructions = f1C0B_parent_instructions;
   body.emit(f1C0B);

   /* END IF */

   body.emit(assign(r1C05, r1C08, 0x01));

   body.emit(assign(r1C06, r1C07, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
uint_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1C15 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1C15);
   ir_variable *const r1C16 = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r1C18 = equal(r1C15, body.constant(0u));
   ir_if *f1C17 = new(mem_ctx) ir_if(operand(r1C18).val);
   exec_list *const f1C17_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1C17->then_instructions;

      body.emit(assign(r1C16, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1C17->else_instructions;

      ir_variable *const r1C19 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1C19, r1C15, 0x01));

      ir_variable *const r1C1A = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1C1B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1C1B);
      /* IF CONDITION */
      ir_expression *const r1C1D = equal(r1C15, body.constant(0u));
      ir_if *f1C1C = new(mem_ctx) ir_if(operand(r1C1D).val);
      exec_list *const f1C1C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1C1C->then_instructions;

         body.emit(assign(r1C1A, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1C1C->else_instructions;

         body.emit(assign(r1C1B, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1C1F = bit_and(r1C15, body.constant(4294901760u));
         ir_expression *const r1C20 = equal(r1C1F, body.constant(0u));
         ir_if *f1C1E = new(mem_ctx) ir_if(operand(r1C20).val);
         exec_list *const f1C1E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C1E->then_instructions;

            body.emit(assign(r1C1B, body.constant(int(16)), 0x01));

            body.emit(assign(r1C19, lshift(r1C15, body.constant(int(16))), 0x01));


         body.instructions = f1C1E_parent_instructions;
         body.emit(f1C1E);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1C22 = bit_and(r1C19, body.constant(4278190080u));
         ir_expression *const r1C23 = equal(r1C22, body.constant(0u));
         ir_if *f1C21 = new(mem_ctx) ir_if(operand(r1C23).val);
         exec_list *const f1C21_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C21->then_instructions;

            body.emit(assign(r1C1B, add(r1C1B, body.constant(int(8))), 0x01));

            body.emit(assign(r1C19, lshift(r1C19, body.constant(int(8))), 0x01));


         body.instructions = f1C21_parent_instructions;
         body.emit(f1C21);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1C25 = bit_and(r1C19, body.constant(4026531840u));
         ir_expression *const r1C26 = equal(r1C25, body.constant(0u));
         ir_if *f1C24 = new(mem_ctx) ir_if(operand(r1C26).val);
         exec_list *const f1C24_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C24->then_instructions;

            body.emit(assign(r1C1B, add(r1C1B, body.constant(int(4))), 0x01));

            body.emit(assign(r1C19, lshift(r1C19, body.constant(int(4))), 0x01));


         body.instructions = f1C24_parent_instructions;
         body.emit(f1C24);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1C28 = bit_and(r1C19, body.constant(3221225472u));
         ir_expression *const r1C29 = equal(r1C28, body.constant(0u));
         ir_if *f1C27 = new(mem_ctx) ir_if(operand(r1C29).val);
         exec_list *const f1C27_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C27->then_instructions;

            body.emit(assign(r1C1B, add(r1C1B, body.constant(int(2))), 0x01));

            body.emit(assign(r1C19, lshift(r1C19, body.constant(int(2))), 0x01));


         body.instructions = f1C27_parent_instructions;
         body.emit(f1C27);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1C2B = bit_and(r1C19, body.constant(2147483648u));
         ir_expression *const r1C2C = equal(r1C2B, body.constant(0u));
         ir_if *f1C2A = new(mem_ctx) ir_if(operand(r1C2C).val);
         exec_list *const f1C2A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C2A->then_instructions;

            body.emit(assign(r1C1B, add(r1C1B, body.constant(int(1))), 0x01));


         body.instructions = f1C2A_parent_instructions;
         body.emit(f1C2A);

         /* END IF */

         body.emit(assign(r1C1A, r1C1B, 0x01));


      body.instructions = f1C1C_parent_instructions;
      body.emit(f1C1C);

      /* END IF */

      ir_variable *const r1C2D = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r1C2D, add(r1C1A, body.constant(int(21))), 0x01));

      ir_variable *const r1C2E = body.make_temp(glsl_type::uint_type, "a0");
      body.emit(assign(r1C2E, body.constant(0u), 0x01));

      ir_variable *const r1C2F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r1C2F);
      ir_variable *const r1C30 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r1C30);
      ir_variable *const r1C31 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      ir_expression *const r1C32 = neg(r1C2D);
      body.emit(assign(r1C31, bit_and(r1C32, body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1C34 = equal(r1C2D, body.constant(int(0)));
      ir_if *f1C33 = new(mem_ctx) ir_if(operand(r1C34).val);
      exec_list *const f1C33_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1C33->then_instructions;

         body.emit(assign(r1C30, body.constant(0u), 0x01));

         body.emit(assign(r1C2F, r1C15, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1C33->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1C36 = less(r1C2D, body.constant(int(32)));
         ir_if *f1C35 = new(mem_ctx) ir_if(operand(r1C36).val);
         exec_list *const f1C35_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C35->then_instructions;

            ir_expression *const r1C37 = rshift(r1C15, r1C31);
            body.emit(assign(r1C30, bit_or(body.constant(0u), r1C37), 0x01));

            body.emit(assign(r1C2F, lshift(r1C15, r1C2D), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C35->else_instructions;

            ir_variable *const r1C38 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1C3A = less(r1C2D, body.constant(int(64)));
            ir_if *f1C39 = new(mem_ctx) ir_if(operand(r1C3A).val);
            exec_list *const f1C39_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C39->then_instructions;

               ir_expression *const r1C3B = add(r1C2D, body.constant(int(-32)));
               body.emit(assign(r1C38, lshift(r1C15, r1C3B), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1C39->else_instructions;

               body.emit(assign(r1C38, body.constant(0u), 0x01));


            body.instructions = f1C39_parent_instructions;
            body.emit(f1C39);

            /* END IF */

            body.emit(assign(r1C30, r1C38, 0x01));

            body.emit(assign(r1C2F, body.constant(0u), 0x01));


         body.instructions = f1C35_parent_instructions;
         body.emit(f1C35);

         /* END IF */


      body.instructions = f1C33_parent_instructions;
      body.emit(f1C33);

      /* END IF */

      ir_variable *const r1C3C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1C3C);
      ir_expression *const r1C3D = sub(body.constant(int(1074)), r1C2D);
      ir_expression *const r1C3E = expr(ir_unop_i2u, r1C3D);
      ir_expression *const r1C3F = lshift(r1C3E, body.constant(int(20)));
      body.emit(assign(r1C3C, add(r1C3F, r1C30), 0x02));

      body.emit(assign(r1C3C, r1C2F, 0x01));

      body.emit(assign(r1C16, r1C3C, 0x03));


   body.instructions = f1C17_parent_instructions;
   body.emit(f1C17);

   /* END IF */

   body.emit(ret(r1C16));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_uint(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1C40 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1C40);
   ir_variable *const r1C41 = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1C42 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r1C42);
   ir_variable *const r1C43 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r1C43);
   ir_variable *const r1C44 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r1C44, swizzle_x(r1C40), 0x01));

   body.emit(assign(r1C43, r1C44, 0x01));

   ir_variable *const r1C45 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1C45, bit_and(swizzle_y(r1C40), body.constant(1048575u)), 0x01));

   body.emit(assign(r1C42, r1C45, 0x01));

   ir_variable *const r1C46 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1C47 = rshift(swizzle_y(r1C40), body.constant(int(20)));
   ir_expression *const r1C48 = bit_and(r1C47, body.constant(2047u));
   body.emit(assign(r1C46, expr(ir_unop_u2i, r1C48), 0x01));

   ir_variable *const r1C49 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r1C49, rshift(swizzle_y(r1C40), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1C4B = nequal(r1C49, body.constant(0u));
   ir_if *f1C4A = new(mem_ctx) ir_if(operand(r1C4B).val);
   exec_list *const f1C4A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1C4A->then_instructions;

      body.emit(assign(r1C41, body.constant(0u), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1C4A->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1C4D = equal(r1C46, body.constant(int(2047)));
      ir_expression *const r1C4E = bit_or(r1C45, swizzle_x(r1C40));
      ir_expression *const r1C4F = nequal(r1C4E, body.constant(0u));
      ir_expression *const r1C50 = logic_and(r1C4D, r1C4F);
      ir_if *f1C4C = new(mem_ctx) ir_if(operand(r1C50).val);
      exec_list *const f1C4C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1C4C->then_instructions;

         body.emit(assign(r1C41, body.constant(4294967295u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1C4C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1C52 = nequal(r1C46, body.constant(int(0)));
         ir_if *f1C51 = new(mem_ctx) ir_if(operand(r1C52).val);
         exec_list *const f1C51_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C51->then_instructions;

            body.emit(assign(r1C42, bit_or(r1C45, body.constant(1048576u)), 0x01));


         body.instructions = f1C51_parent_instructions;
         body.emit(f1C51);

         /* END IF */

         ir_variable *const r1C53 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1C53, sub(body.constant(int(1063)), r1C46), 0x01));

         /* IF CONDITION */
         ir_expression *const r1C55 = less(body.constant(int(0)), r1C53);
         ir_if *f1C54 = new(mem_ctx) ir_if(operand(r1C55).val);
         exec_list *const f1C54_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C54->then_instructions;

            ir_variable *const r1C56 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1C56);
            ir_variable *const r1C57 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r1C57);
            ir_variable *const r1C58 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r1C59 = neg(r1C53);
            body.emit(assign(r1C58, bit_and(r1C59, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1C5B = equal(r1C53, body.constant(int(0)));
            ir_if *f1C5A = new(mem_ctx) ir_if(operand(r1C5B).val);
            exec_list *const f1C5A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C5A->then_instructions;

               body.emit(assign(r1C56, r1C44, 0x01));

               body.emit(assign(r1C57, r1C42, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1C5A->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1C5D = less(r1C53, body.constant(int(32)));
               ir_if *f1C5C = new(mem_ctx) ir_if(operand(r1C5D).val);
               exec_list *const f1C5C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C5C->then_instructions;

                  ir_expression *const r1C5E = lshift(r1C42, r1C58);
                  ir_expression *const r1C5F = rshift(swizzle_x(r1C40), r1C53);
                  ir_expression *const r1C60 = bit_or(r1C5E, r1C5F);
                  ir_expression *const r1C61 = lshift(swizzle_x(r1C40), r1C58);
                  ir_expression *const r1C62 = nequal(r1C61, body.constant(0u));
                  ir_expression *const r1C63 = expr(ir_unop_b2i, r1C62);
                  ir_expression *const r1C64 = expr(ir_unop_i2u, r1C63);
                  body.emit(assign(r1C56, bit_or(r1C60, r1C64), 0x01));

                  body.emit(assign(r1C57, rshift(r1C42, r1C53), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1C5C->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1C66 = equal(r1C53, body.constant(int(32)));
                  ir_if *f1C65 = new(mem_ctx) ir_if(operand(r1C66).val);
                  exec_list *const f1C65_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C65->then_instructions;

                     ir_expression *const r1C67 = nequal(swizzle_x(r1C40), body.constant(0u));
                     ir_expression *const r1C68 = expr(ir_unop_b2i, r1C67);
                     ir_expression *const r1C69 = expr(ir_unop_i2u, r1C68);
                     body.emit(assign(r1C56, bit_or(r1C42, r1C69), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1C65->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1C6B = less(r1C53, body.constant(int(64)));
                     ir_if *f1C6A = new(mem_ctx) ir_if(operand(r1C6B).val);
                     exec_list *const f1C6A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1C6A->then_instructions;

                        ir_expression *const r1C6C = bit_and(r1C53, body.constant(int(31)));
                        ir_expression *const r1C6D = rshift(r1C42, r1C6C);
                        ir_expression *const r1C6E = lshift(r1C42, r1C58);
                        ir_expression *const r1C6F = bit_or(r1C6E, swizzle_x(r1C40));
                        ir_expression *const r1C70 = nequal(r1C6F, body.constant(0u));
                        ir_expression *const r1C71 = expr(ir_unop_b2i, r1C70);
                        ir_expression *const r1C72 = expr(ir_unop_i2u, r1C71);
                        body.emit(assign(r1C56, bit_or(r1C6D, r1C72), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1C6A->else_instructions;

                        ir_expression *const r1C73 = bit_or(r1C42, swizzle_x(r1C40));
                        ir_expression *const r1C74 = nequal(r1C73, body.constant(0u));
                        ir_expression *const r1C75 = expr(ir_unop_b2i, r1C74);
                        body.emit(assign(r1C56, expr(ir_unop_i2u, r1C75), 0x01));


                     body.instructions = f1C6A_parent_instructions;
                     body.emit(f1C6A);

                     /* END IF */


                  body.instructions = f1C65_parent_instructions;
                  body.emit(f1C65);

                  /* END IF */

                  body.emit(assign(r1C57, body.constant(0u), 0x01));


               body.instructions = f1C5C_parent_instructions;
               body.emit(f1C5C);

               /* END IF */


            body.instructions = f1C5A_parent_instructions;
            body.emit(f1C5A);

            /* END IF */

            body.emit(assign(r1C42, r1C57, 0x01));

            body.emit(assign(r1C43, r1C56, 0x01));


         body.instructions = f1C54_parent_instructions;
         body.emit(f1C54);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1C77 = bit_and(r1C42, body.constant(4294963200u));
         ir_expression *const r1C78 = nequal(r1C77, body.constant(0u));
         ir_if *f1C76 = new(mem_ctx) ir_if(operand(r1C78).val);
         exec_list *const f1C76_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C76->then_instructions;

            ir_variable *const r1C79 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1C7B = nequal(r1C49, body.constant(0u));
            ir_if *f1C7A = new(mem_ctx) ir_if(operand(r1C7B).val);
            exec_list *const f1C7A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C7A->then_instructions;

               body.emit(assign(r1C79, body.constant(0u), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1C7A->else_instructions;

               body.emit(assign(r1C79, body.constant(4294967295u), 0x01));


            body.instructions = f1C7A_parent_instructions;
            body.emit(f1C7A);

            /* END IF */

            body.emit(assign(r1C41, r1C79, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C76->else_instructions;

            ir_variable *const r1C7C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1C7C);
            ir_variable *const r1C7D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r1C7D);
            ir_expression *const r1C7E = lshift(r1C42, body.constant(int(20)));
            ir_expression *const r1C7F = rshift(r1C43, body.constant(int(12)));
            body.emit(assign(r1C7C, bit_or(r1C7E, r1C7F), 0x01));

            body.emit(assign(r1C7D, rshift(r1C42, body.constant(int(12))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1C81 = nequal(r1C49, body.constant(0u));
            ir_expression *const r1C82 = nequal(r1C7C, body.constant(0u));
            ir_expression *const r1C83 = logic_and(r1C81, r1C82);
            ir_if *f1C80 = new(mem_ctx) ir_if(operand(r1C83).val);
            exec_list *const f1C80_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C80->then_instructions;

               ir_variable *const r1C84 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1C86 = nequal(r1C49, body.constant(0u));
               ir_if *f1C85 = new(mem_ctx) ir_if(operand(r1C86).val);
               exec_list *const f1C85_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C85->then_instructions;

                  body.emit(assign(r1C84, body.constant(0u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1C85->else_instructions;

                  body.emit(assign(r1C84, body.constant(4294967295u), 0x01));


               body.instructions = f1C85_parent_instructions;
               body.emit(f1C85);

               /* END IF */

               body.emit(assign(r1C41, r1C84, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1C80->else_instructions;

               body.emit(assign(r1C41, r1C7C, 0x01));


            body.instructions = f1C80_parent_instructions;
            body.emit(f1C80);

            /* END IF */


         body.instructions = f1C76_parent_instructions;
         body.emit(f1C76);

         /* END IF */


      body.instructions = f1C4C_parent_instructions;
      body.emit(f1C4C);

      /* END IF */


   body.instructions = f1C4A_parent_instructions;
   body.emit(f1C4A);

   /* END IF */

   body.emit(ret(r1C41));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ftrunc64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1C87 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1C87);
   ir_variable *const r1C88 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1C89 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1C8A = rshift(swizzle_y(r1C87), body.constant(int(20)));
   ir_expression *const r1C8B = bit_and(r1C8A, body.constant(2047u));
   ir_expression *const r1C8C = expr(ir_unop_u2i, r1C8B);
   body.emit(assign(r1C89, add(r1C8C, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1C8E = less(r1C89, body.constant(int(0)));
   ir_if *f1C8D = new(mem_ctx) ir_if(operand(r1C8E).val);
   exec_list *const f1C8D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1C8D->then_instructions;

      body.emit(assign(r1C88, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1C8D->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1C90 = greater(r1C89, body.constant(int(52)));
      ir_if *f1C8F = new(mem_ctx) ir_if(operand(r1C90).val);
      exec_list *const f1C8F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1C8F->then_instructions;

         body.emit(assign(r1C88, r1C87, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1C8F->else_instructions;

         ir_variable *const r1C91 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1C91, sub(body.constant(int(52)), r1C89), 0x01));

         ir_variable *const r1C92 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1C94 = gequal(r1C91, body.constant(int(32)));
         ir_if *f1C93 = new(mem_ctx) ir_if(operand(r1C94).val);
         exec_list *const f1C93_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C93->then_instructions;

            body.emit(assign(r1C92, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C93->else_instructions;

            body.emit(assign(r1C92, lshift(body.constant(4294967295u), r1C91), 0x01));


         body.instructions = f1C93_parent_instructions;
         body.emit(f1C93);

         /* END IF */

         ir_variable *const r1C95 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1C97 = less(r1C91, body.constant(int(33)));
         ir_if *f1C96 = new(mem_ctx) ir_if(operand(r1C97).val);
         exec_list *const f1C96_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C96->then_instructions;

            body.emit(assign(r1C95, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C96->else_instructions;

            ir_expression *const r1C98 = add(r1C91, body.constant(int(-32)));
            body.emit(assign(r1C95, lshift(body.constant(4294967295u), r1C98), 0x01));


         body.instructions = f1C96_parent_instructions;
         body.emit(f1C96);

         /* END IF */

         ir_variable *const r1C99 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r1C99, bit_and(r1C92, swizzle_x(r1C87)), 0x01));

         body.emit(assign(r1C99, bit_and(r1C95, swizzle_y(r1C87)), 0x02));

         body.emit(assign(r1C88, r1C99, 0x03));


      body.instructions = f1C8F_parent_instructions;
      body.emit(f1C8F);

      /* END IF */


   body.instructions = f1C8D_parent_instructions;
   body.emit(f1C8D);

   /* END IF */

   body.emit(ret(r1C88));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ffloor64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1C9A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1C9A);
   ir_variable *const r1C9B = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1C9C = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1C9D = rshift(swizzle_y(r1C9A), body.constant(int(20)));
   ir_expression *const r1C9E = bit_and(r1C9D, body.constant(2047u));
   ir_expression *const r1C9F = expr(ir_unop_u2i, r1C9E);
   body.emit(assign(r1C9C, add(r1C9F, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1CA1 = less(r1C9C, body.constant(int(0)));
   ir_if *f1CA0 = new(mem_ctx) ir_if(operand(r1CA1).val);
   exec_list *const f1CA0_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1CA0->then_instructions;

      body.emit(assign(r1C9B, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1CA0->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1CA3 = greater(r1C9C, body.constant(int(52)));
      ir_if *f1CA2 = new(mem_ctx) ir_if(operand(r1CA3).val);
      exec_list *const f1CA2_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1CA2->then_instructions;

         body.emit(assign(r1C9B, r1C9A, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1CA2->else_instructions;

         ir_variable *const r1CA4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1CA4, sub(body.constant(int(52)), r1C9C), 0x01));

         ir_variable *const r1CA5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1CA7 = gequal(r1CA4, body.constant(int(32)));
         ir_if *f1CA6 = new(mem_ctx) ir_if(operand(r1CA7).val);
         exec_list *const f1CA6_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1CA6->then_instructions;

            body.emit(assign(r1CA5, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1CA6->else_instructions;

            body.emit(assign(r1CA5, lshift(body.constant(4294967295u), r1CA4), 0x01));


         body.instructions = f1CA6_parent_instructions;
         body.emit(f1CA6);

         /* END IF */

         ir_variable *const r1CA8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1CAA = less(r1CA4, body.constant(int(33)));
         ir_if *f1CA9 = new(mem_ctx) ir_if(operand(r1CAA).val);
         exec_list *const f1CA9_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1CA9->then_instructions;

            body.emit(assign(r1CA8, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1CA9->else_instructions;

            ir_expression *const r1CAB = add(r1CA4, body.constant(int(-32)));
            body.emit(assign(r1CA8, lshift(body.constant(4294967295u), r1CAB), 0x01));


         body.instructions = f1CA9_parent_instructions;
         body.emit(f1CA9);

         /* END IF */

         ir_variable *const r1CAC = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r1CAC, bit_and(r1CA5, swizzle_x(r1C9A)), 0x01));

         body.emit(assign(r1CAC, bit_and(r1CA8, swizzle_y(r1C9A)), 0x02));

         body.emit(assign(r1C9B, r1CAC, 0x03));


      body.instructions = f1CA2_parent_instructions;
      body.emit(f1CA2);

      /* END IF */


   body.instructions = f1CA0_parent_instructions;
   body.emit(f1CA0);

   /* END IF */

   ir_variable *const r1CAD = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r1CAE = rshift(swizzle_y(r1C9A), body.constant(int(31)));
   ir_expression *const r1CAF = expr(ir_unop_u2i, r1CAE);
   body.emit(assign(r1CAD, expr(ir_unop_i2b, r1CAF), 0x01));

   ir_variable *const r1CB0 = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r1CB2 = expr(ir_unop_logic_not, r1CAD);
   ir_if *f1CB1 = new(mem_ctx) ir_if(operand(r1CB2).val);
   exec_list *const f1CB1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1CB1->then_instructions;

      body.emit(assign(r1CB0, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1CB1->else_instructions;

      ir_variable *const r1CB3 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r1CB4 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r1CB4);
      ir_variable *const r1CB5 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r1CB5);
      ir_expression *const r1CB6 = rshift(swizzle_y(r1C9A), body.constant(int(20)));
      ir_expression *const r1CB7 = bit_and(r1CB6, body.constant(2047u));
      ir_expression *const r1CB8 = expr(ir_unop_u2i, r1CB7);
      ir_expression *const r1CB9 = equal(r1CB8, body.constant(int(2047)));
      ir_expression *const r1CBA = bit_and(swizzle_y(r1C9A), body.constant(1048575u));
      ir_expression *const r1CBB = bit_or(r1CBA, swizzle_x(r1C9A));
      ir_expression *const r1CBC = nequal(r1CBB, body.constant(0u));
      body.emit(assign(r1CB5, logic_and(r1CB9, r1CBC), 0x01));

      ir_expression *const r1CBD = rshift(swizzle_y(r1C9B), body.constant(int(20)));
      ir_expression *const r1CBE = bit_and(r1CBD, body.constant(2047u));
      ir_expression *const r1CBF = expr(ir_unop_u2i, r1CBE);
      ir_expression *const r1CC0 = equal(r1CBF, body.constant(int(2047)));
      ir_expression *const r1CC1 = bit_and(swizzle_y(r1C9B), body.constant(1048575u));
      ir_expression *const r1CC2 = bit_or(r1CC1, swizzle_x(r1C9B));
      ir_expression *const r1CC3 = nequal(r1CC2, body.constant(0u));
      body.emit(assign(r1CB4, logic_and(r1CC0, r1CC3), 0x01));

      /* IF CONDITION */
      ir_expression *const r1CC5 = logic_or(r1CB5, r1CB4);
      ir_if *f1CC4 = new(mem_ctx) ir_if(operand(r1CC5).val);
      exec_list *const f1CC4_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1CC4->then_instructions;

         body.emit(assign(r1CB3, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1CC4->else_instructions;

         ir_expression *const r1CC6 = equal(swizzle_x(r1C9A), swizzle_x(r1C9B));
         ir_expression *const r1CC7 = equal(swizzle_y(r1C9A), swizzle_y(r1C9B));
         ir_expression *const r1CC8 = equal(swizzle_x(r1C9A), body.constant(0u));
         ir_expression *const r1CC9 = bit_or(swizzle_y(r1C9A), swizzle_y(r1C9B));
         ir_expression *const r1CCA = lshift(r1CC9, body.constant(int(1)));
         ir_expression *const r1CCB = equal(r1CCA, body.constant(0u));
         ir_expression *const r1CCC = logic_and(r1CC8, r1CCB);
         ir_expression *const r1CCD = logic_or(r1CC7, r1CCC);
         body.emit(assign(r1CB3, logic_and(r1CC6, r1CCD), 0x01));


      body.instructions = f1CC4_parent_instructions;
      body.emit(f1CC4);

      /* END IF */

      body.emit(assign(r1CB0, r1CB3, 0x01));


   body.instructions = f1CB1_parent_instructions;
   body.emit(f1CB1);

   /* END IF */

   ir_variable *const r1CCE = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f1CCF = new(mem_ctx) ir_if(operand(r1CB0).val);
   exec_list *const f1CCF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1CCF->then_instructions;

      body.emit(assign(r1CCE, r1C9B, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1CCF->else_instructions;

      ir_variable *const r1CD0 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r1CD1 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1CD1, rshift(swizzle_y(r1C9B), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1CD3 = equal(r1CD1, body.constant(0u));
      ir_if *f1CD2 = new(mem_ctx) ir_if(operand(r1CD3).val);
      exec_list *const f1CD2_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1CD2->then_instructions;

         ir_variable *const r1CD4 = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r1CD4, r1CD1, 0x01));

         ir_variable *const r1CD5 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r1CD6 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r1CD6);
         ir_variable *const r1CD7 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r1CD7);
         ir_variable *const r1CD8 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r1CD8);
         ir_variable *const r1CD9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r1CD9);
         ir_variable *const r1CDA = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r1CDA);
         ir_variable *const r1CDB = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r1CDB);
         ir_variable *const r1CDC = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r1CDC);
         ir_variable *const r1CDD = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r1CDD);
         ir_variable *const r1CDE = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r1CDE, body.constant(0u), 0x01));

         ir_variable *const r1CDF = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r1CE0 = rshift(swizzle_y(r1C9B), body.constant(int(20)));
         ir_expression *const r1CE1 = bit_and(r1CE0, body.constant(2047u));
         body.emit(assign(r1CDF, expr(ir_unop_u2i, r1CE1), 0x01));

         body.emit(assign(r1CD8, r1CDF, 0x01));

         body.emit(assign(r1CD7, body.constant(int(1023)), 0x01));

         body.emit(assign(r1CD6, add(r1CDF, body.constant(int(-1023))), 0x01));

         ir_variable *const r1CE2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1CE2, lshift(swizzle_x(r1C9B), body.constant(int(10))), 0x01));

         ir_variable *const r1CE3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r1CE4 = bit_and(swizzle_y(r1C9B), body.constant(1048575u));
         ir_expression *const r1CE5 = lshift(r1CE4, body.constant(int(10)));
         ir_expression *const r1CE6 = rshift(swizzle_x(r1C9B), body.constant(int(22)));
         body.emit(assign(r1CE3, bit_or(r1CE5, r1CE6), 0x01));

         body.emit(assign(r1CDB, r1CE3, 0x01));

         body.emit(assign(r1CDC, r1CE2, 0x01));

         ir_variable *const r1CE7 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1CE7, body.constant(0u), 0x01));

         ir_variable *const r1CE8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r1CE8, body.constant(0u), 0x01));

         body.emit(assign(r1CD9, r1CE8, 0x01));

         body.emit(assign(r1CDA, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r1CEA = less(body.constant(int(0)), r1CD6);
         ir_if *f1CE9 = new(mem_ctx) ir_if(operand(r1CEA).val);
         exec_list *const f1CE9_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1CE9->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1CEC = equal(r1CDF, body.constant(int(2047)));
            ir_if *f1CEB = new(mem_ctx) ir_if(operand(r1CEC).val);
            exec_list *const f1CEB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1CEB->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1CEE = bit_or(r1CE3, r1CE2);
               ir_expression *const r1CEF = nequal(r1CEE, body.constant(0u));
               ir_if *f1CED = new(mem_ctx) ir_if(operand(r1CEF).val);
               exec_list *const f1CED_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CED->then_instructions;

                  ir_variable *const r1CF0 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1CF0, swizzle_x(r1C9B), 0x01));

                  ir_variable *const r1CF1 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r1CF1, body.constant(0u), 0x01));

                  ir_variable *const r1CF2 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r1CF0, bit_or(swizzle_y(r1C9B), body.constant(524288u)), 0x02));

                  body.emit(assign(r1CF1, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r1CF4 = lshift(swizzle_y(r1C9B), body.constant(int(1)));
                  ir_expression *const r1CF5 = lequal(body.constant(4292870144u), r1CF4);
                  ir_expression *const r1CF6 = nequal(swizzle_x(r1C9B), body.constant(0u));
                  ir_expression *const r1CF7 = bit_and(swizzle_y(r1C9B), body.constant(1048575u));
                  ir_expression *const r1CF8 = nequal(r1CF7, body.constant(0u));
                  ir_expression *const r1CF9 = logic_or(r1CF6, r1CF8);
                  ir_expression *const r1CFA = logic_and(r1CF5, r1CF9);
                  ir_if *f1CF3 = new(mem_ctx) ir_if(operand(r1CFA).val);
                  exec_list *const f1CF3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CF3->then_instructions;

                     body.emit(assign(r1CF2, r1CF0, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1CF3->else_instructions;

                     body.emit(assign(r1CF2, r1CF1, 0x03));


                  body.instructions = f1CF3_parent_instructions;
                  body.emit(f1CF3);

                  /* END IF */

                  body.emit(assign(r1CD5, r1CF2, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1CED->else_instructions;

                  body.emit(assign(r1CD5, r1C9B, 0x03));


               body.instructions = f1CED_parent_instructions;
               body.emit(f1CED);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1CEB->else_instructions;

               body.emit(assign(r1CD9, body.constant(1073741824u), 0x01));

               ir_variable *const r1CFB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1CFB);
               ir_variable *const r1CFC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1CFC);
               ir_variable *const r1CFD = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1CFE = neg(r1CD6);
               body.emit(assign(r1CFD, bit_and(r1CFE, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1D00 = equal(r1CD6, body.constant(int(0)));
               ir_if *f1CFF = new(mem_ctx) ir_if(operand(r1D00).val);
               exec_list *const f1CFF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CFF->then_instructions;

                  body.emit(assign(r1CFB, body.constant(0u), 0x01));

                  body.emit(assign(r1CFC, r1CD9, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1CFF->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1D02 = less(r1CD6, body.constant(int(32)));
                  ir_if *f1D01 = new(mem_ctx) ir_if(operand(r1D02).val);
                  exec_list *const f1D01_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D01->then_instructions;

                     ir_expression *const r1D03 = lshift(body.constant(1073741824u), r1CFD);
                     ir_expression *const r1D04 = bit_or(r1D03, body.constant(0u));
                     body.emit(assign(r1CFB, bit_or(r1D04, body.constant(0u)), 0x01));

                     body.emit(assign(r1CFC, rshift(body.constant(1073741824u), r1CD6), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D01->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1D06 = equal(r1CD6, body.constant(int(32)));
                     ir_if *f1D05 = new(mem_ctx) ir_if(operand(r1D06).val);
                     exec_list *const f1D05_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D05->then_instructions;

                        body.emit(assign(r1CFB, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1D05->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1D08 = less(r1CD6, body.constant(int(64)));
                        ir_if *f1D07 = new(mem_ctx) ir_if(operand(r1D08).val);
                        exec_list *const f1D07_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D07->then_instructions;

                           ir_expression *const r1D09 = bit_and(r1CD6, body.constant(int(31)));
                           ir_expression *const r1D0A = rshift(body.constant(1073741824u), r1D09);
                           ir_expression *const r1D0B = lshift(body.constant(1073741824u), r1CFD);
                           ir_expression *const r1D0C = bit_or(r1D0B, body.constant(0u));
                           ir_expression *const r1D0D = nequal(r1D0C, body.constant(0u));
                           ir_expression *const r1D0E = expr(ir_unop_b2i, r1D0D);
                           ir_expression *const r1D0F = expr(ir_unop_i2u, r1D0E);
                           body.emit(assign(r1CFB, bit_or(r1D0A, r1D0F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D07->else_instructions;

                           body.emit(assign(r1CFB, body.constant(1u), 0x01));


                        body.instructions = f1D07_parent_instructions;
                        body.emit(f1D07);

                        /* END IF */


                     body.instructions = f1D05_parent_instructions;
                     body.emit(f1D05);

                     /* END IF */

                     body.emit(assign(r1CFC, body.constant(0u), 0x01));


                  body.instructions = f1D01_parent_instructions;
                  body.emit(f1D01);

                  /* END IF */


               body.instructions = f1CFF_parent_instructions;
               body.emit(f1CFF);

               /* END IF */

               body.emit(assign(r1CD9, r1CFC, 0x01));

               body.emit(assign(r1CDA, r1CFB, 0x01));

               body.emit(assign(r1CDB, bit_or(r1CE3, body.constant(1073741824u)), 0x01));

               ir_variable *const r1D10 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1D11 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r1D11, sub(r1CE2, r1CFB), 0x01));

               ir_expression *const r1D12 = sub(r1CDB, r1CFC);
               ir_expression *const r1D13 = less(r1CE2, r1CFB);
               ir_expression *const r1D14 = expr(ir_unop_b2i, r1D13);
               ir_expression *const r1D15 = expr(ir_unop_i2u, r1D14);
               body.emit(assign(r1D10, sub(r1D12, r1D15), 0x01));

               body.emit(assign(r1CDD, add(r1CDF, body.constant(int(-1))), 0x01));

               ir_variable *const r1D16 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1D16, add(r1CDD, body.constant(int(-10))), 0x01));

               ir_variable *const r1D17 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1D17, r1D10, 0x01));

               ir_variable *const r1D18 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1D18, r1D11, 0x01));

               ir_variable *const r1D19 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r1D19);
               ir_variable *const r1D1A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1D1A);
               /* IF CONDITION */
               ir_expression *const r1D1C = equal(r1D10, body.constant(0u));
               ir_if *f1D1B = new(mem_ctx) ir_if(operand(r1D1C).val);
               exec_list *const f1D1B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D1B->then_instructions;

                  body.emit(assign(r1D17, r1D11, 0x01));

                  body.emit(assign(r1D18, body.constant(0u), 0x01));

                  body.emit(assign(r1D16, add(r1D16, body.constant(int(-32))), 0x01));


               body.instructions = f1D1B_parent_instructions;
               body.emit(f1D1B);

               /* END IF */

               ir_variable *const r1D1D = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r1D1D, r1D17, 0x01));

               ir_variable *const r1D1E = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r1D1F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1D1F);
               /* IF CONDITION */
               ir_expression *const r1D21 = equal(r1D17, body.constant(0u));
               ir_if *f1D20 = new(mem_ctx) ir_if(operand(r1D21).val);
               exec_list *const f1D20_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D20->then_instructions;

                  body.emit(assign(r1D1E, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1D20->else_instructions;

                  body.emit(assign(r1D1F, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1D23 = bit_and(r1D17, body.constant(4294901760u));
                  ir_expression *const r1D24 = equal(r1D23, body.constant(0u));
                  ir_if *f1D22 = new(mem_ctx) ir_if(operand(r1D24).val);
                  exec_list *const f1D22_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D22->then_instructions;

                     body.emit(assign(r1D1F, body.constant(int(16)), 0x01));

                     body.emit(assign(r1D1D, lshift(r1D17, body.constant(int(16))), 0x01));


                  body.instructions = f1D22_parent_instructions;
                  body.emit(f1D22);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1D26 = bit_and(r1D1D, body.constant(4278190080u));
                  ir_expression *const r1D27 = equal(r1D26, body.constant(0u));
                  ir_if *f1D25 = new(mem_ctx) ir_if(operand(r1D27).val);
                  exec_list *const f1D25_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D25->then_instructions;

                     body.emit(assign(r1D1F, add(r1D1F, body.constant(int(8))), 0x01));

                     body.emit(assign(r1D1D, lshift(r1D1D, body.constant(int(8))), 0x01));


                  body.instructions = f1D25_parent_instructions;
                  body.emit(f1D25);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1D29 = bit_and(r1D1D, body.constant(4026531840u));
                  ir_expression *const r1D2A = equal(r1D29, body.constant(0u));
                  ir_if *f1D28 = new(mem_ctx) ir_if(operand(r1D2A).val);
                  exec_list *const f1D28_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D28->then_instructions;

                     body.emit(assign(r1D1F, add(r1D1F, body.constant(int(4))), 0x01));

                     body.emit(assign(r1D1D, lshift(r1D1D, body.constant(int(4))), 0x01));


                  body.instructions = f1D28_parent_instructions;
                  body.emit(f1D28);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1D2C = bit_and(r1D1D, body.constant(3221225472u));
                  ir_expression *const r1D2D = equal(r1D2C, body.constant(0u));
                  ir_if *f1D2B = new(mem_ctx) ir_if(operand(r1D2D).val);
                  exec_list *const f1D2B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D2B->then_instructions;

                     body.emit(assign(r1D1F, add(r1D1F, body.constant(int(2))), 0x01));

                     body.emit(assign(r1D1D, lshift(r1D1D, body.constant(int(2))), 0x01));


                  body.instructions = f1D2B_parent_instructions;
                  body.emit(f1D2B);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1D2F = bit_and(r1D1D, body.constant(2147483648u));
                  ir_expression *const r1D30 = equal(r1D2F, body.constant(0u));
                  ir_if *f1D2E = new(mem_ctx) ir_if(operand(r1D30).val);
                  exec_list *const f1D2E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D2E->then_instructions;

                     body.emit(assign(r1D1F, add(r1D1F, body.constant(int(1))), 0x01));


                  body.instructions = f1D2E_parent_instructions;
                  body.emit(f1D2E);

                  /* END IF */

                  body.emit(assign(r1D1E, r1D1F, 0x01));


               body.instructions = f1D20_parent_instructions;
               body.emit(f1D20);

               /* END IF */

               body.emit(assign(r1D1A, add(r1D1E, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1D32 = lequal(body.constant(int(0)), r1D1A);
               ir_if *f1D31 = new(mem_ctx) ir_if(operand(r1D32).val);
               exec_list *const f1D31_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D31->then_instructions;

                  body.emit(assign(r1D19, body.constant(0u), 0x01));

                  ir_variable *const r1D33 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1D33, lshift(r1D18, r1D1A), 0x01));

                  ir_variable *const r1D34 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1D36 = equal(r1D1A, body.constant(int(0)));
                  ir_if *f1D35 = new(mem_ctx) ir_if(operand(r1D36).val);
                  exec_list *const f1D35_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D35->then_instructions;

                     body.emit(assign(r1D34, r1D17, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D35->else_instructions;

                     ir_expression *const r1D37 = lshift(r1D17, r1D1A);
                     ir_expression *const r1D38 = neg(r1D1A);
                     ir_expression *const r1D39 = bit_and(r1D38, body.constant(int(31)));
                     ir_expression *const r1D3A = rshift(r1D18, r1D39);
                     body.emit(assign(r1D34, bit_or(r1D37, r1D3A), 0x01));


                  body.instructions = f1D35_parent_instructions;
                  body.emit(f1D35);

                  /* END IF */

                  body.emit(assign(r1D17, r1D34, 0x01));

                  body.emit(assign(r1D18, r1D33, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1D31->else_instructions;

                  ir_variable *const r1D3B = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r1D3B, body.constant(0u), 0x01));

                  ir_variable *const r1D3C = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1D3C, neg(r1D1A), 0x01));

                  ir_variable *const r1D3D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1D3D);
                  ir_variable *const r1D3E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1D3E);
                  ir_variable *const r1D3F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1D3F);
                  ir_variable *const r1D40 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r1D41 = neg(r1D3C);
                  body.emit(assign(r1D40, bit_and(r1D41, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1D43 = equal(r1D3C, body.constant(int(0)));
                  ir_if *f1D42 = new(mem_ctx) ir_if(operand(r1D43).val);
                  exec_list *const f1D42_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D42->then_instructions;

                     body.emit(assign(r1D3D, r1D3B, 0x01));

                     body.emit(assign(r1D3E, r1D18, 0x01));

                     body.emit(assign(r1D3F, r1D17, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D42->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1D45 = less(r1D3C, body.constant(int(32)));
                     ir_if *f1D44 = new(mem_ctx) ir_if(operand(r1D45).val);
                     exec_list *const f1D44_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D44->then_instructions;

                        body.emit(assign(r1D3D, lshift(r1D18, r1D40), 0x01));

                        ir_expression *const r1D46 = lshift(r1D17, r1D40);
                        ir_expression *const r1D47 = rshift(r1D18, r1D3C);
                        body.emit(assign(r1D3E, bit_or(r1D46, r1D47), 0x01));

                        body.emit(assign(r1D3F, rshift(r1D17, r1D3C), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1D44->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1D49 = equal(r1D3C, body.constant(int(32)));
                        ir_if *f1D48 = new(mem_ctx) ir_if(operand(r1D49).val);
                        exec_list *const f1D48_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D48->then_instructions;

                           body.emit(assign(r1D3D, r1D18, 0x01));

                           body.emit(assign(r1D3E, r1D17, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D48->else_instructions;

                           body.emit(assign(r1D3B, bit_or(body.constant(0u), r1D18), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1D4B = less(r1D3C, body.constant(int(64)));
                           ir_if *f1D4A = new(mem_ctx) ir_if(operand(r1D4B).val);
                           exec_list *const f1D4A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D4A->then_instructions;

                              body.emit(assign(r1D3D, lshift(r1D17, r1D40), 0x01));

                              ir_expression *const r1D4C = bit_and(r1D3C, body.constant(int(31)));
                              body.emit(assign(r1D3E, rshift(r1D17, r1D4C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1D4A->else_instructions;

                              ir_variable *const r1D4D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1D4F = equal(r1D3C, body.constant(int(64)));
                              ir_if *f1D4E = new(mem_ctx) ir_if(operand(r1D4F).val);
                              exec_list *const f1D4E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1D4E->then_instructions;

                                 body.emit(assign(r1D4D, r1D17, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1D4E->else_instructions;

                                 ir_expression *const r1D50 = nequal(r1D17, body.constant(0u));
                                 ir_expression *const r1D51 = expr(ir_unop_b2i, r1D50);
                                 body.emit(assign(r1D4D, expr(ir_unop_i2u, r1D51), 0x01));


                              body.instructions = f1D4E_parent_instructions;
                              body.emit(f1D4E);

                              /* END IF */

                              body.emit(assign(r1D3D, r1D4D, 0x01));

                              body.emit(assign(r1D3E, body.constant(0u), 0x01));


                           body.instructions = f1D4A_parent_instructions;
                           body.emit(f1D4A);

                           /* END IF */


                        body.instructions = f1D48_parent_instructions;
                        body.emit(f1D48);

                        /* END IF */

                        body.emit(assign(r1D3F, body.constant(0u), 0x01));


                     body.instructions = f1D44_parent_instructions;
                     body.emit(f1D44);

                     /* END IF */

                     ir_expression *const r1D52 = nequal(r1D3B, body.constant(0u));
                     ir_expression *const r1D53 = expr(ir_unop_b2i, r1D52);
                     ir_expression *const r1D54 = expr(ir_unop_i2u, r1D53);
                     body.emit(assign(r1D3D, bit_or(r1D3D, r1D54), 0x01));


                  body.instructions = f1D42_parent_instructions;
                  body.emit(f1D42);

                  /* END IF */

                  body.emit(assign(r1D17, r1D3F, 0x01));

                  body.emit(assign(r1D18, r1D3E, 0x01));

                  body.emit(assign(r1D19, r1D3D, 0x01));


               body.instructions = f1D31_parent_instructions;
               body.emit(f1D31);

               /* END IF */

               body.emit(assign(r1D16, sub(r1D16, r1D1A), 0x01));

               ir_variable *const r1D55 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1D55, r1D16, 0x01));

               ir_variable *const r1D56 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1D56, r1D17, 0x01));

               ir_variable *const r1D57 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1D57, r1D18, 0x01));

               ir_variable *const r1D58 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1D58, r1D19, 0x01));

               ir_variable *const r1D59 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1D59, body.constant(true), 0x01));

               ir_variable *const r1D5A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1D5B = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1D5B);
               ir_expression *const r1D5C = expr(ir_unop_u2i, r1D19);
               body.emit(assign(r1D5B, less(r1D5C, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1D5E = lequal(body.constant(int(2045)), r1D16);
               ir_if *f1D5D = new(mem_ctx) ir_if(operand(r1D5E).val);
               exec_list *const f1D5D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D5D->then_instructions;

                  ir_variable *const r1D5F = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1D61 = less(body.constant(int(2045)), r1D16);
                  ir_if *f1D60 = new(mem_ctx) ir_if(operand(r1D61).val);
                  exec_list *const f1D60_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D60->then_instructions;

                     body.emit(assign(r1D5F, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D60->else_instructions;

                     ir_variable *const r1D62 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1D64 = equal(r1D16, body.constant(int(2045)));
                     ir_if *f1D63 = new(mem_ctx) ir_if(operand(r1D64).val);
                     exec_list *const f1D63_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D63->then_instructions;

                        ir_expression *const r1D65 = equal(body.constant(2097151u), r1D17);
                        ir_expression *const r1D66 = equal(body.constant(4294967295u), r1D18);
                        body.emit(assign(r1D62, logic_and(r1D65, r1D66), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1D63->else_instructions;

                        body.emit(assign(r1D62, body.constant(false), 0x01));


                     body.instructions = f1D63_parent_instructions;
                     body.emit(f1D63);

                     /* END IF */

                     body.emit(assign(r1D5F, logic_and(r1D62, r1D5B), 0x01));


                  body.instructions = f1D60_parent_instructions;
                  body.emit(f1D60);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1D67 = new(mem_ctx) ir_if(operand(r1D5F).val);
                  exec_list *const f1D67_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D67->then_instructions;

                     ir_variable *const r1D68 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1D68);
                     ir_expression *const r1D69 = lshift(r1CD1, body.constant(int(31)));
                     body.emit(assign(r1D68, add(r1D69, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1D68, body.constant(0u), 0x01));

                     body.emit(assign(r1D5A, r1D68, 0x03));

                     body.emit(assign(r1D59, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D67->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1D6B = less(r1D16, body.constant(int(0)));
                     ir_if *f1D6A = new(mem_ctx) ir_if(operand(r1D6B).val);
                     exec_list *const f1D6A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D6A->then_instructions;

                        ir_variable *const r1D6C = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1D6C, r1D19, 0x01));

                        ir_variable *const r1D6D = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1D6D, neg(r1D16), 0x01));

                        ir_variable *const r1D6E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1D6E);
                        ir_variable *const r1D6F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1D6F);
                        ir_variable *const r1D70 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1D70);
                        ir_variable *const r1D71 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1D72 = neg(r1D6D);
                        body.emit(assign(r1D71, bit_and(r1D72, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1D74 = equal(r1D6D, body.constant(int(0)));
                        ir_if *f1D73 = new(mem_ctx) ir_if(operand(r1D74).val);
                        exec_list *const f1D73_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D73->then_instructions;

                           body.emit(assign(r1D6E, r1D19, 0x01));

                           body.emit(assign(r1D6F, r1D18, 0x01));

                           body.emit(assign(r1D70, r1D17, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D73->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1D76 = less(r1D6D, body.constant(int(32)));
                           ir_if *f1D75 = new(mem_ctx) ir_if(operand(r1D76).val);
                           exec_list *const f1D75_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D75->then_instructions;

                              body.emit(assign(r1D6E, lshift(r1D18, r1D71), 0x01));

                              ir_expression *const r1D77 = lshift(r1D17, r1D71);
                              ir_expression *const r1D78 = rshift(r1D18, r1D6D);
                              body.emit(assign(r1D6F, bit_or(r1D77, r1D78), 0x01));

                              body.emit(assign(r1D70, rshift(r1D17, r1D6D), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1D75->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1D7A = equal(r1D6D, body.constant(int(32)));
                              ir_if *f1D79 = new(mem_ctx) ir_if(operand(r1D7A).val);
                              exec_list *const f1D79_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1D79->then_instructions;

                                 body.emit(assign(r1D6E, r1D18, 0x01));

                                 body.emit(assign(r1D6F, r1D17, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1D79->else_instructions;

                                 body.emit(assign(r1D6C, bit_or(r1D19, r1D18), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1D7C = less(r1D6D, body.constant(int(64)));
                                 ir_if *f1D7B = new(mem_ctx) ir_if(operand(r1D7C).val);
                                 exec_list *const f1D7B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1D7B->then_instructions;

                                    body.emit(assign(r1D6E, lshift(r1D17, r1D71), 0x01));

                                    ir_expression *const r1D7D = bit_and(r1D6D, body.constant(int(31)));
                                    body.emit(assign(r1D6F, rshift(r1D17, r1D7D), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1D7B->else_instructions;

                                    ir_variable *const r1D7E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1D80 = equal(r1D6D, body.constant(int(64)));
                                    ir_if *f1D7F = new(mem_ctx) ir_if(operand(r1D80).val);
                                    exec_list *const f1D7F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1D7F->then_instructions;

                                       body.emit(assign(r1D7E, r1D17, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1D7F->else_instructions;

                                       ir_expression *const r1D81 = nequal(r1D17, body.constant(0u));
                                       ir_expression *const r1D82 = expr(ir_unop_b2i, r1D81);
                                       body.emit(assign(r1D7E, expr(ir_unop_i2u, r1D82), 0x01));


                                    body.instructions = f1D7F_parent_instructions;
                                    body.emit(f1D7F);

                                    /* END IF */

                                    body.emit(assign(r1D6E, r1D7E, 0x01));

                                    body.emit(assign(r1D6F, body.constant(0u), 0x01));


                                 body.instructions = f1D7B_parent_instructions;
                                 body.emit(f1D7B);

                                 /* END IF */


                              body.instructions = f1D79_parent_instructions;
                              body.emit(f1D79);

                              /* END IF */

                              body.emit(assign(r1D70, body.constant(0u), 0x01));


                           body.instructions = f1D75_parent_instructions;
                           body.emit(f1D75);

                           /* END IF */

                           ir_expression *const r1D83 = nequal(r1D6C, body.constant(0u));
                           ir_expression *const r1D84 = expr(ir_unop_b2i, r1D83);
                           ir_expression *const r1D85 = expr(ir_unop_i2u, r1D84);
                           body.emit(assign(r1D6E, bit_or(r1D6E, r1D85), 0x01));


                        body.instructions = f1D73_parent_instructions;
                        body.emit(f1D73);

                        /* END IF */

                        body.emit(assign(r1D56, r1D70, 0x01));

                        body.emit(assign(r1D57, r1D6F, 0x01));

                        body.emit(assign(r1D58, r1D6E, 0x01));

                        body.emit(assign(r1D55, body.constant(int(0)), 0x01));

                        body.emit(assign(r1D5B, less(r1D6E, body.constant(0u)), 0x01));


                     body.instructions = f1D6A_parent_instructions;
                     body.emit(f1D6A);

                     /* END IF */


                  body.instructions = f1D67_parent_instructions;
                  body.emit(f1D67);

                  /* END IF */


               body.instructions = f1D5D_parent_instructions;
               body.emit(f1D5D);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1D86 = new(mem_ctx) ir_if(operand(r1D59).val);
               exec_list *const f1D86_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D86->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1D87 = new(mem_ctx) ir_if(operand(r1D5B).val);
                  exec_list *const f1D87_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D87->then_instructions;

                     ir_variable *const r1D88 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1D88, add(r1D57, body.constant(1u)), 0x01));

                     ir_expression *const r1D89 = less(r1D88, r1D57);
                     ir_expression *const r1D8A = expr(ir_unop_b2i, r1D89);
                     ir_expression *const r1D8B = expr(ir_unop_i2u, r1D8A);
                     body.emit(assign(r1D56, add(r1D56, r1D8B), 0x01));

                     ir_expression *const r1D8C = equal(r1D58, body.constant(0u));
                     ir_expression *const r1D8D = expr(ir_unop_b2i, r1D8C);
                     ir_expression *const r1D8E = expr(ir_unop_i2u, r1D8D);
                     ir_expression *const r1D8F = add(r1D58, r1D8E);
                     ir_expression *const r1D90 = bit_and(r1D8F, body.constant(1u));
                     ir_expression *const r1D91 = expr(ir_unop_bit_not, r1D90);
                     body.emit(assign(r1D57, bit_and(r1D88, r1D91), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D87->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1D93 = bit_or(r1D56, r1D57);
                     ir_expression *const r1D94 = equal(r1D93, body.constant(0u));
                     ir_if *f1D92 = new(mem_ctx) ir_if(operand(r1D94).val);
                     exec_list *const f1D92_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D92->then_instructions;

                        body.emit(assign(r1D55, body.constant(int(0)), 0x01));


                     body.instructions = f1D92_parent_instructions;
                     body.emit(f1D92);

                     /* END IF */


                  body.instructions = f1D87_parent_instructions;
                  body.emit(f1D87);

                  /* END IF */

                  ir_variable *const r1D95 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1D95);
                  ir_expression *const r1D96 = lshift(r1CD1, body.constant(int(31)));
                  ir_expression *const r1D97 = expr(ir_unop_i2u, r1D55);
                  ir_expression *const r1D98 = lshift(r1D97, body.constant(int(20)));
                  ir_expression *const r1D99 = add(r1D96, r1D98);
                  body.emit(assign(r1D95, add(r1D99, r1D56), 0x02));

                  body.emit(assign(r1D95, r1D57, 0x01));

                  body.emit(assign(r1D5A, r1D95, 0x03));

                  body.emit(assign(r1D59, body.constant(false), 0x01));


               body.instructions = f1D86_parent_instructions;
               body.emit(f1D86);

               /* END IF */

               body.emit(assign(r1CD5, r1D5A, 0x03));


            body.instructions = f1CEB_parent_instructions;
            body.emit(f1CEB);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1CE9->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1D9B = less(r1CD6, body.constant(int(0)));
            ir_if *f1D9A = new(mem_ctx) ir_if(operand(r1D9B).val);
            exec_list *const f1D9A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1D9A->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1D9D = equal(r1CDF, body.constant(int(0)));
               ir_if *f1D9C = new(mem_ctx) ir_if(operand(r1D9D).val);
               exec_list *const f1D9C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D9C->then_instructions;

                  body.emit(assign(r1CD6, add(r1CD6, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1D9C->else_instructions;

                  body.emit(assign(r1CDB, bit_or(r1CDB, body.constant(1073741824u)), 0x01));


               body.instructions = f1D9C_parent_instructions;
               body.emit(f1D9C);

               /* END IF */

               ir_variable *const r1D9E = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r1D9E, neg(r1CD6), 0x01));

               ir_variable *const r1D9F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1D9F);
               ir_variable *const r1DA0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1DA0);
               ir_variable *const r1DA1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1DA2 = neg(r1D9E);
               body.emit(assign(r1DA1, bit_and(r1DA2, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1DA4 = equal(r1D9E, body.constant(int(0)));
               ir_if *f1DA3 = new(mem_ctx) ir_if(operand(r1DA4).val);
               exec_list *const f1DA3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1DA3->then_instructions;

                  body.emit(assign(r1D9F, r1CE2, 0x01));

                  body.emit(assign(r1DA0, r1CDB, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1DA3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1DA6 = less(r1D9E, body.constant(int(32)));
                  ir_if *f1DA5 = new(mem_ctx) ir_if(operand(r1DA6).val);
                  exec_list *const f1DA5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DA5->then_instructions;

                     ir_expression *const r1DA7 = lshift(r1CDB, r1DA1);
                     ir_expression *const r1DA8 = rshift(r1CE2, r1D9E);
                     ir_expression *const r1DA9 = bit_or(r1DA7, r1DA8);
                     ir_expression *const r1DAA = lshift(r1CE2, r1DA1);
                     ir_expression *const r1DAB = nequal(r1DAA, body.constant(0u));
                     ir_expression *const r1DAC = expr(ir_unop_b2i, r1DAB);
                     ir_expression *const r1DAD = expr(ir_unop_i2u, r1DAC);
                     body.emit(assign(r1D9F, bit_or(r1DA9, r1DAD), 0x01));

                     body.emit(assign(r1DA0, rshift(r1CDB, r1D9E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1DA5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1DAF = equal(r1D9E, body.constant(int(32)));
                     ir_if *f1DAE = new(mem_ctx) ir_if(operand(r1DAF).val);
                     exec_list *const f1DAE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1DAE->then_instructions;

                        ir_expression *const r1DB0 = nequal(r1CE2, body.constant(0u));
                        ir_expression *const r1DB1 = expr(ir_unop_b2i, r1DB0);
                        ir_expression *const r1DB2 = expr(ir_unop_i2u, r1DB1);
                        body.emit(assign(r1D9F, bit_or(r1CDB, r1DB2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1DAE->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1DB4 = less(r1D9E, body.constant(int(64)));
                        ir_if *f1DB3 = new(mem_ctx) ir_if(operand(r1DB4).val);
                        exec_list *const f1DB3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1DB3->then_instructions;

                           ir_expression *const r1DB5 = bit_and(r1D9E, body.constant(int(31)));
                           ir_expression *const r1DB6 = rshift(r1CDB, r1DB5);
                           ir_expression *const r1DB7 = lshift(r1CDB, r1DA1);
                           ir_expression *const r1DB8 = bit_or(r1DB7, r1CE2);
                           ir_expression *const r1DB9 = nequal(r1DB8, body.constant(0u));
                           ir_expression *const r1DBA = expr(ir_unop_b2i, r1DB9);
                           ir_expression *const r1DBB = expr(ir_unop_i2u, r1DBA);
                           body.emit(assign(r1D9F, bit_or(r1DB6, r1DBB), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1DB3->else_instructions;

                           ir_expression *const r1DBC = bit_or(r1CDB, r1CE2);
                           ir_expression *const r1DBD = nequal(r1DBC, body.constant(0u));
                           ir_expression *const r1DBE = expr(ir_unop_b2i, r1DBD);
                           body.emit(assign(r1D9F, expr(ir_unop_i2u, r1DBE), 0x01));


                        body.instructions = f1DB3_parent_instructions;
                        body.emit(f1DB3);

                        /* END IF */


                     body.instructions = f1DAE_parent_instructions;
                     body.emit(f1DAE);

                     /* END IF */

                     body.emit(assign(r1DA0, body.constant(0u), 0x01));


                  body.instructions = f1DA5_parent_instructions;
                  body.emit(f1DA5);

                  /* END IF */


               body.instructions = f1DA3_parent_instructions;
               body.emit(f1DA3);

               /* END IF */

               body.emit(assign(r1CDB, r1DA0, 0x01));

               body.emit(assign(r1CDC, r1D9F, 0x01));

               body.emit(assign(r1CD9, bit_or(r1CD9, body.constant(1073741824u)), 0x01));

               ir_variable *const r1DBF = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1DC0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r1DC0, sub(r1CDA, r1D9F), 0x01));

               ir_expression *const r1DC1 = sub(r1CD9, r1DA0);
               ir_expression *const r1DC2 = less(r1CDA, r1D9F);
               ir_expression *const r1DC3 = expr(ir_unop_b2i, r1DC2);
               ir_expression *const r1DC4 = expr(ir_unop_i2u, r1DC3);
               body.emit(assign(r1DBF, sub(r1DC1, r1DC4), 0x01));

               body.emit(assign(r1CD4, bit_xor(r1CD1, body.constant(1u)), 0x01));

               body.emit(assign(r1CDD, body.constant(int(1022)), 0x01));

               ir_variable *const r1DC5 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1DC5, body.constant(int(1012)), 0x01));

               ir_variable *const r1DC6 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1DC6, r1DBF, 0x01));

               ir_variable *const r1DC7 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1DC7, r1DC0, 0x01));

               ir_variable *const r1DC8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r1DC8);
               ir_variable *const r1DC9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1DC9);
               /* IF CONDITION */
               ir_expression *const r1DCB = equal(r1DBF, body.constant(0u));
               ir_if *f1DCA = new(mem_ctx) ir_if(operand(r1DCB).val);
               exec_list *const f1DCA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1DCA->then_instructions;

                  body.emit(assign(r1DC6, r1DC0, 0x01));

                  body.emit(assign(r1DC7, body.constant(0u), 0x01));

                  body.emit(assign(r1DC5, body.constant(int(980)), 0x01));


               body.instructions = f1DCA_parent_instructions;
               body.emit(f1DCA);

               /* END IF */

               ir_variable *const r1DCC = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r1DCC, r1DC6, 0x01));

               ir_variable *const r1DCD = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r1DCE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1DCE);
               /* IF CONDITION */
               ir_expression *const r1DD0 = equal(r1DC6, body.constant(0u));
               ir_if *f1DCF = new(mem_ctx) ir_if(operand(r1DD0).val);
               exec_list *const f1DCF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1DCF->then_instructions;

                  body.emit(assign(r1DCD, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1DCF->else_instructions;

                  body.emit(assign(r1DCE, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1DD2 = bit_and(r1DC6, body.constant(4294901760u));
                  ir_expression *const r1DD3 = equal(r1DD2, body.constant(0u));
                  ir_if *f1DD1 = new(mem_ctx) ir_if(operand(r1DD3).val);
                  exec_list *const f1DD1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DD1->then_instructions;

                     body.emit(assign(r1DCE, body.constant(int(16)), 0x01));

                     body.emit(assign(r1DCC, lshift(r1DC6, body.constant(int(16))), 0x01));


                  body.instructions = f1DD1_parent_instructions;
                  body.emit(f1DD1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1DD5 = bit_and(r1DCC, body.constant(4278190080u));
                  ir_expression *const r1DD6 = equal(r1DD5, body.constant(0u));
                  ir_if *f1DD4 = new(mem_ctx) ir_if(operand(r1DD6).val);
                  exec_list *const f1DD4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DD4->then_instructions;

                     body.emit(assign(r1DCE, add(r1DCE, body.constant(int(8))), 0x01));

                     body.emit(assign(r1DCC, lshift(r1DCC, body.constant(int(8))), 0x01));


                  body.instructions = f1DD4_parent_instructions;
                  body.emit(f1DD4);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1DD8 = bit_and(r1DCC, body.constant(4026531840u));
                  ir_expression *const r1DD9 = equal(r1DD8, body.constant(0u));
                  ir_if *f1DD7 = new(mem_ctx) ir_if(operand(r1DD9).val);
                  exec_list *const f1DD7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DD7->then_instructions;

                     body.emit(assign(r1DCE, add(r1DCE, body.constant(int(4))), 0x01));

                     body.emit(assign(r1DCC, lshift(r1DCC, body.constant(int(4))), 0x01));


                  body.instructions = f1DD7_parent_instructions;
                  body.emit(f1DD7);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1DDB = bit_and(r1DCC, body.constant(3221225472u));
                  ir_expression *const r1DDC = equal(r1DDB, body.constant(0u));
                  ir_if *f1DDA = new(mem_ctx) ir_if(operand(r1DDC).val);
                  exec_list *const f1DDA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DDA->then_instructions;

                     body.emit(assign(r1DCE, add(r1DCE, body.constant(int(2))), 0x01));

                     body.emit(assign(r1DCC, lshift(r1DCC, body.constant(int(2))), 0x01));


                  body.instructions = f1DDA_parent_instructions;
                  body.emit(f1DDA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1DDE = bit_and(r1DCC, body.constant(2147483648u));
                  ir_expression *const r1DDF = equal(r1DDE, body.constant(0u));
                  ir_if *f1DDD = new(mem_ctx) ir_if(operand(r1DDF).val);
                  exec_list *const f1DDD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DDD->then_instructions;

                     body.emit(assign(r1DCE, add(r1DCE, body.constant(int(1))), 0x01));


                  body.instructions = f1DDD_parent_instructions;
                  body.emit(f1DDD);

                  /* END IF */

                  body.emit(assign(r1DCD, r1DCE, 0x01));


               body.instructions = f1DCF_parent_instructions;
               body.emit(f1DCF);

               /* END IF */

               body.emit(assign(r1DC9, add(r1DCD, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1DE1 = lequal(body.constant(int(0)), r1DC9);
               ir_if *f1DE0 = new(mem_ctx) ir_if(operand(r1DE1).val);
               exec_list *const f1DE0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1DE0->then_instructions;

                  body.emit(assign(r1DC8, body.constant(0u), 0x01));

                  ir_variable *const r1DE2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1DE2, lshift(r1DC7, r1DC9), 0x01));

                  ir_variable *const r1DE3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1DE5 = equal(r1DC9, body.constant(int(0)));
                  ir_if *f1DE4 = new(mem_ctx) ir_if(operand(r1DE5).val);
                  exec_list *const f1DE4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DE4->then_instructions;

                     body.emit(assign(r1DE3, r1DC6, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1DE4->else_instructions;

                     ir_expression *const r1DE6 = lshift(r1DC6, r1DC9);
                     ir_expression *const r1DE7 = neg(r1DC9);
                     ir_expression *const r1DE8 = bit_and(r1DE7, body.constant(int(31)));
                     ir_expression *const r1DE9 = rshift(r1DC7, r1DE8);
                     body.emit(assign(r1DE3, bit_or(r1DE6, r1DE9), 0x01));


                  body.instructions = f1DE4_parent_instructions;
                  body.emit(f1DE4);

                  /* END IF */

                  body.emit(assign(r1DC6, r1DE3, 0x01));

                  body.emit(assign(r1DC7, r1DE2, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1DE0->else_instructions;

                  ir_variable *const r1DEA = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r1DEA, body.constant(0u), 0x01));

                  ir_variable *const r1DEB = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1DEB, neg(r1DC9), 0x01));

                  ir_variable *const r1DEC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1DEC);
                  ir_variable *const r1DED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1DED);
                  ir_variable *const r1DEE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1DEE);
                  ir_variable *const r1DEF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r1DF0 = neg(r1DEB);
                  body.emit(assign(r1DEF, bit_and(r1DF0, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1DF2 = equal(r1DEB, body.constant(int(0)));
                  ir_if *f1DF1 = new(mem_ctx) ir_if(operand(r1DF2).val);
                  exec_list *const f1DF1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DF1->then_instructions;

                     body.emit(assign(r1DEC, r1DEA, 0x01));

                     body.emit(assign(r1DED, r1DC7, 0x01));

                     body.emit(assign(r1DEE, r1DC6, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1DF1->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1DF4 = less(r1DEB, body.constant(int(32)));
                     ir_if *f1DF3 = new(mem_ctx) ir_if(operand(r1DF4).val);
                     exec_list *const f1DF3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1DF3->then_instructions;

                        body.emit(assign(r1DEC, lshift(r1DC7, r1DEF), 0x01));

                        ir_expression *const r1DF5 = lshift(r1DC6, r1DEF);
                        ir_expression *const r1DF6 = rshift(r1DC7, r1DEB);
                        body.emit(assign(r1DED, bit_or(r1DF5, r1DF6), 0x01));

                        body.emit(assign(r1DEE, rshift(r1DC6, r1DEB), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1DF3->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1DF8 = equal(r1DEB, body.constant(int(32)));
                        ir_if *f1DF7 = new(mem_ctx) ir_if(operand(r1DF8).val);
                        exec_list *const f1DF7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1DF7->then_instructions;

                           body.emit(assign(r1DEC, r1DC7, 0x01));

                           body.emit(assign(r1DED, r1DC6, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1DF7->else_instructions;

                           body.emit(assign(r1DEA, bit_or(body.constant(0u), r1DC7), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1DFA = less(r1DEB, body.constant(int(64)));
                           ir_if *f1DF9 = new(mem_ctx) ir_if(operand(r1DFA).val);
                           exec_list *const f1DF9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1DF9->then_instructions;

                              body.emit(assign(r1DEC, lshift(r1DC6, r1DEF), 0x01));

                              ir_expression *const r1DFB = bit_and(r1DEB, body.constant(int(31)));
                              body.emit(assign(r1DED, rshift(r1DC6, r1DFB), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1DF9->else_instructions;

                              ir_variable *const r1DFC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1DFE = equal(r1DEB, body.constant(int(64)));
                              ir_if *f1DFD = new(mem_ctx) ir_if(operand(r1DFE).val);
                              exec_list *const f1DFD_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1DFD->then_instructions;

                                 body.emit(assign(r1DFC, r1DC6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1DFD->else_instructions;

                                 ir_expression *const r1DFF = nequal(r1DC6, body.constant(0u));
                                 ir_expression *const r1E00 = expr(ir_unop_b2i, r1DFF);
                                 body.emit(assign(r1DFC, expr(ir_unop_i2u, r1E00), 0x01));


                              body.instructions = f1DFD_parent_instructions;
                              body.emit(f1DFD);

                              /* END IF */

                              body.emit(assign(r1DEC, r1DFC, 0x01));

                              body.emit(assign(r1DED, body.constant(0u), 0x01));


                           body.instructions = f1DF9_parent_instructions;
                           body.emit(f1DF9);

                           /* END IF */


                        body.instructions = f1DF7_parent_instructions;
                        body.emit(f1DF7);

                        /* END IF */

                        body.emit(assign(r1DEE, body.constant(0u), 0x01));


                     body.instructions = f1DF3_parent_instructions;
                     body.emit(f1DF3);

                     /* END IF */

                     ir_expression *const r1E01 = nequal(r1DEA, body.constant(0u));
                     ir_expression *const r1E02 = expr(ir_unop_b2i, r1E01);
                     ir_expression *const r1E03 = expr(ir_unop_i2u, r1E02);
                     body.emit(assign(r1DEC, bit_or(r1DEC, r1E03), 0x01));


                  body.instructions = f1DF1_parent_instructions;
                  body.emit(f1DF1);

                  /* END IF */

                  body.emit(assign(r1DC6, r1DEE, 0x01));

                  body.emit(assign(r1DC7, r1DED, 0x01));

                  body.emit(assign(r1DC8, r1DEC, 0x01));


               body.instructions = f1DE0_parent_instructions;
               body.emit(f1DE0);

               /* END IF */

               body.emit(assign(r1DC5, sub(r1DC5, r1DC9), 0x01));

               ir_variable *const r1E04 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1E04, r1DC5, 0x01));

               ir_variable *const r1E05 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1E05, r1DC6, 0x01));

               ir_variable *const r1E06 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1E06, r1DC7, 0x01));

               ir_variable *const r1E07 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1E07, r1DC8, 0x01));

               ir_variable *const r1E08 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1E08, body.constant(true), 0x01));

               ir_variable *const r1E09 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1E0A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1E0A);
               ir_expression *const r1E0B = expr(ir_unop_u2i, r1DC8);
               body.emit(assign(r1E0A, less(r1E0B, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1E0D = lequal(body.constant(int(2045)), r1DC5);
               ir_if *f1E0C = new(mem_ctx) ir_if(operand(r1E0D).val);
               exec_list *const f1E0C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E0C->then_instructions;

                  ir_variable *const r1E0E = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1E10 = less(body.constant(int(2045)), r1DC5);
                  ir_if *f1E0F = new(mem_ctx) ir_if(operand(r1E10).val);
                  exec_list *const f1E0F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E0F->then_instructions;

                     body.emit(assign(r1E0E, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E0F->else_instructions;

                     ir_variable *const r1E11 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1E13 = equal(r1DC5, body.constant(int(2045)));
                     ir_if *f1E12 = new(mem_ctx) ir_if(operand(r1E13).val);
                     exec_list *const f1E12_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E12->then_instructions;

                        ir_expression *const r1E14 = equal(body.constant(2097151u), r1DC6);
                        ir_expression *const r1E15 = equal(body.constant(4294967295u), r1DC7);
                        body.emit(assign(r1E11, logic_and(r1E14, r1E15), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1E12->else_instructions;

                        body.emit(assign(r1E11, body.constant(false), 0x01));


                     body.instructions = f1E12_parent_instructions;
                     body.emit(f1E12);

                     /* END IF */

                     body.emit(assign(r1E0E, logic_and(r1E11, r1E0A), 0x01));


                  body.instructions = f1E0F_parent_instructions;
                  body.emit(f1E0F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1E16 = new(mem_ctx) ir_if(operand(r1E0E).val);
                  exec_list *const f1E16_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E16->then_instructions;

                     ir_variable *const r1E17 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1E17);
                     ir_expression *const r1E18 = lshift(r1CD4, body.constant(int(31)));
                     body.emit(assign(r1E17, add(r1E18, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1E17, body.constant(0u), 0x01));

                     body.emit(assign(r1E09, r1E17, 0x03));

                     body.emit(assign(r1E08, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E16->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1E1A = less(r1DC5, body.constant(int(0)));
                     ir_if *f1E19 = new(mem_ctx) ir_if(operand(r1E1A).val);
                     exec_list *const f1E19_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E19->then_instructions;

                        ir_variable *const r1E1B = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1E1B, r1DC8, 0x01));

                        ir_variable *const r1E1C = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1E1C, neg(r1DC5), 0x01));

                        ir_variable *const r1E1D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1E1D);
                        ir_variable *const r1E1E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1E1E);
                        ir_variable *const r1E1F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1E1F);
                        ir_variable *const r1E20 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1E21 = neg(r1E1C);
                        body.emit(assign(r1E20, bit_and(r1E21, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1E23 = equal(r1E1C, body.constant(int(0)));
                        ir_if *f1E22 = new(mem_ctx) ir_if(operand(r1E23).val);
                        exec_list *const f1E22_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E22->then_instructions;

                           body.emit(assign(r1E1D, r1DC8, 0x01));

                           body.emit(assign(r1E1E, r1DC7, 0x01));

                           body.emit(assign(r1E1F, r1DC6, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1E22->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1E25 = less(r1E1C, body.constant(int(32)));
                           ir_if *f1E24 = new(mem_ctx) ir_if(operand(r1E25).val);
                           exec_list *const f1E24_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1E24->then_instructions;

                              body.emit(assign(r1E1D, lshift(r1DC7, r1E20), 0x01));

                              ir_expression *const r1E26 = lshift(r1DC6, r1E20);
                              ir_expression *const r1E27 = rshift(r1DC7, r1E1C);
                              body.emit(assign(r1E1E, bit_or(r1E26, r1E27), 0x01));

                              body.emit(assign(r1E1F, rshift(r1DC6, r1E1C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1E24->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1E29 = equal(r1E1C, body.constant(int(32)));
                              ir_if *f1E28 = new(mem_ctx) ir_if(operand(r1E29).val);
                              exec_list *const f1E28_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E28->then_instructions;

                                 body.emit(assign(r1E1D, r1DC7, 0x01));

                                 body.emit(assign(r1E1E, r1DC6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1E28->else_instructions;

                                 body.emit(assign(r1E1B, bit_or(r1DC8, r1DC7), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1E2B = less(r1E1C, body.constant(int(64)));
                                 ir_if *f1E2A = new(mem_ctx) ir_if(operand(r1E2B).val);
                                 exec_list *const f1E2A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1E2A->then_instructions;

                                    body.emit(assign(r1E1D, lshift(r1DC6, r1E20), 0x01));

                                    ir_expression *const r1E2C = bit_and(r1E1C, body.constant(int(31)));
                                    body.emit(assign(r1E1E, rshift(r1DC6, r1E2C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1E2A->else_instructions;

                                    ir_variable *const r1E2D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1E2F = equal(r1E1C, body.constant(int(64)));
                                    ir_if *f1E2E = new(mem_ctx) ir_if(operand(r1E2F).val);
                                    exec_list *const f1E2E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1E2E->then_instructions;

                                       body.emit(assign(r1E2D, r1DC6, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1E2E->else_instructions;

                                       ir_expression *const r1E30 = nequal(r1DC6, body.constant(0u));
                                       ir_expression *const r1E31 = expr(ir_unop_b2i, r1E30);
                                       body.emit(assign(r1E2D, expr(ir_unop_i2u, r1E31), 0x01));


                                    body.instructions = f1E2E_parent_instructions;
                                    body.emit(f1E2E);

                                    /* END IF */

                                    body.emit(assign(r1E1D, r1E2D, 0x01));

                                    body.emit(assign(r1E1E, body.constant(0u), 0x01));


                                 body.instructions = f1E2A_parent_instructions;
                                 body.emit(f1E2A);

                                 /* END IF */


                              body.instructions = f1E28_parent_instructions;
                              body.emit(f1E28);

                              /* END IF */

                              body.emit(assign(r1E1F, body.constant(0u), 0x01));


                           body.instructions = f1E24_parent_instructions;
                           body.emit(f1E24);

                           /* END IF */

                           ir_expression *const r1E32 = nequal(r1E1B, body.constant(0u));
                           ir_expression *const r1E33 = expr(ir_unop_b2i, r1E32);
                           ir_expression *const r1E34 = expr(ir_unop_i2u, r1E33);
                           body.emit(assign(r1E1D, bit_or(r1E1D, r1E34), 0x01));


                        body.instructions = f1E22_parent_instructions;
                        body.emit(f1E22);

                        /* END IF */

                        body.emit(assign(r1E05, r1E1F, 0x01));

                        body.emit(assign(r1E06, r1E1E, 0x01));

                        body.emit(assign(r1E07, r1E1D, 0x01));

                        body.emit(assign(r1E04, body.constant(int(0)), 0x01));

                        body.emit(assign(r1E0A, less(r1E1D, body.constant(0u)), 0x01));


                     body.instructions = f1E19_parent_instructions;
                     body.emit(f1E19);

                     /* END IF */


                  body.instructions = f1E16_parent_instructions;
                  body.emit(f1E16);

                  /* END IF */


               body.instructions = f1E0C_parent_instructions;
               body.emit(f1E0C);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1E35 = new(mem_ctx) ir_if(operand(r1E08).val);
               exec_list *const f1E35_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E35->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1E36 = new(mem_ctx) ir_if(operand(r1E0A).val);
                  exec_list *const f1E36_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E36->then_instructions;

                     ir_variable *const r1E37 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1E37, add(r1E06, body.constant(1u)), 0x01));

                     ir_expression *const r1E38 = less(r1E37, r1E06);
                     ir_expression *const r1E39 = expr(ir_unop_b2i, r1E38);
                     ir_expression *const r1E3A = expr(ir_unop_i2u, r1E39);
                     body.emit(assign(r1E05, add(r1E05, r1E3A), 0x01));

                     ir_expression *const r1E3B = equal(r1E07, body.constant(0u));
                     ir_expression *const r1E3C = expr(ir_unop_b2i, r1E3B);
                     ir_expression *const r1E3D = expr(ir_unop_i2u, r1E3C);
                     ir_expression *const r1E3E = add(r1E07, r1E3D);
                     ir_expression *const r1E3F = bit_and(r1E3E, body.constant(1u));
                     ir_expression *const r1E40 = expr(ir_unop_bit_not, r1E3F);
                     body.emit(assign(r1E06, bit_and(r1E37, r1E40), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E36->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1E42 = bit_or(r1E05, r1E06);
                     ir_expression *const r1E43 = equal(r1E42, body.constant(0u));
                     ir_if *f1E41 = new(mem_ctx) ir_if(operand(r1E43).val);
                     exec_list *const f1E41_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E41->then_instructions;

                        body.emit(assign(r1E04, body.constant(int(0)), 0x01));


                     body.instructions = f1E41_parent_instructions;
                     body.emit(f1E41);

                     /* END IF */


                  body.instructions = f1E36_parent_instructions;
                  body.emit(f1E36);

                  /* END IF */

                  ir_variable *const r1E44 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1E44);
                  ir_expression *const r1E45 = lshift(r1CD4, body.constant(int(31)));
                  ir_expression *const r1E46 = expr(ir_unop_i2u, r1E04);
                  ir_expression *const r1E47 = lshift(r1E46, body.constant(int(20)));
                  ir_expression *const r1E48 = add(r1E45, r1E47);
                  body.emit(assign(r1E44, add(r1E48, r1E05), 0x02));

                  body.emit(assign(r1E44, r1E06, 0x01));

                  body.emit(assign(r1E09, r1E44, 0x03));

                  body.emit(assign(r1E08, body.constant(false), 0x01));


               body.instructions = f1E35_parent_instructions;
               body.emit(f1E35);

               /* END IF */

               body.emit(assign(r1CD5, r1E09, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1D9A->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1E4A = equal(r1CDF, body.constant(int(2047)));
               ir_if *f1E49 = new(mem_ctx) ir_if(operand(r1E4A).val);
               exec_list *const f1E49_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E49->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1E4C = bit_or(r1CDB, r1CDC);
                  ir_expression *const r1E4D = bit_or(r1CD9, r1CDA);
                  ir_expression *const r1E4E = bit_or(r1E4C, r1E4D);
                  ir_expression *const r1E4F = nequal(r1E4E, body.constant(0u));
                  ir_if *f1E4B = new(mem_ctx) ir_if(operand(r1E4F).val);
                  exec_list *const f1E4B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E4B->then_instructions;

                     ir_variable *const r1E50 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r1E50, swizzle_x(r1C9B), 0x01));

                     ir_variable *const r1E51 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r1E51, body.constant(0u), 0x01));

                     ir_variable *const r1E52 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r1E50, bit_or(swizzle_y(r1C9B), body.constant(524288u)), 0x02));

                     body.emit(assign(r1E51, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r1E54 = lshift(swizzle_y(r1C9B), body.constant(int(1)));
                     ir_expression *const r1E55 = lequal(body.constant(4292870144u), r1E54);
                     ir_expression *const r1E56 = nequal(swizzle_x(r1C9B), body.constant(0u));
                     ir_expression *const r1E57 = bit_and(swizzle_y(r1C9B), body.constant(1048575u));
                     ir_expression *const r1E58 = nequal(r1E57, body.constant(0u));
                     ir_expression *const r1E59 = logic_or(r1E56, r1E58);
                     ir_expression *const r1E5A = logic_and(r1E55, r1E59);
                     ir_if *f1E53 = new(mem_ctx) ir_if(operand(r1E5A).val);
                     exec_list *const f1E53_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E53->then_instructions;

                        body.emit(assign(r1E52, r1E50, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1E53->else_instructions;

                        body.emit(assign(r1E52, r1E51, 0x03));


                     body.instructions = f1E53_parent_instructions;
                     body.emit(f1E53);

                     /* END IF */

                     body.emit(assign(r1CD5, r1E52, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E4B->else_instructions;

                     ir_constant_data r1E5B_data;
                     memset(&r1E5B_data, 0, sizeof(ir_constant_data));
                     r1E5B_data.u[0] = 4294967295;
                     r1E5B_data.u[1] = 4294967295;
                     ir_constant *const r1E5B = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r1E5B_data);
                     body.emit(assign(r1CD5, r1E5B, 0x03));


                  body.instructions = f1E4B_parent_instructions;
                  body.emit(f1E4B);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1E49->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1E5D = equal(r1CDF, body.constant(int(0)));
                  ir_if *f1E5C = new(mem_ctx) ir_if(operand(r1E5D).val);
                  exec_list *const f1E5C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E5C->then_instructions;

                     body.emit(assign(r1CD8, body.constant(int(1)), 0x01));

                     body.emit(assign(r1CD7, body.constant(int(1)), 0x01));


                  body.instructions = f1E5C_parent_instructions;
                  body.emit(f1E5C);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1E5F = less(r1CD9, r1CDB);
                  ir_if *f1E5E = new(mem_ctx) ir_if(operand(r1E5F).val);
                  exec_list *const f1E5E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E5E->then_instructions;

                     ir_variable *const r1E60 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r1E61 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r1E61, sub(r1CDC, r1CDA), 0x01));

                     ir_expression *const r1E62 = sub(r1CDB, r1CD9);
                     ir_expression *const r1E63 = less(r1CDC, r1CDA);
                     ir_expression *const r1E64 = expr(ir_unop_b2i, r1E63);
                     ir_expression *const r1E65 = expr(ir_unop_i2u, r1E64);
                     body.emit(assign(r1E60, sub(r1E62, r1E65), 0x01));

                     body.emit(assign(r1CDD, add(r1CD8, body.constant(int(-1))), 0x01));

                     ir_variable *const r1E66 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1E66, add(r1CDD, body.constant(int(-10))), 0x01));

                     ir_variable *const r1E67 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1E67, r1E60, 0x01));

                     ir_variable *const r1E68 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1E68, r1E61, 0x01));

                     ir_variable *const r1E69 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r1E69);
                     ir_variable *const r1E6A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1E6A);
                     /* IF CONDITION */
                     ir_expression *const r1E6C = equal(r1E60, body.constant(0u));
                     ir_if *f1E6B = new(mem_ctx) ir_if(operand(r1E6C).val);
                     exec_list *const f1E6B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E6B->then_instructions;

                        body.emit(assign(r1E67, r1E61, 0x01));

                        body.emit(assign(r1E68, body.constant(0u), 0x01));

                        body.emit(assign(r1E66, add(r1E66, body.constant(int(-32))), 0x01));


                     body.instructions = f1E6B_parent_instructions;
                     body.emit(f1E6B);

                     /* END IF */

                     ir_variable *const r1E6D = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1E6D, r1E67, 0x01));

                     ir_variable *const r1E6E = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1E6F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1E6F);
                     /* IF CONDITION */
                     ir_expression *const r1E71 = equal(r1E67, body.constant(0u));
                     ir_if *f1E70 = new(mem_ctx) ir_if(operand(r1E71).val);
                     exec_list *const f1E70_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E70->then_instructions;

                        body.emit(assign(r1E6E, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1E70->else_instructions;

                        body.emit(assign(r1E6F, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1E73 = bit_and(r1E67, body.constant(4294901760u));
                        ir_expression *const r1E74 = equal(r1E73, body.constant(0u));
                        ir_if *f1E72 = new(mem_ctx) ir_if(operand(r1E74).val);
                        exec_list *const f1E72_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E72->then_instructions;

                           body.emit(assign(r1E6F, body.constant(int(16)), 0x01));

                           body.emit(assign(r1E6D, lshift(r1E67, body.constant(int(16))), 0x01));


                        body.instructions = f1E72_parent_instructions;
                        body.emit(f1E72);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1E76 = bit_and(r1E6D, body.constant(4278190080u));
                        ir_expression *const r1E77 = equal(r1E76, body.constant(0u));
                        ir_if *f1E75 = new(mem_ctx) ir_if(operand(r1E77).val);
                        exec_list *const f1E75_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E75->then_instructions;

                           body.emit(assign(r1E6F, add(r1E6F, body.constant(int(8))), 0x01));

                           body.emit(assign(r1E6D, lshift(r1E6D, body.constant(int(8))), 0x01));


                        body.instructions = f1E75_parent_instructions;
                        body.emit(f1E75);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1E79 = bit_and(r1E6D, body.constant(4026531840u));
                        ir_expression *const r1E7A = equal(r1E79, body.constant(0u));
                        ir_if *f1E78 = new(mem_ctx) ir_if(operand(r1E7A).val);
                        exec_list *const f1E78_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E78->then_instructions;

                           body.emit(assign(r1E6F, add(r1E6F, body.constant(int(4))), 0x01));

                           body.emit(assign(r1E6D, lshift(r1E6D, body.constant(int(4))), 0x01));


                        body.instructions = f1E78_parent_instructions;
                        body.emit(f1E78);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1E7C = bit_and(r1E6D, body.constant(3221225472u));
                        ir_expression *const r1E7D = equal(r1E7C, body.constant(0u));
                        ir_if *f1E7B = new(mem_ctx) ir_if(operand(r1E7D).val);
                        exec_list *const f1E7B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E7B->then_instructions;

                           body.emit(assign(r1E6F, add(r1E6F, body.constant(int(2))), 0x01));

                           body.emit(assign(r1E6D, lshift(r1E6D, body.constant(int(2))), 0x01));


                        body.instructions = f1E7B_parent_instructions;
                        body.emit(f1E7B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1E7F = bit_and(r1E6D, body.constant(2147483648u));
                        ir_expression *const r1E80 = equal(r1E7F, body.constant(0u));
                        ir_if *f1E7E = new(mem_ctx) ir_if(operand(r1E80).val);
                        exec_list *const f1E7E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E7E->then_instructions;

                           body.emit(assign(r1E6F, add(r1E6F, body.constant(int(1))), 0x01));


                        body.instructions = f1E7E_parent_instructions;
                        body.emit(f1E7E);

                        /* END IF */

                        body.emit(assign(r1E6E, r1E6F, 0x01));


                     body.instructions = f1E70_parent_instructions;
                     body.emit(f1E70);

                     /* END IF */

                     body.emit(assign(r1E6A, add(r1E6E, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1E82 = lequal(body.constant(int(0)), r1E6A);
                     ir_if *f1E81 = new(mem_ctx) ir_if(operand(r1E82).val);
                     exec_list *const f1E81_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E81->then_instructions;

                        body.emit(assign(r1E69, body.constant(0u), 0x01));

                        ir_variable *const r1E83 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r1E83, lshift(r1E68, r1E6A), 0x01));

                        ir_variable *const r1E84 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1E86 = equal(r1E6A, body.constant(int(0)));
                        ir_if *f1E85 = new(mem_ctx) ir_if(operand(r1E86).val);
                        exec_list *const f1E85_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E85->then_instructions;

                           body.emit(assign(r1E84, r1E67, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1E85->else_instructions;

                           ir_expression *const r1E87 = lshift(r1E67, r1E6A);
                           ir_expression *const r1E88 = neg(r1E6A);
                           ir_expression *const r1E89 = bit_and(r1E88, body.constant(int(31)));
                           ir_expression *const r1E8A = rshift(r1E68, r1E89);
                           body.emit(assign(r1E84, bit_or(r1E87, r1E8A), 0x01));


                        body.instructions = f1E85_parent_instructions;
                        body.emit(f1E85);

                        /* END IF */

                        body.emit(assign(r1E67, r1E84, 0x01));

                        body.emit(assign(r1E68, r1E83, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1E81->else_instructions;

                        ir_variable *const r1E8B = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1E8B, body.constant(0u), 0x01));

                        ir_variable *const r1E8C = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1E8C, neg(r1E6A), 0x01));

                        ir_variable *const r1E8D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1E8D);
                        ir_variable *const r1E8E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1E8E);
                        ir_variable *const r1E8F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1E8F);
                        ir_variable *const r1E90 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1E91 = neg(r1E8C);
                        body.emit(assign(r1E90, bit_and(r1E91, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1E93 = equal(r1E8C, body.constant(int(0)));
                        ir_if *f1E92 = new(mem_ctx) ir_if(operand(r1E93).val);
                        exec_list *const f1E92_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E92->then_instructions;

                           body.emit(assign(r1E8D, r1E8B, 0x01));

                           body.emit(assign(r1E8E, r1E68, 0x01));

                           body.emit(assign(r1E8F, r1E67, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1E92->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1E95 = less(r1E8C, body.constant(int(32)));
                           ir_if *f1E94 = new(mem_ctx) ir_if(operand(r1E95).val);
                           exec_list *const f1E94_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1E94->then_instructions;

                              body.emit(assign(r1E8D, lshift(r1E68, r1E90), 0x01));

                              ir_expression *const r1E96 = lshift(r1E67, r1E90);
                              ir_expression *const r1E97 = rshift(r1E68, r1E8C);
                              body.emit(assign(r1E8E, bit_or(r1E96, r1E97), 0x01));

                              body.emit(assign(r1E8F, rshift(r1E67, r1E8C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1E94->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1E99 = equal(r1E8C, body.constant(int(32)));
                              ir_if *f1E98 = new(mem_ctx) ir_if(operand(r1E99).val);
                              exec_list *const f1E98_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E98->then_instructions;

                                 body.emit(assign(r1E8D, r1E68, 0x01));

                                 body.emit(assign(r1E8E, r1E67, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1E98->else_instructions;

                                 body.emit(assign(r1E8B, bit_or(body.constant(0u), r1E68), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1E9B = less(r1E8C, body.constant(int(64)));
                                 ir_if *f1E9A = new(mem_ctx) ir_if(operand(r1E9B).val);
                                 exec_list *const f1E9A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1E9A->then_instructions;

                                    body.emit(assign(r1E8D, lshift(r1E67, r1E90), 0x01));

                                    ir_expression *const r1E9C = bit_and(r1E8C, body.constant(int(31)));
                                    body.emit(assign(r1E8E, rshift(r1E67, r1E9C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1E9A->else_instructions;

                                    ir_variable *const r1E9D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1E9F = equal(r1E8C, body.constant(int(64)));
                                    ir_if *f1E9E = new(mem_ctx) ir_if(operand(r1E9F).val);
                                    exec_list *const f1E9E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1E9E->then_instructions;

                                       body.emit(assign(r1E9D, r1E67, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1E9E->else_instructions;

                                       ir_expression *const r1EA0 = nequal(r1E67, body.constant(0u));
                                       ir_expression *const r1EA1 = expr(ir_unop_b2i, r1EA0);
                                       body.emit(assign(r1E9D, expr(ir_unop_i2u, r1EA1), 0x01));


                                    body.instructions = f1E9E_parent_instructions;
                                    body.emit(f1E9E);

                                    /* END IF */

                                    body.emit(assign(r1E8D, r1E9D, 0x01));

                                    body.emit(assign(r1E8E, body.constant(0u), 0x01));


                                 body.instructions = f1E9A_parent_instructions;
                                 body.emit(f1E9A);

                                 /* END IF */


                              body.instructions = f1E98_parent_instructions;
                              body.emit(f1E98);

                              /* END IF */

                              body.emit(assign(r1E8F, body.constant(0u), 0x01));


                           body.instructions = f1E94_parent_instructions;
                           body.emit(f1E94);

                           /* END IF */

                           ir_expression *const r1EA2 = nequal(r1E8B, body.constant(0u));
                           ir_expression *const r1EA3 = expr(ir_unop_b2i, r1EA2);
                           ir_expression *const r1EA4 = expr(ir_unop_i2u, r1EA3);
                           body.emit(assign(r1E8D, bit_or(r1E8D, r1EA4), 0x01));


                        body.instructions = f1E92_parent_instructions;
                        body.emit(f1E92);

                        /* END IF */

                        body.emit(assign(r1E67, r1E8F, 0x01));

                        body.emit(assign(r1E68, r1E8E, 0x01));

                        body.emit(assign(r1E69, r1E8D, 0x01));


                     body.instructions = f1E81_parent_instructions;
                     body.emit(f1E81);

                     /* END IF */

                     body.emit(assign(r1E66, sub(r1E66, r1E6A), 0x01));

                     ir_variable *const r1EA5 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1EA5, r1E66, 0x01));

                     ir_variable *const r1EA6 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1EA6, r1E67, 0x01));

                     ir_variable *const r1EA7 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1EA7, r1E68, 0x01));

                     ir_variable *const r1EA8 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r1EA8, r1E69, 0x01));

                     ir_variable *const r1EA9 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r1EA9, body.constant(true), 0x01));

                     ir_variable *const r1EAA = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1EAB = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r1EAB);
                     ir_expression *const r1EAC = expr(ir_unop_u2i, r1E69);
                     body.emit(assign(r1EAB, less(r1EAC, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1EAE = lequal(body.constant(int(2045)), r1E66);
                     ir_if *f1EAD = new(mem_ctx) ir_if(operand(r1EAE).val);
                     exec_list *const f1EAD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1EAD->then_instructions;

                        ir_variable *const r1EAF = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1EB1 = less(body.constant(int(2045)), r1E66);
                        ir_if *f1EB0 = new(mem_ctx) ir_if(operand(r1EB1).val);
                        exec_list *const f1EB0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1EB0->then_instructions;

                           body.emit(assign(r1EAF, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1EB0->else_instructions;

                           ir_variable *const r1EB2 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1EB4 = equal(r1E66, body.constant(int(2045)));
                           ir_if *f1EB3 = new(mem_ctx) ir_if(operand(r1EB4).val);
                           exec_list *const f1EB3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EB3->then_instructions;

                              ir_expression *const r1EB5 = equal(body.constant(2097151u), r1E67);
                              ir_expression *const r1EB6 = equal(body.constant(4294967295u), r1E68);
                              body.emit(assign(r1EB2, logic_and(r1EB5, r1EB6), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1EB3->else_instructions;

                              body.emit(assign(r1EB2, body.constant(false), 0x01));


                           body.instructions = f1EB3_parent_instructions;
                           body.emit(f1EB3);

                           /* END IF */

                           body.emit(assign(r1EAF, logic_and(r1EB2, r1EAB), 0x01));


                        body.instructions = f1EB0_parent_instructions;
                        body.emit(f1EB0);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1EB7 = new(mem_ctx) ir_if(operand(r1EAF).val);
                        exec_list *const f1EB7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1EB7->then_instructions;

                           ir_variable *const r1EB8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1EB8);
                           ir_expression *const r1EB9 = lshift(r1CD4, body.constant(int(31)));
                           body.emit(assign(r1EB8, add(r1EB9, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r1EB8, body.constant(0u), 0x01));

                           body.emit(assign(r1EAA, r1EB8, 0x03));

                           body.emit(assign(r1EA9, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1EB7->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1EBB = less(r1E66, body.constant(int(0)));
                           ir_if *f1EBA = new(mem_ctx) ir_if(operand(r1EBB).val);
                           exec_list *const f1EBA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EBA->then_instructions;

                              ir_variable *const r1EBC = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1EBC, r1E69, 0x01));

                              ir_variable *const r1EBD = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1EBD, neg(r1E66), 0x01));

                              ir_variable *const r1EBE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1EBE);
                              ir_variable *const r1EBF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1EBF);
                              ir_variable *const r1EC0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1EC0);
                              ir_variable *const r1EC1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1EC2 = neg(r1EBD);
                              body.emit(assign(r1EC1, bit_and(r1EC2, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1EC4 = equal(r1EBD, body.constant(int(0)));
                              ir_if *f1EC3 = new(mem_ctx) ir_if(operand(r1EC4).val);
                              exec_list *const f1EC3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1EC3->then_instructions;

                                 body.emit(assign(r1EBE, r1E69, 0x01));

                                 body.emit(assign(r1EBF, r1E68, 0x01));

                                 body.emit(assign(r1EC0, r1E67, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1EC3->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1EC6 = less(r1EBD, body.constant(int(32)));
                                 ir_if *f1EC5 = new(mem_ctx) ir_if(operand(r1EC6).val);
                                 exec_list *const f1EC5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1EC5->then_instructions;

                                    body.emit(assign(r1EBE, lshift(r1E68, r1EC1), 0x01));

                                    ir_expression *const r1EC7 = lshift(r1E67, r1EC1);
                                    ir_expression *const r1EC8 = rshift(r1E68, r1EBD);
                                    body.emit(assign(r1EBF, bit_or(r1EC7, r1EC8), 0x01));

                                    body.emit(assign(r1EC0, rshift(r1E67, r1EBD), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1EC5->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1ECA = equal(r1EBD, body.constant(int(32)));
                                    ir_if *f1EC9 = new(mem_ctx) ir_if(operand(r1ECA).val);
                                    exec_list *const f1EC9_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1EC9->then_instructions;

                                       body.emit(assign(r1EBE, r1E68, 0x01));

                                       body.emit(assign(r1EBF, r1E67, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1EC9->else_instructions;

                                       body.emit(assign(r1EBC, bit_or(r1E69, r1E68), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1ECC = less(r1EBD, body.constant(int(64)));
                                       ir_if *f1ECB = new(mem_ctx) ir_if(operand(r1ECC).val);
                                       exec_list *const f1ECB_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1ECB->then_instructions;

                                          body.emit(assign(r1EBE, lshift(r1E67, r1EC1), 0x01));

                                          ir_expression *const r1ECD = bit_and(r1EBD, body.constant(int(31)));
                                          body.emit(assign(r1EBF, rshift(r1E67, r1ECD), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1ECB->else_instructions;

                                          ir_variable *const r1ECE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1ED0 = equal(r1EBD, body.constant(int(64)));
                                          ir_if *f1ECF = new(mem_ctx) ir_if(operand(r1ED0).val);
                                          exec_list *const f1ECF_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1ECF->then_instructions;

                                             body.emit(assign(r1ECE, r1E67, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1ECF->else_instructions;

                                             ir_expression *const r1ED1 = nequal(r1E67, body.constant(0u));
                                             ir_expression *const r1ED2 = expr(ir_unop_b2i, r1ED1);
                                             body.emit(assign(r1ECE, expr(ir_unop_i2u, r1ED2), 0x01));


                                          body.instructions = f1ECF_parent_instructions;
                                          body.emit(f1ECF);

                                          /* END IF */

                                          body.emit(assign(r1EBE, r1ECE, 0x01));

                                          body.emit(assign(r1EBF, body.constant(0u), 0x01));


                                       body.instructions = f1ECB_parent_instructions;
                                       body.emit(f1ECB);

                                       /* END IF */


                                    body.instructions = f1EC9_parent_instructions;
                                    body.emit(f1EC9);

                                    /* END IF */

                                    body.emit(assign(r1EC0, body.constant(0u), 0x01));


                                 body.instructions = f1EC5_parent_instructions;
                                 body.emit(f1EC5);

                                 /* END IF */

                                 ir_expression *const r1ED3 = nequal(r1EBC, body.constant(0u));
                                 ir_expression *const r1ED4 = expr(ir_unop_b2i, r1ED3);
                                 ir_expression *const r1ED5 = expr(ir_unop_i2u, r1ED4);
                                 body.emit(assign(r1EBE, bit_or(r1EBE, r1ED5), 0x01));


                              body.instructions = f1EC3_parent_instructions;
                              body.emit(f1EC3);

                              /* END IF */

                              body.emit(assign(r1EA6, r1EC0, 0x01));

                              body.emit(assign(r1EA7, r1EBF, 0x01));

                              body.emit(assign(r1EA8, r1EBE, 0x01));

                              body.emit(assign(r1EA5, body.constant(int(0)), 0x01));

                              body.emit(assign(r1EAB, less(r1EBE, body.constant(0u)), 0x01));


                           body.instructions = f1EBA_parent_instructions;
                           body.emit(f1EBA);

                           /* END IF */


                        body.instructions = f1EB7_parent_instructions;
                        body.emit(f1EB7);

                        /* END IF */


                     body.instructions = f1EAD_parent_instructions;
                     body.emit(f1EAD);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f1ED6 = new(mem_ctx) ir_if(operand(r1EA9).val);
                     exec_list *const f1ED6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1ED6->then_instructions;

                        /* IF CONDITION */
                        ir_if *f1ED7 = new(mem_ctx) ir_if(operand(r1EAB).val);
                        exec_list *const f1ED7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1ED7->then_instructions;

                           ir_variable *const r1ED8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r1ED8, add(r1EA7, body.constant(1u)), 0x01));

                           ir_expression *const r1ED9 = less(r1ED8, r1EA7);
                           ir_expression *const r1EDA = expr(ir_unop_b2i, r1ED9);
                           ir_expression *const r1EDB = expr(ir_unop_i2u, r1EDA);
                           body.emit(assign(r1EA6, add(r1EA6, r1EDB), 0x01));

                           ir_expression *const r1EDC = equal(r1EA8, body.constant(0u));
                           ir_expression *const r1EDD = expr(ir_unop_b2i, r1EDC);
                           ir_expression *const r1EDE = expr(ir_unop_i2u, r1EDD);
                           ir_expression *const r1EDF = add(r1EA8, r1EDE);
                           ir_expression *const r1EE0 = bit_and(r1EDF, body.constant(1u));
                           ir_expression *const r1EE1 = expr(ir_unop_bit_not, r1EE0);
                           body.emit(assign(r1EA7, bit_and(r1ED8, r1EE1), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1ED7->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1EE3 = bit_or(r1EA6, r1EA7);
                           ir_expression *const r1EE4 = equal(r1EE3, body.constant(0u));
                           ir_if *f1EE2 = new(mem_ctx) ir_if(operand(r1EE4).val);
                           exec_list *const f1EE2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EE2->then_instructions;

                              body.emit(assign(r1EA5, body.constant(int(0)), 0x01));


                           body.instructions = f1EE2_parent_instructions;
                           body.emit(f1EE2);

                           /* END IF */


                        body.instructions = f1ED7_parent_instructions;
                        body.emit(f1ED7);

                        /* END IF */

                        ir_variable *const r1EE5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r1EE5);
                        ir_expression *const r1EE6 = lshift(r1CD4, body.constant(int(31)));
                        ir_expression *const r1EE7 = expr(ir_unop_i2u, r1EA5);
                        ir_expression *const r1EE8 = lshift(r1EE7, body.constant(int(20)));
                        ir_expression *const r1EE9 = add(r1EE6, r1EE8);
                        body.emit(assign(r1EE5, add(r1EE9, r1EA6), 0x02));

                        body.emit(assign(r1EE5, r1EA7, 0x01));

                        body.emit(assign(r1EAA, r1EE5, 0x03));

                        body.emit(assign(r1EA9, body.constant(false), 0x01));


                     body.instructions = f1ED6_parent_instructions;
                     body.emit(f1ED6);

                     /* END IF */

                     body.emit(assign(r1CD5, r1EAA, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E5E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1EEB = less(r1CDB, r1CD9);
                     ir_if *f1EEA = new(mem_ctx) ir_if(operand(r1EEB).val);
                     exec_list *const f1EEA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1EEA->then_instructions;

                        ir_variable *const r1EEC = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r1EED = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r1EED, sub(r1CDA, r1CDC), 0x01));

                        ir_expression *const r1EEE = sub(r1CD9, r1CDB);
                        ir_expression *const r1EEF = less(r1CDA, r1CDC);
                        ir_expression *const r1EF0 = expr(ir_unop_b2i, r1EEF);
                        ir_expression *const r1EF1 = expr(ir_unop_i2u, r1EF0);
                        body.emit(assign(r1EEC, sub(r1EEE, r1EF1), 0x01));

                        body.emit(assign(r1CD4, bit_xor(r1CD4, body.constant(1u)), 0x01));

                        body.emit(assign(r1CDD, add(r1CD7, body.constant(int(-1))), 0x01));

                        ir_variable *const r1EF2 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r1EF2, add(r1CDD, body.constant(int(-10))), 0x01));

                        ir_variable *const r1EF3 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r1EF3, r1EEC, 0x01));

                        ir_variable *const r1EF4 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r1EF4, r1EED, 0x01));

                        ir_variable *const r1EF5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r1EF5);
                        ir_variable *const r1EF6 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r1EF6);
                        /* IF CONDITION */
                        ir_expression *const r1EF8 = equal(r1EEC, body.constant(0u));
                        ir_if *f1EF7 = new(mem_ctx) ir_if(operand(r1EF8).val);
                        exec_list *const f1EF7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1EF7->then_instructions;

                           body.emit(assign(r1EF3, r1EED, 0x01));

                           body.emit(assign(r1EF4, body.constant(0u), 0x01));

                           body.emit(assign(r1EF2, add(r1EF2, body.constant(int(-32))), 0x01));


                        body.instructions = f1EF7_parent_instructions;
                        body.emit(f1EF7);

                        /* END IF */

                        ir_variable *const r1EF9 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r1EF9, r1EF3, 0x01));

                        ir_variable *const r1EFA = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r1EFB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r1EFB);
                        /* IF CONDITION */
                        ir_expression *const r1EFD = equal(r1EF3, body.constant(0u));
                        ir_if *f1EFC = new(mem_ctx) ir_if(operand(r1EFD).val);
                        exec_list *const f1EFC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1EFC->then_instructions;

                           body.emit(assign(r1EFA, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1EFC->else_instructions;

                           body.emit(assign(r1EFB, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1EFF = bit_and(r1EF3, body.constant(4294901760u));
                           ir_expression *const r1F00 = equal(r1EFF, body.constant(0u));
                           ir_if *f1EFE = new(mem_ctx) ir_if(operand(r1F00).val);
                           exec_list *const f1EFE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EFE->then_instructions;

                              body.emit(assign(r1EFB, body.constant(int(16)), 0x01));

                              body.emit(assign(r1EF9, lshift(r1EF3, body.constant(int(16))), 0x01));


                           body.instructions = f1EFE_parent_instructions;
                           body.emit(f1EFE);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1F02 = bit_and(r1EF9, body.constant(4278190080u));
                           ir_expression *const r1F03 = equal(r1F02, body.constant(0u));
                           ir_if *f1F01 = new(mem_ctx) ir_if(operand(r1F03).val);
                           exec_list *const f1F01_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F01->then_instructions;

                              body.emit(assign(r1EFB, add(r1EFB, body.constant(int(8))), 0x01));

                              body.emit(assign(r1EF9, lshift(r1EF9, body.constant(int(8))), 0x01));


                           body.instructions = f1F01_parent_instructions;
                           body.emit(f1F01);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1F05 = bit_and(r1EF9, body.constant(4026531840u));
                           ir_expression *const r1F06 = equal(r1F05, body.constant(0u));
                           ir_if *f1F04 = new(mem_ctx) ir_if(operand(r1F06).val);
                           exec_list *const f1F04_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F04->then_instructions;

                              body.emit(assign(r1EFB, add(r1EFB, body.constant(int(4))), 0x01));

                              body.emit(assign(r1EF9, lshift(r1EF9, body.constant(int(4))), 0x01));


                           body.instructions = f1F04_parent_instructions;
                           body.emit(f1F04);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1F08 = bit_and(r1EF9, body.constant(3221225472u));
                           ir_expression *const r1F09 = equal(r1F08, body.constant(0u));
                           ir_if *f1F07 = new(mem_ctx) ir_if(operand(r1F09).val);
                           exec_list *const f1F07_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F07->then_instructions;

                              body.emit(assign(r1EFB, add(r1EFB, body.constant(int(2))), 0x01));

                              body.emit(assign(r1EF9, lshift(r1EF9, body.constant(int(2))), 0x01));


                           body.instructions = f1F07_parent_instructions;
                           body.emit(f1F07);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1F0B = bit_and(r1EF9, body.constant(2147483648u));
                           ir_expression *const r1F0C = equal(r1F0B, body.constant(0u));
                           ir_if *f1F0A = new(mem_ctx) ir_if(operand(r1F0C).val);
                           exec_list *const f1F0A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F0A->then_instructions;

                              body.emit(assign(r1EFB, add(r1EFB, body.constant(int(1))), 0x01));


                           body.instructions = f1F0A_parent_instructions;
                           body.emit(f1F0A);

                           /* END IF */

                           body.emit(assign(r1EFA, r1EFB, 0x01));


                        body.instructions = f1EFC_parent_instructions;
                        body.emit(f1EFC);

                        /* END IF */

                        body.emit(assign(r1EF6, add(r1EFA, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1F0E = lequal(body.constant(int(0)), r1EF6);
                        ir_if *f1F0D = new(mem_ctx) ir_if(operand(r1F0E).val);
                        exec_list *const f1F0D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F0D->then_instructions;

                           body.emit(assign(r1EF5, body.constant(0u), 0x01));

                           ir_variable *const r1F0F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r1F0F, lshift(r1EF4, r1EF6), 0x01));

                           ir_variable *const r1F10 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1F12 = equal(r1EF6, body.constant(int(0)));
                           ir_if *f1F11 = new(mem_ctx) ir_if(operand(r1F12).val);
                           exec_list *const f1F11_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F11->then_instructions;

                              body.emit(assign(r1F10, r1EF3, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F11->else_instructions;

                              ir_expression *const r1F13 = lshift(r1EF3, r1EF6);
                              ir_expression *const r1F14 = neg(r1EF6);
                              ir_expression *const r1F15 = bit_and(r1F14, body.constant(int(31)));
                              ir_expression *const r1F16 = rshift(r1EF4, r1F15);
                              body.emit(assign(r1F10, bit_or(r1F13, r1F16), 0x01));


                           body.instructions = f1F11_parent_instructions;
                           body.emit(f1F11);

                           /* END IF */

                           body.emit(assign(r1EF3, r1F10, 0x01));

                           body.emit(assign(r1EF4, r1F0F, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1F0D->else_instructions;

                           ir_variable *const r1F17 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r1F17, body.constant(0u), 0x01));

                           ir_variable *const r1F18 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r1F18, neg(r1EF6), 0x01));

                           ir_variable *const r1F19 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r1F19);
                           ir_variable *const r1F1A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r1F1A);
                           ir_variable *const r1F1B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r1F1B);
                           ir_variable *const r1F1C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r1F1D = neg(r1F18);
                           body.emit(assign(r1F1C, bit_and(r1F1D, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1F1F = equal(r1F18, body.constant(int(0)));
                           ir_if *f1F1E = new(mem_ctx) ir_if(operand(r1F1F).val);
                           exec_list *const f1F1E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F1E->then_instructions;

                              body.emit(assign(r1F19, r1F17, 0x01));

                              body.emit(assign(r1F1A, r1EF4, 0x01));

                              body.emit(assign(r1F1B, r1EF3, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F1E->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1F21 = less(r1F18, body.constant(int(32)));
                              ir_if *f1F20 = new(mem_ctx) ir_if(operand(r1F21).val);
                              exec_list *const f1F20_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F20->then_instructions;

                                 body.emit(assign(r1F19, lshift(r1EF4, r1F1C), 0x01));

                                 ir_expression *const r1F22 = lshift(r1EF3, r1F1C);
                                 ir_expression *const r1F23 = rshift(r1EF4, r1F18);
                                 body.emit(assign(r1F1A, bit_or(r1F22, r1F23), 0x01));

                                 body.emit(assign(r1F1B, rshift(r1EF3, r1F18), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1F20->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1F25 = equal(r1F18, body.constant(int(32)));
                                 ir_if *f1F24 = new(mem_ctx) ir_if(operand(r1F25).val);
                                 exec_list *const f1F24_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1F24->then_instructions;

                                    body.emit(assign(r1F19, r1EF4, 0x01));

                                    body.emit(assign(r1F1A, r1EF3, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1F24->else_instructions;

                                    body.emit(assign(r1F17, bit_or(body.constant(0u), r1EF4), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r1F27 = less(r1F18, body.constant(int(64)));
                                    ir_if *f1F26 = new(mem_ctx) ir_if(operand(r1F27).val);
                                    exec_list *const f1F26_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1F26->then_instructions;

                                       body.emit(assign(r1F19, lshift(r1EF3, r1F1C), 0x01));

                                       ir_expression *const r1F28 = bit_and(r1F18, body.constant(int(31)));
                                       body.emit(assign(r1F1A, rshift(r1EF3, r1F28), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1F26->else_instructions;

                                       ir_variable *const r1F29 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r1F2B = equal(r1F18, body.constant(int(64)));
                                       ir_if *f1F2A = new(mem_ctx) ir_if(operand(r1F2B).val);
                                       exec_list *const f1F2A_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1F2A->then_instructions;

                                          body.emit(assign(r1F29, r1EF3, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1F2A->else_instructions;

                                          ir_expression *const r1F2C = nequal(r1EF3, body.constant(0u));
                                          ir_expression *const r1F2D = expr(ir_unop_b2i, r1F2C);
                                          body.emit(assign(r1F29, expr(ir_unop_i2u, r1F2D), 0x01));


                                       body.instructions = f1F2A_parent_instructions;
                                       body.emit(f1F2A);

                                       /* END IF */

                                       body.emit(assign(r1F19, r1F29, 0x01));

                                       body.emit(assign(r1F1A, body.constant(0u), 0x01));


                                    body.instructions = f1F26_parent_instructions;
                                    body.emit(f1F26);

                                    /* END IF */


                                 body.instructions = f1F24_parent_instructions;
                                 body.emit(f1F24);

                                 /* END IF */

                                 body.emit(assign(r1F1B, body.constant(0u), 0x01));


                              body.instructions = f1F20_parent_instructions;
                              body.emit(f1F20);

                              /* END IF */

                              ir_expression *const r1F2E = nequal(r1F17, body.constant(0u));
                              ir_expression *const r1F2F = expr(ir_unop_b2i, r1F2E);
                              ir_expression *const r1F30 = expr(ir_unop_i2u, r1F2F);
                              body.emit(assign(r1F19, bit_or(r1F19, r1F30), 0x01));


                           body.instructions = f1F1E_parent_instructions;
                           body.emit(f1F1E);

                           /* END IF */

                           body.emit(assign(r1EF3, r1F1B, 0x01));

                           body.emit(assign(r1EF4, r1F1A, 0x01));

                           body.emit(assign(r1EF5, r1F19, 0x01));


                        body.instructions = f1F0D_parent_instructions;
                        body.emit(f1F0D);

                        /* END IF */

                        body.emit(assign(r1EF2, sub(r1EF2, r1EF6), 0x01));

                        ir_variable *const r1F31 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r1F31, r1EF2, 0x01));

                        ir_variable *const r1F32 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r1F32, r1EF3, 0x01));

                        ir_variable *const r1F33 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r1F33, r1EF4, 0x01));

                        ir_variable *const r1F34 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r1F34, r1EF5, 0x01));

                        ir_variable *const r1F35 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r1F35, body.constant(true), 0x01));

                        ir_variable *const r1F36 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r1F37 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r1F37);
                        ir_expression *const r1F38 = expr(ir_unop_u2i, r1EF5);
                        body.emit(assign(r1F37, less(r1F38, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1F3A = lequal(body.constant(int(2045)), r1EF2);
                        ir_if *f1F39 = new(mem_ctx) ir_if(operand(r1F3A).val);
                        exec_list *const f1F39_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F39->then_instructions;

                           ir_variable *const r1F3B = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1F3D = less(body.constant(int(2045)), r1EF2);
                           ir_if *f1F3C = new(mem_ctx) ir_if(operand(r1F3D).val);
                           exec_list *const f1F3C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F3C->then_instructions;

                              body.emit(assign(r1F3B, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F3C->else_instructions;

                              ir_variable *const r1F3E = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1F40 = equal(r1EF2, body.constant(int(2045)));
                              ir_if *f1F3F = new(mem_ctx) ir_if(operand(r1F40).val);
                              exec_list *const f1F3F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F3F->then_instructions;

                                 ir_expression *const r1F41 = equal(body.constant(2097151u), r1EF3);
                                 ir_expression *const r1F42 = equal(body.constant(4294967295u), r1EF4);
                                 body.emit(assign(r1F3E, logic_and(r1F41, r1F42), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1F3F->else_instructions;

                                 body.emit(assign(r1F3E, body.constant(false), 0x01));


                              body.instructions = f1F3F_parent_instructions;
                              body.emit(f1F3F);

                              /* END IF */

                              body.emit(assign(r1F3B, logic_and(r1F3E, r1F37), 0x01));


                           body.instructions = f1F3C_parent_instructions;
                           body.emit(f1F3C);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f1F43 = new(mem_ctx) ir_if(operand(r1F3B).val);
                           exec_list *const f1F43_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F43->then_instructions;

                              ir_variable *const r1F44 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r1F44);
                              ir_expression *const r1F45 = lshift(r1CD4, body.constant(int(31)));
                              body.emit(assign(r1F44, add(r1F45, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r1F44, body.constant(0u), 0x01));

                              body.emit(assign(r1F36, r1F44, 0x03));

                              body.emit(assign(r1F35, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F43->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1F47 = less(r1EF2, body.constant(int(0)));
                              ir_if *f1F46 = new(mem_ctx) ir_if(operand(r1F47).val);
                              exec_list *const f1F46_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F46->then_instructions;

                                 ir_variable *const r1F48 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r1F48, r1EF5, 0x01));

                                 ir_variable *const r1F49 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r1F49, neg(r1EF2), 0x01));

                                 ir_variable *const r1F4A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r1F4A);
                                 ir_variable *const r1F4B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r1F4B);
                                 ir_variable *const r1F4C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r1F4C);
                                 ir_variable *const r1F4D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r1F4E = neg(r1F49);
                                 body.emit(assign(r1F4D, bit_and(r1F4E, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1F50 = equal(r1F49, body.constant(int(0)));
                                 ir_if *f1F4F = new(mem_ctx) ir_if(operand(r1F50).val);
                                 exec_list *const f1F4F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1F4F->then_instructions;

                                    body.emit(assign(r1F4A, r1EF5, 0x01));

                                    body.emit(assign(r1F4B, r1EF4, 0x01));

                                    body.emit(assign(r1F4C, r1EF3, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1F4F->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1F52 = less(r1F49, body.constant(int(32)));
                                    ir_if *f1F51 = new(mem_ctx) ir_if(operand(r1F52).val);
                                    exec_list *const f1F51_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1F51->then_instructions;

                                       body.emit(assign(r1F4A, lshift(r1EF4, r1F4D), 0x01));

                                       ir_expression *const r1F53 = lshift(r1EF3, r1F4D);
                                       ir_expression *const r1F54 = rshift(r1EF4, r1F49);
                                       body.emit(assign(r1F4B, bit_or(r1F53, r1F54), 0x01));

                                       body.emit(assign(r1F4C, rshift(r1EF3, r1F49), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1F51->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r1F56 = equal(r1F49, body.constant(int(32)));
                                       ir_if *f1F55 = new(mem_ctx) ir_if(operand(r1F56).val);
                                       exec_list *const f1F55_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1F55->then_instructions;

                                          body.emit(assign(r1F4A, r1EF4, 0x01));

                                          body.emit(assign(r1F4B, r1EF3, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1F55->else_instructions;

                                          body.emit(assign(r1F48, bit_or(r1EF5, r1EF4), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r1F58 = less(r1F49, body.constant(int(64)));
                                          ir_if *f1F57 = new(mem_ctx) ir_if(operand(r1F58).val);
                                          exec_list *const f1F57_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1F57->then_instructions;

                                             body.emit(assign(r1F4A, lshift(r1EF3, r1F4D), 0x01));

                                             ir_expression *const r1F59 = bit_and(r1F49, body.constant(int(31)));
                                             body.emit(assign(r1F4B, rshift(r1EF3, r1F59), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1F57->else_instructions;

                                             ir_variable *const r1F5A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r1F5C = equal(r1F49, body.constant(int(64)));
                                             ir_if *f1F5B = new(mem_ctx) ir_if(operand(r1F5C).val);
                                             exec_list *const f1F5B_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1F5B->then_instructions;

                                                body.emit(assign(r1F5A, r1EF3, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1F5B->else_instructions;

                                                ir_expression *const r1F5D = nequal(r1EF3, body.constant(0u));
                                                ir_expression *const r1F5E = expr(ir_unop_b2i, r1F5D);
                                                body.emit(assign(r1F5A, expr(ir_unop_i2u, r1F5E), 0x01));


                                             body.instructions = f1F5B_parent_instructions;
                                             body.emit(f1F5B);

                                             /* END IF */

                                             body.emit(assign(r1F4A, r1F5A, 0x01));

                                             body.emit(assign(r1F4B, body.constant(0u), 0x01));


                                          body.instructions = f1F57_parent_instructions;
                                          body.emit(f1F57);

                                          /* END IF */


                                       body.instructions = f1F55_parent_instructions;
                                       body.emit(f1F55);

                                       /* END IF */

                                       body.emit(assign(r1F4C, body.constant(0u), 0x01));


                                    body.instructions = f1F51_parent_instructions;
                                    body.emit(f1F51);

                                    /* END IF */

                                    ir_expression *const r1F5F = nequal(r1F48, body.constant(0u));
                                    ir_expression *const r1F60 = expr(ir_unop_b2i, r1F5F);
                                    ir_expression *const r1F61 = expr(ir_unop_i2u, r1F60);
                                    body.emit(assign(r1F4A, bit_or(r1F4A, r1F61), 0x01));


                                 body.instructions = f1F4F_parent_instructions;
                                 body.emit(f1F4F);

                                 /* END IF */

                                 body.emit(assign(r1F32, r1F4C, 0x01));

                                 body.emit(assign(r1F33, r1F4B, 0x01));

                                 body.emit(assign(r1F34, r1F4A, 0x01));

                                 body.emit(assign(r1F31, body.constant(int(0)), 0x01));

                                 body.emit(assign(r1F37, less(r1F4A, body.constant(0u)), 0x01));


                              body.instructions = f1F46_parent_instructions;
                              body.emit(f1F46);

                              /* END IF */


                           body.instructions = f1F43_parent_instructions;
                           body.emit(f1F43);

                           /* END IF */


                        body.instructions = f1F39_parent_instructions;
                        body.emit(f1F39);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1F62 = new(mem_ctx) ir_if(operand(r1F35).val);
                        exec_list *const f1F62_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F62->then_instructions;

                           /* IF CONDITION */
                           ir_if *f1F63 = new(mem_ctx) ir_if(operand(r1F37).val);
                           exec_list *const f1F63_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F63->then_instructions;

                              ir_variable *const r1F64 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r1F64, add(r1F33, body.constant(1u)), 0x01));

                              ir_expression *const r1F65 = less(r1F64, r1F33);
                              ir_expression *const r1F66 = expr(ir_unop_b2i, r1F65);
                              ir_expression *const r1F67 = expr(ir_unop_i2u, r1F66);
                              body.emit(assign(r1F32, add(r1F32, r1F67), 0x01));

                              ir_expression *const r1F68 = equal(r1F34, body.constant(0u));
                              ir_expression *const r1F69 = expr(ir_unop_b2i, r1F68);
                              ir_expression *const r1F6A = expr(ir_unop_i2u, r1F69);
                              ir_expression *const r1F6B = add(r1F34, r1F6A);
                              ir_expression *const r1F6C = bit_and(r1F6B, body.constant(1u));
                              ir_expression *const r1F6D = expr(ir_unop_bit_not, r1F6C);
                              body.emit(assign(r1F33, bit_and(r1F64, r1F6D), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F63->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1F6F = bit_or(r1F32, r1F33);
                              ir_expression *const r1F70 = equal(r1F6F, body.constant(0u));
                              ir_if *f1F6E = new(mem_ctx) ir_if(operand(r1F70).val);
                              exec_list *const f1F6E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F6E->then_instructions;

                                 body.emit(assign(r1F31, body.constant(int(0)), 0x01));


                              body.instructions = f1F6E_parent_instructions;
                              body.emit(f1F6E);

                              /* END IF */


                           body.instructions = f1F63_parent_instructions;
                           body.emit(f1F63);

                           /* END IF */

                           ir_variable *const r1F71 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1F71);
                           ir_expression *const r1F72 = lshift(r1CD4, body.constant(int(31)));
                           ir_expression *const r1F73 = expr(ir_unop_i2u, r1F31);
                           ir_expression *const r1F74 = lshift(r1F73, body.constant(int(20)));
                           ir_expression *const r1F75 = add(r1F72, r1F74);
                           body.emit(assign(r1F71, add(r1F75, r1F32), 0x02));

                           body.emit(assign(r1F71, r1F33, 0x01));

                           body.emit(assign(r1F36, r1F71, 0x03));

                           body.emit(assign(r1F35, body.constant(false), 0x01));


                        body.instructions = f1F62_parent_instructions;
                        body.emit(f1F62);

                        /* END IF */

                        body.emit(assign(r1CD5, r1F36, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1EEA->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1F77 = less(r1CDA, r1CDC);
                        ir_if *f1F76 = new(mem_ctx) ir_if(operand(r1F77).val);
                        exec_list *const f1F76_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F76->then_instructions;

                           ir_variable *const r1F78 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r1F79 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r1F79, sub(r1CDC, r1CDA), 0x01));

                           ir_expression *const r1F7A = sub(r1CDB, r1CD9);
                           ir_expression *const r1F7B = less(r1CDC, r1CDA);
                           ir_expression *const r1F7C = expr(ir_unop_b2i, r1F7B);
                           ir_expression *const r1F7D = expr(ir_unop_i2u, r1F7C);
                           body.emit(assign(r1F78, sub(r1F7A, r1F7D), 0x01));

                           body.emit(assign(r1CDD, add(r1CD8, body.constant(int(-1))), 0x01));

                           ir_variable *const r1F7E = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r1F7E, add(r1CDD, body.constant(int(-10))), 0x01));

                           ir_variable *const r1F7F = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r1F7F, r1F78, 0x01));

                           ir_variable *const r1F80 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r1F80, r1F79, 0x01));

                           ir_variable *const r1F81 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r1F81);
                           ir_variable *const r1F82 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r1F82);
                           /* IF CONDITION */
                           ir_expression *const r1F84 = equal(r1F78, body.constant(0u));
                           ir_if *f1F83 = new(mem_ctx) ir_if(operand(r1F84).val);
                           exec_list *const f1F83_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F83->then_instructions;

                              body.emit(assign(r1F7F, r1F79, 0x01));

                              body.emit(assign(r1F80, body.constant(0u), 0x01));

                              body.emit(assign(r1F7E, add(r1F7E, body.constant(int(-32))), 0x01));


                           body.instructions = f1F83_parent_instructions;
                           body.emit(f1F83);

                           /* END IF */

                           ir_variable *const r1F85 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r1F85, r1F7F, 0x01));

                           ir_variable *const r1F86 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r1F87 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r1F87);
                           /* IF CONDITION */
                           ir_expression *const r1F89 = equal(r1F7F, body.constant(0u));
                           ir_if *f1F88 = new(mem_ctx) ir_if(operand(r1F89).val);
                           exec_list *const f1F88_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F88->then_instructions;

                              body.emit(assign(r1F86, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F88->else_instructions;

                              body.emit(assign(r1F87, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1F8B = bit_and(r1F7F, body.constant(4294901760u));
                              ir_expression *const r1F8C = equal(r1F8B, body.constant(0u));
                              ir_if *f1F8A = new(mem_ctx) ir_if(operand(r1F8C).val);
                              exec_list *const f1F8A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F8A->then_instructions;

                                 body.emit(assign(r1F87, body.constant(int(16)), 0x01));

                                 body.emit(assign(r1F85, lshift(r1F7F, body.constant(int(16))), 0x01));


                              body.instructions = f1F8A_parent_instructions;
                              body.emit(f1F8A);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1F8E = bit_and(r1F85, body.constant(4278190080u));
                              ir_expression *const r1F8F = equal(r1F8E, body.constant(0u));
                              ir_if *f1F8D = new(mem_ctx) ir_if(operand(r1F8F).val);
                              exec_list *const f1F8D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F8D->then_instructions;

                                 body.emit(assign(r1F87, add(r1F87, body.constant(int(8))), 0x01));

                                 body.emit(assign(r1F85, lshift(r1F85, body.constant(int(8))), 0x01));


                              body.instructions = f1F8D_parent_instructions;
                              body.emit(f1F8D);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1F91 = bit_and(r1F85, body.constant(4026531840u));
                              ir_expression *const r1F92 = equal(r1F91, body.constant(0u));
                              ir_if *f1F90 = new(mem_ctx) ir_if(operand(r1F92).val);
                              exec_list *const f1F90_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F90->then_instructions;

                                 body.emit(assign(r1F87, add(r1F87, body.constant(int(4))), 0x01));

                                 body.emit(assign(r1F85, lshift(r1F85, body.constant(int(4))), 0x01));


                              body.instructions = f1F90_parent_instructions;
                              body.emit(f1F90);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1F94 = bit_and(r1F85, body.constant(3221225472u));
                              ir_expression *const r1F95 = equal(r1F94, body.constant(0u));
                              ir_if *f1F93 = new(mem_ctx) ir_if(operand(r1F95).val);
                              exec_list *const f1F93_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F93->then_instructions;

                                 body.emit(assign(r1F87, add(r1F87, body.constant(int(2))), 0x01));

                                 body.emit(assign(r1F85, lshift(r1F85, body.constant(int(2))), 0x01));


                              body.instructions = f1F93_parent_instructions;
                              body.emit(f1F93);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1F97 = bit_and(r1F85, body.constant(2147483648u));
                              ir_expression *const r1F98 = equal(r1F97, body.constant(0u));
                              ir_if *f1F96 = new(mem_ctx) ir_if(operand(r1F98).val);
                              exec_list *const f1F96_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F96->then_instructions;

                                 body.emit(assign(r1F87, add(r1F87, body.constant(int(1))), 0x01));


                              body.instructions = f1F96_parent_instructions;
                              body.emit(f1F96);

                              /* END IF */

                              body.emit(assign(r1F86, r1F87, 0x01));


                           body.instructions = f1F88_parent_instructions;
                           body.emit(f1F88);

                           /* END IF */

                           body.emit(assign(r1F82, add(r1F86, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1F9A = lequal(body.constant(int(0)), r1F82);
                           ir_if *f1F99 = new(mem_ctx) ir_if(operand(r1F9A).val);
                           exec_list *const f1F99_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F99->then_instructions;

                              body.emit(assign(r1F81, body.constant(0u), 0x01));

                              ir_variable *const r1F9B = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r1F9B, lshift(r1F80, r1F82), 0x01));

                              ir_variable *const r1F9C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1F9E = equal(r1F82, body.constant(int(0)));
                              ir_if *f1F9D = new(mem_ctx) ir_if(operand(r1F9E).val);
                              exec_list *const f1F9D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F9D->then_instructions;

                                 body.emit(assign(r1F9C, r1F7F, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1F9D->else_instructions;

                                 ir_expression *const r1F9F = lshift(r1F7F, r1F82);
                                 ir_expression *const r1FA0 = neg(r1F82);
                                 ir_expression *const r1FA1 = bit_and(r1FA0, body.constant(int(31)));
                                 ir_expression *const r1FA2 = rshift(r1F80, r1FA1);
                                 body.emit(assign(r1F9C, bit_or(r1F9F, r1FA2), 0x01));


                              body.instructions = f1F9D_parent_instructions;
                              body.emit(f1F9D);

                              /* END IF */

                              body.emit(assign(r1F7F, r1F9C, 0x01));

                              body.emit(assign(r1F80, r1F9B, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F99->else_instructions;

                              ir_variable *const r1FA3 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1FA3, body.constant(0u), 0x01));

                              ir_variable *const r1FA4 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1FA4, neg(r1F82), 0x01));

                              ir_variable *const r1FA5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1FA5);
                              ir_variable *const r1FA6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1FA6);
                              ir_variable *const r1FA7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1FA7);
                              ir_variable *const r1FA8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1FA9 = neg(r1FA4);
                              body.emit(assign(r1FA8, bit_and(r1FA9, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1FAB = equal(r1FA4, body.constant(int(0)));
                              ir_if *f1FAA = new(mem_ctx) ir_if(operand(r1FAB).val);
                              exec_list *const f1FAA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FAA->then_instructions;

                                 body.emit(assign(r1FA5, r1FA3, 0x01));

                                 body.emit(assign(r1FA6, r1F80, 0x01));

                                 body.emit(assign(r1FA7, r1F7F, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1FAA->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1FAD = less(r1FA4, body.constant(int(32)));
                                 ir_if *f1FAC = new(mem_ctx) ir_if(operand(r1FAD).val);
                                 exec_list *const f1FAC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FAC->then_instructions;

                                    body.emit(assign(r1FA5, lshift(r1F80, r1FA8), 0x01));

                                    ir_expression *const r1FAE = lshift(r1F7F, r1FA8);
                                    ir_expression *const r1FAF = rshift(r1F80, r1FA4);
                                    body.emit(assign(r1FA6, bit_or(r1FAE, r1FAF), 0x01));

                                    body.emit(assign(r1FA7, rshift(r1F7F, r1FA4), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1FAC->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1FB1 = equal(r1FA4, body.constant(int(32)));
                                    ir_if *f1FB0 = new(mem_ctx) ir_if(operand(r1FB1).val);
                                    exec_list *const f1FB0_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1FB0->then_instructions;

                                       body.emit(assign(r1FA5, r1F80, 0x01));

                                       body.emit(assign(r1FA6, r1F7F, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1FB0->else_instructions;

                                       body.emit(assign(r1FA3, bit_or(body.constant(0u), r1F80), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1FB3 = less(r1FA4, body.constant(int(64)));
                                       ir_if *f1FB2 = new(mem_ctx) ir_if(operand(r1FB3).val);
                                       exec_list *const f1FB2_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1FB2->then_instructions;

                                          body.emit(assign(r1FA5, lshift(r1F7F, r1FA8), 0x01));

                                          ir_expression *const r1FB4 = bit_and(r1FA4, body.constant(int(31)));
                                          body.emit(assign(r1FA6, rshift(r1F7F, r1FB4), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1FB2->else_instructions;

                                          ir_variable *const r1FB5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1FB7 = equal(r1FA4, body.constant(int(64)));
                                          ir_if *f1FB6 = new(mem_ctx) ir_if(operand(r1FB7).val);
                                          exec_list *const f1FB6_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1FB6->then_instructions;

                                             body.emit(assign(r1FB5, r1F7F, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1FB6->else_instructions;

                                             ir_expression *const r1FB8 = nequal(r1F7F, body.constant(0u));
                                             ir_expression *const r1FB9 = expr(ir_unop_b2i, r1FB8);
                                             body.emit(assign(r1FB5, expr(ir_unop_i2u, r1FB9), 0x01));


                                          body.instructions = f1FB6_parent_instructions;
                                          body.emit(f1FB6);

                                          /* END IF */

                                          body.emit(assign(r1FA5, r1FB5, 0x01));

                                          body.emit(assign(r1FA6, body.constant(0u), 0x01));


                                       body.instructions = f1FB2_parent_instructions;
                                       body.emit(f1FB2);

                                       /* END IF */


                                    body.instructions = f1FB0_parent_instructions;
                                    body.emit(f1FB0);

                                    /* END IF */

                                    body.emit(assign(r1FA7, body.constant(0u), 0x01));


                                 body.instructions = f1FAC_parent_instructions;
                                 body.emit(f1FAC);

                                 /* END IF */

                                 ir_expression *const r1FBA = nequal(r1FA3, body.constant(0u));
                                 ir_expression *const r1FBB = expr(ir_unop_b2i, r1FBA);
                                 ir_expression *const r1FBC = expr(ir_unop_i2u, r1FBB);
                                 body.emit(assign(r1FA5, bit_or(r1FA5, r1FBC), 0x01));


                              body.instructions = f1FAA_parent_instructions;
                              body.emit(f1FAA);

                              /* END IF */

                              body.emit(assign(r1F7F, r1FA7, 0x01));

                              body.emit(assign(r1F80, r1FA6, 0x01));

                              body.emit(assign(r1F81, r1FA5, 0x01));


                           body.instructions = f1F99_parent_instructions;
                           body.emit(f1F99);

                           /* END IF */

                           body.emit(assign(r1F7E, sub(r1F7E, r1F82), 0x01));

                           ir_variable *const r1FBD = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r1FBD, r1F7E, 0x01));

                           ir_variable *const r1FBE = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r1FBE, r1F7F, 0x01));

                           ir_variable *const r1FBF = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r1FBF, r1F80, 0x01));

                           ir_variable *const r1FC0 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r1FC0, r1F81, 0x01));

                           ir_variable *const r1FC1 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r1FC1, body.constant(true), 0x01));

                           ir_variable *const r1FC2 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r1FC3 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r1FC3);
                           ir_expression *const r1FC4 = expr(ir_unop_u2i, r1F81);
                           body.emit(assign(r1FC3, less(r1FC4, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1FC6 = lequal(body.constant(int(2045)), r1F7E);
                           ir_if *f1FC5 = new(mem_ctx) ir_if(operand(r1FC6).val);
                           exec_list *const f1FC5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1FC5->then_instructions;

                              ir_variable *const r1FC7 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1FC9 = less(body.constant(int(2045)), r1F7E);
                              ir_if *f1FC8 = new(mem_ctx) ir_if(operand(r1FC9).val);
                              exec_list *const f1FC8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FC8->then_instructions;

                                 body.emit(assign(r1FC7, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1FC8->else_instructions;

                                 ir_variable *const r1FCA = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1FCC = equal(r1F7E, body.constant(int(2045)));
                                 ir_if *f1FCB = new(mem_ctx) ir_if(operand(r1FCC).val);
                                 exec_list *const f1FCB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FCB->then_instructions;

                                    ir_expression *const r1FCD = equal(body.constant(2097151u), r1F7F);
                                    ir_expression *const r1FCE = equal(body.constant(4294967295u), r1F80);
                                    body.emit(assign(r1FCA, logic_and(r1FCD, r1FCE), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1FCB->else_instructions;

                                    body.emit(assign(r1FCA, body.constant(false), 0x01));


                                 body.instructions = f1FCB_parent_instructions;
                                 body.emit(f1FCB);

                                 /* END IF */

                                 body.emit(assign(r1FC7, logic_and(r1FCA, r1FC3), 0x01));


                              body.instructions = f1FC8_parent_instructions;
                              body.emit(f1FC8);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f1FCF = new(mem_ctx) ir_if(operand(r1FC7).val);
                              exec_list *const f1FCF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FCF->then_instructions;

                                 ir_variable *const r1FD0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r1FD0);
                                 ir_expression *const r1FD1 = lshift(r1CD4, body.constant(int(31)));
                                 body.emit(assign(r1FD0, add(r1FD1, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r1FD0, body.constant(0u), 0x01));

                                 body.emit(assign(r1FC2, r1FD0, 0x03));

                                 body.emit(assign(r1FC1, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1FCF->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1FD3 = less(r1F7E, body.constant(int(0)));
                                 ir_if *f1FD2 = new(mem_ctx) ir_if(operand(r1FD3).val);
                                 exec_list *const f1FD2_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FD2->then_instructions;

                                    ir_variable *const r1FD4 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r1FD4, r1F81, 0x01));

                                    ir_variable *const r1FD5 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r1FD5, neg(r1F7E), 0x01));

                                    ir_variable *const r1FD6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r1FD6);
                                    ir_variable *const r1FD7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r1FD7);
                                    ir_variable *const r1FD8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r1FD8);
                                    ir_variable *const r1FD9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r1FDA = neg(r1FD5);
                                    body.emit(assign(r1FD9, bit_and(r1FDA, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r1FDC = equal(r1FD5, body.constant(int(0)));
                                    ir_if *f1FDB = new(mem_ctx) ir_if(operand(r1FDC).val);
                                    exec_list *const f1FDB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1FDB->then_instructions;

                                       body.emit(assign(r1FD6, r1F81, 0x01));

                                       body.emit(assign(r1FD7, r1F80, 0x01));

                                       body.emit(assign(r1FD8, r1F7F, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1FDB->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r1FDE = less(r1FD5, body.constant(int(32)));
                                       ir_if *f1FDD = new(mem_ctx) ir_if(operand(r1FDE).val);
                                       exec_list *const f1FDD_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1FDD->then_instructions;

                                          body.emit(assign(r1FD6, lshift(r1F80, r1FD9), 0x01));

                                          ir_expression *const r1FDF = lshift(r1F7F, r1FD9);
                                          ir_expression *const r1FE0 = rshift(r1F80, r1FD5);
                                          body.emit(assign(r1FD7, bit_or(r1FDF, r1FE0), 0x01));

                                          body.emit(assign(r1FD8, rshift(r1F7F, r1FD5), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1FDD->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r1FE2 = equal(r1FD5, body.constant(int(32)));
                                          ir_if *f1FE1 = new(mem_ctx) ir_if(operand(r1FE2).val);
                                          exec_list *const f1FE1_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1FE1->then_instructions;

                                             body.emit(assign(r1FD6, r1F80, 0x01));

                                             body.emit(assign(r1FD7, r1F7F, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1FE1->else_instructions;

                                             body.emit(assign(r1FD4, bit_or(r1F81, r1F80), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r1FE4 = less(r1FD5, body.constant(int(64)));
                                             ir_if *f1FE3 = new(mem_ctx) ir_if(operand(r1FE4).val);
                                             exec_list *const f1FE3_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1FE3->then_instructions;

                                                body.emit(assign(r1FD6, lshift(r1F7F, r1FD9), 0x01));

                                                ir_expression *const r1FE5 = bit_and(r1FD5, body.constant(int(31)));
                                                body.emit(assign(r1FD7, rshift(r1F7F, r1FE5), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1FE3->else_instructions;

                                                ir_variable *const r1FE6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r1FE8 = equal(r1FD5, body.constant(int(64)));
                                                ir_if *f1FE7 = new(mem_ctx) ir_if(operand(r1FE8).val);
                                                exec_list *const f1FE7_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f1FE7->then_instructions;

                                                   body.emit(assign(r1FE6, r1F7F, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f1FE7->else_instructions;

                                                   ir_expression *const r1FE9 = nequal(r1F7F, body.constant(0u));
                                                   ir_expression *const r1FEA = expr(ir_unop_b2i, r1FE9);
                                                   body.emit(assign(r1FE6, expr(ir_unop_i2u, r1FEA), 0x01));


                                                body.instructions = f1FE7_parent_instructions;
                                                body.emit(f1FE7);

                                                /* END IF */

                                                body.emit(assign(r1FD6, r1FE6, 0x01));

                                                body.emit(assign(r1FD7, body.constant(0u), 0x01));


                                             body.instructions = f1FE3_parent_instructions;
                                             body.emit(f1FE3);

                                             /* END IF */


                                          body.instructions = f1FE1_parent_instructions;
                                          body.emit(f1FE1);

                                          /* END IF */

                                          body.emit(assign(r1FD8, body.constant(0u), 0x01));


                                       body.instructions = f1FDD_parent_instructions;
                                       body.emit(f1FDD);

                                       /* END IF */

                                       ir_expression *const r1FEB = nequal(r1FD4, body.constant(0u));
                                       ir_expression *const r1FEC = expr(ir_unop_b2i, r1FEB);
                                       ir_expression *const r1FED = expr(ir_unop_i2u, r1FEC);
                                       body.emit(assign(r1FD6, bit_or(r1FD6, r1FED), 0x01));


                                    body.instructions = f1FDB_parent_instructions;
                                    body.emit(f1FDB);

                                    /* END IF */

                                    body.emit(assign(r1FBE, r1FD8, 0x01));

                                    body.emit(assign(r1FBF, r1FD7, 0x01));

                                    body.emit(assign(r1FC0, r1FD6, 0x01));

                                    body.emit(assign(r1FBD, body.constant(int(0)), 0x01));

                                    body.emit(assign(r1FC3, less(r1FD6, body.constant(0u)), 0x01));


                                 body.instructions = f1FD2_parent_instructions;
                                 body.emit(f1FD2);

                                 /* END IF */


                              body.instructions = f1FCF_parent_instructions;
                              body.emit(f1FCF);

                              /* END IF */


                           body.instructions = f1FC5_parent_instructions;
                           body.emit(f1FC5);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f1FEE = new(mem_ctx) ir_if(operand(r1FC1).val);
                           exec_list *const f1FEE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1FEE->then_instructions;

                              /* IF CONDITION */
                              ir_if *f1FEF = new(mem_ctx) ir_if(operand(r1FC3).val);
                              exec_list *const f1FEF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FEF->then_instructions;

                                 ir_variable *const r1FF0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r1FF0, add(r1FBF, body.constant(1u)), 0x01));

                                 ir_expression *const r1FF1 = less(r1FF0, r1FBF);
                                 ir_expression *const r1FF2 = expr(ir_unop_b2i, r1FF1);
                                 ir_expression *const r1FF3 = expr(ir_unop_i2u, r1FF2);
                                 body.emit(assign(r1FBE, add(r1FBE, r1FF3), 0x01));

                                 ir_expression *const r1FF4 = equal(r1FC0, body.constant(0u));
                                 ir_expression *const r1FF5 = expr(ir_unop_b2i, r1FF4);
                                 ir_expression *const r1FF6 = expr(ir_unop_i2u, r1FF5);
                                 ir_expression *const r1FF7 = add(r1FC0, r1FF6);
                                 ir_expression *const r1FF8 = bit_and(r1FF7, body.constant(1u));
                                 ir_expression *const r1FF9 = expr(ir_unop_bit_not, r1FF8);
                                 body.emit(assign(r1FBF, bit_and(r1FF0, r1FF9), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1FEF->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1FFB = bit_or(r1FBE, r1FBF);
                                 ir_expression *const r1FFC = equal(r1FFB, body.constant(0u));
                                 ir_if *f1FFA = new(mem_ctx) ir_if(operand(r1FFC).val);
                                 exec_list *const f1FFA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FFA->then_instructions;

                                    body.emit(assign(r1FBD, body.constant(int(0)), 0x01));


                                 body.instructions = f1FFA_parent_instructions;
                                 body.emit(f1FFA);

                                 /* END IF */


                              body.instructions = f1FEF_parent_instructions;
                              body.emit(f1FEF);

                              /* END IF */

                              ir_variable *const r1FFD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r1FFD);
                              ir_expression *const r1FFE = lshift(r1CD4, body.constant(int(31)));
                              ir_expression *const r1FFF = expr(ir_unop_i2u, r1FBD);
                              ir_expression *const r2000 = lshift(r1FFF, body.constant(int(20)));
                              ir_expression *const r2001 = add(r1FFE, r2000);
                              body.emit(assign(r1FFD, add(r2001, r1FBE), 0x02));

                              body.emit(assign(r1FFD, r1FBF, 0x01));

                              body.emit(assign(r1FC2, r1FFD, 0x03));

                              body.emit(assign(r1FC1, body.constant(false), 0x01));


                           body.instructions = f1FEE_parent_instructions;
                           body.emit(f1FEE);

                           /* END IF */

                           body.emit(assign(r1CD5, r1FC2, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1F76->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2003 = less(r1CDC, r1CDA);
                           ir_if *f2002 = new(mem_ctx) ir_if(operand(r2003).val);
                           exec_list *const f2002_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2002->then_instructions;

                              ir_variable *const r2004 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r2005 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2005, sub(r1CDA, r1CDC), 0x01));

                              ir_expression *const r2006 = sub(r1CD9, r1CDB);
                              ir_expression *const r2007 = less(r1CDA, r1CDC);
                              ir_expression *const r2008 = expr(ir_unop_b2i, r2007);
                              ir_expression *const r2009 = expr(ir_unop_i2u, r2008);
                              body.emit(assign(r2004, sub(r2006, r2009), 0x01));

                              body.emit(assign(r1CD4, bit_xor(r1CD4, body.constant(1u)), 0x01));

                              body.emit(assign(r1CDD, add(r1CD7, body.constant(int(-1))), 0x01));

                              ir_variable *const r200A = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r200A, add(r1CDD, body.constant(int(-10))), 0x01));

                              ir_variable *const r200B = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r200B, r2004, 0x01));

                              ir_variable *const r200C = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r200C, r2005, 0x01));

                              ir_variable *const r200D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r200D);
                              ir_variable *const r200E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r200E);
                              /* IF CONDITION */
                              ir_expression *const r2010 = equal(r2004, body.constant(0u));
                              ir_if *f200F = new(mem_ctx) ir_if(operand(r2010).val);
                              exec_list *const f200F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f200F->then_instructions;

                                 body.emit(assign(r200B, r2005, 0x01));

                                 body.emit(assign(r200C, body.constant(0u), 0x01));

                                 body.emit(assign(r200A, add(r200A, body.constant(int(-32))), 0x01));


                              body.instructions = f200F_parent_instructions;
                              body.emit(f200F);

                              /* END IF */

                              ir_variable *const r2011 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r2011, r200B, 0x01));

                              ir_variable *const r2012 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r2013 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2013);
                              /* IF CONDITION */
                              ir_expression *const r2015 = equal(r200B, body.constant(0u));
                              ir_if *f2014 = new(mem_ctx) ir_if(operand(r2015).val);
                              exec_list *const f2014_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2014->then_instructions;

                                 body.emit(assign(r2012, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2014->else_instructions;

                                 body.emit(assign(r2013, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2017 = bit_and(r200B, body.constant(4294901760u));
                                 ir_expression *const r2018 = equal(r2017, body.constant(0u));
                                 ir_if *f2016 = new(mem_ctx) ir_if(operand(r2018).val);
                                 exec_list *const f2016_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2016->then_instructions;

                                    body.emit(assign(r2013, body.constant(int(16)), 0x01));

                                    body.emit(assign(r2011, lshift(r200B, body.constant(int(16))), 0x01));


                                 body.instructions = f2016_parent_instructions;
                                 body.emit(f2016);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r201A = bit_and(r2011, body.constant(4278190080u));
                                 ir_expression *const r201B = equal(r201A, body.constant(0u));
                                 ir_if *f2019 = new(mem_ctx) ir_if(operand(r201B).val);
                                 exec_list *const f2019_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2019->then_instructions;

                                    body.emit(assign(r2013, add(r2013, body.constant(int(8))), 0x01));

                                    body.emit(assign(r2011, lshift(r2011, body.constant(int(8))), 0x01));


                                 body.instructions = f2019_parent_instructions;
                                 body.emit(f2019);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r201D = bit_and(r2011, body.constant(4026531840u));
                                 ir_expression *const r201E = equal(r201D, body.constant(0u));
                                 ir_if *f201C = new(mem_ctx) ir_if(operand(r201E).val);
                                 exec_list *const f201C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f201C->then_instructions;

                                    body.emit(assign(r2013, add(r2013, body.constant(int(4))), 0x01));

                                    body.emit(assign(r2011, lshift(r2011, body.constant(int(4))), 0x01));


                                 body.instructions = f201C_parent_instructions;
                                 body.emit(f201C);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2020 = bit_and(r2011, body.constant(3221225472u));
                                 ir_expression *const r2021 = equal(r2020, body.constant(0u));
                                 ir_if *f201F = new(mem_ctx) ir_if(operand(r2021).val);
                                 exec_list *const f201F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f201F->then_instructions;

                                    body.emit(assign(r2013, add(r2013, body.constant(int(2))), 0x01));

                                    body.emit(assign(r2011, lshift(r2011, body.constant(int(2))), 0x01));


                                 body.instructions = f201F_parent_instructions;
                                 body.emit(f201F);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2023 = bit_and(r2011, body.constant(2147483648u));
                                 ir_expression *const r2024 = equal(r2023, body.constant(0u));
                                 ir_if *f2022 = new(mem_ctx) ir_if(operand(r2024).val);
                                 exec_list *const f2022_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2022->then_instructions;

                                    body.emit(assign(r2013, add(r2013, body.constant(int(1))), 0x01));


                                 body.instructions = f2022_parent_instructions;
                                 body.emit(f2022);

                                 /* END IF */

                                 body.emit(assign(r2012, r2013, 0x01));


                              body.instructions = f2014_parent_instructions;
                              body.emit(f2014);

                              /* END IF */

                              body.emit(assign(r200E, add(r2012, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2026 = lequal(body.constant(int(0)), r200E);
                              ir_if *f2025 = new(mem_ctx) ir_if(operand(r2026).val);
                              exec_list *const f2025_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2025->then_instructions;

                                 body.emit(assign(r200D, body.constant(0u), 0x01));

                                 ir_variable *const r2027 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r2027, lshift(r200C, r200E), 0x01));

                                 ir_variable *const r2028 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r202A = equal(r200E, body.constant(int(0)));
                                 ir_if *f2029 = new(mem_ctx) ir_if(operand(r202A).val);
                                 exec_list *const f2029_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2029->then_instructions;

                                    body.emit(assign(r2028, r200B, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2029->else_instructions;

                                    ir_expression *const r202B = lshift(r200B, r200E);
                                    ir_expression *const r202C = neg(r200E);
                                    ir_expression *const r202D = bit_and(r202C, body.constant(int(31)));
                                    ir_expression *const r202E = rshift(r200C, r202D);
                                    body.emit(assign(r2028, bit_or(r202B, r202E), 0x01));


                                 body.instructions = f2029_parent_instructions;
                                 body.emit(f2029);

                                 /* END IF */

                                 body.emit(assign(r200B, r2028, 0x01));

                                 body.emit(assign(r200C, r2027, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2025->else_instructions;

                                 ir_variable *const r202F = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r202F, body.constant(0u), 0x01));

                                 ir_variable *const r2030 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2030, neg(r200E), 0x01));

                                 ir_variable *const r2031 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2031);
                                 ir_variable *const r2032 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2032);
                                 ir_variable *const r2033 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2033);
                                 ir_variable *const r2034 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2035 = neg(r2030);
                                 body.emit(assign(r2034, bit_and(r2035, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2037 = equal(r2030, body.constant(int(0)));
                                 ir_if *f2036 = new(mem_ctx) ir_if(operand(r2037).val);
                                 exec_list *const f2036_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2036->then_instructions;

                                    body.emit(assign(r2031, r202F, 0x01));

                                    body.emit(assign(r2032, r200C, 0x01));

                                    body.emit(assign(r2033, r200B, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2036->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2039 = less(r2030, body.constant(int(32)));
                                    ir_if *f2038 = new(mem_ctx) ir_if(operand(r2039).val);
                                    exec_list *const f2038_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2038->then_instructions;

                                       body.emit(assign(r2031, lshift(r200C, r2034), 0x01));

                                       ir_expression *const r203A = lshift(r200B, r2034);
                                       ir_expression *const r203B = rshift(r200C, r2030);
                                       body.emit(assign(r2032, bit_or(r203A, r203B), 0x01));

                                       body.emit(assign(r2033, rshift(r200B, r2030), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2038->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r203D = equal(r2030, body.constant(int(32)));
                                       ir_if *f203C = new(mem_ctx) ir_if(operand(r203D).val);
                                       exec_list *const f203C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f203C->then_instructions;

                                          body.emit(assign(r2031, r200C, 0x01));

                                          body.emit(assign(r2032, r200B, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f203C->else_instructions;

                                          body.emit(assign(r202F, bit_or(body.constant(0u), r200C), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r203F = less(r2030, body.constant(int(64)));
                                          ir_if *f203E = new(mem_ctx) ir_if(operand(r203F).val);
                                          exec_list *const f203E_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f203E->then_instructions;

                                             body.emit(assign(r2031, lshift(r200B, r2034), 0x01));

                                             ir_expression *const r2040 = bit_and(r2030, body.constant(int(31)));
                                             body.emit(assign(r2032, rshift(r200B, r2040), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f203E->else_instructions;

                                             ir_variable *const r2041 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2043 = equal(r2030, body.constant(int(64)));
                                             ir_if *f2042 = new(mem_ctx) ir_if(operand(r2043).val);
                                             exec_list *const f2042_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2042->then_instructions;

                                                body.emit(assign(r2041, r200B, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2042->else_instructions;

                                                ir_expression *const r2044 = nequal(r200B, body.constant(0u));
                                                ir_expression *const r2045 = expr(ir_unop_b2i, r2044);
                                                body.emit(assign(r2041, expr(ir_unop_i2u, r2045), 0x01));


                                             body.instructions = f2042_parent_instructions;
                                             body.emit(f2042);

                                             /* END IF */

                                             body.emit(assign(r2031, r2041, 0x01));

                                             body.emit(assign(r2032, body.constant(0u), 0x01));


                                          body.instructions = f203E_parent_instructions;
                                          body.emit(f203E);

                                          /* END IF */


                                       body.instructions = f203C_parent_instructions;
                                       body.emit(f203C);

                                       /* END IF */

                                       body.emit(assign(r2033, body.constant(0u), 0x01));


                                    body.instructions = f2038_parent_instructions;
                                    body.emit(f2038);

                                    /* END IF */

                                    ir_expression *const r2046 = nequal(r202F, body.constant(0u));
                                    ir_expression *const r2047 = expr(ir_unop_b2i, r2046);
                                    ir_expression *const r2048 = expr(ir_unop_i2u, r2047);
                                    body.emit(assign(r2031, bit_or(r2031, r2048), 0x01));


                                 body.instructions = f2036_parent_instructions;
                                 body.emit(f2036);

                                 /* END IF */

                                 body.emit(assign(r200B, r2033, 0x01));

                                 body.emit(assign(r200C, r2032, 0x01));

                                 body.emit(assign(r200D, r2031, 0x01));


                              body.instructions = f2025_parent_instructions;
                              body.emit(f2025);

                              /* END IF */

                              body.emit(assign(r200A, sub(r200A, r200E), 0x01));

                              ir_variable *const r2049 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2049, r200A, 0x01));

                              ir_variable *const r204A = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r204A, r200B, 0x01));

                              ir_variable *const r204B = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r204B, r200C, 0x01));

                              ir_variable *const r204C = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r204C, r200D, 0x01));

                              ir_variable *const r204D = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r204D, body.constant(true), 0x01));

                              ir_variable *const r204E = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r204F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r204F);
                              ir_expression *const r2050 = expr(ir_unop_u2i, r200D);
                              body.emit(assign(r204F, less(r2050, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2052 = lequal(body.constant(int(2045)), r200A);
                              ir_if *f2051 = new(mem_ctx) ir_if(operand(r2052).val);
                              exec_list *const f2051_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2051->then_instructions;

                                 ir_variable *const r2053 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2055 = less(body.constant(int(2045)), r200A);
                                 ir_if *f2054 = new(mem_ctx) ir_if(operand(r2055).val);
                                 exec_list *const f2054_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2054->then_instructions;

                                    body.emit(assign(r2053, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2054->else_instructions;

                                    ir_variable *const r2056 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2058 = equal(r200A, body.constant(int(2045)));
                                    ir_if *f2057 = new(mem_ctx) ir_if(operand(r2058).val);
                                    exec_list *const f2057_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2057->then_instructions;

                                       ir_expression *const r2059 = equal(body.constant(2097151u), r200B);
                                       ir_expression *const r205A = equal(body.constant(4294967295u), r200C);
                                       body.emit(assign(r2056, logic_and(r2059, r205A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2057->else_instructions;

                                       body.emit(assign(r2056, body.constant(false), 0x01));


                                    body.instructions = f2057_parent_instructions;
                                    body.emit(f2057);

                                    /* END IF */

                                    body.emit(assign(r2053, logic_and(r2056, r204F), 0x01));


                                 body.instructions = f2054_parent_instructions;
                                 body.emit(f2054);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f205B = new(mem_ctx) ir_if(operand(r2053).val);
                                 exec_list *const f205B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f205B->then_instructions;

                                    ir_variable *const r205C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r205C);
                                    ir_expression *const r205D = lshift(r1CD4, body.constant(int(31)));
                                    body.emit(assign(r205C, add(r205D, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r205C, body.constant(0u), 0x01));

                                    body.emit(assign(r204E, r205C, 0x03));

                                    body.emit(assign(r204D, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f205B->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r205F = less(r200A, body.constant(int(0)));
                                    ir_if *f205E = new(mem_ctx) ir_if(operand(r205F).val);
                                    exec_list *const f205E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f205E->then_instructions;

                                       ir_variable *const r2060 = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r2060, r200D, 0x01));

                                       ir_variable *const r2061 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r2061, neg(r200A), 0x01));

                                       ir_variable *const r2062 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r2062);
                                       ir_variable *const r2063 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r2063);
                                       ir_variable *const r2064 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r2064);
                                       ir_variable *const r2065 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r2066 = neg(r2061);
                                       body.emit(assign(r2065, bit_and(r2066, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2068 = equal(r2061, body.constant(int(0)));
                                       ir_if *f2067 = new(mem_ctx) ir_if(operand(r2068).val);
                                       exec_list *const f2067_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2067->then_instructions;

                                          body.emit(assign(r2062, r200D, 0x01));

                                          body.emit(assign(r2063, r200C, 0x01));

                                          body.emit(assign(r2064, r200B, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2067->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r206A = less(r2061, body.constant(int(32)));
                                          ir_if *f2069 = new(mem_ctx) ir_if(operand(r206A).val);
                                          exec_list *const f2069_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2069->then_instructions;

                                             body.emit(assign(r2062, lshift(r200C, r2065), 0x01));

                                             ir_expression *const r206B = lshift(r200B, r2065);
                                             ir_expression *const r206C = rshift(r200C, r2061);
                                             body.emit(assign(r2063, bit_or(r206B, r206C), 0x01));

                                             body.emit(assign(r2064, rshift(r200B, r2061), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2069->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r206E = equal(r2061, body.constant(int(32)));
                                             ir_if *f206D = new(mem_ctx) ir_if(operand(r206E).val);
                                             exec_list *const f206D_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f206D->then_instructions;

                                                body.emit(assign(r2062, r200C, 0x01));

                                                body.emit(assign(r2063, r200B, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f206D->else_instructions;

                                                body.emit(assign(r2060, bit_or(r200D, r200C), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r2070 = less(r2061, body.constant(int(64)));
                                                ir_if *f206F = new(mem_ctx) ir_if(operand(r2070).val);
                                                exec_list *const f206F_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f206F->then_instructions;

                                                   body.emit(assign(r2062, lshift(r200B, r2065), 0x01));

                                                   ir_expression *const r2071 = bit_and(r2061, body.constant(int(31)));
                                                   body.emit(assign(r2063, rshift(r200B, r2071), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f206F->else_instructions;

                                                   ir_variable *const r2072 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r2074 = equal(r2061, body.constant(int(64)));
                                                   ir_if *f2073 = new(mem_ctx) ir_if(operand(r2074).val);
                                                   exec_list *const f2073_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f2073->then_instructions;

                                                      body.emit(assign(r2072, r200B, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f2073->else_instructions;

                                                      ir_expression *const r2075 = nequal(r200B, body.constant(0u));
                                                      ir_expression *const r2076 = expr(ir_unop_b2i, r2075);
                                                      body.emit(assign(r2072, expr(ir_unop_i2u, r2076), 0x01));


                                                   body.instructions = f2073_parent_instructions;
                                                   body.emit(f2073);

                                                   /* END IF */

                                                   body.emit(assign(r2062, r2072, 0x01));

                                                   body.emit(assign(r2063, body.constant(0u), 0x01));


                                                body.instructions = f206F_parent_instructions;
                                                body.emit(f206F);

                                                /* END IF */


                                             body.instructions = f206D_parent_instructions;
                                             body.emit(f206D);

                                             /* END IF */

                                             body.emit(assign(r2064, body.constant(0u), 0x01));


                                          body.instructions = f2069_parent_instructions;
                                          body.emit(f2069);

                                          /* END IF */

                                          ir_expression *const r2077 = nequal(r2060, body.constant(0u));
                                          ir_expression *const r2078 = expr(ir_unop_b2i, r2077);
                                          ir_expression *const r2079 = expr(ir_unop_i2u, r2078);
                                          body.emit(assign(r2062, bit_or(r2062, r2079), 0x01));


                                       body.instructions = f2067_parent_instructions;
                                       body.emit(f2067);

                                       /* END IF */

                                       body.emit(assign(r204A, r2064, 0x01));

                                       body.emit(assign(r204B, r2063, 0x01));

                                       body.emit(assign(r204C, r2062, 0x01));

                                       body.emit(assign(r2049, body.constant(int(0)), 0x01));

                                       body.emit(assign(r204F, less(r2062, body.constant(0u)), 0x01));


                                    body.instructions = f205E_parent_instructions;
                                    body.emit(f205E);

                                    /* END IF */


                                 body.instructions = f205B_parent_instructions;
                                 body.emit(f205B);

                                 /* END IF */


                              body.instructions = f2051_parent_instructions;
                              body.emit(f2051);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f207A = new(mem_ctx) ir_if(operand(r204D).val);
                              exec_list *const f207A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f207A->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f207B = new(mem_ctx) ir_if(operand(r204F).val);
                                 exec_list *const f207B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f207B->then_instructions;

                                    ir_variable *const r207C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r207C, add(r204B, body.constant(1u)), 0x01));

                                    ir_expression *const r207D = less(r207C, r204B);
                                    ir_expression *const r207E = expr(ir_unop_b2i, r207D);
                                    ir_expression *const r207F = expr(ir_unop_i2u, r207E);
                                    body.emit(assign(r204A, add(r204A, r207F), 0x01));

                                    ir_expression *const r2080 = equal(r204C, body.constant(0u));
                                    ir_expression *const r2081 = expr(ir_unop_b2i, r2080);
                                    ir_expression *const r2082 = expr(ir_unop_i2u, r2081);
                                    ir_expression *const r2083 = add(r204C, r2082);
                                    ir_expression *const r2084 = bit_and(r2083, body.constant(1u));
                                    ir_expression *const r2085 = expr(ir_unop_bit_not, r2084);
                                    body.emit(assign(r204B, bit_and(r207C, r2085), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f207B->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2087 = bit_or(r204A, r204B);
                                    ir_expression *const r2088 = equal(r2087, body.constant(0u));
                                    ir_if *f2086 = new(mem_ctx) ir_if(operand(r2088).val);
                                    exec_list *const f2086_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2086->then_instructions;

                                       body.emit(assign(r2049, body.constant(int(0)), 0x01));


                                    body.instructions = f2086_parent_instructions;
                                    body.emit(f2086);

                                    /* END IF */


                                 body.instructions = f207B_parent_instructions;
                                 body.emit(f207B);

                                 /* END IF */

                                 ir_variable *const r2089 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2089);
                                 ir_expression *const r208A = lshift(r1CD4, body.constant(int(31)));
                                 ir_expression *const r208B = expr(ir_unop_i2u, r2049);
                                 ir_expression *const r208C = lshift(r208B, body.constant(int(20)));
                                 ir_expression *const r208D = add(r208A, r208C);
                                 body.emit(assign(r2089, add(r208D, r204A), 0x02));

                                 body.emit(assign(r2089, r204B, 0x01));

                                 body.emit(assign(r204E, r2089, 0x03));

                                 body.emit(assign(r204D, body.constant(false), 0x01));


                              body.instructions = f207A_parent_instructions;
                              body.emit(f207A);

                              /* END IF */

                              body.emit(assign(r1CD5, r204E, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2002->else_instructions;

                              ir_variable *const r208E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r208E);
                              body.emit(assign(r208E, body.constant(0u), 0x02));

                              body.emit(assign(r208E, body.constant(0u), 0x01));

                              body.emit(assign(r1CD5, r208E, 0x03));


                           body.instructions = f2002_parent_instructions;
                           body.emit(f2002);

                           /* END IF */


                        body.instructions = f1F76_parent_instructions;
                        body.emit(f1F76);

                        /* END IF */


                     body.instructions = f1EEA_parent_instructions;
                     body.emit(f1EEA);

                     /* END IF */


                  body.instructions = f1E5E_parent_instructions;
                  body.emit(f1E5E);

                  /* END IF */


               body.instructions = f1E49_parent_instructions;
               body.emit(f1E49);

               /* END IF */


            body.instructions = f1D9A_parent_instructions;
            body.emit(f1D9A);

            /* END IF */


         body.instructions = f1CE9_parent_instructions;
         body.emit(f1CE9);

         /* END IF */

         body.emit(assign(r1CD0, r1CD5, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1CD2->else_instructions;

         ir_variable *const r208F = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r208F, body.constant(true), 0x01));

         ir_variable *const r2090 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2091 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2091);
         ir_variable *const r2092 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r2092);
         ir_variable *const r2093 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r2093);
         ir_variable *const r2094 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r2094);
         ir_variable *const r2095 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r2095);
         ir_variable *const r2096 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r2096);
         ir_variable *const r2097 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r2097);
         ir_variable *const r2098 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r2098);
         body.emit(assign(r2098, body.constant(0u), 0x01));

         body.emit(assign(r2097, body.constant(0u), 0x01));

         ir_variable *const r2099 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r2099, swizzle_x(r1C9B), 0x01));

         body.emit(assign(r2095, r2099, 0x01));

         ir_variable *const r209A = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r209A, bit_and(swizzle_y(r1C9B), body.constant(1048575u)), 0x01));

         body.emit(assign(r2094, r209A, 0x01));

         ir_variable *const r209B = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r209B, body.constant(0u), 0x01));

         body.emit(assign(r2093, body.constant(0u), 0x01));

         body.emit(assign(r2092, body.constant(0u), 0x01));

         ir_variable *const r209C = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r209D = rshift(swizzle_y(r1C9B), body.constant(int(20)));
         ir_expression *const r209E = bit_and(r209D, body.constant(2047u));
         body.emit(assign(r209C, expr(ir_unop_u2i, r209E), 0x01));

         ir_variable *const r209F = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r209F, body.constant(int(1023)), 0x01));

         ir_variable *const r20A0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r20A0, add(r209C, body.constant(int(-1023))), 0x01));

         body.emit(assign(r2091, r20A0, 0x01));

         /* IF CONDITION */
         ir_expression *const r20A2 = less(body.constant(int(0)), r20A0);
         ir_if *f20A1 = new(mem_ctx) ir_if(operand(r20A2).val);
         exec_list *const f20A1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f20A1->then_instructions;

            /* IF CONDITION */
            ir_expression *const r20A4 = equal(r209C, body.constant(int(2047)));
            ir_if *f20A3 = new(mem_ctx) ir_if(operand(r20A4).val);
            exec_list *const f20A3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f20A3->then_instructions;

               /* IF CONDITION */
               ir_expression *const r20A6 = bit_or(r209A, swizzle_x(r1C9B));
               ir_expression *const r20A7 = nequal(r20A6, body.constant(0u));
               ir_if *f20A5 = new(mem_ctx) ir_if(operand(r20A7).val);
               exec_list *const f20A5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f20A5->then_instructions;

                  ir_variable *const r20A8 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r20A8, swizzle_x(r1C9B), 0x01));

                  ir_variable *const r20A9 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r20A9, body.constant(0u), 0x01));

                  ir_variable *const r20AA = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r20A8, bit_or(swizzle_y(r1C9B), body.constant(524288u)), 0x02));

                  body.emit(assign(r20A9, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r20AC = lshift(swizzle_y(r1C9B), body.constant(int(1)));
                  ir_expression *const r20AD = lequal(body.constant(4292870144u), r20AC);
                  ir_expression *const r20AE = nequal(swizzle_x(r1C9B), body.constant(0u));
                  ir_expression *const r20AF = bit_and(swizzle_y(r1C9B), body.constant(1048575u));
                  ir_expression *const r20B0 = nequal(r20AF, body.constant(0u));
                  ir_expression *const r20B1 = logic_or(r20AE, r20B0);
                  ir_expression *const r20B2 = logic_and(r20AD, r20B1);
                  ir_if *f20AB = new(mem_ctx) ir_if(operand(r20B2).val);
                  exec_list *const f20AB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f20AB->then_instructions;

                     body.emit(assign(r20AA, r20A8, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f20AB->else_instructions;

                     body.emit(assign(r20AA, r20A9, 0x03));


                  body.instructions = f20AB_parent_instructions;
                  body.emit(f20AB);

                  /* END IF */

                  body.emit(assign(r2090, r20AA, 0x03));

                  body.emit(assign(r208F, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f20A5->else_instructions;

                  body.emit(assign(r2090, r1C9B, 0x03));

                  body.emit(assign(r208F, body.constant(false), 0x01));


               body.instructions = f20A5_parent_instructions;
               body.emit(f20A5);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f20A3->else_instructions;

               body.emit(assign(r2092, body.constant(1048576u), 0x01));

               ir_variable *const r20B3 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r20B3, body.constant(0u), 0x01));

               ir_variable *const r20B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r20B4);
               ir_variable *const r20B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r20B5);
               ir_variable *const r20B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r20B6);
               ir_variable *const r20B7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r20B8 = neg(r20A0);
               body.emit(assign(r20B7, bit_and(r20B8, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r20BA = equal(r20A0, body.constant(int(0)));
               ir_if *f20B9 = new(mem_ctx) ir_if(operand(r20BA).val);
               exec_list *const f20B9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f20B9->then_instructions;

                  body.emit(assign(r20B4, r20B3, 0x01));

                  body.emit(assign(r20B5, body.constant(0u), 0x01));

                  body.emit(assign(r20B6, r2092, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f20B9->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r20BC = less(r20A0, body.constant(int(32)));
                  ir_if *f20BB = new(mem_ctx) ir_if(operand(r20BC).val);
                  exec_list *const f20BB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f20BB->then_instructions;

                     body.emit(assign(r20B4, body.constant(0u), 0x01));

                     ir_expression *const r20BD = lshift(body.constant(1048576u), r20B7);
                     body.emit(assign(r20B5, bit_or(r20BD, body.constant(0u)), 0x01));

                     body.emit(assign(r20B6, rshift(body.constant(1048576u), r20A0), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f20BB->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r20BF = equal(r20A0, body.constant(int(32)));
                     ir_if *f20BE = new(mem_ctx) ir_if(operand(r20BF).val);
                     exec_list *const f20BE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f20BE->then_instructions;

                        body.emit(assign(r20B4, body.constant(0u), 0x01));

                        body.emit(assign(r20B5, r2092, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f20BE->else_instructions;

                        body.emit(assign(r20B3, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r20C1 = less(r20A0, body.constant(int(64)));
                        ir_if *f20C0 = new(mem_ctx) ir_if(operand(r20C1).val);
                        exec_list *const f20C0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f20C0->then_instructions;

                           body.emit(assign(r20B4, lshift(body.constant(1048576u), r20B7), 0x01));

                           ir_expression *const r20C2 = bit_and(r20A0, body.constant(int(31)));
                           body.emit(assign(r20B5, rshift(body.constant(1048576u), r20C2), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f20C0->else_instructions;

                           ir_variable *const r20C3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r20C5 = equal(r20A0, body.constant(int(64)));
                           ir_if *f20C4 = new(mem_ctx) ir_if(operand(r20C5).val);
                           exec_list *const f20C4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20C4->then_instructions;

                              body.emit(assign(r20C3, r2092, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20C4->else_instructions;

                              body.emit(assign(r20C3, body.constant(1u), 0x01));


                           body.instructions = f20C4_parent_instructions;
                           body.emit(f20C4);

                           /* END IF */

                           body.emit(assign(r20B4, r20C3, 0x01));

                           body.emit(assign(r20B5, body.constant(0u), 0x01));


                        body.instructions = f20C0_parent_instructions;
                        body.emit(f20C0);

                        /* END IF */


                     body.instructions = f20BE_parent_instructions;
                     body.emit(f20BE);

                     /* END IF */

                     body.emit(assign(r20B6, body.constant(0u), 0x01));


                  body.instructions = f20BB_parent_instructions;
                  body.emit(f20BB);

                  /* END IF */

                  ir_expression *const r20C6 = nequal(r20B3, body.constant(0u));
                  ir_expression *const r20C7 = expr(ir_unop_b2i, r20C6);
                  ir_expression *const r20C8 = expr(ir_unop_i2u, r20C7);
                  body.emit(assign(r20B4, bit_or(r20B4, r20C8), 0x01));


               body.instructions = f20B9_parent_instructions;
               body.emit(f20B9);

               /* END IF */

               body.emit(assign(r2092, r20B6, 0x01));

               body.emit(assign(r2093, r20B5, 0x01));

               body.emit(assign(r2097, r20B4, 0x01));

               body.emit(assign(r2096, r209C, 0x01));


            body.instructions = f20A3_parent_instructions;
            body.emit(f20A3);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f20A1->else_instructions;

            /* IF CONDITION */
            ir_expression *const r20CA = less(r20A0, body.constant(int(0)));
            ir_if *f20C9 = new(mem_ctx) ir_if(operand(r20CA).val);
            exec_list *const f20C9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f20C9->then_instructions;

               /* IF CONDITION */
               ir_expression *const r20CC = equal(r209C, body.constant(int(0)));
               ir_if *f20CB = new(mem_ctx) ir_if(operand(r20CC).val);
               exec_list *const f20CB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f20CB->then_instructions;

                  body.emit(assign(r2091, add(r20A0, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f20CB->else_instructions;

                  body.emit(assign(r2094, bit_or(r209A, body.constant(1048576u)), 0x01));


               body.instructions = f20CB_parent_instructions;
               body.emit(f20CB);

               /* END IF */

               ir_variable *const r20CD = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r20CD, body.constant(0u), 0x01));

               ir_variable *const r20CE = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r20CE, neg(r2091), 0x01));

               ir_variable *const r20CF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r20CF);
               ir_variable *const r20D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r20D0);
               ir_variable *const r20D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r20D1);
               ir_variable *const r20D2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r20D3 = neg(r20CE);
               body.emit(assign(r20D2, bit_and(r20D3, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r20D5 = equal(r20CE, body.constant(int(0)));
               ir_if *f20D4 = new(mem_ctx) ir_if(operand(r20D5).val);
               exec_list *const f20D4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f20D4->then_instructions;

                  body.emit(assign(r20CF, r20CD, 0x01));

                  body.emit(assign(r20D0, r2099, 0x01));

                  body.emit(assign(r20D1, r2094, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f20D4->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r20D7 = less(r20CE, body.constant(int(32)));
                  ir_if *f20D6 = new(mem_ctx) ir_if(operand(r20D7).val);
                  exec_list *const f20D6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f20D6->then_instructions;

                     body.emit(assign(r20CF, lshift(swizzle_x(r1C9B), r20D2), 0x01));

                     ir_expression *const r20D8 = lshift(r2094, r20D2);
                     ir_expression *const r20D9 = rshift(swizzle_x(r1C9B), r20CE);
                     body.emit(assign(r20D0, bit_or(r20D8, r20D9), 0x01));

                     body.emit(assign(r20D1, rshift(r2094, r20CE), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f20D6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r20DB = equal(r20CE, body.constant(int(32)));
                     ir_if *f20DA = new(mem_ctx) ir_if(operand(r20DB).val);
                     exec_list *const f20DA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f20DA->then_instructions;

                        body.emit(assign(r20CF, r2099, 0x01));

                        body.emit(assign(r20D0, r2094, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f20DA->else_instructions;

                        body.emit(assign(r20CD, bit_or(body.constant(0u), swizzle_x(r1C9B)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r20DD = less(r20CE, body.constant(int(64)));
                        ir_if *f20DC = new(mem_ctx) ir_if(operand(r20DD).val);
                        exec_list *const f20DC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f20DC->then_instructions;

                           body.emit(assign(r20CF, lshift(r2094, r20D2), 0x01));

                           ir_expression *const r20DE = bit_and(r20CE, body.constant(int(31)));
                           body.emit(assign(r20D0, rshift(r2094, r20DE), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f20DC->else_instructions;

                           ir_variable *const r20DF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r20E1 = equal(r20CE, body.constant(int(64)));
                           ir_if *f20E0 = new(mem_ctx) ir_if(operand(r20E1).val);
                           exec_list *const f20E0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20E0->then_instructions;

                              body.emit(assign(r20DF, r2094, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20E0->else_instructions;

                              ir_expression *const r20E2 = nequal(r2094, body.constant(0u));
                              ir_expression *const r20E3 = expr(ir_unop_b2i, r20E2);
                              body.emit(assign(r20DF, expr(ir_unop_i2u, r20E3), 0x01));


                           body.instructions = f20E0_parent_instructions;
                           body.emit(f20E0);

                           /* END IF */

                           body.emit(assign(r20CF, r20DF, 0x01));

                           body.emit(assign(r20D0, body.constant(0u), 0x01));


                        body.instructions = f20DC_parent_instructions;
                        body.emit(f20DC);

                        /* END IF */


                     body.instructions = f20DA_parent_instructions;
                     body.emit(f20DA);

                     /* END IF */

                     body.emit(assign(r20D1, body.constant(0u), 0x01));


                  body.instructions = f20D6_parent_instructions;
                  body.emit(f20D6);

                  /* END IF */

                  ir_expression *const r20E4 = nequal(r20CD, body.constant(0u));
                  ir_expression *const r20E5 = expr(ir_unop_b2i, r20E4);
                  ir_expression *const r20E6 = expr(ir_unop_i2u, r20E5);
                  body.emit(assign(r20CF, bit_or(r20CF, r20E6), 0x01));


               body.instructions = f20D4_parent_instructions;
               body.emit(f20D4);

               /* END IF */

               body.emit(assign(r2094, r20D1, 0x01));

               body.emit(assign(r2095, r20D0, 0x01));

               body.emit(assign(r2097, r20CF, 0x01));

               body.emit(assign(r2096, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f20C9->else_instructions;

               /* IF CONDITION */
               ir_expression *const r20E8 = equal(r209C, body.constant(int(2047)));
               ir_if *f20E7 = new(mem_ctx) ir_if(operand(r20E8).val);
               exec_list *const f20E7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f20E7->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r20EA = bit_or(r2094, r2095);
                  ir_expression *const r20EB = bit_or(r2092, r2093);
                  ir_expression *const r20EC = bit_or(r20EA, r20EB);
                  ir_expression *const r20ED = nequal(r20EC, body.constant(0u));
                  ir_if *f20E9 = new(mem_ctx) ir_if(operand(r20ED).val);
                  exec_list *const f20E9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f20E9->then_instructions;

                     ir_variable *const r20EE = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r20EE, swizzle_x(r1C9B), 0x01));

                     ir_variable *const r20EF = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r20EF, body.constant(0u), 0x01));

                     ir_variable *const r20F0 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r20EE, bit_or(swizzle_y(r1C9B), body.constant(524288u)), 0x02));

                     body.emit(assign(r20EF, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r20F2 = lshift(swizzle_y(r1C9B), body.constant(int(1)));
                     ir_expression *const r20F3 = lequal(body.constant(4292870144u), r20F2);
                     ir_expression *const r20F4 = nequal(swizzle_x(r1C9B), body.constant(0u));
                     ir_expression *const r20F5 = bit_and(swizzle_y(r1C9B), body.constant(1048575u));
                     ir_expression *const r20F6 = nequal(r20F5, body.constant(0u));
                     ir_expression *const r20F7 = logic_or(r20F4, r20F6);
                     ir_expression *const r20F8 = logic_and(r20F3, r20F7);
                     ir_if *f20F1 = new(mem_ctx) ir_if(operand(r20F8).val);
                     exec_list *const f20F1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f20F1->then_instructions;

                        body.emit(assign(r20F0, r20EE, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f20F1->else_instructions;

                        body.emit(assign(r20F0, r20EF, 0x03));


                     body.instructions = f20F1_parent_instructions;
                     body.emit(f20F1);

                     /* END IF */

                     body.emit(assign(r2090, r20F0, 0x03));

                     body.emit(assign(r208F, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f20E9->else_instructions;

                     body.emit(assign(r2090, r1C9B, 0x03));

                     body.emit(assign(r208F, body.constant(false), 0x01));


                  body.instructions = f20E9_parent_instructions;
                  body.emit(f20E9);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f20E7->else_instructions;

                  ir_variable *const r20F9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r20FA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r20FA, add(r2095, r2093), 0x01));

                  ir_expression *const r20FB = add(r2094, r2092);
                  ir_expression *const r20FC = less(r20FA, r2095);
                  ir_expression *const r20FD = expr(ir_unop_b2i, r20FC);
                  ir_expression *const r20FE = expr(ir_unop_i2u, r20FD);
                  body.emit(assign(r20F9, add(r20FB, r20FE), 0x01));

                  body.emit(assign(r2098, r20F9, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2100 = equal(r209C, body.constant(int(0)));
                  ir_if *f20FF = new(mem_ctx) ir_if(operand(r2100).val);
                  exec_list *const f20FF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f20FF->then_instructions;

                     ir_variable *const r2101 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2101);
                     ir_expression *const r2102 = lshift(r1CD1, body.constant(int(31)));
                     body.emit(assign(r2101, add(r2102, r20F9), 0x02));

                     body.emit(assign(r2101, r20FA, 0x01));

                     body.emit(assign(r2090, r2101, 0x03));

                     body.emit(assign(r208F, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f20FF->else_instructions;

                     body.emit(assign(r2098, bit_or(r20F9, body.constant(2097152u)), 0x01));

                     body.emit(assign(r2096, r209C, 0x01));

                     ir_variable *const r2103 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2103);
                     ir_variable *const r2104 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2104);
                     ir_variable *const r2105 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2105);
                     body.emit(assign(r2103, lshift(r20FA, body.constant(int(31))), 0x01));

                     ir_expression *const r2106 = lshift(r2098, body.constant(int(31)));
                     ir_expression *const r2107 = rshift(r20FA, body.constant(int(1)));
                     body.emit(assign(r2104, bit_or(r2106, r2107), 0x01));

                     body.emit(assign(r2105, rshift(r2098, body.constant(int(1))), 0x01));

                     body.emit(assign(r2103, bit_or(r2103, body.constant(0u)), 0x01));

                     body.emit(assign(r2098, r2105, 0x01));

                     body.emit(assign(r2097, r2103, 0x01));

                     ir_variable *const r2108 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2108, r209C, 0x01));

                     ir_variable *const r2109 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2109, r2105, 0x01));

                     ir_variable *const r210A = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r210A, r2104, 0x01));

                     ir_variable *const r210B = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r210B, r2103, 0x01));

                     ir_variable *const r210C = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r210C, body.constant(true), 0x01));

                     ir_variable *const r210D = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r210E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r210E);
                     ir_expression *const r210F = expr(ir_unop_u2i, r2103);
                     body.emit(assign(r210E, less(r210F, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2111 = lequal(body.constant(int(2045)), r209C);
                     ir_if *f2110 = new(mem_ctx) ir_if(operand(r2111).val);
                     exec_list *const f2110_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2110->then_instructions;

                        ir_variable *const r2112 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2114 = less(body.constant(int(2045)), r209C);
                        ir_if *f2113 = new(mem_ctx) ir_if(operand(r2114).val);
                        exec_list *const f2113_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2113->then_instructions;

                           body.emit(assign(r2112, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2113->else_instructions;

                           ir_variable *const r2115 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2117 = equal(r209C, body.constant(int(2045)));
                           ir_if *f2116 = new(mem_ctx) ir_if(operand(r2117).val);
                           exec_list *const f2116_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2116->then_instructions;

                              ir_expression *const r2118 = equal(body.constant(2097151u), r2105);
                              ir_expression *const r2119 = equal(body.constant(4294967295u), r2104);
                              body.emit(assign(r2115, logic_and(r2118, r2119), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2116->else_instructions;

                              body.emit(assign(r2115, body.constant(false), 0x01));


                           body.instructions = f2116_parent_instructions;
                           body.emit(f2116);

                           /* END IF */

                           body.emit(assign(r2112, logic_and(r2115, r210E), 0x01));


                        body.instructions = f2113_parent_instructions;
                        body.emit(f2113);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f211A = new(mem_ctx) ir_if(operand(r2112).val);
                        exec_list *const f211A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f211A->then_instructions;

                           ir_variable *const r211B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r211B);
                           ir_expression *const r211C = lshift(r1CD1, body.constant(int(31)));
                           body.emit(assign(r211B, add(r211C, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r211B, body.constant(0u), 0x01));

                           body.emit(assign(r210D, r211B, 0x03));

                           body.emit(assign(r210C, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f211A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r211E = less(r209C, body.constant(int(0)));
                           ir_if *f211D = new(mem_ctx) ir_if(operand(r211E).val);
                           exec_list *const f211D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f211D->then_instructions;

                              ir_variable *const r211F = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r211F, r2103, 0x01));

                              ir_variable *const r2120 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2120, neg(r209C), 0x01));

                              ir_variable *const r2121 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2121);
                              ir_variable *const r2122 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2122);
                              ir_variable *const r2123 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2123);
                              ir_variable *const r2124 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2125 = neg(r2120);
                              body.emit(assign(r2124, bit_and(r2125, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2127 = equal(r2120, body.constant(int(0)));
                              ir_if *f2126 = new(mem_ctx) ir_if(operand(r2127).val);
                              exec_list *const f2126_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2126->then_instructions;

                                 body.emit(assign(r2121, r2103, 0x01));

                                 body.emit(assign(r2122, r2104, 0x01));

                                 body.emit(assign(r2123, r2105, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2126->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2129 = less(r2120, body.constant(int(32)));
                                 ir_if *f2128 = new(mem_ctx) ir_if(operand(r2129).val);
                                 exec_list *const f2128_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2128->then_instructions;

                                    body.emit(assign(r2121, lshift(r2104, r2124), 0x01));

                                    ir_expression *const r212A = lshift(r2105, r2124);
                                    ir_expression *const r212B = rshift(r2104, r2120);
                                    body.emit(assign(r2122, bit_or(r212A, r212B), 0x01));

                                    body.emit(assign(r2123, rshift(r2105, r2120), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2128->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r212D = equal(r2120, body.constant(int(32)));
                                    ir_if *f212C = new(mem_ctx) ir_if(operand(r212D).val);
                                    exec_list *const f212C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f212C->then_instructions;

                                       body.emit(assign(r2121, r2104, 0x01));

                                       body.emit(assign(r2122, r2105, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f212C->else_instructions;

                                       body.emit(assign(r211F, bit_or(r2103, r2104), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r212F = less(r2120, body.constant(int(64)));
                                       ir_if *f212E = new(mem_ctx) ir_if(operand(r212F).val);
                                       exec_list *const f212E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f212E->then_instructions;

                                          body.emit(assign(r2121, lshift(r2105, r2124), 0x01));

                                          ir_expression *const r2130 = bit_and(r2120, body.constant(int(31)));
                                          body.emit(assign(r2122, rshift(r2105, r2130), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f212E->else_instructions;

                                          ir_variable *const r2131 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2133 = equal(r2120, body.constant(int(64)));
                                          ir_if *f2132 = new(mem_ctx) ir_if(operand(r2133).val);
                                          exec_list *const f2132_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2132->then_instructions;

                                             body.emit(assign(r2131, r2105, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2132->else_instructions;

                                             ir_expression *const r2134 = nequal(r2105, body.constant(0u));
                                             ir_expression *const r2135 = expr(ir_unop_b2i, r2134);
                                             body.emit(assign(r2131, expr(ir_unop_i2u, r2135), 0x01));


                                          body.instructions = f2132_parent_instructions;
                                          body.emit(f2132);

                                          /* END IF */

                                          body.emit(assign(r2121, r2131, 0x01));

                                          body.emit(assign(r2122, body.constant(0u), 0x01));


                                       body.instructions = f212E_parent_instructions;
                                       body.emit(f212E);

                                       /* END IF */


                                    body.instructions = f212C_parent_instructions;
                                    body.emit(f212C);

                                    /* END IF */

                                    body.emit(assign(r2123, body.constant(0u), 0x01));


                                 body.instructions = f2128_parent_instructions;
                                 body.emit(f2128);

                                 /* END IF */

                                 ir_expression *const r2136 = nequal(r211F, body.constant(0u));
                                 ir_expression *const r2137 = expr(ir_unop_b2i, r2136);
                                 ir_expression *const r2138 = expr(ir_unop_i2u, r2137);
                                 body.emit(assign(r2121, bit_or(r2121, r2138), 0x01));


                              body.instructions = f2126_parent_instructions;
                              body.emit(f2126);

                              /* END IF */

                              body.emit(assign(r2109, r2123, 0x01));

                              body.emit(assign(r210A, r2122, 0x01));

                              body.emit(assign(r210B, r2121, 0x01));

                              body.emit(assign(r2108, body.constant(int(0)), 0x01));

                              body.emit(assign(r210E, less(r2121, body.constant(0u)), 0x01));


                           body.instructions = f211D_parent_instructions;
                           body.emit(f211D);

                           /* END IF */


                        body.instructions = f211A_parent_instructions;
                        body.emit(f211A);

                        /* END IF */


                     body.instructions = f2110_parent_instructions;
                     body.emit(f2110);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2139 = new(mem_ctx) ir_if(operand(r210C).val);
                     exec_list *const f2139_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2139->then_instructions;

                        /* IF CONDITION */
                        ir_if *f213A = new(mem_ctx) ir_if(operand(r210E).val);
                        exec_list *const f213A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f213A->then_instructions;

                           ir_variable *const r213B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r213B, add(r210A, body.constant(1u)), 0x01));

                           ir_expression *const r213C = less(r213B, r210A);
                           ir_expression *const r213D = expr(ir_unop_b2i, r213C);
                           ir_expression *const r213E = expr(ir_unop_i2u, r213D);
                           body.emit(assign(r2109, add(r2109, r213E), 0x01));

                           ir_expression *const r213F = equal(r210B, body.constant(0u));
                           ir_expression *const r2140 = expr(ir_unop_b2i, r213F);
                           ir_expression *const r2141 = expr(ir_unop_i2u, r2140);
                           ir_expression *const r2142 = add(r210B, r2141);
                           ir_expression *const r2143 = bit_and(r2142, body.constant(1u));
                           ir_expression *const r2144 = expr(ir_unop_bit_not, r2143);
                           body.emit(assign(r210A, bit_and(r213B, r2144), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f213A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2146 = bit_or(r2109, r210A);
                           ir_expression *const r2147 = equal(r2146, body.constant(0u));
                           ir_if *f2145 = new(mem_ctx) ir_if(operand(r2147).val);
                           exec_list *const f2145_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2145->then_instructions;

                              body.emit(assign(r2108, body.constant(int(0)), 0x01));


                           body.instructions = f2145_parent_instructions;
                           body.emit(f2145);

                           /* END IF */


                        body.instructions = f213A_parent_instructions;
                        body.emit(f213A);

                        /* END IF */

                        ir_variable *const r2148 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2148);
                        ir_expression *const r2149 = lshift(r1CD1, body.constant(int(31)));
                        ir_expression *const r214A = expr(ir_unop_i2u, r2108);
                        ir_expression *const r214B = lshift(r214A, body.constant(int(20)));
                        ir_expression *const r214C = add(r2149, r214B);
                        body.emit(assign(r2148, add(r214C, r2109), 0x02));

                        body.emit(assign(r2148, r210A, 0x01));

                        body.emit(assign(r210D, r2148, 0x03));

                        body.emit(assign(r210C, body.constant(false), 0x01));


                     body.instructions = f2139_parent_instructions;
                     body.emit(f2139);

                     /* END IF */

                     body.emit(assign(r2090, r210D, 0x03));

                     body.emit(assign(r208F, body.constant(false), 0x01));


                  body.instructions = f20FF_parent_instructions;
                  body.emit(f20FF);

                  /* END IF */


               body.instructions = f20E7_parent_instructions;
               body.emit(f20E7);

               /* END IF */


            body.instructions = f20C9_parent_instructions;
            body.emit(f20C9);

            /* END IF */


         body.instructions = f20A1_parent_instructions;
         body.emit(f20A1);

         /* END IF */

         /* IF CONDITION */
         ir_if *f214D = new(mem_ctx) ir_if(operand(r208F).val);
         exec_list *const f214D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f214D->then_instructions;

            body.emit(assign(r2094, bit_or(r2094, body.constant(1048576u)), 0x01));

            ir_variable *const r214E = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r214F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r214F, add(r2095, r2093), 0x01));

            ir_expression *const r2150 = add(r2094, r2092);
            ir_expression *const r2151 = less(r214F, r2095);
            ir_expression *const r2152 = expr(ir_unop_b2i, r2151);
            ir_expression *const r2153 = expr(ir_unop_i2u, r2152);
            body.emit(assign(r214E, add(r2150, r2153), 0x01));

            body.emit(assign(r2098, r214E, 0x01));

            body.emit(assign(r2096, add(r2096, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2155 = less(r214E, body.constant(2097152u));
            ir_if *f2154 = new(mem_ctx) ir_if(operand(r2155).val);
            exec_list *const f2154_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2154->then_instructions;

               ir_variable *const r2156 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2156, r2096, 0x01));

               ir_variable *const r2157 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2157, r214E, 0x01));

               ir_variable *const r2158 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2158, r214F, 0x01));

               ir_variable *const r2159 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2159, r2097, 0x01));

               ir_variable *const r215A = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r215A, body.constant(true), 0x01));

               ir_variable *const r215B = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r215C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r215C);
               ir_expression *const r215D = expr(ir_unop_u2i, r2097);
               body.emit(assign(r215C, less(r215D, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r215F = lequal(body.constant(int(2045)), r2096);
               ir_if *f215E = new(mem_ctx) ir_if(operand(r215F).val);
               exec_list *const f215E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f215E->then_instructions;

                  ir_variable *const r2160 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2162 = less(body.constant(int(2045)), r2096);
                  ir_if *f2161 = new(mem_ctx) ir_if(operand(r2162).val);
                  exec_list *const f2161_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2161->then_instructions;

                     body.emit(assign(r2160, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2161->else_instructions;

                     ir_variable *const r2163 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2165 = equal(r2096, body.constant(int(2045)));
                     ir_if *f2164 = new(mem_ctx) ir_if(operand(r2165).val);
                     exec_list *const f2164_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2164->then_instructions;

                        ir_expression *const r2166 = equal(body.constant(2097151u), r214E);
                        ir_expression *const r2167 = equal(body.constant(4294967295u), r214F);
                        body.emit(assign(r2163, logic_and(r2166, r2167), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2164->else_instructions;

                        body.emit(assign(r2163, body.constant(false), 0x01));


                     body.instructions = f2164_parent_instructions;
                     body.emit(f2164);

                     /* END IF */

                     body.emit(assign(r2160, logic_and(r2163, r215C), 0x01));


                  body.instructions = f2161_parent_instructions;
                  body.emit(f2161);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2168 = new(mem_ctx) ir_if(operand(r2160).val);
                  exec_list *const f2168_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2168->then_instructions;

                     ir_variable *const r2169 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2169);
                     ir_expression *const r216A = lshift(r1CD1, body.constant(int(31)));
                     body.emit(assign(r2169, add(r216A, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2169, body.constant(0u), 0x01));

                     body.emit(assign(r215B, r2169, 0x03));

                     body.emit(assign(r215A, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2168->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r216C = less(r2096, body.constant(int(0)));
                     ir_if *f216B = new(mem_ctx) ir_if(operand(r216C).val);
                     exec_list *const f216B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f216B->then_instructions;

                        ir_variable *const r216D = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r216D, r2097, 0x01));

                        ir_variable *const r216E = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r216E, neg(r2096), 0x01));

                        ir_variable *const r216F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r216F);
                        ir_variable *const r2170 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2170);
                        ir_variable *const r2171 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2171);
                        ir_variable *const r2172 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2173 = neg(r216E);
                        body.emit(assign(r2172, bit_and(r2173, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2175 = equal(r216E, body.constant(int(0)));
                        ir_if *f2174 = new(mem_ctx) ir_if(operand(r2175).val);
                        exec_list *const f2174_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2174->then_instructions;

                           body.emit(assign(r216F, r2097, 0x01));

                           body.emit(assign(r2170, r214F, 0x01));

                           body.emit(assign(r2171, r214E, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2174->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2177 = less(r216E, body.constant(int(32)));
                           ir_if *f2176 = new(mem_ctx) ir_if(operand(r2177).val);
                           exec_list *const f2176_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2176->then_instructions;

                              body.emit(assign(r216F, lshift(r214F, r2172), 0x01));

                              ir_expression *const r2178 = lshift(r214E, r2172);
                              ir_expression *const r2179 = rshift(r214F, r216E);
                              body.emit(assign(r2170, bit_or(r2178, r2179), 0x01));

                              body.emit(assign(r2171, rshift(r214E, r216E), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2176->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r217B = equal(r216E, body.constant(int(32)));
                              ir_if *f217A = new(mem_ctx) ir_if(operand(r217B).val);
                              exec_list *const f217A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f217A->then_instructions;

                                 body.emit(assign(r216F, r214F, 0x01));

                                 body.emit(assign(r2170, r214E, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f217A->else_instructions;

                                 body.emit(assign(r216D, bit_or(r2097, r214F), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r217D = less(r216E, body.constant(int(64)));
                                 ir_if *f217C = new(mem_ctx) ir_if(operand(r217D).val);
                                 exec_list *const f217C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f217C->then_instructions;

                                    body.emit(assign(r216F, lshift(r214E, r2172), 0x01));

                                    ir_expression *const r217E = bit_and(r216E, body.constant(int(31)));
                                    body.emit(assign(r2170, rshift(r214E, r217E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f217C->else_instructions;

                                    ir_variable *const r217F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2181 = equal(r216E, body.constant(int(64)));
                                    ir_if *f2180 = new(mem_ctx) ir_if(operand(r2181).val);
                                    exec_list *const f2180_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2180->then_instructions;

                                       body.emit(assign(r217F, r214E, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2180->else_instructions;

                                       ir_expression *const r2182 = nequal(r214E, body.constant(0u));
                                       ir_expression *const r2183 = expr(ir_unop_b2i, r2182);
                                       body.emit(assign(r217F, expr(ir_unop_i2u, r2183), 0x01));


                                    body.instructions = f2180_parent_instructions;
                                    body.emit(f2180);

                                    /* END IF */

                                    body.emit(assign(r216F, r217F, 0x01));

                                    body.emit(assign(r2170, body.constant(0u), 0x01));


                                 body.instructions = f217C_parent_instructions;
                                 body.emit(f217C);

                                 /* END IF */


                              body.instructions = f217A_parent_instructions;
                              body.emit(f217A);

                              /* END IF */

                              body.emit(assign(r2171, body.constant(0u), 0x01));


                           body.instructions = f2176_parent_instructions;
                           body.emit(f2176);

                           /* END IF */

                           ir_expression *const r2184 = nequal(r216D, body.constant(0u));
                           ir_expression *const r2185 = expr(ir_unop_b2i, r2184);
                           ir_expression *const r2186 = expr(ir_unop_i2u, r2185);
                           body.emit(assign(r216F, bit_or(r216F, r2186), 0x01));


                        body.instructions = f2174_parent_instructions;
                        body.emit(f2174);

                        /* END IF */

                        body.emit(assign(r2157, r2171, 0x01));

                        body.emit(assign(r2158, r2170, 0x01));

                        body.emit(assign(r2159, r216F, 0x01));

                        body.emit(assign(r2156, body.constant(int(0)), 0x01));

                        body.emit(assign(r215C, less(r216F, body.constant(0u)), 0x01));


                     body.instructions = f216B_parent_instructions;
                     body.emit(f216B);

                     /* END IF */


                  body.instructions = f2168_parent_instructions;
                  body.emit(f2168);

                  /* END IF */


               body.instructions = f215E_parent_instructions;
               body.emit(f215E);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2187 = new(mem_ctx) ir_if(operand(r215A).val);
               exec_list *const f2187_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2187->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2188 = new(mem_ctx) ir_if(operand(r215C).val);
                  exec_list *const f2188_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2188->then_instructions;

                     ir_variable *const r2189 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2189, add(r2158, body.constant(1u)), 0x01));

                     ir_expression *const r218A = less(r2189, r2158);
                     ir_expression *const r218B = expr(ir_unop_b2i, r218A);
                     ir_expression *const r218C = expr(ir_unop_i2u, r218B);
                     body.emit(assign(r2157, add(r2157, r218C), 0x01));

                     ir_expression *const r218D = equal(r2159, body.constant(0u));
                     ir_expression *const r218E = expr(ir_unop_b2i, r218D);
                     ir_expression *const r218F = expr(ir_unop_i2u, r218E);
                     ir_expression *const r2190 = add(r2159, r218F);
                     ir_expression *const r2191 = bit_and(r2190, body.constant(1u));
                     ir_expression *const r2192 = expr(ir_unop_bit_not, r2191);
                     body.emit(assign(r2158, bit_and(r2189, r2192), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2188->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2194 = bit_or(r2157, r2158);
                     ir_expression *const r2195 = equal(r2194, body.constant(0u));
                     ir_if *f2193 = new(mem_ctx) ir_if(operand(r2195).val);
                     exec_list *const f2193_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2193->then_instructions;

                        body.emit(assign(r2156, body.constant(int(0)), 0x01));


                     body.instructions = f2193_parent_instructions;
                     body.emit(f2193);

                     /* END IF */


                  body.instructions = f2188_parent_instructions;
                  body.emit(f2188);

                  /* END IF */

                  ir_variable *const r2196 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2196);
                  ir_expression *const r2197 = lshift(r1CD1, body.constant(int(31)));
                  ir_expression *const r2198 = expr(ir_unop_i2u, r2156);
                  ir_expression *const r2199 = lshift(r2198, body.constant(int(20)));
                  ir_expression *const r219A = add(r2197, r2199);
                  body.emit(assign(r2196, add(r219A, r2157), 0x02));

                  body.emit(assign(r2196, r2158, 0x01));

                  body.emit(assign(r215B, r2196, 0x03));

                  body.emit(assign(r215A, body.constant(false), 0x01));


               body.instructions = f2187_parent_instructions;
               body.emit(f2187);

               /* END IF */

               body.emit(assign(r2090, r215B, 0x03));

               body.emit(assign(r208F, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2154->else_instructions;

               body.emit(assign(r2096, add(r2096, body.constant(int(1))), 0x01));

               ir_variable *const r219B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r219B);
               ir_variable *const r219C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r219C);
               ir_variable *const r219D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r219D);
               body.emit(assign(r219B, lshift(r214F, body.constant(int(31))), 0x01));

               ir_expression *const r219E = lshift(r214E, body.constant(int(31)));
               ir_expression *const r219F = rshift(r214F, body.constant(int(1)));
               body.emit(assign(r219C, bit_or(r219E, r219F), 0x01));

               body.emit(assign(r219D, rshift(r214E, body.constant(int(1))), 0x01));

               ir_expression *const r21A0 = nequal(r2097, body.constant(0u));
               ir_expression *const r21A1 = expr(ir_unop_b2i, r21A0);
               ir_expression *const r21A2 = expr(ir_unop_i2u, r21A1);
               body.emit(assign(r219B, bit_or(r219B, r21A2), 0x01));

               body.emit(assign(r2098, r219D, 0x01));

               body.emit(assign(r2097, r219B, 0x01));

               ir_variable *const r21A3 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r21A3, r2096, 0x01));

               ir_variable *const r21A4 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r21A4, r219D, 0x01));

               ir_variable *const r21A5 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r21A5, r219C, 0x01));

               ir_variable *const r21A6 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r21A6, r219B, 0x01));

               ir_variable *const r21A7 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r21A7, body.constant(true), 0x01));

               ir_variable *const r21A8 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r21A9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r21A9);
               ir_expression *const r21AA = expr(ir_unop_u2i, r219B);
               body.emit(assign(r21A9, less(r21AA, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r21AC = lequal(body.constant(int(2045)), r2096);
               ir_if *f21AB = new(mem_ctx) ir_if(operand(r21AC).val);
               exec_list *const f21AB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f21AB->then_instructions;

                  ir_variable *const r21AD = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r21AF = less(body.constant(int(2045)), r2096);
                  ir_if *f21AE = new(mem_ctx) ir_if(operand(r21AF).val);
                  exec_list *const f21AE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f21AE->then_instructions;

                     body.emit(assign(r21AD, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f21AE->else_instructions;

                     ir_variable *const r21B0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r21B2 = equal(r2096, body.constant(int(2045)));
                     ir_if *f21B1 = new(mem_ctx) ir_if(operand(r21B2).val);
                     exec_list *const f21B1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f21B1->then_instructions;

                        ir_expression *const r21B3 = equal(body.constant(2097151u), r219D);
                        ir_expression *const r21B4 = equal(body.constant(4294967295u), r219C);
                        body.emit(assign(r21B0, logic_and(r21B3, r21B4), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f21B1->else_instructions;

                        body.emit(assign(r21B0, body.constant(false), 0x01));


                     body.instructions = f21B1_parent_instructions;
                     body.emit(f21B1);

                     /* END IF */

                     body.emit(assign(r21AD, logic_and(r21B0, r21A9), 0x01));


                  body.instructions = f21AE_parent_instructions;
                  body.emit(f21AE);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f21B5 = new(mem_ctx) ir_if(operand(r21AD).val);
                  exec_list *const f21B5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f21B5->then_instructions;

                     ir_variable *const r21B6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r21B6);
                     ir_expression *const r21B7 = lshift(r1CD1, body.constant(int(31)));
                     body.emit(assign(r21B6, add(r21B7, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r21B6, body.constant(0u), 0x01));

                     body.emit(assign(r21A8, r21B6, 0x03));

                     body.emit(assign(r21A7, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f21B5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r21B9 = less(r2096, body.constant(int(0)));
                     ir_if *f21B8 = new(mem_ctx) ir_if(operand(r21B9).val);
                     exec_list *const f21B8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f21B8->then_instructions;

                        ir_variable *const r21BA = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r21BA, r219B, 0x01));

                        ir_variable *const r21BB = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r21BB, neg(r2096), 0x01));

                        ir_variable *const r21BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r21BC);
                        ir_variable *const r21BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r21BD);
                        ir_variable *const r21BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r21BE);
                        ir_variable *const r21BF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r21C0 = neg(r21BB);
                        body.emit(assign(r21BF, bit_and(r21C0, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r21C2 = equal(r21BB, body.constant(int(0)));
                        ir_if *f21C1 = new(mem_ctx) ir_if(operand(r21C2).val);
                        exec_list *const f21C1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f21C1->then_instructions;

                           body.emit(assign(r21BC, r219B, 0x01));

                           body.emit(assign(r21BD, r219C, 0x01));

                           body.emit(assign(r21BE, r219D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f21C1->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r21C4 = less(r21BB, body.constant(int(32)));
                           ir_if *f21C3 = new(mem_ctx) ir_if(operand(r21C4).val);
                           exec_list *const f21C3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f21C3->then_instructions;

                              body.emit(assign(r21BC, lshift(r219C, r21BF), 0x01));

                              ir_expression *const r21C5 = lshift(r219D, r21BF);
                              ir_expression *const r21C6 = rshift(r219C, r21BB);
                              body.emit(assign(r21BD, bit_or(r21C5, r21C6), 0x01));

                              body.emit(assign(r21BE, rshift(r219D, r21BB), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f21C3->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r21C8 = equal(r21BB, body.constant(int(32)));
                              ir_if *f21C7 = new(mem_ctx) ir_if(operand(r21C8).val);
                              exec_list *const f21C7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f21C7->then_instructions;

                                 body.emit(assign(r21BC, r219C, 0x01));

                                 body.emit(assign(r21BD, r219D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f21C7->else_instructions;

                                 body.emit(assign(r21BA, bit_or(r219B, r219C), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r21CA = less(r21BB, body.constant(int(64)));
                                 ir_if *f21C9 = new(mem_ctx) ir_if(operand(r21CA).val);
                                 exec_list *const f21C9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21C9->then_instructions;

                                    body.emit(assign(r21BC, lshift(r219D, r21BF), 0x01));

                                    ir_expression *const r21CB = bit_and(r21BB, body.constant(int(31)));
                                    body.emit(assign(r21BD, rshift(r219D, r21CB), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f21C9->else_instructions;

                                    ir_variable *const r21CC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r21CE = equal(r21BB, body.constant(int(64)));
                                    ir_if *f21CD = new(mem_ctx) ir_if(operand(r21CE).val);
                                    exec_list *const f21CD_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f21CD->then_instructions;

                                       body.emit(assign(r21CC, r219D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f21CD->else_instructions;

                                       ir_expression *const r21CF = nequal(r219D, body.constant(0u));
                                       ir_expression *const r21D0 = expr(ir_unop_b2i, r21CF);
                                       body.emit(assign(r21CC, expr(ir_unop_i2u, r21D0), 0x01));


                                    body.instructions = f21CD_parent_instructions;
                                    body.emit(f21CD);

                                    /* END IF */

                                    body.emit(assign(r21BC, r21CC, 0x01));

                                    body.emit(assign(r21BD, body.constant(0u), 0x01));


                                 body.instructions = f21C9_parent_instructions;
                                 body.emit(f21C9);

                                 /* END IF */


                              body.instructions = f21C7_parent_instructions;
                              body.emit(f21C7);

                              /* END IF */

                              body.emit(assign(r21BE, body.constant(0u), 0x01));


                           body.instructions = f21C3_parent_instructions;
                           body.emit(f21C3);

                           /* END IF */

                           ir_expression *const r21D1 = nequal(r21BA, body.constant(0u));
                           ir_expression *const r21D2 = expr(ir_unop_b2i, r21D1);
                           ir_expression *const r21D3 = expr(ir_unop_i2u, r21D2);
                           body.emit(assign(r21BC, bit_or(r21BC, r21D3), 0x01));


                        body.instructions = f21C1_parent_instructions;
                        body.emit(f21C1);

                        /* END IF */

                        body.emit(assign(r21A4, r21BE, 0x01));

                        body.emit(assign(r21A5, r21BD, 0x01));

                        body.emit(assign(r21A6, r21BC, 0x01));

                        body.emit(assign(r21A3, body.constant(int(0)), 0x01));

                        body.emit(assign(r21A9, less(r21BC, body.constant(0u)), 0x01));


                     body.instructions = f21B8_parent_instructions;
                     body.emit(f21B8);

                     /* END IF */


                  body.instructions = f21B5_parent_instructions;
                  body.emit(f21B5);

                  /* END IF */


               body.instructions = f21AB_parent_instructions;
               body.emit(f21AB);

               /* END IF */

               /* IF CONDITION */
               ir_if *f21D4 = new(mem_ctx) ir_if(operand(r21A7).val);
               exec_list *const f21D4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f21D4->then_instructions;

                  /* IF CONDITION */
                  ir_if *f21D5 = new(mem_ctx) ir_if(operand(r21A9).val);
                  exec_list *const f21D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f21D5->then_instructions;

                     ir_variable *const r21D6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r21D6, add(r21A5, body.constant(1u)), 0x01));

                     ir_expression *const r21D7 = less(r21D6, r21A5);
                     ir_expression *const r21D8 = expr(ir_unop_b2i, r21D7);
                     ir_expression *const r21D9 = expr(ir_unop_i2u, r21D8);
                     body.emit(assign(r21A4, add(r21A4, r21D9), 0x01));

                     ir_expression *const r21DA = equal(r21A6, body.constant(0u));
                     ir_expression *const r21DB = expr(ir_unop_b2i, r21DA);
                     ir_expression *const r21DC = expr(ir_unop_i2u, r21DB);
                     ir_expression *const r21DD = add(r21A6, r21DC);
                     ir_expression *const r21DE = bit_and(r21DD, body.constant(1u));
                     ir_expression *const r21DF = expr(ir_unop_bit_not, r21DE);
                     body.emit(assign(r21A5, bit_and(r21D6, r21DF), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f21D5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r21E1 = bit_or(r21A4, r21A5);
                     ir_expression *const r21E2 = equal(r21E1, body.constant(0u));
                     ir_if *f21E0 = new(mem_ctx) ir_if(operand(r21E2).val);
                     exec_list *const f21E0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f21E0->then_instructions;

                        body.emit(assign(r21A3, body.constant(int(0)), 0x01));


                     body.instructions = f21E0_parent_instructions;
                     body.emit(f21E0);

                     /* END IF */


                  body.instructions = f21D5_parent_instructions;
                  body.emit(f21D5);

                  /* END IF */

                  ir_variable *const r21E3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r21E3);
                  ir_expression *const r21E4 = lshift(r1CD1, body.constant(int(31)));
                  ir_expression *const r21E5 = expr(ir_unop_i2u, r21A3);
                  ir_expression *const r21E6 = lshift(r21E5, body.constant(int(20)));
                  ir_expression *const r21E7 = add(r21E4, r21E6);
                  body.emit(assign(r21E3, add(r21E7, r21A4), 0x02));

                  body.emit(assign(r21E3, r21A5, 0x01));

                  body.emit(assign(r21A8, r21E3, 0x03));

                  body.emit(assign(r21A7, body.constant(false), 0x01));


               body.instructions = f21D4_parent_instructions;
               body.emit(f21D4);

               /* END IF */

               body.emit(assign(r2090, r21A8, 0x03));

               body.emit(assign(r208F, body.constant(false), 0x01));


            body.instructions = f2154_parent_instructions;
            body.emit(f2154);

            /* END IF */


         body.instructions = f214D_parent_instructions;
         body.emit(f214D);

         /* END IF */

         body.emit(assign(r1CD0, r2090, 0x03));


      body.instructions = f1CD2_parent_instructions;
      body.emit(f1CD2);

      /* END IF */

      body.emit(assign(r1CCE, r1CD0, 0x03));


   body.instructions = f1CCF_parent_instructions;
   body.emit(f1CCF);

   /* END IF */

   body.emit(ret(r1CCE));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fceil64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r21E8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r21E8);
   ir_variable *const r21E9 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r21EA = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r21EB = rshift(swizzle_y(r21E8), body.constant(int(20)));
   ir_expression *const r21EC = bit_and(r21EB, body.constant(2047u));
   ir_expression *const r21ED = expr(ir_unop_u2i, r21EC);
   body.emit(assign(r21EA, add(r21ED, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r21EF = less(r21EA, body.constant(int(0)));
   ir_if *f21EE = new(mem_ctx) ir_if(operand(r21EF).val);
   exec_list *const f21EE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f21EE->then_instructions;

      body.emit(assign(r21E9, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f21EE->else_instructions;

      /* IF CONDITION */
      ir_expression *const r21F1 = greater(r21EA, body.constant(int(52)));
      ir_if *f21F0 = new(mem_ctx) ir_if(operand(r21F1).val);
      exec_list *const f21F0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f21F0->then_instructions;

         body.emit(assign(r21E9, r21E8, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f21F0->else_instructions;

         ir_variable *const r21F2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r21F2, sub(body.constant(int(52)), r21EA), 0x01));

         ir_variable *const r21F3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r21F5 = gequal(r21F2, body.constant(int(32)));
         ir_if *f21F4 = new(mem_ctx) ir_if(operand(r21F5).val);
         exec_list *const f21F4_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f21F4->then_instructions;

            body.emit(assign(r21F3, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f21F4->else_instructions;

            body.emit(assign(r21F3, lshift(body.constant(4294967295u), r21F2), 0x01));


         body.instructions = f21F4_parent_instructions;
         body.emit(f21F4);

         /* END IF */

         ir_variable *const r21F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r21F8 = less(r21F2, body.constant(int(33)));
         ir_if *f21F7 = new(mem_ctx) ir_if(operand(r21F8).val);
         exec_list *const f21F7_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f21F7->then_instructions;

            body.emit(assign(r21F6, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f21F7->else_instructions;

            ir_expression *const r21F9 = add(r21F2, body.constant(int(-32)));
            body.emit(assign(r21F6, lshift(body.constant(4294967295u), r21F9), 0x01));


         body.instructions = f21F7_parent_instructions;
         body.emit(f21F7);

         /* END IF */

         ir_variable *const r21FA = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r21FA, bit_and(r21F3, swizzle_x(r21E8)), 0x01));

         body.emit(assign(r21FA, bit_and(r21F6, swizzle_y(r21E8)), 0x02));

         body.emit(assign(r21E9, r21FA, 0x03));


      body.instructions = f21F0_parent_instructions;
      body.emit(f21F0);

      /* END IF */


   body.instructions = f21EE_parent_instructions;
   body.emit(f21EE);

   /* END IF */

   ir_variable *const r21FB = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r21FB, rshift(swizzle_y(r21E8), body.constant(int(31))), 0x01));

   ir_variable *const r21FC = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r21FE = expr(ir_unop_u2i, r21FB);
   ir_expression *const r21FF = expr(ir_unop_i2b, r21FE);
   ir_if *f21FD = new(mem_ctx) ir_if(operand(r21FF).val);
   exec_list *const f21FD_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f21FD->then_instructions;

      body.emit(assign(r21FC, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f21FD->else_instructions;

      ir_variable *const r2200 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r2201 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r2201);
      ir_variable *const r2202 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r2202);
      ir_expression *const r2203 = rshift(swizzle_y(r21E8), body.constant(int(20)));
      ir_expression *const r2204 = bit_and(r2203, body.constant(2047u));
      ir_expression *const r2205 = expr(ir_unop_u2i, r2204);
      ir_expression *const r2206 = equal(r2205, body.constant(int(2047)));
      ir_expression *const r2207 = bit_and(swizzle_y(r21E8), body.constant(1048575u));
      ir_expression *const r2208 = bit_or(r2207, swizzle_x(r21E8));
      ir_expression *const r2209 = nequal(r2208, body.constant(0u));
      body.emit(assign(r2202, logic_and(r2206, r2209), 0x01));

      ir_expression *const r220A = rshift(swizzle_y(r21E9), body.constant(int(20)));
      ir_expression *const r220B = bit_and(r220A, body.constant(2047u));
      ir_expression *const r220C = expr(ir_unop_u2i, r220B);
      ir_expression *const r220D = equal(r220C, body.constant(int(2047)));
      ir_expression *const r220E = bit_and(swizzle_y(r21E9), body.constant(1048575u));
      ir_expression *const r220F = bit_or(r220E, swizzle_x(r21E9));
      ir_expression *const r2210 = nequal(r220F, body.constant(0u));
      body.emit(assign(r2201, logic_and(r220D, r2210), 0x01));

      /* IF CONDITION */
      ir_expression *const r2212 = logic_or(r2202, r2201);
      ir_if *f2211 = new(mem_ctx) ir_if(operand(r2212).val);
      exec_list *const f2211_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2211->then_instructions;

         body.emit(assign(r2200, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2211->else_instructions;

         ir_expression *const r2213 = equal(swizzle_x(r21E8), swizzle_x(r21E9));
         ir_expression *const r2214 = equal(swizzle_y(r21E8), swizzle_y(r21E9));
         ir_expression *const r2215 = equal(swizzle_x(r21E8), body.constant(0u));
         ir_expression *const r2216 = bit_or(swizzle_y(r21E8), swizzle_y(r21E9));
         ir_expression *const r2217 = lshift(r2216, body.constant(int(1)));
         ir_expression *const r2218 = equal(r2217, body.constant(0u));
         ir_expression *const r2219 = logic_and(r2215, r2218);
         ir_expression *const r221A = logic_or(r2214, r2219);
         body.emit(assign(r2200, logic_and(r2213, r221A), 0x01));


      body.instructions = f2211_parent_instructions;
      body.emit(f2211);

      /* END IF */

      body.emit(assign(r21FC, r2200, 0x01));


   body.instructions = f21FD_parent_instructions;
   body.emit(f21FD);

   /* END IF */

   ir_variable *const r221B = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f221C = new(mem_ctx) ir_if(operand(r21FC).val);
   exec_list *const f221C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f221C->then_instructions;

      body.emit(assign(r221B, r21E9, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f221C->else_instructions;

      ir_variable *const r221D = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r221E = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r221E, rshift(swizzle_y(r21E9), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r2220 = equal(r221E, body.constant(0u));
      ir_if *f221F = new(mem_ctx) ir_if(operand(r2220).val);
      exec_list *const f221F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f221F->then_instructions;

         ir_variable *const r2221 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r2221, body.constant(true), 0x01));

         ir_variable *const r2222 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2223 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2223);
         ir_variable *const r2224 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r2224);
         ir_variable *const r2225 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r2225);
         ir_variable *const r2226 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r2226);
         ir_variable *const r2227 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r2227);
         ir_variable *const r2228 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r2228);
         ir_variable *const r2229 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r2229);
         ir_variable *const r222A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r222A);
         body.emit(assign(r222A, body.constant(0u), 0x01));

         body.emit(assign(r2229, body.constant(0u), 0x01));

         ir_variable *const r222B = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r222B, swizzle_x(r21E9), 0x01));

         body.emit(assign(r2227, r222B, 0x01));

         ir_variable *const r222C = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r222C, bit_and(swizzle_y(r21E9), body.constant(1048575u)), 0x01));

         body.emit(assign(r2226, r222C, 0x01));

         ir_variable *const r222D = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r222D, body.constant(0u), 0x01));

         body.emit(assign(r2225, body.constant(0u), 0x01));

         body.emit(assign(r2224, body.constant(0u), 0x01));

         ir_variable *const r222E = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r222F = rshift(swizzle_y(r21E9), body.constant(int(20)));
         ir_expression *const r2230 = bit_and(r222F, body.constant(2047u));
         body.emit(assign(r222E, expr(ir_unop_u2i, r2230), 0x01));

         ir_variable *const r2231 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r2231, body.constant(int(1023)), 0x01));

         ir_variable *const r2232 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r2232, add(r222E, body.constant(int(-1023))), 0x01));

         body.emit(assign(r2223, r2232, 0x01));

         /* IF CONDITION */
         ir_expression *const r2234 = less(body.constant(int(0)), r2232);
         ir_if *f2233 = new(mem_ctx) ir_if(operand(r2234).val);
         exec_list *const f2233_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2233->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2236 = equal(r222E, body.constant(int(2047)));
            ir_if *f2235 = new(mem_ctx) ir_if(operand(r2236).val);
            exec_list *const f2235_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2235->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2238 = bit_or(r222C, swizzle_x(r21E9));
               ir_expression *const r2239 = nequal(r2238, body.constant(0u));
               ir_if *f2237 = new(mem_ctx) ir_if(operand(r2239).val);
               exec_list *const f2237_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2237->then_instructions;

                  ir_variable *const r223A = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r223A, swizzle_x(r21E9), 0x01));

                  ir_variable *const r223B = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r223B, body.constant(0u), 0x01));

                  ir_variable *const r223C = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r223A, bit_or(swizzle_y(r21E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r223B, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r223E = lshift(swizzle_y(r21E9), body.constant(int(1)));
                  ir_expression *const r223F = lequal(body.constant(4292870144u), r223E);
                  ir_expression *const r2240 = nequal(swizzle_x(r21E9), body.constant(0u));
                  ir_expression *const r2241 = bit_and(swizzle_y(r21E9), body.constant(1048575u));
                  ir_expression *const r2242 = nequal(r2241, body.constant(0u));
                  ir_expression *const r2243 = logic_or(r2240, r2242);
                  ir_expression *const r2244 = logic_and(r223F, r2243);
                  ir_if *f223D = new(mem_ctx) ir_if(operand(r2244).val);
                  exec_list *const f223D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f223D->then_instructions;

                     body.emit(assign(r223C, r223A, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f223D->else_instructions;

                     body.emit(assign(r223C, r223B, 0x03));


                  body.instructions = f223D_parent_instructions;
                  body.emit(f223D);

                  /* END IF */

                  body.emit(assign(r2222, r223C, 0x03));

                  body.emit(assign(r2221, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2237->else_instructions;

                  body.emit(assign(r2222, r21E9, 0x03));

                  body.emit(assign(r2221, body.constant(false), 0x01));


               body.instructions = f2237_parent_instructions;
               body.emit(f2237);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2235->else_instructions;

               body.emit(assign(r2224, body.constant(1048576u), 0x01));

               ir_variable *const r2245 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2245, body.constant(0u), 0x01));

               ir_variable *const r2246 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2246);
               ir_variable *const r2247 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2247);
               ir_variable *const r2248 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2248);
               ir_variable *const r2249 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r224A = neg(r2232);
               body.emit(assign(r2249, bit_and(r224A, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r224C = equal(r2232, body.constant(int(0)));
               ir_if *f224B = new(mem_ctx) ir_if(operand(r224C).val);
               exec_list *const f224B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f224B->then_instructions;

                  body.emit(assign(r2246, r2245, 0x01));

                  body.emit(assign(r2247, body.constant(0u), 0x01));

                  body.emit(assign(r2248, r2224, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f224B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r224E = less(r2232, body.constant(int(32)));
                  ir_if *f224D = new(mem_ctx) ir_if(operand(r224E).val);
                  exec_list *const f224D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f224D->then_instructions;

                     body.emit(assign(r2246, body.constant(0u), 0x01));

                     ir_expression *const r224F = lshift(body.constant(1048576u), r2249);
                     body.emit(assign(r2247, bit_or(r224F, body.constant(0u)), 0x01));

                     body.emit(assign(r2248, rshift(body.constant(1048576u), r2232), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f224D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2251 = equal(r2232, body.constant(int(32)));
                     ir_if *f2250 = new(mem_ctx) ir_if(operand(r2251).val);
                     exec_list *const f2250_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2250->then_instructions;

                        body.emit(assign(r2246, body.constant(0u), 0x01));

                        body.emit(assign(r2247, r2224, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2250->else_instructions;

                        body.emit(assign(r2245, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2253 = less(r2232, body.constant(int(64)));
                        ir_if *f2252 = new(mem_ctx) ir_if(operand(r2253).val);
                        exec_list *const f2252_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2252->then_instructions;

                           body.emit(assign(r2246, lshift(body.constant(1048576u), r2249), 0x01));

                           ir_expression *const r2254 = bit_and(r2232, body.constant(int(31)));
                           body.emit(assign(r2247, rshift(body.constant(1048576u), r2254), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2252->else_instructions;

                           ir_variable *const r2255 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2257 = equal(r2232, body.constant(int(64)));
                           ir_if *f2256 = new(mem_ctx) ir_if(operand(r2257).val);
                           exec_list *const f2256_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2256->then_instructions;

                              body.emit(assign(r2255, r2224, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2256->else_instructions;

                              body.emit(assign(r2255, body.constant(1u), 0x01));


                           body.instructions = f2256_parent_instructions;
                           body.emit(f2256);

                           /* END IF */

                           body.emit(assign(r2246, r2255, 0x01));

                           body.emit(assign(r2247, body.constant(0u), 0x01));


                        body.instructions = f2252_parent_instructions;
                        body.emit(f2252);

                        /* END IF */


                     body.instructions = f2250_parent_instructions;
                     body.emit(f2250);

                     /* END IF */

                     body.emit(assign(r2248, body.constant(0u), 0x01));


                  body.instructions = f224D_parent_instructions;
                  body.emit(f224D);

                  /* END IF */

                  ir_expression *const r2258 = nequal(r2245, body.constant(0u));
                  ir_expression *const r2259 = expr(ir_unop_b2i, r2258);
                  ir_expression *const r225A = expr(ir_unop_i2u, r2259);
                  body.emit(assign(r2246, bit_or(r2246, r225A), 0x01));


               body.instructions = f224B_parent_instructions;
               body.emit(f224B);

               /* END IF */

               body.emit(assign(r2224, r2248, 0x01));

               body.emit(assign(r2225, r2247, 0x01));

               body.emit(assign(r2229, r2246, 0x01));

               body.emit(assign(r2228, r222E, 0x01));


            body.instructions = f2235_parent_instructions;
            body.emit(f2235);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2233->else_instructions;

            /* IF CONDITION */
            ir_expression *const r225C = less(r2232, body.constant(int(0)));
            ir_if *f225B = new(mem_ctx) ir_if(operand(r225C).val);
            exec_list *const f225B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f225B->then_instructions;

               /* IF CONDITION */
               ir_expression *const r225E = equal(r222E, body.constant(int(0)));
               ir_if *f225D = new(mem_ctx) ir_if(operand(r225E).val);
               exec_list *const f225D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f225D->then_instructions;

                  body.emit(assign(r2223, add(r2232, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f225D->else_instructions;

                  body.emit(assign(r2226, bit_or(r222C, body.constant(1048576u)), 0x01));


               body.instructions = f225D_parent_instructions;
               body.emit(f225D);

               /* END IF */

               ir_variable *const r225F = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r225F, body.constant(0u), 0x01));

               ir_variable *const r2260 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2260, neg(r2223), 0x01));

               ir_variable *const r2261 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2261);
               ir_variable *const r2262 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2262);
               ir_variable *const r2263 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2263);
               ir_variable *const r2264 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2265 = neg(r2260);
               body.emit(assign(r2264, bit_and(r2265, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2267 = equal(r2260, body.constant(int(0)));
               ir_if *f2266 = new(mem_ctx) ir_if(operand(r2267).val);
               exec_list *const f2266_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2266->then_instructions;

                  body.emit(assign(r2261, r225F, 0x01));

                  body.emit(assign(r2262, r222B, 0x01));

                  body.emit(assign(r2263, r2226, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2266->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2269 = less(r2260, body.constant(int(32)));
                  ir_if *f2268 = new(mem_ctx) ir_if(operand(r2269).val);
                  exec_list *const f2268_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2268->then_instructions;

                     body.emit(assign(r2261, lshift(swizzle_x(r21E9), r2264), 0x01));

                     ir_expression *const r226A = lshift(r2226, r2264);
                     ir_expression *const r226B = rshift(swizzle_x(r21E9), r2260);
                     body.emit(assign(r2262, bit_or(r226A, r226B), 0x01));

                     body.emit(assign(r2263, rshift(r2226, r2260), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2268->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r226D = equal(r2260, body.constant(int(32)));
                     ir_if *f226C = new(mem_ctx) ir_if(operand(r226D).val);
                     exec_list *const f226C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f226C->then_instructions;

                        body.emit(assign(r2261, r222B, 0x01));

                        body.emit(assign(r2262, r2226, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f226C->else_instructions;

                        body.emit(assign(r225F, bit_or(body.constant(0u), swizzle_x(r21E9)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r226F = less(r2260, body.constant(int(64)));
                        ir_if *f226E = new(mem_ctx) ir_if(operand(r226F).val);
                        exec_list *const f226E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f226E->then_instructions;

                           body.emit(assign(r2261, lshift(r2226, r2264), 0x01));

                           ir_expression *const r2270 = bit_and(r2260, body.constant(int(31)));
                           body.emit(assign(r2262, rshift(r2226, r2270), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f226E->else_instructions;

                           ir_variable *const r2271 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2273 = equal(r2260, body.constant(int(64)));
                           ir_if *f2272 = new(mem_ctx) ir_if(operand(r2273).val);
                           exec_list *const f2272_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2272->then_instructions;

                              body.emit(assign(r2271, r2226, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2272->else_instructions;

                              ir_expression *const r2274 = nequal(r2226, body.constant(0u));
                              ir_expression *const r2275 = expr(ir_unop_b2i, r2274);
                              body.emit(assign(r2271, expr(ir_unop_i2u, r2275), 0x01));


                           body.instructions = f2272_parent_instructions;
                           body.emit(f2272);

                           /* END IF */

                           body.emit(assign(r2261, r2271, 0x01));

                           body.emit(assign(r2262, body.constant(0u), 0x01));


                        body.instructions = f226E_parent_instructions;
                        body.emit(f226E);

                        /* END IF */


                     body.instructions = f226C_parent_instructions;
                     body.emit(f226C);

                     /* END IF */

                     body.emit(assign(r2263, body.constant(0u), 0x01));


                  body.instructions = f2268_parent_instructions;
                  body.emit(f2268);

                  /* END IF */

                  ir_expression *const r2276 = nequal(r225F, body.constant(0u));
                  ir_expression *const r2277 = expr(ir_unop_b2i, r2276);
                  ir_expression *const r2278 = expr(ir_unop_i2u, r2277);
                  body.emit(assign(r2261, bit_or(r2261, r2278), 0x01));


               body.instructions = f2266_parent_instructions;
               body.emit(f2266);

               /* END IF */

               body.emit(assign(r2226, r2263, 0x01));

               body.emit(assign(r2227, r2262, 0x01));

               body.emit(assign(r2229, r2261, 0x01));

               body.emit(assign(r2228, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f225B->else_instructions;

               /* IF CONDITION */
               ir_expression *const r227A = equal(r222E, body.constant(int(2047)));
               ir_if *f2279 = new(mem_ctx) ir_if(operand(r227A).val);
               exec_list *const f2279_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2279->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r227C = bit_or(r2226, r2227);
                  ir_expression *const r227D = bit_or(r2224, r2225);
                  ir_expression *const r227E = bit_or(r227C, r227D);
                  ir_expression *const r227F = nequal(r227E, body.constant(0u));
                  ir_if *f227B = new(mem_ctx) ir_if(operand(r227F).val);
                  exec_list *const f227B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f227B->then_instructions;

                     ir_variable *const r2280 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r2280, swizzle_x(r21E9), 0x01));

                     ir_variable *const r2281 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r2281, body.constant(0u), 0x01));

                     ir_variable *const r2282 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r2280, bit_or(swizzle_y(r21E9), body.constant(524288u)), 0x02));

                     body.emit(assign(r2281, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r2284 = lshift(swizzle_y(r21E9), body.constant(int(1)));
                     ir_expression *const r2285 = lequal(body.constant(4292870144u), r2284);
                     ir_expression *const r2286 = nequal(swizzle_x(r21E9), body.constant(0u));
                     ir_expression *const r2287 = bit_and(swizzle_y(r21E9), body.constant(1048575u));
                     ir_expression *const r2288 = nequal(r2287, body.constant(0u));
                     ir_expression *const r2289 = logic_or(r2286, r2288);
                     ir_expression *const r228A = logic_and(r2285, r2289);
                     ir_if *f2283 = new(mem_ctx) ir_if(operand(r228A).val);
                     exec_list *const f2283_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2283->then_instructions;

                        body.emit(assign(r2282, r2280, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2283->else_instructions;

                        body.emit(assign(r2282, r2281, 0x03));


                     body.instructions = f2283_parent_instructions;
                     body.emit(f2283);

                     /* END IF */

                     body.emit(assign(r2222, r2282, 0x03));

                     body.emit(assign(r2221, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f227B->else_instructions;

                     body.emit(assign(r2222, r21E9, 0x03));

                     body.emit(assign(r2221, body.constant(false), 0x01));


                  body.instructions = f227B_parent_instructions;
                  body.emit(f227B);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2279->else_instructions;

                  ir_variable *const r228B = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r228C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r228C, add(r2227, r2225), 0x01));

                  ir_expression *const r228D = add(r2226, r2224);
                  ir_expression *const r228E = less(r228C, r2227);
                  ir_expression *const r228F = expr(ir_unop_b2i, r228E);
                  ir_expression *const r2290 = expr(ir_unop_i2u, r228F);
                  body.emit(assign(r228B, add(r228D, r2290), 0x01));

                  body.emit(assign(r222A, r228B, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2292 = equal(r222E, body.constant(int(0)));
                  ir_if *f2291 = new(mem_ctx) ir_if(operand(r2292).val);
                  exec_list *const f2291_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2291->then_instructions;

                     ir_variable *const r2293 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2293);
                     ir_expression *const r2294 = lshift(r221E, body.constant(int(31)));
                     body.emit(assign(r2293, add(r2294, r228B), 0x02));

                     body.emit(assign(r2293, r228C, 0x01));

                     body.emit(assign(r2222, r2293, 0x03));

                     body.emit(assign(r2221, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2291->else_instructions;

                     body.emit(assign(r222A, bit_or(r228B, body.constant(2097152u)), 0x01));

                     body.emit(assign(r2228, r222E, 0x01));

                     ir_variable *const r2295 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2295);
                     ir_variable *const r2296 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2296);
                     ir_variable *const r2297 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2297);
                     body.emit(assign(r2295, lshift(r228C, body.constant(int(31))), 0x01));

                     ir_expression *const r2298 = lshift(r222A, body.constant(int(31)));
                     ir_expression *const r2299 = rshift(r228C, body.constant(int(1)));
                     body.emit(assign(r2296, bit_or(r2298, r2299), 0x01));

                     body.emit(assign(r2297, rshift(r222A, body.constant(int(1))), 0x01));

                     body.emit(assign(r2295, bit_or(r2295, body.constant(0u)), 0x01));

                     body.emit(assign(r222A, r2297, 0x01));

                     body.emit(assign(r2229, r2295, 0x01));

                     ir_variable *const r229A = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r229A, r222E, 0x01));

                     ir_variable *const r229B = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r229B, r2297, 0x01));

                     ir_variable *const r229C = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r229C, r2296, 0x01));

                     ir_variable *const r229D = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r229D, r2295, 0x01));

                     ir_variable *const r229E = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r229E, body.constant(true), 0x01));

                     ir_variable *const r229F = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r22A0 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r22A0);
                     ir_expression *const r22A1 = expr(ir_unop_u2i, r2295);
                     body.emit(assign(r22A0, less(r22A1, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r22A3 = lequal(body.constant(int(2045)), r222E);
                     ir_if *f22A2 = new(mem_ctx) ir_if(operand(r22A3).val);
                     exec_list *const f22A2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22A2->then_instructions;

                        ir_variable *const r22A4 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r22A6 = less(body.constant(int(2045)), r222E);
                        ir_if *f22A5 = new(mem_ctx) ir_if(operand(r22A6).val);
                        exec_list *const f22A5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22A5->then_instructions;

                           body.emit(assign(r22A4, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22A5->else_instructions;

                           ir_variable *const r22A7 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r22A9 = equal(r222E, body.constant(int(2045)));
                           ir_if *f22A8 = new(mem_ctx) ir_if(operand(r22A9).val);
                           exec_list *const f22A8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f22A8->then_instructions;

                              ir_expression *const r22AA = equal(body.constant(2097151u), r2297);
                              ir_expression *const r22AB = equal(body.constant(4294967295u), r2296);
                              body.emit(assign(r22A7, logic_and(r22AA, r22AB), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f22A8->else_instructions;

                              body.emit(assign(r22A7, body.constant(false), 0x01));


                           body.instructions = f22A8_parent_instructions;
                           body.emit(f22A8);

                           /* END IF */

                           body.emit(assign(r22A4, logic_and(r22A7, r22A0), 0x01));


                        body.instructions = f22A5_parent_instructions;
                        body.emit(f22A5);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f22AC = new(mem_ctx) ir_if(operand(r22A4).val);
                        exec_list *const f22AC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22AC->then_instructions;

                           ir_variable *const r22AD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r22AD);
                           ir_expression *const r22AE = lshift(r221E, body.constant(int(31)));
                           body.emit(assign(r22AD, add(r22AE, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r22AD, body.constant(0u), 0x01));

                           body.emit(assign(r229F, r22AD, 0x03));

                           body.emit(assign(r229E, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22AC->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r22B0 = less(r222E, body.constant(int(0)));
                           ir_if *f22AF = new(mem_ctx) ir_if(operand(r22B0).val);
                           exec_list *const f22AF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f22AF->then_instructions;

                              ir_variable *const r22B1 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r22B1, r2295, 0x01));

                              ir_variable *const r22B2 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r22B2, neg(r222E), 0x01));

                              ir_variable *const r22B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r22B3);
                              ir_variable *const r22B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r22B4);
                              ir_variable *const r22B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r22B5);
                              ir_variable *const r22B6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r22B7 = neg(r22B2);
                              body.emit(assign(r22B6, bit_and(r22B7, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r22B9 = equal(r22B2, body.constant(int(0)));
                              ir_if *f22B8 = new(mem_ctx) ir_if(operand(r22B9).val);
                              exec_list *const f22B8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f22B8->then_instructions;

                                 body.emit(assign(r22B3, r2295, 0x01));

                                 body.emit(assign(r22B4, r2296, 0x01));

                                 body.emit(assign(r22B5, r2297, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f22B8->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r22BB = less(r22B2, body.constant(int(32)));
                                 ir_if *f22BA = new(mem_ctx) ir_if(operand(r22BB).val);
                                 exec_list *const f22BA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f22BA->then_instructions;

                                    body.emit(assign(r22B3, lshift(r2296, r22B6), 0x01));

                                    ir_expression *const r22BC = lshift(r2297, r22B6);
                                    ir_expression *const r22BD = rshift(r2296, r22B2);
                                    body.emit(assign(r22B4, bit_or(r22BC, r22BD), 0x01));

                                    body.emit(assign(r22B5, rshift(r2297, r22B2), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f22BA->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r22BF = equal(r22B2, body.constant(int(32)));
                                    ir_if *f22BE = new(mem_ctx) ir_if(operand(r22BF).val);
                                    exec_list *const f22BE_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f22BE->then_instructions;

                                       body.emit(assign(r22B3, r2296, 0x01));

                                       body.emit(assign(r22B4, r2297, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f22BE->else_instructions;

                                       body.emit(assign(r22B1, bit_or(r2295, r2296), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r22C1 = less(r22B2, body.constant(int(64)));
                                       ir_if *f22C0 = new(mem_ctx) ir_if(operand(r22C1).val);
                                       exec_list *const f22C0_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f22C0->then_instructions;

                                          body.emit(assign(r22B3, lshift(r2297, r22B6), 0x01));

                                          ir_expression *const r22C2 = bit_and(r22B2, body.constant(int(31)));
                                          body.emit(assign(r22B4, rshift(r2297, r22C2), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f22C0->else_instructions;

                                          ir_variable *const r22C3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r22C5 = equal(r22B2, body.constant(int(64)));
                                          ir_if *f22C4 = new(mem_ctx) ir_if(operand(r22C5).val);
                                          exec_list *const f22C4_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f22C4->then_instructions;

                                             body.emit(assign(r22C3, r2297, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f22C4->else_instructions;

                                             ir_expression *const r22C6 = nequal(r2297, body.constant(0u));
                                             ir_expression *const r22C7 = expr(ir_unop_b2i, r22C6);
                                             body.emit(assign(r22C3, expr(ir_unop_i2u, r22C7), 0x01));


                                          body.instructions = f22C4_parent_instructions;
                                          body.emit(f22C4);

                                          /* END IF */

                                          body.emit(assign(r22B3, r22C3, 0x01));

                                          body.emit(assign(r22B4, body.constant(0u), 0x01));


                                       body.instructions = f22C0_parent_instructions;
                                       body.emit(f22C0);

                                       /* END IF */


                                    body.instructions = f22BE_parent_instructions;
                                    body.emit(f22BE);

                                    /* END IF */

                                    body.emit(assign(r22B5, body.constant(0u), 0x01));


                                 body.instructions = f22BA_parent_instructions;
                                 body.emit(f22BA);

                                 /* END IF */

                                 ir_expression *const r22C8 = nequal(r22B1, body.constant(0u));
                                 ir_expression *const r22C9 = expr(ir_unop_b2i, r22C8);
                                 ir_expression *const r22CA = expr(ir_unop_i2u, r22C9);
                                 body.emit(assign(r22B3, bit_or(r22B3, r22CA), 0x01));


                              body.instructions = f22B8_parent_instructions;
                              body.emit(f22B8);

                              /* END IF */

                              body.emit(assign(r229B, r22B5, 0x01));

                              body.emit(assign(r229C, r22B4, 0x01));

                              body.emit(assign(r229D, r22B3, 0x01));

                              body.emit(assign(r229A, body.constant(int(0)), 0x01));

                              body.emit(assign(r22A0, less(r22B3, body.constant(0u)), 0x01));


                           body.instructions = f22AF_parent_instructions;
                           body.emit(f22AF);

                           /* END IF */


                        body.instructions = f22AC_parent_instructions;
                        body.emit(f22AC);

                        /* END IF */


                     body.instructions = f22A2_parent_instructions;
                     body.emit(f22A2);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f22CB = new(mem_ctx) ir_if(operand(r229E).val);
                     exec_list *const f22CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22CB->then_instructions;

                        /* IF CONDITION */
                        ir_if *f22CC = new(mem_ctx) ir_if(operand(r22A0).val);
                        exec_list *const f22CC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22CC->then_instructions;

                           ir_variable *const r22CD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r22CD, add(r229C, body.constant(1u)), 0x01));

                           ir_expression *const r22CE = less(r22CD, r229C);
                           ir_expression *const r22CF = expr(ir_unop_b2i, r22CE);
                           ir_expression *const r22D0 = expr(ir_unop_i2u, r22CF);
                           body.emit(assign(r229B, add(r229B, r22D0), 0x01));

                           ir_expression *const r22D1 = equal(r229D, body.constant(0u));
                           ir_expression *const r22D2 = expr(ir_unop_b2i, r22D1);
                           ir_expression *const r22D3 = expr(ir_unop_i2u, r22D2);
                           ir_expression *const r22D4 = add(r229D, r22D3);
                           ir_expression *const r22D5 = bit_and(r22D4, body.constant(1u));
                           ir_expression *const r22D6 = expr(ir_unop_bit_not, r22D5);
                           body.emit(assign(r229C, bit_and(r22CD, r22D6), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22CC->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r22D8 = bit_or(r229B, r229C);
                           ir_expression *const r22D9 = equal(r22D8, body.constant(0u));
                           ir_if *f22D7 = new(mem_ctx) ir_if(operand(r22D9).val);
                           exec_list *const f22D7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f22D7->then_instructions;

                              body.emit(assign(r229A, body.constant(int(0)), 0x01));


                           body.instructions = f22D7_parent_instructions;
                           body.emit(f22D7);

                           /* END IF */


                        body.instructions = f22CC_parent_instructions;
                        body.emit(f22CC);

                        /* END IF */

                        ir_variable *const r22DA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r22DA);
                        ir_expression *const r22DB = lshift(r221E, body.constant(int(31)));
                        ir_expression *const r22DC = expr(ir_unop_i2u, r229A);
                        ir_expression *const r22DD = lshift(r22DC, body.constant(int(20)));
                        ir_expression *const r22DE = add(r22DB, r22DD);
                        body.emit(assign(r22DA, add(r22DE, r229B), 0x02));

                        body.emit(assign(r22DA, r229C, 0x01));

                        body.emit(assign(r229F, r22DA, 0x03));

                        body.emit(assign(r229E, body.constant(false), 0x01));


                     body.instructions = f22CB_parent_instructions;
                     body.emit(f22CB);

                     /* END IF */

                     body.emit(assign(r2222, r229F, 0x03));

                     body.emit(assign(r2221, body.constant(false), 0x01));


                  body.instructions = f2291_parent_instructions;
                  body.emit(f2291);

                  /* END IF */


               body.instructions = f2279_parent_instructions;
               body.emit(f2279);

               /* END IF */


            body.instructions = f225B_parent_instructions;
            body.emit(f225B);

            /* END IF */


         body.instructions = f2233_parent_instructions;
         body.emit(f2233);

         /* END IF */

         /* IF CONDITION */
         ir_if *f22DF = new(mem_ctx) ir_if(operand(r2221).val);
         exec_list *const f22DF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f22DF->then_instructions;

            body.emit(assign(r2226, bit_or(r2226, body.constant(1048576u)), 0x01));

            ir_variable *const r22E0 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r22E1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r22E1, add(r2227, r2225), 0x01));

            ir_expression *const r22E2 = add(r2226, r2224);
            ir_expression *const r22E3 = less(r22E1, r2227);
            ir_expression *const r22E4 = expr(ir_unop_b2i, r22E3);
            ir_expression *const r22E5 = expr(ir_unop_i2u, r22E4);
            body.emit(assign(r22E0, add(r22E2, r22E5), 0x01));

            body.emit(assign(r222A, r22E0, 0x01));

            body.emit(assign(r2228, add(r2228, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r22E7 = less(r22E0, body.constant(2097152u));
            ir_if *f22E6 = new(mem_ctx) ir_if(operand(r22E7).val);
            exec_list *const f22E6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f22E6->then_instructions;

               ir_variable *const r22E8 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r22E8, r2228, 0x01));

               ir_variable *const r22E9 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r22E9, r22E0, 0x01));

               ir_variable *const r22EA = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r22EA, r22E1, 0x01));

               ir_variable *const r22EB = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r22EB, r2229, 0x01));

               ir_variable *const r22EC = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r22EC, body.constant(true), 0x01));

               ir_variable *const r22ED = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r22EE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r22EE);
               ir_expression *const r22EF = expr(ir_unop_u2i, r2229);
               body.emit(assign(r22EE, less(r22EF, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r22F1 = lequal(body.constant(int(2045)), r2228);
               ir_if *f22F0 = new(mem_ctx) ir_if(operand(r22F1).val);
               exec_list *const f22F0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f22F0->then_instructions;

                  ir_variable *const r22F2 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r22F4 = less(body.constant(int(2045)), r2228);
                  ir_if *f22F3 = new(mem_ctx) ir_if(operand(r22F4).val);
                  exec_list *const f22F3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f22F3->then_instructions;

                     body.emit(assign(r22F2, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f22F3->else_instructions;

                     ir_variable *const r22F5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r22F7 = equal(r2228, body.constant(int(2045)));
                     ir_if *f22F6 = new(mem_ctx) ir_if(operand(r22F7).val);
                     exec_list *const f22F6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22F6->then_instructions;

                        ir_expression *const r22F8 = equal(body.constant(2097151u), r22E0);
                        ir_expression *const r22F9 = equal(body.constant(4294967295u), r22E1);
                        body.emit(assign(r22F5, logic_and(r22F8, r22F9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f22F6->else_instructions;

                        body.emit(assign(r22F5, body.constant(false), 0x01));


                     body.instructions = f22F6_parent_instructions;
                     body.emit(f22F6);

                     /* END IF */

                     body.emit(assign(r22F2, logic_and(r22F5, r22EE), 0x01));


                  body.instructions = f22F3_parent_instructions;
                  body.emit(f22F3);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f22FA = new(mem_ctx) ir_if(operand(r22F2).val);
                  exec_list *const f22FA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f22FA->then_instructions;

                     ir_variable *const r22FB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r22FB);
                     ir_expression *const r22FC = lshift(r221E, body.constant(int(31)));
                     body.emit(assign(r22FB, add(r22FC, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r22FB, body.constant(0u), 0x01));

                     body.emit(assign(r22ED, r22FB, 0x03));

                     body.emit(assign(r22EC, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f22FA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r22FE = less(r2228, body.constant(int(0)));
                     ir_if *f22FD = new(mem_ctx) ir_if(operand(r22FE).val);
                     exec_list *const f22FD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22FD->then_instructions;

                        ir_variable *const r22FF = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r22FF, r2229, 0x01));

                        ir_variable *const r2300 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2300, neg(r2228), 0x01));

                        ir_variable *const r2301 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2301);
                        ir_variable *const r2302 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2302);
                        ir_variable *const r2303 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2303);
                        ir_variable *const r2304 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2305 = neg(r2300);
                        body.emit(assign(r2304, bit_and(r2305, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2307 = equal(r2300, body.constant(int(0)));
                        ir_if *f2306 = new(mem_ctx) ir_if(operand(r2307).val);
                        exec_list *const f2306_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2306->then_instructions;

                           body.emit(assign(r2301, r2229, 0x01));

                           body.emit(assign(r2302, r22E1, 0x01));

                           body.emit(assign(r2303, r22E0, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2306->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2309 = less(r2300, body.constant(int(32)));
                           ir_if *f2308 = new(mem_ctx) ir_if(operand(r2309).val);
                           exec_list *const f2308_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2308->then_instructions;

                              body.emit(assign(r2301, lshift(r22E1, r2304), 0x01));

                              ir_expression *const r230A = lshift(r22E0, r2304);
                              ir_expression *const r230B = rshift(r22E1, r2300);
                              body.emit(assign(r2302, bit_or(r230A, r230B), 0x01));

                              body.emit(assign(r2303, rshift(r22E0, r2300), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2308->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r230D = equal(r2300, body.constant(int(32)));
                              ir_if *f230C = new(mem_ctx) ir_if(operand(r230D).val);
                              exec_list *const f230C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f230C->then_instructions;

                                 body.emit(assign(r2301, r22E1, 0x01));

                                 body.emit(assign(r2302, r22E0, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f230C->else_instructions;

                                 body.emit(assign(r22FF, bit_or(r2229, r22E1), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r230F = less(r2300, body.constant(int(64)));
                                 ir_if *f230E = new(mem_ctx) ir_if(operand(r230F).val);
                                 exec_list *const f230E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f230E->then_instructions;

                                    body.emit(assign(r2301, lshift(r22E0, r2304), 0x01));

                                    ir_expression *const r2310 = bit_and(r2300, body.constant(int(31)));
                                    body.emit(assign(r2302, rshift(r22E0, r2310), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f230E->else_instructions;

                                    ir_variable *const r2311 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2313 = equal(r2300, body.constant(int(64)));
                                    ir_if *f2312 = new(mem_ctx) ir_if(operand(r2313).val);
                                    exec_list *const f2312_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2312->then_instructions;

                                       body.emit(assign(r2311, r22E0, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2312->else_instructions;

                                       ir_expression *const r2314 = nequal(r22E0, body.constant(0u));
                                       ir_expression *const r2315 = expr(ir_unop_b2i, r2314);
                                       body.emit(assign(r2311, expr(ir_unop_i2u, r2315), 0x01));


                                    body.instructions = f2312_parent_instructions;
                                    body.emit(f2312);

                                    /* END IF */

                                    body.emit(assign(r2301, r2311, 0x01));

                                    body.emit(assign(r2302, body.constant(0u), 0x01));


                                 body.instructions = f230E_parent_instructions;
                                 body.emit(f230E);

                                 /* END IF */


                              body.instructions = f230C_parent_instructions;
                              body.emit(f230C);

                              /* END IF */

                              body.emit(assign(r2303, body.constant(0u), 0x01));


                           body.instructions = f2308_parent_instructions;
                           body.emit(f2308);

                           /* END IF */

                           ir_expression *const r2316 = nequal(r22FF, body.constant(0u));
                           ir_expression *const r2317 = expr(ir_unop_b2i, r2316);
                           ir_expression *const r2318 = expr(ir_unop_i2u, r2317);
                           body.emit(assign(r2301, bit_or(r2301, r2318), 0x01));


                        body.instructions = f2306_parent_instructions;
                        body.emit(f2306);

                        /* END IF */

                        body.emit(assign(r22E9, r2303, 0x01));

                        body.emit(assign(r22EA, r2302, 0x01));

                        body.emit(assign(r22EB, r2301, 0x01));

                        body.emit(assign(r22E8, body.constant(int(0)), 0x01));

                        body.emit(assign(r22EE, less(r2301, body.constant(0u)), 0x01));


                     body.instructions = f22FD_parent_instructions;
                     body.emit(f22FD);

                     /* END IF */


                  body.instructions = f22FA_parent_instructions;
                  body.emit(f22FA);

                  /* END IF */


               body.instructions = f22F0_parent_instructions;
               body.emit(f22F0);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2319 = new(mem_ctx) ir_if(operand(r22EC).val);
               exec_list *const f2319_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2319->then_instructions;

                  /* IF CONDITION */
                  ir_if *f231A = new(mem_ctx) ir_if(operand(r22EE).val);
                  exec_list *const f231A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f231A->then_instructions;

                     ir_variable *const r231B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r231B, add(r22EA, body.constant(1u)), 0x01));

                     ir_expression *const r231C = less(r231B, r22EA);
                     ir_expression *const r231D = expr(ir_unop_b2i, r231C);
                     ir_expression *const r231E = expr(ir_unop_i2u, r231D);
                     body.emit(assign(r22E9, add(r22E9, r231E), 0x01));

                     ir_expression *const r231F = equal(r22EB, body.constant(0u));
                     ir_expression *const r2320 = expr(ir_unop_b2i, r231F);
                     ir_expression *const r2321 = expr(ir_unop_i2u, r2320);
                     ir_expression *const r2322 = add(r22EB, r2321);
                     ir_expression *const r2323 = bit_and(r2322, body.constant(1u));
                     ir_expression *const r2324 = expr(ir_unop_bit_not, r2323);
                     body.emit(assign(r22EA, bit_and(r231B, r2324), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f231A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2326 = bit_or(r22E9, r22EA);
                     ir_expression *const r2327 = equal(r2326, body.constant(0u));
                     ir_if *f2325 = new(mem_ctx) ir_if(operand(r2327).val);
                     exec_list *const f2325_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2325->then_instructions;

                        body.emit(assign(r22E8, body.constant(int(0)), 0x01));


                     body.instructions = f2325_parent_instructions;
                     body.emit(f2325);

                     /* END IF */


                  body.instructions = f231A_parent_instructions;
                  body.emit(f231A);

                  /* END IF */

                  ir_variable *const r2328 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2328);
                  ir_expression *const r2329 = lshift(r221E, body.constant(int(31)));
                  ir_expression *const r232A = expr(ir_unop_i2u, r22E8);
                  ir_expression *const r232B = lshift(r232A, body.constant(int(20)));
                  ir_expression *const r232C = add(r2329, r232B);
                  body.emit(assign(r2328, add(r232C, r22E9), 0x02));

                  body.emit(assign(r2328, r22EA, 0x01));

                  body.emit(assign(r22ED, r2328, 0x03));

                  body.emit(assign(r22EC, body.constant(false), 0x01));


               body.instructions = f2319_parent_instructions;
               body.emit(f2319);

               /* END IF */

               body.emit(assign(r2222, r22ED, 0x03));

               body.emit(assign(r2221, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f22E6->else_instructions;

               body.emit(assign(r2228, add(r2228, body.constant(int(1))), 0x01));

               ir_variable *const r232D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r232D);
               ir_variable *const r232E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r232E);
               ir_variable *const r232F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r232F);
               body.emit(assign(r232D, lshift(r22E1, body.constant(int(31))), 0x01));

               ir_expression *const r2330 = lshift(r22E0, body.constant(int(31)));
               ir_expression *const r2331 = rshift(r22E1, body.constant(int(1)));
               body.emit(assign(r232E, bit_or(r2330, r2331), 0x01));

               body.emit(assign(r232F, rshift(r22E0, body.constant(int(1))), 0x01));

               ir_expression *const r2332 = nequal(r2229, body.constant(0u));
               ir_expression *const r2333 = expr(ir_unop_b2i, r2332);
               ir_expression *const r2334 = expr(ir_unop_i2u, r2333);
               body.emit(assign(r232D, bit_or(r232D, r2334), 0x01));

               body.emit(assign(r222A, r232F, 0x01));

               body.emit(assign(r2229, r232D, 0x01));

               ir_variable *const r2335 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2335, r2228, 0x01));

               ir_variable *const r2336 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2336, r232F, 0x01));

               ir_variable *const r2337 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2337, r232E, 0x01));

               ir_variable *const r2338 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2338, r232D, 0x01));

               ir_variable *const r2339 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2339, body.constant(true), 0x01));

               ir_variable *const r233A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r233B = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r233B);
               ir_expression *const r233C = expr(ir_unop_u2i, r232D);
               body.emit(assign(r233B, less(r233C, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r233E = lequal(body.constant(int(2045)), r2228);
               ir_if *f233D = new(mem_ctx) ir_if(operand(r233E).val);
               exec_list *const f233D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f233D->then_instructions;

                  ir_variable *const r233F = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2341 = less(body.constant(int(2045)), r2228);
                  ir_if *f2340 = new(mem_ctx) ir_if(operand(r2341).val);
                  exec_list *const f2340_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2340->then_instructions;

                     body.emit(assign(r233F, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2340->else_instructions;

                     ir_variable *const r2342 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2344 = equal(r2228, body.constant(int(2045)));
                     ir_if *f2343 = new(mem_ctx) ir_if(operand(r2344).val);
                     exec_list *const f2343_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2343->then_instructions;

                        ir_expression *const r2345 = equal(body.constant(2097151u), r232F);
                        ir_expression *const r2346 = equal(body.constant(4294967295u), r232E);
                        body.emit(assign(r2342, logic_and(r2345, r2346), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2343->else_instructions;

                        body.emit(assign(r2342, body.constant(false), 0x01));


                     body.instructions = f2343_parent_instructions;
                     body.emit(f2343);

                     /* END IF */

                     body.emit(assign(r233F, logic_and(r2342, r233B), 0x01));


                  body.instructions = f2340_parent_instructions;
                  body.emit(f2340);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2347 = new(mem_ctx) ir_if(operand(r233F).val);
                  exec_list *const f2347_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2347->then_instructions;

                     ir_variable *const r2348 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2348);
                     ir_expression *const r2349 = lshift(r221E, body.constant(int(31)));
                     body.emit(assign(r2348, add(r2349, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2348, body.constant(0u), 0x01));

                     body.emit(assign(r233A, r2348, 0x03));

                     body.emit(assign(r2339, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2347->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r234B = less(r2228, body.constant(int(0)));
                     ir_if *f234A = new(mem_ctx) ir_if(operand(r234B).val);
                     exec_list *const f234A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f234A->then_instructions;

                        ir_variable *const r234C = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r234C, r232D, 0x01));

                        ir_variable *const r234D = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r234D, neg(r2228), 0x01));

                        ir_variable *const r234E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r234E);
                        ir_variable *const r234F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r234F);
                        ir_variable *const r2350 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2350);
                        ir_variable *const r2351 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2352 = neg(r234D);
                        body.emit(assign(r2351, bit_and(r2352, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2354 = equal(r234D, body.constant(int(0)));
                        ir_if *f2353 = new(mem_ctx) ir_if(operand(r2354).val);
                        exec_list *const f2353_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2353->then_instructions;

                           body.emit(assign(r234E, r232D, 0x01));

                           body.emit(assign(r234F, r232E, 0x01));

                           body.emit(assign(r2350, r232F, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2353->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2356 = less(r234D, body.constant(int(32)));
                           ir_if *f2355 = new(mem_ctx) ir_if(operand(r2356).val);
                           exec_list *const f2355_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2355->then_instructions;

                              body.emit(assign(r234E, lshift(r232E, r2351), 0x01));

                              ir_expression *const r2357 = lshift(r232F, r2351);
                              ir_expression *const r2358 = rshift(r232E, r234D);
                              body.emit(assign(r234F, bit_or(r2357, r2358), 0x01));

                              body.emit(assign(r2350, rshift(r232F, r234D), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2355->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r235A = equal(r234D, body.constant(int(32)));
                              ir_if *f2359 = new(mem_ctx) ir_if(operand(r235A).val);
                              exec_list *const f2359_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2359->then_instructions;

                                 body.emit(assign(r234E, r232E, 0x01));

                                 body.emit(assign(r234F, r232F, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2359->else_instructions;

                                 body.emit(assign(r234C, bit_or(r232D, r232E), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r235C = less(r234D, body.constant(int(64)));
                                 ir_if *f235B = new(mem_ctx) ir_if(operand(r235C).val);
                                 exec_list *const f235B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f235B->then_instructions;

                                    body.emit(assign(r234E, lshift(r232F, r2351), 0x01));

                                    ir_expression *const r235D = bit_and(r234D, body.constant(int(31)));
                                    body.emit(assign(r234F, rshift(r232F, r235D), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f235B->else_instructions;

                                    ir_variable *const r235E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2360 = equal(r234D, body.constant(int(64)));
                                    ir_if *f235F = new(mem_ctx) ir_if(operand(r2360).val);
                                    exec_list *const f235F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f235F->then_instructions;

                                       body.emit(assign(r235E, r232F, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f235F->else_instructions;

                                       ir_expression *const r2361 = nequal(r232F, body.constant(0u));
                                       ir_expression *const r2362 = expr(ir_unop_b2i, r2361);
                                       body.emit(assign(r235E, expr(ir_unop_i2u, r2362), 0x01));


                                    body.instructions = f235F_parent_instructions;
                                    body.emit(f235F);

                                    /* END IF */

                                    body.emit(assign(r234E, r235E, 0x01));

                                    body.emit(assign(r234F, body.constant(0u), 0x01));


                                 body.instructions = f235B_parent_instructions;
                                 body.emit(f235B);

                                 /* END IF */


                              body.instructions = f2359_parent_instructions;
                              body.emit(f2359);

                              /* END IF */

                              body.emit(assign(r2350, body.constant(0u), 0x01));


                           body.instructions = f2355_parent_instructions;
                           body.emit(f2355);

                           /* END IF */

                           ir_expression *const r2363 = nequal(r234C, body.constant(0u));
                           ir_expression *const r2364 = expr(ir_unop_b2i, r2363);
                           ir_expression *const r2365 = expr(ir_unop_i2u, r2364);
                           body.emit(assign(r234E, bit_or(r234E, r2365), 0x01));


                        body.instructions = f2353_parent_instructions;
                        body.emit(f2353);

                        /* END IF */

                        body.emit(assign(r2336, r2350, 0x01));

                        body.emit(assign(r2337, r234F, 0x01));

                        body.emit(assign(r2338, r234E, 0x01));

                        body.emit(assign(r2335, body.constant(int(0)), 0x01));

                        body.emit(assign(r233B, less(r234E, body.constant(0u)), 0x01));


                     body.instructions = f234A_parent_instructions;
                     body.emit(f234A);

                     /* END IF */


                  body.instructions = f2347_parent_instructions;
                  body.emit(f2347);

                  /* END IF */


               body.instructions = f233D_parent_instructions;
               body.emit(f233D);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2366 = new(mem_ctx) ir_if(operand(r2339).val);
               exec_list *const f2366_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2366->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2367 = new(mem_ctx) ir_if(operand(r233B).val);
                  exec_list *const f2367_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2367->then_instructions;

                     ir_variable *const r2368 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2368, add(r2337, body.constant(1u)), 0x01));

                     ir_expression *const r2369 = less(r2368, r2337);
                     ir_expression *const r236A = expr(ir_unop_b2i, r2369);
                     ir_expression *const r236B = expr(ir_unop_i2u, r236A);
                     body.emit(assign(r2336, add(r2336, r236B), 0x01));

                     ir_expression *const r236C = equal(r2338, body.constant(0u));
                     ir_expression *const r236D = expr(ir_unop_b2i, r236C);
                     ir_expression *const r236E = expr(ir_unop_i2u, r236D);
                     ir_expression *const r236F = add(r2338, r236E);
                     ir_expression *const r2370 = bit_and(r236F, body.constant(1u));
                     ir_expression *const r2371 = expr(ir_unop_bit_not, r2370);
                     body.emit(assign(r2337, bit_and(r2368, r2371), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2367->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2373 = bit_or(r2336, r2337);
                     ir_expression *const r2374 = equal(r2373, body.constant(0u));
                     ir_if *f2372 = new(mem_ctx) ir_if(operand(r2374).val);
                     exec_list *const f2372_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2372->then_instructions;

                        body.emit(assign(r2335, body.constant(int(0)), 0x01));


                     body.instructions = f2372_parent_instructions;
                     body.emit(f2372);

                     /* END IF */


                  body.instructions = f2367_parent_instructions;
                  body.emit(f2367);

                  /* END IF */

                  ir_variable *const r2375 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2375);
                  ir_expression *const r2376 = lshift(r221E, body.constant(int(31)));
                  ir_expression *const r2377 = expr(ir_unop_i2u, r2335);
                  ir_expression *const r2378 = lshift(r2377, body.constant(int(20)));
                  ir_expression *const r2379 = add(r2376, r2378);
                  body.emit(assign(r2375, add(r2379, r2336), 0x02));

                  body.emit(assign(r2375, r2337, 0x01));

                  body.emit(assign(r233A, r2375, 0x03));

                  body.emit(assign(r2339, body.constant(false), 0x01));


               body.instructions = f2366_parent_instructions;
               body.emit(f2366);

               /* END IF */

               body.emit(assign(r2222, r233A, 0x03));

               body.emit(assign(r2221, body.constant(false), 0x01));


            body.instructions = f22E6_parent_instructions;
            body.emit(f22E6);

            /* END IF */


         body.instructions = f22DF_parent_instructions;
         body.emit(f22DF);

         /* END IF */

         body.emit(assign(r221D, r2222, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f221F->else_instructions;

         ir_variable *const r237A = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r237A, r221E, 0x01));

         ir_variable *const r237B = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r237C = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r237C);
         ir_variable *const r237D = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r237D);
         ir_variable *const r237E = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r237E);
         ir_variable *const r237F = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r237F);
         ir_variable *const r2380 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r2380);
         ir_variable *const r2381 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r2381);
         ir_variable *const r2382 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r2382);
         ir_variable *const r2383 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r2383);
         ir_variable *const r2384 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r2384, body.constant(0u), 0x01));

         ir_variable *const r2385 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r2386 = rshift(swizzle_y(r21E9), body.constant(int(20)));
         ir_expression *const r2387 = bit_and(r2386, body.constant(2047u));
         body.emit(assign(r2385, expr(ir_unop_u2i, r2387), 0x01));

         body.emit(assign(r237E, r2385, 0x01));

         body.emit(assign(r237D, body.constant(int(1023)), 0x01));

         body.emit(assign(r237C, add(r2385, body.constant(int(-1023))), 0x01));

         ir_variable *const r2388 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r2388, lshift(swizzle_x(r21E9), body.constant(int(10))), 0x01));

         ir_variable *const r2389 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r238A = bit_and(swizzle_y(r21E9), body.constant(1048575u));
         ir_expression *const r238B = lshift(r238A, body.constant(int(10)));
         ir_expression *const r238C = rshift(swizzle_x(r21E9), body.constant(int(22)));
         body.emit(assign(r2389, bit_or(r238B, r238C), 0x01));

         body.emit(assign(r2381, r2389, 0x01));

         body.emit(assign(r2382, r2388, 0x01));

         ir_variable *const r238D = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r238D, body.constant(0u), 0x01));

         ir_variable *const r238E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r238E, body.constant(0u), 0x01));

         body.emit(assign(r237F, r238E, 0x01));

         body.emit(assign(r2380, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r2390 = less(body.constant(int(0)), r237C);
         ir_if *f238F = new(mem_ctx) ir_if(operand(r2390).val);
         exec_list *const f238F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f238F->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2392 = equal(r2385, body.constant(int(2047)));
            ir_if *f2391 = new(mem_ctx) ir_if(operand(r2392).val);
            exec_list *const f2391_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2391->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2394 = bit_or(r2389, r2388);
               ir_expression *const r2395 = nequal(r2394, body.constant(0u));
               ir_if *f2393 = new(mem_ctx) ir_if(operand(r2395).val);
               exec_list *const f2393_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2393->then_instructions;

                  ir_variable *const r2396 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2396, swizzle_x(r21E9), 0x01));

                  ir_variable *const r2397 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2397, body.constant(0u), 0x01));

                  ir_variable *const r2398 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r2396, bit_or(swizzle_y(r21E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r2397, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r239A = lshift(swizzle_y(r21E9), body.constant(int(1)));
                  ir_expression *const r239B = lequal(body.constant(4292870144u), r239A);
                  ir_expression *const r239C = nequal(swizzle_x(r21E9), body.constant(0u));
                  ir_expression *const r239D = bit_and(swizzle_y(r21E9), body.constant(1048575u));
                  ir_expression *const r239E = nequal(r239D, body.constant(0u));
                  ir_expression *const r239F = logic_or(r239C, r239E);
                  ir_expression *const r23A0 = logic_and(r239B, r239F);
                  ir_if *f2399 = new(mem_ctx) ir_if(operand(r23A0).val);
                  exec_list *const f2399_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2399->then_instructions;

                     body.emit(assign(r2398, r2396, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2399->else_instructions;

                     body.emit(assign(r2398, r2397, 0x03));


                  body.instructions = f2399_parent_instructions;
                  body.emit(f2399);

                  /* END IF */

                  body.emit(assign(r237B, r2398, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2393->else_instructions;

                  body.emit(assign(r237B, r21E9, 0x03));


               body.instructions = f2393_parent_instructions;
               body.emit(f2393);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2391->else_instructions;

               body.emit(assign(r237F, body.constant(1073741824u), 0x01));

               ir_variable *const r23A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r23A1);
               ir_variable *const r23A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r23A2);
               ir_variable *const r23A3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r23A4 = neg(r237C);
               body.emit(assign(r23A3, bit_and(r23A4, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r23A6 = equal(r237C, body.constant(int(0)));
               ir_if *f23A5 = new(mem_ctx) ir_if(operand(r23A6).val);
               exec_list *const f23A5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23A5->then_instructions;

                  body.emit(assign(r23A1, body.constant(0u), 0x01));

                  body.emit(assign(r23A2, r237F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f23A5->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r23A8 = less(r237C, body.constant(int(32)));
                  ir_if *f23A7 = new(mem_ctx) ir_if(operand(r23A8).val);
                  exec_list *const f23A7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23A7->then_instructions;

                     ir_expression *const r23A9 = lshift(body.constant(1073741824u), r23A3);
                     ir_expression *const r23AA = bit_or(r23A9, body.constant(0u));
                     body.emit(assign(r23A1, bit_or(r23AA, body.constant(0u)), 0x01));

                     body.emit(assign(r23A2, rshift(body.constant(1073741824u), r237C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23A7->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r23AC = equal(r237C, body.constant(int(32)));
                     ir_if *f23AB = new(mem_ctx) ir_if(operand(r23AC).val);
                     exec_list *const f23AB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f23AB->then_instructions;

                        body.emit(assign(r23A1, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f23AB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r23AE = less(r237C, body.constant(int(64)));
                        ir_if *f23AD = new(mem_ctx) ir_if(operand(r23AE).val);
                        exec_list *const f23AD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f23AD->then_instructions;

                           ir_expression *const r23AF = bit_and(r237C, body.constant(int(31)));
                           ir_expression *const r23B0 = rshift(body.constant(1073741824u), r23AF);
                           ir_expression *const r23B1 = lshift(body.constant(1073741824u), r23A3);
                           ir_expression *const r23B2 = bit_or(r23B1, body.constant(0u));
                           ir_expression *const r23B3 = nequal(r23B2, body.constant(0u));
                           ir_expression *const r23B4 = expr(ir_unop_b2i, r23B3);
                           ir_expression *const r23B5 = expr(ir_unop_i2u, r23B4);
                           body.emit(assign(r23A1, bit_or(r23B0, r23B5), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f23AD->else_instructions;

                           body.emit(assign(r23A1, body.constant(1u), 0x01));


                        body.instructions = f23AD_parent_instructions;
                        body.emit(f23AD);

                        /* END IF */


                     body.instructions = f23AB_parent_instructions;
                     body.emit(f23AB);

                     /* END IF */

                     body.emit(assign(r23A2, body.constant(0u), 0x01));


                  body.instructions = f23A7_parent_instructions;
                  body.emit(f23A7);

                  /* END IF */


               body.instructions = f23A5_parent_instructions;
               body.emit(f23A5);

               /* END IF */

               body.emit(assign(r237F, r23A2, 0x01));

               body.emit(assign(r2380, r23A1, 0x01));

               body.emit(assign(r2381, bit_or(r2389, body.constant(1073741824u)), 0x01));

               ir_variable *const r23B6 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r23B7 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r23B7, sub(r2388, r23A1), 0x01));

               ir_expression *const r23B8 = sub(r2381, r23A2);
               ir_expression *const r23B9 = less(r2388, r23A1);
               ir_expression *const r23BA = expr(ir_unop_b2i, r23B9);
               ir_expression *const r23BB = expr(ir_unop_i2u, r23BA);
               body.emit(assign(r23B6, sub(r23B8, r23BB), 0x01));

               body.emit(assign(r2383, add(r2385, body.constant(int(-1))), 0x01));

               ir_variable *const r23BC = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r23BC, add(r2383, body.constant(int(-10))), 0x01));

               ir_variable *const r23BD = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r23BD, r23B6, 0x01));

               ir_variable *const r23BE = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r23BE, r23B7, 0x01));

               ir_variable *const r23BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r23BF);
               ir_variable *const r23C0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r23C0);
               /* IF CONDITION */
               ir_expression *const r23C2 = equal(r23B6, body.constant(0u));
               ir_if *f23C1 = new(mem_ctx) ir_if(operand(r23C2).val);
               exec_list *const f23C1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23C1->then_instructions;

                  body.emit(assign(r23BD, r23B7, 0x01));

                  body.emit(assign(r23BE, body.constant(0u), 0x01));

                  body.emit(assign(r23BC, add(r23BC, body.constant(int(-32))), 0x01));


               body.instructions = f23C1_parent_instructions;
               body.emit(f23C1);

               /* END IF */

               ir_variable *const r23C3 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r23C3, r23BD, 0x01));

               ir_variable *const r23C4 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r23C5 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r23C5);
               /* IF CONDITION */
               ir_expression *const r23C7 = equal(r23BD, body.constant(0u));
               ir_if *f23C6 = new(mem_ctx) ir_if(operand(r23C7).val);
               exec_list *const f23C6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23C6->then_instructions;

                  body.emit(assign(r23C4, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f23C6->else_instructions;

                  body.emit(assign(r23C5, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r23C9 = bit_and(r23BD, body.constant(4294901760u));
                  ir_expression *const r23CA = equal(r23C9, body.constant(0u));
                  ir_if *f23C8 = new(mem_ctx) ir_if(operand(r23CA).val);
                  exec_list *const f23C8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23C8->then_instructions;

                     body.emit(assign(r23C5, body.constant(int(16)), 0x01));

                     body.emit(assign(r23C3, lshift(r23BD, body.constant(int(16))), 0x01));


                  body.instructions = f23C8_parent_instructions;
                  body.emit(f23C8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r23CC = bit_and(r23C3, body.constant(4278190080u));
                  ir_expression *const r23CD = equal(r23CC, body.constant(0u));
                  ir_if *f23CB = new(mem_ctx) ir_if(operand(r23CD).val);
                  exec_list *const f23CB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23CB->then_instructions;

                     body.emit(assign(r23C5, add(r23C5, body.constant(int(8))), 0x01));

                     body.emit(assign(r23C3, lshift(r23C3, body.constant(int(8))), 0x01));


                  body.instructions = f23CB_parent_instructions;
                  body.emit(f23CB);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r23CF = bit_and(r23C3, body.constant(4026531840u));
                  ir_expression *const r23D0 = equal(r23CF, body.constant(0u));
                  ir_if *f23CE = new(mem_ctx) ir_if(operand(r23D0).val);
                  exec_list *const f23CE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23CE->then_instructions;

                     body.emit(assign(r23C5, add(r23C5, body.constant(int(4))), 0x01));

                     body.emit(assign(r23C3, lshift(r23C3, body.constant(int(4))), 0x01));


                  body.instructions = f23CE_parent_instructions;
                  body.emit(f23CE);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r23D2 = bit_and(r23C3, body.constant(3221225472u));
                  ir_expression *const r23D3 = equal(r23D2, body.constant(0u));
                  ir_if *f23D1 = new(mem_ctx) ir_if(operand(r23D3).val);
                  exec_list *const f23D1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23D1->then_instructions;

                     body.emit(assign(r23C5, add(r23C5, body.constant(int(2))), 0x01));

                     body.emit(assign(r23C3, lshift(r23C3, body.constant(int(2))), 0x01));


                  body.instructions = f23D1_parent_instructions;
                  body.emit(f23D1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r23D5 = bit_and(r23C3, body.constant(2147483648u));
                  ir_expression *const r23D6 = equal(r23D5, body.constant(0u));
                  ir_if *f23D4 = new(mem_ctx) ir_if(operand(r23D6).val);
                  exec_list *const f23D4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23D4->then_instructions;

                     body.emit(assign(r23C5, add(r23C5, body.constant(int(1))), 0x01));


                  body.instructions = f23D4_parent_instructions;
                  body.emit(f23D4);

                  /* END IF */

                  body.emit(assign(r23C4, r23C5, 0x01));


               body.instructions = f23C6_parent_instructions;
               body.emit(f23C6);

               /* END IF */

               body.emit(assign(r23C0, add(r23C4, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r23D8 = lequal(body.constant(int(0)), r23C0);
               ir_if *f23D7 = new(mem_ctx) ir_if(operand(r23D8).val);
               exec_list *const f23D7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23D7->then_instructions;

                  body.emit(assign(r23BF, body.constant(0u), 0x01));

                  ir_variable *const r23D9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r23D9, lshift(r23BE, r23C0), 0x01));

                  ir_variable *const r23DA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r23DC = equal(r23C0, body.constant(int(0)));
                  ir_if *f23DB = new(mem_ctx) ir_if(operand(r23DC).val);
                  exec_list *const f23DB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23DB->then_instructions;

                     body.emit(assign(r23DA, r23BD, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23DB->else_instructions;

                     ir_expression *const r23DD = lshift(r23BD, r23C0);
                     ir_expression *const r23DE = neg(r23C0);
                     ir_expression *const r23DF = bit_and(r23DE, body.constant(int(31)));
                     ir_expression *const r23E0 = rshift(r23BE, r23DF);
                     body.emit(assign(r23DA, bit_or(r23DD, r23E0), 0x01));


                  body.instructions = f23DB_parent_instructions;
                  body.emit(f23DB);

                  /* END IF */

                  body.emit(assign(r23BD, r23DA, 0x01));

                  body.emit(assign(r23BE, r23D9, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f23D7->else_instructions;

                  ir_variable *const r23E1 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r23E1, body.constant(0u), 0x01));

                  ir_variable *const r23E2 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r23E2, neg(r23C0), 0x01));

                  ir_variable *const r23E3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r23E3);
                  ir_variable *const r23E4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r23E4);
                  ir_variable *const r23E5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r23E5);
                  ir_variable *const r23E6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r23E7 = neg(r23E2);
                  body.emit(assign(r23E6, bit_and(r23E7, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r23E9 = equal(r23E2, body.constant(int(0)));
                  ir_if *f23E8 = new(mem_ctx) ir_if(operand(r23E9).val);
                  exec_list *const f23E8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23E8->then_instructions;

                     body.emit(assign(r23E3, r23E1, 0x01));

                     body.emit(assign(r23E4, r23BE, 0x01));

                     body.emit(assign(r23E5, r23BD, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23E8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r23EB = less(r23E2, body.constant(int(32)));
                     ir_if *f23EA = new(mem_ctx) ir_if(operand(r23EB).val);
                     exec_list *const f23EA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f23EA->then_instructions;

                        body.emit(assign(r23E3, lshift(r23BE, r23E6), 0x01));

                        ir_expression *const r23EC = lshift(r23BD, r23E6);
                        ir_expression *const r23ED = rshift(r23BE, r23E2);
                        body.emit(assign(r23E4, bit_or(r23EC, r23ED), 0x01));

                        body.emit(assign(r23E5, rshift(r23BD, r23E2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f23EA->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r23EF = equal(r23E2, body.constant(int(32)));
                        ir_if *f23EE = new(mem_ctx) ir_if(operand(r23EF).val);
                        exec_list *const f23EE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f23EE->then_instructions;

                           body.emit(assign(r23E3, r23BE, 0x01));

                           body.emit(assign(r23E4, r23BD, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f23EE->else_instructions;

                           body.emit(assign(r23E1, bit_or(body.constant(0u), r23BE), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r23F1 = less(r23E2, body.constant(int(64)));
                           ir_if *f23F0 = new(mem_ctx) ir_if(operand(r23F1).val);
                           exec_list *const f23F0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f23F0->then_instructions;

                              body.emit(assign(r23E3, lshift(r23BD, r23E6), 0x01));

                              ir_expression *const r23F2 = bit_and(r23E2, body.constant(int(31)));
                              body.emit(assign(r23E4, rshift(r23BD, r23F2), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f23F0->else_instructions;

                              ir_variable *const r23F3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r23F5 = equal(r23E2, body.constant(int(64)));
                              ir_if *f23F4 = new(mem_ctx) ir_if(operand(r23F5).val);
                              exec_list *const f23F4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f23F4->then_instructions;

                                 body.emit(assign(r23F3, r23BD, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f23F4->else_instructions;

                                 ir_expression *const r23F6 = nequal(r23BD, body.constant(0u));
                                 ir_expression *const r23F7 = expr(ir_unop_b2i, r23F6);
                                 body.emit(assign(r23F3, expr(ir_unop_i2u, r23F7), 0x01));


                              body.instructions = f23F4_parent_instructions;
                              body.emit(f23F4);

                              /* END IF */

                              body.emit(assign(r23E3, r23F3, 0x01));

                              body.emit(assign(r23E4, body.constant(0u), 0x01));


                           body.instructions = f23F0_parent_instructions;
                           body.emit(f23F0);

                           /* END IF */


                        body.instructions = f23EE_parent_instructions;
                        body.emit(f23EE);

                        /* END IF */

                        body.emit(assign(r23E5, body.constant(0u), 0x01));


                     body.instructions = f23EA_parent_instructions;
                     body.emit(f23EA);

                     /* END IF */

                     ir_expression *const r23F8 = nequal(r23E1, body.constant(0u));
                     ir_expression *const r23F9 = expr(ir_unop_b2i, r23F8);
                     ir_expression *const r23FA = expr(ir_unop_i2u, r23F9);
                     body.emit(assign(r23E3, bit_or(r23E3, r23FA), 0x01));


                  body.instructions = f23E8_parent_instructions;
                  body.emit(f23E8);

                  /* END IF */

                  body.emit(assign(r23BD, r23E5, 0x01));

                  body.emit(assign(r23BE, r23E4, 0x01));

                  body.emit(assign(r23BF, r23E3, 0x01));


               body.instructions = f23D7_parent_instructions;
               body.emit(f23D7);

               /* END IF */

               body.emit(assign(r23BC, sub(r23BC, r23C0), 0x01));

               ir_variable *const r23FB = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r23FB, r23BC, 0x01));

               ir_variable *const r23FC = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r23FC, r23BD, 0x01));

               ir_variable *const r23FD = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r23FD, r23BE, 0x01));

               ir_variable *const r23FE = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r23FE, r23BF, 0x01));

               ir_variable *const r23FF = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r23FF, body.constant(true), 0x01));

               ir_variable *const r2400 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2401 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2401);
               ir_expression *const r2402 = expr(ir_unop_u2i, r23BF);
               body.emit(assign(r2401, less(r2402, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2404 = lequal(body.constant(int(2045)), r23BC);
               ir_if *f2403 = new(mem_ctx) ir_if(operand(r2404).val);
               exec_list *const f2403_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2403->then_instructions;

                  ir_variable *const r2405 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2407 = less(body.constant(int(2045)), r23BC);
                  ir_if *f2406 = new(mem_ctx) ir_if(operand(r2407).val);
                  exec_list *const f2406_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2406->then_instructions;

                     body.emit(assign(r2405, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2406->else_instructions;

                     ir_variable *const r2408 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r240A = equal(r23BC, body.constant(int(2045)));
                     ir_if *f2409 = new(mem_ctx) ir_if(operand(r240A).val);
                     exec_list *const f2409_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2409->then_instructions;

                        ir_expression *const r240B = equal(body.constant(2097151u), r23BD);
                        ir_expression *const r240C = equal(body.constant(4294967295u), r23BE);
                        body.emit(assign(r2408, logic_and(r240B, r240C), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2409->else_instructions;

                        body.emit(assign(r2408, body.constant(false), 0x01));


                     body.instructions = f2409_parent_instructions;
                     body.emit(f2409);

                     /* END IF */

                     body.emit(assign(r2405, logic_and(r2408, r2401), 0x01));


                  body.instructions = f2406_parent_instructions;
                  body.emit(f2406);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f240D = new(mem_ctx) ir_if(operand(r2405).val);
                  exec_list *const f240D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f240D->then_instructions;

                     ir_variable *const r240E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r240E);
                     ir_expression *const r240F = lshift(r221E, body.constant(int(31)));
                     body.emit(assign(r240E, add(r240F, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r240E, body.constant(0u), 0x01));

                     body.emit(assign(r2400, r240E, 0x03));

                     body.emit(assign(r23FF, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f240D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2411 = less(r23BC, body.constant(int(0)));
                     ir_if *f2410 = new(mem_ctx) ir_if(operand(r2411).val);
                     exec_list *const f2410_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2410->then_instructions;

                        ir_variable *const r2412 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2412, r23BF, 0x01));

                        ir_variable *const r2413 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2413, neg(r23BC), 0x01));

                        ir_variable *const r2414 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2414);
                        ir_variable *const r2415 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2415);
                        ir_variable *const r2416 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2416);
                        ir_variable *const r2417 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2418 = neg(r2413);
                        body.emit(assign(r2417, bit_and(r2418, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r241A = equal(r2413, body.constant(int(0)));
                        ir_if *f2419 = new(mem_ctx) ir_if(operand(r241A).val);
                        exec_list *const f2419_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2419->then_instructions;

                           body.emit(assign(r2414, r23BF, 0x01));

                           body.emit(assign(r2415, r23BE, 0x01));

                           body.emit(assign(r2416, r23BD, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2419->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r241C = less(r2413, body.constant(int(32)));
                           ir_if *f241B = new(mem_ctx) ir_if(operand(r241C).val);
                           exec_list *const f241B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f241B->then_instructions;

                              body.emit(assign(r2414, lshift(r23BE, r2417), 0x01));

                              ir_expression *const r241D = lshift(r23BD, r2417);
                              ir_expression *const r241E = rshift(r23BE, r2413);
                              body.emit(assign(r2415, bit_or(r241D, r241E), 0x01));

                              body.emit(assign(r2416, rshift(r23BD, r2413), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f241B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2420 = equal(r2413, body.constant(int(32)));
                              ir_if *f241F = new(mem_ctx) ir_if(operand(r2420).val);
                              exec_list *const f241F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f241F->then_instructions;

                                 body.emit(assign(r2414, r23BE, 0x01));

                                 body.emit(assign(r2415, r23BD, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f241F->else_instructions;

                                 body.emit(assign(r2412, bit_or(r23BF, r23BE), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2422 = less(r2413, body.constant(int(64)));
                                 ir_if *f2421 = new(mem_ctx) ir_if(operand(r2422).val);
                                 exec_list *const f2421_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2421->then_instructions;

                                    body.emit(assign(r2414, lshift(r23BD, r2417), 0x01));

                                    ir_expression *const r2423 = bit_and(r2413, body.constant(int(31)));
                                    body.emit(assign(r2415, rshift(r23BD, r2423), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2421->else_instructions;

                                    ir_variable *const r2424 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2426 = equal(r2413, body.constant(int(64)));
                                    ir_if *f2425 = new(mem_ctx) ir_if(operand(r2426).val);
                                    exec_list *const f2425_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2425->then_instructions;

                                       body.emit(assign(r2424, r23BD, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2425->else_instructions;

                                       ir_expression *const r2427 = nequal(r23BD, body.constant(0u));
                                       ir_expression *const r2428 = expr(ir_unop_b2i, r2427);
                                       body.emit(assign(r2424, expr(ir_unop_i2u, r2428), 0x01));


                                    body.instructions = f2425_parent_instructions;
                                    body.emit(f2425);

                                    /* END IF */

                                    body.emit(assign(r2414, r2424, 0x01));

                                    body.emit(assign(r2415, body.constant(0u), 0x01));


                                 body.instructions = f2421_parent_instructions;
                                 body.emit(f2421);

                                 /* END IF */


                              body.instructions = f241F_parent_instructions;
                              body.emit(f241F);

                              /* END IF */

                              body.emit(assign(r2416, body.constant(0u), 0x01));


                           body.instructions = f241B_parent_instructions;
                           body.emit(f241B);

                           /* END IF */

                           ir_expression *const r2429 = nequal(r2412, body.constant(0u));
                           ir_expression *const r242A = expr(ir_unop_b2i, r2429);
                           ir_expression *const r242B = expr(ir_unop_i2u, r242A);
                           body.emit(assign(r2414, bit_or(r2414, r242B), 0x01));


                        body.instructions = f2419_parent_instructions;
                        body.emit(f2419);

                        /* END IF */

                        body.emit(assign(r23FC, r2416, 0x01));

                        body.emit(assign(r23FD, r2415, 0x01));

                        body.emit(assign(r23FE, r2414, 0x01));

                        body.emit(assign(r23FB, body.constant(int(0)), 0x01));

                        body.emit(assign(r2401, less(r2414, body.constant(0u)), 0x01));


                     body.instructions = f2410_parent_instructions;
                     body.emit(f2410);

                     /* END IF */


                  body.instructions = f240D_parent_instructions;
                  body.emit(f240D);

                  /* END IF */


               body.instructions = f2403_parent_instructions;
               body.emit(f2403);

               /* END IF */

               /* IF CONDITION */
               ir_if *f242C = new(mem_ctx) ir_if(operand(r23FF).val);
               exec_list *const f242C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f242C->then_instructions;

                  /* IF CONDITION */
                  ir_if *f242D = new(mem_ctx) ir_if(operand(r2401).val);
                  exec_list *const f242D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f242D->then_instructions;

                     ir_variable *const r242E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r242E, add(r23FD, body.constant(1u)), 0x01));

                     ir_expression *const r242F = less(r242E, r23FD);
                     ir_expression *const r2430 = expr(ir_unop_b2i, r242F);
                     ir_expression *const r2431 = expr(ir_unop_i2u, r2430);
                     body.emit(assign(r23FC, add(r23FC, r2431), 0x01));

                     ir_expression *const r2432 = equal(r23FE, body.constant(0u));
                     ir_expression *const r2433 = expr(ir_unop_b2i, r2432);
                     ir_expression *const r2434 = expr(ir_unop_i2u, r2433);
                     ir_expression *const r2435 = add(r23FE, r2434);
                     ir_expression *const r2436 = bit_and(r2435, body.constant(1u));
                     ir_expression *const r2437 = expr(ir_unop_bit_not, r2436);
                     body.emit(assign(r23FD, bit_and(r242E, r2437), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f242D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2439 = bit_or(r23FC, r23FD);
                     ir_expression *const r243A = equal(r2439, body.constant(0u));
                     ir_if *f2438 = new(mem_ctx) ir_if(operand(r243A).val);
                     exec_list *const f2438_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2438->then_instructions;

                        body.emit(assign(r23FB, body.constant(int(0)), 0x01));


                     body.instructions = f2438_parent_instructions;
                     body.emit(f2438);

                     /* END IF */


                  body.instructions = f242D_parent_instructions;
                  body.emit(f242D);

                  /* END IF */

                  ir_variable *const r243B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r243B);
                  ir_expression *const r243C = lshift(r221E, body.constant(int(31)));
                  ir_expression *const r243D = expr(ir_unop_i2u, r23FB);
                  ir_expression *const r243E = lshift(r243D, body.constant(int(20)));
                  ir_expression *const r243F = add(r243C, r243E);
                  body.emit(assign(r243B, add(r243F, r23FC), 0x02));

                  body.emit(assign(r243B, r23FD, 0x01));

                  body.emit(assign(r2400, r243B, 0x03));

                  body.emit(assign(r23FF, body.constant(false), 0x01));


               body.instructions = f242C_parent_instructions;
               body.emit(f242C);

               /* END IF */

               body.emit(assign(r237B, r2400, 0x03));


            body.instructions = f2391_parent_instructions;
            body.emit(f2391);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f238F->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2441 = less(r237C, body.constant(int(0)));
            ir_if *f2440 = new(mem_ctx) ir_if(operand(r2441).val);
            exec_list *const f2440_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2440->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2443 = equal(r2385, body.constant(int(0)));
               ir_if *f2442 = new(mem_ctx) ir_if(operand(r2443).val);
               exec_list *const f2442_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2442->then_instructions;

                  body.emit(assign(r237C, add(r237C, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2442->else_instructions;

                  body.emit(assign(r2381, bit_or(r2381, body.constant(1073741824u)), 0x01));


               body.instructions = f2442_parent_instructions;
               body.emit(f2442);

               /* END IF */

               ir_variable *const r2444 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2444, neg(r237C), 0x01));

               ir_variable *const r2445 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2445);
               ir_variable *const r2446 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2446);
               ir_variable *const r2447 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2448 = neg(r2444);
               body.emit(assign(r2447, bit_and(r2448, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r244A = equal(r2444, body.constant(int(0)));
               ir_if *f2449 = new(mem_ctx) ir_if(operand(r244A).val);
               exec_list *const f2449_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2449->then_instructions;

                  body.emit(assign(r2445, r2388, 0x01));

                  body.emit(assign(r2446, r2381, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2449->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r244C = less(r2444, body.constant(int(32)));
                  ir_if *f244B = new(mem_ctx) ir_if(operand(r244C).val);
                  exec_list *const f244B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f244B->then_instructions;

                     ir_expression *const r244D = lshift(r2381, r2447);
                     ir_expression *const r244E = rshift(r2388, r2444);
                     ir_expression *const r244F = bit_or(r244D, r244E);
                     ir_expression *const r2450 = lshift(r2388, r2447);
                     ir_expression *const r2451 = nequal(r2450, body.constant(0u));
                     ir_expression *const r2452 = expr(ir_unop_b2i, r2451);
                     ir_expression *const r2453 = expr(ir_unop_i2u, r2452);
                     body.emit(assign(r2445, bit_or(r244F, r2453), 0x01));

                     body.emit(assign(r2446, rshift(r2381, r2444), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f244B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2455 = equal(r2444, body.constant(int(32)));
                     ir_if *f2454 = new(mem_ctx) ir_if(operand(r2455).val);
                     exec_list *const f2454_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2454->then_instructions;

                        ir_expression *const r2456 = nequal(r2388, body.constant(0u));
                        ir_expression *const r2457 = expr(ir_unop_b2i, r2456);
                        ir_expression *const r2458 = expr(ir_unop_i2u, r2457);
                        body.emit(assign(r2445, bit_or(r2381, r2458), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2454->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r245A = less(r2444, body.constant(int(64)));
                        ir_if *f2459 = new(mem_ctx) ir_if(operand(r245A).val);
                        exec_list *const f2459_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2459->then_instructions;

                           ir_expression *const r245B = bit_and(r2444, body.constant(int(31)));
                           ir_expression *const r245C = rshift(r2381, r245B);
                           ir_expression *const r245D = lshift(r2381, r2447);
                           ir_expression *const r245E = bit_or(r245D, r2388);
                           ir_expression *const r245F = nequal(r245E, body.constant(0u));
                           ir_expression *const r2460 = expr(ir_unop_b2i, r245F);
                           ir_expression *const r2461 = expr(ir_unop_i2u, r2460);
                           body.emit(assign(r2445, bit_or(r245C, r2461), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2459->else_instructions;

                           ir_expression *const r2462 = bit_or(r2381, r2388);
                           ir_expression *const r2463 = nequal(r2462, body.constant(0u));
                           ir_expression *const r2464 = expr(ir_unop_b2i, r2463);
                           body.emit(assign(r2445, expr(ir_unop_i2u, r2464), 0x01));


                        body.instructions = f2459_parent_instructions;
                        body.emit(f2459);

                        /* END IF */


                     body.instructions = f2454_parent_instructions;
                     body.emit(f2454);

                     /* END IF */

                     body.emit(assign(r2446, body.constant(0u), 0x01));


                  body.instructions = f244B_parent_instructions;
                  body.emit(f244B);

                  /* END IF */


               body.instructions = f2449_parent_instructions;
               body.emit(f2449);

               /* END IF */

               body.emit(assign(r2381, r2446, 0x01));

               body.emit(assign(r2382, r2445, 0x01));

               body.emit(assign(r237F, bit_or(r237F, body.constant(1073741824u)), 0x01));

               ir_variable *const r2465 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r2466 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2466, sub(r2380, r2445), 0x01));

               ir_expression *const r2467 = sub(r237F, r2446);
               ir_expression *const r2468 = less(r2380, r2445);
               ir_expression *const r2469 = expr(ir_unop_b2i, r2468);
               ir_expression *const r246A = expr(ir_unop_i2u, r2469);
               body.emit(assign(r2465, sub(r2467, r246A), 0x01));

               body.emit(assign(r237A, bit_xor(r221E, body.constant(1u)), 0x01));

               body.emit(assign(r2383, body.constant(int(1022)), 0x01));

               ir_variable *const r246B = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r246B, body.constant(int(1012)), 0x01));

               ir_variable *const r246C = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r246C, r2465, 0x01));

               ir_variable *const r246D = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r246D, r2466, 0x01));

               ir_variable *const r246E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r246E);
               ir_variable *const r246F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r246F);
               /* IF CONDITION */
               ir_expression *const r2471 = equal(r2465, body.constant(0u));
               ir_if *f2470 = new(mem_ctx) ir_if(operand(r2471).val);
               exec_list *const f2470_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2470->then_instructions;

                  body.emit(assign(r246C, r2466, 0x01));

                  body.emit(assign(r246D, body.constant(0u), 0x01));

                  body.emit(assign(r246B, body.constant(int(980)), 0x01));


               body.instructions = f2470_parent_instructions;
               body.emit(f2470);

               /* END IF */

               ir_variable *const r2472 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2472, r246C, 0x01));

               ir_variable *const r2473 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r2474 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2474);
               /* IF CONDITION */
               ir_expression *const r2476 = equal(r246C, body.constant(0u));
               ir_if *f2475 = new(mem_ctx) ir_if(operand(r2476).val);
               exec_list *const f2475_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2475->then_instructions;

                  body.emit(assign(r2473, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2475->else_instructions;

                  body.emit(assign(r2474, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2478 = bit_and(r246C, body.constant(4294901760u));
                  ir_expression *const r2479 = equal(r2478, body.constant(0u));
                  ir_if *f2477 = new(mem_ctx) ir_if(operand(r2479).val);
                  exec_list *const f2477_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2477->then_instructions;

                     body.emit(assign(r2474, body.constant(int(16)), 0x01));

                     body.emit(assign(r2472, lshift(r246C, body.constant(int(16))), 0x01));


                  body.instructions = f2477_parent_instructions;
                  body.emit(f2477);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r247B = bit_and(r2472, body.constant(4278190080u));
                  ir_expression *const r247C = equal(r247B, body.constant(0u));
                  ir_if *f247A = new(mem_ctx) ir_if(operand(r247C).val);
                  exec_list *const f247A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f247A->then_instructions;

                     body.emit(assign(r2474, add(r2474, body.constant(int(8))), 0x01));

                     body.emit(assign(r2472, lshift(r2472, body.constant(int(8))), 0x01));


                  body.instructions = f247A_parent_instructions;
                  body.emit(f247A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r247E = bit_and(r2472, body.constant(4026531840u));
                  ir_expression *const r247F = equal(r247E, body.constant(0u));
                  ir_if *f247D = new(mem_ctx) ir_if(operand(r247F).val);
                  exec_list *const f247D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f247D->then_instructions;

                     body.emit(assign(r2474, add(r2474, body.constant(int(4))), 0x01));

                     body.emit(assign(r2472, lshift(r2472, body.constant(int(4))), 0x01));


                  body.instructions = f247D_parent_instructions;
                  body.emit(f247D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2481 = bit_and(r2472, body.constant(3221225472u));
                  ir_expression *const r2482 = equal(r2481, body.constant(0u));
                  ir_if *f2480 = new(mem_ctx) ir_if(operand(r2482).val);
                  exec_list *const f2480_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2480->then_instructions;

                     body.emit(assign(r2474, add(r2474, body.constant(int(2))), 0x01));

                     body.emit(assign(r2472, lshift(r2472, body.constant(int(2))), 0x01));


                  body.instructions = f2480_parent_instructions;
                  body.emit(f2480);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2484 = bit_and(r2472, body.constant(2147483648u));
                  ir_expression *const r2485 = equal(r2484, body.constant(0u));
                  ir_if *f2483 = new(mem_ctx) ir_if(operand(r2485).val);
                  exec_list *const f2483_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2483->then_instructions;

                     body.emit(assign(r2474, add(r2474, body.constant(int(1))), 0x01));


                  body.instructions = f2483_parent_instructions;
                  body.emit(f2483);

                  /* END IF */

                  body.emit(assign(r2473, r2474, 0x01));


               body.instructions = f2475_parent_instructions;
               body.emit(f2475);

               /* END IF */

               body.emit(assign(r246F, add(r2473, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2487 = lequal(body.constant(int(0)), r246F);
               ir_if *f2486 = new(mem_ctx) ir_if(operand(r2487).val);
               exec_list *const f2486_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2486->then_instructions;

                  body.emit(assign(r246E, body.constant(0u), 0x01));

                  ir_variable *const r2488 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2488, lshift(r246D, r246F), 0x01));

                  ir_variable *const r2489 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r248B = equal(r246F, body.constant(int(0)));
                  ir_if *f248A = new(mem_ctx) ir_if(operand(r248B).val);
                  exec_list *const f248A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f248A->then_instructions;

                     body.emit(assign(r2489, r246C, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f248A->else_instructions;

                     ir_expression *const r248C = lshift(r246C, r246F);
                     ir_expression *const r248D = neg(r246F);
                     ir_expression *const r248E = bit_and(r248D, body.constant(int(31)));
                     ir_expression *const r248F = rshift(r246D, r248E);
                     body.emit(assign(r2489, bit_or(r248C, r248F), 0x01));


                  body.instructions = f248A_parent_instructions;
                  body.emit(f248A);

                  /* END IF */

                  body.emit(assign(r246C, r2489, 0x01));

                  body.emit(assign(r246D, r2488, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2486->else_instructions;

                  ir_variable *const r2490 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2490, body.constant(0u), 0x01));

                  ir_variable *const r2491 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2491, neg(r246F), 0x01));

                  ir_variable *const r2492 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2492);
                  ir_variable *const r2493 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2493);
                  ir_variable *const r2494 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2494);
                  ir_variable *const r2495 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2496 = neg(r2491);
                  body.emit(assign(r2495, bit_and(r2496, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2498 = equal(r2491, body.constant(int(0)));
                  ir_if *f2497 = new(mem_ctx) ir_if(operand(r2498).val);
                  exec_list *const f2497_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2497->then_instructions;

                     body.emit(assign(r2492, r2490, 0x01));

                     body.emit(assign(r2493, r246D, 0x01));

                     body.emit(assign(r2494, r246C, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2497->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r249A = less(r2491, body.constant(int(32)));
                     ir_if *f2499 = new(mem_ctx) ir_if(operand(r249A).val);
                     exec_list *const f2499_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2499->then_instructions;

                        body.emit(assign(r2492, lshift(r246D, r2495), 0x01));

                        ir_expression *const r249B = lshift(r246C, r2495);
                        ir_expression *const r249C = rshift(r246D, r2491);
                        body.emit(assign(r2493, bit_or(r249B, r249C), 0x01));

                        body.emit(assign(r2494, rshift(r246C, r2491), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2499->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r249E = equal(r2491, body.constant(int(32)));
                        ir_if *f249D = new(mem_ctx) ir_if(operand(r249E).val);
                        exec_list *const f249D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f249D->then_instructions;

                           body.emit(assign(r2492, r246D, 0x01));

                           body.emit(assign(r2493, r246C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f249D->else_instructions;

                           body.emit(assign(r2490, bit_or(body.constant(0u), r246D), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r24A0 = less(r2491, body.constant(int(64)));
                           ir_if *f249F = new(mem_ctx) ir_if(operand(r24A0).val);
                           exec_list *const f249F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f249F->then_instructions;

                              body.emit(assign(r2492, lshift(r246C, r2495), 0x01));

                              ir_expression *const r24A1 = bit_and(r2491, body.constant(int(31)));
                              body.emit(assign(r2493, rshift(r246C, r24A1), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f249F->else_instructions;

                              ir_variable *const r24A2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r24A4 = equal(r2491, body.constant(int(64)));
                              ir_if *f24A3 = new(mem_ctx) ir_if(operand(r24A4).val);
                              exec_list *const f24A3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f24A3->then_instructions;

                                 body.emit(assign(r24A2, r246C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f24A3->else_instructions;

                                 ir_expression *const r24A5 = nequal(r246C, body.constant(0u));
                                 ir_expression *const r24A6 = expr(ir_unop_b2i, r24A5);
                                 body.emit(assign(r24A2, expr(ir_unop_i2u, r24A6), 0x01));


                              body.instructions = f24A3_parent_instructions;
                              body.emit(f24A3);

                              /* END IF */

                              body.emit(assign(r2492, r24A2, 0x01));

                              body.emit(assign(r2493, body.constant(0u), 0x01));


                           body.instructions = f249F_parent_instructions;
                           body.emit(f249F);

                           /* END IF */


                        body.instructions = f249D_parent_instructions;
                        body.emit(f249D);

                        /* END IF */

                        body.emit(assign(r2494, body.constant(0u), 0x01));


                     body.instructions = f2499_parent_instructions;
                     body.emit(f2499);

                     /* END IF */

                     ir_expression *const r24A7 = nequal(r2490, body.constant(0u));
                     ir_expression *const r24A8 = expr(ir_unop_b2i, r24A7);
                     ir_expression *const r24A9 = expr(ir_unop_i2u, r24A8);
                     body.emit(assign(r2492, bit_or(r2492, r24A9), 0x01));


                  body.instructions = f2497_parent_instructions;
                  body.emit(f2497);

                  /* END IF */

                  body.emit(assign(r246C, r2494, 0x01));

                  body.emit(assign(r246D, r2493, 0x01));

                  body.emit(assign(r246E, r2492, 0x01));


               body.instructions = f2486_parent_instructions;
               body.emit(f2486);

               /* END IF */

               body.emit(assign(r246B, sub(r246B, r246F), 0x01));

               ir_variable *const r24AA = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r24AA, r246B, 0x01));

               ir_variable *const r24AB = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r24AB, r246C, 0x01));

               ir_variable *const r24AC = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r24AC, r246D, 0x01));

               ir_variable *const r24AD = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r24AD, r246E, 0x01));

               ir_variable *const r24AE = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r24AE, body.constant(true), 0x01));

               ir_variable *const r24AF = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r24B0 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r24B0);
               ir_expression *const r24B1 = expr(ir_unop_u2i, r246E);
               body.emit(assign(r24B0, less(r24B1, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r24B3 = lequal(body.constant(int(2045)), r246B);
               ir_if *f24B2 = new(mem_ctx) ir_if(operand(r24B3).val);
               exec_list *const f24B2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f24B2->then_instructions;

                  ir_variable *const r24B4 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r24B6 = less(body.constant(int(2045)), r246B);
                  ir_if *f24B5 = new(mem_ctx) ir_if(operand(r24B6).val);
                  exec_list *const f24B5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24B5->then_instructions;

                     body.emit(assign(r24B4, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24B5->else_instructions;

                     ir_variable *const r24B7 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r24B9 = equal(r246B, body.constant(int(2045)));
                     ir_if *f24B8 = new(mem_ctx) ir_if(operand(r24B9).val);
                     exec_list *const f24B8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24B8->then_instructions;

                        ir_expression *const r24BA = equal(body.constant(2097151u), r246C);
                        ir_expression *const r24BB = equal(body.constant(4294967295u), r246D);
                        body.emit(assign(r24B7, logic_and(r24BA, r24BB), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f24B8->else_instructions;

                        body.emit(assign(r24B7, body.constant(false), 0x01));


                     body.instructions = f24B8_parent_instructions;
                     body.emit(f24B8);

                     /* END IF */

                     body.emit(assign(r24B4, logic_and(r24B7, r24B0), 0x01));


                  body.instructions = f24B5_parent_instructions;
                  body.emit(f24B5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f24BC = new(mem_ctx) ir_if(operand(r24B4).val);
                  exec_list *const f24BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24BC->then_instructions;

                     ir_variable *const r24BD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r24BD);
                     ir_expression *const r24BE = lshift(r237A, body.constant(int(31)));
                     body.emit(assign(r24BD, add(r24BE, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r24BD, body.constant(0u), 0x01));

                     body.emit(assign(r24AF, r24BD, 0x03));

                     body.emit(assign(r24AE, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24BC->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r24C0 = less(r246B, body.constant(int(0)));
                     ir_if *f24BF = new(mem_ctx) ir_if(operand(r24C0).val);
                     exec_list *const f24BF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24BF->then_instructions;

                        ir_variable *const r24C1 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r24C1, r246E, 0x01));

                        ir_variable *const r24C2 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r24C2, neg(r246B), 0x01));

                        ir_variable *const r24C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r24C3);
                        ir_variable *const r24C4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r24C4);
                        ir_variable *const r24C5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r24C5);
                        ir_variable *const r24C6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r24C7 = neg(r24C2);
                        body.emit(assign(r24C6, bit_and(r24C7, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r24C9 = equal(r24C2, body.constant(int(0)));
                        ir_if *f24C8 = new(mem_ctx) ir_if(operand(r24C9).val);
                        exec_list *const f24C8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f24C8->then_instructions;

                           body.emit(assign(r24C3, r246E, 0x01));

                           body.emit(assign(r24C4, r246D, 0x01));

                           body.emit(assign(r24C5, r246C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f24C8->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r24CB = less(r24C2, body.constant(int(32)));
                           ir_if *f24CA = new(mem_ctx) ir_if(operand(r24CB).val);
                           exec_list *const f24CA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f24CA->then_instructions;

                              body.emit(assign(r24C3, lshift(r246D, r24C6), 0x01));

                              ir_expression *const r24CC = lshift(r246C, r24C6);
                              ir_expression *const r24CD = rshift(r246D, r24C2);
                              body.emit(assign(r24C4, bit_or(r24CC, r24CD), 0x01));

                              body.emit(assign(r24C5, rshift(r246C, r24C2), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f24CA->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r24CF = equal(r24C2, body.constant(int(32)));
                              ir_if *f24CE = new(mem_ctx) ir_if(operand(r24CF).val);
                              exec_list *const f24CE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f24CE->then_instructions;

                                 body.emit(assign(r24C3, r246D, 0x01));

                                 body.emit(assign(r24C4, r246C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f24CE->else_instructions;

                                 body.emit(assign(r24C1, bit_or(r246E, r246D), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r24D1 = less(r24C2, body.constant(int(64)));
                                 ir_if *f24D0 = new(mem_ctx) ir_if(operand(r24D1).val);
                                 exec_list *const f24D0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f24D0->then_instructions;

                                    body.emit(assign(r24C3, lshift(r246C, r24C6), 0x01));

                                    ir_expression *const r24D2 = bit_and(r24C2, body.constant(int(31)));
                                    body.emit(assign(r24C4, rshift(r246C, r24D2), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f24D0->else_instructions;

                                    ir_variable *const r24D3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r24D5 = equal(r24C2, body.constant(int(64)));
                                    ir_if *f24D4 = new(mem_ctx) ir_if(operand(r24D5).val);
                                    exec_list *const f24D4_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f24D4->then_instructions;

                                       body.emit(assign(r24D3, r246C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f24D4->else_instructions;

                                       ir_expression *const r24D6 = nequal(r246C, body.constant(0u));
                                       ir_expression *const r24D7 = expr(ir_unop_b2i, r24D6);
                                       body.emit(assign(r24D3, expr(ir_unop_i2u, r24D7), 0x01));


                                    body.instructions = f24D4_parent_instructions;
                                    body.emit(f24D4);

                                    /* END IF */

                                    body.emit(assign(r24C3, r24D3, 0x01));

                                    body.emit(assign(r24C4, body.constant(0u), 0x01));


                                 body.instructions = f24D0_parent_instructions;
                                 body.emit(f24D0);

                                 /* END IF */


                              body.instructions = f24CE_parent_instructions;
                              body.emit(f24CE);

                              /* END IF */

                              body.emit(assign(r24C5, body.constant(0u), 0x01));


                           body.instructions = f24CA_parent_instructions;
                           body.emit(f24CA);

                           /* END IF */

                           ir_expression *const r24D8 = nequal(r24C1, body.constant(0u));
                           ir_expression *const r24D9 = expr(ir_unop_b2i, r24D8);
                           ir_expression *const r24DA = expr(ir_unop_i2u, r24D9);
                           body.emit(assign(r24C3, bit_or(r24C3, r24DA), 0x01));


                        body.instructions = f24C8_parent_instructions;
                        body.emit(f24C8);

                        /* END IF */

                        body.emit(assign(r24AB, r24C5, 0x01));

                        body.emit(assign(r24AC, r24C4, 0x01));

                        body.emit(assign(r24AD, r24C3, 0x01));

                        body.emit(assign(r24AA, body.constant(int(0)), 0x01));

                        body.emit(assign(r24B0, less(r24C3, body.constant(0u)), 0x01));


                     body.instructions = f24BF_parent_instructions;
                     body.emit(f24BF);

                     /* END IF */


                  body.instructions = f24BC_parent_instructions;
                  body.emit(f24BC);

                  /* END IF */


               body.instructions = f24B2_parent_instructions;
               body.emit(f24B2);

               /* END IF */

               /* IF CONDITION */
               ir_if *f24DB = new(mem_ctx) ir_if(operand(r24AE).val);
               exec_list *const f24DB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f24DB->then_instructions;

                  /* IF CONDITION */
                  ir_if *f24DC = new(mem_ctx) ir_if(operand(r24B0).val);
                  exec_list *const f24DC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24DC->then_instructions;

                     ir_variable *const r24DD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r24DD, add(r24AC, body.constant(1u)), 0x01));

                     ir_expression *const r24DE = less(r24DD, r24AC);
                     ir_expression *const r24DF = expr(ir_unop_b2i, r24DE);
                     ir_expression *const r24E0 = expr(ir_unop_i2u, r24DF);
                     body.emit(assign(r24AB, add(r24AB, r24E0), 0x01));

                     ir_expression *const r24E1 = equal(r24AD, body.constant(0u));
                     ir_expression *const r24E2 = expr(ir_unop_b2i, r24E1);
                     ir_expression *const r24E3 = expr(ir_unop_i2u, r24E2);
                     ir_expression *const r24E4 = add(r24AD, r24E3);
                     ir_expression *const r24E5 = bit_and(r24E4, body.constant(1u));
                     ir_expression *const r24E6 = expr(ir_unop_bit_not, r24E5);
                     body.emit(assign(r24AC, bit_and(r24DD, r24E6), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24DC->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r24E8 = bit_or(r24AB, r24AC);
                     ir_expression *const r24E9 = equal(r24E8, body.constant(0u));
                     ir_if *f24E7 = new(mem_ctx) ir_if(operand(r24E9).val);
                     exec_list *const f24E7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24E7->then_instructions;

                        body.emit(assign(r24AA, body.constant(int(0)), 0x01));


                     body.instructions = f24E7_parent_instructions;
                     body.emit(f24E7);

                     /* END IF */


                  body.instructions = f24DC_parent_instructions;
                  body.emit(f24DC);

                  /* END IF */

                  ir_variable *const r24EA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r24EA);
                  ir_expression *const r24EB = lshift(r237A, body.constant(int(31)));
                  ir_expression *const r24EC = expr(ir_unop_i2u, r24AA);
                  ir_expression *const r24ED = lshift(r24EC, body.constant(int(20)));
                  ir_expression *const r24EE = add(r24EB, r24ED);
                  body.emit(assign(r24EA, add(r24EE, r24AB), 0x02));

                  body.emit(assign(r24EA, r24AC, 0x01));

                  body.emit(assign(r24AF, r24EA, 0x03));

                  body.emit(assign(r24AE, body.constant(false), 0x01));


               body.instructions = f24DB_parent_instructions;
               body.emit(f24DB);

               /* END IF */

               body.emit(assign(r237B, r24AF, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2440->else_instructions;

               /* IF CONDITION */
               ir_expression *const r24F0 = equal(r2385, body.constant(int(2047)));
               ir_if *f24EF = new(mem_ctx) ir_if(operand(r24F0).val);
               exec_list *const f24EF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f24EF->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r24F2 = bit_or(r2381, r2382);
                  ir_expression *const r24F3 = bit_or(r237F, r2380);
                  ir_expression *const r24F4 = bit_or(r24F2, r24F3);
                  ir_expression *const r24F5 = nequal(r24F4, body.constant(0u));
                  ir_if *f24F1 = new(mem_ctx) ir_if(operand(r24F5).val);
                  exec_list *const f24F1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24F1->then_instructions;

                     ir_variable *const r24F6 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r24F6, swizzle_x(r21E9), 0x01));

                     ir_variable *const r24F7 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r24F7, body.constant(0u), 0x01));

                     ir_variable *const r24F8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r24F6, bit_or(swizzle_y(r21E9), body.constant(524288u)), 0x02));

                     body.emit(assign(r24F7, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r24FA = lshift(swizzle_y(r21E9), body.constant(int(1)));
                     ir_expression *const r24FB = lequal(body.constant(4292870144u), r24FA);
                     ir_expression *const r24FC = nequal(swizzle_x(r21E9), body.constant(0u));
                     ir_expression *const r24FD = bit_and(swizzle_y(r21E9), body.constant(1048575u));
                     ir_expression *const r24FE = nequal(r24FD, body.constant(0u));
                     ir_expression *const r24FF = logic_or(r24FC, r24FE);
                     ir_expression *const r2500 = logic_and(r24FB, r24FF);
                     ir_if *f24F9 = new(mem_ctx) ir_if(operand(r2500).val);
                     exec_list *const f24F9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24F9->then_instructions;

                        body.emit(assign(r24F8, r24F6, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f24F9->else_instructions;

                        body.emit(assign(r24F8, r24F7, 0x03));


                     body.instructions = f24F9_parent_instructions;
                     body.emit(f24F9);

                     /* END IF */

                     body.emit(assign(r237B, r24F8, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24F1->else_instructions;

                     ir_constant_data r2501_data;
                     memset(&r2501_data, 0, sizeof(ir_constant_data));
                     r2501_data.u[0] = 4294967295;
                     r2501_data.u[1] = 4294967295;
                     ir_constant *const r2501 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r2501_data);
                     body.emit(assign(r237B, r2501, 0x03));


                  body.instructions = f24F1_parent_instructions;
                  body.emit(f24F1);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f24EF->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2503 = equal(r2385, body.constant(int(0)));
                  ir_if *f2502 = new(mem_ctx) ir_if(operand(r2503).val);
                  exec_list *const f2502_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2502->then_instructions;

                     body.emit(assign(r237E, body.constant(int(1)), 0x01));

                     body.emit(assign(r237D, body.constant(int(1)), 0x01));


                  body.instructions = f2502_parent_instructions;
                  body.emit(f2502);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2505 = less(r237F, r2381);
                  ir_if *f2504 = new(mem_ctx) ir_if(operand(r2505).val);
                  exec_list *const f2504_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2504->then_instructions;

                     ir_variable *const r2506 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r2507 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r2507, sub(r2382, r2380), 0x01));

                     ir_expression *const r2508 = sub(r2381, r237F);
                     ir_expression *const r2509 = less(r2382, r2380);
                     ir_expression *const r250A = expr(ir_unop_b2i, r2509);
                     ir_expression *const r250B = expr(ir_unop_i2u, r250A);
                     body.emit(assign(r2506, sub(r2508, r250B), 0x01));

                     body.emit(assign(r2383, add(r237E, body.constant(int(-1))), 0x01));

                     ir_variable *const r250C = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r250C, add(r2383, body.constant(int(-10))), 0x01));

                     ir_variable *const r250D = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r250D, r2506, 0x01));

                     ir_variable *const r250E = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r250E, r2507, 0x01));

                     ir_variable *const r250F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r250F);
                     ir_variable *const r2510 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2510);
                     /* IF CONDITION */
                     ir_expression *const r2512 = equal(r2506, body.constant(0u));
                     ir_if *f2511 = new(mem_ctx) ir_if(operand(r2512).val);
                     exec_list *const f2511_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2511->then_instructions;

                        body.emit(assign(r250D, r2507, 0x01));

                        body.emit(assign(r250E, body.constant(0u), 0x01));

                        body.emit(assign(r250C, add(r250C, body.constant(int(-32))), 0x01));


                     body.instructions = f2511_parent_instructions;
                     body.emit(f2511);

                     /* END IF */

                     ir_variable *const r2513 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r2513, r250D, 0x01));

                     ir_variable *const r2514 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r2515 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2515);
                     /* IF CONDITION */
                     ir_expression *const r2517 = equal(r250D, body.constant(0u));
                     ir_if *f2516 = new(mem_ctx) ir_if(operand(r2517).val);
                     exec_list *const f2516_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2516->then_instructions;

                        body.emit(assign(r2514, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2516->else_instructions;

                        body.emit(assign(r2515, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2519 = bit_and(r250D, body.constant(4294901760u));
                        ir_expression *const r251A = equal(r2519, body.constant(0u));
                        ir_if *f2518 = new(mem_ctx) ir_if(operand(r251A).val);
                        exec_list *const f2518_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2518->then_instructions;

                           body.emit(assign(r2515, body.constant(int(16)), 0x01));

                           body.emit(assign(r2513, lshift(r250D, body.constant(int(16))), 0x01));


                        body.instructions = f2518_parent_instructions;
                        body.emit(f2518);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r251C = bit_and(r2513, body.constant(4278190080u));
                        ir_expression *const r251D = equal(r251C, body.constant(0u));
                        ir_if *f251B = new(mem_ctx) ir_if(operand(r251D).val);
                        exec_list *const f251B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f251B->then_instructions;

                           body.emit(assign(r2515, add(r2515, body.constant(int(8))), 0x01));

                           body.emit(assign(r2513, lshift(r2513, body.constant(int(8))), 0x01));


                        body.instructions = f251B_parent_instructions;
                        body.emit(f251B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r251F = bit_and(r2513, body.constant(4026531840u));
                        ir_expression *const r2520 = equal(r251F, body.constant(0u));
                        ir_if *f251E = new(mem_ctx) ir_if(operand(r2520).val);
                        exec_list *const f251E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f251E->then_instructions;

                           body.emit(assign(r2515, add(r2515, body.constant(int(4))), 0x01));

                           body.emit(assign(r2513, lshift(r2513, body.constant(int(4))), 0x01));


                        body.instructions = f251E_parent_instructions;
                        body.emit(f251E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2522 = bit_and(r2513, body.constant(3221225472u));
                        ir_expression *const r2523 = equal(r2522, body.constant(0u));
                        ir_if *f2521 = new(mem_ctx) ir_if(operand(r2523).val);
                        exec_list *const f2521_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2521->then_instructions;

                           body.emit(assign(r2515, add(r2515, body.constant(int(2))), 0x01));

                           body.emit(assign(r2513, lshift(r2513, body.constant(int(2))), 0x01));


                        body.instructions = f2521_parent_instructions;
                        body.emit(f2521);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2525 = bit_and(r2513, body.constant(2147483648u));
                        ir_expression *const r2526 = equal(r2525, body.constant(0u));
                        ir_if *f2524 = new(mem_ctx) ir_if(operand(r2526).val);
                        exec_list *const f2524_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2524->then_instructions;

                           body.emit(assign(r2515, add(r2515, body.constant(int(1))), 0x01));


                        body.instructions = f2524_parent_instructions;
                        body.emit(f2524);

                        /* END IF */

                        body.emit(assign(r2514, r2515, 0x01));


                     body.instructions = f2516_parent_instructions;
                     body.emit(f2516);

                     /* END IF */

                     body.emit(assign(r2510, add(r2514, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2528 = lequal(body.constant(int(0)), r2510);
                     ir_if *f2527 = new(mem_ctx) ir_if(operand(r2528).val);
                     exec_list *const f2527_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2527->then_instructions;

                        body.emit(assign(r250F, body.constant(0u), 0x01));

                        ir_variable *const r2529 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2529, lshift(r250E, r2510), 0x01));

                        ir_variable *const r252A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r252C = equal(r2510, body.constant(int(0)));
                        ir_if *f252B = new(mem_ctx) ir_if(operand(r252C).val);
                        exec_list *const f252B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f252B->then_instructions;

                           body.emit(assign(r252A, r250D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f252B->else_instructions;

                           ir_expression *const r252D = lshift(r250D, r2510);
                           ir_expression *const r252E = neg(r2510);
                           ir_expression *const r252F = bit_and(r252E, body.constant(int(31)));
                           ir_expression *const r2530 = rshift(r250E, r252F);
                           body.emit(assign(r252A, bit_or(r252D, r2530), 0x01));


                        body.instructions = f252B_parent_instructions;
                        body.emit(f252B);

                        /* END IF */

                        body.emit(assign(r250D, r252A, 0x01));

                        body.emit(assign(r250E, r2529, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2527->else_instructions;

                        ir_variable *const r2531 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2531, body.constant(0u), 0x01));

                        ir_variable *const r2532 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2532, neg(r2510), 0x01));

                        ir_variable *const r2533 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2533);
                        ir_variable *const r2534 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2534);
                        ir_variable *const r2535 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2535);
                        ir_variable *const r2536 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2537 = neg(r2532);
                        body.emit(assign(r2536, bit_and(r2537, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2539 = equal(r2532, body.constant(int(0)));
                        ir_if *f2538 = new(mem_ctx) ir_if(operand(r2539).val);
                        exec_list *const f2538_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2538->then_instructions;

                           body.emit(assign(r2533, r2531, 0x01));

                           body.emit(assign(r2534, r250E, 0x01));

                           body.emit(assign(r2535, r250D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2538->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r253B = less(r2532, body.constant(int(32)));
                           ir_if *f253A = new(mem_ctx) ir_if(operand(r253B).val);
                           exec_list *const f253A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f253A->then_instructions;

                              body.emit(assign(r2533, lshift(r250E, r2536), 0x01));

                              ir_expression *const r253C = lshift(r250D, r2536);
                              ir_expression *const r253D = rshift(r250E, r2532);
                              body.emit(assign(r2534, bit_or(r253C, r253D), 0x01));

                              body.emit(assign(r2535, rshift(r250D, r2532), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f253A->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r253F = equal(r2532, body.constant(int(32)));
                              ir_if *f253E = new(mem_ctx) ir_if(operand(r253F).val);
                              exec_list *const f253E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f253E->then_instructions;

                                 body.emit(assign(r2533, r250E, 0x01));

                                 body.emit(assign(r2534, r250D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f253E->else_instructions;

                                 body.emit(assign(r2531, bit_or(body.constant(0u), r250E), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2541 = less(r2532, body.constant(int(64)));
                                 ir_if *f2540 = new(mem_ctx) ir_if(operand(r2541).val);
                                 exec_list *const f2540_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2540->then_instructions;

                                    body.emit(assign(r2533, lshift(r250D, r2536), 0x01));

                                    ir_expression *const r2542 = bit_and(r2532, body.constant(int(31)));
                                    body.emit(assign(r2534, rshift(r250D, r2542), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2540->else_instructions;

                                    ir_variable *const r2543 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2545 = equal(r2532, body.constant(int(64)));
                                    ir_if *f2544 = new(mem_ctx) ir_if(operand(r2545).val);
                                    exec_list *const f2544_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2544->then_instructions;

                                       body.emit(assign(r2543, r250D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2544->else_instructions;

                                       ir_expression *const r2546 = nequal(r250D, body.constant(0u));
                                       ir_expression *const r2547 = expr(ir_unop_b2i, r2546);
                                       body.emit(assign(r2543, expr(ir_unop_i2u, r2547), 0x01));


                                    body.instructions = f2544_parent_instructions;
                                    body.emit(f2544);

                                    /* END IF */

                                    body.emit(assign(r2533, r2543, 0x01));

                                    body.emit(assign(r2534, body.constant(0u), 0x01));


                                 body.instructions = f2540_parent_instructions;
                                 body.emit(f2540);

                                 /* END IF */


                              body.instructions = f253E_parent_instructions;
                              body.emit(f253E);

                              /* END IF */

                              body.emit(assign(r2535, body.constant(0u), 0x01));


                           body.instructions = f253A_parent_instructions;
                           body.emit(f253A);

                           /* END IF */

                           ir_expression *const r2548 = nequal(r2531, body.constant(0u));
                           ir_expression *const r2549 = expr(ir_unop_b2i, r2548);
                           ir_expression *const r254A = expr(ir_unop_i2u, r2549);
                           body.emit(assign(r2533, bit_or(r2533, r254A), 0x01));


                        body.instructions = f2538_parent_instructions;
                        body.emit(f2538);

                        /* END IF */

                        body.emit(assign(r250D, r2535, 0x01));

                        body.emit(assign(r250E, r2534, 0x01));

                        body.emit(assign(r250F, r2533, 0x01));


                     body.instructions = f2527_parent_instructions;
                     body.emit(f2527);

                     /* END IF */

                     body.emit(assign(r250C, sub(r250C, r2510), 0x01));

                     ir_variable *const r254B = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r254B, r250C, 0x01));

                     ir_variable *const r254C = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r254C, r250D, 0x01));

                     ir_variable *const r254D = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r254D, r250E, 0x01));

                     ir_variable *const r254E = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r254E, r250F, 0x01));

                     ir_variable *const r254F = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r254F, body.constant(true), 0x01));

                     ir_variable *const r2550 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2551 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2551);
                     ir_expression *const r2552 = expr(ir_unop_u2i, r250F);
                     body.emit(assign(r2551, less(r2552, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2554 = lequal(body.constant(int(2045)), r250C);
                     ir_if *f2553 = new(mem_ctx) ir_if(operand(r2554).val);
                     exec_list *const f2553_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2553->then_instructions;

                        ir_variable *const r2555 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2557 = less(body.constant(int(2045)), r250C);
                        ir_if *f2556 = new(mem_ctx) ir_if(operand(r2557).val);
                        exec_list *const f2556_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2556->then_instructions;

                           body.emit(assign(r2555, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2556->else_instructions;

                           ir_variable *const r2558 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r255A = equal(r250C, body.constant(int(2045)));
                           ir_if *f2559 = new(mem_ctx) ir_if(operand(r255A).val);
                           exec_list *const f2559_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2559->then_instructions;

                              ir_expression *const r255B = equal(body.constant(2097151u), r250D);
                              ir_expression *const r255C = equal(body.constant(4294967295u), r250E);
                              body.emit(assign(r2558, logic_and(r255B, r255C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2559->else_instructions;

                              body.emit(assign(r2558, body.constant(false), 0x01));


                           body.instructions = f2559_parent_instructions;
                           body.emit(f2559);

                           /* END IF */

                           body.emit(assign(r2555, logic_and(r2558, r2551), 0x01));


                        body.instructions = f2556_parent_instructions;
                        body.emit(f2556);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f255D = new(mem_ctx) ir_if(operand(r2555).val);
                        exec_list *const f255D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f255D->then_instructions;

                           ir_variable *const r255E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r255E);
                           ir_expression *const r255F = lshift(r237A, body.constant(int(31)));
                           body.emit(assign(r255E, add(r255F, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r255E, body.constant(0u), 0x01));

                           body.emit(assign(r2550, r255E, 0x03));

                           body.emit(assign(r254F, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f255D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2561 = less(r250C, body.constant(int(0)));
                           ir_if *f2560 = new(mem_ctx) ir_if(operand(r2561).val);
                           exec_list *const f2560_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2560->then_instructions;

                              ir_variable *const r2562 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2562, r250F, 0x01));

                              ir_variable *const r2563 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2563, neg(r250C), 0x01));

                              ir_variable *const r2564 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2564);
                              ir_variable *const r2565 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2565);
                              ir_variable *const r2566 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2566);
                              ir_variable *const r2567 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2568 = neg(r2563);
                              body.emit(assign(r2567, bit_and(r2568, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r256A = equal(r2563, body.constant(int(0)));
                              ir_if *f2569 = new(mem_ctx) ir_if(operand(r256A).val);
                              exec_list *const f2569_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2569->then_instructions;

                                 body.emit(assign(r2564, r250F, 0x01));

                                 body.emit(assign(r2565, r250E, 0x01));

                                 body.emit(assign(r2566, r250D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2569->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r256C = less(r2563, body.constant(int(32)));
                                 ir_if *f256B = new(mem_ctx) ir_if(operand(r256C).val);
                                 exec_list *const f256B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f256B->then_instructions;

                                    body.emit(assign(r2564, lshift(r250E, r2567), 0x01));

                                    ir_expression *const r256D = lshift(r250D, r2567);
                                    ir_expression *const r256E = rshift(r250E, r2563);
                                    body.emit(assign(r2565, bit_or(r256D, r256E), 0x01));

                                    body.emit(assign(r2566, rshift(r250D, r2563), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f256B->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2570 = equal(r2563, body.constant(int(32)));
                                    ir_if *f256F = new(mem_ctx) ir_if(operand(r2570).val);
                                    exec_list *const f256F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f256F->then_instructions;

                                       body.emit(assign(r2564, r250E, 0x01));

                                       body.emit(assign(r2565, r250D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f256F->else_instructions;

                                       body.emit(assign(r2562, bit_or(r250F, r250E), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2572 = less(r2563, body.constant(int(64)));
                                       ir_if *f2571 = new(mem_ctx) ir_if(operand(r2572).val);
                                       exec_list *const f2571_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2571->then_instructions;

                                          body.emit(assign(r2564, lshift(r250D, r2567), 0x01));

                                          ir_expression *const r2573 = bit_and(r2563, body.constant(int(31)));
                                          body.emit(assign(r2565, rshift(r250D, r2573), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2571->else_instructions;

                                          ir_variable *const r2574 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2576 = equal(r2563, body.constant(int(64)));
                                          ir_if *f2575 = new(mem_ctx) ir_if(operand(r2576).val);
                                          exec_list *const f2575_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2575->then_instructions;

                                             body.emit(assign(r2574, r250D, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2575->else_instructions;

                                             ir_expression *const r2577 = nequal(r250D, body.constant(0u));
                                             ir_expression *const r2578 = expr(ir_unop_b2i, r2577);
                                             body.emit(assign(r2574, expr(ir_unop_i2u, r2578), 0x01));


                                          body.instructions = f2575_parent_instructions;
                                          body.emit(f2575);

                                          /* END IF */

                                          body.emit(assign(r2564, r2574, 0x01));

                                          body.emit(assign(r2565, body.constant(0u), 0x01));


                                       body.instructions = f2571_parent_instructions;
                                       body.emit(f2571);

                                       /* END IF */


                                    body.instructions = f256F_parent_instructions;
                                    body.emit(f256F);

                                    /* END IF */

                                    body.emit(assign(r2566, body.constant(0u), 0x01));


                                 body.instructions = f256B_parent_instructions;
                                 body.emit(f256B);

                                 /* END IF */

                                 ir_expression *const r2579 = nequal(r2562, body.constant(0u));
                                 ir_expression *const r257A = expr(ir_unop_b2i, r2579);
                                 ir_expression *const r257B = expr(ir_unop_i2u, r257A);
                                 body.emit(assign(r2564, bit_or(r2564, r257B), 0x01));


                              body.instructions = f2569_parent_instructions;
                              body.emit(f2569);

                              /* END IF */

                              body.emit(assign(r254C, r2566, 0x01));

                              body.emit(assign(r254D, r2565, 0x01));

                              body.emit(assign(r254E, r2564, 0x01));

                              body.emit(assign(r254B, body.constant(int(0)), 0x01));

                              body.emit(assign(r2551, less(r2564, body.constant(0u)), 0x01));


                           body.instructions = f2560_parent_instructions;
                           body.emit(f2560);

                           /* END IF */


                        body.instructions = f255D_parent_instructions;
                        body.emit(f255D);

                        /* END IF */


                     body.instructions = f2553_parent_instructions;
                     body.emit(f2553);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f257C = new(mem_ctx) ir_if(operand(r254F).val);
                     exec_list *const f257C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f257C->then_instructions;

                        /* IF CONDITION */
                        ir_if *f257D = new(mem_ctx) ir_if(operand(r2551).val);
                        exec_list *const f257D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f257D->then_instructions;

                           ir_variable *const r257E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r257E, add(r254D, body.constant(1u)), 0x01));

                           ir_expression *const r257F = less(r257E, r254D);
                           ir_expression *const r2580 = expr(ir_unop_b2i, r257F);
                           ir_expression *const r2581 = expr(ir_unop_i2u, r2580);
                           body.emit(assign(r254C, add(r254C, r2581), 0x01));

                           ir_expression *const r2582 = equal(r254E, body.constant(0u));
                           ir_expression *const r2583 = expr(ir_unop_b2i, r2582);
                           ir_expression *const r2584 = expr(ir_unop_i2u, r2583);
                           ir_expression *const r2585 = add(r254E, r2584);
                           ir_expression *const r2586 = bit_and(r2585, body.constant(1u));
                           ir_expression *const r2587 = expr(ir_unop_bit_not, r2586);
                           body.emit(assign(r254D, bit_and(r257E, r2587), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f257D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2589 = bit_or(r254C, r254D);
                           ir_expression *const r258A = equal(r2589, body.constant(0u));
                           ir_if *f2588 = new(mem_ctx) ir_if(operand(r258A).val);
                           exec_list *const f2588_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2588->then_instructions;

                              body.emit(assign(r254B, body.constant(int(0)), 0x01));


                           body.instructions = f2588_parent_instructions;
                           body.emit(f2588);

                           /* END IF */


                        body.instructions = f257D_parent_instructions;
                        body.emit(f257D);

                        /* END IF */

                        ir_variable *const r258B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r258B);
                        ir_expression *const r258C = lshift(r237A, body.constant(int(31)));
                        ir_expression *const r258D = expr(ir_unop_i2u, r254B);
                        ir_expression *const r258E = lshift(r258D, body.constant(int(20)));
                        ir_expression *const r258F = add(r258C, r258E);
                        body.emit(assign(r258B, add(r258F, r254C), 0x02));

                        body.emit(assign(r258B, r254D, 0x01));

                        body.emit(assign(r2550, r258B, 0x03));

                        body.emit(assign(r254F, body.constant(false), 0x01));


                     body.instructions = f257C_parent_instructions;
                     body.emit(f257C);

                     /* END IF */

                     body.emit(assign(r237B, r2550, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2504->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2591 = less(r2381, r237F);
                     ir_if *f2590 = new(mem_ctx) ir_if(operand(r2591).val);
                     exec_list *const f2590_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2590->then_instructions;

                        ir_variable *const r2592 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r2593 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2593, sub(r2380, r2382), 0x01));

                        ir_expression *const r2594 = sub(r237F, r2381);
                        ir_expression *const r2595 = less(r2380, r2382);
                        ir_expression *const r2596 = expr(ir_unop_b2i, r2595);
                        ir_expression *const r2597 = expr(ir_unop_i2u, r2596);
                        body.emit(assign(r2592, sub(r2594, r2597), 0x01));

                        body.emit(assign(r237A, bit_xor(r237A, body.constant(1u)), 0x01));

                        body.emit(assign(r2383, add(r237D, body.constant(int(-1))), 0x01));

                        ir_variable *const r2598 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2598, add(r2383, body.constant(int(-10))), 0x01));

                        ir_variable *const r2599 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2599, r2592, 0x01));

                        ir_variable *const r259A = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r259A, r2593, 0x01));

                        ir_variable *const r259B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r259B);
                        ir_variable *const r259C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r259C);
                        /* IF CONDITION */
                        ir_expression *const r259E = equal(r2592, body.constant(0u));
                        ir_if *f259D = new(mem_ctx) ir_if(operand(r259E).val);
                        exec_list *const f259D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f259D->then_instructions;

                           body.emit(assign(r2599, r2593, 0x01));

                           body.emit(assign(r259A, body.constant(0u), 0x01));

                           body.emit(assign(r2598, add(r2598, body.constant(int(-32))), 0x01));


                        body.instructions = f259D_parent_instructions;
                        body.emit(f259D);

                        /* END IF */

                        ir_variable *const r259F = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r259F, r2599, 0x01));

                        ir_variable *const r25A0 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r25A1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r25A1);
                        /* IF CONDITION */
                        ir_expression *const r25A3 = equal(r2599, body.constant(0u));
                        ir_if *f25A2 = new(mem_ctx) ir_if(operand(r25A3).val);
                        exec_list *const f25A2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25A2->then_instructions;

                           body.emit(assign(r25A0, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f25A2->else_instructions;

                           body.emit(assign(r25A1, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r25A5 = bit_and(r2599, body.constant(4294901760u));
                           ir_expression *const r25A6 = equal(r25A5, body.constant(0u));
                           ir_if *f25A4 = new(mem_ctx) ir_if(operand(r25A6).val);
                           exec_list *const f25A4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25A4->then_instructions;

                              body.emit(assign(r25A1, body.constant(int(16)), 0x01));

                              body.emit(assign(r259F, lshift(r2599, body.constant(int(16))), 0x01));


                           body.instructions = f25A4_parent_instructions;
                           body.emit(f25A4);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r25A8 = bit_and(r259F, body.constant(4278190080u));
                           ir_expression *const r25A9 = equal(r25A8, body.constant(0u));
                           ir_if *f25A7 = new(mem_ctx) ir_if(operand(r25A9).val);
                           exec_list *const f25A7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25A7->then_instructions;

                              body.emit(assign(r25A1, add(r25A1, body.constant(int(8))), 0x01));

                              body.emit(assign(r259F, lshift(r259F, body.constant(int(8))), 0x01));


                           body.instructions = f25A7_parent_instructions;
                           body.emit(f25A7);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r25AB = bit_and(r259F, body.constant(4026531840u));
                           ir_expression *const r25AC = equal(r25AB, body.constant(0u));
                           ir_if *f25AA = new(mem_ctx) ir_if(operand(r25AC).val);
                           exec_list *const f25AA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25AA->then_instructions;

                              body.emit(assign(r25A1, add(r25A1, body.constant(int(4))), 0x01));

                              body.emit(assign(r259F, lshift(r259F, body.constant(int(4))), 0x01));


                           body.instructions = f25AA_parent_instructions;
                           body.emit(f25AA);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r25AE = bit_and(r259F, body.constant(3221225472u));
                           ir_expression *const r25AF = equal(r25AE, body.constant(0u));
                           ir_if *f25AD = new(mem_ctx) ir_if(operand(r25AF).val);
                           exec_list *const f25AD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25AD->then_instructions;

                              body.emit(assign(r25A1, add(r25A1, body.constant(int(2))), 0x01));

                              body.emit(assign(r259F, lshift(r259F, body.constant(int(2))), 0x01));


                           body.instructions = f25AD_parent_instructions;
                           body.emit(f25AD);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r25B1 = bit_and(r259F, body.constant(2147483648u));
                           ir_expression *const r25B2 = equal(r25B1, body.constant(0u));
                           ir_if *f25B0 = new(mem_ctx) ir_if(operand(r25B2).val);
                           exec_list *const f25B0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25B0->then_instructions;

                              body.emit(assign(r25A1, add(r25A1, body.constant(int(1))), 0x01));


                           body.instructions = f25B0_parent_instructions;
                           body.emit(f25B0);

                           /* END IF */

                           body.emit(assign(r25A0, r25A1, 0x01));


                        body.instructions = f25A2_parent_instructions;
                        body.emit(f25A2);

                        /* END IF */

                        body.emit(assign(r259C, add(r25A0, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r25B4 = lequal(body.constant(int(0)), r259C);
                        ir_if *f25B3 = new(mem_ctx) ir_if(operand(r25B4).val);
                        exec_list *const f25B3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25B3->then_instructions;

                           body.emit(assign(r259B, body.constant(0u), 0x01));

                           ir_variable *const r25B5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r25B5, lshift(r259A, r259C), 0x01));

                           ir_variable *const r25B6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r25B8 = equal(r259C, body.constant(int(0)));
                           ir_if *f25B7 = new(mem_ctx) ir_if(operand(r25B8).val);
                           exec_list *const f25B7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25B7->then_instructions;

                              body.emit(assign(r25B6, r2599, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f25B7->else_instructions;

                              ir_expression *const r25B9 = lshift(r2599, r259C);
                              ir_expression *const r25BA = neg(r259C);
                              ir_expression *const r25BB = bit_and(r25BA, body.constant(int(31)));
                              ir_expression *const r25BC = rshift(r259A, r25BB);
                              body.emit(assign(r25B6, bit_or(r25B9, r25BC), 0x01));


                           body.instructions = f25B7_parent_instructions;
                           body.emit(f25B7);

                           /* END IF */

                           body.emit(assign(r2599, r25B6, 0x01));

                           body.emit(assign(r259A, r25B5, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f25B3->else_instructions;

                           ir_variable *const r25BD = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r25BD, body.constant(0u), 0x01));

                           ir_variable *const r25BE = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r25BE, neg(r259C), 0x01));

                           ir_variable *const r25BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r25BF);
                           ir_variable *const r25C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r25C0);
                           ir_variable *const r25C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r25C1);
                           ir_variable *const r25C2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r25C3 = neg(r25BE);
                           body.emit(assign(r25C2, bit_and(r25C3, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r25C5 = equal(r25BE, body.constant(int(0)));
                           ir_if *f25C4 = new(mem_ctx) ir_if(operand(r25C5).val);
                           exec_list *const f25C4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25C4->then_instructions;

                              body.emit(assign(r25BF, r25BD, 0x01));

                              body.emit(assign(r25C0, r259A, 0x01));

                              body.emit(assign(r25C1, r2599, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f25C4->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r25C7 = less(r25BE, body.constant(int(32)));
                              ir_if *f25C6 = new(mem_ctx) ir_if(operand(r25C7).val);
                              exec_list *const f25C6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f25C6->then_instructions;

                                 body.emit(assign(r25BF, lshift(r259A, r25C2), 0x01));

                                 ir_expression *const r25C8 = lshift(r2599, r25C2);
                                 ir_expression *const r25C9 = rshift(r259A, r25BE);
                                 body.emit(assign(r25C0, bit_or(r25C8, r25C9), 0x01));

                                 body.emit(assign(r25C1, rshift(r2599, r25BE), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f25C6->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r25CB = equal(r25BE, body.constant(int(32)));
                                 ir_if *f25CA = new(mem_ctx) ir_if(operand(r25CB).val);
                                 exec_list *const f25CA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f25CA->then_instructions;

                                    body.emit(assign(r25BF, r259A, 0x01));

                                    body.emit(assign(r25C0, r2599, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f25CA->else_instructions;

                                    body.emit(assign(r25BD, bit_or(body.constant(0u), r259A), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r25CD = less(r25BE, body.constant(int(64)));
                                    ir_if *f25CC = new(mem_ctx) ir_if(operand(r25CD).val);
                                    exec_list *const f25CC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f25CC->then_instructions;

                                       body.emit(assign(r25BF, lshift(r2599, r25C2), 0x01));

                                       ir_expression *const r25CE = bit_and(r25BE, body.constant(int(31)));
                                       body.emit(assign(r25C0, rshift(r2599, r25CE), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f25CC->else_instructions;

                                       ir_variable *const r25CF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r25D1 = equal(r25BE, body.constant(int(64)));
                                       ir_if *f25D0 = new(mem_ctx) ir_if(operand(r25D1).val);
                                       exec_list *const f25D0_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f25D0->then_instructions;

                                          body.emit(assign(r25CF, r2599, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f25D0->else_instructions;

                                          ir_expression *const r25D2 = nequal(r2599, body.constant(0u));
                                          ir_expression *const r25D3 = expr(ir_unop_b2i, r25D2);
                                          body.emit(assign(r25CF, expr(ir_unop_i2u, r25D3), 0x01));


                                       body.instructions = f25D0_parent_instructions;
                                       body.emit(f25D0);

                                       /* END IF */

                                       body.emit(assign(r25BF, r25CF, 0x01));

                                       body.emit(assign(r25C0, body.constant(0u), 0x01));


                                    body.instructions = f25CC_parent_instructions;
                                    body.emit(f25CC);

                                    /* END IF */


                                 body.instructions = f25CA_parent_instructions;
                                 body.emit(f25CA);

                                 /* END IF */

                                 body.emit(assign(r25C1, body.constant(0u), 0x01));


                              body.instructions = f25C6_parent_instructions;
                              body.emit(f25C6);

                              /* END IF */

                              ir_expression *const r25D4 = nequal(r25BD, body.constant(0u));
                              ir_expression *const r25D5 = expr(ir_unop_b2i, r25D4);
                              ir_expression *const r25D6 = expr(ir_unop_i2u, r25D5);
                              body.emit(assign(r25BF, bit_or(r25BF, r25D6), 0x01));


                           body.instructions = f25C4_parent_instructions;
                           body.emit(f25C4);

                           /* END IF */

                           body.emit(assign(r2599, r25C1, 0x01));

                           body.emit(assign(r259A, r25C0, 0x01));

                           body.emit(assign(r259B, r25BF, 0x01));


                        body.instructions = f25B3_parent_instructions;
                        body.emit(f25B3);

                        /* END IF */

                        body.emit(assign(r2598, sub(r2598, r259C), 0x01));

                        ir_variable *const r25D7 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r25D7, r2598, 0x01));

                        ir_variable *const r25D8 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r25D8, r2599, 0x01));

                        ir_variable *const r25D9 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r25D9, r259A, 0x01));

                        ir_variable *const r25DA = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r25DA, r259B, 0x01));

                        ir_variable *const r25DB = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r25DB, body.constant(true), 0x01));

                        ir_variable *const r25DC = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r25DD = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r25DD);
                        ir_expression *const r25DE = expr(ir_unop_u2i, r259B);
                        body.emit(assign(r25DD, less(r25DE, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r25E0 = lequal(body.constant(int(2045)), r2598);
                        ir_if *f25DF = new(mem_ctx) ir_if(operand(r25E0).val);
                        exec_list *const f25DF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25DF->then_instructions;

                           ir_variable *const r25E1 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r25E3 = less(body.constant(int(2045)), r2598);
                           ir_if *f25E2 = new(mem_ctx) ir_if(operand(r25E3).val);
                           exec_list *const f25E2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25E2->then_instructions;

                              body.emit(assign(r25E1, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f25E2->else_instructions;

                              ir_variable *const r25E4 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r25E6 = equal(r2598, body.constant(int(2045)));
                              ir_if *f25E5 = new(mem_ctx) ir_if(operand(r25E6).val);
                              exec_list *const f25E5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f25E5->then_instructions;

                                 ir_expression *const r25E7 = equal(body.constant(2097151u), r2599);
                                 ir_expression *const r25E8 = equal(body.constant(4294967295u), r259A);
                                 body.emit(assign(r25E4, logic_and(r25E7, r25E8), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f25E5->else_instructions;

                                 body.emit(assign(r25E4, body.constant(false), 0x01));


                              body.instructions = f25E5_parent_instructions;
                              body.emit(f25E5);

                              /* END IF */

                              body.emit(assign(r25E1, logic_and(r25E4, r25DD), 0x01));


                           body.instructions = f25E2_parent_instructions;
                           body.emit(f25E2);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f25E9 = new(mem_ctx) ir_if(operand(r25E1).val);
                           exec_list *const f25E9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25E9->then_instructions;

                              ir_variable *const r25EA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r25EA);
                              ir_expression *const r25EB = lshift(r237A, body.constant(int(31)));
                              body.emit(assign(r25EA, add(r25EB, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r25EA, body.constant(0u), 0x01));

                              body.emit(assign(r25DC, r25EA, 0x03));

                              body.emit(assign(r25DB, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f25E9->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r25ED = less(r2598, body.constant(int(0)));
                              ir_if *f25EC = new(mem_ctx) ir_if(operand(r25ED).val);
                              exec_list *const f25EC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f25EC->then_instructions;

                                 ir_variable *const r25EE = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r25EE, r259B, 0x01));

                                 ir_variable *const r25EF = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r25EF, neg(r2598), 0x01));

                                 ir_variable *const r25F0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r25F0);
                                 ir_variable *const r25F1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r25F1);
                                 ir_variable *const r25F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r25F2);
                                 ir_variable *const r25F3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r25F4 = neg(r25EF);
                                 body.emit(assign(r25F3, bit_and(r25F4, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r25F6 = equal(r25EF, body.constant(int(0)));
                                 ir_if *f25F5 = new(mem_ctx) ir_if(operand(r25F6).val);
                                 exec_list *const f25F5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f25F5->then_instructions;

                                    body.emit(assign(r25F0, r259B, 0x01));

                                    body.emit(assign(r25F1, r259A, 0x01));

                                    body.emit(assign(r25F2, r2599, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f25F5->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r25F8 = less(r25EF, body.constant(int(32)));
                                    ir_if *f25F7 = new(mem_ctx) ir_if(operand(r25F8).val);
                                    exec_list *const f25F7_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f25F7->then_instructions;

                                       body.emit(assign(r25F0, lshift(r259A, r25F3), 0x01));

                                       ir_expression *const r25F9 = lshift(r2599, r25F3);
                                       ir_expression *const r25FA = rshift(r259A, r25EF);
                                       body.emit(assign(r25F1, bit_or(r25F9, r25FA), 0x01));

                                       body.emit(assign(r25F2, rshift(r2599, r25EF), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f25F7->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r25FC = equal(r25EF, body.constant(int(32)));
                                       ir_if *f25FB = new(mem_ctx) ir_if(operand(r25FC).val);
                                       exec_list *const f25FB_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f25FB->then_instructions;

                                          body.emit(assign(r25F0, r259A, 0x01));

                                          body.emit(assign(r25F1, r2599, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f25FB->else_instructions;

                                          body.emit(assign(r25EE, bit_or(r259B, r259A), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r25FE = less(r25EF, body.constant(int(64)));
                                          ir_if *f25FD = new(mem_ctx) ir_if(operand(r25FE).val);
                                          exec_list *const f25FD_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f25FD->then_instructions;

                                             body.emit(assign(r25F0, lshift(r2599, r25F3), 0x01));

                                             ir_expression *const r25FF = bit_and(r25EF, body.constant(int(31)));
                                             body.emit(assign(r25F1, rshift(r2599, r25FF), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f25FD->else_instructions;

                                             ir_variable *const r2600 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2602 = equal(r25EF, body.constant(int(64)));
                                             ir_if *f2601 = new(mem_ctx) ir_if(operand(r2602).val);
                                             exec_list *const f2601_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2601->then_instructions;

                                                body.emit(assign(r2600, r2599, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2601->else_instructions;

                                                ir_expression *const r2603 = nequal(r2599, body.constant(0u));
                                                ir_expression *const r2604 = expr(ir_unop_b2i, r2603);
                                                body.emit(assign(r2600, expr(ir_unop_i2u, r2604), 0x01));


                                             body.instructions = f2601_parent_instructions;
                                             body.emit(f2601);

                                             /* END IF */

                                             body.emit(assign(r25F0, r2600, 0x01));

                                             body.emit(assign(r25F1, body.constant(0u), 0x01));


                                          body.instructions = f25FD_parent_instructions;
                                          body.emit(f25FD);

                                          /* END IF */


                                       body.instructions = f25FB_parent_instructions;
                                       body.emit(f25FB);

                                       /* END IF */

                                       body.emit(assign(r25F2, body.constant(0u), 0x01));


                                    body.instructions = f25F7_parent_instructions;
                                    body.emit(f25F7);

                                    /* END IF */

                                    ir_expression *const r2605 = nequal(r25EE, body.constant(0u));
                                    ir_expression *const r2606 = expr(ir_unop_b2i, r2605);
                                    ir_expression *const r2607 = expr(ir_unop_i2u, r2606);
                                    body.emit(assign(r25F0, bit_or(r25F0, r2607), 0x01));


                                 body.instructions = f25F5_parent_instructions;
                                 body.emit(f25F5);

                                 /* END IF */

                                 body.emit(assign(r25D8, r25F2, 0x01));

                                 body.emit(assign(r25D9, r25F1, 0x01));

                                 body.emit(assign(r25DA, r25F0, 0x01));

                                 body.emit(assign(r25D7, body.constant(int(0)), 0x01));

                                 body.emit(assign(r25DD, less(r25F0, body.constant(0u)), 0x01));


                              body.instructions = f25EC_parent_instructions;
                              body.emit(f25EC);

                              /* END IF */


                           body.instructions = f25E9_parent_instructions;
                           body.emit(f25E9);

                           /* END IF */


                        body.instructions = f25DF_parent_instructions;
                        body.emit(f25DF);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2608 = new(mem_ctx) ir_if(operand(r25DB).val);
                        exec_list *const f2608_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2608->then_instructions;

                           /* IF CONDITION */
                           ir_if *f2609 = new(mem_ctx) ir_if(operand(r25DD).val);
                           exec_list *const f2609_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2609->then_instructions;

                              ir_variable *const r260A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r260A, add(r25D9, body.constant(1u)), 0x01));

                              ir_expression *const r260B = less(r260A, r25D9);
                              ir_expression *const r260C = expr(ir_unop_b2i, r260B);
                              ir_expression *const r260D = expr(ir_unop_i2u, r260C);
                              body.emit(assign(r25D8, add(r25D8, r260D), 0x01));

                              ir_expression *const r260E = equal(r25DA, body.constant(0u));
                              ir_expression *const r260F = expr(ir_unop_b2i, r260E);
                              ir_expression *const r2610 = expr(ir_unop_i2u, r260F);
                              ir_expression *const r2611 = add(r25DA, r2610);
                              ir_expression *const r2612 = bit_and(r2611, body.constant(1u));
                              ir_expression *const r2613 = expr(ir_unop_bit_not, r2612);
                              body.emit(assign(r25D9, bit_and(r260A, r2613), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2609->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2615 = bit_or(r25D8, r25D9);
                              ir_expression *const r2616 = equal(r2615, body.constant(0u));
                              ir_if *f2614 = new(mem_ctx) ir_if(operand(r2616).val);
                              exec_list *const f2614_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2614->then_instructions;

                                 body.emit(assign(r25D7, body.constant(int(0)), 0x01));


                              body.instructions = f2614_parent_instructions;
                              body.emit(f2614);

                              /* END IF */


                           body.instructions = f2609_parent_instructions;
                           body.emit(f2609);

                           /* END IF */

                           ir_variable *const r2617 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2617);
                           ir_expression *const r2618 = lshift(r237A, body.constant(int(31)));
                           ir_expression *const r2619 = expr(ir_unop_i2u, r25D7);
                           ir_expression *const r261A = lshift(r2619, body.constant(int(20)));
                           ir_expression *const r261B = add(r2618, r261A);
                           body.emit(assign(r2617, add(r261B, r25D8), 0x02));

                           body.emit(assign(r2617, r25D9, 0x01));

                           body.emit(assign(r25DC, r2617, 0x03));

                           body.emit(assign(r25DB, body.constant(false), 0x01));


                        body.instructions = f2608_parent_instructions;
                        body.emit(f2608);

                        /* END IF */

                        body.emit(assign(r237B, r25DC, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2590->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r261D = less(r2380, r2382);
                        ir_if *f261C = new(mem_ctx) ir_if(operand(r261D).val);
                        exec_list *const f261C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f261C->then_instructions;

                           ir_variable *const r261E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r261F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r261F, sub(r2382, r2380), 0x01));

                           ir_expression *const r2620 = sub(r2381, r237F);
                           ir_expression *const r2621 = less(r2382, r2380);
                           ir_expression *const r2622 = expr(ir_unop_b2i, r2621);
                           ir_expression *const r2623 = expr(ir_unop_i2u, r2622);
                           body.emit(assign(r261E, sub(r2620, r2623), 0x01));

                           body.emit(assign(r2383, add(r237E, body.constant(int(-1))), 0x01));

                           ir_variable *const r2624 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2624, add(r2383, body.constant(int(-10))), 0x01));

                           ir_variable *const r2625 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2625, r261E, 0x01));

                           ir_variable *const r2626 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2626, r261F, 0x01));

                           ir_variable *const r2627 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r2627);
                           ir_variable *const r2628 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2628);
                           /* IF CONDITION */
                           ir_expression *const r262A = equal(r261E, body.constant(0u));
                           ir_if *f2629 = new(mem_ctx) ir_if(operand(r262A).val);
                           exec_list *const f2629_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2629->then_instructions;

                              body.emit(assign(r2625, r261F, 0x01));

                              body.emit(assign(r2626, body.constant(0u), 0x01));

                              body.emit(assign(r2624, add(r2624, body.constant(int(-32))), 0x01));


                           body.instructions = f2629_parent_instructions;
                           body.emit(f2629);

                           /* END IF */

                           ir_variable *const r262B = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r262B, r2625, 0x01));

                           ir_variable *const r262C = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r262D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r262D);
                           /* IF CONDITION */
                           ir_expression *const r262F = equal(r2625, body.constant(0u));
                           ir_if *f262E = new(mem_ctx) ir_if(operand(r262F).val);
                           exec_list *const f262E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f262E->then_instructions;

                              body.emit(assign(r262C, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f262E->else_instructions;

                              body.emit(assign(r262D, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2631 = bit_and(r2625, body.constant(4294901760u));
                              ir_expression *const r2632 = equal(r2631, body.constant(0u));
                              ir_if *f2630 = new(mem_ctx) ir_if(operand(r2632).val);
                              exec_list *const f2630_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2630->then_instructions;

                                 body.emit(assign(r262D, body.constant(int(16)), 0x01));

                                 body.emit(assign(r262B, lshift(r2625, body.constant(int(16))), 0x01));


                              body.instructions = f2630_parent_instructions;
                              body.emit(f2630);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2634 = bit_and(r262B, body.constant(4278190080u));
                              ir_expression *const r2635 = equal(r2634, body.constant(0u));
                              ir_if *f2633 = new(mem_ctx) ir_if(operand(r2635).val);
                              exec_list *const f2633_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2633->then_instructions;

                                 body.emit(assign(r262D, add(r262D, body.constant(int(8))), 0x01));

                                 body.emit(assign(r262B, lshift(r262B, body.constant(int(8))), 0x01));


                              body.instructions = f2633_parent_instructions;
                              body.emit(f2633);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2637 = bit_and(r262B, body.constant(4026531840u));
                              ir_expression *const r2638 = equal(r2637, body.constant(0u));
                              ir_if *f2636 = new(mem_ctx) ir_if(operand(r2638).val);
                              exec_list *const f2636_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2636->then_instructions;

                                 body.emit(assign(r262D, add(r262D, body.constant(int(4))), 0x01));

                                 body.emit(assign(r262B, lshift(r262B, body.constant(int(4))), 0x01));


                              body.instructions = f2636_parent_instructions;
                              body.emit(f2636);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r263A = bit_and(r262B, body.constant(3221225472u));
                              ir_expression *const r263B = equal(r263A, body.constant(0u));
                              ir_if *f2639 = new(mem_ctx) ir_if(operand(r263B).val);
                              exec_list *const f2639_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2639->then_instructions;

                                 body.emit(assign(r262D, add(r262D, body.constant(int(2))), 0x01));

                                 body.emit(assign(r262B, lshift(r262B, body.constant(int(2))), 0x01));


                              body.instructions = f2639_parent_instructions;
                              body.emit(f2639);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r263D = bit_and(r262B, body.constant(2147483648u));
                              ir_expression *const r263E = equal(r263D, body.constant(0u));
                              ir_if *f263C = new(mem_ctx) ir_if(operand(r263E).val);
                              exec_list *const f263C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f263C->then_instructions;

                                 body.emit(assign(r262D, add(r262D, body.constant(int(1))), 0x01));


                              body.instructions = f263C_parent_instructions;
                              body.emit(f263C);

                              /* END IF */

                              body.emit(assign(r262C, r262D, 0x01));


                           body.instructions = f262E_parent_instructions;
                           body.emit(f262E);

                           /* END IF */

                           body.emit(assign(r2628, add(r262C, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2640 = lequal(body.constant(int(0)), r2628);
                           ir_if *f263F = new(mem_ctx) ir_if(operand(r2640).val);
                           exec_list *const f263F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f263F->then_instructions;

                              body.emit(assign(r2627, body.constant(0u), 0x01));

                              ir_variable *const r2641 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2641, lshift(r2626, r2628), 0x01));

                              ir_variable *const r2642 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2644 = equal(r2628, body.constant(int(0)));
                              ir_if *f2643 = new(mem_ctx) ir_if(operand(r2644).val);
                              exec_list *const f2643_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2643->then_instructions;

                                 body.emit(assign(r2642, r2625, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2643->else_instructions;

                                 ir_expression *const r2645 = lshift(r2625, r2628);
                                 ir_expression *const r2646 = neg(r2628);
                                 ir_expression *const r2647 = bit_and(r2646, body.constant(int(31)));
                                 ir_expression *const r2648 = rshift(r2626, r2647);
                                 body.emit(assign(r2642, bit_or(r2645, r2648), 0x01));


                              body.instructions = f2643_parent_instructions;
                              body.emit(f2643);

                              /* END IF */

                              body.emit(assign(r2625, r2642, 0x01));

                              body.emit(assign(r2626, r2641, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f263F->else_instructions;

                              ir_variable *const r2649 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2649, body.constant(0u), 0x01));

                              ir_variable *const r264A = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r264A, neg(r2628), 0x01));

                              ir_variable *const r264B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r264B);
                              ir_variable *const r264C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r264C);
                              ir_variable *const r264D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r264D);
                              ir_variable *const r264E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r264F = neg(r264A);
                              body.emit(assign(r264E, bit_and(r264F, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2651 = equal(r264A, body.constant(int(0)));
                              ir_if *f2650 = new(mem_ctx) ir_if(operand(r2651).val);
                              exec_list *const f2650_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2650->then_instructions;

                                 body.emit(assign(r264B, r2649, 0x01));

                                 body.emit(assign(r264C, r2626, 0x01));

                                 body.emit(assign(r264D, r2625, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2650->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2653 = less(r264A, body.constant(int(32)));
                                 ir_if *f2652 = new(mem_ctx) ir_if(operand(r2653).val);
                                 exec_list *const f2652_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2652->then_instructions;

                                    body.emit(assign(r264B, lshift(r2626, r264E), 0x01));

                                    ir_expression *const r2654 = lshift(r2625, r264E);
                                    ir_expression *const r2655 = rshift(r2626, r264A);
                                    body.emit(assign(r264C, bit_or(r2654, r2655), 0x01));

                                    body.emit(assign(r264D, rshift(r2625, r264A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2652->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2657 = equal(r264A, body.constant(int(32)));
                                    ir_if *f2656 = new(mem_ctx) ir_if(operand(r2657).val);
                                    exec_list *const f2656_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2656->then_instructions;

                                       body.emit(assign(r264B, r2626, 0x01));

                                       body.emit(assign(r264C, r2625, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2656->else_instructions;

                                       body.emit(assign(r2649, bit_or(body.constant(0u), r2626), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2659 = less(r264A, body.constant(int(64)));
                                       ir_if *f2658 = new(mem_ctx) ir_if(operand(r2659).val);
                                       exec_list *const f2658_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2658->then_instructions;

                                          body.emit(assign(r264B, lshift(r2625, r264E), 0x01));

                                          ir_expression *const r265A = bit_and(r264A, body.constant(int(31)));
                                          body.emit(assign(r264C, rshift(r2625, r265A), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2658->else_instructions;

                                          ir_variable *const r265B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r265D = equal(r264A, body.constant(int(64)));
                                          ir_if *f265C = new(mem_ctx) ir_if(operand(r265D).val);
                                          exec_list *const f265C_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f265C->then_instructions;

                                             body.emit(assign(r265B, r2625, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f265C->else_instructions;

                                             ir_expression *const r265E = nequal(r2625, body.constant(0u));
                                             ir_expression *const r265F = expr(ir_unop_b2i, r265E);
                                             body.emit(assign(r265B, expr(ir_unop_i2u, r265F), 0x01));


                                          body.instructions = f265C_parent_instructions;
                                          body.emit(f265C);

                                          /* END IF */

                                          body.emit(assign(r264B, r265B, 0x01));

                                          body.emit(assign(r264C, body.constant(0u), 0x01));


                                       body.instructions = f2658_parent_instructions;
                                       body.emit(f2658);

                                       /* END IF */


                                    body.instructions = f2656_parent_instructions;
                                    body.emit(f2656);

                                    /* END IF */

                                    body.emit(assign(r264D, body.constant(0u), 0x01));


                                 body.instructions = f2652_parent_instructions;
                                 body.emit(f2652);

                                 /* END IF */

                                 ir_expression *const r2660 = nequal(r2649, body.constant(0u));
                                 ir_expression *const r2661 = expr(ir_unop_b2i, r2660);
                                 ir_expression *const r2662 = expr(ir_unop_i2u, r2661);
                                 body.emit(assign(r264B, bit_or(r264B, r2662), 0x01));


                              body.instructions = f2650_parent_instructions;
                              body.emit(f2650);

                              /* END IF */

                              body.emit(assign(r2625, r264D, 0x01));

                              body.emit(assign(r2626, r264C, 0x01));

                              body.emit(assign(r2627, r264B, 0x01));


                           body.instructions = f263F_parent_instructions;
                           body.emit(f263F);

                           /* END IF */

                           body.emit(assign(r2624, sub(r2624, r2628), 0x01));

                           ir_variable *const r2663 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2663, r2624, 0x01));

                           ir_variable *const r2664 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2664, r2625, 0x01));

                           ir_variable *const r2665 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2665, r2626, 0x01));

                           ir_variable *const r2666 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r2666, r2627, 0x01));

                           ir_variable *const r2667 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r2667, body.constant(true), 0x01));

                           ir_variable *const r2668 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r2669 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r2669);
                           ir_expression *const r266A = expr(ir_unop_u2i, r2627);
                           body.emit(assign(r2669, less(r266A, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r266C = lequal(body.constant(int(2045)), r2624);
                           ir_if *f266B = new(mem_ctx) ir_if(operand(r266C).val);
                           exec_list *const f266B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f266B->then_instructions;

                              ir_variable *const r266D = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r266F = less(body.constant(int(2045)), r2624);
                              ir_if *f266E = new(mem_ctx) ir_if(operand(r266F).val);
                              exec_list *const f266E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f266E->then_instructions;

                                 body.emit(assign(r266D, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f266E->else_instructions;

                                 ir_variable *const r2670 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2672 = equal(r2624, body.constant(int(2045)));
                                 ir_if *f2671 = new(mem_ctx) ir_if(operand(r2672).val);
                                 exec_list *const f2671_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2671->then_instructions;

                                    ir_expression *const r2673 = equal(body.constant(2097151u), r2625);
                                    ir_expression *const r2674 = equal(body.constant(4294967295u), r2626);
                                    body.emit(assign(r2670, logic_and(r2673, r2674), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2671->else_instructions;

                                    body.emit(assign(r2670, body.constant(false), 0x01));


                                 body.instructions = f2671_parent_instructions;
                                 body.emit(f2671);

                                 /* END IF */

                                 body.emit(assign(r266D, logic_and(r2670, r2669), 0x01));


                              body.instructions = f266E_parent_instructions;
                              body.emit(f266E);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2675 = new(mem_ctx) ir_if(operand(r266D).val);
                              exec_list *const f2675_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2675->then_instructions;

                                 ir_variable *const r2676 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2676);
                                 ir_expression *const r2677 = lshift(r237A, body.constant(int(31)));
                                 body.emit(assign(r2676, add(r2677, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r2676, body.constant(0u), 0x01));

                                 body.emit(assign(r2668, r2676, 0x03));

                                 body.emit(assign(r2667, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2675->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2679 = less(r2624, body.constant(int(0)));
                                 ir_if *f2678 = new(mem_ctx) ir_if(operand(r2679).val);
                                 exec_list *const f2678_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2678->then_instructions;

                                    ir_variable *const r267A = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r267A, r2627, 0x01));

                                    ir_variable *const r267B = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r267B, neg(r2624), 0x01));

                                    ir_variable *const r267C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r267C);
                                    ir_variable *const r267D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r267D);
                                    ir_variable *const r267E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r267E);
                                    ir_variable *const r267F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r2680 = neg(r267B);
                                    body.emit(assign(r267F, bit_and(r2680, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2682 = equal(r267B, body.constant(int(0)));
                                    ir_if *f2681 = new(mem_ctx) ir_if(operand(r2682).val);
                                    exec_list *const f2681_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2681->then_instructions;

                                       body.emit(assign(r267C, r2627, 0x01));

                                       body.emit(assign(r267D, r2626, 0x01));

                                       body.emit(assign(r267E, r2625, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2681->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2684 = less(r267B, body.constant(int(32)));
                                       ir_if *f2683 = new(mem_ctx) ir_if(operand(r2684).val);
                                       exec_list *const f2683_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2683->then_instructions;

                                          body.emit(assign(r267C, lshift(r2626, r267F), 0x01));

                                          ir_expression *const r2685 = lshift(r2625, r267F);
                                          ir_expression *const r2686 = rshift(r2626, r267B);
                                          body.emit(assign(r267D, bit_or(r2685, r2686), 0x01));

                                          body.emit(assign(r267E, rshift(r2625, r267B), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2683->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2688 = equal(r267B, body.constant(int(32)));
                                          ir_if *f2687 = new(mem_ctx) ir_if(operand(r2688).val);
                                          exec_list *const f2687_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2687->then_instructions;

                                             body.emit(assign(r267C, r2626, 0x01));

                                             body.emit(assign(r267D, r2625, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2687->else_instructions;

                                             body.emit(assign(r267A, bit_or(r2627, r2626), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r268A = less(r267B, body.constant(int(64)));
                                             ir_if *f2689 = new(mem_ctx) ir_if(operand(r268A).val);
                                             exec_list *const f2689_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2689->then_instructions;

                                                body.emit(assign(r267C, lshift(r2625, r267F), 0x01));

                                                ir_expression *const r268B = bit_and(r267B, body.constant(int(31)));
                                                body.emit(assign(r267D, rshift(r2625, r268B), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2689->else_instructions;

                                                ir_variable *const r268C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r268E = equal(r267B, body.constant(int(64)));
                                                ir_if *f268D = new(mem_ctx) ir_if(operand(r268E).val);
                                                exec_list *const f268D_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f268D->then_instructions;

                                                   body.emit(assign(r268C, r2625, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f268D->else_instructions;

                                                   ir_expression *const r268F = nequal(r2625, body.constant(0u));
                                                   ir_expression *const r2690 = expr(ir_unop_b2i, r268F);
                                                   body.emit(assign(r268C, expr(ir_unop_i2u, r2690), 0x01));


                                                body.instructions = f268D_parent_instructions;
                                                body.emit(f268D);

                                                /* END IF */

                                                body.emit(assign(r267C, r268C, 0x01));

                                                body.emit(assign(r267D, body.constant(0u), 0x01));


                                             body.instructions = f2689_parent_instructions;
                                             body.emit(f2689);

                                             /* END IF */


                                          body.instructions = f2687_parent_instructions;
                                          body.emit(f2687);

                                          /* END IF */

                                          body.emit(assign(r267E, body.constant(0u), 0x01));


                                       body.instructions = f2683_parent_instructions;
                                       body.emit(f2683);

                                       /* END IF */

                                       ir_expression *const r2691 = nequal(r267A, body.constant(0u));
                                       ir_expression *const r2692 = expr(ir_unop_b2i, r2691);
                                       ir_expression *const r2693 = expr(ir_unop_i2u, r2692);
                                       body.emit(assign(r267C, bit_or(r267C, r2693), 0x01));


                                    body.instructions = f2681_parent_instructions;
                                    body.emit(f2681);

                                    /* END IF */

                                    body.emit(assign(r2664, r267E, 0x01));

                                    body.emit(assign(r2665, r267D, 0x01));

                                    body.emit(assign(r2666, r267C, 0x01));

                                    body.emit(assign(r2663, body.constant(int(0)), 0x01));

                                    body.emit(assign(r2669, less(r267C, body.constant(0u)), 0x01));


                                 body.instructions = f2678_parent_instructions;
                                 body.emit(f2678);

                                 /* END IF */


                              body.instructions = f2675_parent_instructions;
                              body.emit(f2675);

                              /* END IF */


                           body.instructions = f266B_parent_instructions;
                           body.emit(f266B);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2694 = new(mem_ctx) ir_if(operand(r2667).val);
                           exec_list *const f2694_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2694->then_instructions;

                              /* IF CONDITION */
                              ir_if *f2695 = new(mem_ctx) ir_if(operand(r2669).val);
                              exec_list *const f2695_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2695->then_instructions;

                                 ir_variable *const r2696 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r2696, add(r2665, body.constant(1u)), 0x01));

                                 ir_expression *const r2697 = less(r2696, r2665);
                                 ir_expression *const r2698 = expr(ir_unop_b2i, r2697);
                                 ir_expression *const r2699 = expr(ir_unop_i2u, r2698);
                                 body.emit(assign(r2664, add(r2664, r2699), 0x01));

                                 ir_expression *const r269A = equal(r2666, body.constant(0u));
                                 ir_expression *const r269B = expr(ir_unop_b2i, r269A);
                                 ir_expression *const r269C = expr(ir_unop_i2u, r269B);
                                 ir_expression *const r269D = add(r2666, r269C);
                                 ir_expression *const r269E = bit_and(r269D, body.constant(1u));
                                 ir_expression *const r269F = expr(ir_unop_bit_not, r269E);
                                 body.emit(assign(r2665, bit_and(r2696, r269F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2695->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r26A1 = bit_or(r2664, r2665);
                                 ir_expression *const r26A2 = equal(r26A1, body.constant(0u));
                                 ir_if *f26A0 = new(mem_ctx) ir_if(operand(r26A2).val);
                                 exec_list *const f26A0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26A0->then_instructions;

                                    body.emit(assign(r2663, body.constant(int(0)), 0x01));


                                 body.instructions = f26A0_parent_instructions;
                                 body.emit(f26A0);

                                 /* END IF */


                              body.instructions = f2695_parent_instructions;
                              body.emit(f2695);

                              /* END IF */

                              ir_variable *const r26A3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r26A3);
                              ir_expression *const r26A4 = lshift(r237A, body.constant(int(31)));
                              ir_expression *const r26A5 = expr(ir_unop_i2u, r2663);
                              ir_expression *const r26A6 = lshift(r26A5, body.constant(int(20)));
                              ir_expression *const r26A7 = add(r26A4, r26A6);
                              body.emit(assign(r26A3, add(r26A7, r2664), 0x02));

                              body.emit(assign(r26A3, r2665, 0x01));

                              body.emit(assign(r2668, r26A3, 0x03));

                              body.emit(assign(r2667, body.constant(false), 0x01));


                           body.instructions = f2694_parent_instructions;
                           body.emit(f2694);

                           /* END IF */

                           body.emit(assign(r237B, r2668, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f261C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r26A9 = less(r2382, r2380);
                           ir_if *f26A8 = new(mem_ctx) ir_if(operand(r26A9).val);
                           exec_list *const f26A8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f26A8->then_instructions;

                              ir_variable *const r26AA = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r26AB = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r26AB, sub(r2380, r2382), 0x01));

                              ir_expression *const r26AC = sub(r237F, r2381);
                              ir_expression *const r26AD = less(r2380, r2382);
                              ir_expression *const r26AE = expr(ir_unop_b2i, r26AD);
                              ir_expression *const r26AF = expr(ir_unop_i2u, r26AE);
                              body.emit(assign(r26AA, sub(r26AC, r26AF), 0x01));

                              body.emit(assign(r237A, bit_xor(r237A, body.constant(1u)), 0x01));

                              body.emit(assign(r2383, add(r237D, body.constant(int(-1))), 0x01));

                              ir_variable *const r26B0 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r26B0, add(r2383, body.constant(int(-10))), 0x01));

                              ir_variable *const r26B1 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r26B1, r26AA, 0x01));

                              ir_variable *const r26B2 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r26B2, r26AB, 0x01));

                              ir_variable *const r26B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r26B3);
                              ir_variable *const r26B4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r26B4);
                              /* IF CONDITION */
                              ir_expression *const r26B6 = equal(r26AA, body.constant(0u));
                              ir_if *f26B5 = new(mem_ctx) ir_if(operand(r26B6).val);
                              exec_list *const f26B5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f26B5->then_instructions;

                                 body.emit(assign(r26B1, r26AB, 0x01));

                                 body.emit(assign(r26B2, body.constant(0u), 0x01));

                                 body.emit(assign(r26B0, add(r26B0, body.constant(int(-32))), 0x01));


                              body.instructions = f26B5_parent_instructions;
                              body.emit(f26B5);

                              /* END IF */

                              ir_variable *const r26B7 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r26B7, r26B1, 0x01));

                              ir_variable *const r26B8 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r26B9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r26B9);
                              /* IF CONDITION */
                              ir_expression *const r26BB = equal(r26B1, body.constant(0u));
                              ir_if *f26BA = new(mem_ctx) ir_if(operand(r26BB).val);
                              exec_list *const f26BA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f26BA->then_instructions;

                                 body.emit(assign(r26B8, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f26BA->else_instructions;

                                 body.emit(assign(r26B9, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r26BD = bit_and(r26B1, body.constant(4294901760u));
                                 ir_expression *const r26BE = equal(r26BD, body.constant(0u));
                                 ir_if *f26BC = new(mem_ctx) ir_if(operand(r26BE).val);
                                 exec_list *const f26BC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26BC->then_instructions;

                                    body.emit(assign(r26B9, body.constant(int(16)), 0x01));

                                    body.emit(assign(r26B7, lshift(r26B1, body.constant(int(16))), 0x01));


                                 body.instructions = f26BC_parent_instructions;
                                 body.emit(f26BC);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r26C0 = bit_and(r26B7, body.constant(4278190080u));
                                 ir_expression *const r26C1 = equal(r26C0, body.constant(0u));
                                 ir_if *f26BF = new(mem_ctx) ir_if(operand(r26C1).val);
                                 exec_list *const f26BF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26BF->then_instructions;

                                    body.emit(assign(r26B9, add(r26B9, body.constant(int(8))), 0x01));

                                    body.emit(assign(r26B7, lshift(r26B7, body.constant(int(8))), 0x01));


                                 body.instructions = f26BF_parent_instructions;
                                 body.emit(f26BF);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r26C3 = bit_and(r26B7, body.constant(4026531840u));
                                 ir_expression *const r26C4 = equal(r26C3, body.constant(0u));
                                 ir_if *f26C2 = new(mem_ctx) ir_if(operand(r26C4).val);
                                 exec_list *const f26C2_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26C2->then_instructions;

                                    body.emit(assign(r26B9, add(r26B9, body.constant(int(4))), 0x01));

                                    body.emit(assign(r26B7, lshift(r26B7, body.constant(int(4))), 0x01));


                                 body.instructions = f26C2_parent_instructions;
                                 body.emit(f26C2);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r26C6 = bit_and(r26B7, body.constant(3221225472u));
                                 ir_expression *const r26C7 = equal(r26C6, body.constant(0u));
                                 ir_if *f26C5 = new(mem_ctx) ir_if(operand(r26C7).val);
                                 exec_list *const f26C5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26C5->then_instructions;

                                    body.emit(assign(r26B9, add(r26B9, body.constant(int(2))), 0x01));

                                    body.emit(assign(r26B7, lshift(r26B7, body.constant(int(2))), 0x01));


                                 body.instructions = f26C5_parent_instructions;
                                 body.emit(f26C5);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r26C9 = bit_and(r26B7, body.constant(2147483648u));
                                 ir_expression *const r26CA = equal(r26C9, body.constant(0u));
                                 ir_if *f26C8 = new(mem_ctx) ir_if(operand(r26CA).val);
                                 exec_list *const f26C8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26C8->then_instructions;

                                    body.emit(assign(r26B9, add(r26B9, body.constant(int(1))), 0x01));


                                 body.instructions = f26C8_parent_instructions;
                                 body.emit(f26C8);

                                 /* END IF */

                                 body.emit(assign(r26B8, r26B9, 0x01));


                              body.instructions = f26BA_parent_instructions;
                              body.emit(f26BA);

                              /* END IF */

                              body.emit(assign(r26B4, add(r26B8, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r26CC = lequal(body.constant(int(0)), r26B4);
                              ir_if *f26CB = new(mem_ctx) ir_if(operand(r26CC).val);
                              exec_list *const f26CB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f26CB->then_instructions;

                                 body.emit(assign(r26B3, body.constant(0u), 0x01));

                                 ir_variable *const r26CD = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r26CD, lshift(r26B2, r26B4), 0x01));

                                 ir_variable *const r26CE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r26D0 = equal(r26B4, body.constant(int(0)));
                                 ir_if *f26CF = new(mem_ctx) ir_if(operand(r26D0).val);
                                 exec_list *const f26CF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26CF->then_instructions;

                                    body.emit(assign(r26CE, r26B1, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26CF->else_instructions;

                                    ir_expression *const r26D1 = lshift(r26B1, r26B4);
                                    ir_expression *const r26D2 = neg(r26B4);
                                    ir_expression *const r26D3 = bit_and(r26D2, body.constant(int(31)));
                                    ir_expression *const r26D4 = rshift(r26B2, r26D3);
                                    body.emit(assign(r26CE, bit_or(r26D1, r26D4), 0x01));


                                 body.instructions = f26CF_parent_instructions;
                                 body.emit(f26CF);

                                 /* END IF */

                                 body.emit(assign(r26B1, r26CE, 0x01));

                                 body.emit(assign(r26B2, r26CD, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f26CB->else_instructions;

                                 ir_variable *const r26D5 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r26D5, body.constant(0u), 0x01));

                                 ir_variable *const r26D6 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r26D6, neg(r26B4), 0x01));

                                 ir_variable *const r26D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r26D7);
                                 ir_variable *const r26D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r26D8);
                                 ir_variable *const r26D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r26D9);
                                 ir_variable *const r26DA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r26DB = neg(r26D6);
                                 body.emit(assign(r26DA, bit_and(r26DB, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r26DD = equal(r26D6, body.constant(int(0)));
                                 ir_if *f26DC = new(mem_ctx) ir_if(operand(r26DD).val);
                                 exec_list *const f26DC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26DC->then_instructions;

                                    body.emit(assign(r26D7, r26D5, 0x01));

                                    body.emit(assign(r26D8, r26B2, 0x01));

                                    body.emit(assign(r26D9, r26B1, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26DC->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r26DF = less(r26D6, body.constant(int(32)));
                                    ir_if *f26DE = new(mem_ctx) ir_if(operand(r26DF).val);
                                    exec_list *const f26DE_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f26DE->then_instructions;

                                       body.emit(assign(r26D7, lshift(r26B2, r26DA), 0x01));

                                       ir_expression *const r26E0 = lshift(r26B1, r26DA);
                                       ir_expression *const r26E1 = rshift(r26B2, r26D6);
                                       body.emit(assign(r26D8, bit_or(r26E0, r26E1), 0x01));

                                       body.emit(assign(r26D9, rshift(r26B1, r26D6), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f26DE->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r26E3 = equal(r26D6, body.constant(int(32)));
                                       ir_if *f26E2 = new(mem_ctx) ir_if(operand(r26E3).val);
                                       exec_list *const f26E2_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f26E2->then_instructions;

                                          body.emit(assign(r26D7, r26B2, 0x01));

                                          body.emit(assign(r26D8, r26B1, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f26E2->else_instructions;

                                          body.emit(assign(r26D5, bit_or(body.constant(0u), r26B2), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r26E5 = less(r26D6, body.constant(int(64)));
                                          ir_if *f26E4 = new(mem_ctx) ir_if(operand(r26E5).val);
                                          exec_list *const f26E4_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f26E4->then_instructions;

                                             body.emit(assign(r26D7, lshift(r26B1, r26DA), 0x01));

                                             ir_expression *const r26E6 = bit_and(r26D6, body.constant(int(31)));
                                             body.emit(assign(r26D8, rshift(r26B1, r26E6), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f26E4->else_instructions;

                                             ir_variable *const r26E7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r26E9 = equal(r26D6, body.constant(int(64)));
                                             ir_if *f26E8 = new(mem_ctx) ir_if(operand(r26E9).val);
                                             exec_list *const f26E8_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f26E8->then_instructions;

                                                body.emit(assign(r26E7, r26B1, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f26E8->else_instructions;

                                                ir_expression *const r26EA = nequal(r26B1, body.constant(0u));
                                                ir_expression *const r26EB = expr(ir_unop_b2i, r26EA);
                                                body.emit(assign(r26E7, expr(ir_unop_i2u, r26EB), 0x01));


                                             body.instructions = f26E8_parent_instructions;
                                             body.emit(f26E8);

                                             /* END IF */

                                             body.emit(assign(r26D7, r26E7, 0x01));

                                             body.emit(assign(r26D8, body.constant(0u), 0x01));


                                          body.instructions = f26E4_parent_instructions;
                                          body.emit(f26E4);

                                          /* END IF */


                                       body.instructions = f26E2_parent_instructions;
                                       body.emit(f26E2);

                                       /* END IF */

                                       body.emit(assign(r26D9, body.constant(0u), 0x01));


                                    body.instructions = f26DE_parent_instructions;
                                    body.emit(f26DE);

                                    /* END IF */

                                    ir_expression *const r26EC = nequal(r26D5, body.constant(0u));
                                    ir_expression *const r26ED = expr(ir_unop_b2i, r26EC);
                                    ir_expression *const r26EE = expr(ir_unop_i2u, r26ED);
                                    body.emit(assign(r26D7, bit_or(r26D7, r26EE), 0x01));


                                 body.instructions = f26DC_parent_instructions;
                                 body.emit(f26DC);

                                 /* END IF */

                                 body.emit(assign(r26B1, r26D9, 0x01));

                                 body.emit(assign(r26B2, r26D8, 0x01));

                                 body.emit(assign(r26B3, r26D7, 0x01));


                              body.instructions = f26CB_parent_instructions;
                              body.emit(f26CB);

                              /* END IF */

                              body.emit(assign(r26B0, sub(r26B0, r26B4), 0x01));

                              ir_variable *const r26EF = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r26EF, r26B0, 0x01));

                              ir_variable *const r26F0 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r26F0, r26B1, 0x01));

                              ir_variable *const r26F1 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r26F1, r26B2, 0x01));

                              ir_variable *const r26F2 = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r26F2, r26B3, 0x01));

                              ir_variable *const r26F3 = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r26F3, body.constant(true), 0x01));

                              ir_variable *const r26F4 = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r26F5 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r26F5);
                              ir_expression *const r26F6 = expr(ir_unop_u2i, r26B3);
                              body.emit(assign(r26F5, less(r26F6, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r26F8 = lequal(body.constant(int(2045)), r26B0);
                              ir_if *f26F7 = new(mem_ctx) ir_if(operand(r26F8).val);
                              exec_list *const f26F7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f26F7->then_instructions;

                                 ir_variable *const r26F9 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r26FB = less(body.constant(int(2045)), r26B0);
                                 ir_if *f26FA = new(mem_ctx) ir_if(operand(r26FB).val);
                                 exec_list *const f26FA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26FA->then_instructions;

                                    body.emit(assign(r26F9, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26FA->else_instructions;

                                    ir_variable *const r26FC = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r26FE = equal(r26B0, body.constant(int(2045)));
                                    ir_if *f26FD = new(mem_ctx) ir_if(operand(r26FE).val);
                                    exec_list *const f26FD_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f26FD->then_instructions;

                                       ir_expression *const r26FF = equal(body.constant(2097151u), r26B1);
                                       ir_expression *const r2700 = equal(body.constant(4294967295u), r26B2);
                                       body.emit(assign(r26FC, logic_and(r26FF, r2700), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f26FD->else_instructions;

                                       body.emit(assign(r26FC, body.constant(false), 0x01));


                                    body.instructions = f26FD_parent_instructions;
                                    body.emit(f26FD);

                                    /* END IF */

                                    body.emit(assign(r26F9, logic_and(r26FC, r26F5), 0x01));


                                 body.instructions = f26FA_parent_instructions;
                                 body.emit(f26FA);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f2701 = new(mem_ctx) ir_if(operand(r26F9).val);
                                 exec_list *const f2701_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2701->then_instructions;

                                    ir_variable *const r2702 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r2702);
                                    ir_expression *const r2703 = lshift(r237A, body.constant(int(31)));
                                    body.emit(assign(r2702, add(r2703, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r2702, body.constant(0u), 0x01));

                                    body.emit(assign(r26F4, r2702, 0x03));

                                    body.emit(assign(r26F3, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2701->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2705 = less(r26B0, body.constant(int(0)));
                                    ir_if *f2704 = new(mem_ctx) ir_if(operand(r2705).val);
                                    exec_list *const f2704_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2704->then_instructions;

                                       ir_variable *const r2706 = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r2706, r26B3, 0x01));

                                       ir_variable *const r2707 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r2707, neg(r26B0), 0x01));

                                       ir_variable *const r2708 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r2708);
                                       ir_variable *const r2709 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r2709);
                                       ir_variable *const r270A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r270A);
                                       ir_variable *const r270B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r270C = neg(r2707);
                                       body.emit(assign(r270B, bit_and(r270C, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r270E = equal(r2707, body.constant(int(0)));
                                       ir_if *f270D = new(mem_ctx) ir_if(operand(r270E).val);
                                       exec_list *const f270D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f270D->then_instructions;

                                          body.emit(assign(r2708, r26B3, 0x01));

                                          body.emit(assign(r2709, r26B2, 0x01));

                                          body.emit(assign(r270A, r26B1, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f270D->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2710 = less(r2707, body.constant(int(32)));
                                          ir_if *f270F = new(mem_ctx) ir_if(operand(r2710).val);
                                          exec_list *const f270F_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f270F->then_instructions;

                                             body.emit(assign(r2708, lshift(r26B2, r270B), 0x01));

                                             ir_expression *const r2711 = lshift(r26B1, r270B);
                                             ir_expression *const r2712 = rshift(r26B2, r2707);
                                             body.emit(assign(r2709, bit_or(r2711, r2712), 0x01));

                                             body.emit(assign(r270A, rshift(r26B1, r2707), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f270F->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r2714 = equal(r2707, body.constant(int(32)));
                                             ir_if *f2713 = new(mem_ctx) ir_if(operand(r2714).val);
                                             exec_list *const f2713_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2713->then_instructions;

                                                body.emit(assign(r2708, r26B2, 0x01));

                                                body.emit(assign(r2709, r26B1, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2713->else_instructions;

                                                body.emit(assign(r2706, bit_or(r26B3, r26B2), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r2716 = less(r2707, body.constant(int(64)));
                                                ir_if *f2715 = new(mem_ctx) ir_if(operand(r2716).val);
                                                exec_list *const f2715_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2715->then_instructions;

                                                   body.emit(assign(r2708, lshift(r26B1, r270B), 0x01));

                                                   ir_expression *const r2717 = bit_and(r2707, body.constant(int(31)));
                                                   body.emit(assign(r2709, rshift(r26B1, r2717), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2715->else_instructions;

                                                   ir_variable *const r2718 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r271A = equal(r2707, body.constant(int(64)));
                                                   ir_if *f2719 = new(mem_ctx) ir_if(operand(r271A).val);
                                                   exec_list *const f2719_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f2719->then_instructions;

                                                      body.emit(assign(r2718, r26B1, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f2719->else_instructions;

                                                      ir_expression *const r271B = nequal(r26B1, body.constant(0u));
                                                      ir_expression *const r271C = expr(ir_unop_b2i, r271B);
                                                      body.emit(assign(r2718, expr(ir_unop_i2u, r271C), 0x01));


                                                   body.instructions = f2719_parent_instructions;
                                                   body.emit(f2719);

                                                   /* END IF */

                                                   body.emit(assign(r2708, r2718, 0x01));

                                                   body.emit(assign(r2709, body.constant(0u), 0x01));


                                                body.instructions = f2715_parent_instructions;
                                                body.emit(f2715);

                                                /* END IF */


                                             body.instructions = f2713_parent_instructions;
                                             body.emit(f2713);

                                             /* END IF */

                                             body.emit(assign(r270A, body.constant(0u), 0x01));


                                          body.instructions = f270F_parent_instructions;
                                          body.emit(f270F);

                                          /* END IF */

                                          ir_expression *const r271D = nequal(r2706, body.constant(0u));
                                          ir_expression *const r271E = expr(ir_unop_b2i, r271D);
                                          ir_expression *const r271F = expr(ir_unop_i2u, r271E);
                                          body.emit(assign(r2708, bit_or(r2708, r271F), 0x01));


                                       body.instructions = f270D_parent_instructions;
                                       body.emit(f270D);

                                       /* END IF */

                                       body.emit(assign(r26F0, r270A, 0x01));

                                       body.emit(assign(r26F1, r2709, 0x01));

                                       body.emit(assign(r26F2, r2708, 0x01));

                                       body.emit(assign(r26EF, body.constant(int(0)), 0x01));

                                       body.emit(assign(r26F5, less(r2708, body.constant(0u)), 0x01));


                                    body.instructions = f2704_parent_instructions;
                                    body.emit(f2704);

                                    /* END IF */


                                 body.instructions = f2701_parent_instructions;
                                 body.emit(f2701);

                                 /* END IF */


                              body.instructions = f26F7_parent_instructions;
                              body.emit(f26F7);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2720 = new(mem_ctx) ir_if(operand(r26F3).val);
                              exec_list *const f2720_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2720->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f2721 = new(mem_ctx) ir_if(operand(r26F5).val);
                                 exec_list *const f2721_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2721->then_instructions;

                                    ir_variable *const r2722 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r2722, add(r26F1, body.constant(1u)), 0x01));

                                    ir_expression *const r2723 = less(r2722, r26F1);
                                    ir_expression *const r2724 = expr(ir_unop_b2i, r2723);
                                    ir_expression *const r2725 = expr(ir_unop_i2u, r2724);
                                    body.emit(assign(r26F0, add(r26F0, r2725), 0x01));

                                    ir_expression *const r2726 = equal(r26F2, body.constant(0u));
                                    ir_expression *const r2727 = expr(ir_unop_b2i, r2726);
                                    ir_expression *const r2728 = expr(ir_unop_i2u, r2727);
                                    ir_expression *const r2729 = add(r26F2, r2728);
                                    ir_expression *const r272A = bit_and(r2729, body.constant(1u));
                                    ir_expression *const r272B = expr(ir_unop_bit_not, r272A);
                                    body.emit(assign(r26F1, bit_and(r2722, r272B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2721->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r272D = bit_or(r26F0, r26F1);
                                    ir_expression *const r272E = equal(r272D, body.constant(0u));
                                    ir_if *f272C = new(mem_ctx) ir_if(operand(r272E).val);
                                    exec_list *const f272C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f272C->then_instructions;

                                       body.emit(assign(r26EF, body.constant(int(0)), 0x01));


                                    body.instructions = f272C_parent_instructions;
                                    body.emit(f272C);

                                    /* END IF */


                                 body.instructions = f2721_parent_instructions;
                                 body.emit(f2721);

                                 /* END IF */

                                 ir_variable *const r272F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r272F);
                                 ir_expression *const r2730 = lshift(r237A, body.constant(int(31)));
                                 ir_expression *const r2731 = expr(ir_unop_i2u, r26EF);
                                 ir_expression *const r2732 = lshift(r2731, body.constant(int(20)));
                                 ir_expression *const r2733 = add(r2730, r2732);
                                 body.emit(assign(r272F, add(r2733, r26F0), 0x02));

                                 body.emit(assign(r272F, r26F1, 0x01));

                                 body.emit(assign(r26F4, r272F, 0x03));

                                 body.emit(assign(r26F3, body.constant(false), 0x01));


                              body.instructions = f2720_parent_instructions;
                              body.emit(f2720);

                              /* END IF */

                              body.emit(assign(r237B, r26F4, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f26A8->else_instructions;

                              ir_variable *const r2734 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2734);
                              body.emit(assign(r2734, body.constant(0u), 0x02));

                              body.emit(assign(r2734, body.constant(0u), 0x01));

                              body.emit(assign(r237B, r2734, 0x03));


                           body.instructions = f26A8_parent_instructions;
                           body.emit(f26A8);

                           /* END IF */


                        body.instructions = f261C_parent_instructions;
                        body.emit(f261C);

                        /* END IF */


                     body.instructions = f2590_parent_instructions;
                     body.emit(f2590);

                     /* END IF */


                  body.instructions = f2504_parent_instructions;
                  body.emit(f2504);

                  /* END IF */


               body.instructions = f24EF_parent_instructions;
               body.emit(f24EF);

               /* END IF */


            body.instructions = f2440_parent_instructions;
            body.emit(f2440);

            /* END IF */


         body.instructions = f238F_parent_instructions;
         body.emit(f238F);

         /* END IF */

         body.emit(assign(r221D, r237B, 0x03));


      body.instructions = f221F_parent_instructions;
      body.emit(f221F);

      /* END IF */

      body.emit(assign(r221B, r221D, 0x03));


   body.instructions = f221C_parent_instructions;
   body.emit(f221C);

   /* END IF */

   body.emit(ret(r221B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ffract64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r2735 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r2735);
   ir_variable *const r2736 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r2737 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r2738 = rshift(swizzle_y(r2735), body.constant(int(20)));
   ir_expression *const r2739 = bit_and(r2738, body.constant(2047u));
   ir_expression *const r273A = expr(ir_unop_u2i, r2739);
   body.emit(assign(r2737, add(r273A, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r273C = less(r2737, body.constant(int(0)));
   ir_if *f273B = new(mem_ctx) ir_if(operand(r273C).val);
   exec_list *const f273B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f273B->then_instructions;

      body.emit(assign(r2736, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f273B->else_instructions;

      /* IF CONDITION */
      ir_expression *const r273E = greater(r2737, body.constant(int(52)));
      ir_if *f273D = new(mem_ctx) ir_if(operand(r273E).val);
      exec_list *const f273D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f273D->then_instructions;

         body.emit(assign(r2736, r2735, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f273D->else_instructions;

         ir_variable *const r273F = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r273F, sub(body.constant(int(52)), r2737), 0x01));

         ir_variable *const r2740 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r2742 = gequal(r273F, body.constant(int(32)));
         ir_if *f2741 = new(mem_ctx) ir_if(operand(r2742).val);
         exec_list *const f2741_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2741->then_instructions;

            body.emit(assign(r2740, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2741->else_instructions;

            body.emit(assign(r2740, lshift(body.constant(4294967295u), r273F), 0x01));


         body.instructions = f2741_parent_instructions;
         body.emit(f2741);

         /* END IF */

         ir_variable *const r2743 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r2745 = less(r273F, body.constant(int(33)));
         ir_if *f2744 = new(mem_ctx) ir_if(operand(r2745).val);
         exec_list *const f2744_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2744->then_instructions;

            body.emit(assign(r2743, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2744->else_instructions;

            ir_expression *const r2746 = add(r273F, body.constant(int(-32)));
            body.emit(assign(r2743, lshift(body.constant(4294967295u), r2746), 0x01));


         body.instructions = f2744_parent_instructions;
         body.emit(f2744);

         /* END IF */

         ir_variable *const r2747 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r2747, bit_and(r2740, swizzle_x(r2735)), 0x01));

         body.emit(assign(r2747, bit_and(r2743, swizzle_y(r2735)), 0x02));

         body.emit(assign(r2736, r2747, 0x03));


      body.instructions = f273D_parent_instructions;
      body.emit(f273D);

      /* END IF */


   body.instructions = f273B_parent_instructions;
   body.emit(f273B);

   /* END IF */

   ir_variable *const r2748 = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r2749 = rshift(swizzle_y(r2735), body.constant(int(31)));
   ir_expression *const r274A = expr(ir_unop_u2i, r2749);
   body.emit(assign(r2748, expr(ir_unop_i2b, r274A), 0x01));

   ir_variable *const r274B = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r274D = expr(ir_unop_logic_not, r2748);
   ir_if *f274C = new(mem_ctx) ir_if(operand(r274D).val);
   exec_list *const f274C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f274C->then_instructions;

      body.emit(assign(r274B, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f274C->else_instructions;

      ir_variable *const r274E = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r274F = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r274F);
      ir_variable *const r2750 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r2750);
      ir_expression *const r2751 = rshift(swizzle_y(r2735), body.constant(int(20)));
      ir_expression *const r2752 = bit_and(r2751, body.constant(2047u));
      ir_expression *const r2753 = expr(ir_unop_u2i, r2752);
      ir_expression *const r2754 = equal(r2753, body.constant(int(2047)));
      ir_expression *const r2755 = bit_and(swizzle_y(r2735), body.constant(1048575u));
      ir_expression *const r2756 = bit_or(r2755, swizzle_x(r2735));
      ir_expression *const r2757 = nequal(r2756, body.constant(0u));
      body.emit(assign(r2750, logic_and(r2754, r2757), 0x01));

      ir_expression *const r2758 = rshift(swizzle_y(r2736), body.constant(int(20)));
      ir_expression *const r2759 = bit_and(r2758, body.constant(2047u));
      ir_expression *const r275A = expr(ir_unop_u2i, r2759);
      ir_expression *const r275B = equal(r275A, body.constant(int(2047)));
      ir_expression *const r275C = bit_and(swizzle_y(r2736), body.constant(1048575u));
      ir_expression *const r275D = bit_or(r275C, swizzle_x(r2736));
      ir_expression *const r275E = nequal(r275D, body.constant(0u));
      body.emit(assign(r274F, logic_and(r275B, r275E), 0x01));

      /* IF CONDITION */
      ir_expression *const r2760 = logic_or(r2750, r274F);
      ir_if *f275F = new(mem_ctx) ir_if(operand(r2760).val);
      exec_list *const f275F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f275F->then_instructions;

         body.emit(assign(r274E, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f275F->else_instructions;

         ir_expression *const r2761 = equal(swizzle_x(r2735), swizzle_x(r2736));
         ir_expression *const r2762 = equal(swizzle_y(r2735), swizzle_y(r2736));
         ir_expression *const r2763 = equal(swizzle_x(r2735), body.constant(0u));
         ir_expression *const r2764 = bit_or(swizzle_y(r2735), swizzle_y(r2736));
         ir_expression *const r2765 = lshift(r2764, body.constant(int(1)));
         ir_expression *const r2766 = equal(r2765, body.constant(0u));
         ir_expression *const r2767 = logic_and(r2763, r2766);
         ir_expression *const r2768 = logic_or(r2762, r2767);
         body.emit(assign(r274E, logic_and(r2761, r2768), 0x01));


      body.instructions = f275F_parent_instructions;
      body.emit(f275F);

      /* END IF */

      body.emit(assign(r274B, r274E, 0x01));


   body.instructions = f274C_parent_instructions;
   body.emit(f274C);

   /* END IF */

   ir_variable *const r2769 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f276A = new(mem_ctx) ir_if(operand(r274B).val);
   exec_list *const f276A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f276A->then_instructions;

      body.emit(assign(r2769, r2736, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f276A->else_instructions;

      ir_variable *const r276B = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r276C = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r276C, rshift(swizzle_y(r2736), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r276E = equal(r276C, body.constant(0u));
      ir_if *f276D = new(mem_ctx) ir_if(operand(r276E).val);
      exec_list *const f276D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f276D->then_instructions;

         ir_variable *const r276F = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r276F, r276C, 0x01));

         ir_variable *const r2770 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2771 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2771);
         ir_variable *const r2772 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r2772);
         ir_variable *const r2773 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r2773);
         ir_variable *const r2774 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r2774);
         ir_variable *const r2775 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r2775);
         ir_variable *const r2776 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r2776);
         ir_variable *const r2777 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r2777);
         ir_variable *const r2778 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r2778);
         ir_variable *const r2779 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r2779, body.constant(0u), 0x01));

         ir_variable *const r277A = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r277B = rshift(swizzle_y(r2736), body.constant(int(20)));
         ir_expression *const r277C = bit_and(r277B, body.constant(2047u));
         body.emit(assign(r277A, expr(ir_unop_u2i, r277C), 0x01));

         body.emit(assign(r2773, r277A, 0x01));

         body.emit(assign(r2772, body.constant(int(1023)), 0x01));

         body.emit(assign(r2771, add(r277A, body.constant(int(-1023))), 0x01));

         ir_variable *const r277D = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r277D, lshift(swizzle_x(r2736), body.constant(int(10))), 0x01));

         ir_variable *const r277E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r277F = bit_and(swizzle_y(r2736), body.constant(1048575u));
         ir_expression *const r2780 = lshift(r277F, body.constant(int(10)));
         ir_expression *const r2781 = rshift(swizzle_x(r2736), body.constant(int(22)));
         body.emit(assign(r277E, bit_or(r2780, r2781), 0x01));

         body.emit(assign(r2776, r277E, 0x01));

         body.emit(assign(r2777, r277D, 0x01));

         ir_variable *const r2782 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r2782, body.constant(0u), 0x01));

         ir_variable *const r2783 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r2783, body.constant(0u), 0x01));

         body.emit(assign(r2774, r2783, 0x01));

         body.emit(assign(r2775, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r2785 = less(body.constant(int(0)), r2771);
         ir_if *f2784 = new(mem_ctx) ir_if(operand(r2785).val);
         exec_list *const f2784_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2784->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2787 = equal(r277A, body.constant(int(2047)));
            ir_if *f2786 = new(mem_ctx) ir_if(operand(r2787).val);
            exec_list *const f2786_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2786->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2789 = bit_or(r277E, r277D);
               ir_expression *const r278A = nequal(r2789, body.constant(0u));
               ir_if *f2788 = new(mem_ctx) ir_if(operand(r278A).val);
               exec_list *const f2788_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2788->then_instructions;

                  ir_variable *const r278B = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r278B, swizzle_x(r2736), 0x01));

                  ir_variable *const r278C = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r278C, body.constant(0u), 0x01));

                  ir_variable *const r278D = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r278B, bit_or(swizzle_y(r2736), body.constant(524288u)), 0x02));

                  body.emit(assign(r278C, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r278F = lshift(swizzle_y(r2736), body.constant(int(1)));
                  ir_expression *const r2790 = lequal(body.constant(4292870144u), r278F);
                  ir_expression *const r2791 = nequal(swizzle_x(r2736), body.constant(0u));
                  ir_expression *const r2792 = bit_and(swizzle_y(r2736), body.constant(1048575u));
                  ir_expression *const r2793 = nequal(r2792, body.constant(0u));
                  ir_expression *const r2794 = logic_or(r2791, r2793);
                  ir_expression *const r2795 = logic_and(r2790, r2794);
                  ir_if *f278E = new(mem_ctx) ir_if(operand(r2795).val);
                  exec_list *const f278E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f278E->then_instructions;

                     body.emit(assign(r278D, r278B, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f278E->else_instructions;

                     body.emit(assign(r278D, r278C, 0x03));


                  body.instructions = f278E_parent_instructions;
                  body.emit(f278E);

                  /* END IF */

                  body.emit(assign(r2770, r278D, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2788->else_instructions;

                  body.emit(assign(r2770, r2736, 0x03));


               body.instructions = f2788_parent_instructions;
               body.emit(f2788);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2786->else_instructions;

               body.emit(assign(r2774, body.constant(1073741824u), 0x01));

               ir_variable *const r2796 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2796);
               ir_variable *const r2797 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2797);
               ir_variable *const r2798 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2799 = neg(r2771);
               body.emit(assign(r2798, bit_and(r2799, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r279B = equal(r2771, body.constant(int(0)));
               ir_if *f279A = new(mem_ctx) ir_if(operand(r279B).val);
               exec_list *const f279A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f279A->then_instructions;

                  body.emit(assign(r2796, body.constant(0u), 0x01));

                  body.emit(assign(r2797, r2774, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f279A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r279D = less(r2771, body.constant(int(32)));
                  ir_if *f279C = new(mem_ctx) ir_if(operand(r279D).val);
                  exec_list *const f279C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f279C->then_instructions;

                     ir_expression *const r279E = lshift(body.constant(1073741824u), r2798);
                     ir_expression *const r279F = bit_or(r279E, body.constant(0u));
                     body.emit(assign(r2796, bit_or(r279F, body.constant(0u)), 0x01));

                     body.emit(assign(r2797, rshift(body.constant(1073741824u), r2771), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f279C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r27A1 = equal(r2771, body.constant(int(32)));
                     ir_if *f27A0 = new(mem_ctx) ir_if(operand(r27A1).val);
                     exec_list *const f27A0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f27A0->then_instructions;

                        body.emit(assign(r2796, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f27A0->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r27A3 = less(r2771, body.constant(int(64)));
                        ir_if *f27A2 = new(mem_ctx) ir_if(operand(r27A3).val);
                        exec_list *const f27A2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f27A2->then_instructions;

                           ir_expression *const r27A4 = bit_and(r2771, body.constant(int(31)));
                           ir_expression *const r27A5 = rshift(body.constant(1073741824u), r27A4);
                           ir_expression *const r27A6 = lshift(body.constant(1073741824u), r2798);
                           ir_expression *const r27A7 = bit_or(r27A6, body.constant(0u));
                           ir_expression *const r27A8 = nequal(r27A7, body.constant(0u));
                           ir_expression *const r27A9 = expr(ir_unop_b2i, r27A8);
                           ir_expression *const r27AA = expr(ir_unop_i2u, r27A9);
                           body.emit(assign(r2796, bit_or(r27A5, r27AA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f27A2->else_instructions;

                           body.emit(assign(r2796, body.constant(1u), 0x01));


                        body.instructions = f27A2_parent_instructions;
                        body.emit(f27A2);

                        /* END IF */


                     body.instructions = f27A0_parent_instructions;
                     body.emit(f27A0);

                     /* END IF */

                     body.emit(assign(r2797, body.constant(0u), 0x01));


                  body.instructions = f279C_parent_instructions;
                  body.emit(f279C);

                  /* END IF */


               body.instructions = f279A_parent_instructions;
               body.emit(f279A);

               /* END IF */

               body.emit(assign(r2774, r2797, 0x01));

               body.emit(assign(r2775, r2796, 0x01));

               body.emit(assign(r2776, bit_or(r277E, body.constant(1073741824u)), 0x01));

               ir_variable *const r27AB = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r27AC = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r27AC, sub(r277D, r2796), 0x01));

               ir_expression *const r27AD = sub(r2776, r2797);
               ir_expression *const r27AE = less(r277D, r2796);
               ir_expression *const r27AF = expr(ir_unop_b2i, r27AE);
               ir_expression *const r27B0 = expr(ir_unop_i2u, r27AF);
               body.emit(assign(r27AB, sub(r27AD, r27B0), 0x01));

               body.emit(assign(r2778, add(r277A, body.constant(int(-1))), 0x01));

               ir_variable *const r27B1 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r27B1, add(r2778, body.constant(int(-10))), 0x01));

               ir_variable *const r27B2 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r27B2, r27AB, 0x01));

               ir_variable *const r27B3 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r27B3, r27AC, 0x01));

               ir_variable *const r27B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r27B4);
               ir_variable *const r27B5 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r27B5);
               /* IF CONDITION */
               ir_expression *const r27B7 = equal(r27AB, body.constant(0u));
               ir_if *f27B6 = new(mem_ctx) ir_if(operand(r27B7).val);
               exec_list *const f27B6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27B6->then_instructions;

                  body.emit(assign(r27B2, r27AC, 0x01));

                  body.emit(assign(r27B3, body.constant(0u), 0x01));

                  body.emit(assign(r27B1, add(r27B1, body.constant(int(-32))), 0x01));


               body.instructions = f27B6_parent_instructions;
               body.emit(f27B6);

               /* END IF */

               ir_variable *const r27B8 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r27B8, r27B2, 0x01));

               ir_variable *const r27B9 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r27BA = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r27BA);
               /* IF CONDITION */
               ir_expression *const r27BC = equal(r27B2, body.constant(0u));
               ir_if *f27BB = new(mem_ctx) ir_if(operand(r27BC).val);
               exec_list *const f27BB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27BB->then_instructions;

                  body.emit(assign(r27B9, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f27BB->else_instructions;

                  body.emit(assign(r27BA, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r27BE = bit_and(r27B2, body.constant(4294901760u));
                  ir_expression *const r27BF = equal(r27BE, body.constant(0u));
                  ir_if *f27BD = new(mem_ctx) ir_if(operand(r27BF).val);
                  exec_list *const f27BD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27BD->then_instructions;

                     body.emit(assign(r27BA, body.constant(int(16)), 0x01));

                     body.emit(assign(r27B8, lshift(r27B2, body.constant(int(16))), 0x01));


                  body.instructions = f27BD_parent_instructions;
                  body.emit(f27BD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r27C1 = bit_and(r27B8, body.constant(4278190080u));
                  ir_expression *const r27C2 = equal(r27C1, body.constant(0u));
                  ir_if *f27C0 = new(mem_ctx) ir_if(operand(r27C2).val);
                  exec_list *const f27C0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27C0->then_instructions;

                     body.emit(assign(r27BA, add(r27BA, body.constant(int(8))), 0x01));

                     body.emit(assign(r27B8, lshift(r27B8, body.constant(int(8))), 0x01));


                  body.instructions = f27C0_parent_instructions;
                  body.emit(f27C0);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r27C4 = bit_and(r27B8, body.constant(4026531840u));
                  ir_expression *const r27C5 = equal(r27C4, body.constant(0u));
                  ir_if *f27C3 = new(mem_ctx) ir_if(operand(r27C5).val);
                  exec_list *const f27C3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27C3->then_instructions;

                     body.emit(assign(r27BA, add(r27BA, body.constant(int(4))), 0x01));

                     body.emit(assign(r27B8, lshift(r27B8, body.constant(int(4))), 0x01));


                  body.instructions = f27C3_parent_instructions;
                  body.emit(f27C3);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r27C7 = bit_and(r27B8, body.constant(3221225472u));
                  ir_expression *const r27C8 = equal(r27C7, body.constant(0u));
                  ir_if *f27C6 = new(mem_ctx) ir_if(operand(r27C8).val);
                  exec_list *const f27C6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27C6->then_instructions;

                     body.emit(assign(r27BA, add(r27BA, body.constant(int(2))), 0x01));

                     body.emit(assign(r27B8, lshift(r27B8, body.constant(int(2))), 0x01));


                  body.instructions = f27C6_parent_instructions;
                  body.emit(f27C6);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r27CA = bit_and(r27B8, body.constant(2147483648u));
                  ir_expression *const r27CB = equal(r27CA, body.constant(0u));
                  ir_if *f27C9 = new(mem_ctx) ir_if(operand(r27CB).val);
                  exec_list *const f27C9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27C9->then_instructions;

                     body.emit(assign(r27BA, add(r27BA, body.constant(int(1))), 0x01));


                  body.instructions = f27C9_parent_instructions;
                  body.emit(f27C9);

                  /* END IF */

                  body.emit(assign(r27B9, r27BA, 0x01));


               body.instructions = f27BB_parent_instructions;
               body.emit(f27BB);

               /* END IF */

               body.emit(assign(r27B5, add(r27B9, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r27CD = lequal(body.constant(int(0)), r27B5);
               ir_if *f27CC = new(mem_ctx) ir_if(operand(r27CD).val);
               exec_list *const f27CC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27CC->then_instructions;

                  body.emit(assign(r27B4, body.constant(0u), 0x01));

                  ir_variable *const r27CE = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r27CE, lshift(r27B3, r27B5), 0x01));

                  ir_variable *const r27CF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r27D1 = equal(r27B5, body.constant(int(0)));
                  ir_if *f27D0 = new(mem_ctx) ir_if(operand(r27D1).val);
                  exec_list *const f27D0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27D0->then_instructions;

                     body.emit(assign(r27CF, r27B2, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27D0->else_instructions;

                     ir_expression *const r27D2 = lshift(r27B2, r27B5);
                     ir_expression *const r27D3 = neg(r27B5);
                     ir_expression *const r27D4 = bit_and(r27D3, body.constant(int(31)));
                     ir_expression *const r27D5 = rshift(r27B3, r27D4);
                     body.emit(assign(r27CF, bit_or(r27D2, r27D5), 0x01));


                  body.instructions = f27D0_parent_instructions;
                  body.emit(f27D0);

                  /* END IF */

                  body.emit(assign(r27B2, r27CF, 0x01));

                  body.emit(assign(r27B3, r27CE, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f27CC->else_instructions;

                  ir_variable *const r27D6 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r27D6, body.constant(0u), 0x01));

                  ir_variable *const r27D7 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r27D7, neg(r27B5), 0x01));

                  ir_variable *const r27D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r27D8);
                  ir_variable *const r27D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r27D9);
                  ir_variable *const r27DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r27DA);
                  ir_variable *const r27DB = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r27DC = neg(r27D7);
                  body.emit(assign(r27DB, bit_and(r27DC, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r27DE = equal(r27D7, body.constant(int(0)));
                  ir_if *f27DD = new(mem_ctx) ir_if(operand(r27DE).val);
                  exec_list *const f27DD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27DD->then_instructions;

                     body.emit(assign(r27D8, r27D6, 0x01));

                     body.emit(assign(r27D9, r27B3, 0x01));

                     body.emit(assign(r27DA, r27B2, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27DD->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r27E0 = less(r27D7, body.constant(int(32)));
                     ir_if *f27DF = new(mem_ctx) ir_if(operand(r27E0).val);
                     exec_list *const f27DF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f27DF->then_instructions;

                        body.emit(assign(r27D8, lshift(r27B3, r27DB), 0x01));

                        ir_expression *const r27E1 = lshift(r27B2, r27DB);
                        ir_expression *const r27E2 = rshift(r27B3, r27D7);
                        body.emit(assign(r27D9, bit_or(r27E1, r27E2), 0x01));

                        body.emit(assign(r27DA, rshift(r27B2, r27D7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f27DF->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r27E4 = equal(r27D7, body.constant(int(32)));
                        ir_if *f27E3 = new(mem_ctx) ir_if(operand(r27E4).val);
                        exec_list *const f27E3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f27E3->then_instructions;

                           body.emit(assign(r27D8, r27B3, 0x01));

                           body.emit(assign(r27D9, r27B2, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f27E3->else_instructions;

                           body.emit(assign(r27D6, bit_or(body.constant(0u), r27B3), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r27E6 = less(r27D7, body.constant(int(64)));
                           ir_if *f27E5 = new(mem_ctx) ir_if(operand(r27E6).val);
                           exec_list *const f27E5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f27E5->then_instructions;

                              body.emit(assign(r27D8, lshift(r27B2, r27DB), 0x01));

                              ir_expression *const r27E7 = bit_and(r27D7, body.constant(int(31)));
                              body.emit(assign(r27D9, rshift(r27B2, r27E7), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f27E5->else_instructions;

                              ir_variable *const r27E8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r27EA = equal(r27D7, body.constant(int(64)));
                              ir_if *f27E9 = new(mem_ctx) ir_if(operand(r27EA).val);
                              exec_list *const f27E9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27E9->then_instructions;

                                 body.emit(assign(r27E8, r27B2, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f27E9->else_instructions;

                                 ir_expression *const r27EB = nequal(r27B2, body.constant(0u));
                                 ir_expression *const r27EC = expr(ir_unop_b2i, r27EB);
                                 body.emit(assign(r27E8, expr(ir_unop_i2u, r27EC), 0x01));


                              body.instructions = f27E9_parent_instructions;
                              body.emit(f27E9);

                              /* END IF */

                              body.emit(assign(r27D8, r27E8, 0x01));

                              body.emit(assign(r27D9, body.constant(0u), 0x01));


                           body.instructions = f27E5_parent_instructions;
                           body.emit(f27E5);

                           /* END IF */


                        body.instructions = f27E3_parent_instructions;
                        body.emit(f27E3);

                        /* END IF */

                        body.emit(assign(r27DA, body.constant(0u), 0x01));


                     body.instructions = f27DF_parent_instructions;
                     body.emit(f27DF);

                     /* END IF */

                     ir_expression *const r27ED = nequal(r27D6, body.constant(0u));
                     ir_expression *const r27EE = expr(ir_unop_b2i, r27ED);
                     ir_expression *const r27EF = expr(ir_unop_i2u, r27EE);
                     body.emit(assign(r27D8, bit_or(r27D8, r27EF), 0x01));


                  body.instructions = f27DD_parent_instructions;
                  body.emit(f27DD);

                  /* END IF */

                  body.emit(assign(r27B2, r27DA, 0x01));

                  body.emit(assign(r27B3, r27D9, 0x01));

                  body.emit(assign(r27B4, r27D8, 0x01));


               body.instructions = f27CC_parent_instructions;
               body.emit(f27CC);

               /* END IF */

               body.emit(assign(r27B1, sub(r27B1, r27B5), 0x01));

               ir_variable *const r27F0 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r27F0, r27B1, 0x01));

               ir_variable *const r27F1 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r27F1, r27B2, 0x01));

               ir_variable *const r27F2 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r27F2, r27B3, 0x01));

               ir_variable *const r27F3 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r27F3, r27B4, 0x01));

               ir_variable *const r27F4 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r27F4, body.constant(true), 0x01));

               ir_variable *const r27F5 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r27F6 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r27F6);
               ir_expression *const r27F7 = expr(ir_unop_u2i, r27B4);
               body.emit(assign(r27F6, less(r27F7, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r27F9 = lequal(body.constant(int(2045)), r27B1);
               ir_if *f27F8 = new(mem_ctx) ir_if(operand(r27F9).val);
               exec_list *const f27F8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27F8->then_instructions;

                  ir_variable *const r27FA = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r27FC = less(body.constant(int(2045)), r27B1);
                  ir_if *f27FB = new(mem_ctx) ir_if(operand(r27FC).val);
                  exec_list *const f27FB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27FB->then_instructions;

                     body.emit(assign(r27FA, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27FB->else_instructions;

                     ir_variable *const r27FD = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r27FF = equal(r27B1, body.constant(int(2045)));
                     ir_if *f27FE = new(mem_ctx) ir_if(operand(r27FF).val);
                     exec_list *const f27FE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f27FE->then_instructions;

                        ir_expression *const r2800 = equal(body.constant(2097151u), r27B2);
                        ir_expression *const r2801 = equal(body.constant(4294967295u), r27B3);
                        body.emit(assign(r27FD, logic_and(r2800, r2801), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f27FE->else_instructions;

                        body.emit(assign(r27FD, body.constant(false), 0x01));


                     body.instructions = f27FE_parent_instructions;
                     body.emit(f27FE);

                     /* END IF */

                     body.emit(assign(r27FA, logic_and(r27FD, r27F6), 0x01));


                  body.instructions = f27FB_parent_instructions;
                  body.emit(f27FB);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2802 = new(mem_ctx) ir_if(operand(r27FA).val);
                  exec_list *const f2802_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2802->then_instructions;

                     ir_variable *const r2803 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2803);
                     ir_expression *const r2804 = lshift(r276C, body.constant(int(31)));
                     body.emit(assign(r2803, add(r2804, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2803, body.constant(0u), 0x01));

                     body.emit(assign(r27F5, r2803, 0x03));

                     body.emit(assign(r27F4, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2802->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2806 = less(r27B1, body.constant(int(0)));
                     ir_if *f2805 = new(mem_ctx) ir_if(operand(r2806).val);
                     exec_list *const f2805_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2805->then_instructions;

                        ir_variable *const r2807 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2807, r27B4, 0x01));

                        ir_variable *const r2808 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2808, neg(r27B1), 0x01));

                        ir_variable *const r2809 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2809);
                        ir_variable *const r280A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r280A);
                        ir_variable *const r280B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r280B);
                        ir_variable *const r280C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r280D = neg(r2808);
                        body.emit(assign(r280C, bit_and(r280D, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r280F = equal(r2808, body.constant(int(0)));
                        ir_if *f280E = new(mem_ctx) ir_if(operand(r280F).val);
                        exec_list *const f280E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f280E->then_instructions;

                           body.emit(assign(r2809, r27B4, 0x01));

                           body.emit(assign(r280A, r27B3, 0x01));

                           body.emit(assign(r280B, r27B2, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f280E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2811 = less(r2808, body.constant(int(32)));
                           ir_if *f2810 = new(mem_ctx) ir_if(operand(r2811).val);
                           exec_list *const f2810_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2810->then_instructions;

                              body.emit(assign(r2809, lshift(r27B3, r280C), 0x01));

                              ir_expression *const r2812 = lshift(r27B2, r280C);
                              ir_expression *const r2813 = rshift(r27B3, r2808);
                              body.emit(assign(r280A, bit_or(r2812, r2813), 0x01));

                              body.emit(assign(r280B, rshift(r27B2, r2808), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2810->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2815 = equal(r2808, body.constant(int(32)));
                              ir_if *f2814 = new(mem_ctx) ir_if(operand(r2815).val);
                              exec_list *const f2814_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2814->then_instructions;

                                 body.emit(assign(r2809, r27B3, 0x01));

                                 body.emit(assign(r280A, r27B2, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2814->else_instructions;

                                 body.emit(assign(r2807, bit_or(r27B4, r27B3), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2817 = less(r2808, body.constant(int(64)));
                                 ir_if *f2816 = new(mem_ctx) ir_if(operand(r2817).val);
                                 exec_list *const f2816_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2816->then_instructions;

                                    body.emit(assign(r2809, lshift(r27B2, r280C), 0x01));

                                    ir_expression *const r2818 = bit_and(r2808, body.constant(int(31)));
                                    body.emit(assign(r280A, rshift(r27B2, r2818), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2816->else_instructions;

                                    ir_variable *const r2819 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r281B = equal(r2808, body.constant(int(64)));
                                    ir_if *f281A = new(mem_ctx) ir_if(operand(r281B).val);
                                    exec_list *const f281A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f281A->then_instructions;

                                       body.emit(assign(r2819, r27B2, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f281A->else_instructions;

                                       ir_expression *const r281C = nequal(r27B2, body.constant(0u));
                                       ir_expression *const r281D = expr(ir_unop_b2i, r281C);
                                       body.emit(assign(r2819, expr(ir_unop_i2u, r281D), 0x01));


                                    body.instructions = f281A_parent_instructions;
                                    body.emit(f281A);

                                    /* END IF */

                                    body.emit(assign(r2809, r2819, 0x01));

                                    body.emit(assign(r280A, body.constant(0u), 0x01));


                                 body.instructions = f2816_parent_instructions;
                                 body.emit(f2816);

                                 /* END IF */


                              body.instructions = f2814_parent_instructions;
                              body.emit(f2814);

                              /* END IF */

                              body.emit(assign(r280B, body.constant(0u), 0x01));


                           body.instructions = f2810_parent_instructions;
                           body.emit(f2810);

                           /* END IF */

                           ir_expression *const r281E = nequal(r2807, body.constant(0u));
                           ir_expression *const r281F = expr(ir_unop_b2i, r281E);
                           ir_expression *const r2820 = expr(ir_unop_i2u, r281F);
                           body.emit(assign(r2809, bit_or(r2809, r2820), 0x01));


                        body.instructions = f280E_parent_instructions;
                        body.emit(f280E);

                        /* END IF */

                        body.emit(assign(r27F1, r280B, 0x01));

                        body.emit(assign(r27F2, r280A, 0x01));

                        body.emit(assign(r27F3, r2809, 0x01));

                        body.emit(assign(r27F0, body.constant(int(0)), 0x01));

                        body.emit(assign(r27F6, less(r2809, body.constant(0u)), 0x01));


                     body.instructions = f2805_parent_instructions;
                     body.emit(f2805);

                     /* END IF */


                  body.instructions = f2802_parent_instructions;
                  body.emit(f2802);

                  /* END IF */


               body.instructions = f27F8_parent_instructions;
               body.emit(f27F8);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2821 = new(mem_ctx) ir_if(operand(r27F4).val);
               exec_list *const f2821_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2821->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2822 = new(mem_ctx) ir_if(operand(r27F6).val);
                  exec_list *const f2822_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2822->then_instructions;

                     ir_variable *const r2823 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2823, add(r27F2, body.constant(1u)), 0x01));

                     ir_expression *const r2824 = less(r2823, r27F2);
                     ir_expression *const r2825 = expr(ir_unop_b2i, r2824);
                     ir_expression *const r2826 = expr(ir_unop_i2u, r2825);
                     body.emit(assign(r27F1, add(r27F1, r2826), 0x01));

                     ir_expression *const r2827 = equal(r27F3, body.constant(0u));
                     ir_expression *const r2828 = expr(ir_unop_b2i, r2827);
                     ir_expression *const r2829 = expr(ir_unop_i2u, r2828);
                     ir_expression *const r282A = add(r27F3, r2829);
                     ir_expression *const r282B = bit_and(r282A, body.constant(1u));
                     ir_expression *const r282C = expr(ir_unop_bit_not, r282B);
                     body.emit(assign(r27F2, bit_and(r2823, r282C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2822->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r282E = bit_or(r27F1, r27F2);
                     ir_expression *const r282F = equal(r282E, body.constant(0u));
                     ir_if *f282D = new(mem_ctx) ir_if(operand(r282F).val);
                     exec_list *const f282D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f282D->then_instructions;

                        body.emit(assign(r27F0, body.constant(int(0)), 0x01));


                     body.instructions = f282D_parent_instructions;
                     body.emit(f282D);

                     /* END IF */


                  body.instructions = f2822_parent_instructions;
                  body.emit(f2822);

                  /* END IF */

                  ir_variable *const r2830 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2830);
                  ir_expression *const r2831 = lshift(r276C, body.constant(int(31)));
                  ir_expression *const r2832 = expr(ir_unop_i2u, r27F0);
                  ir_expression *const r2833 = lshift(r2832, body.constant(int(20)));
                  ir_expression *const r2834 = add(r2831, r2833);
                  body.emit(assign(r2830, add(r2834, r27F1), 0x02));

                  body.emit(assign(r2830, r27F2, 0x01));

                  body.emit(assign(r27F5, r2830, 0x03));

                  body.emit(assign(r27F4, body.constant(false), 0x01));


               body.instructions = f2821_parent_instructions;
               body.emit(f2821);

               /* END IF */

               body.emit(assign(r2770, r27F5, 0x03));


            body.instructions = f2786_parent_instructions;
            body.emit(f2786);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2784->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2836 = less(r2771, body.constant(int(0)));
            ir_if *f2835 = new(mem_ctx) ir_if(operand(r2836).val);
            exec_list *const f2835_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2835->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2838 = equal(r277A, body.constant(int(0)));
               ir_if *f2837 = new(mem_ctx) ir_if(operand(r2838).val);
               exec_list *const f2837_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2837->then_instructions;

                  body.emit(assign(r2771, add(r2771, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2837->else_instructions;

                  body.emit(assign(r2776, bit_or(r2776, body.constant(1073741824u)), 0x01));


               body.instructions = f2837_parent_instructions;
               body.emit(f2837);

               /* END IF */

               ir_variable *const r2839 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2839, neg(r2771), 0x01));

               ir_variable *const r283A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r283A);
               ir_variable *const r283B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r283B);
               ir_variable *const r283C = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r283D = neg(r2839);
               body.emit(assign(r283C, bit_and(r283D, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r283F = equal(r2839, body.constant(int(0)));
               ir_if *f283E = new(mem_ctx) ir_if(operand(r283F).val);
               exec_list *const f283E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f283E->then_instructions;

                  body.emit(assign(r283A, r277D, 0x01));

                  body.emit(assign(r283B, r2776, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f283E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2841 = less(r2839, body.constant(int(32)));
                  ir_if *f2840 = new(mem_ctx) ir_if(operand(r2841).val);
                  exec_list *const f2840_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2840->then_instructions;

                     ir_expression *const r2842 = lshift(r2776, r283C);
                     ir_expression *const r2843 = rshift(r277D, r2839);
                     ir_expression *const r2844 = bit_or(r2842, r2843);
                     ir_expression *const r2845 = lshift(r277D, r283C);
                     ir_expression *const r2846 = nequal(r2845, body.constant(0u));
                     ir_expression *const r2847 = expr(ir_unop_b2i, r2846);
                     ir_expression *const r2848 = expr(ir_unop_i2u, r2847);
                     body.emit(assign(r283A, bit_or(r2844, r2848), 0x01));

                     body.emit(assign(r283B, rshift(r2776, r2839), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2840->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r284A = equal(r2839, body.constant(int(32)));
                     ir_if *f2849 = new(mem_ctx) ir_if(operand(r284A).val);
                     exec_list *const f2849_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2849->then_instructions;

                        ir_expression *const r284B = nequal(r277D, body.constant(0u));
                        ir_expression *const r284C = expr(ir_unop_b2i, r284B);
                        ir_expression *const r284D = expr(ir_unop_i2u, r284C);
                        body.emit(assign(r283A, bit_or(r2776, r284D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2849->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r284F = less(r2839, body.constant(int(64)));
                        ir_if *f284E = new(mem_ctx) ir_if(operand(r284F).val);
                        exec_list *const f284E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f284E->then_instructions;

                           ir_expression *const r2850 = bit_and(r2839, body.constant(int(31)));
                           ir_expression *const r2851 = rshift(r2776, r2850);
                           ir_expression *const r2852 = lshift(r2776, r283C);
                           ir_expression *const r2853 = bit_or(r2852, r277D);
                           ir_expression *const r2854 = nequal(r2853, body.constant(0u));
                           ir_expression *const r2855 = expr(ir_unop_b2i, r2854);
                           ir_expression *const r2856 = expr(ir_unop_i2u, r2855);
                           body.emit(assign(r283A, bit_or(r2851, r2856), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f284E->else_instructions;

                           ir_expression *const r2857 = bit_or(r2776, r277D);
                           ir_expression *const r2858 = nequal(r2857, body.constant(0u));
                           ir_expression *const r2859 = expr(ir_unop_b2i, r2858);
                           body.emit(assign(r283A, expr(ir_unop_i2u, r2859), 0x01));


                        body.instructions = f284E_parent_instructions;
                        body.emit(f284E);

                        /* END IF */


                     body.instructions = f2849_parent_instructions;
                     body.emit(f2849);

                     /* END IF */

                     body.emit(assign(r283B, body.constant(0u), 0x01));


                  body.instructions = f2840_parent_instructions;
                  body.emit(f2840);

                  /* END IF */


               body.instructions = f283E_parent_instructions;
               body.emit(f283E);

               /* END IF */

               body.emit(assign(r2776, r283B, 0x01));

               body.emit(assign(r2777, r283A, 0x01));

               body.emit(assign(r2774, bit_or(r2774, body.constant(1073741824u)), 0x01));

               ir_variable *const r285A = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r285B = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r285B, sub(r2775, r283A), 0x01));

               ir_expression *const r285C = sub(r2774, r283B);
               ir_expression *const r285D = less(r2775, r283A);
               ir_expression *const r285E = expr(ir_unop_b2i, r285D);
               ir_expression *const r285F = expr(ir_unop_i2u, r285E);
               body.emit(assign(r285A, sub(r285C, r285F), 0x01));

               body.emit(assign(r276F, bit_xor(r276C, body.constant(1u)), 0x01));

               body.emit(assign(r2778, body.constant(int(1022)), 0x01));

               ir_variable *const r2860 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2860, body.constant(int(1012)), 0x01));

               ir_variable *const r2861 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2861, r285A, 0x01));

               ir_variable *const r2862 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2862, r285B, 0x01));

               ir_variable *const r2863 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2863);
               ir_variable *const r2864 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2864);
               /* IF CONDITION */
               ir_expression *const r2866 = equal(r285A, body.constant(0u));
               ir_if *f2865 = new(mem_ctx) ir_if(operand(r2866).val);
               exec_list *const f2865_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2865->then_instructions;

                  body.emit(assign(r2861, r285B, 0x01));

                  body.emit(assign(r2862, body.constant(0u), 0x01));

                  body.emit(assign(r2860, body.constant(int(980)), 0x01));


               body.instructions = f2865_parent_instructions;
               body.emit(f2865);

               /* END IF */

               ir_variable *const r2867 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2867, r2861, 0x01));

               ir_variable *const r2868 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r2869 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2869);
               /* IF CONDITION */
               ir_expression *const r286B = equal(r2861, body.constant(0u));
               ir_if *f286A = new(mem_ctx) ir_if(operand(r286B).val);
               exec_list *const f286A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f286A->then_instructions;

                  body.emit(assign(r2868, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f286A->else_instructions;

                  body.emit(assign(r2869, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r286D = bit_and(r2861, body.constant(4294901760u));
                  ir_expression *const r286E = equal(r286D, body.constant(0u));
                  ir_if *f286C = new(mem_ctx) ir_if(operand(r286E).val);
                  exec_list *const f286C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f286C->then_instructions;

                     body.emit(assign(r2869, body.constant(int(16)), 0x01));

                     body.emit(assign(r2867, lshift(r2861, body.constant(int(16))), 0x01));


                  body.instructions = f286C_parent_instructions;
                  body.emit(f286C);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2870 = bit_and(r2867, body.constant(4278190080u));
                  ir_expression *const r2871 = equal(r2870, body.constant(0u));
                  ir_if *f286F = new(mem_ctx) ir_if(operand(r2871).val);
                  exec_list *const f286F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f286F->then_instructions;

                     body.emit(assign(r2869, add(r2869, body.constant(int(8))), 0x01));

                     body.emit(assign(r2867, lshift(r2867, body.constant(int(8))), 0x01));


                  body.instructions = f286F_parent_instructions;
                  body.emit(f286F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2873 = bit_and(r2867, body.constant(4026531840u));
                  ir_expression *const r2874 = equal(r2873, body.constant(0u));
                  ir_if *f2872 = new(mem_ctx) ir_if(operand(r2874).val);
                  exec_list *const f2872_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2872->then_instructions;

                     body.emit(assign(r2869, add(r2869, body.constant(int(4))), 0x01));

                     body.emit(assign(r2867, lshift(r2867, body.constant(int(4))), 0x01));


                  body.instructions = f2872_parent_instructions;
                  body.emit(f2872);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2876 = bit_and(r2867, body.constant(3221225472u));
                  ir_expression *const r2877 = equal(r2876, body.constant(0u));
                  ir_if *f2875 = new(mem_ctx) ir_if(operand(r2877).val);
                  exec_list *const f2875_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2875->then_instructions;

                     body.emit(assign(r2869, add(r2869, body.constant(int(2))), 0x01));

                     body.emit(assign(r2867, lshift(r2867, body.constant(int(2))), 0x01));


                  body.instructions = f2875_parent_instructions;
                  body.emit(f2875);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2879 = bit_and(r2867, body.constant(2147483648u));
                  ir_expression *const r287A = equal(r2879, body.constant(0u));
                  ir_if *f2878 = new(mem_ctx) ir_if(operand(r287A).val);
                  exec_list *const f2878_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2878->then_instructions;

                     body.emit(assign(r2869, add(r2869, body.constant(int(1))), 0x01));


                  body.instructions = f2878_parent_instructions;
                  body.emit(f2878);

                  /* END IF */

                  body.emit(assign(r2868, r2869, 0x01));


               body.instructions = f286A_parent_instructions;
               body.emit(f286A);

               /* END IF */

               body.emit(assign(r2864, add(r2868, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r287C = lequal(body.constant(int(0)), r2864);
               ir_if *f287B = new(mem_ctx) ir_if(operand(r287C).val);
               exec_list *const f287B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f287B->then_instructions;

                  body.emit(assign(r2863, body.constant(0u), 0x01));

                  ir_variable *const r287D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r287D, lshift(r2862, r2864), 0x01));

                  ir_variable *const r287E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2880 = equal(r2864, body.constant(int(0)));
                  ir_if *f287F = new(mem_ctx) ir_if(operand(r2880).val);
                  exec_list *const f287F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f287F->then_instructions;

                     body.emit(assign(r287E, r2861, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f287F->else_instructions;

                     ir_expression *const r2881 = lshift(r2861, r2864);
                     ir_expression *const r2882 = neg(r2864);
                     ir_expression *const r2883 = bit_and(r2882, body.constant(int(31)));
                     ir_expression *const r2884 = rshift(r2862, r2883);
                     body.emit(assign(r287E, bit_or(r2881, r2884), 0x01));


                  body.instructions = f287F_parent_instructions;
                  body.emit(f287F);

                  /* END IF */

                  body.emit(assign(r2861, r287E, 0x01));

                  body.emit(assign(r2862, r287D, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f287B->else_instructions;

                  ir_variable *const r2885 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2885, body.constant(0u), 0x01));

                  ir_variable *const r2886 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2886, neg(r2864), 0x01));

                  ir_variable *const r2887 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2887);
                  ir_variable *const r2888 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2888);
                  ir_variable *const r2889 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2889);
                  ir_variable *const r288A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r288B = neg(r2886);
                  body.emit(assign(r288A, bit_and(r288B, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r288D = equal(r2886, body.constant(int(0)));
                  ir_if *f288C = new(mem_ctx) ir_if(operand(r288D).val);
                  exec_list *const f288C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f288C->then_instructions;

                     body.emit(assign(r2887, r2885, 0x01));

                     body.emit(assign(r2888, r2862, 0x01));

                     body.emit(assign(r2889, r2861, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f288C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r288F = less(r2886, body.constant(int(32)));
                     ir_if *f288E = new(mem_ctx) ir_if(operand(r288F).val);
                     exec_list *const f288E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f288E->then_instructions;

                        body.emit(assign(r2887, lshift(r2862, r288A), 0x01));

                        ir_expression *const r2890 = lshift(r2861, r288A);
                        ir_expression *const r2891 = rshift(r2862, r2886);
                        body.emit(assign(r2888, bit_or(r2890, r2891), 0x01));

                        body.emit(assign(r2889, rshift(r2861, r2886), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f288E->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2893 = equal(r2886, body.constant(int(32)));
                        ir_if *f2892 = new(mem_ctx) ir_if(operand(r2893).val);
                        exec_list *const f2892_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2892->then_instructions;

                           body.emit(assign(r2887, r2862, 0x01));

                           body.emit(assign(r2888, r2861, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2892->else_instructions;

                           body.emit(assign(r2885, bit_or(body.constant(0u), r2862), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2895 = less(r2886, body.constant(int(64)));
                           ir_if *f2894 = new(mem_ctx) ir_if(operand(r2895).val);
                           exec_list *const f2894_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2894->then_instructions;

                              body.emit(assign(r2887, lshift(r2861, r288A), 0x01));

                              ir_expression *const r2896 = bit_and(r2886, body.constant(int(31)));
                              body.emit(assign(r2888, rshift(r2861, r2896), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2894->else_instructions;

                              ir_variable *const r2897 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2899 = equal(r2886, body.constant(int(64)));
                              ir_if *f2898 = new(mem_ctx) ir_if(operand(r2899).val);
                              exec_list *const f2898_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2898->then_instructions;

                                 body.emit(assign(r2897, r2861, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2898->else_instructions;

                                 ir_expression *const r289A = nequal(r2861, body.constant(0u));
                                 ir_expression *const r289B = expr(ir_unop_b2i, r289A);
                                 body.emit(assign(r2897, expr(ir_unop_i2u, r289B), 0x01));


                              body.instructions = f2898_parent_instructions;
                              body.emit(f2898);

                              /* END IF */

                              body.emit(assign(r2887, r2897, 0x01));

                              body.emit(assign(r2888, body.constant(0u), 0x01));


                           body.instructions = f2894_parent_instructions;
                           body.emit(f2894);

                           /* END IF */


                        body.instructions = f2892_parent_instructions;
                        body.emit(f2892);

                        /* END IF */

                        body.emit(assign(r2889, body.constant(0u), 0x01));


                     body.instructions = f288E_parent_instructions;
                     body.emit(f288E);

                     /* END IF */

                     ir_expression *const r289C = nequal(r2885, body.constant(0u));
                     ir_expression *const r289D = expr(ir_unop_b2i, r289C);
                     ir_expression *const r289E = expr(ir_unop_i2u, r289D);
                     body.emit(assign(r2887, bit_or(r2887, r289E), 0x01));


                  body.instructions = f288C_parent_instructions;
                  body.emit(f288C);

                  /* END IF */

                  body.emit(assign(r2861, r2889, 0x01));

                  body.emit(assign(r2862, r2888, 0x01));

                  body.emit(assign(r2863, r2887, 0x01));


               body.instructions = f287B_parent_instructions;
               body.emit(f287B);

               /* END IF */

               body.emit(assign(r2860, sub(r2860, r2864), 0x01));

               ir_variable *const r289F = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r289F, r2860, 0x01));

               ir_variable *const r28A0 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r28A0, r2861, 0x01));

               ir_variable *const r28A1 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r28A1, r2862, 0x01));

               ir_variable *const r28A2 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r28A2, r2863, 0x01));

               ir_variable *const r28A3 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r28A3, body.constant(true), 0x01));

               ir_variable *const r28A4 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r28A5 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r28A5);
               ir_expression *const r28A6 = expr(ir_unop_u2i, r2863);
               body.emit(assign(r28A5, less(r28A6, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r28A8 = lequal(body.constant(int(2045)), r2860);
               ir_if *f28A7 = new(mem_ctx) ir_if(operand(r28A8).val);
               exec_list *const f28A7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f28A7->then_instructions;

                  ir_variable *const r28A9 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r28AB = less(body.constant(int(2045)), r2860);
                  ir_if *f28AA = new(mem_ctx) ir_if(operand(r28AB).val);
                  exec_list *const f28AA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28AA->then_instructions;

                     body.emit(assign(r28A9, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f28AA->else_instructions;

                     ir_variable *const r28AC = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r28AE = equal(r2860, body.constant(int(2045)));
                     ir_if *f28AD = new(mem_ctx) ir_if(operand(r28AE).val);
                     exec_list *const f28AD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28AD->then_instructions;

                        ir_expression *const r28AF = equal(body.constant(2097151u), r2861);
                        ir_expression *const r28B0 = equal(body.constant(4294967295u), r2862);
                        body.emit(assign(r28AC, logic_and(r28AF, r28B0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f28AD->else_instructions;

                        body.emit(assign(r28AC, body.constant(false), 0x01));


                     body.instructions = f28AD_parent_instructions;
                     body.emit(f28AD);

                     /* END IF */

                     body.emit(assign(r28A9, logic_and(r28AC, r28A5), 0x01));


                  body.instructions = f28AA_parent_instructions;
                  body.emit(f28AA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f28B1 = new(mem_ctx) ir_if(operand(r28A9).val);
                  exec_list *const f28B1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28B1->then_instructions;

                     ir_variable *const r28B2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r28B2);
                     ir_expression *const r28B3 = lshift(r276F, body.constant(int(31)));
                     body.emit(assign(r28B2, add(r28B3, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r28B2, body.constant(0u), 0x01));

                     body.emit(assign(r28A4, r28B2, 0x03));

                     body.emit(assign(r28A3, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f28B1->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r28B5 = less(r2860, body.constant(int(0)));
                     ir_if *f28B4 = new(mem_ctx) ir_if(operand(r28B5).val);
                     exec_list *const f28B4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28B4->then_instructions;

                        ir_variable *const r28B6 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r28B6, r2863, 0x01));

                        ir_variable *const r28B7 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r28B7, neg(r2860), 0x01));

                        ir_variable *const r28B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r28B8);
                        ir_variable *const r28B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r28B9);
                        ir_variable *const r28BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r28BA);
                        ir_variable *const r28BB = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r28BC = neg(r28B7);
                        body.emit(assign(r28BB, bit_and(r28BC, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r28BE = equal(r28B7, body.constant(int(0)));
                        ir_if *f28BD = new(mem_ctx) ir_if(operand(r28BE).val);
                        exec_list *const f28BD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28BD->then_instructions;

                           body.emit(assign(r28B8, r2863, 0x01));

                           body.emit(assign(r28B9, r2862, 0x01));

                           body.emit(assign(r28BA, r2861, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f28BD->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r28C0 = less(r28B7, body.constant(int(32)));
                           ir_if *f28BF = new(mem_ctx) ir_if(operand(r28C0).val);
                           exec_list *const f28BF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f28BF->then_instructions;

                              body.emit(assign(r28B8, lshift(r2862, r28BB), 0x01));

                              ir_expression *const r28C1 = lshift(r2861, r28BB);
                              ir_expression *const r28C2 = rshift(r2862, r28B7);
                              body.emit(assign(r28B9, bit_or(r28C1, r28C2), 0x01));

                              body.emit(assign(r28BA, rshift(r2861, r28B7), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f28BF->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r28C4 = equal(r28B7, body.constant(int(32)));
                              ir_if *f28C3 = new(mem_ctx) ir_if(operand(r28C4).val);
                              exec_list *const f28C3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f28C3->then_instructions;

                                 body.emit(assign(r28B8, r2862, 0x01));

                                 body.emit(assign(r28B9, r2861, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f28C3->else_instructions;

                                 body.emit(assign(r28B6, bit_or(r2863, r2862), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r28C6 = less(r28B7, body.constant(int(64)));
                                 ir_if *f28C5 = new(mem_ctx) ir_if(operand(r28C6).val);
                                 exec_list *const f28C5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f28C5->then_instructions;

                                    body.emit(assign(r28B8, lshift(r2861, r28BB), 0x01));

                                    ir_expression *const r28C7 = bit_and(r28B7, body.constant(int(31)));
                                    body.emit(assign(r28B9, rshift(r2861, r28C7), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f28C5->else_instructions;

                                    ir_variable *const r28C8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r28CA = equal(r28B7, body.constant(int(64)));
                                    ir_if *f28C9 = new(mem_ctx) ir_if(operand(r28CA).val);
                                    exec_list *const f28C9_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f28C9->then_instructions;

                                       body.emit(assign(r28C8, r2861, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f28C9->else_instructions;

                                       ir_expression *const r28CB = nequal(r2861, body.constant(0u));
                                       ir_expression *const r28CC = expr(ir_unop_b2i, r28CB);
                                       body.emit(assign(r28C8, expr(ir_unop_i2u, r28CC), 0x01));


                                    body.instructions = f28C9_parent_instructions;
                                    body.emit(f28C9);

                                    /* END IF */

                                    body.emit(assign(r28B8, r28C8, 0x01));

                                    body.emit(assign(r28B9, body.constant(0u), 0x01));


                                 body.instructions = f28C5_parent_instructions;
                                 body.emit(f28C5);

                                 /* END IF */


                              body.instructions = f28C3_parent_instructions;
                              body.emit(f28C3);

                              /* END IF */

                              body.emit(assign(r28BA, body.constant(0u), 0x01));


                           body.instructions = f28BF_parent_instructions;
                           body.emit(f28BF);

                           /* END IF */

                           ir_expression *const r28CD = nequal(r28B6, body.constant(0u));
                           ir_expression *const r28CE = expr(ir_unop_b2i, r28CD);
                           ir_expression *const r28CF = expr(ir_unop_i2u, r28CE);
                           body.emit(assign(r28B8, bit_or(r28B8, r28CF), 0x01));


                        body.instructions = f28BD_parent_instructions;
                        body.emit(f28BD);

                        /* END IF */

                        body.emit(assign(r28A0, r28BA, 0x01));

                        body.emit(assign(r28A1, r28B9, 0x01));

                        body.emit(assign(r28A2, r28B8, 0x01));

                        body.emit(assign(r289F, body.constant(int(0)), 0x01));

                        body.emit(assign(r28A5, less(r28B8, body.constant(0u)), 0x01));


                     body.instructions = f28B4_parent_instructions;
                     body.emit(f28B4);

                     /* END IF */


                  body.instructions = f28B1_parent_instructions;
                  body.emit(f28B1);

                  /* END IF */


               body.instructions = f28A7_parent_instructions;
               body.emit(f28A7);

               /* END IF */

               /* IF CONDITION */
               ir_if *f28D0 = new(mem_ctx) ir_if(operand(r28A3).val);
               exec_list *const f28D0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f28D0->then_instructions;

                  /* IF CONDITION */
                  ir_if *f28D1 = new(mem_ctx) ir_if(operand(r28A5).val);
                  exec_list *const f28D1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28D1->then_instructions;

                     ir_variable *const r28D2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r28D2, add(r28A1, body.constant(1u)), 0x01));

                     ir_expression *const r28D3 = less(r28D2, r28A1);
                     ir_expression *const r28D4 = expr(ir_unop_b2i, r28D3);
                     ir_expression *const r28D5 = expr(ir_unop_i2u, r28D4);
                     body.emit(assign(r28A0, add(r28A0, r28D5), 0x01));

                     ir_expression *const r28D6 = equal(r28A2, body.constant(0u));
                     ir_expression *const r28D7 = expr(ir_unop_b2i, r28D6);
                     ir_expression *const r28D8 = expr(ir_unop_i2u, r28D7);
                     ir_expression *const r28D9 = add(r28A2, r28D8);
                     ir_expression *const r28DA = bit_and(r28D9, body.constant(1u));
                     ir_expression *const r28DB = expr(ir_unop_bit_not, r28DA);
                     body.emit(assign(r28A1, bit_and(r28D2, r28DB), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f28D1->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r28DD = bit_or(r28A0, r28A1);
                     ir_expression *const r28DE = equal(r28DD, body.constant(0u));
                     ir_if *f28DC = new(mem_ctx) ir_if(operand(r28DE).val);
                     exec_list *const f28DC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28DC->then_instructions;

                        body.emit(assign(r289F, body.constant(int(0)), 0x01));


                     body.instructions = f28DC_parent_instructions;
                     body.emit(f28DC);

                     /* END IF */


                  body.instructions = f28D1_parent_instructions;
                  body.emit(f28D1);

                  /* END IF */

                  ir_variable *const r28DF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r28DF);
                  ir_expression *const r28E0 = lshift(r276F, body.constant(int(31)));
                  ir_expression *const r28E1 = expr(ir_unop_i2u, r289F);
                  ir_expression *const r28E2 = lshift(r28E1, body.constant(int(20)));
                  ir_expression *const r28E3 = add(r28E0, r28E2);
                  body.emit(assign(r28DF, add(r28E3, r28A0), 0x02));

                  body.emit(assign(r28DF, r28A1, 0x01));

                  body.emit(assign(r28A4, r28DF, 0x03));

                  body.emit(assign(r28A3, body.constant(false), 0x01));


               body.instructions = f28D0_parent_instructions;
               body.emit(f28D0);

               /* END IF */

               body.emit(assign(r2770, r28A4, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2835->else_instructions;

               /* IF CONDITION */
               ir_expression *const r28E5 = equal(r277A, body.constant(int(2047)));
               ir_if *f28E4 = new(mem_ctx) ir_if(operand(r28E5).val);
               exec_list *const f28E4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f28E4->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r28E7 = bit_or(r2776, r2777);
                  ir_expression *const r28E8 = bit_or(r2774, r2775);
                  ir_expression *const r28E9 = bit_or(r28E7, r28E8);
                  ir_expression *const r28EA = nequal(r28E9, body.constant(0u));
                  ir_if *f28E6 = new(mem_ctx) ir_if(operand(r28EA).val);
                  exec_list *const f28E6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28E6->then_instructions;

                     ir_variable *const r28EB = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r28EB, swizzle_x(r2736), 0x01));

                     ir_variable *const r28EC = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r28EC, body.constant(0u), 0x01));

                     ir_variable *const r28ED = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r28EB, bit_or(swizzle_y(r2736), body.constant(524288u)), 0x02));

                     body.emit(assign(r28EC, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r28EF = lshift(swizzle_y(r2736), body.constant(int(1)));
                     ir_expression *const r28F0 = lequal(body.constant(4292870144u), r28EF);
                     ir_expression *const r28F1 = nequal(swizzle_x(r2736), body.constant(0u));
                     ir_expression *const r28F2 = bit_and(swizzle_y(r2736), body.constant(1048575u));
                     ir_expression *const r28F3 = nequal(r28F2, body.constant(0u));
                     ir_expression *const r28F4 = logic_or(r28F1, r28F3);
                     ir_expression *const r28F5 = logic_and(r28F0, r28F4);
                     ir_if *f28EE = new(mem_ctx) ir_if(operand(r28F5).val);
                     exec_list *const f28EE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28EE->then_instructions;

                        body.emit(assign(r28ED, r28EB, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f28EE->else_instructions;

                        body.emit(assign(r28ED, r28EC, 0x03));


                     body.instructions = f28EE_parent_instructions;
                     body.emit(f28EE);

                     /* END IF */

                     body.emit(assign(r2770, r28ED, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f28E6->else_instructions;

                     ir_constant_data r28F6_data;
                     memset(&r28F6_data, 0, sizeof(ir_constant_data));
                     r28F6_data.u[0] = 4294967295;
                     r28F6_data.u[1] = 4294967295;
                     ir_constant *const r28F6 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r28F6_data);
                     body.emit(assign(r2770, r28F6, 0x03));


                  body.instructions = f28E6_parent_instructions;
                  body.emit(f28E6);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f28E4->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r28F8 = equal(r277A, body.constant(int(0)));
                  ir_if *f28F7 = new(mem_ctx) ir_if(operand(r28F8).val);
                  exec_list *const f28F7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28F7->then_instructions;

                     body.emit(assign(r2773, body.constant(int(1)), 0x01));

                     body.emit(assign(r2772, body.constant(int(1)), 0x01));


                  body.instructions = f28F7_parent_instructions;
                  body.emit(f28F7);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r28FA = less(r2774, r2776);
                  ir_if *f28F9 = new(mem_ctx) ir_if(operand(r28FA).val);
                  exec_list *const f28F9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28F9->then_instructions;

                     ir_variable *const r28FB = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r28FC = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r28FC, sub(r2777, r2775), 0x01));

                     ir_expression *const r28FD = sub(r2776, r2774);
                     ir_expression *const r28FE = less(r2777, r2775);
                     ir_expression *const r28FF = expr(ir_unop_b2i, r28FE);
                     ir_expression *const r2900 = expr(ir_unop_i2u, r28FF);
                     body.emit(assign(r28FB, sub(r28FD, r2900), 0x01));

                     body.emit(assign(r2778, add(r2773, body.constant(int(-1))), 0x01));

                     ir_variable *const r2901 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2901, add(r2778, body.constant(int(-10))), 0x01));

                     ir_variable *const r2902 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2902, r28FB, 0x01));

                     ir_variable *const r2903 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2903, r28FC, 0x01));

                     ir_variable *const r2904 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r2904);
                     ir_variable *const r2905 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2905);
                     /* IF CONDITION */
                     ir_expression *const r2907 = equal(r28FB, body.constant(0u));
                     ir_if *f2906 = new(mem_ctx) ir_if(operand(r2907).val);
                     exec_list *const f2906_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2906->then_instructions;

                        body.emit(assign(r2902, r28FC, 0x01));

                        body.emit(assign(r2903, body.constant(0u), 0x01));

                        body.emit(assign(r2901, add(r2901, body.constant(int(-32))), 0x01));


                     body.instructions = f2906_parent_instructions;
                     body.emit(f2906);

                     /* END IF */

                     ir_variable *const r2908 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r2908, r2902, 0x01));

                     ir_variable *const r2909 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r290A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r290A);
                     /* IF CONDITION */
                     ir_expression *const r290C = equal(r2902, body.constant(0u));
                     ir_if *f290B = new(mem_ctx) ir_if(operand(r290C).val);
                     exec_list *const f290B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f290B->then_instructions;

                        body.emit(assign(r2909, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f290B->else_instructions;

                        body.emit(assign(r290A, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r290E = bit_and(r2902, body.constant(4294901760u));
                        ir_expression *const r290F = equal(r290E, body.constant(0u));
                        ir_if *f290D = new(mem_ctx) ir_if(operand(r290F).val);
                        exec_list *const f290D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f290D->then_instructions;

                           body.emit(assign(r290A, body.constant(int(16)), 0x01));

                           body.emit(assign(r2908, lshift(r2902, body.constant(int(16))), 0x01));


                        body.instructions = f290D_parent_instructions;
                        body.emit(f290D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2911 = bit_and(r2908, body.constant(4278190080u));
                        ir_expression *const r2912 = equal(r2911, body.constant(0u));
                        ir_if *f2910 = new(mem_ctx) ir_if(operand(r2912).val);
                        exec_list *const f2910_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2910->then_instructions;

                           body.emit(assign(r290A, add(r290A, body.constant(int(8))), 0x01));

                           body.emit(assign(r2908, lshift(r2908, body.constant(int(8))), 0x01));


                        body.instructions = f2910_parent_instructions;
                        body.emit(f2910);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2914 = bit_and(r2908, body.constant(4026531840u));
                        ir_expression *const r2915 = equal(r2914, body.constant(0u));
                        ir_if *f2913 = new(mem_ctx) ir_if(operand(r2915).val);
                        exec_list *const f2913_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2913->then_instructions;

                           body.emit(assign(r290A, add(r290A, body.constant(int(4))), 0x01));

                           body.emit(assign(r2908, lshift(r2908, body.constant(int(4))), 0x01));


                        body.instructions = f2913_parent_instructions;
                        body.emit(f2913);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2917 = bit_and(r2908, body.constant(3221225472u));
                        ir_expression *const r2918 = equal(r2917, body.constant(0u));
                        ir_if *f2916 = new(mem_ctx) ir_if(operand(r2918).val);
                        exec_list *const f2916_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2916->then_instructions;

                           body.emit(assign(r290A, add(r290A, body.constant(int(2))), 0x01));

                           body.emit(assign(r2908, lshift(r2908, body.constant(int(2))), 0x01));


                        body.instructions = f2916_parent_instructions;
                        body.emit(f2916);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r291A = bit_and(r2908, body.constant(2147483648u));
                        ir_expression *const r291B = equal(r291A, body.constant(0u));
                        ir_if *f2919 = new(mem_ctx) ir_if(operand(r291B).val);
                        exec_list *const f2919_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2919->then_instructions;

                           body.emit(assign(r290A, add(r290A, body.constant(int(1))), 0x01));


                        body.instructions = f2919_parent_instructions;
                        body.emit(f2919);

                        /* END IF */

                        body.emit(assign(r2909, r290A, 0x01));


                     body.instructions = f290B_parent_instructions;
                     body.emit(f290B);

                     /* END IF */

                     body.emit(assign(r2905, add(r2909, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r291D = lequal(body.constant(int(0)), r2905);
                     ir_if *f291C = new(mem_ctx) ir_if(operand(r291D).val);
                     exec_list *const f291C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f291C->then_instructions;

                        body.emit(assign(r2904, body.constant(0u), 0x01));

                        ir_variable *const r291E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r291E, lshift(r2903, r2905), 0x01));

                        ir_variable *const r291F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2921 = equal(r2905, body.constant(int(0)));
                        ir_if *f2920 = new(mem_ctx) ir_if(operand(r2921).val);
                        exec_list *const f2920_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2920->then_instructions;

                           body.emit(assign(r291F, r2902, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2920->else_instructions;

                           ir_expression *const r2922 = lshift(r2902, r2905);
                           ir_expression *const r2923 = neg(r2905);
                           ir_expression *const r2924 = bit_and(r2923, body.constant(int(31)));
                           ir_expression *const r2925 = rshift(r2903, r2924);
                           body.emit(assign(r291F, bit_or(r2922, r2925), 0x01));


                        body.instructions = f2920_parent_instructions;
                        body.emit(f2920);

                        /* END IF */

                        body.emit(assign(r2902, r291F, 0x01));

                        body.emit(assign(r2903, r291E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f291C->else_instructions;

                        ir_variable *const r2926 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2926, body.constant(0u), 0x01));

                        ir_variable *const r2927 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2927, neg(r2905), 0x01));

                        ir_variable *const r2928 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2928);
                        ir_variable *const r2929 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2929);
                        ir_variable *const r292A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r292A);
                        ir_variable *const r292B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r292C = neg(r2927);
                        body.emit(assign(r292B, bit_and(r292C, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r292E = equal(r2927, body.constant(int(0)));
                        ir_if *f292D = new(mem_ctx) ir_if(operand(r292E).val);
                        exec_list *const f292D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f292D->then_instructions;

                           body.emit(assign(r2928, r2926, 0x01));

                           body.emit(assign(r2929, r2903, 0x01));

                           body.emit(assign(r292A, r2902, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f292D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2930 = less(r2927, body.constant(int(32)));
                           ir_if *f292F = new(mem_ctx) ir_if(operand(r2930).val);
                           exec_list *const f292F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f292F->then_instructions;

                              body.emit(assign(r2928, lshift(r2903, r292B), 0x01));

                              ir_expression *const r2931 = lshift(r2902, r292B);
                              ir_expression *const r2932 = rshift(r2903, r2927);
                              body.emit(assign(r2929, bit_or(r2931, r2932), 0x01));

                              body.emit(assign(r292A, rshift(r2902, r2927), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f292F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2934 = equal(r2927, body.constant(int(32)));
                              ir_if *f2933 = new(mem_ctx) ir_if(operand(r2934).val);
                              exec_list *const f2933_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2933->then_instructions;

                                 body.emit(assign(r2928, r2903, 0x01));

                                 body.emit(assign(r2929, r2902, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2933->else_instructions;

                                 body.emit(assign(r2926, bit_or(body.constant(0u), r2903), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2936 = less(r2927, body.constant(int(64)));
                                 ir_if *f2935 = new(mem_ctx) ir_if(operand(r2936).val);
                                 exec_list *const f2935_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2935->then_instructions;

                                    body.emit(assign(r2928, lshift(r2902, r292B), 0x01));

                                    ir_expression *const r2937 = bit_and(r2927, body.constant(int(31)));
                                    body.emit(assign(r2929, rshift(r2902, r2937), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2935->else_instructions;

                                    ir_variable *const r2938 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r293A = equal(r2927, body.constant(int(64)));
                                    ir_if *f2939 = new(mem_ctx) ir_if(operand(r293A).val);
                                    exec_list *const f2939_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2939->then_instructions;

                                       body.emit(assign(r2938, r2902, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2939->else_instructions;

                                       ir_expression *const r293B = nequal(r2902, body.constant(0u));
                                       ir_expression *const r293C = expr(ir_unop_b2i, r293B);
                                       body.emit(assign(r2938, expr(ir_unop_i2u, r293C), 0x01));


                                    body.instructions = f2939_parent_instructions;
                                    body.emit(f2939);

                                    /* END IF */

                                    body.emit(assign(r2928, r2938, 0x01));

                                    body.emit(assign(r2929, body.constant(0u), 0x01));


                                 body.instructions = f2935_parent_instructions;
                                 body.emit(f2935);

                                 /* END IF */


                              body.instructions = f2933_parent_instructions;
                              body.emit(f2933);

                              /* END IF */

                              body.emit(assign(r292A, body.constant(0u), 0x01));


                           body.instructions = f292F_parent_instructions;
                           body.emit(f292F);

                           /* END IF */

                           ir_expression *const r293D = nequal(r2926, body.constant(0u));
                           ir_expression *const r293E = expr(ir_unop_b2i, r293D);
                           ir_expression *const r293F = expr(ir_unop_i2u, r293E);
                           body.emit(assign(r2928, bit_or(r2928, r293F), 0x01));


                        body.instructions = f292D_parent_instructions;
                        body.emit(f292D);

                        /* END IF */

                        body.emit(assign(r2902, r292A, 0x01));

                        body.emit(assign(r2903, r2929, 0x01));

                        body.emit(assign(r2904, r2928, 0x01));


                     body.instructions = f291C_parent_instructions;
                     body.emit(f291C);

                     /* END IF */

                     body.emit(assign(r2901, sub(r2901, r2905), 0x01));

                     ir_variable *const r2940 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2940, r2901, 0x01));

                     ir_variable *const r2941 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2941, r2902, 0x01));

                     ir_variable *const r2942 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2942, r2903, 0x01));

                     ir_variable *const r2943 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2943, r2904, 0x01));

                     ir_variable *const r2944 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2944, body.constant(true), 0x01));

                     ir_variable *const r2945 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2946 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2946);
                     ir_expression *const r2947 = expr(ir_unop_u2i, r2904);
                     body.emit(assign(r2946, less(r2947, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2949 = lequal(body.constant(int(2045)), r2901);
                     ir_if *f2948 = new(mem_ctx) ir_if(operand(r2949).val);
                     exec_list *const f2948_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2948->then_instructions;

                        ir_variable *const r294A = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r294C = less(body.constant(int(2045)), r2901);
                        ir_if *f294B = new(mem_ctx) ir_if(operand(r294C).val);
                        exec_list *const f294B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f294B->then_instructions;

                           body.emit(assign(r294A, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f294B->else_instructions;

                           ir_variable *const r294D = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r294F = equal(r2901, body.constant(int(2045)));
                           ir_if *f294E = new(mem_ctx) ir_if(operand(r294F).val);
                           exec_list *const f294E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f294E->then_instructions;

                              ir_expression *const r2950 = equal(body.constant(2097151u), r2902);
                              ir_expression *const r2951 = equal(body.constant(4294967295u), r2903);
                              body.emit(assign(r294D, logic_and(r2950, r2951), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f294E->else_instructions;

                              body.emit(assign(r294D, body.constant(false), 0x01));


                           body.instructions = f294E_parent_instructions;
                           body.emit(f294E);

                           /* END IF */

                           body.emit(assign(r294A, logic_and(r294D, r2946), 0x01));


                        body.instructions = f294B_parent_instructions;
                        body.emit(f294B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2952 = new(mem_ctx) ir_if(operand(r294A).val);
                        exec_list *const f2952_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2952->then_instructions;

                           ir_variable *const r2953 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2953);
                           ir_expression *const r2954 = lshift(r276F, body.constant(int(31)));
                           body.emit(assign(r2953, add(r2954, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2953, body.constant(0u), 0x01));

                           body.emit(assign(r2945, r2953, 0x03));

                           body.emit(assign(r2944, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2952->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2956 = less(r2901, body.constant(int(0)));
                           ir_if *f2955 = new(mem_ctx) ir_if(operand(r2956).val);
                           exec_list *const f2955_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2955->then_instructions;

                              ir_variable *const r2957 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2957, r2904, 0x01));

                              ir_variable *const r2958 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2958, neg(r2901), 0x01));

                              ir_variable *const r2959 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2959);
                              ir_variable *const r295A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r295A);
                              ir_variable *const r295B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r295B);
                              ir_variable *const r295C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r295D = neg(r2958);
                              body.emit(assign(r295C, bit_and(r295D, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r295F = equal(r2958, body.constant(int(0)));
                              ir_if *f295E = new(mem_ctx) ir_if(operand(r295F).val);
                              exec_list *const f295E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f295E->then_instructions;

                                 body.emit(assign(r2959, r2904, 0x01));

                                 body.emit(assign(r295A, r2903, 0x01));

                                 body.emit(assign(r295B, r2902, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f295E->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2961 = less(r2958, body.constant(int(32)));
                                 ir_if *f2960 = new(mem_ctx) ir_if(operand(r2961).val);
                                 exec_list *const f2960_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2960->then_instructions;

                                    body.emit(assign(r2959, lshift(r2903, r295C), 0x01));

                                    ir_expression *const r2962 = lshift(r2902, r295C);
                                    ir_expression *const r2963 = rshift(r2903, r2958);
                                    body.emit(assign(r295A, bit_or(r2962, r2963), 0x01));

                                    body.emit(assign(r295B, rshift(r2902, r2958), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2960->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2965 = equal(r2958, body.constant(int(32)));
                                    ir_if *f2964 = new(mem_ctx) ir_if(operand(r2965).val);
                                    exec_list *const f2964_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2964->then_instructions;

                                       body.emit(assign(r2959, r2903, 0x01));

                                       body.emit(assign(r295A, r2902, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2964->else_instructions;

                                       body.emit(assign(r2957, bit_or(r2904, r2903), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2967 = less(r2958, body.constant(int(64)));
                                       ir_if *f2966 = new(mem_ctx) ir_if(operand(r2967).val);
                                       exec_list *const f2966_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2966->then_instructions;

                                          body.emit(assign(r2959, lshift(r2902, r295C), 0x01));

                                          ir_expression *const r2968 = bit_and(r2958, body.constant(int(31)));
                                          body.emit(assign(r295A, rshift(r2902, r2968), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2966->else_instructions;

                                          ir_variable *const r2969 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r296B = equal(r2958, body.constant(int(64)));
                                          ir_if *f296A = new(mem_ctx) ir_if(operand(r296B).val);
                                          exec_list *const f296A_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f296A->then_instructions;

                                             body.emit(assign(r2969, r2902, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f296A->else_instructions;

                                             ir_expression *const r296C = nequal(r2902, body.constant(0u));
                                             ir_expression *const r296D = expr(ir_unop_b2i, r296C);
                                             body.emit(assign(r2969, expr(ir_unop_i2u, r296D), 0x01));


                                          body.instructions = f296A_parent_instructions;
                                          body.emit(f296A);

                                          /* END IF */

                                          body.emit(assign(r2959, r2969, 0x01));

                                          body.emit(assign(r295A, body.constant(0u), 0x01));


                                       body.instructions = f2966_parent_instructions;
                                       body.emit(f2966);

                                       /* END IF */


                                    body.instructions = f2964_parent_instructions;
                                    body.emit(f2964);

                                    /* END IF */

                                    body.emit(assign(r295B, body.constant(0u), 0x01));


                                 body.instructions = f2960_parent_instructions;
                                 body.emit(f2960);

                                 /* END IF */

                                 ir_expression *const r296E = nequal(r2957, body.constant(0u));
                                 ir_expression *const r296F = expr(ir_unop_b2i, r296E);
                                 ir_expression *const r2970 = expr(ir_unop_i2u, r296F);
                                 body.emit(assign(r2959, bit_or(r2959, r2970), 0x01));


                              body.instructions = f295E_parent_instructions;
                              body.emit(f295E);

                              /* END IF */

                              body.emit(assign(r2941, r295B, 0x01));

                              body.emit(assign(r2942, r295A, 0x01));

                              body.emit(assign(r2943, r2959, 0x01));

                              body.emit(assign(r2940, body.constant(int(0)), 0x01));

                              body.emit(assign(r2946, less(r2959, body.constant(0u)), 0x01));


                           body.instructions = f2955_parent_instructions;
                           body.emit(f2955);

                           /* END IF */


                        body.instructions = f2952_parent_instructions;
                        body.emit(f2952);

                        /* END IF */


                     body.instructions = f2948_parent_instructions;
                     body.emit(f2948);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2971 = new(mem_ctx) ir_if(operand(r2944).val);
                     exec_list *const f2971_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2971->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2972 = new(mem_ctx) ir_if(operand(r2946).val);
                        exec_list *const f2972_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2972->then_instructions;

                           ir_variable *const r2973 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2973, add(r2942, body.constant(1u)), 0x01));

                           ir_expression *const r2974 = less(r2973, r2942);
                           ir_expression *const r2975 = expr(ir_unop_b2i, r2974);
                           ir_expression *const r2976 = expr(ir_unop_i2u, r2975);
                           body.emit(assign(r2941, add(r2941, r2976), 0x01));

                           ir_expression *const r2977 = equal(r2943, body.constant(0u));
                           ir_expression *const r2978 = expr(ir_unop_b2i, r2977);
                           ir_expression *const r2979 = expr(ir_unop_i2u, r2978);
                           ir_expression *const r297A = add(r2943, r2979);
                           ir_expression *const r297B = bit_and(r297A, body.constant(1u));
                           ir_expression *const r297C = expr(ir_unop_bit_not, r297B);
                           body.emit(assign(r2942, bit_and(r2973, r297C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2972->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r297E = bit_or(r2941, r2942);
                           ir_expression *const r297F = equal(r297E, body.constant(0u));
                           ir_if *f297D = new(mem_ctx) ir_if(operand(r297F).val);
                           exec_list *const f297D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f297D->then_instructions;

                              body.emit(assign(r2940, body.constant(int(0)), 0x01));


                           body.instructions = f297D_parent_instructions;
                           body.emit(f297D);

                           /* END IF */


                        body.instructions = f2972_parent_instructions;
                        body.emit(f2972);

                        /* END IF */

                        ir_variable *const r2980 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2980);
                        ir_expression *const r2981 = lshift(r276F, body.constant(int(31)));
                        ir_expression *const r2982 = expr(ir_unop_i2u, r2940);
                        ir_expression *const r2983 = lshift(r2982, body.constant(int(20)));
                        ir_expression *const r2984 = add(r2981, r2983);
                        body.emit(assign(r2980, add(r2984, r2941), 0x02));

                        body.emit(assign(r2980, r2942, 0x01));

                        body.emit(assign(r2945, r2980, 0x03));

                        body.emit(assign(r2944, body.constant(false), 0x01));


                     body.instructions = f2971_parent_instructions;
                     body.emit(f2971);

                     /* END IF */

                     body.emit(assign(r2770, r2945, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f28F9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2986 = less(r2776, r2774);
                     ir_if *f2985 = new(mem_ctx) ir_if(operand(r2986).val);
                     exec_list *const f2985_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2985->then_instructions;

                        ir_variable *const r2987 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r2988 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2988, sub(r2775, r2777), 0x01));

                        ir_expression *const r2989 = sub(r2774, r2776);
                        ir_expression *const r298A = less(r2775, r2777);
                        ir_expression *const r298B = expr(ir_unop_b2i, r298A);
                        ir_expression *const r298C = expr(ir_unop_i2u, r298B);
                        body.emit(assign(r2987, sub(r2989, r298C), 0x01));

                        body.emit(assign(r276F, bit_xor(r276F, body.constant(1u)), 0x01));

                        body.emit(assign(r2778, add(r2772, body.constant(int(-1))), 0x01));

                        ir_variable *const r298D = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r298D, add(r2778, body.constant(int(-10))), 0x01));

                        ir_variable *const r298E = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r298E, r2987, 0x01));

                        ir_variable *const r298F = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r298F, r2988, 0x01));

                        ir_variable *const r2990 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r2990);
                        ir_variable *const r2991 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2991);
                        /* IF CONDITION */
                        ir_expression *const r2993 = equal(r2987, body.constant(0u));
                        ir_if *f2992 = new(mem_ctx) ir_if(operand(r2993).val);
                        exec_list *const f2992_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2992->then_instructions;

                           body.emit(assign(r298E, r2988, 0x01));

                           body.emit(assign(r298F, body.constant(0u), 0x01));

                           body.emit(assign(r298D, add(r298D, body.constant(int(-32))), 0x01));


                        body.instructions = f2992_parent_instructions;
                        body.emit(f2992);

                        /* END IF */

                        ir_variable *const r2994 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r2994, r298E, 0x01));

                        ir_variable *const r2995 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r2996 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2996);
                        /* IF CONDITION */
                        ir_expression *const r2998 = equal(r298E, body.constant(0u));
                        ir_if *f2997 = new(mem_ctx) ir_if(operand(r2998).val);
                        exec_list *const f2997_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2997->then_instructions;

                           body.emit(assign(r2995, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2997->else_instructions;

                           body.emit(assign(r2996, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r299A = bit_and(r298E, body.constant(4294901760u));
                           ir_expression *const r299B = equal(r299A, body.constant(0u));
                           ir_if *f2999 = new(mem_ctx) ir_if(operand(r299B).val);
                           exec_list *const f2999_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2999->then_instructions;

                              body.emit(assign(r2996, body.constant(int(16)), 0x01));

                              body.emit(assign(r2994, lshift(r298E, body.constant(int(16))), 0x01));


                           body.instructions = f2999_parent_instructions;
                           body.emit(f2999);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r299D = bit_and(r2994, body.constant(4278190080u));
                           ir_expression *const r299E = equal(r299D, body.constant(0u));
                           ir_if *f299C = new(mem_ctx) ir_if(operand(r299E).val);
                           exec_list *const f299C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f299C->then_instructions;

                              body.emit(assign(r2996, add(r2996, body.constant(int(8))), 0x01));

                              body.emit(assign(r2994, lshift(r2994, body.constant(int(8))), 0x01));


                           body.instructions = f299C_parent_instructions;
                           body.emit(f299C);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r29A0 = bit_and(r2994, body.constant(4026531840u));
                           ir_expression *const r29A1 = equal(r29A0, body.constant(0u));
                           ir_if *f299F = new(mem_ctx) ir_if(operand(r29A1).val);
                           exec_list *const f299F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f299F->then_instructions;

                              body.emit(assign(r2996, add(r2996, body.constant(int(4))), 0x01));

                              body.emit(assign(r2994, lshift(r2994, body.constant(int(4))), 0x01));


                           body.instructions = f299F_parent_instructions;
                           body.emit(f299F);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r29A3 = bit_and(r2994, body.constant(3221225472u));
                           ir_expression *const r29A4 = equal(r29A3, body.constant(0u));
                           ir_if *f29A2 = new(mem_ctx) ir_if(operand(r29A4).val);
                           exec_list *const f29A2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29A2->then_instructions;

                              body.emit(assign(r2996, add(r2996, body.constant(int(2))), 0x01));

                              body.emit(assign(r2994, lshift(r2994, body.constant(int(2))), 0x01));


                           body.instructions = f29A2_parent_instructions;
                           body.emit(f29A2);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r29A6 = bit_and(r2994, body.constant(2147483648u));
                           ir_expression *const r29A7 = equal(r29A6, body.constant(0u));
                           ir_if *f29A5 = new(mem_ctx) ir_if(operand(r29A7).val);
                           exec_list *const f29A5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29A5->then_instructions;

                              body.emit(assign(r2996, add(r2996, body.constant(int(1))), 0x01));


                           body.instructions = f29A5_parent_instructions;
                           body.emit(f29A5);

                           /* END IF */

                           body.emit(assign(r2995, r2996, 0x01));


                        body.instructions = f2997_parent_instructions;
                        body.emit(f2997);

                        /* END IF */

                        body.emit(assign(r2991, add(r2995, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r29A9 = lequal(body.constant(int(0)), r2991);
                        ir_if *f29A8 = new(mem_ctx) ir_if(operand(r29A9).val);
                        exec_list *const f29A8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f29A8->then_instructions;

                           body.emit(assign(r2990, body.constant(0u), 0x01));

                           ir_variable *const r29AA = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r29AA, lshift(r298F, r2991), 0x01));

                           ir_variable *const r29AB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r29AD = equal(r2991, body.constant(int(0)));
                           ir_if *f29AC = new(mem_ctx) ir_if(operand(r29AD).val);
                           exec_list *const f29AC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29AC->then_instructions;

                              body.emit(assign(r29AB, r298E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29AC->else_instructions;

                              ir_expression *const r29AE = lshift(r298E, r2991);
                              ir_expression *const r29AF = neg(r2991);
                              ir_expression *const r29B0 = bit_and(r29AF, body.constant(int(31)));
                              ir_expression *const r29B1 = rshift(r298F, r29B0);
                              body.emit(assign(r29AB, bit_or(r29AE, r29B1), 0x01));


                           body.instructions = f29AC_parent_instructions;
                           body.emit(f29AC);

                           /* END IF */

                           body.emit(assign(r298E, r29AB, 0x01));

                           body.emit(assign(r298F, r29AA, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f29A8->else_instructions;

                           ir_variable *const r29B2 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r29B2, body.constant(0u), 0x01));

                           ir_variable *const r29B3 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r29B3, neg(r2991), 0x01));

                           ir_variable *const r29B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r29B4);
                           ir_variable *const r29B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r29B5);
                           ir_variable *const r29B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r29B6);
                           ir_variable *const r29B7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r29B8 = neg(r29B3);
                           body.emit(assign(r29B7, bit_and(r29B8, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r29BA = equal(r29B3, body.constant(int(0)));
                           ir_if *f29B9 = new(mem_ctx) ir_if(operand(r29BA).val);
                           exec_list *const f29B9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29B9->then_instructions;

                              body.emit(assign(r29B4, r29B2, 0x01));

                              body.emit(assign(r29B5, r298F, 0x01));

                              body.emit(assign(r29B6, r298E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29B9->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r29BC = less(r29B3, body.constant(int(32)));
                              ir_if *f29BB = new(mem_ctx) ir_if(operand(r29BC).val);
                              exec_list *const f29BB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29BB->then_instructions;

                                 body.emit(assign(r29B4, lshift(r298F, r29B7), 0x01));

                                 ir_expression *const r29BD = lshift(r298E, r29B7);
                                 ir_expression *const r29BE = rshift(r298F, r29B3);
                                 body.emit(assign(r29B5, bit_or(r29BD, r29BE), 0x01));

                                 body.emit(assign(r29B6, rshift(r298E, r29B3), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f29BB->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r29C0 = equal(r29B3, body.constant(int(32)));
                                 ir_if *f29BF = new(mem_ctx) ir_if(operand(r29C0).val);
                                 exec_list *const f29BF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f29BF->then_instructions;

                                    body.emit(assign(r29B4, r298F, 0x01));

                                    body.emit(assign(r29B5, r298E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f29BF->else_instructions;

                                    body.emit(assign(r29B2, bit_or(body.constant(0u), r298F), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r29C2 = less(r29B3, body.constant(int(64)));
                                    ir_if *f29C1 = new(mem_ctx) ir_if(operand(r29C2).val);
                                    exec_list *const f29C1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f29C1->then_instructions;

                                       body.emit(assign(r29B4, lshift(r298E, r29B7), 0x01));

                                       ir_expression *const r29C3 = bit_and(r29B3, body.constant(int(31)));
                                       body.emit(assign(r29B5, rshift(r298E, r29C3), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f29C1->else_instructions;

                                       ir_variable *const r29C4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r29C6 = equal(r29B3, body.constant(int(64)));
                                       ir_if *f29C5 = new(mem_ctx) ir_if(operand(r29C6).val);
                                       exec_list *const f29C5_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f29C5->then_instructions;

                                          body.emit(assign(r29C4, r298E, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f29C5->else_instructions;

                                          ir_expression *const r29C7 = nequal(r298E, body.constant(0u));
                                          ir_expression *const r29C8 = expr(ir_unop_b2i, r29C7);
                                          body.emit(assign(r29C4, expr(ir_unop_i2u, r29C8), 0x01));


                                       body.instructions = f29C5_parent_instructions;
                                       body.emit(f29C5);

                                       /* END IF */

                                       body.emit(assign(r29B4, r29C4, 0x01));

                                       body.emit(assign(r29B5, body.constant(0u), 0x01));


                                    body.instructions = f29C1_parent_instructions;
                                    body.emit(f29C1);

                                    /* END IF */


                                 body.instructions = f29BF_parent_instructions;
                                 body.emit(f29BF);

                                 /* END IF */

                                 body.emit(assign(r29B6, body.constant(0u), 0x01));


                              body.instructions = f29BB_parent_instructions;
                              body.emit(f29BB);

                              /* END IF */

                              ir_expression *const r29C9 = nequal(r29B2, body.constant(0u));
                              ir_expression *const r29CA = expr(ir_unop_b2i, r29C9);
                              ir_expression *const r29CB = expr(ir_unop_i2u, r29CA);
                              body.emit(assign(r29B4, bit_or(r29B4, r29CB), 0x01));


                           body.instructions = f29B9_parent_instructions;
                           body.emit(f29B9);

                           /* END IF */

                           body.emit(assign(r298E, r29B6, 0x01));

                           body.emit(assign(r298F, r29B5, 0x01));

                           body.emit(assign(r2990, r29B4, 0x01));


                        body.instructions = f29A8_parent_instructions;
                        body.emit(f29A8);

                        /* END IF */

                        body.emit(assign(r298D, sub(r298D, r2991), 0x01));

                        ir_variable *const r29CC = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r29CC, r298D, 0x01));

                        ir_variable *const r29CD = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r29CD, r298E, 0x01));

                        ir_variable *const r29CE = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r29CE, r298F, 0x01));

                        ir_variable *const r29CF = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r29CF, r2990, 0x01));

                        ir_variable *const r29D0 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r29D0, body.constant(true), 0x01));

                        ir_variable *const r29D1 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r29D2 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r29D2);
                        ir_expression *const r29D3 = expr(ir_unop_u2i, r2990);
                        body.emit(assign(r29D2, less(r29D3, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r29D5 = lequal(body.constant(int(2045)), r298D);
                        ir_if *f29D4 = new(mem_ctx) ir_if(operand(r29D5).val);
                        exec_list *const f29D4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f29D4->then_instructions;

                           ir_variable *const r29D6 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r29D8 = less(body.constant(int(2045)), r298D);
                           ir_if *f29D7 = new(mem_ctx) ir_if(operand(r29D8).val);
                           exec_list *const f29D7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29D7->then_instructions;

                              body.emit(assign(r29D6, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29D7->else_instructions;

                              ir_variable *const r29D9 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r29DB = equal(r298D, body.constant(int(2045)));
                              ir_if *f29DA = new(mem_ctx) ir_if(operand(r29DB).val);
                              exec_list *const f29DA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29DA->then_instructions;

                                 ir_expression *const r29DC = equal(body.constant(2097151u), r298E);
                                 ir_expression *const r29DD = equal(body.constant(4294967295u), r298F);
                                 body.emit(assign(r29D9, logic_and(r29DC, r29DD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f29DA->else_instructions;

                                 body.emit(assign(r29D9, body.constant(false), 0x01));


                              body.instructions = f29DA_parent_instructions;
                              body.emit(f29DA);

                              /* END IF */

                              body.emit(assign(r29D6, logic_and(r29D9, r29D2), 0x01));


                           body.instructions = f29D7_parent_instructions;
                           body.emit(f29D7);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f29DE = new(mem_ctx) ir_if(operand(r29D6).val);
                           exec_list *const f29DE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29DE->then_instructions;

                              ir_variable *const r29DF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r29DF);
                              ir_expression *const r29E0 = lshift(r276F, body.constant(int(31)));
                              body.emit(assign(r29DF, add(r29E0, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r29DF, body.constant(0u), 0x01));

                              body.emit(assign(r29D1, r29DF, 0x03));

                              body.emit(assign(r29D0, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29DE->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r29E2 = less(r298D, body.constant(int(0)));
                              ir_if *f29E1 = new(mem_ctx) ir_if(operand(r29E2).val);
                              exec_list *const f29E1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29E1->then_instructions;

                                 ir_variable *const r29E3 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r29E3, r2990, 0x01));

                                 ir_variable *const r29E4 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r29E4, neg(r298D), 0x01));

                                 ir_variable *const r29E5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r29E5);
                                 ir_variable *const r29E6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r29E6);
                                 ir_variable *const r29E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r29E7);
                                 ir_variable *const r29E8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r29E9 = neg(r29E4);
                                 body.emit(assign(r29E8, bit_and(r29E9, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r29EB = equal(r29E4, body.constant(int(0)));
                                 ir_if *f29EA = new(mem_ctx) ir_if(operand(r29EB).val);
                                 exec_list *const f29EA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f29EA->then_instructions;

                                    body.emit(assign(r29E5, r2990, 0x01));

                                    body.emit(assign(r29E6, r298F, 0x01));

                                    body.emit(assign(r29E7, r298E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f29EA->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r29ED = less(r29E4, body.constant(int(32)));
                                    ir_if *f29EC = new(mem_ctx) ir_if(operand(r29ED).val);
                                    exec_list *const f29EC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f29EC->then_instructions;

                                       body.emit(assign(r29E5, lshift(r298F, r29E8), 0x01));

                                       ir_expression *const r29EE = lshift(r298E, r29E8);
                                       ir_expression *const r29EF = rshift(r298F, r29E4);
                                       body.emit(assign(r29E6, bit_or(r29EE, r29EF), 0x01));

                                       body.emit(assign(r29E7, rshift(r298E, r29E4), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f29EC->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r29F1 = equal(r29E4, body.constant(int(32)));
                                       ir_if *f29F0 = new(mem_ctx) ir_if(operand(r29F1).val);
                                       exec_list *const f29F0_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f29F0->then_instructions;

                                          body.emit(assign(r29E5, r298F, 0x01));

                                          body.emit(assign(r29E6, r298E, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f29F0->else_instructions;

                                          body.emit(assign(r29E3, bit_or(r2990, r298F), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r29F3 = less(r29E4, body.constant(int(64)));
                                          ir_if *f29F2 = new(mem_ctx) ir_if(operand(r29F3).val);
                                          exec_list *const f29F2_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f29F2->then_instructions;

                                             body.emit(assign(r29E5, lshift(r298E, r29E8), 0x01));

                                             ir_expression *const r29F4 = bit_and(r29E4, body.constant(int(31)));
                                             body.emit(assign(r29E6, rshift(r298E, r29F4), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f29F2->else_instructions;

                                             ir_variable *const r29F5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r29F7 = equal(r29E4, body.constant(int(64)));
                                             ir_if *f29F6 = new(mem_ctx) ir_if(operand(r29F7).val);
                                             exec_list *const f29F6_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f29F6->then_instructions;

                                                body.emit(assign(r29F5, r298E, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f29F6->else_instructions;

                                                ir_expression *const r29F8 = nequal(r298E, body.constant(0u));
                                                ir_expression *const r29F9 = expr(ir_unop_b2i, r29F8);
                                                body.emit(assign(r29F5, expr(ir_unop_i2u, r29F9), 0x01));


                                             body.instructions = f29F6_parent_instructions;
                                             body.emit(f29F6);

                                             /* END IF */

                                             body.emit(assign(r29E5, r29F5, 0x01));

                                             body.emit(assign(r29E6, body.constant(0u), 0x01));


                                          body.instructions = f29F2_parent_instructions;
                                          body.emit(f29F2);

                                          /* END IF */


                                       body.instructions = f29F0_parent_instructions;
                                       body.emit(f29F0);

                                       /* END IF */

                                       body.emit(assign(r29E7, body.constant(0u), 0x01));


                                    body.instructions = f29EC_parent_instructions;
                                    body.emit(f29EC);

                                    /* END IF */

                                    ir_expression *const r29FA = nequal(r29E3, body.constant(0u));
                                    ir_expression *const r29FB = expr(ir_unop_b2i, r29FA);
                                    ir_expression *const r29FC = expr(ir_unop_i2u, r29FB);
                                    body.emit(assign(r29E5, bit_or(r29E5, r29FC), 0x01));


                                 body.instructions = f29EA_parent_instructions;
                                 body.emit(f29EA);

                                 /* END IF */

                                 body.emit(assign(r29CD, r29E7, 0x01));

                                 body.emit(assign(r29CE, r29E6, 0x01));

                                 body.emit(assign(r29CF, r29E5, 0x01));

                                 body.emit(assign(r29CC, body.constant(int(0)), 0x01));

                                 body.emit(assign(r29D2, less(r29E5, body.constant(0u)), 0x01));


                              body.instructions = f29E1_parent_instructions;
                              body.emit(f29E1);

                              /* END IF */


                           body.instructions = f29DE_parent_instructions;
                           body.emit(f29DE);

                           /* END IF */


                        body.instructions = f29D4_parent_instructions;
                        body.emit(f29D4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f29FD = new(mem_ctx) ir_if(operand(r29D0).val);
                        exec_list *const f29FD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f29FD->then_instructions;

                           /* IF CONDITION */
                           ir_if *f29FE = new(mem_ctx) ir_if(operand(r29D2).val);
                           exec_list *const f29FE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29FE->then_instructions;

                              ir_variable *const r29FF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r29FF, add(r29CE, body.constant(1u)), 0x01));

                              ir_expression *const r2A00 = less(r29FF, r29CE);
                              ir_expression *const r2A01 = expr(ir_unop_b2i, r2A00);
                              ir_expression *const r2A02 = expr(ir_unop_i2u, r2A01);
                              body.emit(assign(r29CD, add(r29CD, r2A02), 0x01));

                              ir_expression *const r2A03 = equal(r29CF, body.constant(0u));
                              ir_expression *const r2A04 = expr(ir_unop_b2i, r2A03);
                              ir_expression *const r2A05 = expr(ir_unop_i2u, r2A04);
                              ir_expression *const r2A06 = add(r29CF, r2A05);
                              ir_expression *const r2A07 = bit_and(r2A06, body.constant(1u));
                              ir_expression *const r2A08 = expr(ir_unop_bit_not, r2A07);
                              body.emit(assign(r29CE, bit_and(r29FF, r2A08), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29FE->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2A0A = bit_or(r29CD, r29CE);
                              ir_expression *const r2A0B = equal(r2A0A, body.constant(0u));
                              ir_if *f2A09 = new(mem_ctx) ir_if(operand(r2A0B).val);
                              exec_list *const f2A09_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A09->then_instructions;

                                 body.emit(assign(r29CC, body.constant(int(0)), 0x01));


                              body.instructions = f2A09_parent_instructions;
                              body.emit(f2A09);

                              /* END IF */


                           body.instructions = f29FE_parent_instructions;
                           body.emit(f29FE);

                           /* END IF */

                           ir_variable *const r2A0C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2A0C);
                           ir_expression *const r2A0D = lshift(r276F, body.constant(int(31)));
                           ir_expression *const r2A0E = expr(ir_unop_i2u, r29CC);
                           ir_expression *const r2A0F = lshift(r2A0E, body.constant(int(20)));
                           ir_expression *const r2A10 = add(r2A0D, r2A0F);
                           body.emit(assign(r2A0C, add(r2A10, r29CD), 0x02));

                           body.emit(assign(r2A0C, r29CE, 0x01));

                           body.emit(assign(r29D1, r2A0C, 0x03));

                           body.emit(assign(r29D0, body.constant(false), 0x01));


                        body.instructions = f29FD_parent_instructions;
                        body.emit(f29FD);

                        /* END IF */

                        body.emit(assign(r2770, r29D1, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2985->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2A12 = less(r2775, r2777);
                        ir_if *f2A11 = new(mem_ctx) ir_if(operand(r2A12).val);
                        exec_list *const f2A11_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2A11->then_instructions;

                           ir_variable *const r2A13 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r2A14 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2A14, sub(r2777, r2775), 0x01));

                           ir_expression *const r2A15 = sub(r2776, r2774);
                           ir_expression *const r2A16 = less(r2777, r2775);
                           ir_expression *const r2A17 = expr(ir_unop_b2i, r2A16);
                           ir_expression *const r2A18 = expr(ir_unop_i2u, r2A17);
                           body.emit(assign(r2A13, sub(r2A15, r2A18), 0x01));

                           body.emit(assign(r2778, add(r2773, body.constant(int(-1))), 0x01));

                           ir_variable *const r2A19 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2A19, add(r2778, body.constant(int(-10))), 0x01));

                           ir_variable *const r2A1A = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2A1A, r2A13, 0x01));

                           ir_variable *const r2A1B = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2A1B, r2A14, 0x01));

                           ir_variable *const r2A1C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r2A1C);
                           ir_variable *const r2A1D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2A1D);
                           /* IF CONDITION */
                           ir_expression *const r2A1F = equal(r2A13, body.constant(0u));
                           ir_if *f2A1E = new(mem_ctx) ir_if(operand(r2A1F).val);
                           exec_list *const f2A1E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A1E->then_instructions;

                              body.emit(assign(r2A1A, r2A14, 0x01));

                              body.emit(assign(r2A1B, body.constant(0u), 0x01));

                              body.emit(assign(r2A19, add(r2A19, body.constant(int(-32))), 0x01));


                           body.instructions = f2A1E_parent_instructions;
                           body.emit(f2A1E);

                           /* END IF */

                           ir_variable *const r2A20 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r2A20, r2A1A, 0x01));

                           ir_variable *const r2A21 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r2A22 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2A22);
                           /* IF CONDITION */
                           ir_expression *const r2A24 = equal(r2A1A, body.constant(0u));
                           ir_if *f2A23 = new(mem_ctx) ir_if(operand(r2A24).val);
                           exec_list *const f2A23_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A23->then_instructions;

                              body.emit(assign(r2A21, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2A23->else_instructions;

                              body.emit(assign(r2A22, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2A26 = bit_and(r2A1A, body.constant(4294901760u));
                              ir_expression *const r2A27 = equal(r2A26, body.constant(0u));
                              ir_if *f2A25 = new(mem_ctx) ir_if(operand(r2A27).val);
                              exec_list *const f2A25_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A25->then_instructions;

                                 body.emit(assign(r2A22, body.constant(int(16)), 0x01));

                                 body.emit(assign(r2A20, lshift(r2A1A, body.constant(int(16))), 0x01));


                              body.instructions = f2A25_parent_instructions;
                              body.emit(f2A25);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2A29 = bit_and(r2A20, body.constant(4278190080u));
                              ir_expression *const r2A2A = equal(r2A29, body.constant(0u));
                              ir_if *f2A28 = new(mem_ctx) ir_if(operand(r2A2A).val);
                              exec_list *const f2A28_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A28->then_instructions;

                                 body.emit(assign(r2A22, add(r2A22, body.constant(int(8))), 0x01));

                                 body.emit(assign(r2A20, lshift(r2A20, body.constant(int(8))), 0x01));


                              body.instructions = f2A28_parent_instructions;
                              body.emit(f2A28);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2A2C = bit_and(r2A20, body.constant(4026531840u));
                              ir_expression *const r2A2D = equal(r2A2C, body.constant(0u));
                              ir_if *f2A2B = new(mem_ctx) ir_if(operand(r2A2D).val);
                              exec_list *const f2A2B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A2B->then_instructions;

                                 body.emit(assign(r2A22, add(r2A22, body.constant(int(4))), 0x01));

                                 body.emit(assign(r2A20, lshift(r2A20, body.constant(int(4))), 0x01));


                              body.instructions = f2A2B_parent_instructions;
                              body.emit(f2A2B);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2A2F = bit_and(r2A20, body.constant(3221225472u));
                              ir_expression *const r2A30 = equal(r2A2F, body.constant(0u));
                              ir_if *f2A2E = new(mem_ctx) ir_if(operand(r2A30).val);
                              exec_list *const f2A2E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A2E->then_instructions;

                                 body.emit(assign(r2A22, add(r2A22, body.constant(int(2))), 0x01));

                                 body.emit(assign(r2A20, lshift(r2A20, body.constant(int(2))), 0x01));


                              body.instructions = f2A2E_parent_instructions;
                              body.emit(f2A2E);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2A32 = bit_and(r2A20, body.constant(2147483648u));
                              ir_expression *const r2A33 = equal(r2A32, body.constant(0u));
                              ir_if *f2A31 = new(mem_ctx) ir_if(operand(r2A33).val);
                              exec_list *const f2A31_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A31->then_instructions;

                                 body.emit(assign(r2A22, add(r2A22, body.constant(int(1))), 0x01));


                              body.instructions = f2A31_parent_instructions;
                              body.emit(f2A31);

                              /* END IF */

                              body.emit(assign(r2A21, r2A22, 0x01));


                           body.instructions = f2A23_parent_instructions;
                           body.emit(f2A23);

                           /* END IF */

                           body.emit(assign(r2A1D, add(r2A21, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2A35 = lequal(body.constant(int(0)), r2A1D);
                           ir_if *f2A34 = new(mem_ctx) ir_if(operand(r2A35).val);
                           exec_list *const f2A34_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A34->then_instructions;

                              body.emit(assign(r2A1C, body.constant(0u), 0x01));

                              ir_variable *const r2A36 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2A36, lshift(r2A1B, r2A1D), 0x01));

                              ir_variable *const r2A37 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2A39 = equal(r2A1D, body.constant(int(0)));
                              ir_if *f2A38 = new(mem_ctx) ir_if(operand(r2A39).val);
                              exec_list *const f2A38_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A38->then_instructions;

                                 body.emit(assign(r2A37, r2A1A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A38->else_instructions;

                                 ir_expression *const r2A3A = lshift(r2A1A, r2A1D);
                                 ir_expression *const r2A3B = neg(r2A1D);
                                 ir_expression *const r2A3C = bit_and(r2A3B, body.constant(int(31)));
                                 ir_expression *const r2A3D = rshift(r2A1B, r2A3C);
                                 body.emit(assign(r2A37, bit_or(r2A3A, r2A3D), 0x01));


                              body.instructions = f2A38_parent_instructions;
                              body.emit(f2A38);

                              /* END IF */

                              body.emit(assign(r2A1A, r2A37, 0x01));

                              body.emit(assign(r2A1B, r2A36, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2A34->else_instructions;

                              ir_variable *const r2A3E = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2A3E, body.constant(0u), 0x01));

                              ir_variable *const r2A3F = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2A3F, neg(r2A1D), 0x01));

                              ir_variable *const r2A40 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2A40);
                              ir_variable *const r2A41 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2A41);
                              ir_variable *const r2A42 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2A42);
                              ir_variable *const r2A43 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2A44 = neg(r2A3F);
                              body.emit(assign(r2A43, bit_and(r2A44, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2A46 = equal(r2A3F, body.constant(int(0)));
                              ir_if *f2A45 = new(mem_ctx) ir_if(operand(r2A46).val);
                              exec_list *const f2A45_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A45->then_instructions;

                                 body.emit(assign(r2A40, r2A3E, 0x01));

                                 body.emit(assign(r2A41, r2A1B, 0x01));

                                 body.emit(assign(r2A42, r2A1A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A45->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2A48 = less(r2A3F, body.constant(int(32)));
                                 ir_if *f2A47 = new(mem_ctx) ir_if(operand(r2A48).val);
                                 exec_list *const f2A47_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A47->then_instructions;

                                    body.emit(assign(r2A40, lshift(r2A1B, r2A43), 0x01));

                                    ir_expression *const r2A49 = lshift(r2A1A, r2A43);
                                    ir_expression *const r2A4A = rshift(r2A1B, r2A3F);
                                    body.emit(assign(r2A41, bit_or(r2A49, r2A4A), 0x01));

                                    body.emit(assign(r2A42, rshift(r2A1A, r2A3F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2A47->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2A4C = equal(r2A3F, body.constant(int(32)));
                                    ir_if *f2A4B = new(mem_ctx) ir_if(operand(r2A4C).val);
                                    exec_list *const f2A4B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2A4B->then_instructions;

                                       body.emit(assign(r2A40, r2A1B, 0x01));

                                       body.emit(assign(r2A41, r2A1A, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2A4B->else_instructions;

                                       body.emit(assign(r2A3E, bit_or(body.constant(0u), r2A1B), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2A4E = less(r2A3F, body.constant(int(64)));
                                       ir_if *f2A4D = new(mem_ctx) ir_if(operand(r2A4E).val);
                                       exec_list *const f2A4D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2A4D->then_instructions;

                                          body.emit(assign(r2A40, lshift(r2A1A, r2A43), 0x01));

                                          ir_expression *const r2A4F = bit_and(r2A3F, body.constant(int(31)));
                                          body.emit(assign(r2A41, rshift(r2A1A, r2A4F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2A4D->else_instructions;

                                          ir_variable *const r2A50 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2A52 = equal(r2A3F, body.constant(int(64)));
                                          ir_if *f2A51 = new(mem_ctx) ir_if(operand(r2A52).val);
                                          exec_list *const f2A51_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2A51->then_instructions;

                                             body.emit(assign(r2A50, r2A1A, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2A51->else_instructions;

                                             ir_expression *const r2A53 = nequal(r2A1A, body.constant(0u));
                                             ir_expression *const r2A54 = expr(ir_unop_b2i, r2A53);
                                             body.emit(assign(r2A50, expr(ir_unop_i2u, r2A54), 0x01));


                                          body.instructions = f2A51_parent_instructions;
                                          body.emit(f2A51);

                                          /* END IF */

                                          body.emit(assign(r2A40, r2A50, 0x01));

                                          body.emit(assign(r2A41, body.constant(0u), 0x01));


                                       body.instructions = f2A4D_parent_instructions;
                                       body.emit(f2A4D);

                                       /* END IF */


                                    body.instructions = f2A4B_parent_instructions;
                                    body.emit(f2A4B);

                                    /* END IF */

                                    body.emit(assign(r2A42, body.constant(0u), 0x01));


                                 body.instructions = f2A47_parent_instructions;
                                 body.emit(f2A47);

                                 /* END IF */

                                 ir_expression *const r2A55 = nequal(r2A3E, body.constant(0u));
                                 ir_expression *const r2A56 = expr(ir_unop_b2i, r2A55);
                                 ir_expression *const r2A57 = expr(ir_unop_i2u, r2A56);
                                 body.emit(assign(r2A40, bit_or(r2A40, r2A57), 0x01));


                              body.instructions = f2A45_parent_instructions;
                              body.emit(f2A45);

                              /* END IF */

                              body.emit(assign(r2A1A, r2A42, 0x01));

                              body.emit(assign(r2A1B, r2A41, 0x01));

                              body.emit(assign(r2A1C, r2A40, 0x01));


                           body.instructions = f2A34_parent_instructions;
                           body.emit(f2A34);

                           /* END IF */

                           body.emit(assign(r2A19, sub(r2A19, r2A1D), 0x01));

                           ir_variable *const r2A58 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2A58, r2A19, 0x01));

                           ir_variable *const r2A59 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2A59, r2A1A, 0x01));

                           ir_variable *const r2A5A = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2A5A, r2A1B, 0x01));

                           ir_variable *const r2A5B = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r2A5B, r2A1C, 0x01));

                           ir_variable *const r2A5C = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r2A5C, body.constant(true), 0x01));

                           ir_variable *const r2A5D = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r2A5E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r2A5E);
                           ir_expression *const r2A5F = expr(ir_unop_u2i, r2A1C);
                           body.emit(assign(r2A5E, less(r2A5F, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2A61 = lequal(body.constant(int(2045)), r2A19);
                           ir_if *f2A60 = new(mem_ctx) ir_if(operand(r2A61).val);
                           exec_list *const f2A60_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A60->then_instructions;

                              ir_variable *const r2A62 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2A64 = less(body.constant(int(2045)), r2A19);
                              ir_if *f2A63 = new(mem_ctx) ir_if(operand(r2A64).val);
                              exec_list *const f2A63_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A63->then_instructions;

                                 body.emit(assign(r2A62, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A63->else_instructions;

                                 ir_variable *const r2A65 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2A67 = equal(r2A19, body.constant(int(2045)));
                                 ir_if *f2A66 = new(mem_ctx) ir_if(operand(r2A67).val);
                                 exec_list *const f2A66_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A66->then_instructions;

                                    ir_expression *const r2A68 = equal(body.constant(2097151u), r2A1A);
                                    ir_expression *const r2A69 = equal(body.constant(4294967295u), r2A1B);
                                    body.emit(assign(r2A65, logic_and(r2A68, r2A69), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2A66->else_instructions;

                                    body.emit(assign(r2A65, body.constant(false), 0x01));


                                 body.instructions = f2A66_parent_instructions;
                                 body.emit(f2A66);

                                 /* END IF */

                                 body.emit(assign(r2A62, logic_and(r2A65, r2A5E), 0x01));


                              body.instructions = f2A63_parent_instructions;
                              body.emit(f2A63);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2A6A = new(mem_ctx) ir_if(operand(r2A62).val);
                              exec_list *const f2A6A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A6A->then_instructions;

                                 ir_variable *const r2A6B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2A6B);
                                 ir_expression *const r2A6C = lshift(r276F, body.constant(int(31)));
                                 body.emit(assign(r2A6B, add(r2A6C, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r2A6B, body.constant(0u), 0x01));

                                 body.emit(assign(r2A5D, r2A6B, 0x03));

                                 body.emit(assign(r2A5C, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A6A->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2A6E = less(r2A19, body.constant(int(0)));
                                 ir_if *f2A6D = new(mem_ctx) ir_if(operand(r2A6E).val);
                                 exec_list *const f2A6D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A6D->then_instructions;

                                    ir_variable *const r2A6F = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r2A6F, r2A1C, 0x01));

                                    ir_variable *const r2A70 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r2A70, neg(r2A19), 0x01));

                                    ir_variable *const r2A71 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r2A71);
                                    ir_variable *const r2A72 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r2A72);
                                    ir_variable *const r2A73 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r2A73);
                                    ir_variable *const r2A74 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r2A75 = neg(r2A70);
                                    body.emit(assign(r2A74, bit_and(r2A75, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2A77 = equal(r2A70, body.constant(int(0)));
                                    ir_if *f2A76 = new(mem_ctx) ir_if(operand(r2A77).val);
                                    exec_list *const f2A76_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2A76->then_instructions;

                                       body.emit(assign(r2A71, r2A1C, 0x01));

                                       body.emit(assign(r2A72, r2A1B, 0x01));

                                       body.emit(assign(r2A73, r2A1A, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2A76->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2A79 = less(r2A70, body.constant(int(32)));
                                       ir_if *f2A78 = new(mem_ctx) ir_if(operand(r2A79).val);
                                       exec_list *const f2A78_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2A78->then_instructions;

                                          body.emit(assign(r2A71, lshift(r2A1B, r2A74), 0x01));

                                          ir_expression *const r2A7A = lshift(r2A1A, r2A74);
                                          ir_expression *const r2A7B = rshift(r2A1B, r2A70);
                                          body.emit(assign(r2A72, bit_or(r2A7A, r2A7B), 0x01));

                                          body.emit(assign(r2A73, rshift(r2A1A, r2A70), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2A78->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2A7D = equal(r2A70, body.constant(int(32)));
                                          ir_if *f2A7C = new(mem_ctx) ir_if(operand(r2A7D).val);
                                          exec_list *const f2A7C_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2A7C->then_instructions;

                                             body.emit(assign(r2A71, r2A1B, 0x01));

                                             body.emit(assign(r2A72, r2A1A, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2A7C->else_instructions;

                                             body.emit(assign(r2A6F, bit_or(r2A1C, r2A1B), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r2A7F = less(r2A70, body.constant(int(64)));
                                             ir_if *f2A7E = new(mem_ctx) ir_if(operand(r2A7F).val);
                                             exec_list *const f2A7E_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2A7E->then_instructions;

                                                body.emit(assign(r2A71, lshift(r2A1A, r2A74), 0x01));

                                                ir_expression *const r2A80 = bit_and(r2A70, body.constant(int(31)));
                                                body.emit(assign(r2A72, rshift(r2A1A, r2A80), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2A7E->else_instructions;

                                                ir_variable *const r2A81 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r2A83 = equal(r2A70, body.constant(int(64)));
                                                ir_if *f2A82 = new(mem_ctx) ir_if(operand(r2A83).val);
                                                exec_list *const f2A82_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2A82->then_instructions;

                                                   body.emit(assign(r2A81, r2A1A, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2A82->else_instructions;

                                                   ir_expression *const r2A84 = nequal(r2A1A, body.constant(0u));
                                                   ir_expression *const r2A85 = expr(ir_unop_b2i, r2A84);
                                                   body.emit(assign(r2A81, expr(ir_unop_i2u, r2A85), 0x01));


                                                body.instructions = f2A82_parent_instructions;
                                                body.emit(f2A82);

                                                /* END IF */

                                                body.emit(assign(r2A71, r2A81, 0x01));

                                                body.emit(assign(r2A72, body.constant(0u), 0x01));


                                             body.instructions = f2A7E_parent_instructions;
                                             body.emit(f2A7E);

                                             /* END IF */


                                          body.instructions = f2A7C_parent_instructions;
                                          body.emit(f2A7C);

                                          /* END IF */

                                          body.emit(assign(r2A73, body.constant(0u), 0x01));


                                       body.instructions = f2A78_parent_instructions;
                                       body.emit(f2A78);

                                       /* END IF */

                                       ir_expression *const r2A86 = nequal(r2A6F, body.constant(0u));
                                       ir_expression *const r2A87 = expr(ir_unop_b2i, r2A86);
                                       ir_expression *const r2A88 = expr(ir_unop_i2u, r2A87);
                                       body.emit(assign(r2A71, bit_or(r2A71, r2A88), 0x01));


                                    body.instructions = f2A76_parent_instructions;
                                    body.emit(f2A76);

                                    /* END IF */

                                    body.emit(assign(r2A59, r2A73, 0x01));

                                    body.emit(assign(r2A5A, r2A72, 0x01));

                                    body.emit(assign(r2A5B, r2A71, 0x01));

                                    body.emit(assign(r2A58, body.constant(int(0)), 0x01));

                                    body.emit(assign(r2A5E, less(r2A71, body.constant(0u)), 0x01));


                                 body.instructions = f2A6D_parent_instructions;
                                 body.emit(f2A6D);

                                 /* END IF */


                              body.instructions = f2A6A_parent_instructions;
                              body.emit(f2A6A);

                              /* END IF */


                           body.instructions = f2A60_parent_instructions;
                           body.emit(f2A60);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2A89 = new(mem_ctx) ir_if(operand(r2A5C).val);
                           exec_list *const f2A89_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A89->then_instructions;

                              /* IF CONDITION */
                              ir_if *f2A8A = new(mem_ctx) ir_if(operand(r2A5E).val);
                              exec_list *const f2A8A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A8A->then_instructions;

                                 ir_variable *const r2A8B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r2A8B, add(r2A5A, body.constant(1u)), 0x01));

                                 ir_expression *const r2A8C = less(r2A8B, r2A5A);
                                 ir_expression *const r2A8D = expr(ir_unop_b2i, r2A8C);
                                 ir_expression *const r2A8E = expr(ir_unop_i2u, r2A8D);
                                 body.emit(assign(r2A59, add(r2A59, r2A8E), 0x01));

                                 ir_expression *const r2A8F = equal(r2A5B, body.constant(0u));
                                 ir_expression *const r2A90 = expr(ir_unop_b2i, r2A8F);
                                 ir_expression *const r2A91 = expr(ir_unop_i2u, r2A90);
                                 ir_expression *const r2A92 = add(r2A5B, r2A91);
                                 ir_expression *const r2A93 = bit_and(r2A92, body.constant(1u));
                                 ir_expression *const r2A94 = expr(ir_unop_bit_not, r2A93);
                                 body.emit(assign(r2A5A, bit_and(r2A8B, r2A94), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A8A->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2A96 = bit_or(r2A59, r2A5A);
                                 ir_expression *const r2A97 = equal(r2A96, body.constant(0u));
                                 ir_if *f2A95 = new(mem_ctx) ir_if(operand(r2A97).val);
                                 exec_list *const f2A95_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A95->then_instructions;

                                    body.emit(assign(r2A58, body.constant(int(0)), 0x01));


                                 body.instructions = f2A95_parent_instructions;
                                 body.emit(f2A95);

                                 /* END IF */


                              body.instructions = f2A8A_parent_instructions;
                              body.emit(f2A8A);

                              /* END IF */

                              ir_variable *const r2A98 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2A98);
                              ir_expression *const r2A99 = lshift(r276F, body.constant(int(31)));
                              ir_expression *const r2A9A = expr(ir_unop_i2u, r2A58);
                              ir_expression *const r2A9B = lshift(r2A9A, body.constant(int(20)));
                              ir_expression *const r2A9C = add(r2A99, r2A9B);
                              body.emit(assign(r2A98, add(r2A9C, r2A59), 0x02));

                              body.emit(assign(r2A98, r2A5A, 0x01));

                              body.emit(assign(r2A5D, r2A98, 0x03));

                              body.emit(assign(r2A5C, body.constant(false), 0x01));


                           body.instructions = f2A89_parent_instructions;
                           body.emit(f2A89);

                           /* END IF */

                           body.emit(assign(r2770, r2A5D, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2A11->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2A9E = less(r2777, r2775);
                           ir_if *f2A9D = new(mem_ctx) ir_if(operand(r2A9E).val);
                           exec_list *const f2A9D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A9D->then_instructions;

                              ir_variable *const r2A9F = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r2AA0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2AA0, sub(r2775, r2777), 0x01));

                              ir_expression *const r2AA1 = sub(r2774, r2776);
                              ir_expression *const r2AA2 = less(r2775, r2777);
                              ir_expression *const r2AA3 = expr(ir_unop_b2i, r2AA2);
                              ir_expression *const r2AA4 = expr(ir_unop_i2u, r2AA3);
                              body.emit(assign(r2A9F, sub(r2AA1, r2AA4), 0x01));

                              body.emit(assign(r276F, bit_xor(r276F, body.constant(1u)), 0x01));

                              body.emit(assign(r2778, add(r2772, body.constant(int(-1))), 0x01));

                              ir_variable *const r2AA5 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2AA5, add(r2778, body.constant(int(-10))), 0x01));

                              ir_variable *const r2AA6 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2AA6, r2A9F, 0x01));

                              ir_variable *const r2AA7 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2AA7, r2AA0, 0x01));

                              ir_variable *const r2AA8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r2AA8);
                              ir_variable *const r2AA9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2AA9);
                              /* IF CONDITION */
                              ir_expression *const r2AAB = equal(r2A9F, body.constant(0u));
                              ir_if *f2AAA = new(mem_ctx) ir_if(operand(r2AAB).val);
                              exec_list *const f2AAA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2AAA->then_instructions;

                                 body.emit(assign(r2AA6, r2AA0, 0x01));

                                 body.emit(assign(r2AA7, body.constant(0u), 0x01));

                                 body.emit(assign(r2AA5, add(r2AA5, body.constant(int(-32))), 0x01));


                              body.instructions = f2AAA_parent_instructions;
                              body.emit(f2AAA);

                              /* END IF */

                              ir_variable *const r2AAC = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r2AAC, r2AA6, 0x01));

                              ir_variable *const r2AAD = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r2AAE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2AAE);
                              /* IF CONDITION */
                              ir_expression *const r2AB0 = equal(r2AA6, body.constant(0u));
                              ir_if *f2AAF = new(mem_ctx) ir_if(operand(r2AB0).val);
                              exec_list *const f2AAF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2AAF->then_instructions;

                                 body.emit(assign(r2AAD, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2AAF->else_instructions;

                                 body.emit(assign(r2AAE, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2AB2 = bit_and(r2AA6, body.constant(4294901760u));
                                 ir_expression *const r2AB3 = equal(r2AB2, body.constant(0u));
                                 ir_if *f2AB1 = new(mem_ctx) ir_if(operand(r2AB3).val);
                                 exec_list *const f2AB1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AB1->then_instructions;

                                    body.emit(assign(r2AAE, body.constant(int(16)), 0x01));

                                    body.emit(assign(r2AAC, lshift(r2AA6, body.constant(int(16))), 0x01));


                                 body.instructions = f2AB1_parent_instructions;
                                 body.emit(f2AB1);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2AB5 = bit_and(r2AAC, body.constant(4278190080u));
                                 ir_expression *const r2AB6 = equal(r2AB5, body.constant(0u));
                                 ir_if *f2AB4 = new(mem_ctx) ir_if(operand(r2AB6).val);
                                 exec_list *const f2AB4_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AB4->then_instructions;

                                    body.emit(assign(r2AAE, add(r2AAE, body.constant(int(8))), 0x01));

                                    body.emit(assign(r2AAC, lshift(r2AAC, body.constant(int(8))), 0x01));


                                 body.instructions = f2AB4_parent_instructions;
                                 body.emit(f2AB4);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2AB8 = bit_and(r2AAC, body.constant(4026531840u));
                                 ir_expression *const r2AB9 = equal(r2AB8, body.constant(0u));
                                 ir_if *f2AB7 = new(mem_ctx) ir_if(operand(r2AB9).val);
                                 exec_list *const f2AB7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AB7->then_instructions;

                                    body.emit(assign(r2AAE, add(r2AAE, body.constant(int(4))), 0x01));

                                    body.emit(assign(r2AAC, lshift(r2AAC, body.constant(int(4))), 0x01));


                                 body.instructions = f2AB7_parent_instructions;
                                 body.emit(f2AB7);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2ABB = bit_and(r2AAC, body.constant(3221225472u));
                                 ir_expression *const r2ABC = equal(r2ABB, body.constant(0u));
                                 ir_if *f2ABA = new(mem_ctx) ir_if(operand(r2ABC).val);
                                 exec_list *const f2ABA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2ABA->then_instructions;

                                    body.emit(assign(r2AAE, add(r2AAE, body.constant(int(2))), 0x01));

                                    body.emit(assign(r2AAC, lshift(r2AAC, body.constant(int(2))), 0x01));


                                 body.instructions = f2ABA_parent_instructions;
                                 body.emit(f2ABA);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2ABE = bit_and(r2AAC, body.constant(2147483648u));
                                 ir_expression *const r2ABF = equal(r2ABE, body.constant(0u));
                                 ir_if *f2ABD = new(mem_ctx) ir_if(operand(r2ABF).val);
                                 exec_list *const f2ABD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2ABD->then_instructions;

                                    body.emit(assign(r2AAE, add(r2AAE, body.constant(int(1))), 0x01));


                                 body.instructions = f2ABD_parent_instructions;
                                 body.emit(f2ABD);

                                 /* END IF */

                                 body.emit(assign(r2AAD, r2AAE, 0x01));


                              body.instructions = f2AAF_parent_instructions;
                              body.emit(f2AAF);

                              /* END IF */

                              body.emit(assign(r2AA9, add(r2AAD, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2AC1 = lequal(body.constant(int(0)), r2AA9);
                              ir_if *f2AC0 = new(mem_ctx) ir_if(operand(r2AC1).val);
                              exec_list *const f2AC0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2AC0->then_instructions;

                                 body.emit(assign(r2AA8, body.constant(0u), 0x01));

                                 ir_variable *const r2AC2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r2AC2, lshift(r2AA7, r2AA9), 0x01));

                                 ir_variable *const r2AC3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2AC5 = equal(r2AA9, body.constant(int(0)));
                                 ir_if *f2AC4 = new(mem_ctx) ir_if(operand(r2AC5).val);
                                 exec_list *const f2AC4_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AC4->then_instructions;

                                    body.emit(assign(r2AC3, r2AA6, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2AC4->else_instructions;

                                    ir_expression *const r2AC6 = lshift(r2AA6, r2AA9);
                                    ir_expression *const r2AC7 = neg(r2AA9);
                                    ir_expression *const r2AC8 = bit_and(r2AC7, body.constant(int(31)));
                                    ir_expression *const r2AC9 = rshift(r2AA7, r2AC8);
                                    body.emit(assign(r2AC3, bit_or(r2AC6, r2AC9), 0x01));


                                 body.instructions = f2AC4_parent_instructions;
                                 body.emit(f2AC4);

                                 /* END IF */

                                 body.emit(assign(r2AA6, r2AC3, 0x01));

                                 body.emit(assign(r2AA7, r2AC2, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2AC0->else_instructions;

                                 ir_variable *const r2ACA = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2ACA, body.constant(0u), 0x01));

                                 ir_variable *const r2ACB = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2ACB, neg(r2AA9), 0x01));

                                 ir_variable *const r2ACC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2ACC);
                                 ir_variable *const r2ACD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2ACD);
                                 ir_variable *const r2ACE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2ACE);
                                 ir_variable *const r2ACF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2AD0 = neg(r2ACB);
                                 body.emit(assign(r2ACF, bit_and(r2AD0, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2AD2 = equal(r2ACB, body.constant(int(0)));
                                 ir_if *f2AD1 = new(mem_ctx) ir_if(operand(r2AD2).val);
                                 exec_list *const f2AD1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AD1->then_instructions;

                                    body.emit(assign(r2ACC, r2ACA, 0x01));

                                    body.emit(assign(r2ACD, r2AA7, 0x01));

                                    body.emit(assign(r2ACE, r2AA6, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2AD1->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2AD4 = less(r2ACB, body.constant(int(32)));
                                    ir_if *f2AD3 = new(mem_ctx) ir_if(operand(r2AD4).val);
                                    exec_list *const f2AD3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2AD3->then_instructions;

                                       body.emit(assign(r2ACC, lshift(r2AA7, r2ACF), 0x01));

                                       ir_expression *const r2AD5 = lshift(r2AA6, r2ACF);
                                       ir_expression *const r2AD6 = rshift(r2AA7, r2ACB);
                                       body.emit(assign(r2ACD, bit_or(r2AD5, r2AD6), 0x01));

                                       body.emit(assign(r2ACE, rshift(r2AA6, r2ACB), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2AD3->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2AD8 = equal(r2ACB, body.constant(int(32)));
                                       ir_if *f2AD7 = new(mem_ctx) ir_if(operand(r2AD8).val);
                                       exec_list *const f2AD7_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2AD7->then_instructions;

                                          body.emit(assign(r2ACC, r2AA7, 0x01));

                                          body.emit(assign(r2ACD, r2AA6, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2AD7->else_instructions;

                                          body.emit(assign(r2ACA, bit_or(body.constant(0u), r2AA7), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2ADA = less(r2ACB, body.constant(int(64)));
                                          ir_if *f2AD9 = new(mem_ctx) ir_if(operand(r2ADA).val);
                                          exec_list *const f2AD9_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2AD9->then_instructions;

                                             body.emit(assign(r2ACC, lshift(r2AA6, r2ACF), 0x01));

                                             ir_expression *const r2ADB = bit_and(r2ACB, body.constant(int(31)));
                                             body.emit(assign(r2ACD, rshift(r2AA6, r2ADB), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2AD9->else_instructions;

                                             ir_variable *const r2ADC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2ADE = equal(r2ACB, body.constant(int(64)));
                                             ir_if *f2ADD = new(mem_ctx) ir_if(operand(r2ADE).val);
                                             exec_list *const f2ADD_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2ADD->then_instructions;

                                                body.emit(assign(r2ADC, r2AA6, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2ADD->else_instructions;

                                                ir_expression *const r2ADF = nequal(r2AA6, body.constant(0u));
                                                ir_expression *const r2AE0 = expr(ir_unop_b2i, r2ADF);
                                                body.emit(assign(r2ADC, expr(ir_unop_i2u, r2AE0), 0x01));


                                             body.instructions = f2ADD_parent_instructions;
                                             body.emit(f2ADD);

                                             /* END IF */

                                             body.emit(assign(r2ACC, r2ADC, 0x01));

                                             body.emit(assign(r2ACD, body.constant(0u), 0x01));


                                          body.instructions = f2AD9_parent_instructions;
                                          body.emit(f2AD9);

                                          /* END IF */


                                       body.instructions = f2AD7_parent_instructions;
                                       body.emit(f2AD7);

                                       /* END IF */

                                       body.emit(assign(r2ACE, body.constant(0u), 0x01));


                                    body.instructions = f2AD3_parent_instructions;
                                    body.emit(f2AD3);

                                    /* END IF */

                                    ir_expression *const r2AE1 = nequal(r2ACA, body.constant(0u));
                                    ir_expression *const r2AE2 = expr(ir_unop_b2i, r2AE1);
                                    ir_expression *const r2AE3 = expr(ir_unop_i2u, r2AE2);
                                    body.emit(assign(r2ACC, bit_or(r2ACC, r2AE3), 0x01));


                                 body.instructions = f2AD1_parent_instructions;
                                 body.emit(f2AD1);

                                 /* END IF */

                                 body.emit(assign(r2AA6, r2ACE, 0x01));

                                 body.emit(assign(r2AA7, r2ACD, 0x01));

                                 body.emit(assign(r2AA8, r2ACC, 0x01));


                              body.instructions = f2AC0_parent_instructions;
                              body.emit(f2AC0);

                              /* END IF */

                              body.emit(assign(r2AA5, sub(r2AA5, r2AA9), 0x01));

                              ir_variable *const r2AE4 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2AE4, r2AA5, 0x01));

                              ir_variable *const r2AE5 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2AE5, r2AA6, 0x01));

                              ir_variable *const r2AE6 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2AE6, r2AA7, 0x01));

                              ir_variable *const r2AE7 = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r2AE7, r2AA8, 0x01));

                              ir_variable *const r2AE8 = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r2AE8, body.constant(true), 0x01));

                              ir_variable *const r2AE9 = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r2AEA = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r2AEA);
                              ir_expression *const r2AEB = expr(ir_unop_u2i, r2AA8);
                              body.emit(assign(r2AEA, less(r2AEB, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2AED = lequal(body.constant(int(2045)), r2AA5);
                              ir_if *f2AEC = new(mem_ctx) ir_if(operand(r2AED).val);
                              exec_list *const f2AEC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2AEC->then_instructions;

                                 ir_variable *const r2AEE = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2AF0 = less(body.constant(int(2045)), r2AA5);
                                 ir_if *f2AEF = new(mem_ctx) ir_if(operand(r2AF0).val);
                                 exec_list *const f2AEF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AEF->then_instructions;

                                    body.emit(assign(r2AEE, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2AEF->else_instructions;

                                    ir_variable *const r2AF1 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2AF3 = equal(r2AA5, body.constant(int(2045)));
                                    ir_if *f2AF2 = new(mem_ctx) ir_if(operand(r2AF3).val);
                                    exec_list *const f2AF2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2AF2->then_instructions;

                                       ir_expression *const r2AF4 = equal(body.constant(2097151u), r2AA6);
                                       ir_expression *const r2AF5 = equal(body.constant(4294967295u), r2AA7);
                                       body.emit(assign(r2AF1, logic_and(r2AF4, r2AF5), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2AF2->else_instructions;

                                       body.emit(assign(r2AF1, body.constant(false), 0x01));


                                    body.instructions = f2AF2_parent_instructions;
                                    body.emit(f2AF2);

                                    /* END IF */

                                    body.emit(assign(r2AEE, logic_and(r2AF1, r2AEA), 0x01));


                                 body.instructions = f2AEF_parent_instructions;
                                 body.emit(f2AEF);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f2AF6 = new(mem_ctx) ir_if(operand(r2AEE).val);
                                 exec_list *const f2AF6_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AF6->then_instructions;

                                    ir_variable *const r2AF7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r2AF7);
                                    ir_expression *const r2AF8 = lshift(r276F, body.constant(int(31)));
                                    body.emit(assign(r2AF7, add(r2AF8, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r2AF7, body.constant(0u), 0x01));

                                    body.emit(assign(r2AE9, r2AF7, 0x03));

                                    body.emit(assign(r2AE8, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2AF6->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2AFA = less(r2AA5, body.constant(int(0)));
                                    ir_if *f2AF9 = new(mem_ctx) ir_if(operand(r2AFA).val);
                                    exec_list *const f2AF9_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2AF9->then_instructions;

                                       ir_variable *const r2AFB = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r2AFB, r2AA8, 0x01));

                                       ir_variable *const r2AFC = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r2AFC, neg(r2AA5), 0x01));

                                       ir_variable *const r2AFD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r2AFD);
                                       ir_variable *const r2AFE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r2AFE);
                                       ir_variable *const r2AFF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r2AFF);
                                       ir_variable *const r2B00 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r2B01 = neg(r2AFC);
                                       body.emit(assign(r2B00, bit_and(r2B01, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2B03 = equal(r2AFC, body.constant(int(0)));
                                       ir_if *f2B02 = new(mem_ctx) ir_if(operand(r2B03).val);
                                       exec_list *const f2B02_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2B02->then_instructions;

                                          body.emit(assign(r2AFD, r2AA8, 0x01));

                                          body.emit(assign(r2AFE, r2AA7, 0x01));

                                          body.emit(assign(r2AFF, r2AA6, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2B02->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2B05 = less(r2AFC, body.constant(int(32)));
                                          ir_if *f2B04 = new(mem_ctx) ir_if(operand(r2B05).val);
                                          exec_list *const f2B04_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2B04->then_instructions;

                                             body.emit(assign(r2AFD, lshift(r2AA7, r2B00), 0x01));

                                             ir_expression *const r2B06 = lshift(r2AA6, r2B00);
                                             ir_expression *const r2B07 = rshift(r2AA7, r2AFC);
                                             body.emit(assign(r2AFE, bit_or(r2B06, r2B07), 0x01));

                                             body.emit(assign(r2AFF, rshift(r2AA6, r2AFC), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2B04->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r2B09 = equal(r2AFC, body.constant(int(32)));
                                             ir_if *f2B08 = new(mem_ctx) ir_if(operand(r2B09).val);
                                             exec_list *const f2B08_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2B08->then_instructions;

                                                body.emit(assign(r2AFD, r2AA7, 0x01));

                                                body.emit(assign(r2AFE, r2AA6, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2B08->else_instructions;

                                                body.emit(assign(r2AFB, bit_or(r2AA8, r2AA7), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r2B0B = less(r2AFC, body.constant(int(64)));
                                                ir_if *f2B0A = new(mem_ctx) ir_if(operand(r2B0B).val);
                                                exec_list *const f2B0A_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2B0A->then_instructions;

                                                   body.emit(assign(r2AFD, lshift(r2AA6, r2B00), 0x01));

                                                   ir_expression *const r2B0C = bit_and(r2AFC, body.constant(int(31)));
                                                   body.emit(assign(r2AFE, rshift(r2AA6, r2B0C), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2B0A->else_instructions;

                                                   ir_variable *const r2B0D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r2B0F = equal(r2AFC, body.constant(int(64)));
                                                   ir_if *f2B0E = new(mem_ctx) ir_if(operand(r2B0F).val);
                                                   exec_list *const f2B0E_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f2B0E->then_instructions;

                                                      body.emit(assign(r2B0D, r2AA6, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f2B0E->else_instructions;

                                                      ir_expression *const r2B10 = nequal(r2AA6, body.constant(0u));
                                                      ir_expression *const r2B11 = expr(ir_unop_b2i, r2B10);
                                                      body.emit(assign(r2B0D, expr(ir_unop_i2u, r2B11), 0x01));


                                                   body.instructions = f2B0E_parent_instructions;
                                                   body.emit(f2B0E);

                                                   /* END IF */

                                                   body.emit(assign(r2AFD, r2B0D, 0x01));

                                                   body.emit(assign(r2AFE, body.constant(0u), 0x01));


                                                body.instructions = f2B0A_parent_instructions;
                                                body.emit(f2B0A);

                                                /* END IF */


                                             body.instructions = f2B08_parent_instructions;
                                             body.emit(f2B08);

                                             /* END IF */

                                             body.emit(assign(r2AFF, body.constant(0u), 0x01));


                                          body.instructions = f2B04_parent_instructions;
                                          body.emit(f2B04);

                                          /* END IF */

                                          ir_expression *const r2B12 = nequal(r2AFB, body.constant(0u));
                                          ir_expression *const r2B13 = expr(ir_unop_b2i, r2B12);
                                          ir_expression *const r2B14 = expr(ir_unop_i2u, r2B13);
                                          body.emit(assign(r2AFD, bit_or(r2AFD, r2B14), 0x01));


                                       body.instructions = f2B02_parent_instructions;
                                       body.emit(f2B02);

                                       /* END IF */

                                       body.emit(assign(r2AE5, r2AFF, 0x01));

                                       body.emit(assign(r2AE6, r2AFE, 0x01));

                                       body.emit(assign(r2AE7, r2AFD, 0x01));

                                       body.emit(assign(r2AE4, body.constant(int(0)), 0x01));

                                       body.emit(assign(r2AEA, less(r2AFD, body.constant(0u)), 0x01));


                                    body.instructions = f2AF9_parent_instructions;
                                    body.emit(f2AF9);

                                    /* END IF */


                                 body.instructions = f2AF6_parent_instructions;
                                 body.emit(f2AF6);

                                 /* END IF */


                              body.instructions = f2AEC_parent_instructions;
                              body.emit(f2AEC);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2B15 = new(mem_ctx) ir_if(operand(r2AE8).val);
                              exec_list *const f2B15_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2B15->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f2B16 = new(mem_ctx) ir_if(operand(r2AEA).val);
                                 exec_list *const f2B16_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2B16->then_instructions;

                                    ir_variable *const r2B17 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r2B17, add(r2AE6, body.constant(1u)), 0x01));

                                    ir_expression *const r2B18 = less(r2B17, r2AE6);
                                    ir_expression *const r2B19 = expr(ir_unop_b2i, r2B18);
                                    ir_expression *const r2B1A = expr(ir_unop_i2u, r2B19);
                                    body.emit(assign(r2AE5, add(r2AE5, r2B1A), 0x01));

                                    ir_expression *const r2B1B = equal(r2AE7, body.constant(0u));
                                    ir_expression *const r2B1C = expr(ir_unop_b2i, r2B1B);
                                    ir_expression *const r2B1D = expr(ir_unop_i2u, r2B1C);
                                    ir_expression *const r2B1E = add(r2AE7, r2B1D);
                                    ir_expression *const r2B1F = bit_and(r2B1E, body.constant(1u));
                                    ir_expression *const r2B20 = expr(ir_unop_bit_not, r2B1F);
                                    body.emit(assign(r2AE6, bit_and(r2B17, r2B20), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2B16->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2B22 = bit_or(r2AE5, r2AE6);
                                    ir_expression *const r2B23 = equal(r2B22, body.constant(0u));
                                    ir_if *f2B21 = new(mem_ctx) ir_if(operand(r2B23).val);
                                    exec_list *const f2B21_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2B21->then_instructions;

                                       body.emit(assign(r2AE4, body.constant(int(0)), 0x01));


                                    body.instructions = f2B21_parent_instructions;
                                    body.emit(f2B21);

                                    /* END IF */


                                 body.instructions = f2B16_parent_instructions;
                                 body.emit(f2B16);

                                 /* END IF */

                                 ir_variable *const r2B24 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2B24);
                                 ir_expression *const r2B25 = lshift(r276F, body.constant(int(31)));
                                 ir_expression *const r2B26 = expr(ir_unop_i2u, r2AE4);
                                 ir_expression *const r2B27 = lshift(r2B26, body.constant(int(20)));
                                 ir_expression *const r2B28 = add(r2B25, r2B27);
                                 body.emit(assign(r2B24, add(r2B28, r2AE5), 0x02));

                                 body.emit(assign(r2B24, r2AE6, 0x01));

                                 body.emit(assign(r2AE9, r2B24, 0x03));

                                 body.emit(assign(r2AE8, body.constant(false), 0x01));


                              body.instructions = f2B15_parent_instructions;
                              body.emit(f2B15);

                              /* END IF */

                              body.emit(assign(r2770, r2AE9, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2A9D->else_instructions;

                              ir_variable *const r2B29 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2B29);
                              body.emit(assign(r2B29, body.constant(0u), 0x02));

                              body.emit(assign(r2B29, body.constant(0u), 0x01));

                              body.emit(assign(r2770, r2B29, 0x03));


                           body.instructions = f2A9D_parent_instructions;
                           body.emit(f2A9D);

                           /* END IF */


                        body.instructions = f2A11_parent_instructions;
                        body.emit(f2A11);

                        /* END IF */


                     body.instructions = f2985_parent_instructions;
                     body.emit(f2985);

                     /* END IF */


                  body.instructions = f28F9_parent_instructions;
                  body.emit(f28F9);

                  /* END IF */


               body.instructions = f28E4_parent_instructions;
               body.emit(f28E4);

               /* END IF */


            body.instructions = f2835_parent_instructions;
            body.emit(f2835);

            /* END IF */


         body.instructions = f2784_parent_instructions;
         body.emit(f2784);

         /* END IF */

         body.emit(assign(r276B, r2770, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f276D->else_instructions;

         ir_variable *const r2B2A = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r2B2A, body.constant(true), 0x01));

         ir_variable *const r2B2B = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2B2C = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2B2C);
         ir_variable *const r2B2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r2B2D);
         ir_variable *const r2B2E = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r2B2E);
         ir_variable *const r2B2F = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r2B2F);
         ir_variable *const r2B30 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r2B30);
         ir_variable *const r2B31 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r2B31);
         ir_variable *const r2B32 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r2B32);
         ir_variable *const r2B33 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r2B33);
         body.emit(assign(r2B33, body.constant(0u), 0x01));

         body.emit(assign(r2B32, body.constant(0u), 0x01));

         ir_variable *const r2B34 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r2B34, swizzle_x(r2736), 0x01));

         body.emit(assign(r2B30, r2B34, 0x01));

         ir_variable *const r2B35 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r2B35, bit_and(swizzle_y(r2736), body.constant(1048575u)), 0x01));

         body.emit(assign(r2B2F, r2B35, 0x01));

         ir_variable *const r2B36 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r2B36, body.constant(0u), 0x01));

         body.emit(assign(r2B2E, body.constant(0u), 0x01));

         body.emit(assign(r2B2D, body.constant(0u), 0x01));

         ir_variable *const r2B37 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r2B38 = rshift(swizzle_y(r2736), body.constant(int(20)));
         ir_expression *const r2B39 = bit_and(r2B38, body.constant(2047u));
         body.emit(assign(r2B37, expr(ir_unop_u2i, r2B39), 0x01));

         ir_variable *const r2B3A = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r2B3A, body.constant(int(1023)), 0x01));

         ir_variable *const r2B3B = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r2B3B, add(r2B37, body.constant(int(-1023))), 0x01));

         body.emit(assign(r2B2C, r2B3B, 0x01));

         /* IF CONDITION */
         ir_expression *const r2B3D = less(body.constant(int(0)), r2B3B);
         ir_if *f2B3C = new(mem_ctx) ir_if(operand(r2B3D).val);
         exec_list *const f2B3C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2B3C->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2B3F = equal(r2B37, body.constant(int(2047)));
            ir_if *f2B3E = new(mem_ctx) ir_if(operand(r2B3F).val);
            exec_list *const f2B3E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2B3E->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2B41 = bit_or(r2B35, swizzle_x(r2736));
               ir_expression *const r2B42 = nequal(r2B41, body.constant(0u));
               ir_if *f2B40 = new(mem_ctx) ir_if(operand(r2B42).val);
               exec_list *const f2B40_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B40->then_instructions;

                  ir_variable *const r2B43 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2B43, swizzle_x(r2736), 0x01));

                  ir_variable *const r2B44 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2B44, body.constant(0u), 0x01));

                  ir_variable *const r2B45 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r2B43, bit_or(swizzle_y(r2736), body.constant(524288u)), 0x02));

                  body.emit(assign(r2B44, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2B47 = lshift(swizzle_y(r2736), body.constant(int(1)));
                  ir_expression *const r2B48 = lequal(body.constant(4292870144u), r2B47);
                  ir_expression *const r2B49 = nequal(swizzle_x(r2736), body.constant(0u));
                  ir_expression *const r2B4A = bit_and(swizzle_y(r2736), body.constant(1048575u));
                  ir_expression *const r2B4B = nequal(r2B4A, body.constant(0u));
                  ir_expression *const r2B4C = logic_or(r2B49, r2B4B);
                  ir_expression *const r2B4D = logic_and(r2B48, r2B4C);
                  ir_if *f2B46 = new(mem_ctx) ir_if(operand(r2B4D).val);
                  exec_list *const f2B46_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B46->then_instructions;

                     body.emit(assign(r2B45, r2B43, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B46->else_instructions;

                     body.emit(assign(r2B45, r2B44, 0x03));


                  body.instructions = f2B46_parent_instructions;
                  body.emit(f2B46);

                  /* END IF */

                  body.emit(assign(r2B2B, r2B45, 0x03));

                  body.emit(assign(r2B2A, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2B40->else_instructions;

                  body.emit(assign(r2B2B, r2736, 0x03));

                  body.emit(assign(r2B2A, body.constant(false), 0x01));


               body.instructions = f2B40_parent_instructions;
               body.emit(f2B40);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2B3E->else_instructions;

               body.emit(assign(r2B2D, body.constant(1048576u), 0x01));

               ir_variable *const r2B4E = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2B4E, body.constant(0u), 0x01));

               ir_variable *const r2B4F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2B4F);
               ir_variable *const r2B50 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2B50);
               ir_variable *const r2B51 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2B51);
               ir_variable *const r2B52 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2B53 = neg(r2B3B);
               body.emit(assign(r2B52, bit_and(r2B53, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2B55 = equal(r2B3B, body.constant(int(0)));
               ir_if *f2B54 = new(mem_ctx) ir_if(operand(r2B55).val);
               exec_list *const f2B54_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B54->then_instructions;

                  body.emit(assign(r2B4F, r2B4E, 0x01));

                  body.emit(assign(r2B50, body.constant(0u), 0x01));

                  body.emit(assign(r2B51, r2B2D, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2B54->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2B57 = less(r2B3B, body.constant(int(32)));
                  ir_if *f2B56 = new(mem_ctx) ir_if(operand(r2B57).val);
                  exec_list *const f2B56_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B56->then_instructions;

                     body.emit(assign(r2B4F, body.constant(0u), 0x01));

                     ir_expression *const r2B58 = lshift(body.constant(1048576u), r2B52);
                     body.emit(assign(r2B50, bit_or(r2B58, body.constant(0u)), 0x01));

                     body.emit(assign(r2B51, rshift(body.constant(1048576u), r2B3B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B56->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2B5A = equal(r2B3B, body.constant(int(32)));
                     ir_if *f2B59 = new(mem_ctx) ir_if(operand(r2B5A).val);
                     exec_list *const f2B59_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B59->then_instructions;

                        body.emit(assign(r2B4F, body.constant(0u), 0x01));

                        body.emit(assign(r2B50, r2B2D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2B59->else_instructions;

                        body.emit(assign(r2B4E, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2B5C = less(r2B3B, body.constant(int(64)));
                        ir_if *f2B5B = new(mem_ctx) ir_if(operand(r2B5C).val);
                        exec_list *const f2B5B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B5B->then_instructions;

                           body.emit(assign(r2B4F, lshift(body.constant(1048576u), r2B52), 0x01));

                           ir_expression *const r2B5D = bit_and(r2B3B, body.constant(int(31)));
                           body.emit(assign(r2B50, rshift(body.constant(1048576u), r2B5D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B5B->else_instructions;

                           ir_variable *const r2B5E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2B60 = equal(r2B3B, body.constant(int(64)));
                           ir_if *f2B5F = new(mem_ctx) ir_if(operand(r2B60).val);
                           exec_list *const f2B5F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B5F->then_instructions;

                              body.emit(assign(r2B5E, r2B2D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B5F->else_instructions;

                              body.emit(assign(r2B5E, body.constant(1u), 0x01));


                           body.instructions = f2B5F_parent_instructions;
                           body.emit(f2B5F);

                           /* END IF */

                           body.emit(assign(r2B4F, r2B5E, 0x01));

                           body.emit(assign(r2B50, body.constant(0u), 0x01));


                        body.instructions = f2B5B_parent_instructions;
                        body.emit(f2B5B);

                        /* END IF */


                     body.instructions = f2B59_parent_instructions;
                     body.emit(f2B59);

                     /* END IF */

                     body.emit(assign(r2B51, body.constant(0u), 0x01));


                  body.instructions = f2B56_parent_instructions;
                  body.emit(f2B56);

                  /* END IF */

                  ir_expression *const r2B61 = nequal(r2B4E, body.constant(0u));
                  ir_expression *const r2B62 = expr(ir_unop_b2i, r2B61);
                  ir_expression *const r2B63 = expr(ir_unop_i2u, r2B62);
                  body.emit(assign(r2B4F, bit_or(r2B4F, r2B63), 0x01));


               body.instructions = f2B54_parent_instructions;
               body.emit(f2B54);

               /* END IF */

               body.emit(assign(r2B2D, r2B51, 0x01));

               body.emit(assign(r2B2E, r2B50, 0x01));

               body.emit(assign(r2B32, r2B4F, 0x01));

               body.emit(assign(r2B31, r2B37, 0x01));


            body.instructions = f2B3E_parent_instructions;
            body.emit(f2B3E);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2B3C->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2B65 = less(r2B3B, body.constant(int(0)));
            ir_if *f2B64 = new(mem_ctx) ir_if(operand(r2B65).val);
            exec_list *const f2B64_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2B64->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2B67 = equal(r2B37, body.constant(int(0)));
               ir_if *f2B66 = new(mem_ctx) ir_if(operand(r2B67).val);
               exec_list *const f2B66_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B66->then_instructions;

                  body.emit(assign(r2B2C, add(r2B3B, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2B66->else_instructions;

                  body.emit(assign(r2B2F, bit_or(r2B35, body.constant(1048576u)), 0x01));


               body.instructions = f2B66_parent_instructions;
               body.emit(f2B66);

               /* END IF */

               ir_variable *const r2B68 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2B68, body.constant(0u), 0x01));

               ir_variable *const r2B69 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2B69, neg(r2B2C), 0x01));

               ir_variable *const r2B6A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2B6A);
               ir_variable *const r2B6B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2B6B);
               ir_variable *const r2B6C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2B6C);
               ir_variable *const r2B6D = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2B6E = neg(r2B69);
               body.emit(assign(r2B6D, bit_and(r2B6E, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2B70 = equal(r2B69, body.constant(int(0)));
               ir_if *f2B6F = new(mem_ctx) ir_if(operand(r2B70).val);
               exec_list *const f2B6F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B6F->then_instructions;

                  body.emit(assign(r2B6A, r2B68, 0x01));

                  body.emit(assign(r2B6B, r2B34, 0x01));

                  body.emit(assign(r2B6C, r2B2F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2B6F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2B72 = less(r2B69, body.constant(int(32)));
                  ir_if *f2B71 = new(mem_ctx) ir_if(operand(r2B72).val);
                  exec_list *const f2B71_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B71->then_instructions;

                     body.emit(assign(r2B6A, lshift(swizzle_x(r2736), r2B6D), 0x01));

                     ir_expression *const r2B73 = lshift(r2B2F, r2B6D);
                     ir_expression *const r2B74 = rshift(swizzle_x(r2736), r2B69);
                     body.emit(assign(r2B6B, bit_or(r2B73, r2B74), 0x01));

                     body.emit(assign(r2B6C, rshift(r2B2F, r2B69), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B71->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2B76 = equal(r2B69, body.constant(int(32)));
                     ir_if *f2B75 = new(mem_ctx) ir_if(operand(r2B76).val);
                     exec_list *const f2B75_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B75->then_instructions;

                        body.emit(assign(r2B6A, r2B34, 0x01));

                        body.emit(assign(r2B6B, r2B2F, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2B75->else_instructions;

                        body.emit(assign(r2B68, bit_or(body.constant(0u), swizzle_x(r2736)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2B78 = less(r2B69, body.constant(int(64)));
                        ir_if *f2B77 = new(mem_ctx) ir_if(operand(r2B78).val);
                        exec_list *const f2B77_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B77->then_instructions;

                           body.emit(assign(r2B6A, lshift(r2B2F, r2B6D), 0x01));

                           ir_expression *const r2B79 = bit_and(r2B69, body.constant(int(31)));
                           body.emit(assign(r2B6B, rshift(r2B2F, r2B79), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B77->else_instructions;

                           ir_variable *const r2B7A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2B7C = equal(r2B69, body.constant(int(64)));
                           ir_if *f2B7B = new(mem_ctx) ir_if(operand(r2B7C).val);
                           exec_list *const f2B7B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B7B->then_instructions;

                              body.emit(assign(r2B7A, r2B2F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B7B->else_instructions;

                              ir_expression *const r2B7D = nequal(r2B2F, body.constant(0u));
                              ir_expression *const r2B7E = expr(ir_unop_b2i, r2B7D);
                              body.emit(assign(r2B7A, expr(ir_unop_i2u, r2B7E), 0x01));


                           body.instructions = f2B7B_parent_instructions;
                           body.emit(f2B7B);

                           /* END IF */

                           body.emit(assign(r2B6A, r2B7A, 0x01));

                           body.emit(assign(r2B6B, body.constant(0u), 0x01));


                        body.instructions = f2B77_parent_instructions;
                        body.emit(f2B77);

                        /* END IF */


                     body.instructions = f2B75_parent_instructions;
                     body.emit(f2B75);

                     /* END IF */

                     body.emit(assign(r2B6C, body.constant(0u), 0x01));


                  body.instructions = f2B71_parent_instructions;
                  body.emit(f2B71);

                  /* END IF */

                  ir_expression *const r2B7F = nequal(r2B68, body.constant(0u));
                  ir_expression *const r2B80 = expr(ir_unop_b2i, r2B7F);
                  ir_expression *const r2B81 = expr(ir_unop_i2u, r2B80);
                  body.emit(assign(r2B6A, bit_or(r2B6A, r2B81), 0x01));


               body.instructions = f2B6F_parent_instructions;
               body.emit(f2B6F);

               /* END IF */

               body.emit(assign(r2B2F, r2B6C, 0x01));

               body.emit(assign(r2B30, r2B6B, 0x01));

               body.emit(assign(r2B32, r2B6A, 0x01));

               body.emit(assign(r2B31, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2B64->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2B83 = equal(r2B37, body.constant(int(2047)));
               ir_if *f2B82 = new(mem_ctx) ir_if(operand(r2B83).val);
               exec_list *const f2B82_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B82->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2B85 = bit_or(r2B2F, r2B30);
                  ir_expression *const r2B86 = bit_or(r2B2D, r2B2E);
                  ir_expression *const r2B87 = bit_or(r2B85, r2B86);
                  ir_expression *const r2B88 = nequal(r2B87, body.constant(0u));
                  ir_if *f2B84 = new(mem_ctx) ir_if(operand(r2B88).val);
                  exec_list *const f2B84_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B84->then_instructions;

                     ir_variable *const r2B89 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r2B89, swizzle_x(r2736), 0x01));

                     ir_variable *const r2B8A = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r2B8A, body.constant(0u), 0x01));

                     ir_variable *const r2B8B = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r2B89, bit_or(swizzle_y(r2736), body.constant(524288u)), 0x02));

                     body.emit(assign(r2B8A, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r2B8D = lshift(swizzle_y(r2736), body.constant(int(1)));
                     ir_expression *const r2B8E = lequal(body.constant(4292870144u), r2B8D);
                     ir_expression *const r2B8F = nequal(swizzle_x(r2736), body.constant(0u));
                     ir_expression *const r2B90 = bit_and(swizzle_y(r2736), body.constant(1048575u));
                     ir_expression *const r2B91 = nequal(r2B90, body.constant(0u));
                     ir_expression *const r2B92 = logic_or(r2B8F, r2B91);
                     ir_expression *const r2B93 = logic_and(r2B8E, r2B92);
                     ir_if *f2B8C = new(mem_ctx) ir_if(operand(r2B93).val);
                     exec_list *const f2B8C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B8C->then_instructions;

                        body.emit(assign(r2B8B, r2B89, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2B8C->else_instructions;

                        body.emit(assign(r2B8B, r2B8A, 0x03));


                     body.instructions = f2B8C_parent_instructions;
                     body.emit(f2B8C);

                     /* END IF */

                     body.emit(assign(r2B2B, r2B8B, 0x03));

                     body.emit(assign(r2B2A, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B84->else_instructions;

                     body.emit(assign(r2B2B, r2736, 0x03));

                     body.emit(assign(r2B2A, body.constant(false), 0x01));


                  body.instructions = f2B84_parent_instructions;
                  body.emit(f2B84);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2B82->else_instructions;

                  ir_variable *const r2B94 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r2B95 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2B95, add(r2B30, r2B2E), 0x01));

                  ir_expression *const r2B96 = add(r2B2F, r2B2D);
                  ir_expression *const r2B97 = less(r2B95, r2B30);
                  ir_expression *const r2B98 = expr(ir_unop_b2i, r2B97);
                  ir_expression *const r2B99 = expr(ir_unop_i2u, r2B98);
                  body.emit(assign(r2B94, add(r2B96, r2B99), 0x01));

                  body.emit(assign(r2B33, r2B94, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2B9B = equal(r2B37, body.constant(int(0)));
                  ir_if *f2B9A = new(mem_ctx) ir_if(operand(r2B9B).val);
                  exec_list *const f2B9A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B9A->then_instructions;

                     ir_variable *const r2B9C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2B9C);
                     ir_expression *const r2B9D = lshift(r276C, body.constant(int(31)));
                     body.emit(assign(r2B9C, add(r2B9D, r2B94), 0x02));

                     body.emit(assign(r2B9C, r2B95, 0x01));

                     body.emit(assign(r2B2B, r2B9C, 0x03));

                     body.emit(assign(r2B2A, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B9A->else_instructions;

                     body.emit(assign(r2B33, bit_or(r2B94, body.constant(2097152u)), 0x01));

                     body.emit(assign(r2B31, r2B37, 0x01));

                     ir_variable *const r2B9E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2B9E);
                     ir_variable *const r2B9F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2B9F);
                     ir_variable *const r2BA0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2BA0);
                     body.emit(assign(r2B9E, lshift(r2B95, body.constant(int(31))), 0x01));

                     ir_expression *const r2BA1 = lshift(r2B33, body.constant(int(31)));
                     ir_expression *const r2BA2 = rshift(r2B95, body.constant(int(1)));
                     body.emit(assign(r2B9F, bit_or(r2BA1, r2BA2), 0x01));

                     body.emit(assign(r2BA0, rshift(r2B33, body.constant(int(1))), 0x01));

                     body.emit(assign(r2B9E, bit_or(r2B9E, body.constant(0u)), 0x01));

                     body.emit(assign(r2B33, r2BA0, 0x01));

                     body.emit(assign(r2B32, r2B9E, 0x01));

                     ir_variable *const r2BA3 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2BA3, r2B37, 0x01));

                     ir_variable *const r2BA4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2BA4, r2BA0, 0x01));

                     ir_variable *const r2BA5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2BA5, r2B9F, 0x01));

                     ir_variable *const r2BA6 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2BA6, r2B9E, 0x01));

                     ir_variable *const r2BA7 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2BA7, body.constant(true), 0x01));

                     ir_variable *const r2BA8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2BA9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2BA9);
                     ir_expression *const r2BAA = expr(ir_unop_u2i, r2B9E);
                     body.emit(assign(r2BA9, less(r2BAA, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2BAC = lequal(body.constant(int(2045)), r2B37);
                     ir_if *f2BAB = new(mem_ctx) ir_if(operand(r2BAC).val);
                     exec_list *const f2BAB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2BAB->then_instructions;

                        ir_variable *const r2BAD = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2BAF = less(body.constant(int(2045)), r2B37);
                        ir_if *f2BAE = new(mem_ctx) ir_if(operand(r2BAF).val);
                        exec_list *const f2BAE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BAE->then_instructions;

                           body.emit(assign(r2BAD, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2BAE->else_instructions;

                           ir_variable *const r2BB0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2BB2 = equal(r2B37, body.constant(int(2045)));
                           ir_if *f2BB1 = new(mem_ctx) ir_if(operand(r2BB2).val);
                           exec_list *const f2BB1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2BB1->then_instructions;

                              ir_expression *const r2BB3 = equal(body.constant(2097151u), r2BA0);
                              ir_expression *const r2BB4 = equal(body.constant(4294967295u), r2B9F);
                              body.emit(assign(r2BB0, logic_and(r2BB3, r2BB4), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2BB1->else_instructions;

                              body.emit(assign(r2BB0, body.constant(false), 0x01));


                           body.instructions = f2BB1_parent_instructions;
                           body.emit(f2BB1);

                           /* END IF */

                           body.emit(assign(r2BAD, logic_and(r2BB0, r2BA9), 0x01));


                        body.instructions = f2BAE_parent_instructions;
                        body.emit(f2BAE);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2BB5 = new(mem_ctx) ir_if(operand(r2BAD).val);
                        exec_list *const f2BB5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BB5->then_instructions;

                           ir_variable *const r2BB6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2BB6);
                           ir_expression *const r2BB7 = lshift(r276C, body.constant(int(31)));
                           body.emit(assign(r2BB6, add(r2BB7, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2BB6, body.constant(0u), 0x01));

                           body.emit(assign(r2BA8, r2BB6, 0x03));

                           body.emit(assign(r2BA7, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2BB5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2BB9 = less(r2B37, body.constant(int(0)));
                           ir_if *f2BB8 = new(mem_ctx) ir_if(operand(r2BB9).val);
                           exec_list *const f2BB8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2BB8->then_instructions;

                              ir_variable *const r2BBA = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2BBA, r2B9E, 0x01));

                              ir_variable *const r2BBB = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2BBB, neg(r2B37), 0x01));

                              ir_variable *const r2BBC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2BBC);
                              ir_variable *const r2BBD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2BBD);
                              ir_variable *const r2BBE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2BBE);
                              ir_variable *const r2BBF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2BC0 = neg(r2BBB);
                              body.emit(assign(r2BBF, bit_and(r2BC0, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2BC2 = equal(r2BBB, body.constant(int(0)));
                              ir_if *f2BC1 = new(mem_ctx) ir_if(operand(r2BC2).val);
                              exec_list *const f2BC1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BC1->then_instructions;

                                 body.emit(assign(r2BBC, r2B9E, 0x01));

                                 body.emit(assign(r2BBD, r2B9F, 0x01));

                                 body.emit(assign(r2BBE, r2BA0, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2BC1->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2BC4 = less(r2BBB, body.constant(int(32)));
                                 ir_if *f2BC3 = new(mem_ctx) ir_if(operand(r2BC4).val);
                                 exec_list *const f2BC3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2BC3->then_instructions;

                                    body.emit(assign(r2BBC, lshift(r2B9F, r2BBF), 0x01));

                                    ir_expression *const r2BC5 = lshift(r2BA0, r2BBF);
                                    ir_expression *const r2BC6 = rshift(r2B9F, r2BBB);
                                    body.emit(assign(r2BBD, bit_or(r2BC5, r2BC6), 0x01));

                                    body.emit(assign(r2BBE, rshift(r2BA0, r2BBB), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2BC3->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2BC8 = equal(r2BBB, body.constant(int(32)));
                                    ir_if *f2BC7 = new(mem_ctx) ir_if(operand(r2BC8).val);
                                    exec_list *const f2BC7_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2BC7->then_instructions;

                                       body.emit(assign(r2BBC, r2B9F, 0x01));

                                       body.emit(assign(r2BBD, r2BA0, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2BC7->else_instructions;

                                       body.emit(assign(r2BBA, bit_or(r2B9E, r2B9F), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2BCA = less(r2BBB, body.constant(int(64)));
                                       ir_if *f2BC9 = new(mem_ctx) ir_if(operand(r2BCA).val);
                                       exec_list *const f2BC9_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2BC9->then_instructions;

                                          body.emit(assign(r2BBC, lshift(r2BA0, r2BBF), 0x01));

                                          ir_expression *const r2BCB = bit_and(r2BBB, body.constant(int(31)));
                                          body.emit(assign(r2BBD, rshift(r2BA0, r2BCB), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2BC9->else_instructions;

                                          ir_variable *const r2BCC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2BCE = equal(r2BBB, body.constant(int(64)));
                                          ir_if *f2BCD = new(mem_ctx) ir_if(operand(r2BCE).val);
                                          exec_list *const f2BCD_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2BCD->then_instructions;

                                             body.emit(assign(r2BCC, r2BA0, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2BCD->else_instructions;

                                             ir_expression *const r2BCF = nequal(r2BA0, body.constant(0u));
                                             ir_expression *const r2BD0 = expr(ir_unop_b2i, r2BCF);
                                             body.emit(assign(r2BCC, expr(ir_unop_i2u, r2BD0), 0x01));


                                          body.instructions = f2BCD_parent_instructions;
                                          body.emit(f2BCD);

                                          /* END IF */

                                          body.emit(assign(r2BBC, r2BCC, 0x01));

                                          body.emit(assign(r2BBD, body.constant(0u), 0x01));


                                       body.instructions = f2BC9_parent_instructions;
                                       body.emit(f2BC9);

                                       /* END IF */


                                    body.instructions = f2BC7_parent_instructions;
                                    body.emit(f2BC7);

                                    /* END IF */

                                    body.emit(assign(r2BBE, body.constant(0u), 0x01));


                                 body.instructions = f2BC3_parent_instructions;
                                 body.emit(f2BC3);

                                 /* END IF */

                                 ir_expression *const r2BD1 = nequal(r2BBA, body.constant(0u));
                                 ir_expression *const r2BD2 = expr(ir_unop_b2i, r2BD1);
                                 ir_expression *const r2BD3 = expr(ir_unop_i2u, r2BD2);
                                 body.emit(assign(r2BBC, bit_or(r2BBC, r2BD3), 0x01));


                              body.instructions = f2BC1_parent_instructions;
                              body.emit(f2BC1);

                              /* END IF */

                              body.emit(assign(r2BA4, r2BBE, 0x01));

                              body.emit(assign(r2BA5, r2BBD, 0x01));

                              body.emit(assign(r2BA6, r2BBC, 0x01));

                              body.emit(assign(r2BA3, body.constant(int(0)), 0x01));

                              body.emit(assign(r2BA9, less(r2BBC, body.constant(0u)), 0x01));


                           body.instructions = f2BB8_parent_instructions;
                           body.emit(f2BB8);

                           /* END IF */


                        body.instructions = f2BB5_parent_instructions;
                        body.emit(f2BB5);

                        /* END IF */


                     body.instructions = f2BAB_parent_instructions;
                     body.emit(f2BAB);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2BD4 = new(mem_ctx) ir_if(operand(r2BA7).val);
                     exec_list *const f2BD4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2BD4->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2BD5 = new(mem_ctx) ir_if(operand(r2BA9).val);
                        exec_list *const f2BD5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BD5->then_instructions;

                           ir_variable *const r2BD6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2BD6, add(r2BA5, body.constant(1u)), 0x01));

                           ir_expression *const r2BD7 = less(r2BD6, r2BA5);
                           ir_expression *const r2BD8 = expr(ir_unop_b2i, r2BD7);
                           ir_expression *const r2BD9 = expr(ir_unop_i2u, r2BD8);
                           body.emit(assign(r2BA4, add(r2BA4, r2BD9), 0x01));

                           ir_expression *const r2BDA = equal(r2BA6, body.constant(0u));
                           ir_expression *const r2BDB = expr(ir_unop_b2i, r2BDA);
                           ir_expression *const r2BDC = expr(ir_unop_i2u, r2BDB);
                           ir_expression *const r2BDD = add(r2BA6, r2BDC);
                           ir_expression *const r2BDE = bit_and(r2BDD, body.constant(1u));
                           ir_expression *const r2BDF = expr(ir_unop_bit_not, r2BDE);
                           body.emit(assign(r2BA5, bit_and(r2BD6, r2BDF), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2BD5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2BE1 = bit_or(r2BA4, r2BA5);
                           ir_expression *const r2BE2 = equal(r2BE1, body.constant(0u));
                           ir_if *f2BE0 = new(mem_ctx) ir_if(operand(r2BE2).val);
                           exec_list *const f2BE0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2BE0->then_instructions;

                              body.emit(assign(r2BA3, body.constant(int(0)), 0x01));


                           body.instructions = f2BE0_parent_instructions;
                           body.emit(f2BE0);

                           /* END IF */


                        body.instructions = f2BD5_parent_instructions;
                        body.emit(f2BD5);

                        /* END IF */

                        ir_variable *const r2BE3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2BE3);
                        ir_expression *const r2BE4 = lshift(r276C, body.constant(int(31)));
                        ir_expression *const r2BE5 = expr(ir_unop_i2u, r2BA3);
                        ir_expression *const r2BE6 = lshift(r2BE5, body.constant(int(20)));
                        ir_expression *const r2BE7 = add(r2BE4, r2BE6);
                        body.emit(assign(r2BE3, add(r2BE7, r2BA4), 0x02));

                        body.emit(assign(r2BE3, r2BA5, 0x01));

                        body.emit(assign(r2BA8, r2BE3, 0x03));

                        body.emit(assign(r2BA7, body.constant(false), 0x01));


                     body.instructions = f2BD4_parent_instructions;
                     body.emit(f2BD4);

                     /* END IF */

                     body.emit(assign(r2B2B, r2BA8, 0x03));

                     body.emit(assign(r2B2A, body.constant(false), 0x01));


                  body.instructions = f2B9A_parent_instructions;
                  body.emit(f2B9A);

                  /* END IF */


               body.instructions = f2B82_parent_instructions;
               body.emit(f2B82);

               /* END IF */


            body.instructions = f2B64_parent_instructions;
            body.emit(f2B64);

            /* END IF */


         body.instructions = f2B3C_parent_instructions;
         body.emit(f2B3C);

         /* END IF */

         /* IF CONDITION */
         ir_if *f2BE8 = new(mem_ctx) ir_if(operand(r2B2A).val);
         exec_list *const f2BE8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2BE8->then_instructions;

            body.emit(assign(r2B2F, bit_or(r2B2F, body.constant(1048576u)), 0x01));

            ir_variable *const r2BE9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r2BEA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r2BEA, add(r2B30, r2B2E), 0x01));

            ir_expression *const r2BEB = add(r2B2F, r2B2D);
            ir_expression *const r2BEC = less(r2BEA, r2B30);
            ir_expression *const r2BED = expr(ir_unop_b2i, r2BEC);
            ir_expression *const r2BEE = expr(ir_unop_i2u, r2BED);
            body.emit(assign(r2BE9, add(r2BEB, r2BEE), 0x01));

            body.emit(assign(r2B33, r2BE9, 0x01));

            body.emit(assign(r2B31, add(r2B31, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2BF0 = less(r2BE9, body.constant(2097152u));
            ir_if *f2BEF = new(mem_ctx) ir_if(operand(r2BF0).val);
            exec_list *const f2BEF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2BEF->then_instructions;

               ir_variable *const r2BF1 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2BF1, r2B31, 0x01));

               ir_variable *const r2BF2 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2BF2, r2BE9, 0x01));

               ir_variable *const r2BF3 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2BF3, r2BEA, 0x01));

               ir_variable *const r2BF4 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2BF4, r2B32, 0x01));

               ir_variable *const r2BF5 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2BF5, body.constant(true), 0x01));

               ir_variable *const r2BF6 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2BF7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2BF7);
               ir_expression *const r2BF8 = expr(ir_unop_u2i, r2B32);
               body.emit(assign(r2BF7, less(r2BF8, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2BFA = lequal(body.constant(int(2045)), r2B31);
               ir_if *f2BF9 = new(mem_ctx) ir_if(operand(r2BFA).val);
               exec_list *const f2BF9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2BF9->then_instructions;

                  ir_variable *const r2BFB = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2BFD = less(body.constant(int(2045)), r2B31);
                  ir_if *f2BFC = new(mem_ctx) ir_if(operand(r2BFD).val);
                  exec_list *const f2BFC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2BFC->then_instructions;

                     body.emit(assign(r2BFB, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2BFC->else_instructions;

                     ir_variable *const r2BFE = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2C00 = equal(r2B31, body.constant(int(2045)));
                     ir_if *f2BFF = new(mem_ctx) ir_if(operand(r2C00).val);
                     exec_list *const f2BFF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2BFF->then_instructions;

                        ir_expression *const r2C01 = equal(body.constant(2097151u), r2BE9);
                        ir_expression *const r2C02 = equal(body.constant(4294967295u), r2BEA);
                        body.emit(assign(r2BFE, logic_and(r2C01, r2C02), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2BFF->else_instructions;

                        body.emit(assign(r2BFE, body.constant(false), 0x01));


                     body.instructions = f2BFF_parent_instructions;
                     body.emit(f2BFF);

                     /* END IF */

                     body.emit(assign(r2BFB, logic_and(r2BFE, r2BF7), 0x01));


                  body.instructions = f2BFC_parent_instructions;
                  body.emit(f2BFC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2C03 = new(mem_ctx) ir_if(operand(r2BFB).val);
                  exec_list *const f2C03_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2C03->then_instructions;

                     ir_variable *const r2C04 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2C04);
                     ir_expression *const r2C05 = lshift(r276C, body.constant(int(31)));
                     body.emit(assign(r2C04, add(r2C05, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2C04, body.constant(0u), 0x01));

                     body.emit(assign(r2BF6, r2C04, 0x03));

                     body.emit(assign(r2BF5, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2C03->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2C07 = less(r2B31, body.constant(int(0)));
                     ir_if *f2C06 = new(mem_ctx) ir_if(operand(r2C07).val);
                     exec_list *const f2C06_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2C06->then_instructions;

                        ir_variable *const r2C08 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2C08, r2B32, 0x01));

                        ir_variable *const r2C09 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2C09, neg(r2B31), 0x01));

                        ir_variable *const r2C0A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2C0A);
                        ir_variable *const r2C0B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2C0B);
                        ir_variable *const r2C0C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2C0C);
                        ir_variable *const r2C0D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2C0E = neg(r2C09);
                        body.emit(assign(r2C0D, bit_and(r2C0E, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2C10 = equal(r2C09, body.constant(int(0)));
                        ir_if *f2C0F = new(mem_ctx) ir_if(operand(r2C10).val);
                        exec_list *const f2C0F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2C0F->then_instructions;

                           body.emit(assign(r2C0A, r2B32, 0x01));

                           body.emit(assign(r2C0B, r2BEA, 0x01));

                           body.emit(assign(r2C0C, r2BE9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2C0F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2C12 = less(r2C09, body.constant(int(32)));
                           ir_if *f2C11 = new(mem_ctx) ir_if(operand(r2C12).val);
                           exec_list *const f2C11_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C11->then_instructions;

                              body.emit(assign(r2C0A, lshift(r2BEA, r2C0D), 0x01));

                              ir_expression *const r2C13 = lshift(r2BE9, r2C0D);
                              ir_expression *const r2C14 = rshift(r2BEA, r2C09);
                              body.emit(assign(r2C0B, bit_or(r2C13, r2C14), 0x01));

                              body.emit(assign(r2C0C, rshift(r2BE9, r2C09), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2C11->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2C16 = equal(r2C09, body.constant(int(32)));
                              ir_if *f2C15 = new(mem_ctx) ir_if(operand(r2C16).val);
                              exec_list *const f2C15_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C15->then_instructions;

                                 body.emit(assign(r2C0A, r2BEA, 0x01));

                                 body.emit(assign(r2C0B, r2BE9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2C15->else_instructions;

                                 body.emit(assign(r2C08, bit_or(r2B32, r2BEA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2C18 = less(r2C09, body.constant(int(64)));
                                 ir_if *f2C17 = new(mem_ctx) ir_if(operand(r2C18).val);
                                 exec_list *const f2C17_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C17->then_instructions;

                                    body.emit(assign(r2C0A, lshift(r2BE9, r2C0D), 0x01));

                                    ir_expression *const r2C19 = bit_and(r2C09, body.constant(int(31)));
                                    body.emit(assign(r2C0B, rshift(r2BE9, r2C19), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2C17->else_instructions;

                                    ir_variable *const r2C1A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2C1C = equal(r2C09, body.constant(int(64)));
                                    ir_if *f2C1B = new(mem_ctx) ir_if(operand(r2C1C).val);
                                    exec_list *const f2C1B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2C1B->then_instructions;

                                       body.emit(assign(r2C1A, r2BE9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2C1B->else_instructions;

                                       ir_expression *const r2C1D = nequal(r2BE9, body.constant(0u));
                                       ir_expression *const r2C1E = expr(ir_unop_b2i, r2C1D);
                                       body.emit(assign(r2C1A, expr(ir_unop_i2u, r2C1E), 0x01));


                                    body.instructions = f2C1B_parent_instructions;
                                    body.emit(f2C1B);

                                    /* END IF */

                                    body.emit(assign(r2C0A, r2C1A, 0x01));

                                    body.emit(assign(r2C0B, body.constant(0u), 0x01));


                                 body.instructions = f2C17_parent_instructions;
                                 body.emit(f2C17);

                                 /* END IF */


                              body.instructions = f2C15_parent_instructions;
                              body.emit(f2C15);

                              /* END IF */

                              body.emit(assign(r2C0C, body.constant(0u), 0x01));


                           body.instructions = f2C11_parent_instructions;
                           body.emit(f2C11);

                           /* END IF */

                           ir_expression *const r2C1F = nequal(r2C08, body.constant(0u));
                           ir_expression *const r2C20 = expr(ir_unop_b2i, r2C1F);
                           ir_expression *const r2C21 = expr(ir_unop_i2u, r2C20);
                           body.emit(assign(r2C0A, bit_or(r2C0A, r2C21), 0x01));


                        body.instructions = f2C0F_parent_instructions;
                        body.emit(f2C0F);

                        /* END IF */

                        body.emit(assign(r2BF2, r2C0C, 0x01));

                        body.emit(assign(r2BF3, r2C0B, 0x01));

                        body.emit(assign(r2BF4, r2C0A, 0x01));

                        body.emit(assign(r2BF1, body.constant(int(0)), 0x01));

                        body.emit(assign(r2BF7, less(r2C0A, body.constant(0u)), 0x01));


                     body.instructions = f2C06_parent_instructions;
                     body.emit(f2C06);

                     /* END IF */


                  body.instructions = f2C03_parent_instructions;
                  body.emit(f2C03);

                  /* END IF */


               body.instructions = f2BF9_parent_instructions;
               body.emit(f2BF9);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2C22 = new(mem_ctx) ir_if(operand(r2BF5).val);
               exec_list *const f2C22_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2C22->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2C23 = new(mem_ctx) ir_if(operand(r2BF7).val);
                  exec_list *const f2C23_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2C23->then_instructions;

                     ir_variable *const r2C24 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2C24, add(r2BF3, body.constant(1u)), 0x01));

                     ir_expression *const r2C25 = less(r2C24, r2BF3);
                     ir_expression *const r2C26 = expr(ir_unop_b2i, r2C25);
                     ir_expression *const r2C27 = expr(ir_unop_i2u, r2C26);
                     body.emit(assign(r2BF2, add(r2BF2, r2C27), 0x01));

                     ir_expression *const r2C28 = equal(r2BF4, body.constant(0u));
                     ir_expression *const r2C29 = expr(ir_unop_b2i, r2C28);
                     ir_expression *const r2C2A = expr(ir_unop_i2u, r2C29);
                     ir_expression *const r2C2B = add(r2BF4, r2C2A);
                     ir_expression *const r2C2C = bit_and(r2C2B, body.constant(1u));
                     ir_expression *const r2C2D = expr(ir_unop_bit_not, r2C2C);
                     body.emit(assign(r2BF3, bit_and(r2C24, r2C2D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2C23->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2C2F = bit_or(r2BF2, r2BF3);
                     ir_expression *const r2C30 = equal(r2C2F, body.constant(0u));
                     ir_if *f2C2E = new(mem_ctx) ir_if(operand(r2C30).val);
                     exec_list *const f2C2E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2C2E->then_instructions;

                        body.emit(assign(r2BF1, body.constant(int(0)), 0x01));


                     body.instructions = f2C2E_parent_instructions;
                     body.emit(f2C2E);

                     /* END IF */


                  body.instructions = f2C23_parent_instructions;
                  body.emit(f2C23);

                  /* END IF */

                  ir_variable *const r2C31 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2C31);
                  ir_expression *const r2C32 = lshift(r276C, body.constant(int(31)));
                  ir_expression *const r2C33 = expr(ir_unop_i2u, r2BF1);
                  ir_expression *const r2C34 = lshift(r2C33, body.constant(int(20)));
                  ir_expression *const r2C35 = add(r2C32, r2C34);
                  body.emit(assign(r2C31, add(r2C35, r2BF2), 0x02));

                  body.emit(assign(r2C31, r2BF3, 0x01));

                  body.emit(assign(r2BF6, r2C31, 0x03));

                  body.emit(assign(r2BF5, body.constant(false), 0x01));


               body.instructions = f2C22_parent_instructions;
               body.emit(f2C22);

               /* END IF */

               body.emit(assign(r2B2B, r2BF6, 0x03));

               body.emit(assign(r2B2A, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2BEF->else_instructions;

               body.emit(assign(r2B31, add(r2B31, body.constant(int(1))), 0x01));

               ir_variable *const r2C36 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2C36);
               ir_variable *const r2C37 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2C37);
               ir_variable *const r2C38 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2C38);
               body.emit(assign(r2C36, lshift(r2BEA, body.constant(int(31))), 0x01));

               ir_expression *const r2C39 = lshift(r2BE9, body.constant(int(31)));
               ir_expression *const r2C3A = rshift(r2BEA, body.constant(int(1)));
               body.emit(assign(r2C37, bit_or(r2C39, r2C3A), 0x01));

               body.emit(assign(r2C38, rshift(r2BE9, body.constant(int(1))), 0x01));

               ir_expression *const r2C3B = nequal(r2B32, body.constant(0u));
               ir_expression *const r2C3C = expr(ir_unop_b2i, r2C3B);
               ir_expression *const r2C3D = expr(ir_unop_i2u, r2C3C);
               body.emit(assign(r2C36, bit_or(r2C36, r2C3D), 0x01));

               body.emit(assign(r2B33, r2C38, 0x01));

               body.emit(assign(r2B32, r2C36, 0x01));

               ir_variable *const r2C3E = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2C3E, r2B31, 0x01));

               ir_variable *const r2C3F = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2C3F, r2C38, 0x01));

               ir_variable *const r2C40 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2C40, r2C37, 0x01));

               ir_variable *const r2C41 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2C41, r2C36, 0x01));

               ir_variable *const r2C42 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2C42, body.constant(true), 0x01));

               ir_variable *const r2C43 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2C44 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2C44);
               ir_expression *const r2C45 = expr(ir_unop_u2i, r2C36);
               body.emit(assign(r2C44, less(r2C45, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2C47 = lequal(body.constant(int(2045)), r2B31);
               ir_if *f2C46 = new(mem_ctx) ir_if(operand(r2C47).val);
               exec_list *const f2C46_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2C46->then_instructions;

                  ir_variable *const r2C48 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2C4A = less(body.constant(int(2045)), r2B31);
                  ir_if *f2C49 = new(mem_ctx) ir_if(operand(r2C4A).val);
                  exec_list *const f2C49_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2C49->then_instructions;

                     body.emit(assign(r2C48, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2C49->else_instructions;

                     ir_variable *const r2C4B = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2C4D = equal(r2B31, body.constant(int(2045)));
                     ir_if *f2C4C = new(mem_ctx) ir_if(operand(r2C4D).val);
                     exec_list *const f2C4C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2C4C->then_instructions;

                        ir_expression *const r2C4E = equal(body.constant(2097151u), r2C38);
                        ir_expression *const r2C4F = equal(body.constant(4294967295u), r2C37);
                        body.emit(assign(r2C4B, logic_and(r2C4E, r2C4F), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2C4C->else_instructions;

                        body.emit(assign(r2C4B, body.constant(false), 0x01));


                     body.instructions = f2C4C_parent_instructions;
                     body.emit(f2C4C);

                     /* END IF */

                     body.emit(assign(r2C48, logic_and(r2C4B, r2C44), 0x01));


                  body.instructions = f2C49_parent_instructions;
                  body.emit(f2C49);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2C50 = new(mem_ctx) ir_if(operand(r2C48).val);
                  exec_list *const f2C50_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2C50->then_instructions;

                     ir_variable *const r2C51 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2C51);
                     ir_expression *const r2C52 = lshift(r276C, body.constant(int(31)));
                     body.emit(assign(r2C51, add(r2C52, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2C51, body.constant(0u), 0x01));

                     body.emit(assign(r2C43, r2C51, 0x03));

                     body.emit(assign(r2C42, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2C50->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2C54 = less(r2B31, body.constant(int(0)));
                     ir_if *f2C53 = new(mem_ctx) ir_if(operand(r2C54).val);
                     exec_list *const f2C53_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2C53->then_instructions;

                        ir_variable *const r2C55 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2C55, r2C36, 0x01));

                        ir_variable *const r2C56 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2C56, neg(r2B31), 0x01));

                        ir_variable *const r2C57 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2C57);
                        ir_variable *const r2C58 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2C58);
                        ir_variable *const r2C59 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2C59);
                        ir_variable *const r2C5A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2C5B = neg(r2C56);
                        body.emit(assign(r2C5A, bit_and(r2C5B, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2C5D = equal(r2C56, body.constant(int(0)));
                        ir_if *f2C5C = new(mem_ctx) ir_if(operand(r2C5D).val);
                        exec_list *const f2C5C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2C5C->then_instructions;

                           body.emit(assign(r2C57, r2C36, 0x01));

                           body.emit(assign(r2C58, r2C37, 0x01));

                           body.emit(assign(r2C59, r2C38, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2C5C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2C5F = less(r2C56, body.constant(int(32)));
                           ir_if *f2C5E = new(mem_ctx) ir_if(operand(r2C5F).val);
                           exec_list *const f2C5E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C5E->then_instructions;

                              body.emit(assign(r2C57, lshift(r2C37, r2C5A), 0x01));

                              ir_expression *const r2C60 = lshift(r2C38, r2C5A);
                              ir_expression *const r2C61 = rshift(r2C37, r2C56);
                              body.emit(assign(r2C58, bit_or(r2C60, r2C61), 0x01));

                              body.emit(assign(r2C59, rshift(r2C38, r2C56), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2C5E->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2C63 = equal(r2C56, body.constant(int(32)));
                              ir_if *f2C62 = new(mem_ctx) ir_if(operand(r2C63).val);
                              exec_list *const f2C62_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C62->then_instructions;

                                 body.emit(assign(r2C57, r2C37, 0x01));

                                 body.emit(assign(r2C58, r2C38, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2C62->else_instructions;

                                 body.emit(assign(r2C55, bit_or(r2C36, r2C37), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2C65 = less(r2C56, body.constant(int(64)));
                                 ir_if *f2C64 = new(mem_ctx) ir_if(operand(r2C65).val);
                                 exec_list *const f2C64_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C64->then_instructions;

                                    body.emit(assign(r2C57, lshift(r2C38, r2C5A), 0x01));

                                    ir_expression *const r2C66 = bit_and(r2C56, body.constant(int(31)));
                                    body.emit(assign(r2C58, rshift(r2C38, r2C66), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2C64->else_instructions;

                                    ir_variable *const r2C67 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2C69 = equal(r2C56, body.constant(int(64)));
                                    ir_if *f2C68 = new(mem_ctx) ir_if(operand(r2C69).val);
                                    exec_list *const f2C68_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2C68->then_instructions;

                                       body.emit(assign(r2C67, r2C38, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2C68->else_instructions;

                                       ir_expression *const r2C6A = nequal(r2C38, body.constant(0u));
                                       ir_expression *const r2C6B = expr(ir_unop_b2i, r2C6A);
                                       body.emit(assign(r2C67, expr(ir_unop_i2u, r2C6B), 0x01));


                                    body.instructions = f2C68_parent_instructions;
                                    body.emit(f2C68);

                                    /* END IF */

                                    body.emit(assign(r2C57, r2C67, 0x01));

                                    body.emit(assign(r2C58, body.constant(0u), 0x01));


                                 body.instructions = f2C64_parent_instructions;
                                 body.emit(f2C64);

                                 /* END IF */


                              body.instructions = f2C62_parent_instructions;
                              body.emit(f2C62);

                              /* END IF */

                              body.emit(assign(r2C59, body.constant(0u), 0x01));


                           body.instructions = f2C5E_parent_instructions;
                           body.emit(f2C5E);

                           /* END IF */

                           ir_expression *const r2C6C = nequal(r2C55, body.constant(0u));
                           ir_expression *const r2C6D = expr(ir_unop_b2i, r2C6C);
                           ir_expression *const r2C6E = expr(ir_unop_i2u, r2C6D);
                           body.emit(assign(r2C57, bit_or(r2C57, r2C6E), 0x01));


                        body.instructions = f2C5C_parent_instructions;
                        body.emit(f2C5C);

                        /* END IF */

                        body.emit(assign(r2C3F, r2C59, 0x01));

                        body.emit(assign(r2C40, r2C58, 0x01));

                        body.emit(assign(r2C41, r2C57, 0x01));

                        body.emit(assign(r2C3E, body.constant(int(0)), 0x01));

                        body.emit(assign(r2C44, less(r2C57, body.constant(0u)), 0x01));


                     body.instructions = f2C53_parent_instructions;
                     body.emit(f2C53);

                     /* END IF */


                  body.instructions = f2C50_parent_instructions;
                  body.emit(f2C50);

                  /* END IF */


               body.instructions = f2C46_parent_instructions;
               body.emit(f2C46);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2C6F = new(mem_ctx) ir_if(operand(r2C42).val);
               exec_list *const f2C6F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2C6F->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2C70 = new(mem_ctx) ir_if(operand(r2C44).val);
                  exec_list *const f2C70_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2C70->then_instructions;

                     ir_variable *const r2C71 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2C71, add(r2C40, body.constant(1u)), 0x01));

                     ir_expression *const r2C72 = less(r2C71, r2C40);
                     ir_expression *const r2C73 = expr(ir_unop_b2i, r2C72);
                     ir_expression *const r2C74 = expr(ir_unop_i2u, r2C73);
                     body.emit(assign(r2C3F, add(r2C3F, r2C74), 0x01));

                     ir_expression *const r2C75 = equal(r2C41, body.constant(0u));
                     ir_expression *const r2C76 = expr(ir_unop_b2i, r2C75);
                     ir_expression *const r2C77 = expr(ir_unop_i2u, r2C76);
                     ir_expression *const r2C78 = add(r2C41, r2C77);
                     ir_expression *const r2C79 = bit_and(r2C78, body.constant(1u));
                     ir_expression *const r2C7A = expr(ir_unop_bit_not, r2C79);
                     body.emit(assign(r2C40, bit_and(r2C71, r2C7A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2C70->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2C7C = bit_or(r2C3F, r2C40);
                     ir_expression *const r2C7D = equal(r2C7C, body.constant(0u));
                     ir_if *f2C7B = new(mem_ctx) ir_if(operand(r2C7D).val);
                     exec_list *const f2C7B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2C7B->then_instructions;

                        body.emit(assign(r2C3E, body.constant(int(0)), 0x01));


                     body.instructions = f2C7B_parent_instructions;
                     body.emit(f2C7B);

                     /* END IF */


                  body.instructions = f2C70_parent_instructions;
                  body.emit(f2C70);

                  /* END IF */

                  ir_variable *const r2C7E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2C7E);
                  ir_expression *const r2C7F = lshift(r276C, body.constant(int(31)));
                  ir_expression *const r2C80 = expr(ir_unop_i2u, r2C3E);
                  ir_expression *const r2C81 = lshift(r2C80, body.constant(int(20)));
                  ir_expression *const r2C82 = add(r2C7F, r2C81);
                  body.emit(assign(r2C7E, add(r2C82, r2C3F), 0x02));

                  body.emit(assign(r2C7E, r2C40, 0x01));

                  body.emit(assign(r2C43, r2C7E, 0x03));

                  body.emit(assign(r2C42, body.constant(false), 0x01));


               body.instructions = f2C6F_parent_instructions;
               body.emit(f2C6F);

               /* END IF */

               body.emit(assign(r2B2B, r2C43, 0x03));

               body.emit(assign(r2B2A, body.constant(false), 0x01));


            body.instructions = f2BEF_parent_instructions;
            body.emit(f2BEF);

            /* END IF */


         body.instructions = f2BE8_parent_instructions;
         body.emit(f2BE8);

         /* END IF */

         body.emit(assign(r276B, r2B2B, 0x03));


      body.instructions = f276D_parent_instructions;
      body.emit(f276D);

      /* END IF */

      body.emit(assign(r2769, r276B, 0x03));


   body.instructions = f276A_parent_instructions;
   body.emit(f276A);

   /* END IF */

   ir_variable *const r2C83 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r2C84 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r2C84, rshift(swizzle_y(r2735), body.constant(int(31))), 0x01));

   ir_variable *const r2C85 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r2C85, rshift(swizzle_y(r2769), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r2C87 = equal(r2C84, r2C85);
   ir_if *f2C86 = new(mem_ctx) ir_if(operand(r2C87).val);
   exec_list *const f2C86_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f2C86->then_instructions;

      ir_variable *const r2C88 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r2C88, r2C84, 0x01));

      ir_variable *const r2C89 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r2C8A = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r2C8A);
      ir_variable *const r2C8B = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r2C8B);
      ir_variable *const r2C8C = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r2C8C);
      ir_variable *const r2C8D = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r2C8D);
      ir_variable *const r2C8E = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r2C8E);
      ir_variable *const r2C8F = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r2C8F);
      ir_variable *const r2C90 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r2C90);
      ir_variable *const r2C91 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r2C91);
      ir_variable *const r2C92 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r2C93 = rshift(swizzle_y(r2735), body.constant(int(20)));
      ir_expression *const r2C94 = bit_and(r2C93, body.constant(2047u));
      body.emit(assign(r2C92, expr(ir_unop_u2i, r2C94), 0x01));

      body.emit(assign(r2C8C, r2C92, 0x01));

      ir_variable *const r2C95 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r2C96 = rshift(swizzle_y(r2769), body.constant(int(20)));
      ir_expression *const r2C97 = bit_and(r2C96, body.constant(2047u));
      body.emit(assign(r2C95, expr(ir_unop_u2i, r2C97), 0x01));

      body.emit(assign(r2C8B, r2C95, 0x01));

      body.emit(assign(r2C8A, sub(r2C92, r2C95), 0x01));

      ir_variable *const r2C98 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r2C98, lshift(swizzle_x(r2735), body.constant(int(10))), 0x01));

      ir_variable *const r2C99 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r2C9A = bit_and(swizzle_y(r2735), body.constant(1048575u));
      ir_expression *const r2C9B = lshift(r2C9A, body.constant(int(10)));
      ir_expression *const r2C9C = rshift(swizzle_x(r2735), body.constant(int(22)));
      body.emit(assign(r2C99, bit_or(r2C9B, r2C9C), 0x01));

      body.emit(assign(r2C8F, r2C99, 0x01));

      body.emit(assign(r2C90, r2C98, 0x01));

      ir_variable *const r2C9D = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r2C9D, lshift(swizzle_x(r2769), body.constant(int(10))), 0x01));

      ir_variable *const r2C9E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r2C9F = bit_and(swizzle_y(r2769), body.constant(1048575u));
      ir_expression *const r2CA0 = lshift(r2C9F, body.constant(int(10)));
      ir_expression *const r2CA1 = rshift(swizzle_x(r2769), body.constant(int(22)));
      body.emit(assign(r2C9E, bit_or(r2CA0, r2CA1), 0x01));

      body.emit(assign(r2C8D, r2C9E, 0x01));

      body.emit(assign(r2C8E, r2C9D, 0x01));

      /* IF CONDITION */
      ir_expression *const r2CA3 = less(body.constant(int(0)), r2C8A);
      ir_if *f2CA2 = new(mem_ctx) ir_if(operand(r2CA3).val);
      exec_list *const f2CA2_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2CA2->then_instructions;

         /* IF CONDITION */
         ir_expression *const r2CA5 = equal(r2C92, body.constant(int(2047)));
         ir_if *f2CA4 = new(mem_ctx) ir_if(operand(r2CA5).val);
         exec_list *const f2CA4_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2CA4->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2CA7 = bit_or(r2C99, r2C98);
            ir_expression *const r2CA8 = nequal(r2CA7, body.constant(0u));
            ir_if *f2CA6 = new(mem_ctx) ir_if(operand(r2CA8).val);
            exec_list *const f2CA6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2CA6->then_instructions;

               ir_variable *const r2CA9 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r2CA9, swizzle_x(r2735), 0x01));

               ir_variable *const r2CAA = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r2CAA, swizzle_x(r2769), 0x01));

               ir_variable *const r2CAB = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2CAC = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r2CAD = rshift(swizzle_y(r2735), body.constant(int(19)));
               ir_expression *const r2CAE = bit_and(r2CAD, body.constant(4095u));
               ir_expression *const r2CAF = equal(r2CAE, body.constant(4094u));
               ir_expression *const r2CB0 = nequal(swizzle_x(r2735), body.constant(0u));
               ir_expression *const r2CB1 = bit_and(swizzle_y(r2735), body.constant(524287u));
               ir_expression *const r2CB2 = nequal(r2CB1, body.constant(0u));
               ir_expression *const r2CB3 = logic_or(r2CB0, r2CB2);
               body.emit(assign(r2CAC, logic_and(r2CAF, r2CB3), 0x01));

               ir_variable *const r2CB4 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r2CB5 = lshift(swizzle_y(r2769), body.constant(int(1)));
               ir_expression *const r2CB6 = lequal(body.constant(4292870144u), r2CB5);
               ir_expression *const r2CB7 = nequal(swizzle_x(r2769), body.constant(0u));
               ir_expression *const r2CB8 = bit_and(swizzle_y(r2769), body.constant(1048575u));
               ir_expression *const r2CB9 = nequal(r2CB8, body.constant(0u));
               ir_expression *const r2CBA = logic_or(r2CB7, r2CB9);
               body.emit(assign(r2CB4, logic_and(r2CB6, r2CBA), 0x01));

               body.emit(assign(r2CA9, bit_or(swizzle_y(r2735), body.constant(524288u)), 0x02));

               body.emit(assign(r2CAA, bit_or(swizzle_y(r2769), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r2CBC = lshift(swizzle_y(r2735), body.constant(int(1)));
               ir_expression *const r2CBD = lequal(body.constant(4292870144u), r2CBC);
               ir_expression *const r2CBE = nequal(swizzle_x(r2735), body.constant(0u));
               ir_expression *const r2CBF = bit_and(swizzle_y(r2735), body.constant(1048575u));
               ir_expression *const r2CC0 = nequal(r2CBF, body.constant(0u));
               ir_expression *const r2CC1 = logic_or(r2CBE, r2CC0);
               ir_expression *const r2CC2 = logic_and(r2CBD, r2CC1);
               ir_if *f2CBB = new(mem_ctx) ir_if(operand(r2CC2).val);
               exec_list *const f2CBB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CBB->then_instructions;

                  ir_variable *const r2CC3 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2CC5 = logic_and(r2CAC, r2CB4);
                  ir_if *f2CC4 = new(mem_ctx) ir_if(operand(r2CC5).val);
                  exec_list *const f2CC4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2CC4->then_instructions;

                     body.emit(assign(r2CC3, r2CAA, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2CC4->else_instructions;

                     body.emit(assign(r2CC3, r2CA9, 0x03));


                  body.instructions = f2CC4_parent_instructions;
                  body.emit(f2CC4);

                  /* END IF */

                  body.emit(assign(r2CAB, r2CC3, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2CBB->else_instructions;

                  body.emit(assign(r2CAB, r2CAA, 0x03));


               body.instructions = f2CBB_parent_instructions;
               body.emit(f2CBB);

               /* END IF */

               body.emit(assign(r2C89, r2CAB, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2CA6->else_instructions;

               body.emit(assign(r2C89, r2735, 0x03));


            body.instructions = f2CA6_parent_instructions;
            body.emit(f2CA6);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2CA4->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2CC7 = equal(r2C95, body.constant(int(0)));
            ir_if *f2CC6 = new(mem_ctx) ir_if(operand(r2CC7).val);
            exec_list *const f2CC6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2CC6->then_instructions;

               body.emit(assign(r2C8A, add(r2C8A, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2CC6->else_instructions;

               body.emit(assign(r2C8D, bit_or(r2C9E, body.constant(1073741824u)), 0x01));


            body.instructions = f2CC6_parent_instructions;
            body.emit(f2CC6);

            /* END IF */

            ir_variable *const r2CC8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r2CC8);
            ir_variable *const r2CC9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r2CC9);
            ir_variable *const r2CCA = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r2CCB = neg(r2C8A);
            body.emit(assign(r2CCA, bit_and(r2CCB, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2CCD = equal(r2C8A, body.constant(int(0)));
            ir_if *f2CCC = new(mem_ctx) ir_if(operand(r2CCD).val);
            exec_list *const f2CCC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2CCC->then_instructions;

               body.emit(assign(r2CC8, r2C9D, 0x01));

               body.emit(assign(r2CC9, r2C8D, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2CCC->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2CCF = less(r2C8A, body.constant(int(32)));
               ir_if *f2CCE = new(mem_ctx) ir_if(operand(r2CCF).val);
               exec_list *const f2CCE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CCE->then_instructions;

                  ir_expression *const r2CD0 = lshift(r2C8D, r2CCA);
                  ir_expression *const r2CD1 = rshift(r2C9D, r2C8A);
                  ir_expression *const r2CD2 = bit_or(r2CD0, r2CD1);
                  ir_expression *const r2CD3 = lshift(r2C9D, r2CCA);
                  ir_expression *const r2CD4 = nequal(r2CD3, body.constant(0u));
                  ir_expression *const r2CD5 = expr(ir_unop_b2i, r2CD4);
                  ir_expression *const r2CD6 = expr(ir_unop_i2u, r2CD5);
                  body.emit(assign(r2CC8, bit_or(r2CD2, r2CD6), 0x01));

                  body.emit(assign(r2CC9, rshift(r2C8D, r2C8A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2CCE->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2CD8 = equal(r2C8A, body.constant(int(32)));
                  ir_if *f2CD7 = new(mem_ctx) ir_if(operand(r2CD8).val);
                  exec_list *const f2CD7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2CD7->then_instructions;

                     ir_expression *const r2CD9 = nequal(r2C9D, body.constant(0u));
                     ir_expression *const r2CDA = expr(ir_unop_b2i, r2CD9);
                     ir_expression *const r2CDB = expr(ir_unop_i2u, r2CDA);
                     body.emit(assign(r2CC8, bit_or(r2C8D, r2CDB), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2CD7->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2CDD = less(r2C8A, body.constant(int(64)));
                     ir_if *f2CDC = new(mem_ctx) ir_if(operand(r2CDD).val);
                     exec_list *const f2CDC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2CDC->then_instructions;

                        ir_expression *const r2CDE = bit_and(r2C8A, body.constant(int(31)));
                        ir_expression *const r2CDF = rshift(r2C8D, r2CDE);
                        ir_expression *const r2CE0 = lshift(r2C8D, r2CCA);
                        ir_expression *const r2CE1 = bit_or(r2CE0, r2C9D);
                        ir_expression *const r2CE2 = nequal(r2CE1, body.constant(0u));
                        ir_expression *const r2CE3 = expr(ir_unop_b2i, r2CE2);
                        ir_expression *const r2CE4 = expr(ir_unop_i2u, r2CE3);
                        body.emit(assign(r2CC8, bit_or(r2CDF, r2CE4), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2CDC->else_instructions;

                        ir_expression *const r2CE5 = bit_or(r2C8D, r2C9D);
                        ir_expression *const r2CE6 = nequal(r2CE5, body.constant(0u));
                        ir_expression *const r2CE7 = expr(ir_unop_b2i, r2CE6);
                        body.emit(assign(r2CC8, expr(ir_unop_i2u, r2CE7), 0x01));


                     body.instructions = f2CDC_parent_instructions;
                     body.emit(f2CDC);

                     /* END IF */


                  body.instructions = f2CD7_parent_instructions;
                  body.emit(f2CD7);

                  /* END IF */

                  body.emit(assign(r2CC9, body.constant(0u), 0x01));


               body.instructions = f2CCE_parent_instructions;
               body.emit(f2CCE);

               /* END IF */


            body.instructions = f2CCC_parent_instructions;
            body.emit(f2CCC);

            /* END IF */

            body.emit(assign(r2C8D, r2CC9, 0x01));

            body.emit(assign(r2C8E, r2CC8, 0x01));

            body.emit(assign(r2C8F, bit_or(r2C99, body.constant(1073741824u)), 0x01));

            ir_variable *const r2CE8 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r2CE9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r2CE9, sub(r2C98, r2CC8), 0x01));

            ir_expression *const r2CEA = sub(r2C8F, r2CC9);
            ir_expression *const r2CEB = less(r2C98, r2CC8);
            ir_expression *const r2CEC = expr(ir_unop_b2i, r2CEB);
            ir_expression *const r2CED = expr(ir_unop_i2u, r2CEC);
            body.emit(assign(r2CE8, sub(r2CEA, r2CED), 0x01));

            body.emit(assign(r2C91, add(r2C92, body.constant(int(-1))), 0x01));

            ir_variable *const r2CEE = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r2CEE, add(r2C91, body.constant(int(-10))), 0x01));

            ir_variable *const r2CEF = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r2CEF, r2CE8, 0x01));

            ir_variable *const r2CF0 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r2CF0, r2CE9, 0x01));

            ir_variable *const r2CF1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r2CF1);
            ir_variable *const r2CF2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r2CF2);
            /* IF CONDITION */
            ir_expression *const r2CF4 = equal(r2CE8, body.constant(0u));
            ir_if *f2CF3 = new(mem_ctx) ir_if(operand(r2CF4).val);
            exec_list *const f2CF3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2CF3->then_instructions;

               body.emit(assign(r2CEF, r2CE9, 0x01));

               body.emit(assign(r2CF0, body.constant(0u), 0x01));

               body.emit(assign(r2CEE, add(r2CEE, body.constant(int(-32))), 0x01));


            body.instructions = f2CF3_parent_instructions;
            body.emit(f2CF3);

            /* END IF */

            ir_variable *const r2CF5 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r2CF5, r2CEF, 0x01));

            ir_variable *const r2CF6 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r2CF7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r2CF7);
            /* IF CONDITION */
            ir_expression *const r2CF9 = equal(r2CEF, body.constant(0u));
            ir_if *f2CF8 = new(mem_ctx) ir_if(operand(r2CF9).val);
            exec_list *const f2CF8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2CF8->then_instructions;

               body.emit(assign(r2CF6, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2CF8->else_instructions;

               body.emit(assign(r2CF7, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r2CFB = bit_and(r2CEF, body.constant(4294901760u));
               ir_expression *const r2CFC = equal(r2CFB, body.constant(0u));
               ir_if *f2CFA = new(mem_ctx) ir_if(operand(r2CFC).val);
               exec_list *const f2CFA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CFA->then_instructions;

                  body.emit(assign(r2CF7, body.constant(int(16)), 0x01));

                  body.emit(assign(r2CF5, lshift(r2CEF, body.constant(int(16))), 0x01));


               body.instructions = f2CFA_parent_instructions;
               body.emit(f2CFA);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2CFE = bit_and(r2CF5, body.constant(4278190080u));
               ir_expression *const r2CFF = equal(r2CFE, body.constant(0u));
               ir_if *f2CFD = new(mem_ctx) ir_if(operand(r2CFF).val);
               exec_list *const f2CFD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CFD->then_instructions;

                  body.emit(assign(r2CF7, add(r2CF7, body.constant(int(8))), 0x01));

                  body.emit(assign(r2CF5, lshift(r2CF5, body.constant(int(8))), 0x01));


               body.instructions = f2CFD_parent_instructions;
               body.emit(f2CFD);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2D01 = bit_and(r2CF5, body.constant(4026531840u));
               ir_expression *const r2D02 = equal(r2D01, body.constant(0u));
               ir_if *f2D00 = new(mem_ctx) ir_if(operand(r2D02).val);
               exec_list *const f2D00_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D00->then_instructions;

                  body.emit(assign(r2CF7, add(r2CF7, body.constant(int(4))), 0x01));

                  body.emit(assign(r2CF5, lshift(r2CF5, body.constant(int(4))), 0x01));


               body.instructions = f2D00_parent_instructions;
               body.emit(f2D00);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2D04 = bit_and(r2CF5, body.constant(3221225472u));
               ir_expression *const r2D05 = equal(r2D04, body.constant(0u));
               ir_if *f2D03 = new(mem_ctx) ir_if(operand(r2D05).val);
               exec_list *const f2D03_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D03->then_instructions;

                  body.emit(assign(r2CF7, add(r2CF7, body.constant(int(2))), 0x01));

                  body.emit(assign(r2CF5, lshift(r2CF5, body.constant(int(2))), 0x01));


               body.instructions = f2D03_parent_instructions;
               body.emit(f2D03);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2D07 = bit_and(r2CF5, body.constant(2147483648u));
               ir_expression *const r2D08 = equal(r2D07, body.constant(0u));
               ir_if *f2D06 = new(mem_ctx) ir_if(operand(r2D08).val);
               exec_list *const f2D06_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D06->then_instructions;

                  body.emit(assign(r2CF7, add(r2CF7, body.constant(int(1))), 0x01));


               body.instructions = f2D06_parent_instructions;
               body.emit(f2D06);

               /* END IF */

               body.emit(assign(r2CF6, r2CF7, 0x01));


            body.instructions = f2CF8_parent_instructions;
            body.emit(f2CF8);

            /* END IF */

            body.emit(assign(r2CF2, add(r2CF6, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2D0A = lequal(body.constant(int(0)), r2CF2);
            ir_if *f2D09 = new(mem_ctx) ir_if(operand(r2D0A).val);
            exec_list *const f2D09_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2D09->then_instructions;

               body.emit(assign(r2CF1, body.constant(0u), 0x01));

               ir_variable *const r2D0B = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2D0B, lshift(r2CF0, r2CF2), 0x01));

               ir_variable *const r2D0C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r2D0E = equal(r2CF2, body.constant(int(0)));
               ir_if *f2D0D = new(mem_ctx) ir_if(operand(r2D0E).val);
               exec_list *const f2D0D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D0D->then_instructions;

                  body.emit(assign(r2D0C, r2CEF, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D0D->else_instructions;

                  ir_expression *const r2D0F = lshift(r2CEF, r2CF2);
                  ir_expression *const r2D10 = neg(r2CF2);
                  ir_expression *const r2D11 = bit_and(r2D10, body.constant(int(31)));
                  ir_expression *const r2D12 = rshift(r2CF0, r2D11);
                  body.emit(assign(r2D0C, bit_or(r2D0F, r2D12), 0x01));


               body.instructions = f2D0D_parent_instructions;
               body.emit(f2D0D);

               /* END IF */

               body.emit(assign(r2CEF, r2D0C, 0x01));

               body.emit(assign(r2CF0, r2D0B, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2D09->else_instructions;

               ir_variable *const r2D13 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2D13, body.constant(0u), 0x01));

               ir_variable *const r2D14 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2D14, neg(r2CF2), 0x01));

               ir_variable *const r2D15 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2D15);
               ir_variable *const r2D16 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2D16);
               ir_variable *const r2D17 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2D17);
               ir_variable *const r2D18 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2D19 = neg(r2D14);
               body.emit(assign(r2D18, bit_and(r2D19, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2D1B = equal(r2D14, body.constant(int(0)));
               ir_if *f2D1A = new(mem_ctx) ir_if(operand(r2D1B).val);
               exec_list *const f2D1A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D1A->then_instructions;

                  body.emit(assign(r2D15, r2D13, 0x01));

                  body.emit(assign(r2D16, r2CF0, 0x01));

                  body.emit(assign(r2D17, r2CEF, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D1A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2D1D = less(r2D14, body.constant(int(32)));
                  ir_if *f2D1C = new(mem_ctx) ir_if(operand(r2D1D).val);
                  exec_list *const f2D1C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D1C->then_instructions;

                     body.emit(assign(r2D15, lshift(r2CF0, r2D18), 0x01));

                     ir_expression *const r2D1E = lshift(r2CEF, r2D18);
                     ir_expression *const r2D1F = rshift(r2CF0, r2D14);
                     body.emit(assign(r2D16, bit_or(r2D1E, r2D1F), 0x01));

                     body.emit(assign(r2D17, rshift(r2CEF, r2D14), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2D1C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2D21 = equal(r2D14, body.constant(int(32)));
                     ir_if *f2D20 = new(mem_ctx) ir_if(operand(r2D21).val);
                     exec_list *const f2D20_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D20->then_instructions;

                        body.emit(assign(r2D15, r2CF0, 0x01));

                        body.emit(assign(r2D16, r2CEF, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2D20->else_instructions;

                        body.emit(assign(r2D13, bit_or(body.constant(0u), r2CF0), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2D23 = less(r2D14, body.constant(int(64)));
                        ir_if *f2D22 = new(mem_ctx) ir_if(operand(r2D23).val);
                        exec_list *const f2D22_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2D22->then_instructions;

                           body.emit(assign(r2D15, lshift(r2CEF, r2D18), 0x01));

                           ir_expression *const r2D24 = bit_and(r2D14, body.constant(int(31)));
                           body.emit(assign(r2D16, rshift(r2CEF, r2D24), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2D22->else_instructions;

                           ir_variable *const r2D25 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2D27 = equal(r2D14, body.constant(int(64)));
                           ir_if *f2D26 = new(mem_ctx) ir_if(operand(r2D27).val);
                           exec_list *const f2D26_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2D26->then_instructions;

                              body.emit(assign(r2D25, r2CEF, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2D26->else_instructions;

                              ir_expression *const r2D28 = nequal(r2CEF, body.constant(0u));
                              ir_expression *const r2D29 = expr(ir_unop_b2i, r2D28);
                              body.emit(assign(r2D25, expr(ir_unop_i2u, r2D29), 0x01));


                           body.instructions = f2D26_parent_instructions;
                           body.emit(f2D26);

                           /* END IF */

                           body.emit(assign(r2D15, r2D25, 0x01));

                           body.emit(assign(r2D16, body.constant(0u), 0x01));


                        body.instructions = f2D22_parent_instructions;
                        body.emit(f2D22);

                        /* END IF */


                     body.instructions = f2D20_parent_instructions;
                     body.emit(f2D20);

                     /* END IF */

                     body.emit(assign(r2D17, body.constant(0u), 0x01));


                  body.instructions = f2D1C_parent_instructions;
                  body.emit(f2D1C);

                  /* END IF */

                  ir_expression *const r2D2A = nequal(r2D13, body.constant(0u));
                  ir_expression *const r2D2B = expr(ir_unop_b2i, r2D2A);
                  ir_expression *const r2D2C = expr(ir_unop_i2u, r2D2B);
                  body.emit(assign(r2D15, bit_or(r2D15, r2D2C), 0x01));


               body.instructions = f2D1A_parent_instructions;
               body.emit(f2D1A);

               /* END IF */

               body.emit(assign(r2CEF, r2D17, 0x01));

               body.emit(assign(r2CF0, r2D16, 0x01));

               body.emit(assign(r2CF1, r2D15, 0x01));


            body.instructions = f2D09_parent_instructions;
            body.emit(f2D09);

            /* END IF */

            body.emit(assign(r2CEE, sub(r2CEE, r2CF2), 0x01));

            ir_variable *const r2D2D = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r2D2D, r2CEE, 0x01));

            ir_variable *const r2D2E = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r2D2E, r2CEF, 0x01));

            ir_variable *const r2D2F = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r2D2F, r2CF0, 0x01));

            ir_variable *const r2D30 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r2D30, r2CF1, 0x01));

            ir_variable *const r2D31 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r2D31, body.constant(true), 0x01));

            ir_variable *const r2D32 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r2D33 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r2D33);
            ir_expression *const r2D34 = expr(ir_unop_u2i, r2CF1);
            body.emit(assign(r2D33, less(r2D34, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2D36 = lequal(body.constant(int(2045)), r2CEE);
            ir_if *f2D35 = new(mem_ctx) ir_if(operand(r2D36).val);
            exec_list *const f2D35_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2D35->then_instructions;

               ir_variable *const r2D37 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r2D39 = less(body.constant(int(2045)), r2CEE);
               ir_if *f2D38 = new(mem_ctx) ir_if(operand(r2D39).val);
               exec_list *const f2D38_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D38->then_instructions;

                  body.emit(assign(r2D37, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D38->else_instructions;

                  ir_variable *const r2D3A = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2D3C = equal(r2CEE, body.constant(int(2045)));
                  ir_if *f2D3B = new(mem_ctx) ir_if(operand(r2D3C).val);
                  exec_list *const f2D3B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D3B->then_instructions;

                     ir_expression *const r2D3D = equal(body.constant(2097151u), r2CEF);
                     ir_expression *const r2D3E = equal(body.constant(4294967295u), r2CF0);
                     body.emit(assign(r2D3A, logic_and(r2D3D, r2D3E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2D3B->else_instructions;

                     body.emit(assign(r2D3A, body.constant(false), 0x01));


                  body.instructions = f2D3B_parent_instructions;
                  body.emit(f2D3B);

                  /* END IF */

                  body.emit(assign(r2D37, logic_and(r2D3A, r2D33), 0x01));


               body.instructions = f2D38_parent_instructions;
               body.emit(f2D38);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2D3F = new(mem_ctx) ir_if(operand(r2D37).val);
               exec_list *const f2D3F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D3F->then_instructions;

                  ir_variable *const r2D40 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2D40);
                  ir_expression *const r2D41 = lshift(r2C84, body.constant(int(31)));
                  body.emit(assign(r2D40, add(r2D41, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r2D40, body.constant(0u), 0x01));

                  body.emit(assign(r2D32, r2D40, 0x03));

                  body.emit(assign(r2D31, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D3F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2D43 = less(r2CEE, body.constant(int(0)));
                  ir_if *f2D42 = new(mem_ctx) ir_if(operand(r2D43).val);
                  exec_list *const f2D42_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D42->then_instructions;

                     ir_variable *const r2D44 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r2D44, r2CF1, 0x01));

                     ir_variable *const r2D45 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r2D45, neg(r2CEE), 0x01));

                     ir_variable *const r2D46 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2D46);
                     ir_variable *const r2D47 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2D47);
                     ir_variable *const r2D48 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2D48);
                     ir_variable *const r2D49 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r2D4A = neg(r2D45);
                     body.emit(assign(r2D49, bit_and(r2D4A, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2D4C = equal(r2D45, body.constant(int(0)));
                     ir_if *f2D4B = new(mem_ctx) ir_if(operand(r2D4C).val);
                     exec_list *const f2D4B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D4B->then_instructions;

                        body.emit(assign(r2D46, r2CF1, 0x01));

                        body.emit(assign(r2D47, r2CF0, 0x01));

                        body.emit(assign(r2D48, r2CEF, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2D4B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2D4E = less(r2D45, body.constant(int(32)));
                        ir_if *f2D4D = new(mem_ctx) ir_if(operand(r2D4E).val);
                        exec_list *const f2D4D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2D4D->then_instructions;

                           body.emit(assign(r2D46, lshift(r2CF0, r2D49), 0x01));

                           ir_expression *const r2D4F = lshift(r2CEF, r2D49);
                           ir_expression *const r2D50 = rshift(r2CF0, r2D45);
                           body.emit(assign(r2D47, bit_or(r2D4F, r2D50), 0x01));

                           body.emit(assign(r2D48, rshift(r2CEF, r2D45), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2D4D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2D52 = equal(r2D45, body.constant(int(32)));
                           ir_if *f2D51 = new(mem_ctx) ir_if(operand(r2D52).val);
                           exec_list *const f2D51_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2D51->then_instructions;

                              body.emit(assign(r2D46, r2CF0, 0x01));

                              body.emit(assign(r2D47, r2CEF, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2D51->else_instructions;

                              body.emit(assign(r2D44, bit_or(r2CF1, r2CF0), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2D54 = less(r2D45, body.constant(int(64)));
                              ir_if *f2D53 = new(mem_ctx) ir_if(operand(r2D54).val);
                              exec_list *const f2D53_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2D53->then_instructions;

                                 body.emit(assign(r2D46, lshift(r2CEF, r2D49), 0x01));

                                 ir_expression *const r2D55 = bit_and(r2D45, body.constant(int(31)));
                                 body.emit(assign(r2D47, rshift(r2CEF, r2D55), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2D53->else_instructions;

                                 ir_variable *const r2D56 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2D58 = equal(r2D45, body.constant(int(64)));
                                 ir_if *f2D57 = new(mem_ctx) ir_if(operand(r2D58).val);
                                 exec_list *const f2D57_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2D57->then_instructions;

                                    body.emit(assign(r2D56, r2CEF, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2D57->else_instructions;

                                    ir_expression *const r2D59 = nequal(r2CEF, body.constant(0u));
                                    ir_expression *const r2D5A = expr(ir_unop_b2i, r2D59);
                                    body.emit(assign(r2D56, expr(ir_unop_i2u, r2D5A), 0x01));


                                 body.instructions = f2D57_parent_instructions;
                                 body.emit(f2D57);

                                 /* END IF */

                                 body.emit(assign(r2D46, r2D56, 0x01));

                                 body.emit(assign(r2D47, body.constant(0u), 0x01));


                              body.instructions = f2D53_parent_instructions;
                              body.emit(f2D53);

                              /* END IF */


                           body.instructions = f2D51_parent_instructions;
                           body.emit(f2D51);

                           /* END IF */

                           body.emit(assign(r2D48, body.constant(0u), 0x01));


                        body.instructions = f2D4D_parent_instructions;
                        body.emit(f2D4D);

                        /* END IF */

                        ir_expression *const r2D5B = nequal(r2D44, body.constant(0u));
                        ir_expression *const r2D5C = expr(ir_unop_b2i, r2D5B);
                        ir_expression *const r2D5D = expr(ir_unop_i2u, r2D5C);
                        body.emit(assign(r2D46, bit_or(r2D46, r2D5D), 0x01));


                     body.instructions = f2D4B_parent_instructions;
                     body.emit(f2D4B);

                     /* END IF */

                     body.emit(assign(r2D2E, r2D48, 0x01));

                     body.emit(assign(r2D2F, r2D47, 0x01));

                     body.emit(assign(r2D30, r2D46, 0x01));

                     body.emit(assign(r2D2D, body.constant(int(0)), 0x01));

                     body.emit(assign(r2D33, less(r2D46, body.constant(0u)), 0x01));


                  body.instructions = f2D42_parent_instructions;
                  body.emit(f2D42);

                  /* END IF */


               body.instructions = f2D3F_parent_instructions;
               body.emit(f2D3F);

               /* END IF */


            body.instructions = f2D35_parent_instructions;
            body.emit(f2D35);

            /* END IF */

            /* IF CONDITION */
            ir_if *f2D5E = new(mem_ctx) ir_if(operand(r2D31).val);
            exec_list *const f2D5E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2D5E->then_instructions;

               /* IF CONDITION */
               ir_if *f2D5F = new(mem_ctx) ir_if(operand(r2D33).val);
               exec_list *const f2D5F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D5F->then_instructions;

                  ir_variable *const r2D60 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2D60, add(r2D2F, body.constant(1u)), 0x01));

                  ir_expression *const r2D61 = less(r2D60, r2D2F);
                  ir_expression *const r2D62 = expr(ir_unop_b2i, r2D61);
                  ir_expression *const r2D63 = expr(ir_unop_i2u, r2D62);
                  body.emit(assign(r2D2E, add(r2D2E, r2D63), 0x01));

                  ir_expression *const r2D64 = equal(r2D30, body.constant(0u));
                  ir_expression *const r2D65 = expr(ir_unop_b2i, r2D64);
                  ir_expression *const r2D66 = expr(ir_unop_i2u, r2D65);
                  ir_expression *const r2D67 = add(r2D30, r2D66);
                  ir_expression *const r2D68 = bit_and(r2D67, body.constant(1u));
                  ir_expression *const r2D69 = expr(ir_unop_bit_not, r2D68);
                  body.emit(assign(r2D2F, bit_and(r2D60, r2D69), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D5F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2D6B = bit_or(r2D2E, r2D2F);
                  ir_expression *const r2D6C = equal(r2D6B, body.constant(0u));
                  ir_if *f2D6A = new(mem_ctx) ir_if(operand(r2D6C).val);
                  exec_list *const f2D6A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D6A->then_instructions;

                     body.emit(assign(r2D2D, body.constant(int(0)), 0x01));


                  body.instructions = f2D6A_parent_instructions;
                  body.emit(f2D6A);

                  /* END IF */


               body.instructions = f2D5F_parent_instructions;
               body.emit(f2D5F);

               /* END IF */

               ir_variable *const r2D6D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r2D6D);
               ir_expression *const r2D6E = lshift(r2C84, body.constant(int(31)));
               ir_expression *const r2D6F = expr(ir_unop_i2u, r2D2D);
               ir_expression *const r2D70 = lshift(r2D6F, body.constant(int(20)));
               ir_expression *const r2D71 = add(r2D6E, r2D70);
               body.emit(assign(r2D6D, add(r2D71, r2D2E), 0x02));

               body.emit(assign(r2D6D, r2D2F, 0x01));

               body.emit(assign(r2D32, r2D6D, 0x03));

               body.emit(assign(r2D31, body.constant(false), 0x01));


            body.instructions = f2D5E_parent_instructions;
            body.emit(f2D5E);

            /* END IF */

            body.emit(assign(r2C89, r2D32, 0x03));


         body.instructions = f2CA4_parent_instructions;
         body.emit(f2CA4);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2CA2->else_instructions;

         /* IF CONDITION */
         ir_expression *const r2D73 = less(r2C8A, body.constant(int(0)));
         ir_if *f2D72 = new(mem_ctx) ir_if(operand(r2D73).val);
         exec_list *const f2D72_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2D72->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2D75 = equal(r2C95, body.constant(int(2047)));
            ir_if *f2D74 = new(mem_ctx) ir_if(operand(r2D75).val);
            exec_list *const f2D74_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2D74->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2D77 = bit_or(r2C8D, r2C8E);
               ir_expression *const r2D78 = nequal(r2D77, body.constant(0u));
               ir_if *f2D76 = new(mem_ctx) ir_if(operand(r2D78).val);
               exec_list *const f2D76_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D76->then_instructions;

                  ir_variable *const r2D79 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2D79, swizzle_x(r2735), 0x01));

                  ir_variable *const r2D7A = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2D7A, swizzle_x(r2769), 0x01));

                  ir_variable *const r2D7B = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2D7C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r2D7D = rshift(swizzle_y(r2735), body.constant(int(19)));
                  ir_expression *const r2D7E = bit_and(r2D7D, body.constant(4095u));
                  ir_expression *const r2D7F = equal(r2D7E, body.constant(4094u));
                  ir_expression *const r2D80 = nequal(swizzle_x(r2735), body.constant(0u));
                  ir_expression *const r2D81 = bit_and(swizzle_y(r2735), body.constant(524287u));
                  ir_expression *const r2D82 = nequal(r2D81, body.constant(0u));
                  ir_expression *const r2D83 = logic_or(r2D80, r2D82);
                  body.emit(assign(r2D7C, logic_and(r2D7F, r2D83), 0x01));

                  ir_variable *const r2D84 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r2D85 = lshift(swizzle_y(r2769), body.constant(int(1)));
                  ir_expression *const r2D86 = lequal(body.constant(4292870144u), r2D85);
                  ir_expression *const r2D87 = nequal(swizzle_x(r2769), body.constant(0u));
                  ir_expression *const r2D88 = bit_and(swizzle_y(r2769), body.constant(1048575u));
                  ir_expression *const r2D89 = nequal(r2D88, body.constant(0u));
                  ir_expression *const r2D8A = logic_or(r2D87, r2D89);
                  body.emit(assign(r2D84, logic_and(r2D86, r2D8A), 0x01));

                  body.emit(assign(r2D79, bit_or(swizzle_y(r2735), body.constant(524288u)), 0x02));

                  body.emit(assign(r2D7A, bit_or(swizzle_y(r2769), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2D8C = lshift(swizzle_y(r2735), body.constant(int(1)));
                  ir_expression *const r2D8D = lequal(body.constant(4292870144u), r2D8C);
                  ir_expression *const r2D8E = nequal(swizzle_x(r2735), body.constant(0u));
                  ir_expression *const r2D8F = bit_and(swizzle_y(r2735), body.constant(1048575u));
                  ir_expression *const r2D90 = nequal(r2D8F, body.constant(0u));
                  ir_expression *const r2D91 = logic_or(r2D8E, r2D90);
                  ir_expression *const r2D92 = logic_and(r2D8D, r2D91);
                  ir_if *f2D8B = new(mem_ctx) ir_if(operand(r2D92).val);
                  exec_list *const f2D8B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D8B->then_instructions;

                     ir_variable *const r2D93 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2D95 = logic_and(r2D7C, r2D84);
                     ir_if *f2D94 = new(mem_ctx) ir_if(operand(r2D95).val);
                     exec_list *const f2D94_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D94->then_instructions;

                        body.emit(assign(r2D93, r2D7A, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2D94->else_instructions;

                        body.emit(assign(r2D93, r2D79, 0x03));


                     body.instructions = f2D94_parent_instructions;
                     body.emit(f2D94);

                     /* END IF */

                     body.emit(assign(r2D7B, r2D93, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2D8B->else_instructions;

                     body.emit(assign(r2D7B, r2D7A, 0x03));


                  body.instructions = f2D8B_parent_instructions;
                  body.emit(f2D8B);

                  /* END IF */

                  body.emit(assign(r2C89, r2D7B, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D76->else_instructions;

                  ir_variable *const r2D96 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2D96);
                  ir_expression *const r2D97 = bit_xor(r2C84, body.constant(1u));
                  ir_expression *const r2D98 = lshift(r2D97, body.constant(int(31)));
                  body.emit(assign(r2D96, add(r2D98, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r2D96, body.constant(0u), 0x01));

                  body.emit(assign(r2C89, r2D96, 0x03));


               body.instructions = f2D76_parent_instructions;
               body.emit(f2D76);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2D74->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2D9A = equal(r2C92, body.constant(int(0)));
               ir_if *f2D99 = new(mem_ctx) ir_if(operand(r2D9A).val);
               exec_list *const f2D99_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D99->then_instructions;

                  body.emit(assign(r2C8A, add(r2C8A, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D99->else_instructions;

                  body.emit(assign(r2C8F, bit_or(r2C8F, body.constant(1073741824u)), 0x01));


               body.instructions = f2D99_parent_instructions;
               body.emit(f2D99);

               /* END IF */

               ir_variable *const r2D9B = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2D9B, neg(r2C8A), 0x01));

               ir_variable *const r2D9C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2D9C);
               ir_variable *const r2D9D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2D9D);
               ir_variable *const r2D9E = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2D9F = neg(r2D9B);
               body.emit(assign(r2D9E, bit_and(r2D9F, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2DA1 = equal(r2D9B, body.constant(int(0)));
               ir_if *f2DA0 = new(mem_ctx) ir_if(operand(r2DA1).val);
               exec_list *const f2DA0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DA0->then_instructions;

                  body.emit(assign(r2D9C, r2C98, 0x01));

                  body.emit(assign(r2D9D, r2C8F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2DA0->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2DA3 = less(r2D9B, body.constant(int(32)));
                  ir_if *f2DA2 = new(mem_ctx) ir_if(operand(r2DA3).val);
                  exec_list *const f2DA2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DA2->then_instructions;

                     ir_expression *const r2DA4 = lshift(r2C8F, r2D9E);
                     ir_expression *const r2DA5 = rshift(r2C98, r2D9B);
                     ir_expression *const r2DA6 = bit_or(r2DA4, r2DA5);
                     ir_expression *const r2DA7 = lshift(r2C98, r2D9E);
                     ir_expression *const r2DA8 = nequal(r2DA7, body.constant(0u));
                     ir_expression *const r2DA9 = expr(ir_unop_b2i, r2DA8);
                     ir_expression *const r2DAA = expr(ir_unop_i2u, r2DA9);
                     body.emit(assign(r2D9C, bit_or(r2DA6, r2DAA), 0x01));

                     body.emit(assign(r2D9D, rshift(r2C8F, r2D9B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DA2->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2DAC = equal(r2D9B, body.constant(int(32)));
                     ir_if *f2DAB = new(mem_ctx) ir_if(operand(r2DAC).val);
                     exec_list *const f2DAB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DAB->then_instructions;

                        ir_expression *const r2DAD = nequal(r2C98, body.constant(0u));
                        ir_expression *const r2DAE = expr(ir_unop_b2i, r2DAD);
                        ir_expression *const r2DAF = expr(ir_unop_i2u, r2DAE);
                        body.emit(assign(r2D9C, bit_or(r2C8F, r2DAF), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2DAB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2DB1 = less(r2D9B, body.constant(int(64)));
                        ir_if *f2DB0 = new(mem_ctx) ir_if(operand(r2DB1).val);
                        exec_list *const f2DB0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2DB0->then_instructions;

                           ir_expression *const r2DB2 = bit_and(r2D9B, body.constant(int(31)));
                           ir_expression *const r2DB3 = rshift(r2C8F, r2DB2);
                           ir_expression *const r2DB4 = lshift(r2C8F, r2D9E);
                           ir_expression *const r2DB5 = bit_or(r2DB4, r2C98);
                           ir_expression *const r2DB6 = nequal(r2DB5, body.constant(0u));
                           ir_expression *const r2DB7 = expr(ir_unop_b2i, r2DB6);
                           ir_expression *const r2DB8 = expr(ir_unop_i2u, r2DB7);
                           body.emit(assign(r2D9C, bit_or(r2DB3, r2DB8), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2DB0->else_instructions;

                           ir_expression *const r2DB9 = bit_or(r2C8F, r2C98);
                           ir_expression *const r2DBA = nequal(r2DB9, body.constant(0u));
                           ir_expression *const r2DBB = expr(ir_unop_b2i, r2DBA);
                           body.emit(assign(r2D9C, expr(ir_unop_i2u, r2DBB), 0x01));


                        body.instructions = f2DB0_parent_instructions;
                        body.emit(f2DB0);

                        /* END IF */


                     body.instructions = f2DAB_parent_instructions;
                     body.emit(f2DAB);

                     /* END IF */

                     body.emit(assign(r2D9D, body.constant(0u), 0x01));


                  body.instructions = f2DA2_parent_instructions;
                  body.emit(f2DA2);

                  /* END IF */


               body.instructions = f2DA0_parent_instructions;
               body.emit(f2DA0);

               /* END IF */

               body.emit(assign(r2C8F, r2D9D, 0x01));

               body.emit(assign(r2C90, r2D9C, 0x01));

               body.emit(assign(r2C8D, bit_or(r2C8D, body.constant(1073741824u)), 0x01));

               ir_variable *const r2DBC = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r2DBD = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2DBD, sub(r2C8E, r2D9C), 0x01));

               ir_expression *const r2DBE = sub(r2C8D, r2D9D);
               ir_expression *const r2DBF = less(r2C8E, r2D9C);
               ir_expression *const r2DC0 = expr(ir_unop_b2i, r2DBF);
               ir_expression *const r2DC1 = expr(ir_unop_i2u, r2DC0);
               body.emit(assign(r2DBC, sub(r2DBE, r2DC1), 0x01));

               body.emit(assign(r2C88, bit_xor(r2C84, body.constant(1u)), 0x01));

               body.emit(assign(r2C91, add(r2C95, body.constant(int(-1))), 0x01));

               ir_variable *const r2DC2 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2DC2, add(r2C91, body.constant(int(-10))), 0x01));

               ir_variable *const r2DC3 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2DC3, r2DBC, 0x01));

               ir_variable *const r2DC4 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2DC4, r2DBD, 0x01));

               ir_variable *const r2DC5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2DC5);
               ir_variable *const r2DC6 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2DC6);
               /* IF CONDITION */
               ir_expression *const r2DC8 = equal(r2DBC, body.constant(0u));
               ir_if *f2DC7 = new(mem_ctx) ir_if(operand(r2DC8).val);
               exec_list *const f2DC7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DC7->then_instructions;

                  body.emit(assign(r2DC3, r2DBD, 0x01));

                  body.emit(assign(r2DC4, body.constant(0u), 0x01));

                  body.emit(assign(r2DC2, add(r2DC2, body.constant(int(-32))), 0x01));


               body.instructions = f2DC7_parent_instructions;
               body.emit(f2DC7);

               /* END IF */

               ir_variable *const r2DC9 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2DC9, r2DC3, 0x01));

               ir_variable *const r2DCA = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r2DCB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2DCB);
               /* IF CONDITION */
               ir_expression *const r2DCD = equal(r2DC3, body.constant(0u));
               ir_if *f2DCC = new(mem_ctx) ir_if(operand(r2DCD).val);
               exec_list *const f2DCC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DCC->then_instructions;

                  body.emit(assign(r2DCA, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2DCC->else_instructions;

                  body.emit(assign(r2DCB, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2DCF = bit_and(r2DC3, body.constant(4294901760u));
                  ir_expression *const r2DD0 = equal(r2DCF, body.constant(0u));
                  ir_if *f2DCE = new(mem_ctx) ir_if(operand(r2DD0).val);
                  exec_list *const f2DCE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DCE->then_instructions;

                     body.emit(assign(r2DCB, body.constant(int(16)), 0x01));

                     body.emit(assign(r2DC9, lshift(r2DC3, body.constant(int(16))), 0x01));


                  body.instructions = f2DCE_parent_instructions;
                  body.emit(f2DCE);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2DD2 = bit_and(r2DC9, body.constant(4278190080u));
                  ir_expression *const r2DD3 = equal(r2DD2, body.constant(0u));
                  ir_if *f2DD1 = new(mem_ctx) ir_if(operand(r2DD3).val);
                  exec_list *const f2DD1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DD1->then_instructions;

                     body.emit(assign(r2DCB, add(r2DCB, body.constant(int(8))), 0x01));

                     body.emit(assign(r2DC9, lshift(r2DC9, body.constant(int(8))), 0x01));


                  body.instructions = f2DD1_parent_instructions;
                  body.emit(f2DD1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2DD5 = bit_and(r2DC9, body.constant(4026531840u));
                  ir_expression *const r2DD6 = equal(r2DD5, body.constant(0u));
                  ir_if *f2DD4 = new(mem_ctx) ir_if(operand(r2DD6).val);
                  exec_list *const f2DD4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DD4->then_instructions;

                     body.emit(assign(r2DCB, add(r2DCB, body.constant(int(4))), 0x01));

                     body.emit(assign(r2DC9, lshift(r2DC9, body.constant(int(4))), 0x01));


                  body.instructions = f2DD4_parent_instructions;
                  body.emit(f2DD4);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2DD8 = bit_and(r2DC9, body.constant(3221225472u));
                  ir_expression *const r2DD9 = equal(r2DD8, body.constant(0u));
                  ir_if *f2DD7 = new(mem_ctx) ir_if(operand(r2DD9).val);
                  exec_list *const f2DD7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DD7->then_instructions;

                     body.emit(assign(r2DCB, add(r2DCB, body.constant(int(2))), 0x01));

                     body.emit(assign(r2DC9, lshift(r2DC9, body.constant(int(2))), 0x01));


                  body.instructions = f2DD7_parent_instructions;
                  body.emit(f2DD7);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2DDB = bit_and(r2DC9, body.constant(2147483648u));
                  ir_expression *const r2DDC = equal(r2DDB, body.constant(0u));
                  ir_if *f2DDA = new(mem_ctx) ir_if(operand(r2DDC).val);
                  exec_list *const f2DDA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DDA->then_instructions;

                     body.emit(assign(r2DCB, add(r2DCB, body.constant(int(1))), 0x01));


                  body.instructions = f2DDA_parent_instructions;
                  body.emit(f2DDA);

                  /* END IF */

                  body.emit(assign(r2DCA, r2DCB, 0x01));


               body.instructions = f2DCC_parent_instructions;
               body.emit(f2DCC);

               /* END IF */

               body.emit(assign(r2DC6, add(r2DCA, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2DDE = lequal(body.constant(int(0)), r2DC6);
               ir_if *f2DDD = new(mem_ctx) ir_if(operand(r2DDE).val);
               exec_list *const f2DDD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DDD->then_instructions;

                  body.emit(assign(r2DC5, body.constant(0u), 0x01));

                  ir_variable *const r2DDF = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2DDF, lshift(r2DC4, r2DC6), 0x01));

                  ir_variable *const r2DE0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2DE2 = equal(r2DC6, body.constant(int(0)));
                  ir_if *f2DE1 = new(mem_ctx) ir_if(operand(r2DE2).val);
                  exec_list *const f2DE1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DE1->then_instructions;

                     body.emit(assign(r2DE0, r2DC3, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DE1->else_instructions;

                     ir_expression *const r2DE3 = lshift(r2DC3, r2DC6);
                     ir_expression *const r2DE4 = neg(r2DC6);
                     ir_expression *const r2DE5 = bit_and(r2DE4, body.constant(int(31)));
                     ir_expression *const r2DE6 = rshift(r2DC4, r2DE5);
                     body.emit(assign(r2DE0, bit_or(r2DE3, r2DE6), 0x01));


                  body.instructions = f2DE1_parent_instructions;
                  body.emit(f2DE1);

                  /* END IF */

                  body.emit(assign(r2DC3, r2DE0, 0x01));

                  body.emit(assign(r2DC4, r2DDF, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2DDD->else_instructions;

                  ir_variable *const r2DE7 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2DE7, body.constant(0u), 0x01));

                  ir_variable *const r2DE8 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2DE8, neg(r2DC6), 0x01));

                  ir_variable *const r2DE9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2DE9);
                  ir_variable *const r2DEA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2DEA);
                  ir_variable *const r2DEB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2DEB);
                  ir_variable *const r2DEC = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2DED = neg(r2DE8);
                  body.emit(assign(r2DEC, bit_and(r2DED, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2DEF = equal(r2DE8, body.constant(int(0)));
                  ir_if *f2DEE = new(mem_ctx) ir_if(operand(r2DEF).val);
                  exec_list *const f2DEE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DEE->then_instructions;

                     body.emit(assign(r2DE9, r2DE7, 0x01));

                     body.emit(assign(r2DEA, r2DC4, 0x01));

                     body.emit(assign(r2DEB, r2DC3, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DEE->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2DF1 = less(r2DE8, body.constant(int(32)));
                     ir_if *f2DF0 = new(mem_ctx) ir_if(operand(r2DF1).val);
                     exec_list *const f2DF0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DF0->then_instructions;

                        body.emit(assign(r2DE9, lshift(r2DC4, r2DEC), 0x01));

                        ir_expression *const r2DF2 = lshift(r2DC3, r2DEC);
                        ir_expression *const r2DF3 = rshift(r2DC4, r2DE8);
                        body.emit(assign(r2DEA, bit_or(r2DF2, r2DF3), 0x01));

                        body.emit(assign(r2DEB, rshift(r2DC3, r2DE8), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2DF0->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2DF5 = equal(r2DE8, body.constant(int(32)));
                        ir_if *f2DF4 = new(mem_ctx) ir_if(operand(r2DF5).val);
                        exec_list *const f2DF4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2DF4->then_instructions;

                           body.emit(assign(r2DE9, r2DC4, 0x01));

                           body.emit(assign(r2DEA, r2DC3, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2DF4->else_instructions;

                           body.emit(assign(r2DE7, bit_or(body.constant(0u), r2DC4), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2DF7 = less(r2DE8, body.constant(int(64)));
                           ir_if *f2DF6 = new(mem_ctx) ir_if(operand(r2DF7).val);
                           exec_list *const f2DF6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2DF6->then_instructions;

                              body.emit(assign(r2DE9, lshift(r2DC3, r2DEC), 0x01));

                              ir_expression *const r2DF8 = bit_and(r2DE8, body.constant(int(31)));
                              body.emit(assign(r2DEA, rshift(r2DC3, r2DF8), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2DF6->else_instructions;

                              ir_variable *const r2DF9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2DFB = equal(r2DE8, body.constant(int(64)));
                              ir_if *f2DFA = new(mem_ctx) ir_if(operand(r2DFB).val);
                              exec_list *const f2DFA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2DFA->then_instructions;

                                 body.emit(assign(r2DF9, r2DC3, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2DFA->else_instructions;

                                 ir_expression *const r2DFC = nequal(r2DC3, body.constant(0u));
                                 ir_expression *const r2DFD = expr(ir_unop_b2i, r2DFC);
                                 body.emit(assign(r2DF9, expr(ir_unop_i2u, r2DFD), 0x01));


                              body.instructions = f2DFA_parent_instructions;
                              body.emit(f2DFA);

                              /* END IF */

                              body.emit(assign(r2DE9, r2DF9, 0x01));

                              body.emit(assign(r2DEA, body.constant(0u), 0x01));


                           body.instructions = f2DF6_parent_instructions;
                           body.emit(f2DF6);

                           /* END IF */


                        body.instructions = f2DF4_parent_instructions;
                        body.emit(f2DF4);

                        /* END IF */

                        body.emit(assign(r2DEB, body.constant(0u), 0x01));


                     body.instructions = f2DF0_parent_instructions;
                     body.emit(f2DF0);

                     /* END IF */

                     ir_expression *const r2DFE = nequal(r2DE7, body.constant(0u));
                     ir_expression *const r2DFF = expr(ir_unop_b2i, r2DFE);
                     ir_expression *const r2E00 = expr(ir_unop_i2u, r2DFF);
                     body.emit(assign(r2DE9, bit_or(r2DE9, r2E00), 0x01));


                  body.instructions = f2DEE_parent_instructions;
                  body.emit(f2DEE);

                  /* END IF */

                  body.emit(assign(r2DC3, r2DEB, 0x01));

                  body.emit(assign(r2DC4, r2DEA, 0x01));

                  body.emit(assign(r2DC5, r2DE9, 0x01));


               body.instructions = f2DDD_parent_instructions;
               body.emit(f2DDD);

               /* END IF */

               body.emit(assign(r2DC2, sub(r2DC2, r2DC6), 0x01));

               ir_variable *const r2E01 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2E01, r2DC2, 0x01));

               ir_variable *const r2E02 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2E02, r2DC3, 0x01));

               ir_variable *const r2E03 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2E03, r2DC4, 0x01));

               ir_variable *const r2E04 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2E04, r2DC5, 0x01));

               ir_variable *const r2E05 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2E05, body.constant(true), 0x01));

               ir_variable *const r2E06 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2E07 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2E07);
               ir_expression *const r2E08 = expr(ir_unop_u2i, r2DC5);
               body.emit(assign(r2E07, less(r2E08, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2E0A = lequal(body.constant(int(2045)), r2DC2);
               ir_if *f2E09 = new(mem_ctx) ir_if(operand(r2E0A).val);
               exec_list *const f2E09_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E09->then_instructions;

                  ir_variable *const r2E0B = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2E0D = less(body.constant(int(2045)), r2DC2);
                  ir_if *f2E0C = new(mem_ctx) ir_if(operand(r2E0D).val);
                  exec_list *const f2E0C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E0C->then_instructions;

                     body.emit(assign(r2E0B, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E0C->else_instructions;

                     ir_variable *const r2E0E = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2E10 = equal(r2DC2, body.constant(int(2045)));
                     ir_if *f2E0F = new(mem_ctx) ir_if(operand(r2E10).val);
                     exec_list *const f2E0F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E0F->then_instructions;

                        ir_expression *const r2E11 = equal(body.constant(2097151u), r2DC3);
                        ir_expression *const r2E12 = equal(body.constant(4294967295u), r2DC4);
                        body.emit(assign(r2E0E, logic_and(r2E11, r2E12), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E0F->else_instructions;

                        body.emit(assign(r2E0E, body.constant(false), 0x01));


                     body.instructions = f2E0F_parent_instructions;
                     body.emit(f2E0F);

                     /* END IF */

                     body.emit(assign(r2E0B, logic_and(r2E0E, r2E07), 0x01));


                  body.instructions = f2E0C_parent_instructions;
                  body.emit(f2E0C);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2E13 = new(mem_ctx) ir_if(operand(r2E0B).val);
                  exec_list *const f2E13_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E13->then_instructions;

                     ir_variable *const r2E14 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2E14);
                     ir_expression *const r2E15 = lshift(r2C88, body.constant(int(31)));
                     body.emit(assign(r2E14, add(r2E15, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2E14, body.constant(0u), 0x01));

                     body.emit(assign(r2E06, r2E14, 0x03));

                     body.emit(assign(r2E05, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E13->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2E17 = less(r2DC2, body.constant(int(0)));
                     ir_if *f2E16 = new(mem_ctx) ir_if(operand(r2E17).val);
                     exec_list *const f2E16_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E16->then_instructions;

                        ir_variable *const r2E18 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2E18, r2DC5, 0x01));

                        ir_variable *const r2E19 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2E19, neg(r2DC2), 0x01));

                        ir_variable *const r2E1A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2E1A);
                        ir_variable *const r2E1B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2E1B);
                        ir_variable *const r2E1C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2E1C);
                        ir_variable *const r2E1D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2E1E = neg(r2E19);
                        body.emit(assign(r2E1D, bit_and(r2E1E, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2E20 = equal(r2E19, body.constant(int(0)));
                        ir_if *f2E1F = new(mem_ctx) ir_if(operand(r2E20).val);
                        exec_list *const f2E1F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2E1F->then_instructions;

                           body.emit(assign(r2E1A, r2DC5, 0x01));

                           body.emit(assign(r2E1B, r2DC4, 0x01));

                           body.emit(assign(r2E1C, r2DC3, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2E1F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2E22 = less(r2E19, body.constant(int(32)));
                           ir_if *f2E21 = new(mem_ctx) ir_if(operand(r2E22).val);
                           exec_list *const f2E21_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2E21->then_instructions;

                              body.emit(assign(r2E1A, lshift(r2DC4, r2E1D), 0x01));

                              ir_expression *const r2E23 = lshift(r2DC3, r2E1D);
                              ir_expression *const r2E24 = rshift(r2DC4, r2E19);
                              body.emit(assign(r2E1B, bit_or(r2E23, r2E24), 0x01));

                              body.emit(assign(r2E1C, rshift(r2DC3, r2E19), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2E21->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2E26 = equal(r2E19, body.constant(int(32)));
                              ir_if *f2E25 = new(mem_ctx) ir_if(operand(r2E26).val);
                              exec_list *const f2E25_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2E25->then_instructions;

                                 body.emit(assign(r2E1A, r2DC4, 0x01));

                                 body.emit(assign(r2E1B, r2DC3, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2E25->else_instructions;

                                 body.emit(assign(r2E18, bit_or(r2DC5, r2DC4), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2E28 = less(r2E19, body.constant(int(64)));
                                 ir_if *f2E27 = new(mem_ctx) ir_if(operand(r2E28).val);
                                 exec_list *const f2E27_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2E27->then_instructions;

                                    body.emit(assign(r2E1A, lshift(r2DC3, r2E1D), 0x01));

                                    ir_expression *const r2E29 = bit_and(r2E19, body.constant(int(31)));
                                    body.emit(assign(r2E1B, rshift(r2DC3, r2E29), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2E27->else_instructions;

                                    ir_variable *const r2E2A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2E2C = equal(r2E19, body.constant(int(64)));
                                    ir_if *f2E2B = new(mem_ctx) ir_if(operand(r2E2C).val);
                                    exec_list *const f2E2B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2E2B->then_instructions;

                                       body.emit(assign(r2E2A, r2DC3, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2E2B->else_instructions;

                                       ir_expression *const r2E2D = nequal(r2DC3, body.constant(0u));
                                       ir_expression *const r2E2E = expr(ir_unop_b2i, r2E2D);
                                       body.emit(assign(r2E2A, expr(ir_unop_i2u, r2E2E), 0x01));


                                    body.instructions = f2E2B_parent_instructions;
                                    body.emit(f2E2B);

                                    /* END IF */

                                    body.emit(assign(r2E1A, r2E2A, 0x01));

                                    body.emit(assign(r2E1B, body.constant(0u), 0x01));


                                 body.instructions = f2E27_parent_instructions;
                                 body.emit(f2E27);

                                 /* END IF */


                              body.instructions = f2E25_parent_instructions;
                              body.emit(f2E25);

                              /* END IF */

                              body.emit(assign(r2E1C, body.constant(0u), 0x01));


                           body.instructions = f2E21_parent_instructions;
                           body.emit(f2E21);

                           /* END IF */

                           ir_expression *const r2E2F = nequal(r2E18, body.constant(0u));
                           ir_expression *const r2E30 = expr(ir_unop_b2i, r2E2F);
                           ir_expression *const r2E31 = expr(ir_unop_i2u, r2E30);
                           body.emit(assign(r2E1A, bit_or(r2E1A, r2E31), 0x01));


                        body.instructions = f2E1F_parent_instructions;
                        body.emit(f2E1F);

                        /* END IF */

                        body.emit(assign(r2E02, r2E1C, 0x01));

                        body.emit(assign(r2E03, r2E1B, 0x01));

                        body.emit(assign(r2E04, r2E1A, 0x01));

                        body.emit(assign(r2E01, body.constant(int(0)), 0x01));

                        body.emit(assign(r2E07, less(r2E1A, body.constant(0u)), 0x01));


                     body.instructions = f2E16_parent_instructions;
                     body.emit(f2E16);

                     /* END IF */


                  body.instructions = f2E13_parent_instructions;
                  body.emit(f2E13);

                  /* END IF */


               body.instructions = f2E09_parent_instructions;
               body.emit(f2E09);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2E32 = new(mem_ctx) ir_if(operand(r2E05).val);
               exec_list *const f2E32_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E32->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2E33 = new(mem_ctx) ir_if(operand(r2E07).val);
                  exec_list *const f2E33_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E33->then_instructions;

                     ir_variable *const r2E34 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2E34, add(r2E03, body.constant(1u)), 0x01));

                     ir_expression *const r2E35 = less(r2E34, r2E03);
                     ir_expression *const r2E36 = expr(ir_unop_b2i, r2E35);
                     ir_expression *const r2E37 = expr(ir_unop_i2u, r2E36);
                     body.emit(assign(r2E02, add(r2E02, r2E37), 0x01));

                     ir_expression *const r2E38 = equal(r2E04, body.constant(0u));
                     ir_expression *const r2E39 = expr(ir_unop_b2i, r2E38);
                     ir_expression *const r2E3A = expr(ir_unop_i2u, r2E39);
                     ir_expression *const r2E3B = add(r2E04, r2E3A);
                     ir_expression *const r2E3C = bit_and(r2E3B, body.constant(1u));
                     ir_expression *const r2E3D = expr(ir_unop_bit_not, r2E3C);
                     body.emit(assign(r2E03, bit_and(r2E34, r2E3D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E33->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2E3F = bit_or(r2E02, r2E03);
                     ir_expression *const r2E40 = equal(r2E3F, body.constant(0u));
                     ir_if *f2E3E = new(mem_ctx) ir_if(operand(r2E40).val);
                     exec_list *const f2E3E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E3E->then_instructions;

                        body.emit(assign(r2E01, body.constant(int(0)), 0x01));


                     body.instructions = f2E3E_parent_instructions;
                     body.emit(f2E3E);

                     /* END IF */


                  body.instructions = f2E33_parent_instructions;
                  body.emit(f2E33);

                  /* END IF */

                  ir_variable *const r2E41 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2E41);
                  ir_expression *const r2E42 = lshift(r2C88, body.constant(int(31)));
                  ir_expression *const r2E43 = expr(ir_unop_i2u, r2E01);
                  ir_expression *const r2E44 = lshift(r2E43, body.constant(int(20)));
                  ir_expression *const r2E45 = add(r2E42, r2E44);
                  body.emit(assign(r2E41, add(r2E45, r2E02), 0x02));

                  body.emit(assign(r2E41, r2E03, 0x01));

                  body.emit(assign(r2E06, r2E41, 0x03));

                  body.emit(assign(r2E05, body.constant(false), 0x01));


               body.instructions = f2E32_parent_instructions;
               body.emit(f2E32);

               /* END IF */

               body.emit(assign(r2C89, r2E06, 0x03));


            body.instructions = f2D74_parent_instructions;
            body.emit(f2D74);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2D72->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2E47 = equal(r2C92, body.constant(int(2047)));
            ir_if *f2E46 = new(mem_ctx) ir_if(operand(r2E47).val);
            exec_list *const f2E46_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2E46->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2E49 = bit_or(r2C8F, r2C90);
               ir_expression *const r2E4A = bit_or(r2C8D, r2C8E);
               ir_expression *const r2E4B = bit_or(r2E49, r2E4A);
               ir_expression *const r2E4C = nequal(r2E4B, body.constant(0u));
               ir_if *f2E48 = new(mem_ctx) ir_if(operand(r2E4C).val);
               exec_list *const f2E48_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E48->then_instructions;

                  ir_variable *const r2E4D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2E4D, swizzle_x(r2735), 0x01));

                  ir_variable *const r2E4E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2E4E, swizzle_x(r2769), 0x01));

                  ir_variable *const r2E4F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2E50 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r2E51 = rshift(swizzle_y(r2735), body.constant(int(19)));
                  ir_expression *const r2E52 = bit_and(r2E51, body.constant(4095u));
                  ir_expression *const r2E53 = equal(r2E52, body.constant(4094u));
                  ir_expression *const r2E54 = nequal(swizzle_x(r2735), body.constant(0u));
                  ir_expression *const r2E55 = bit_and(swizzle_y(r2735), body.constant(524287u));
                  ir_expression *const r2E56 = nequal(r2E55, body.constant(0u));
                  ir_expression *const r2E57 = logic_or(r2E54, r2E56);
                  body.emit(assign(r2E50, logic_and(r2E53, r2E57), 0x01));

                  ir_variable *const r2E58 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r2E59 = lshift(swizzle_y(r2769), body.constant(int(1)));
                  ir_expression *const r2E5A = lequal(body.constant(4292870144u), r2E59);
                  ir_expression *const r2E5B = nequal(swizzle_x(r2769), body.constant(0u));
                  ir_expression *const r2E5C = bit_and(swizzle_y(r2769), body.constant(1048575u));
                  ir_expression *const r2E5D = nequal(r2E5C, body.constant(0u));
                  ir_expression *const r2E5E = logic_or(r2E5B, r2E5D);
                  body.emit(assign(r2E58, logic_and(r2E5A, r2E5E), 0x01));

                  body.emit(assign(r2E4D, bit_or(swizzle_y(r2735), body.constant(524288u)), 0x02));

                  body.emit(assign(r2E4E, bit_or(swizzle_y(r2769), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2E60 = lshift(swizzle_y(r2735), body.constant(int(1)));
                  ir_expression *const r2E61 = lequal(body.constant(4292870144u), r2E60);
                  ir_expression *const r2E62 = nequal(swizzle_x(r2735), body.constant(0u));
                  ir_expression *const r2E63 = bit_and(swizzle_y(r2735), body.constant(1048575u));
                  ir_expression *const r2E64 = nequal(r2E63, body.constant(0u));
                  ir_expression *const r2E65 = logic_or(r2E62, r2E64);
                  ir_expression *const r2E66 = logic_and(r2E61, r2E65);
                  ir_if *f2E5F = new(mem_ctx) ir_if(operand(r2E66).val);
                  exec_list *const f2E5F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E5F->then_instructions;

                     ir_variable *const r2E67 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2E69 = logic_and(r2E50, r2E58);
                     ir_if *f2E68 = new(mem_ctx) ir_if(operand(r2E69).val);
                     exec_list *const f2E68_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E68->then_instructions;

                        body.emit(assign(r2E67, r2E4E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E68->else_instructions;

                        body.emit(assign(r2E67, r2E4D, 0x03));


                     body.instructions = f2E68_parent_instructions;
                     body.emit(f2E68);

                     /* END IF */

                     body.emit(assign(r2E4F, r2E67, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E5F->else_instructions;

                     body.emit(assign(r2E4F, r2E4E, 0x03));


                  body.instructions = f2E5F_parent_instructions;
                  body.emit(f2E5F);

                  /* END IF */

                  body.emit(assign(r2C89, r2E4F, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2E48->else_instructions;

                  ir_constant_data r2E6A_data;
                  memset(&r2E6A_data, 0, sizeof(ir_constant_data));
                  r2E6A_data.u[0] = 4294967295;
                  r2E6A_data.u[1] = 4294967295;
                  ir_constant *const r2E6A = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r2E6A_data);
                  body.emit(assign(r2C89, r2E6A, 0x03));


               body.instructions = f2E48_parent_instructions;
               body.emit(f2E48);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2E46->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2E6C = equal(r2C92, body.constant(int(0)));
               ir_if *f2E6B = new(mem_ctx) ir_if(operand(r2E6C).val);
               exec_list *const f2E6B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E6B->then_instructions;

                  body.emit(assign(r2C8C, body.constant(int(1)), 0x01));

                  body.emit(assign(r2C8B, body.constant(int(1)), 0x01));


               body.instructions = f2E6B_parent_instructions;
               body.emit(f2E6B);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2E6E = less(r2C8D, r2C8F);
               ir_if *f2E6D = new(mem_ctx) ir_if(operand(r2E6E).val);
               exec_list *const f2E6D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E6D->then_instructions;

                  ir_variable *const r2E6F = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r2E70 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2E70, sub(r2C90, r2C8E), 0x01));

                  ir_expression *const r2E71 = sub(r2C8F, r2C8D);
                  ir_expression *const r2E72 = less(r2C90, r2C8E);
                  ir_expression *const r2E73 = expr(ir_unop_b2i, r2E72);
                  ir_expression *const r2E74 = expr(ir_unop_i2u, r2E73);
                  body.emit(assign(r2E6F, sub(r2E71, r2E74), 0x01));

                  body.emit(assign(r2C91, add(r2C8C, body.constant(int(-1))), 0x01));

                  ir_variable *const r2E75 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r2E75, add(r2C91, body.constant(int(-10))), 0x01));

                  ir_variable *const r2E76 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r2E76, r2E6F, 0x01));

                  ir_variable *const r2E77 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r2E77, r2E70, 0x01));

                  ir_variable *const r2E78 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r2E78);
                  ir_variable *const r2E79 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r2E79);
                  /* IF CONDITION */
                  ir_expression *const r2E7B = equal(r2E6F, body.constant(0u));
                  ir_if *f2E7A = new(mem_ctx) ir_if(operand(r2E7B).val);
                  exec_list *const f2E7A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E7A->then_instructions;

                     body.emit(assign(r2E76, r2E70, 0x01));

                     body.emit(assign(r2E77, body.constant(0u), 0x01));

                     body.emit(assign(r2E75, add(r2E75, body.constant(int(-32))), 0x01));


                  body.instructions = f2E7A_parent_instructions;
                  body.emit(f2E7A);

                  /* END IF */

                  ir_variable *const r2E7C = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r2E7C, r2E76, 0x01));

                  ir_variable *const r2E7D = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r2E7E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r2E7E);
                  /* IF CONDITION */
                  ir_expression *const r2E80 = equal(r2E76, body.constant(0u));
                  ir_if *f2E7F = new(mem_ctx) ir_if(operand(r2E80).val);
                  exec_list *const f2E7F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E7F->then_instructions;

                     body.emit(assign(r2E7D, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E7F->else_instructions;

                     body.emit(assign(r2E7E, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2E82 = bit_and(r2E76, body.constant(4294901760u));
                     ir_expression *const r2E83 = equal(r2E82, body.constant(0u));
                     ir_if *f2E81 = new(mem_ctx) ir_if(operand(r2E83).val);
                     exec_list *const f2E81_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E81->then_instructions;

                        body.emit(assign(r2E7E, body.constant(int(16)), 0x01));

                        body.emit(assign(r2E7C, lshift(r2E76, body.constant(int(16))), 0x01));


                     body.instructions = f2E81_parent_instructions;
                     body.emit(f2E81);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E85 = bit_and(r2E7C, body.constant(4278190080u));
                     ir_expression *const r2E86 = equal(r2E85, body.constant(0u));
                     ir_if *f2E84 = new(mem_ctx) ir_if(operand(r2E86).val);
                     exec_list *const f2E84_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E84->then_instructions;

                        body.emit(assign(r2E7E, add(r2E7E, body.constant(int(8))), 0x01));

                        body.emit(assign(r2E7C, lshift(r2E7C, body.constant(int(8))), 0x01));


                     body.instructions = f2E84_parent_instructions;
                     body.emit(f2E84);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E88 = bit_and(r2E7C, body.constant(4026531840u));
                     ir_expression *const r2E89 = equal(r2E88, body.constant(0u));
                     ir_if *f2E87 = new(mem_ctx) ir_if(operand(r2E89).val);
                     exec_list *const f2E87_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E87->then_instructions;

                        body.emit(assign(r2E7E, add(r2E7E, body.constant(int(4))), 0x01));

                        body.emit(assign(r2E7C, lshift(r2E7C, body.constant(int(4))), 0x01));


                     body.instructions = f2E87_parent_instructions;
                     body.emit(f2E87);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E8B = bit_and(r2E7C, body.constant(3221225472u));
                     ir_expression *const r2E8C = equal(r2E8B, body.constant(0u));
                     ir_if *f2E8A = new(mem_ctx) ir_if(operand(r2E8C).val);
                     exec_list *const f2E8A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E8A->then_instructions;

                        body.emit(assign(r2E7E, add(r2E7E, body.constant(int(2))), 0x01));

                        body.emit(assign(r2E7C, lshift(r2E7C, body.constant(int(2))), 0x01));


                     body.instructions = f2E8A_parent_instructions;
                     body.emit(f2E8A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E8E = bit_and(r2E7C, body.constant(2147483648u));
                     ir_expression *const r2E8F = equal(r2E8E, body.constant(0u));
                     ir_if *f2E8D = new(mem_ctx) ir_if(operand(r2E8F).val);
                     exec_list *const f2E8D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E8D->then_instructions;

                        body.emit(assign(r2E7E, add(r2E7E, body.constant(int(1))), 0x01));


                     body.instructions = f2E8D_parent_instructions;
                     body.emit(f2E8D);

                     /* END IF */

                     body.emit(assign(r2E7D, r2E7E, 0x01));


                  body.instructions = f2E7F_parent_instructions;
                  body.emit(f2E7F);

                  /* END IF */

                  body.emit(assign(r2E79, add(r2E7D, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2E91 = lequal(body.constant(int(0)), r2E79);
                  ir_if *f2E90 = new(mem_ctx) ir_if(operand(r2E91).val);
                  exec_list *const f2E90_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E90->then_instructions;

                     body.emit(assign(r2E78, body.constant(0u), 0x01));

                     ir_variable *const r2E92 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r2E92, lshift(r2E77, r2E79), 0x01));

                     ir_variable *const r2E93 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2E95 = equal(r2E79, body.constant(int(0)));
                     ir_if *f2E94 = new(mem_ctx) ir_if(operand(r2E95).val);
                     exec_list *const f2E94_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E94->then_instructions;

                        body.emit(assign(r2E93, r2E76, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E94->else_instructions;

                        ir_expression *const r2E96 = lshift(r2E76, r2E79);
                        ir_expression *const r2E97 = neg(r2E79);
                        ir_expression *const r2E98 = bit_and(r2E97, body.constant(int(31)));
                        ir_expression *const r2E99 = rshift(r2E77, r2E98);
                        body.emit(assign(r2E93, bit_or(r2E96, r2E99), 0x01));


                     body.instructions = f2E94_parent_instructions;
                     body.emit(f2E94);

                     /* END IF */

                     body.emit(assign(r2E76, r2E93, 0x01));

                     body.emit(assign(r2E77, r2E92, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E90->else_instructions;

                     ir_variable *const r2E9A = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r2E9A, body.constant(0u), 0x01));

                     ir_variable *const r2E9B = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r2E9B, neg(r2E79), 0x01));

                     ir_variable *const r2E9C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2E9C);
                     ir_variable *const r2E9D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2E9D);
                     ir_variable *const r2E9E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2E9E);
                     ir_variable *const r2E9F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r2EA0 = neg(r2E9B);
                     body.emit(assign(r2E9F, bit_and(r2EA0, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2EA2 = equal(r2E9B, body.constant(int(0)));
                     ir_if *f2EA1 = new(mem_ctx) ir_if(operand(r2EA2).val);
                     exec_list *const f2EA1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2EA1->then_instructions;

                        body.emit(assign(r2E9C, r2E9A, 0x01));

                        body.emit(assign(r2E9D, r2E77, 0x01));

                        body.emit(assign(r2E9E, r2E76, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2EA1->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2EA4 = less(r2E9B, body.constant(int(32)));
                        ir_if *f2EA3 = new(mem_ctx) ir_if(operand(r2EA4).val);
                        exec_list *const f2EA3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EA3->then_instructions;

                           body.emit(assign(r2E9C, lshift(r2E77, r2E9F), 0x01));

                           ir_expression *const r2EA5 = lshift(r2E76, r2E9F);
                           ir_expression *const r2EA6 = rshift(r2E77, r2E9B);
                           body.emit(assign(r2E9D, bit_or(r2EA5, r2EA6), 0x01));

                           body.emit(assign(r2E9E, rshift(r2E76, r2E9B), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2EA3->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2EA8 = equal(r2E9B, body.constant(int(32)));
                           ir_if *f2EA7 = new(mem_ctx) ir_if(operand(r2EA8).val);
                           exec_list *const f2EA7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2EA7->then_instructions;

                              body.emit(assign(r2E9C, r2E77, 0x01));

                              body.emit(assign(r2E9D, r2E76, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2EA7->else_instructions;

                              body.emit(assign(r2E9A, bit_or(body.constant(0u), r2E77), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2EAA = less(r2E9B, body.constant(int(64)));
                              ir_if *f2EA9 = new(mem_ctx) ir_if(operand(r2EAA).val);
                              exec_list *const f2EA9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2EA9->then_instructions;

                                 body.emit(assign(r2E9C, lshift(r2E76, r2E9F), 0x01));

                                 ir_expression *const r2EAB = bit_and(r2E9B, body.constant(int(31)));
                                 body.emit(assign(r2E9D, rshift(r2E76, r2EAB), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2EA9->else_instructions;

                                 ir_variable *const r2EAC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2EAE = equal(r2E9B, body.constant(int(64)));
                                 ir_if *f2EAD = new(mem_ctx) ir_if(operand(r2EAE).val);
                                 exec_list *const f2EAD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2EAD->then_instructions;

                                    body.emit(assign(r2EAC, r2E76, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2EAD->else_instructions;

                                    ir_expression *const r2EAF = nequal(r2E76, body.constant(0u));
                                    ir_expression *const r2EB0 = expr(ir_unop_b2i, r2EAF);
                                    body.emit(assign(r2EAC, expr(ir_unop_i2u, r2EB0), 0x01));


                                 body.instructions = f2EAD_parent_instructions;
                                 body.emit(f2EAD);

                                 /* END IF */

                                 body.emit(assign(r2E9C, r2EAC, 0x01));

                                 body.emit(assign(r2E9D, body.constant(0u), 0x01));


                              body.instructions = f2EA9_parent_instructions;
                              body.emit(f2EA9);

                              /* END IF */


                           body.instructions = f2EA7_parent_instructions;
                           body.emit(f2EA7);

                           /* END IF */

                           body.emit(assign(r2E9E, body.constant(0u), 0x01));


                        body.instructions = f2EA3_parent_instructions;
                        body.emit(f2EA3);

                        /* END IF */

                        ir_expression *const r2EB1 = nequal(r2E9A, body.constant(0u));
                        ir_expression *const r2EB2 = expr(ir_unop_b2i, r2EB1);
                        ir_expression *const r2EB3 = expr(ir_unop_i2u, r2EB2);
                        body.emit(assign(r2E9C, bit_or(r2E9C, r2EB3), 0x01));


                     body.instructions = f2EA1_parent_instructions;
                     body.emit(f2EA1);

                     /* END IF */

                     body.emit(assign(r2E76, r2E9E, 0x01));

                     body.emit(assign(r2E77, r2E9D, 0x01));

                     body.emit(assign(r2E78, r2E9C, 0x01));


                  body.instructions = f2E90_parent_instructions;
                  body.emit(f2E90);

                  /* END IF */

                  body.emit(assign(r2E75, sub(r2E75, r2E79), 0x01));

                  ir_variable *const r2EB4 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r2EB4, r2E75, 0x01));

                  ir_variable *const r2EB5 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r2EB5, r2E76, 0x01));

                  ir_variable *const r2EB6 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r2EB6, r2E77, 0x01));

                  ir_variable *const r2EB7 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r2EB7, r2E78, 0x01));

                  ir_variable *const r2EB8 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r2EB8, body.constant(true), 0x01));

                  ir_variable *const r2EB9 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2EBA = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r2EBA);
                  ir_expression *const r2EBB = expr(ir_unop_u2i, r2E78);
                  body.emit(assign(r2EBA, less(r2EBB, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2EBD = lequal(body.constant(int(2045)), r2E75);
                  ir_if *f2EBC = new(mem_ctx) ir_if(operand(r2EBD).val);
                  exec_list *const f2EBC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2EBC->then_instructions;

                     ir_variable *const r2EBE = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2EC0 = less(body.constant(int(2045)), r2E75);
                     ir_if *f2EBF = new(mem_ctx) ir_if(operand(r2EC0).val);
                     exec_list *const f2EBF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2EBF->then_instructions;

                        body.emit(assign(r2EBE, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2EBF->else_instructions;

                        ir_variable *const r2EC1 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2EC3 = equal(r2E75, body.constant(int(2045)));
                        ir_if *f2EC2 = new(mem_ctx) ir_if(operand(r2EC3).val);
                        exec_list *const f2EC2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EC2->then_instructions;

                           ir_expression *const r2EC4 = equal(body.constant(2097151u), r2E76);
                           ir_expression *const r2EC5 = equal(body.constant(4294967295u), r2E77);
                           body.emit(assign(r2EC1, logic_and(r2EC4, r2EC5), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2EC2->else_instructions;

                           body.emit(assign(r2EC1, body.constant(false), 0x01));


                        body.instructions = f2EC2_parent_instructions;
                        body.emit(f2EC2);

                        /* END IF */

                        body.emit(assign(r2EBE, logic_and(r2EC1, r2EBA), 0x01));


                     body.instructions = f2EBF_parent_instructions;
                     body.emit(f2EBF);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2EC6 = new(mem_ctx) ir_if(operand(r2EBE).val);
                     exec_list *const f2EC6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2EC6->then_instructions;

                        ir_variable *const r2EC7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2EC7);
                        ir_expression *const r2EC8 = lshift(r2C88, body.constant(int(31)));
                        body.emit(assign(r2EC7, add(r2EC8, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r2EC7, body.constant(0u), 0x01));

                        body.emit(assign(r2EB9, r2EC7, 0x03));

                        body.emit(assign(r2EB8, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2EC6->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2ECA = less(r2E75, body.constant(int(0)));
                        ir_if *f2EC9 = new(mem_ctx) ir_if(operand(r2ECA).val);
                        exec_list *const f2EC9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EC9->then_instructions;

                           ir_variable *const r2ECB = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r2ECB, r2E78, 0x01));

                           ir_variable *const r2ECC = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2ECC, neg(r2E75), 0x01));

                           ir_variable *const r2ECD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r2ECD);
                           ir_variable *const r2ECE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r2ECE);
                           ir_variable *const r2ECF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r2ECF);
                           ir_variable *const r2ED0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r2ED1 = neg(r2ECC);
                           body.emit(assign(r2ED0, bit_and(r2ED1, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2ED3 = equal(r2ECC, body.constant(int(0)));
                           ir_if *f2ED2 = new(mem_ctx) ir_if(operand(r2ED3).val);
                           exec_list *const f2ED2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2ED2->then_instructions;

                              body.emit(assign(r2ECD, r2E78, 0x01));

                              body.emit(assign(r2ECE, r2E77, 0x01));

                              body.emit(assign(r2ECF, r2E76, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2ED2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2ED5 = less(r2ECC, body.constant(int(32)));
                              ir_if *f2ED4 = new(mem_ctx) ir_if(operand(r2ED5).val);
                              exec_list *const f2ED4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2ED4->then_instructions;

                                 body.emit(assign(r2ECD, lshift(r2E77, r2ED0), 0x01));

                                 ir_expression *const r2ED6 = lshift(r2E76, r2ED0);
                                 ir_expression *const r2ED7 = rshift(r2E77, r2ECC);
                                 body.emit(assign(r2ECE, bit_or(r2ED6, r2ED7), 0x01));

                                 body.emit(assign(r2ECF, rshift(r2E76, r2ECC), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2ED4->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2ED9 = equal(r2ECC, body.constant(int(32)));
                                 ir_if *f2ED8 = new(mem_ctx) ir_if(operand(r2ED9).val);
                                 exec_list *const f2ED8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2ED8->then_instructions;

                                    body.emit(assign(r2ECD, r2E77, 0x01));

                                    body.emit(assign(r2ECE, r2E76, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2ED8->else_instructions;

                                    body.emit(assign(r2ECB, bit_or(r2E78, r2E77), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2EDB = less(r2ECC, body.constant(int(64)));
                                    ir_if *f2EDA = new(mem_ctx) ir_if(operand(r2EDB).val);
                                    exec_list *const f2EDA_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2EDA->then_instructions;

                                       body.emit(assign(r2ECD, lshift(r2E76, r2ED0), 0x01));

                                       ir_expression *const r2EDC = bit_and(r2ECC, body.constant(int(31)));
                                       body.emit(assign(r2ECE, rshift(r2E76, r2EDC), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2EDA->else_instructions;

                                       ir_variable *const r2EDD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r2EDF = equal(r2ECC, body.constant(int(64)));
                                       ir_if *f2EDE = new(mem_ctx) ir_if(operand(r2EDF).val);
                                       exec_list *const f2EDE_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2EDE->then_instructions;

                                          body.emit(assign(r2EDD, r2E76, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2EDE->else_instructions;

                                          ir_expression *const r2EE0 = nequal(r2E76, body.constant(0u));
                                          ir_expression *const r2EE1 = expr(ir_unop_b2i, r2EE0);
                                          body.emit(assign(r2EDD, expr(ir_unop_i2u, r2EE1), 0x01));


                                       body.instructions = f2EDE_parent_instructions;
                                       body.emit(f2EDE);

                                       /* END IF */

                                       body.emit(assign(r2ECD, r2EDD, 0x01));

                                       body.emit(assign(r2ECE, body.constant(0u), 0x01));


                                    body.instructions = f2EDA_parent_instructions;
                                    body.emit(f2EDA);

                                    /* END IF */


                                 body.instructions = f2ED8_parent_instructions;
                                 body.emit(f2ED8);

                                 /* END IF */

                                 body.emit(assign(r2ECF, body.constant(0u), 0x01));


                              body.instructions = f2ED4_parent_instructions;
                              body.emit(f2ED4);

                              /* END IF */

                              ir_expression *const r2EE2 = nequal(r2ECB, body.constant(0u));
                              ir_expression *const r2EE3 = expr(ir_unop_b2i, r2EE2);
                              ir_expression *const r2EE4 = expr(ir_unop_i2u, r2EE3);
                              body.emit(assign(r2ECD, bit_or(r2ECD, r2EE4), 0x01));


                           body.instructions = f2ED2_parent_instructions;
                           body.emit(f2ED2);

                           /* END IF */

                           body.emit(assign(r2EB5, r2ECF, 0x01));

                           body.emit(assign(r2EB6, r2ECE, 0x01));

                           body.emit(assign(r2EB7, r2ECD, 0x01));

                           body.emit(assign(r2EB4, body.constant(int(0)), 0x01));

                           body.emit(assign(r2EBA, less(r2ECD, body.constant(0u)), 0x01));


                        body.instructions = f2EC9_parent_instructions;
                        body.emit(f2EC9);

                        /* END IF */


                     body.instructions = f2EC6_parent_instructions;
                     body.emit(f2EC6);

                     /* END IF */


                  body.instructions = f2EBC_parent_instructions;
                  body.emit(f2EBC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2EE5 = new(mem_ctx) ir_if(operand(r2EB8).val);
                  exec_list *const f2EE5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2EE5->then_instructions;

                     /* IF CONDITION */
                     ir_if *f2EE6 = new(mem_ctx) ir_if(operand(r2EBA).val);
                     exec_list *const f2EE6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2EE6->then_instructions;

                        ir_variable *const r2EE7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r2EE7, add(r2EB6, body.constant(1u)), 0x01));

                        ir_expression *const r2EE8 = less(r2EE7, r2EB6);
                        ir_expression *const r2EE9 = expr(ir_unop_b2i, r2EE8);
                        ir_expression *const r2EEA = expr(ir_unop_i2u, r2EE9);
                        body.emit(assign(r2EB5, add(r2EB5, r2EEA), 0x01));

                        ir_expression *const r2EEB = equal(r2EB7, body.constant(0u));
                        ir_expression *const r2EEC = expr(ir_unop_b2i, r2EEB);
                        ir_expression *const r2EED = expr(ir_unop_i2u, r2EEC);
                        ir_expression *const r2EEE = add(r2EB7, r2EED);
                        ir_expression *const r2EEF = bit_and(r2EEE, body.constant(1u));
                        ir_expression *const r2EF0 = expr(ir_unop_bit_not, r2EEF);
                        body.emit(assign(r2EB6, bit_and(r2EE7, r2EF0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2EE6->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2EF2 = bit_or(r2EB5, r2EB6);
                        ir_expression *const r2EF3 = equal(r2EF2, body.constant(0u));
                        ir_if *f2EF1 = new(mem_ctx) ir_if(operand(r2EF3).val);
                        exec_list *const f2EF1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EF1->then_instructions;

                           body.emit(assign(r2EB4, body.constant(int(0)), 0x01));


                        body.instructions = f2EF1_parent_instructions;
                        body.emit(f2EF1);

                        /* END IF */


                     body.instructions = f2EE6_parent_instructions;
                     body.emit(f2EE6);

                     /* END IF */

                     ir_variable *const r2EF4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2EF4);
                     ir_expression *const r2EF5 = lshift(r2C88, body.constant(int(31)));
                     ir_expression *const r2EF6 = expr(ir_unop_i2u, r2EB4);
                     ir_expression *const r2EF7 = lshift(r2EF6, body.constant(int(20)));
                     ir_expression *const r2EF8 = add(r2EF5, r2EF7);
                     body.emit(assign(r2EF4, add(r2EF8, r2EB5), 0x02));

                     body.emit(assign(r2EF4, r2EB6, 0x01));

                     body.emit(assign(r2EB9, r2EF4, 0x03));

                     body.emit(assign(r2EB8, body.constant(false), 0x01));


                  body.instructions = f2EE5_parent_instructions;
                  body.emit(f2EE5);

                  /* END IF */

                  body.emit(assign(r2C89, r2EB9, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2E6D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2EFA = less(r2C8F, r2C8D);
                  ir_if *f2EF9 = new(mem_ctx) ir_if(operand(r2EFA).val);
                  exec_list *const f2EF9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2EF9->then_instructions;

                     ir_variable *const r2EFB = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r2EFC = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r2EFC, sub(r2C8E, r2C90), 0x01));

                     ir_expression *const r2EFD = sub(r2C8D, r2C8F);
                     ir_expression *const r2EFE = less(r2C8E, r2C90);
                     ir_expression *const r2EFF = expr(ir_unop_b2i, r2EFE);
                     ir_expression *const r2F00 = expr(ir_unop_i2u, r2EFF);
                     body.emit(assign(r2EFB, sub(r2EFD, r2F00), 0x01));

                     body.emit(assign(r2C88, bit_xor(r2C88, body.constant(1u)), 0x01));

                     body.emit(assign(r2C91, add(r2C8B, body.constant(int(-1))), 0x01));

                     ir_variable *const r2F01 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2F01, add(r2C91, body.constant(int(-10))), 0x01));

                     ir_variable *const r2F02 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2F02, r2EFB, 0x01));

                     ir_variable *const r2F03 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2F03, r2EFC, 0x01));

                     ir_variable *const r2F04 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r2F04);
                     ir_variable *const r2F05 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2F05);
                     /* IF CONDITION */
                     ir_expression *const r2F07 = equal(r2EFB, body.constant(0u));
                     ir_if *f2F06 = new(mem_ctx) ir_if(operand(r2F07).val);
                     exec_list *const f2F06_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F06->then_instructions;

                        body.emit(assign(r2F02, r2EFC, 0x01));

                        body.emit(assign(r2F03, body.constant(0u), 0x01));

                        body.emit(assign(r2F01, add(r2F01, body.constant(int(-32))), 0x01));


                     body.instructions = f2F06_parent_instructions;
                     body.emit(f2F06);

                     /* END IF */

                     ir_variable *const r2F08 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r2F08, r2F02, 0x01));

                     ir_variable *const r2F09 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r2F0A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2F0A);
                     /* IF CONDITION */
                     ir_expression *const r2F0C = equal(r2F02, body.constant(0u));
                     ir_if *f2F0B = new(mem_ctx) ir_if(operand(r2F0C).val);
                     exec_list *const f2F0B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F0B->then_instructions;

                        body.emit(assign(r2F09, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2F0B->else_instructions;

                        body.emit(assign(r2F0A, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2F0E = bit_and(r2F02, body.constant(4294901760u));
                        ir_expression *const r2F0F = equal(r2F0E, body.constant(0u));
                        ir_if *f2F0D = new(mem_ctx) ir_if(operand(r2F0F).val);
                        exec_list *const f2F0D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F0D->then_instructions;

                           body.emit(assign(r2F0A, body.constant(int(16)), 0x01));

                           body.emit(assign(r2F08, lshift(r2F02, body.constant(int(16))), 0x01));


                        body.instructions = f2F0D_parent_instructions;
                        body.emit(f2F0D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2F11 = bit_and(r2F08, body.constant(4278190080u));
                        ir_expression *const r2F12 = equal(r2F11, body.constant(0u));
                        ir_if *f2F10 = new(mem_ctx) ir_if(operand(r2F12).val);
                        exec_list *const f2F10_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F10->then_instructions;

                           body.emit(assign(r2F0A, add(r2F0A, body.constant(int(8))), 0x01));

                           body.emit(assign(r2F08, lshift(r2F08, body.constant(int(8))), 0x01));


                        body.instructions = f2F10_parent_instructions;
                        body.emit(f2F10);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2F14 = bit_and(r2F08, body.constant(4026531840u));
                        ir_expression *const r2F15 = equal(r2F14, body.constant(0u));
                        ir_if *f2F13 = new(mem_ctx) ir_if(operand(r2F15).val);
                        exec_list *const f2F13_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F13->then_instructions;

                           body.emit(assign(r2F0A, add(r2F0A, body.constant(int(4))), 0x01));

                           body.emit(assign(r2F08, lshift(r2F08, body.constant(int(4))), 0x01));


                        body.instructions = f2F13_parent_instructions;
                        body.emit(f2F13);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2F17 = bit_and(r2F08, body.constant(3221225472u));
                        ir_expression *const r2F18 = equal(r2F17, body.constant(0u));
                        ir_if *f2F16 = new(mem_ctx) ir_if(operand(r2F18).val);
                        exec_list *const f2F16_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F16->then_instructions;

                           body.emit(assign(r2F0A, add(r2F0A, body.constant(int(2))), 0x01));

                           body.emit(assign(r2F08, lshift(r2F08, body.constant(int(2))), 0x01));


                        body.instructions = f2F16_parent_instructions;
                        body.emit(f2F16);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2F1A = bit_and(r2F08, body.constant(2147483648u));
                        ir_expression *const r2F1B = equal(r2F1A, body.constant(0u));
                        ir_if *f2F19 = new(mem_ctx) ir_if(operand(r2F1B).val);
                        exec_list *const f2F19_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F19->then_instructions;

                           body.emit(assign(r2F0A, add(r2F0A, body.constant(int(1))), 0x01));


                        body.instructions = f2F19_parent_instructions;
                        body.emit(f2F19);

                        /* END IF */

                        body.emit(assign(r2F09, r2F0A, 0x01));


                     body.instructions = f2F0B_parent_instructions;
                     body.emit(f2F0B);

                     /* END IF */

                     body.emit(assign(r2F05, add(r2F09, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2F1D = lequal(body.constant(int(0)), r2F05);
                     ir_if *f2F1C = new(mem_ctx) ir_if(operand(r2F1D).val);
                     exec_list *const f2F1C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F1C->then_instructions;

                        body.emit(assign(r2F04, body.constant(0u), 0x01));

                        ir_variable *const r2F1E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2F1E, lshift(r2F03, r2F05), 0x01));

                        ir_variable *const r2F1F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2F21 = equal(r2F05, body.constant(int(0)));
                        ir_if *f2F20 = new(mem_ctx) ir_if(operand(r2F21).val);
                        exec_list *const f2F20_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F20->then_instructions;

                           body.emit(assign(r2F1F, r2F02, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F20->else_instructions;

                           ir_expression *const r2F22 = lshift(r2F02, r2F05);
                           ir_expression *const r2F23 = neg(r2F05);
                           ir_expression *const r2F24 = bit_and(r2F23, body.constant(int(31)));
                           ir_expression *const r2F25 = rshift(r2F03, r2F24);
                           body.emit(assign(r2F1F, bit_or(r2F22, r2F25), 0x01));


                        body.instructions = f2F20_parent_instructions;
                        body.emit(f2F20);

                        /* END IF */

                        body.emit(assign(r2F02, r2F1F, 0x01));

                        body.emit(assign(r2F03, r2F1E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2F1C->else_instructions;

                        ir_variable *const r2F26 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2F26, body.constant(0u), 0x01));

                        ir_variable *const r2F27 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2F27, neg(r2F05), 0x01));

                        ir_variable *const r2F28 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2F28);
                        ir_variable *const r2F29 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2F29);
                        ir_variable *const r2F2A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2F2A);
                        ir_variable *const r2F2B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2F2C = neg(r2F27);
                        body.emit(assign(r2F2B, bit_and(r2F2C, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2F2E = equal(r2F27, body.constant(int(0)));
                        ir_if *f2F2D = new(mem_ctx) ir_if(operand(r2F2E).val);
                        exec_list *const f2F2D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F2D->then_instructions;

                           body.emit(assign(r2F28, r2F26, 0x01));

                           body.emit(assign(r2F29, r2F03, 0x01));

                           body.emit(assign(r2F2A, r2F02, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F2D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2F30 = less(r2F27, body.constant(int(32)));
                           ir_if *f2F2F = new(mem_ctx) ir_if(operand(r2F30).val);
                           exec_list *const f2F2F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F2F->then_instructions;

                              body.emit(assign(r2F28, lshift(r2F03, r2F2B), 0x01));

                              ir_expression *const r2F31 = lshift(r2F02, r2F2B);
                              ir_expression *const r2F32 = rshift(r2F03, r2F27);
                              body.emit(assign(r2F29, bit_or(r2F31, r2F32), 0x01));

                              body.emit(assign(r2F2A, rshift(r2F02, r2F27), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2F2F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2F34 = equal(r2F27, body.constant(int(32)));
                              ir_if *f2F33 = new(mem_ctx) ir_if(operand(r2F34).val);
                              exec_list *const f2F33_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2F33->then_instructions;

                                 body.emit(assign(r2F28, r2F03, 0x01));

                                 body.emit(assign(r2F29, r2F02, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2F33->else_instructions;

                                 body.emit(assign(r2F26, bit_or(body.constant(0u), r2F03), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2F36 = less(r2F27, body.constant(int(64)));
                                 ir_if *f2F35 = new(mem_ctx) ir_if(operand(r2F36).val);
                                 exec_list *const f2F35_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2F35->then_instructions;

                                    body.emit(assign(r2F28, lshift(r2F02, r2F2B), 0x01));

                                    ir_expression *const r2F37 = bit_and(r2F27, body.constant(int(31)));
                                    body.emit(assign(r2F29, rshift(r2F02, r2F37), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2F35->else_instructions;

                                    ir_variable *const r2F38 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2F3A = equal(r2F27, body.constant(int(64)));
                                    ir_if *f2F39 = new(mem_ctx) ir_if(operand(r2F3A).val);
                                    exec_list *const f2F39_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2F39->then_instructions;

                                       body.emit(assign(r2F38, r2F02, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2F39->else_instructions;

                                       ir_expression *const r2F3B = nequal(r2F02, body.constant(0u));
                                       ir_expression *const r2F3C = expr(ir_unop_b2i, r2F3B);
                                       body.emit(assign(r2F38, expr(ir_unop_i2u, r2F3C), 0x01));


                                    body.instructions = f2F39_parent_instructions;
                                    body.emit(f2F39);

                                    /* END IF */

                                    body.emit(assign(r2F28, r2F38, 0x01));

                                    body.emit(assign(r2F29, body.constant(0u), 0x01));


                                 body.instructions = f2F35_parent_instructions;
                                 body.emit(f2F35);

                                 /* END IF */


                              body.instructions = f2F33_parent_instructions;
                              body.emit(f2F33);

                              /* END IF */

                              body.emit(assign(r2F2A, body.constant(0u), 0x01));


                           body.instructions = f2F2F_parent_instructions;
                           body.emit(f2F2F);

                           /* END IF */

                           ir_expression *const r2F3D = nequal(r2F26, body.constant(0u));
                           ir_expression *const r2F3E = expr(ir_unop_b2i, r2F3D);
                           ir_expression *const r2F3F = expr(ir_unop_i2u, r2F3E);
                           body.emit(assign(r2F28, bit_or(r2F28, r2F3F), 0x01));


                        body.instructions = f2F2D_parent_instructions;
                        body.emit(f2F2D);

                        /* END IF */

                        body.emit(assign(r2F02, r2F2A, 0x01));

                        body.emit(assign(r2F03, r2F29, 0x01));

                        body.emit(assign(r2F04, r2F28, 0x01));


                     body.instructions = f2F1C_parent_instructions;
                     body.emit(f2F1C);

                     /* END IF */

                     body.emit(assign(r2F01, sub(r2F01, r2F05), 0x01));

                     ir_variable *const r2F40 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2F40, r2F01, 0x01));

                     ir_variable *const r2F41 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2F41, r2F02, 0x01));

                     ir_variable *const r2F42 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2F42, r2F03, 0x01));

                     ir_variable *const r2F43 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2F43, r2F04, 0x01));

                     ir_variable *const r2F44 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2F44, body.constant(true), 0x01));

                     ir_variable *const r2F45 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2F46 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2F46);
                     ir_expression *const r2F47 = expr(ir_unop_u2i, r2F04);
                     body.emit(assign(r2F46, less(r2F47, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2F49 = lequal(body.constant(int(2045)), r2F01);
                     ir_if *f2F48 = new(mem_ctx) ir_if(operand(r2F49).val);
                     exec_list *const f2F48_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F48->then_instructions;

                        ir_variable *const r2F4A = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2F4C = less(body.constant(int(2045)), r2F01);
                        ir_if *f2F4B = new(mem_ctx) ir_if(operand(r2F4C).val);
                        exec_list *const f2F4B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F4B->then_instructions;

                           body.emit(assign(r2F4A, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F4B->else_instructions;

                           ir_variable *const r2F4D = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2F4F = equal(r2F01, body.constant(int(2045)));
                           ir_if *f2F4E = new(mem_ctx) ir_if(operand(r2F4F).val);
                           exec_list *const f2F4E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F4E->then_instructions;

                              ir_expression *const r2F50 = equal(body.constant(2097151u), r2F02);
                              ir_expression *const r2F51 = equal(body.constant(4294967295u), r2F03);
                              body.emit(assign(r2F4D, logic_and(r2F50, r2F51), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2F4E->else_instructions;

                              body.emit(assign(r2F4D, body.constant(false), 0x01));


                           body.instructions = f2F4E_parent_instructions;
                           body.emit(f2F4E);

                           /* END IF */

                           body.emit(assign(r2F4A, logic_and(r2F4D, r2F46), 0x01));


                        body.instructions = f2F4B_parent_instructions;
                        body.emit(f2F4B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2F52 = new(mem_ctx) ir_if(operand(r2F4A).val);
                        exec_list *const f2F52_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F52->then_instructions;

                           ir_variable *const r2F53 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2F53);
                           ir_expression *const r2F54 = lshift(r2C88, body.constant(int(31)));
                           body.emit(assign(r2F53, add(r2F54, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2F53, body.constant(0u), 0x01));

                           body.emit(assign(r2F45, r2F53, 0x03));

                           body.emit(assign(r2F44, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F52->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2F56 = less(r2F01, body.constant(int(0)));
                           ir_if *f2F55 = new(mem_ctx) ir_if(operand(r2F56).val);
                           exec_list *const f2F55_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F55->then_instructions;

                              ir_variable *const r2F57 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2F57, r2F04, 0x01));

                              ir_variable *const r2F58 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2F58, neg(r2F01), 0x01));

                              ir_variable *const r2F59 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2F59);
                              ir_variable *const r2F5A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2F5A);
                              ir_variable *const r2F5B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2F5B);
                              ir_variable *const r2F5C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2F5D = neg(r2F58);
                              body.emit(assign(r2F5C, bit_and(r2F5D, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2F5F = equal(r2F58, body.constant(int(0)));
                              ir_if *f2F5E = new(mem_ctx) ir_if(operand(r2F5F).val);
                              exec_list *const f2F5E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2F5E->then_instructions;

                                 body.emit(assign(r2F59, r2F04, 0x01));

                                 body.emit(assign(r2F5A, r2F03, 0x01));

                                 body.emit(assign(r2F5B, r2F02, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2F5E->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2F61 = less(r2F58, body.constant(int(32)));
                                 ir_if *f2F60 = new(mem_ctx) ir_if(operand(r2F61).val);
                                 exec_list *const f2F60_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2F60->then_instructions;

                                    body.emit(assign(r2F59, lshift(r2F03, r2F5C), 0x01));

                                    ir_expression *const r2F62 = lshift(r2F02, r2F5C);
                                    ir_expression *const r2F63 = rshift(r2F03, r2F58);
                                    body.emit(assign(r2F5A, bit_or(r2F62, r2F63), 0x01));

                                    body.emit(assign(r2F5B, rshift(r2F02, r2F58), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2F60->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2F65 = equal(r2F58, body.constant(int(32)));
                                    ir_if *f2F64 = new(mem_ctx) ir_if(operand(r2F65).val);
                                    exec_list *const f2F64_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2F64->then_instructions;

                                       body.emit(assign(r2F59, r2F03, 0x01));

                                       body.emit(assign(r2F5A, r2F02, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2F64->else_instructions;

                                       body.emit(assign(r2F57, bit_or(r2F04, r2F03), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2F67 = less(r2F58, body.constant(int(64)));
                                       ir_if *f2F66 = new(mem_ctx) ir_if(operand(r2F67).val);
                                       exec_list *const f2F66_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2F66->then_instructions;

                                          body.emit(assign(r2F59, lshift(r2F02, r2F5C), 0x01));

                                          ir_expression *const r2F68 = bit_and(r2F58, body.constant(int(31)));
                                          body.emit(assign(r2F5A, rshift(r2F02, r2F68), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2F66->else_instructions;

                                          ir_variable *const r2F69 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2F6B = equal(r2F58, body.constant(int(64)));
                                          ir_if *f2F6A = new(mem_ctx) ir_if(operand(r2F6B).val);
                                          exec_list *const f2F6A_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2F6A->then_instructions;

                                             body.emit(assign(r2F69, r2F02, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2F6A->else_instructions;

                                             ir_expression *const r2F6C = nequal(r2F02, body.constant(0u));
                                             ir_expression *const r2F6D = expr(ir_unop_b2i, r2F6C);
                                             body.emit(assign(r2F69, expr(ir_unop_i2u, r2F6D), 0x01));


                                          body.instructions = f2F6A_parent_instructions;
                                          body.emit(f2F6A);

                                          /* END IF */

                                          body.emit(assign(r2F59, r2F69, 0x01));

                                          body.emit(assign(r2F5A, body.constant(0u), 0x01));


                                       body.instructions = f2F66_parent_instructions;
                                       body.emit(f2F66);

                                       /* END IF */


                                    body.instructions = f2F64_parent_instructions;
                                    body.emit(f2F64);

                                    /* END IF */

                                    body.emit(assign(r2F5B, body.constant(0u), 0x01));


                                 body.instructions = f2F60_parent_instructions;
                                 body.emit(f2F60);

                                 /* END IF */

                                 ir_expression *const r2F6E = nequal(r2F57, body.constant(0u));
                                 ir_expression *const r2F6F = expr(ir_unop_b2i, r2F6E);
                                 ir_expression *const r2F70 = expr(ir_unop_i2u, r2F6F);
                                 body.emit(assign(r2F59, bit_or(r2F59, r2F70), 0x01));


                              body.instructions = f2F5E_parent_instructions;
                              body.emit(f2F5E);

                              /* END IF */

                              body.emit(assign(r2F41, r2F5B, 0x01));

                              body.emit(assign(r2F42, r2F5A, 0x01));

                              body.emit(assign(r2F43, r2F59, 0x01));

                              body.emit(assign(r2F40, body.constant(int(0)), 0x01));

                              body.emit(assign(r2F46, less(r2F59, body.constant(0u)), 0x01));


                           body.instructions = f2F55_parent_instructions;
                           body.emit(f2F55);

                           /* END IF */


                        body.instructions = f2F52_parent_instructions;
                        body.emit(f2F52);

                        /* END IF */


                     body.instructions = f2F48_parent_instructions;
                     body.emit(f2F48);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2F71 = new(mem_ctx) ir_if(operand(r2F44).val);
                     exec_list *const f2F71_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F71->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2F72 = new(mem_ctx) ir_if(operand(r2F46).val);
                        exec_list *const f2F72_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F72->then_instructions;

                           ir_variable *const r2F73 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2F73, add(r2F42, body.constant(1u)), 0x01));

                           ir_expression *const r2F74 = less(r2F73, r2F42);
                           ir_expression *const r2F75 = expr(ir_unop_b2i, r2F74);
                           ir_expression *const r2F76 = expr(ir_unop_i2u, r2F75);
                           body.emit(assign(r2F41, add(r2F41, r2F76), 0x01));

                           ir_expression *const r2F77 = equal(r2F43, body.constant(0u));
                           ir_expression *const r2F78 = expr(ir_unop_b2i, r2F77);
                           ir_expression *const r2F79 = expr(ir_unop_i2u, r2F78);
                           ir_expression *const r2F7A = add(r2F43, r2F79);
                           ir_expression *const r2F7B = bit_and(r2F7A, body.constant(1u));
                           ir_expression *const r2F7C = expr(ir_unop_bit_not, r2F7B);
                           body.emit(assign(r2F42, bit_and(r2F73, r2F7C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F72->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2F7E = bit_or(r2F41, r2F42);
                           ir_expression *const r2F7F = equal(r2F7E, body.constant(0u));
                           ir_if *f2F7D = new(mem_ctx) ir_if(operand(r2F7F).val);
                           exec_list *const f2F7D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F7D->then_instructions;

                              body.emit(assign(r2F40, body.constant(int(0)), 0x01));


                           body.instructions = f2F7D_parent_instructions;
                           body.emit(f2F7D);

                           /* END IF */


                        body.instructions = f2F72_parent_instructions;
                        body.emit(f2F72);

                        /* END IF */

                        ir_variable *const r2F80 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2F80);
                        ir_expression *const r2F81 = lshift(r2C88, body.constant(int(31)));
                        ir_expression *const r2F82 = expr(ir_unop_i2u, r2F40);
                        ir_expression *const r2F83 = lshift(r2F82, body.constant(int(20)));
                        ir_expression *const r2F84 = add(r2F81, r2F83);
                        body.emit(assign(r2F80, add(r2F84, r2F41), 0x02));

                        body.emit(assign(r2F80, r2F42, 0x01));

                        body.emit(assign(r2F45, r2F80, 0x03));

                        body.emit(assign(r2F44, body.constant(false), 0x01));


                     body.instructions = f2F71_parent_instructions;
                     body.emit(f2F71);

                     /* END IF */

                     body.emit(assign(r2C89, r2F45, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2EF9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2F86 = less(r2C8E, r2C90);
                     ir_if *f2F85 = new(mem_ctx) ir_if(operand(r2F86).val);
                     exec_list *const f2F85_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F85->then_instructions;

                        ir_variable *const r2F87 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r2F88 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2F88, sub(r2C90, r2C8E), 0x01));

                        ir_expression *const r2F89 = sub(r2C8F, r2C8D);
                        ir_expression *const r2F8A = less(r2C90, r2C8E);
                        ir_expression *const r2F8B = expr(ir_unop_b2i, r2F8A);
                        ir_expression *const r2F8C = expr(ir_unop_i2u, r2F8B);
                        body.emit(assign(r2F87, sub(r2F89, r2F8C), 0x01));

                        body.emit(assign(r2C91, add(r2C8C, body.constant(int(-1))), 0x01));

                        ir_variable *const r2F8D = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2F8D, add(r2C91, body.constant(int(-10))), 0x01));

                        ir_variable *const r2F8E = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2F8E, r2F87, 0x01));

                        ir_variable *const r2F8F = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2F8F, r2F88, 0x01));

                        ir_variable *const r2F90 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r2F90);
                        ir_variable *const r2F91 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2F91);
                        /* IF CONDITION */
                        ir_expression *const r2F93 = equal(r2F87, body.constant(0u));
                        ir_if *f2F92 = new(mem_ctx) ir_if(operand(r2F93).val);
                        exec_list *const f2F92_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F92->then_instructions;

                           body.emit(assign(r2F8E, r2F88, 0x01));

                           body.emit(assign(r2F8F, body.constant(0u), 0x01));

                           body.emit(assign(r2F8D, add(r2F8D, body.constant(int(-32))), 0x01));


                        body.instructions = f2F92_parent_instructions;
                        body.emit(f2F92);

                        /* END IF */

                        ir_variable *const r2F94 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r2F94, r2F8E, 0x01));

                        ir_variable *const r2F95 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r2F96 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2F96);
                        /* IF CONDITION */
                        ir_expression *const r2F98 = equal(r2F8E, body.constant(0u));
                        ir_if *f2F97 = new(mem_ctx) ir_if(operand(r2F98).val);
                        exec_list *const f2F97_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F97->then_instructions;

                           body.emit(assign(r2F95, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F97->else_instructions;

                           body.emit(assign(r2F96, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2F9A = bit_and(r2F8E, body.constant(4294901760u));
                           ir_expression *const r2F9B = equal(r2F9A, body.constant(0u));
                           ir_if *f2F99 = new(mem_ctx) ir_if(operand(r2F9B).val);
                           exec_list *const f2F99_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F99->then_instructions;

                              body.emit(assign(r2F96, body.constant(int(16)), 0x01));

                              body.emit(assign(r2F94, lshift(r2F8E, body.constant(int(16))), 0x01));


                           body.instructions = f2F99_parent_instructions;
                           body.emit(f2F99);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2F9D = bit_and(r2F94, body.constant(4278190080u));
                           ir_expression *const r2F9E = equal(r2F9D, body.constant(0u));
                           ir_if *f2F9C = new(mem_ctx) ir_if(operand(r2F9E).val);
                           exec_list *const f2F9C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F9C->then_instructions;

                              body.emit(assign(r2F96, add(r2F96, body.constant(int(8))), 0x01));

                              body.emit(assign(r2F94, lshift(r2F94, body.constant(int(8))), 0x01));


                           body.instructions = f2F9C_parent_instructions;
                           body.emit(f2F9C);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2FA0 = bit_and(r2F94, body.constant(4026531840u));
                           ir_expression *const r2FA1 = equal(r2FA0, body.constant(0u));
                           ir_if *f2F9F = new(mem_ctx) ir_if(operand(r2FA1).val);
                           exec_list *const f2F9F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F9F->then_instructions;

                              body.emit(assign(r2F96, add(r2F96, body.constant(int(4))), 0x01));

                              body.emit(assign(r2F94, lshift(r2F94, body.constant(int(4))), 0x01));


                           body.instructions = f2F9F_parent_instructions;
                           body.emit(f2F9F);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2FA3 = bit_and(r2F94, body.constant(3221225472u));
                           ir_expression *const r2FA4 = equal(r2FA3, body.constant(0u));
                           ir_if *f2FA2 = new(mem_ctx) ir_if(operand(r2FA4).val);
                           exec_list *const f2FA2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FA2->then_instructions;

                              body.emit(assign(r2F96, add(r2F96, body.constant(int(2))), 0x01));

                              body.emit(assign(r2F94, lshift(r2F94, body.constant(int(2))), 0x01));


                           body.instructions = f2FA2_parent_instructions;
                           body.emit(f2FA2);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2FA6 = bit_and(r2F94, body.constant(2147483648u));
                           ir_expression *const r2FA7 = equal(r2FA6, body.constant(0u));
                           ir_if *f2FA5 = new(mem_ctx) ir_if(operand(r2FA7).val);
                           exec_list *const f2FA5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FA5->then_instructions;

                              body.emit(assign(r2F96, add(r2F96, body.constant(int(1))), 0x01));


                           body.instructions = f2FA5_parent_instructions;
                           body.emit(f2FA5);

                           /* END IF */

                           body.emit(assign(r2F95, r2F96, 0x01));


                        body.instructions = f2F97_parent_instructions;
                        body.emit(f2F97);

                        /* END IF */

                        body.emit(assign(r2F91, add(r2F95, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2FA9 = lequal(body.constant(int(0)), r2F91);
                        ir_if *f2FA8 = new(mem_ctx) ir_if(operand(r2FA9).val);
                        exec_list *const f2FA8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2FA8->then_instructions;

                           body.emit(assign(r2F90, body.constant(0u), 0x01));

                           ir_variable *const r2FAA = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2FAA, lshift(r2F8F, r2F91), 0x01));

                           ir_variable *const r2FAB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2FAD = equal(r2F91, body.constant(int(0)));
                           ir_if *f2FAC = new(mem_ctx) ir_if(operand(r2FAD).val);
                           exec_list *const f2FAC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FAC->then_instructions;

                              body.emit(assign(r2FAB, r2F8E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2FAC->else_instructions;

                              ir_expression *const r2FAE = lshift(r2F8E, r2F91);
                              ir_expression *const r2FAF = neg(r2F91);
                              ir_expression *const r2FB0 = bit_and(r2FAF, body.constant(int(31)));
                              ir_expression *const r2FB1 = rshift(r2F8F, r2FB0);
                              body.emit(assign(r2FAB, bit_or(r2FAE, r2FB1), 0x01));


                           body.instructions = f2FAC_parent_instructions;
                           body.emit(f2FAC);

                           /* END IF */

                           body.emit(assign(r2F8E, r2FAB, 0x01));

                           body.emit(assign(r2F8F, r2FAA, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2FA8->else_instructions;

                           ir_variable *const r2FB2 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r2FB2, body.constant(0u), 0x01));

                           ir_variable *const r2FB3 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2FB3, neg(r2F91), 0x01));

                           ir_variable *const r2FB4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r2FB4);
                           ir_variable *const r2FB5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r2FB5);
                           ir_variable *const r2FB6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r2FB6);
                           ir_variable *const r2FB7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r2FB8 = neg(r2FB3);
                           body.emit(assign(r2FB7, bit_and(r2FB8, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2FBA = equal(r2FB3, body.constant(int(0)));
                           ir_if *f2FB9 = new(mem_ctx) ir_if(operand(r2FBA).val);
                           exec_list *const f2FB9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FB9->then_instructions;

                              body.emit(assign(r2FB4, r2FB2, 0x01));

                              body.emit(assign(r2FB5, r2F8F, 0x01));

                              body.emit(assign(r2FB6, r2F8E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2FB9->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2FBC = less(r2FB3, body.constant(int(32)));
                              ir_if *f2FBB = new(mem_ctx) ir_if(operand(r2FBC).val);
                              exec_list *const f2FBB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2FBB->then_instructions;

                                 body.emit(assign(r2FB4, lshift(r2F8F, r2FB7), 0x01));

                                 ir_expression *const r2FBD = lshift(r2F8E, r2FB7);
                                 ir_expression *const r2FBE = rshift(r2F8F, r2FB3);
                                 body.emit(assign(r2FB5, bit_or(r2FBD, r2FBE), 0x01));

                                 body.emit(assign(r2FB6, rshift(r2F8E, r2FB3), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2FBB->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2FC0 = equal(r2FB3, body.constant(int(32)));
                                 ir_if *f2FBF = new(mem_ctx) ir_if(operand(r2FC0).val);
                                 exec_list *const f2FBF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2FBF->then_instructions;

                                    body.emit(assign(r2FB4, r2F8F, 0x01));

                                    body.emit(assign(r2FB5, r2F8E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2FBF->else_instructions;

                                    body.emit(assign(r2FB2, bit_or(body.constant(0u), r2F8F), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2FC2 = less(r2FB3, body.constant(int(64)));
                                    ir_if *f2FC1 = new(mem_ctx) ir_if(operand(r2FC2).val);
                                    exec_list *const f2FC1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2FC1->then_instructions;

                                       body.emit(assign(r2FB4, lshift(r2F8E, r2FB7), 0x01));

                                       ir_expression *const r2FC3 = bit_and(r2FB3, body.constant(int(31)));
                                       body.emit(assign(r2FB5, rshift(r2F8E, r2FC3), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2FC1->else_instructions;

                                       ir_variable *const r2FC4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r2FC6 = equal(r2FB3, body.constant(int(64)));
                                       ir_if *f2FC5 = new(mem_ctx) ir_if(operand(r2FC6).val);
                                       exec_list *const f2FC5_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2FC5->then_instructions;

                                          body.emit(assign(r2FC4, r2F8E, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2FC5->else_instructions;

                                          ir_expression *const r2FC7 = nequal(r2F8E, body.constant(0u));
                                          ir_expression *const r2FC8 = expr(ir_unop_b2i, r2FC7);
                                          body.emit(assign(r2FC4, expr(ir_unop_i2u, r2FC8), 0x01));


                                       body.instructions = f2FC5_parent_instructions;
                                       body.emit(f2FC5);

                                       /* END IF */

                                       body.emit(assign(r2FB4, r2FC4, 0x01));

                                       body.emit(assign(r2FB5, body.constant(0u), 0x01));


                                    body.instructions = f2FC1_parent_instructions;
                                    body.emit(f2FC1);

                                    /* END IF */


                                 body.instructions = f2FBF_parent_instructions;
                                 body.emit(f2FBF);

                                 /* END IF */

                                 body.emit(assign(r2FB6, body.constant(0u), 0x01));


                              body.instructions = f2FBB_parent_instructions;
                              body.emit(f2FBB);

                              /* END IF */

                              ir_expression *const r2FC9 = nequal(r2FB2, body.constant(0u));
                              ir_expression *const r2FCA = expr(ir_unop_b2i, r2FC9);
                              ir_expression *const r2FCB = expr(ir_unop_i2u, r2FCA);
                              body.emit(assign(r2FB4, bit_or(r2FB4, r2FCB), 0x01));


                           body.instructions = f2FB9_parent_instructions;
                           body.emit(f2FB9);

                           /* END IF */

                           body.emit(assign(r2F8E, r2FB6, 0x01));

                           body.emit(assign(r2F8F, r2FB5, 0x01));

                           body.emit(assign(r2F90, r2FB4, 0x01));


                        body.instructions = f2FA8_parent_instructions;
                        body.emit(f2FA8);

                        /* END IF */

                        body.emit(assign(r2F8D, sub(r2F8D, r2F91), 0x01));

                        ir_variable *const r2FCC = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2FCC, r2F8D, 0x01));

                        ir_variable *const r2FCD = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2FCD, r2F8E, 0x01));

                        ir_variable *const r2FCE = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2FCE, r2F8F, 0x01));

                        ir_variable *const r2FCF = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r2FCF, r2F90, 0x01));

                        ir_variable *const r2FD0 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r2FD0, body.constant(true), 0x01));

                        ir_variable *const r2FD1 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r2FD2 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r2FD2);
                        ir_expression *const r2FD3 = expr(ir_unop_u2i, r2F90);
                        body.emit(assign(r2FD2, less(r2FD3, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2FD5 = lequal(body.constant(int(2045)), r2F8D);
                        ir_if *f2FD4 = new(mem_ctx) ir_if(operand(r2FD5).val);
                        exec_list *const f2FD4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2FD4->then_instructions;

                           ir_variable *const r2FD6 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2FD8 = less(body.constant(int(2045)), r2F8D);
                           ir_if *f2FD7 = new(mem_ctx) ir_if(operand(r2FD8).val);
                           exec_list *const f2FD7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FD7->then_instructions;

                              body.emit(assign(r2FD6, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2FD7->else_instructions;

                              ir_variable *const r2FD9 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2FDB = equal(r2F8D, body.constant(int(2045)));
                              ir_if *f2FDA = new(mem_ctx) ir_if(operand(r2FDB).val);
                              exec_list *const f2FDA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2FDA->then_instructions;

                                 ir_expression *const r2FDC = equal(body.constant(2097151u), r2F8E);
                                 ir_expression *const r2FDD = equal(body.constant(4294967295u), r2F8F);
                                 body.emit(assign(r2FD9, logic_and(r2FDC, r2FDD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2FDA->else_instructions;

                                 body.emit(assign(r2FD9, body.constant(false), 0x01));


                              body.instructions = f2FDA_parent_instructions;
                              body.emit(f2FDA);

                              /* END IF */

                              body.emit(assign(r2FD6, logic_and(r2FD9, r2FD2), 0x01));


                           body.instructions = f2FD7_parent_instructions;
                           body.emit(f2FD7);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2FDE = new(mem_ctx) ir_if(operand(r2FD6).val);
                           exec_list *const f2FDE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FDE->then_instructions;

                              ir_variable *const r2FDF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2FDF);
                              ir_expression *const r2FE0 = lshift(r2C88, body.constant(int(31)));
                              body.emit(assign(r2FDF, add(r2FE0, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r2FDF, body.constant(0u), 0x01));

                              body.emit(assign(r2FD1, r2FDF, 0x03));

                              body.emit(assign(r2FD0, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2FDE->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2FE2 = less(r2F8D, body.constant(int(0)));
                              ir_if *f2FE1 = new(mem_ctx) ir_if(operand(r2FE2).val);
                              exec_list *const f2FE1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2FE1->then_instructions;

                                 ir_variable *const r2FE3 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2FE3, r2F90, 0x01));

                                 ir_variable *const r2FE4 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2FE4, neg(r2F8D), 0x01));

                                 ir_variable *const r2FE5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2FE5);
                                 ir_variable *const r2FE6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2FE6);
                                 ir_variable *const r2FE7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2FE7);
                                 ir_variable *const r2FE8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2FE9 = neg(r2FE4);
                                 body.emit(assign(r2FE8, bit_and(r2FE9, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2FEB = equal(r2FE4, body.constant(int(0)));
                                 ir_if *f2FEA = new(mem_ctx) ir_if(operand(r2FEB).val);
                                 exec_list *const f2FEA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2FEA->then_instructions;

                                    body.emit(assign(r2FE5, r2F90, 0x01));

                                    body.emit(assign(r2FE6, r2F8F, 0x01));

                                    body.emit(assign(r2FE7, r2F8E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2FEA->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2FED = less(r2FE4, body.constant(int(32)));
                                    ir_if *f2FEC = new(mem_ctx) ir_if(operand(r2FED).val);
                                    exec_list *const f2FEC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2FEC->then_instructions;

                                       body.emit(assign(r2FE5, lshift(r2F8F, r2FE8), 0x01));

                                       ir_expression *const r2FEE = lshift(r2F8E, r2FE8);
                                       ir_expression *const r2FEF = rshift(r2F8F, r2FE4);
                                       body.emit(assign(r2FE6, bit_or(r2FEE, r2FEF), 0x01));

                                       body.emit(assign(r2FE7, rshift(r2F8E, r2FE4), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2FEC->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2FF1 = equal(r2FE4, body.constant(int(32)));
                                       ir_if *f2FF0 = new(mem_ctx) ir_if(operand(r2FF1).val);
                                       exec_list *const f2FF0_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2FF0->then_instructions;

                                          body.emit(assign(r2FE5, r2F8F, 0x01));

                                          body.emit(assign(r2FE6, r2F8E, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2FF0->else_instructions;

                                          body.emit(assign(r2FE3, bit_or(r2F90, r2F8F), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2FF3 = less(r2FE4, body.constant(int(64)));
                                          ir_if *f2FF2 = new(mem_ctx) ir_if(operand(r2FF3).val);
                                          exec_list *const f2FF2_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2FF2->then_instructions;

                                             body.emit(assign(r2FE5, lshift(r2F8E, r2FE8), 0x01));

                                             ir_expression *const r2FF4 = bit_and(r2FE4, body.constant(int(31)));
                                             body.emit(assign(r2FE6, rshift(r2F8E, r2FF4), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2FF2->else_instructions;

                                             ir_variable *const r2FF5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2FF7 = equal(r2FE4, body.constant(int(64)));
                                             ir_if *f2FF6 = new(mem_ctx) ir_if(operand(r2FF7).val);
                                             exec_list *const f2FF6_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2FF6->then_instructions;

                                                body.emit(assign(r2FF5, r2F8E, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2FF6->else_instructions;

                                                ir_expression *const r2FF8 = nequal(r2F8E, body.constant(0u));
                                                ir_expression *const r2FF9 = expr(ir_unop_b2i, r2FF8);
                                                body.emit(assign(r2FF5, expr(ir_unop_i2u, r2FF9), 0x01));


                                             body.instructions = f2FF6_parent_instructions;
                                             body.emit(f2FF6);

                                             /* END IF */

                                             body.emit(assign(r2FE5, r2FF5, 0x01));

                                             body.emit(assign(r2FE6, body.constant(0u), 0x01));


                                          body.instructions = f2FF2_parent_instructions;
                                          body.emit(f2FF2);

                                          /* END IF */


                                       body.instructions = f2FF0_parent_instructions;
                                       body.emit(f2FF0);

                                       /* END IF */

                                       body.emit(assign(r2FE7, body.constant(0u), 0x01));


                                    body.instructions = f2FEC_parent_instructions;
                                    body.emit(f2FEC);

                                    /* END IF */

                                    ir_expression *const r2FFA = nequal(r2FE3, body.constant(0u));
                                    ir_expression *const r2FFB = expr(ir_unop_b2i, r2FFA);
                                    ir_expression *const r2FFC = expr(ir_unop_i2u, r2FFB);
                                    body.emit(assign(r2FE5, bit_or(r2FE5, r2FFC), 0x01));


                                 body.instructions = f2FEA_parent_instructions;
                                 body.emit(f2FEA);

                                 /* END IF */

                                 body.emit(assign(r2FCD, r2FE7, 0x01));

                                 body.emit(assign(r2FCE, r2FE6, 0x01));

                                 body.emit(assign(r2FCF, r2FE5, 0x01));

                                 body.emit(assign(r2FCC, body.constant(int(0)), 0x01));

                                 body.emit(assign(r2FD2, less(r2FE5, body.constant(0u)), 0x01));


                              body.instructions = f2FE1_parent_instructions;
                              body.emit(f2FE1);

                              /* END IF */


                           body.instructions = f2FDE_parent_instructions;
                           body.emit(f2FDE);

                           /* END IF */


                        body.instructions = f2FD4_parent_instructions;
                        body.emit(f2FD4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2FFD = new(mem_ctx) ir_if(operand(r2FD0).val);
                        exec_list *const f2FFD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2FFD->then_instructions;

                           /* IF CONDITION */
                           ir_if *f2FFE = new(mem_ctx) ir_if(operand(r2FD2).val);
                           exec_list *const f2FFE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FFE->then_instructions;

                              ir_variable *const r2FFF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r2FFF, add(r2FCE, body.constant(1u)), 0x01));

                              ir_expression *const r3000 = less(r2FFF, r2FCE);
                              ir_expression *const r3001 = expr(ir_unop_b2i, r3000);
                              ir_expression *const r3002 = expr(ir_unop_i2u, r3001);
                              body.emit(assign(r2FCD, add(r2FCD, r3002), 0x01));

                              ir_expression *const r3003 = equal(r2FCF, body.constant(0u));
                              ir_expression *const r3004 = expr(ir_unop_b2i, r3003);
                              ir_expression *const r3005 = expr(ir_unop_i2u, r3004);
                              ir_expression *const r3006 = add(r2FCF, r3005);
                              ir_expression *const r3007 = bit_and(r3006, body.constant(1u));
                              ir_expression *const r3008 = expr(ir_unop_bit_not, r3007);
                              body.emit(assign(r2FCE, bit_and(r2FFF, r3008), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2FFE->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r300A = bit_or(r2FCD, r2FCE);
                              ir_expression *const r300B = equal(r300A, body.constant(0u));
                              ir_if *f3009 = new(mem_ctx) ir_if(operand(r300B).val);
                              exec_list *const f3009_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3009->then_instructions;

                                 body.emit(assign(r2FCC, body.constant(int(0)), 0x01));


                              body.instructions = f3009_parent_instructions;
                              body.emit(f3009);

                              /* END IF */


                           body.instructions = f2FFE_parent_instructions;
                           body.emit(f2FFE);

                           /* END IF */

                           ir_variable *const r300C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r300C);
                           ir_expression *const r300D = lshift(r2C88, body.constant(int(31)));
                           ir_expression *const r300E = expr(ir_unop_i2u, r2FCC);
                           ir_expression *const r300F = lshift(r300E, body.constant(int(20)));
                           ir_expression *const r3010 = add(r300D, r300F);
                           body.emit(assign(r300C, add(r3010, r2FCD), 0x02));

                           body.emit(assign(r300C, r2FCE, 0x01));

                           body.emit(assign(r2FD1, r300C, 0x03));

                           body.emit(assign(r2FD0, body.constant(false), 0x01));


                        body.instructions = f2FFD_parent_instructions;
                        body.emit(f2FFD);

                        /* END IF */

                        body.emit(assign(r2C89, r2FD1, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2F85->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3012 = less(r2C90, r2C8E);
                        ir_if *f3011 = new(mem_ctx) ir_if(operand(r3012).val);
                        exec_list *const f3011_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3011->then_instructions;

                           ir_variable *const r3013 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r3014 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r3014, sub(r2C8E, r2C90), 0x01));

                           ir_expression *const r3015 = sub(r2C8D, r2C8F);
                           ir_expression *const r3016 = less(r2C8E, r2C90);
                           ir_expression *const r3017 = expr(ir_unop_b2i, r3016);
                           ir_expression *const r3018 = expr(ir_unop_i2u, r3017);
                           body.emit(assign(r3013, sub(r3015, r3018), 0x01));

                           body.emit(assign(r2C88, bit_xor(r2C88, body.constant(1u)), 0x01));

                           body.emit(assign(r2C91, add(r2C8B, body.constant(int(-1))), 0x01));

                           ir_variable *const r3019 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r3019, add(r2C91, body.constant(int(-10))), 0x01));

                           ir_variable *const r301A = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r301A, r3013, 0x01));

                           ir_variable *const r301B = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r301B, r3014, 0x01));

                           ir_variable *const r301C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r301C);
                           ir_variable *const r301D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r301D);
                           /* IF CONDITION */
                           ir_expression *const r301F = equal(r3013, body.constant(0u));
                           ir_if *f301E = new(mem_ctx) ir_if(operand(r301F).val);
                           exec_list *const f301E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f301E->then_instructions;

                              body.emit(assign(r301A, r3014, 0x01));

                              body.emit(assign(r301B, body.constant(0u), 0x01));

                              body.emit(assign(r3019, add(r3019, body.constant(int(-32))), 0x01));


                           body.instructions = f301E_parent_instructions;
                           body.emit(f301E);

                           /* END IF */

                           ir_variable *const r3020 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r3020, r301A, 0x01));

                           ir_variable *const r3021 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r3022 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r3022);
                           /* IF CONDITION */
                           ir_expression *const r3024 = equal(r301A, body.constant(0u));
                           ir_if *f3023 = new(mem_ctx) ir_if(operand(r3024).val);
                           exec_list *const f3023_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3023->then_instructions;

                              body.emit(assign(r3021, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3023->else_instructions;

                              body.emit(assign(r3022, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3026 = bit_and(r301A, body.constant(4294901760u));
                              ir_expression *const r3027 = equal(r3026, body.constant(0u));
                              ir_if *f3025 = new(mem_ctx) ir_if(operand(r3027).val);
                              exec_list *const f3025_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3025->then_instructions;

                                 body.emit(assign(r3022, body.constant(int(16)), 0x01));

                                 body.emit(assign(r3020, lshift(r301A, body.constant(int(16))), 0x01));


                              body.instructions = f3025_parent_instructions;
                              body.emit(f3025);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3029 = bit_and(r3020, body.constant(4278190080u));
                              ir_expression *const r302A = equal(r3029, body.constant(0u));
                              ir_if *f3028 = new(mem_ctx) ir_if(operand(r302A).val);
                              exec_list *const f3028_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3028->then_instructions;

                                 body.emit(assign(r3022, add(r3022, body.constant(int(8))), 0x01));

                                 body.emit(assign(r3020, lshift(r3020, body.constant(int(8))), 0x01));


                              body.instructions = f3028_parent_instructions;
                              body.emit(f3028);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r302C = bit_and(r3020, body.constant(4026531840u));
                              ir_expression *const r302D = equal(r302C, body.constant(0u));
                              ir_if *f302B = new(mem_ctx) ir_if(operand(r302D).val);
                              exec_list *const f302B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f302B->then_instructions;

                                 body.emit(assign(r3022, add(r3022, body.constant(int(4))), 0x01));

                                 body.emit(assign(r3020, lshift(r3020, body.constant(int(4))), 0x01));


                              body.instructions = f302B_parent_instructions;
                              body.emit(f302B);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r302F = bit_and(r3020, body.constant(3221225472u));
                              ir_expression *const r3030 = equal(r302F, body.constant(0u));
                              ir_if *f302E = new(mem_ctx) ir_if(operand(r3030).val);
                              exec_list *const f302E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f302E->then_instructions;

                                 body.emit(assign(r3022, add(r3022, body.constant(int(2))), 0x01));

                                 body.emit(assign(r3020, lshift(r3020, body.constant(int(2))), 0x01));


                              body.instructions = f302E_parent_instructions;
                              body.emit(f302E);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3032 = bit_and(r3020, body.constant(2147483648u));
                              ir_expression *const r3033 = equal(r3032, body.constant(0u));
                              ir_if *f3031 = new(mem_ctx) ir_if(operand(r3033).val);
                              exec_list *const f3031_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3031->then_instructions;

                                 body.emit(assign(r3022, add(r3022, body.constant(int(1))), 0x01));


                              body.instructions = f3031_parent_instructions;
                              body.emit(f3031);

                              /* END IF */

                              body.emit(assign(r3021, r3022, 0x01));


                           body.instructions = f3023_parent_instructions;
                           body.emit(f3023);

                           /* END IF */

                           body.emit(assign(r301D, add(r3021, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3035 = lequal(body.constant(int(0)), r301D);
                           ir_if *f3034 = new(mem_ctx) ir_if(operand(r3035).val);
                           exec_list *const f3034_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3034->then_instructions;

                              body.emit(assign(r301C, body.constant(0u), 0x01));

                              ir_variable *const r3036 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r3036, lshift(r301B, r301D), 0x01));

                              ir_variable *const r3037 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3039 = equal(r301D, body.constant(int(0)));
                              ir_if *f3038 = new(mem_ctx) ir_if(operand(r3039).val);
                              exec_list *const f3038_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3038->then_instructions;

                                 body.emit(assign(r3037, r301A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3038->else_instructions;

                                 ir_expression *const r303A = lshift(r301A, r301D);
                                 ir_expression *const r303B = neg(r301D);
                                 ir_expression *const r303C = bit_and(r303B, body.constant(int(31)));
                                 ir_expression *const r303D = rshift(r301B, r303C);
                                 body.emit(assign(r3037, bit_or(r303A, r303D), 0x01));


                              body.instructions = f3038_parent_instructions;
                              body.emit(f3038);

                              /* END IF */

                              body.emit(assign(r301A, r3037, 0x01));

                              body.emit(assign(r301B, r3036, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3034->else_instructions;

                              ir_variable *const r303E = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r303E, body.constant(0u), 0x01));

                              ir_variable *const r303F = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r303F, neg(r301D), 0x01));

                              ir_variable *const r3040 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r3040);
                              ir_variable *const r3041 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r3041);
                              ir_variable *const r3042 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r3042);
                              ir_variable *const r3043 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r3044 = neg(r303F);
                              body.emit(assign(r3043, bit_and(r3044, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3046 = equal(r303F, body.constant(int(0)));
                              ir_if *f3045 = new(mem_ctx) ir_if(operand(r3046).val);
                              exec_list *const f3045_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3045->then_instructions;

                                 body.emit(assign(r3040, r303E, 0x01));

                                 body.emit(assign(r3041, r301B, 0x01));

                                 body.emit(assign(r3042, r301A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3045->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3048 = less(r303F, body.constant(int(32)));
                                 ir_if *f3047 = new(mem_ctx) ir_if(operand(r3048).val);
                                 exec_list *const f3047_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3047->then_instructions;

                                    body.emit(assign(r3040, lshift(r301B, r3043), 0x01));

                                    ir_expression *const r3049 = lshift(r301A, r3043);
                                    ir_expression *const r304A = rshift(r301B, r303F);
                                    body.emit(assign(r3041, bit_or(r3049, r304A), 0x01));

                                    body.emit(assign(r3042, rshift(r301A, r303F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3047->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r304C = equal(r303F, body.constant(int(32)));
                                    ir_if *f304B = new(mem_ctx) ir_if(operand(r304C).val);
                                    exec_list *const f304B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f304B->then_instructions;

                                       body.emit(assign(r3040, r301B, 0x01));

                                       body.emit(assign(r3041, r301A, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f304B->else_instructions;

                                       body.emit(assign(r303E, bit_or(body.constant(0u), r301B), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r304E = less(r303F, body.constant(int(64)));
                                       ir_if *f304D = new(mem_ctx) ir_if(operand(r304E).val);
                                       exec_list *const f304D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f304D->then_instructions;

                                          body.emit(assign(r3040, lshift(r301A, r3043), 0x01));

                                          ir_expression *const r304F = bit_and(r303F, body.constant(int(31)));
                                          body.emit(assign(r3041, rshift(r301A, r304F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f304D->else_instructions;

                                          ir_variable *const r3050 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3052 = equal(r303F, body.constant(int(64)));
                                          ir_if *f3051 = new(mem_ctx) ir_if(operand(r3052).val);
                                          exec_list *const f3051_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3051->then_instructions;

                                             body.emit(assign(r3050, r301A, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3051->else_instructions;

                                             ir_expression *const r3053 = nequal(r301A, body.constant(0u));
                                             ir_expression *const r3054 = expr(ir_unop_b2i, r3053);
                                             body.emit(assign(r3050, expr(ir_unop_i2u, r3054), 0x01));


                                          body.instructions = f3051_parent_instructions;
                                          body.emit(f3051);

                                          /* END IF */

                                          body.emit(assign(r3040, r3050, 0x01));

                                          body.emit(assign(r3041, body.constant(0u), 0x01));


                                       body.instructions = f304D_parent_instructions;
                                       body.emit(f304D);

                                       /* END IF */


                                    body.instructions = f304B_parent_instructions;
                                    body.emit(f304B);

                                    /* END IF */

                                    body.emit(assign(r3042, body.constant(0u), 0x01));


                                 body.instructions = f3047_parent_instructions;
                                 body.emit(f3047);

                                 /* END IF */

                                 ir_expression *const r3055 = nequal(r303E, body.constant(0u));
                                 ir_expression *const r3056 = expr(ir_unop_b2i, r3055);
                                 ir_expression *const r3057 = expr(ir_unop_i2u, r3056);
                                 body.emit(assign(r3040, bit_or(r3040, r3057), 0x01));


                              body.instructions = f3045_parent_instructions;
                              body.emit(f3045);

                              /* END IF */

                              body.emit(assign(r301A, r3042, 0x01));

                              body.emit(assign(r301B, r3041, 0x01));

                              body.emit(assign(r301C, r3040, 0x01));


                           body.instructions = f3034_parent_instructions;
                           body.emit(f3034);

                           /* END IF */

                           body.emit(assign(r3019, sub(r3019, r301D), 0x01));

                           ir_variable *const r3058 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r3058, r3019, 0x01));

                           ir_variable *const r3059 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r3059, r301A, 0x01));

                           ir_variable *const r305A = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r305A, r301B, 0x01));

                           ir_variable *const r305B = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r305B, r301C, 0x01));

                           ir_variable *const r305C = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r305C, body.constant(true), 0x01));

                           ir_variable *const r305D = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r305E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r305E);
                           ir_expression *const r305F = expr(ir_unop_u2i, r301C);
                           body.emit(assign(r305E, less(r305F, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3061 = lequal(body.constant(int(2045)), r3019);
                           ir_if *f3060 = new(mem_ctx) ir_if(operand(r3061).val);
                           exec_list *const f3060_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3060->then_instructions;

                              ir_variable *const r3062 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3064 = less(body.constant(int(2045)), r3019);
                              ir_if *f3063 = new(mem_ctx) ir_if(operand(r3064).val);
                              exec_list *const f3063_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3063->then_instructions;

                                 body.emit(assign(r3062, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3063->else_instructions;

                                 ir_variable *const r3065 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3067 = equal(r3019, body.constant(int(2045)));
                                 ir_if *f3066 = new(mem_ctx) ir_if(operand(r3067).val);
                                 exec_list *const f3066_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3066->then_instructions;

                                    ir_expression *const r3068 = equal(body.constant(2097151u), r301A);
                                    ir_expression *const r3069 = equal(body.constant(4294967295u), r301B);
                                    body.emit(assign(r3065, logic_and(r3068, r3069), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3066->else_instructions;

                                    body.emit(assign(r3065, body.constant(false), 0x01));


                                 body.instructions = f3066_parent_instructions;
                                 body.emit(f3066);

                                 /* END IF */

                                 body.emit(assign(r3062, logic_and(r3065, r305E), 0x01));


                              body.instructions = f3063_parent_instructions;
                              body.emit(f3063);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f306A = new(mem_ctx) ir_if(operand(r3062).val);
                              exec_list *const f306A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f306A->then_instructions;

                                 ir_variable *const r306B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r306B);
                                 ir_expression *const r306C = lshift(r2C88, body.constant(int(31)));
                                 body.emit(assign(r306B, add(r306C, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r306B, body.constant(0u), 0x01));

                                 body.emit(assign(r305D, r306B, 0x03));

                                 body.emit(assign(r305C, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f306A->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r306E = less(r3019, body.constant(int(0)));
                                 ir_if *f306D = new(mem_ctx) ir_if(operand(r306E).val);
                                 exec_list *const f306D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f306D->then_instructions;

                                    ir_variable *const r306F = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r306F, r301C, 0x01));

                                    ir_variable *const r3070 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r3070, neg(r3019), 0x01));

                                    ir_variable *const r3071 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r3071);
                                    ir_variable *const r3072 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r3072);
                                    ir_variable *const r3073 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r3073);
                                    ir_variable *const r3074 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r3075 = neg(r3070);
                                    body.emit(assign(r3074, bit_and(r3075, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3077 = equal(r3070, body.constant(int(0)));
                                    ir_if *f3076 = new(mem_ctx) ir_if(operand(r3077).val);
                                    exec_list *const f3076_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3076->then_instructions;

                                       body.emit(assign(r3071, r301C, 0x01));

                                       body.emit(assign(r3072, r301B, 0x01));

                                       body.emit(assign(r3073, r301A, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3076->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r3079 = less(r3070, body.constant(int(32)));
                                       ir_if *f3078 = new(mem_ctx) ir_if(operand(r3079).val);
                                       exec_list *const f3078_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3078->then_instructions;

                                          body.emit(assign(r3071, lshift(r301B, r3074), 0x01));

                                          ir_expression *const r307A = lshift(r301A, r3074);
                                          ir_expression *const r307B = rshift(r301B, r3070);
                                          body.emit(assign(r3072, bit_or(r307A, r307B), 0x01));

                                          body.emit(assign(r3073, rshift(r301A, r3070), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3078->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r307D = equal(r3070, body.constant(int(32)));
                                          ir_if *f307C = new(mem_ctx) ir_if(operand(r307D).val);
                                          exec_list *const f307C_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f307C->then_instructions;

                                             body.emit(assign(r3071, r301B, 0x01));

                                             body.emit(assign(r3072, r301A, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f307C->else_instructions;

                                             body.emit(assign(r306F, bit_or(r301C, r301B), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r307F = less(r3070, body.constant(int(64)));
                                             ir_if *f307E = new(mem_ctx) ir_if(operand(r307F).val);
                                             exec_list *const f307E_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f307E->then_instructions;

                                                body.emit(assign(r3071, lshift(r301A, r3074), 0x01));

                                                ir_expression *const r3080 = bit_and(r3070, body.constant(int(31)));
                                                body.emit(assign(r3072, rshift(r301A, r3080), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f307E->else_instructions;

                                                ir_variable *const r3081 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r3083 = equal(r3070, body.constant(int(64)));
                                                ir_if *f3082 = new(mem_ctx) ir_if(operand(r3083).val);
                                                exec_list *const f3082_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f3082->then_instructions;

                                                   body.emit(assign(r3081, r301A, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f3082->else_instructions;

                                                   ir_expression *const r3084 = nequal(r301A, body.constant(0u));
                                                   ir_expression *const r3085 = expr(ir_unop_b2i, r3084);
                                                   body.emit(assign(r3081, expr(ir_unop_i2u, r3085), 0x01));


                                                body.instructions = f3082_parent_instructions;
                                                body.emit(f3082);

                                                /* END IF */

                                                body.emit(assign(r3071, r3081, 0x01));

                                                body.emit(assign(r3072, body.constant(0u), 0x01));


                                             body.instructions = f307E_parent_instructions;
                                             body.emit(f307E);

                                             /* END IF */


                                          body.instructions = f307C_parent_instructions;
                                          body.emit(f307C);

                                          /* END IF */

                                          body.emit(assign(r3073, body.constant(0u), 0x01));


                                       body.instructions = f3078_parent_instructions;
                                       body.emit(f3078);

                                       /* END IF */

                                       ir_expression *const r3086 = nequal(r306F, body.constant(0u));
                                       ir_expression *const r3087 = expr(ir_unop_b2i, r3086);
                                       ir_expression *const r3088 = expr(ir_unop_i2u, r3087);
                                       body.emit(assign(r3071, bit_or(r3071, r3088), 0x01));


                                    body.instructions = f3076_parent_instructions;
                                    body.emit(f3076);

                                    /* END IF */

                                    body.emit(assign(r3059, r3073, 0x01));

                                    body.emit(assign(r305A, r3072, 0x01));

                                    body.emit(assign(r305B, r3071, 0x01));

                                    body.emit(assign(r3058, body.constant(int(0)), 0x01));

                                    body.emit(assign(r305E, less(r3071, body.constant(0u)), 0x01));


                                 body.instructions = f306D_parent_instructions;
                                 body.emit(f306D);

                                 /* END IF */


                              body.instructions = f306A_parent_instructions;
                              body.emit(f306A);

                              /* END IF */


                           body.instructions = f3060_parent_instructions;
                           body.emit(f3060);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f3089 = new(mem_ctx) ir_if(operand(r305C).val);
                           exec_list *const f3089_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3089->then_instructions;

                              /* IF CONDITION */
                              ir_if *f308A = new(mem_ctx) ir_if(operand(r305E).val);
                              exec_list *const f308A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f308A->then_instructions;

                                 ir_variable *const r308B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r308B, add(r305A, body.constant(1u)), 0x01));

                                 ir_expression *const r308C = less(r308B, r305A);
                                 ir_expression *const r308D = expr(ir_unop_b2i, r308C);
                                 ir_expression *const r308E = expr(ir_unop_i2u, r308D);
                                 body.emit(assign(r3059, add(r3059, r308E), 0x01));

                                 ir_expression *const r308F = equal(r305B, body.constant(0u));
                                 ir_expression *const r3090 = expr(ir_unop_b2i, r308F);
                                 ir_expression *const r3091 = expr(ir_unop_i2u, r3090);
                                 ir_expression *const r3092 = add(r305B, r3091);
                                 ir_expression *const r3093 = bit_and(r3092, body.constant(1u));
                                 ir_expression *const r3094 = expr(ir_unop_bit_not, r3093);
                                 body.emit(assign(r305A, bit_and(r308B, r3094), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f308A->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3096 = bit_or(r3059, r305A);
                                 ir_expression *const r3097 = equal(r3096, body.constant(0u));
                                 ir_if *f3095 = new(mem_ctx) ir_if(operand(r3097).val);
                                 exec_list *const f3095_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3095->then_instructions;

                                    body.emit(assign(r3058, body.constant(int(0)), 0x01));


                                 body.instructions = f3095_parent_instructions;
                                 body.emit(f3095);

                                 /* END IF */


                              body.instructions = f308A_parent_instructions;
                              body.emit(f308A);

                              /* END IF */

                              ir_variable *const r3098 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3098);
                              ir_expression *const r3099 = lshift(r2C88, body.constant(int(31)));
                              ir_expression *const r309A = expr(ir_unop_i2u, r3058);
                              ir_expression *const r309B = lshift(r309A, body.constant(int(20)));
                              ir_expression *const r309C = add(r3099, r309B);
                              body.emit(assign(r3098, add(r309C, r3059), 0x02));

                              body.emit(assign(r3098, r305A, 0x01));

                              body.emit(assign(r305D, r3098, 0x03));

                              body.emit(assign(r305C, body.constant(false), 0x01));


                           body.instructions = f3089_parent_instructions;
                           body.emit(f3089);

                           /* END IF */

                           body.emit(assign(r2C89, r305D, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3011->else_instructions;

                           ir_variable *const r309D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r309D);
                           body.emit(assign(r309D, body.constant(0u), 0x02));

                           body.emit(assign(r309D, body.constant(0u), 0x01));

                           body.emit(assign(r2C89, r309D, 0x03));


                        body.instructions = f3011_parent_instructions;
                        body.emit(f3011);

                        /* END IF */


                     body.instructions = f2F85_parent_instructions;
                     body.emit(f2F85);

                     /* END IF */


                  body.instructions = f2EF9_parent_instructions;
                  body.emit(f2EF9);

                  /* END IF */


               body.instructions = f2E6D_parent_instructions;
               body.emit(f2E6D);

               /* END IF */


            body.instructions = f2E46_parent_instructions;
            body.emit(f2E46);

            /* END IF */


         body.instructions = f2D72_parent_instructions;
         body.emit(f2D72);

         /* END IF */


      body.instructions = f2CA2_parent_instructions;
      body.emit(f2CA2);

      /* END IF */

      body.emit(assign(r2C83, r2C89, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f2C86->else_instructions;

      ir_variable *const r309E = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r309E, body.constant(true), 0x01));

      ir_variable *const r309F = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r30A0 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r30A0);
      ir_variable *const r30A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r30A1);
      ir_variable *const r30A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r30A2);
      ir_variable *const r30A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r30A3);
      ir_variable *const r30A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r30A4);
      ir_variable *const r30A5 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r30A5);
      ir_variable *const r30A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r30A6);
      ir_variable *const r30A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r30A7);
      body.emit(assign(r30A7, body.constant(0u), 0x01));

      body.emit(assign(r30A6, body.constant(0u), 0x01));

      ir_variable *const r30A8 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r30A8, swizzle_x(r2735), 0x01));

      body.emit(assign(r30A4, r30A8, 0x01));

      ir_variable *const r30A9 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r30A9, bit_and(swizzle_y(r2735), body.constant(1048575u)), 0x01));

      body.emit(assign(r30A3, r30A9, 0x01));

      ir_variable *const r30AA = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r30AA, swizzle_x(r2769), 0x01));

      body.emit(assign(r30A2, r30AA, 0x01));

      ir_variable *const r30AB = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r30AB, bit_and(swizzle_y(r2769), body.constant(1048575u)), 0x01));

      body.emit(assign(r30A1, r30AB, 0x01));

      ir_variable *const r30AC = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r30AD = rshift(swizzle_y(r2735), body.constant(int(20)));
      ir_expression *const r30AE = bit_and(r30AD, body.constant(2047u));
      body.emit(assign(r30AC, expr(ir_unop_u2i, r30AE), 0x01));

      ir_variable *const r30AF = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r30B0 = rshift(swizzle_y(r2769), body.constant(int(20)));
      ir_expression *const r30B1 = bit_and(r30B0, body.constant(2047u));
      body.emit(assign(r30AF, expr(ir_unop_u2i, r30B1), 0x01));

      ir_variable *const r30B2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r30B2, sub(r30AC, r30AF), 0x01));

      body.emit(assign(r30A0, r30B2, 0x01));

      /* IF CONDITION */
      ir_expression *const r30B4 = less(body.constant(int(0)), r30B2);
      ir_if *f30B3 = new(mem_ctx) ir_if(operand(r30B4).val);
      exec_list *const f30B3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f30B3->then_instructions;

         /* IF CONDITION */
         ir_expression *const r30B6 = equal(r30AC, body.constant(int(2047)));
         ir_if *f30B5 = new(mem_ctx) ir_if(operand(r30B6).val);
         exec_list *const f30B5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f30B5->then_instructions;

            /* IF CONDITION */
            ir_expression *const r30B8 = bit_or(r30A9, swizzle_x(r2735));
            ir_expression *const r30B9 = nequal(r30B8, body.constant(0u));
            ir_if *f30B7 = new(mem_ctx) ir_if(operand(r30B9).val);
            exec_list *const f30B7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f30B7->then_instructions;

               ir_variable *const r30BA = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r30BA, swizzle_x(r2735), 0x01));

               ir_variable *const r30BB = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r30BB, swizzle_x(r2769), 0x01));

               ir_variable *const r30BC = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r30BD = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r30BE = rshift(swizzle_y(r2735), body.constant(int(19)));
               ir_expression *const r30BF = bit_and(r30BE, body.constant(4095u));
               ir_expression *const r30C0 = equal(r30BF, body.constant(4094u));
               ir_expression *const r30C1 = nequal(swizzle_x(r2735), body.constant(0u));
               ir_expression *const r30C2 = bit_and(swizzle_y(r2735), body.constant(524287u));
               ir_expression *const r30C3 = nequal(r30C2, body.constant(0u));
               ir_expression *const r30C4 = logic_or(r30C1, r30C3);
               body.emit(assign(r30BD, logic_and(r30C0, r30C4), 0x01));

               ir_variable *const r30C5 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r30C6 = lshift(swizzle_y(r2769), body.constant(int(1)));
               ir_expression *const r30C7 = lequal(body.constant(4292870144u), r30C6);
               ir_expression *const r30C8 = nequal(swizzle_x(r2769), body.constant(0u));
               ir_expression *const r30C9 = bit_and(swizzle_y(r2769), body.constant(1048575u));
               ir_expression *const r30CA = nequal(r30C9, body.constant(0u));
               ir_expression *const r30CB = logic_or(r30C8, r30CA);
               body.emit(assign(r30C5, logic_and(r30C7, r30CB), 0x01));

               body.emit(assign(r30BA, bit_or(swizzle_y(r2735), body.constant(524288u)), 0x02));

               body.emit(assign(r30BB, bit_or(swizzle_y(r2769), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r30CD = lshift(swizzle_y(r2735), body.constant(int(1)));
               ir_expression *const r30CE = lequal(body.constant(4292870144u), r30CD);
               ir_expression *const r30CF = nequal(swizzle_x(r2735), body.constant(0u));
               ir_expression *const r30D0 = bit_and(swizzle_y(r2735), body.constant(1048575u));
               ir_expression *const r30D1 = nequal(r30D0, body.constant(0u));
               ir_expression *const r30D2 = logic_or(r30CF, r30D1);
               ir_expression *const r30D3 = logic_and(r30CE, r30D2);
               ir_if *f30CC = new(mem_ctx) ir_if(operand(r30D3).val);
               exec_list *const f30CC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f30CC->then_instructions;

                  ir_variable *const r30D4 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r30D6 = logic_and(r30BD, r30C5);
                  ir_if *f30D5 = new(mem_ctx) ir_if(operand(r30D6).val);
                  exec_list *const f30D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f30D5->then_instructions;

                     body.emit(assign(r30D4, r30BB, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f30D5->else_instructions;

                     body.emit(assign(r30D4, r30BA, 0x03));


                  body.instructions = f30D5_parent_instructions;
                  body.emit(f30D5);

                  /* END IF */

                  body.emit(assign(r30BC, r30D4, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f30CC->else_instructions;

                  body.emit(assign(r30BC, r30BB, 0x03));


               body.instructions = f30CC_parent_instructions;
               body.emit(f30CC);

               /* END IF */

               body.emit(assign(r309F, r30BC, 0x03));

               body.emit(assign(r309E, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f30B7->else_instructions;

               body.emit(assign(r309F, r2735, 0x03));

               body.emit(assign(r309E, body.constant(false), 0x01));


            body.instructions = f30B7_parent_instructions;
            body.emit(f30B7);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f30B5->else_instructions;

            /* IF CONDITION */
            ir_expression *const r30D8 = equal(r30AF, body.constant(int(0)));
            ir_if *f30D7 = new(mem_ctx) ir_if(operand(r30D8).val);
            exec_list *const f30D7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f30D7->then_instructions;

               body.emit(assign(r30A0, add(r30B2, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f30D7->else_instructions;

               body.emit(assign(r30A1, bit_or(r30AB, body.constant(1048576u)), 0x01));


            body.instructions = f30D7_parent_instructions;
            body.emit(f30D7);

            /* END IF */

            ir_variable *const r30D9 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r30D9, body.constant(0u), 0x01));

            ir_variable *const r30DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r30DA);
            ir_variable *const r30DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r30DB);
            ir_variable *const r30DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r30DC);
            ir_variable *const r30DD = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r30DE = neg(r30A0);
            body.emit(assign(r30DD, bit_and(r30DE, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r30E0 = equal(r30A0, body.constant(int(0)));
            ir_if *f30DF = new(mem_ctx) ir_if(operand(r30E0).val);
            exec_list *const f30DF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f30DF->then_instructions;

               body.emit(assign(r30DA, r30D9, 0x01));

               body.emit(assign(r30DB, r30AA, 0x01));

               body.emit(assign(r30DC, r30A1, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f30DF->else_instructions;

               /* IF CONDITION */
               ir_expression *const r30E2 = less(r30A0, body.constant(int(32)));
               ir_if *f30E1 = new(mem_ctx) ir_if(operand(r30E2).val);
               exec_list *const f30E1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f30E1->then_instructions;

                  body.emit(assign(r30DA, lshift(swizzle_x(r2769), r30DD), 0x01));

                  ir_expression *const r30E3 = lshift(r30A1, r30DD);
                  ir_expression *const r30E4 = rshift(swizzle_x(r2769), r30A0);
                  body.emit(assign(r30DB, bit_or(r30E3, r30E4), 0x01));

                  body.emit(assign(r30DC, rshift(r30A1, r30A0), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f30E1->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r30E6 = equal(r30A0, body.constant(int(32)));
                  ir_if *f30E5 = new(mem_ctx) ir_if(operand(r30E6).val);
                  exec_list *const f30E5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f30E5->then_instructions;

                     body.emit(assign(r30DA, r30AA, 0x01));

                     body.emit(assign(r30DB, r30A1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f30E5->else_instructions;

                     body.emit(assign(r30D9, bit_or(body.constant(0u), swizzle_x(r2769)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r30E8 = less(r30A0, body.constant(int(64)));
                     ir_if *f30E7 = new(mem_ctx) ir_if(operand(r30E8).val);
                     exec_list *const f30E7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f30E7->then_instructions;

                        body.emit(assign(r30DA, lshift(r30A1, r30DD), 0x01));

                        ir_expression *const r30E9 = bit_and(r30A0, body.constant(int(31)));
                        body.emit(assign(r30DB, rshift(r30A1, r30E9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f30E7->else_instructions;

                        ir_variable *const r30EA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r30EC = equal(r30A0, body.constant(int(64)));
                        ir_if *f30EB = new(mem_ctx) ir_if(operand(r30EC).val);
                        exec_list *const f30EB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30EB->then_instructions;

                           body.emit(assign(r30EA, r30A1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f30EB->else_instructions;

                           ir_expression *const r30ED = nequal(r30A1, body.constant(0u));
                           ir_expression *const r30EE = expr(ir_unop_b2i, r30ED);
                           body.emit(assign(r30EA, expr(ir_unop_i2u, r30EE), 0x01));


                        body.instructions = f30EB_parent_instructions;
                        body.emit(f30EB);

                        /* END IF */

                        body.emit(assign(r30DA, r30EA, 0x01));

                        body.emit(assign(r30DB, body.constant(0u), 0x01));


                     body.instructions = f30E7_parent_instructions;
                     body.emit(f30E7);

                     /* END IF */


                  body.instructions = f30E5_parent_instructions;
                  body.emit(f30E5);

                  /* END IF */

                  body.emit(assign(r30DC, body.constant(0u), 0x01));


               body.instructions = f30E1_parent_instructions;
               body.emit(f30E1);

               /* END IF */

               ir_expression *const r30EF = nequal(r30D9, body.constant(0u));
               ir_expression *const r30F0 = expr(ir_unop_b2i, r30EF);
               ir_expression *const r30F1 = expr(ir_unop_i2u, r30F0);
               body.emit(assign(r30DA, bit_or(r30DA, r30F1), 0x01));


            body.instructions = f30DF_parent_instructions;
            body.emit(f30DF);

            /* END IF */

            body.emit(assign(r30A1, r30DC, 0x01));

            body.emit(assign(r30A2, r30DB, 0x01));

            body.emit(assign(r30A6, r30DA, 0x01));

            body.emit(assign(r30A5, r30AC, 0x01));


         body.instructions = f30B5_parent_instructions;
         body.emit(f30B5);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f30B3->else_instructions;

         /* IF CONDITION */
         ir_expression *const r30F3 = less(r30A0, body.constant(int(0)));
         ir_if *f30F2 = new(mem_ctx) ir_if(operand(r30F3).val);
         exec_list *const f30F2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f30F2->then_instructions;

            /* IF CONDITION */
            ir_expression *const r30F5 = equal(r30AF, body.constant(int(2047)));
            ir_if *f30F4 = new(mem_ctx) ir_if(operand(r30F5).val);
            exec_list *const f30F4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f30F4->then_instructions;

               /* IF CONDITION */
               ir_expression *const r30F7 = bit_or(r30A1, r30A2);
               ir_expression *const r30F8 = nequal(r30F7, body.constant(0u));
               ir_if *f30F6 = new(mem_ctx) ir_if(operand(r30F8).val);
               exec_list *const f30F6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f30F6->then_instructions;

                  ir_variable *const r30F9 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r30F9, swizzle_x(r2735), 0x01));

                  ir_variable *const r30FA = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r30FA, swizzle_x(r2769), 0x01));

                  ir_variable *const r30FB = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r30FC = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r30FD = rshift(swizzle_y(r2735), body.constant(int(19)));
                  ir_expression *const r30FE = bit_and(r30FD, body.constant(4095u));
                  ir_expression *const r30FF = equal(r30FE, body.constant(4094u));
                  ir_expression *const r3100 = nequal(swizzle_x(r2735), body.constant(0u));
                  ir_expression *const r3101 = bit_and(swizzle_y(r2735), body.constant(524287u));
                  ir_expression *const r3102 = nequal(r3101, body.constant(0u));
                  ir_expression *const r3103 = logic_or(r3100, r3102);
                  body.emit(assign(r30FC, logic_and(r30FF, r3103), 0x01));

                  ir_variable *const r3104 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r3105 = lshift(swizzle_y(r2769), body.constant(int(1)));
                  ir_expression *const r3106 = lequal(body.constant(4292870144u), r3105);
                  ir_expression *const r3107 = nequal(swizzle_x(r2769), body.constant(0u));
                  ir_expression *const r3108 = bit_and(swizzle_y(r2769), body.constant(1048575u));
                  ir_expression *const r3109 = nequal(r3108, body.constant(0u));
                  ir_expression *const r310A = logic_or(r3107, r3109);
                  body.emit(assign(r3104, logic_and(r3106, r310A), 0x01));

                  body.emit(assign(r30F9, bit_or(swizzle_y(r2735), body.constant(524288u)), 0x02));

                  body.emit(assign(r30FA, bit_or(swizzle_y(r2769), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r310C = lshift(swizzle_y(r2735), body.constant(int(1)));
                  ir_expression *const r310D = lequal(body.constant(4292870144u), r310C);
                  ir_expression *const r310E = nequal(swizzle_x(r2735), body.constant(0u));
                  ir_expression *const r310F = bit_and(swizzle_y(r2735), body.constant(1048575u));
                  ir_expression *const r3110 = nequal(r310F, body.constant(0u));
                  ir_expression *const r3111 = logic_or(r310E, r3110);
                  ir_expression *const r3112 = logic_and(r310D, r3111);
                  ir_if *f310B = new(mem_ctx) ir_if(operand(r3112).val);
                  exec_list *const f310B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f310B->then_instructions;

                     ir_variable *const r3113 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3115 = logic_and(r30FC, r3104);
                     ir_if *f3114 = new(mem_ctx) ir_if(operand(r3115).val);
                     exec_list *const f3114_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3114->then_instructions;

                        body.emit(assign(r3113, r30FA, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3114->else_instructions;

                        body.emit(assign(r3113, r30F9, 0x03));


                     body.instructions = f3114_parent_instructions;
                     body.emit(f3114);

                     /* END IF */

                     body.emit(assign(r30FB, r3113, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f310B->else_instructions;

                     body.emit(assign(r30FB, r30FA, 0x03));


                  body.instructions = f310B_parent_instructions;
                  body.emit(f310B);

                  /* END IF */

                  body.emit(assign(r309F, r30FB, 0x03));

                  body.emit(assign(r309E, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f30F6->else_instructions;

                  ir_variable *const r3116 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3116);
                  ir_expression *const r3117 = lshift(r2C84, body.constant(int(31)));
                  body.emit(assign(r3116, add(r3117, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r3116, body.constant(0u), 0x01));

                  body.emit(assign(r309F, r3116, 0x03));

                  body.emit(assign(r309E, body.constant(false), 0x01));


               body.instructions = f30F6_parent_instructions;
               body.emit(f30F6);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f30F4->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3119 = equal(r30AC, body.constant(int(0)));
               ir_if *f3118 = new(mem_ctx) ir_if(operand(r3119).val);
               exec_list *const f3118_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3118->then_instructions;

                  body.emit(assign(r30A0, add(r30A0, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3118->else_instructions;

                  body.emit(assign(r30A3, bit_or(r30A9, body.constant(1048576u)), 0x01));


               body.instructions = f3118_parent_instructions;
               body.emit(f3118);

               /* END IF */

               ir_variable *const r311A = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r311A, body.constant(0u), 0x01));

               ir_variable *const r311B = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r311B, neg(r30A0), 0x01));

               ir_variable *const r311C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r311C);
               ir_variable *const r311D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r311D);
               ir_variable *const r311E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r311E);
               ir_variable *const r311F = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r3120 = neg(r311B);
               body.emit(assign(r311F, bit_and(r3120, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3122 = equal(r311B, body.constant(int(0)));
               ir_if *f3121 = new(mem_ctx) ir_if(operand(r3122).val);
               exec_list *const f3121_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3121->then_instructions;

                  body.emit(assign(r311C, r311A, 0x01));

                  body.emit(assign(r311D, r30A8, 0x01));

                  body.emit(assign(r311E, r30A3, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3121->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3124 = less(r311B, body.constant(int(32)));
                  ir_if *f3123 = new(mem_ctx) ir_if(operand(r3124).val);
                  exec_list *const f3123_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3123->then_instructions;

                     body.emit(assign(r311C, lshift(swizzle_x(r2735), r311F), 0x01));

                     ir_expression *const r3125 = lshift(r30A3, r311F);
                     ir_expression *const r3126 = rshift(swizzle_x(r2735), r311B);
                     body.emit(assign(r311D, bit_or(r3125, r3126), 0x01));

                     body.emit(assign(r311E, rshift(r30A3, r311B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3123->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3128 = equal(r311B, body.constant(int(32)));
                     ir_if *f3127 = new(mem_ctx) ir_if(operand(r3128).val);
                     exec_list *const f3127_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3127->then_instructions;

                        body.emit(assign(r311C, r30A8, 0x01));

                        body.emit(assign(r311D, r30A3, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3127->else_instructions;

                        body.emit(assign(r311A, bit_or(body.constant(0u), swizzle_x(r2735)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r312A = less(r311B, body.constant(int(64)));
                        ir_if *f3129 = new(mem_ctx) ir_if(operand(r312A).val);
                        exec_list *const f3129_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3129->then_instructions;

                           body.emit(assign(r311C, lshift(r30A3, r311F), 0x01));

                           ir_expression *const r312B = bit_and(r311B, body.constant(int(31)));
                           body.emit(assign(r311D, rshift(r30A3, r312B), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3129->else_instructions;

                           ir_variable *const r312C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r312E = equal(r311B, body.constant(int(64)));
                           ir_if *f312D = new(mem_ctx) ir_if(operand(r312E).val);
                           exec_list *const f312D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f312D->then_instructions;

                              body.emit(assign(r312C, r30A3, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f312D->else_instructions;

                              ir_expression *const r312F = nequal(r30A3, body.constant(0u));
                              ir_expression *const r3130 = expr(ir_unop_b2i, r312F);
                              body.emit(assign(r312C, expr(ir_unop_i2u, r3130), 0x01));


                           body.instructions = f312D_parent_instructions;
                           body.emit(f312D);

                           /* END IF */

                           body.emit(assign(r311C, r312C, 0x01));

                           body.emit(assign(r311D, body.constant(0u), 0x01));


                        body.instructions = f3129_parent_instructions;
                        body.emit(f3129);

                        /* END IF */


                     body.instructions = f3127_parent_instructions;
                     body.emit(f3127);

                     /* END IF */

                     body.emit(assign(r311E, body.constant(0u), 0x01));


                  body.instructions = f3123_parent_instructions;
                  body.emit(f3123);

                  /* END IF */

                  ir_expression *const r3131 = nequal(r311A, body.constant(0u));
                  ir_expression *const r3132 = expr(ir_unop_b2i, r3131);
                  ir_expression *const r3133 = expr(ir_unop_i2u, r3132);
                  body.emit(assign(r311C, bit_or(r311C, r3133), 0x01));


               body.instructions = f3121_parent_instructions;
               body.emit(f3121);

               /* END IF */

               body.emit(assign(r30A3, r311E, 0x01));

               body.emit(assign(r30A4, r311D, 0x01));

               body.emit(assign(r30A6, r311C, 0x01));

               body.emit(assign(r30A5, r30AF, 0x01));


            body.instructions = f30F4_parent_instructions;
            body.emit(f30F4);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f30F2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3135 = equal(r30AC, body.constant(int(2047)));
            ir_if *f3134 = new(mem_ctx) ir_if(operand(r3135).val);
            exec_list *const f3134_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3134->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3137 = bit_or(r30A3, r30A4);
               ir_expression *const r3138 = bit_or(r30A1, r30A2);
               ir_expression *const r3139 = bit_or(r3137, r3138);
               ir_expression *const r313A = nequal(r3139, body.constant(0u));
               ir_if *f3136 = new(mem_ctx) ir_if(operand(r313A).val);
               exec_list *const f3136_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3136->then_instructions;

                  ir_variable *const r313B = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r313B, swizzle_x(r2735), 0x01));

                  ir_variable *const r313C = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r313C, swizzle_x(r2769), 0x01));

                  ir_variable *const r313D = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r313E = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r313F = rshift(swizzle_y(r2735), body.constant(int(19)));
                  ir_expression *const r3140 = bit_and(r313F, body.constant(4095u));
                  ir_expression *const r3141 = equal(r3140, body.constant(4094u));
                  ir_expression *const r3142 = nequal(swizzle_x(r2735), body.constant(0u));
                  ir_expression *const r3143 = bit_and(swizzle_y(r2735), body.constant(524287u));
                  ir_expression *const r3144 = nequal(r3143, body.constant(0u));
                  ir_expression *const r3145 = logic_or(r3142, r3144);
                  body.emit(assign(r313E, logic_and(r3141, r3145), 0x01));

                  ir_variable *const r3146 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r3147 = lshift(swizzle_y(r2769), body.constant(int(1)));
                  ir_expression *const r3148 = lequal(body.constant(4292870144u), r3147);
                  ir_expression *const r3149 = nequal(swizzle_x(r2769), body.constant(0u));
                  ir_expression *const r314A = bit_and(swizzle_y(r2769), body.constant(1048575u));
                  ir_expression *const r314B = nequal(r314A, body.constant(0u));
                  ir_expression *const r314C = logic_or(r3149, r314B);
                  body.emit(assign(r3146, logic_and(r3148, r314C), 0x01));

                  body.emit(assign(r313B, bit_or(swizzle_y(r2735), body.constant(524288u)), 0x02));

                  body.emit(assign(r313C, bit_or(swizzle_y(r2769), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r314E = lshift(swizzle_y(r2735), body.constant(int(1)));
                  ir_expression *const r314F = lequal(body.constant(4292870144u), r314E);
                  ir_expression *const r3150 = nequal(swizzle_x(r2735), body.constant(0u));
                  ir_expression *const r3151 = bit_and(swizzle_y(r2735), body.constant(1048575u));
                  ir_expression *const r3152 = nequal(r3151, body.constant(0u));
                  ir_expression *const r3153 = logic_or(r3150, r3152);
                  ir_expression *const r3154 = logic_and(r314F, r3153);
                  ir_if *f314D = new(mem_ctx) ir_if(operand(r3154).val);
                  exec_list *const f314D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f314D->then_instructions;

                     ir_variable *const r3155 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3157 = logic_and(r313E, r3146);
                     ir_if *f3156 = new(mem_ctx) ir_if(operand(r3157).val);
                     exec_list *const f3156_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3156->then_instructions;

                        body.emit(assign(r3155, r313C, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3156->else_instructions;

                        body.emit(assign(r3155, r313B, 0x03));


                     body.instructions = f3156_parent_instructions;
                     body.emit(f3156);

                     /* END IF */

                     body.emit(assign(r313D, r3155, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f314D->else_instructions;

                     body.emit(assign(r313D, r313C, 0x03));


                  body.instructions = f314D_parent_instructions;
                  body.emit(f314D);

                  /* END IF */

                  body.emit(assign(r309F, r313D, 0x03));

                  body.emit(assign(r309E, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3136->else_instructions;

                  body.emit(assign(r309F, r2735, 0x03));

                  body.emit(assign(r309E, body.constant(false), 0x01));


               body.instructions = f3136_parent_instructions;
               body.emit(f3136);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3134->else_instructions;

               ir_variable *const r3158 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r3159 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3159, add(r30A4, r30A2), 0x01));

               ir_expression *const r315A = add(r30A3, r30A1);
               ir_expression *const r315B = less(r3159, r30A4);
               ir_expression *const r315C = expr(ir_unop_b2i, r315B);
               ir_expression *const r315D = expr(ir_unop_i2u, r315C);
               body.emit(assign(r3158, add(r315A, r315D), 0x01));

               body.emit(assign(r30A7, r3158, 0x01));

               /* IF CONDITION */
               ir_expression *const r315F = equal(r30AC, body.constant(int(0)));
               ir_if *f315E = new(mem_ctx) ir_if(operand(r315F).val);
               exec_list *const f315E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f315E->then_instructions;

                  ir_variable *const r3160 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3160);
                  ir_expression *const r3161 = lshift(r2C84, body.constant(int(31)));
                  body.emit(assign(r3160, add(r3161, r3158), 0x02));

                  body.emit(assign(r3160, r3159, 0x01));

                  body.emit(assign(r309F, r3160, 0x03));

                  body.emit(assign(r309E, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f315E->else_instructions;

                  body.emit(assign(r30A7, bit_or(r3158, body.constant(2097152u)), 0x01));

                  body.emit(assign(r30A5, r30AC, 0x01));

                  ir_variable *const r3162 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r3162);
                  ir_variable *const r3163 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3163);
                  ir_variable *const r3164 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r3164);
                  body.emit(assign(r3162, lshift(r3159, body.constant(int(31))), 0x01));

                  ir_expression *const r3165 = lshift(r30A7, body.constant(int(31)));
                  ir_expression *const r3166 = rshift(r3159, body.constant(int(1)));
                  body.emit(assign(r3163, bit_or(r3165, r3166), 0x01));

                  body.emit(assign(r3164, rshift(r30A7, body.constant(int(1))), 0x01));

                  body.emit(assign(r3162, bit_or(r3162, body.constant(0u)), 0x01));

                  body.emit(assign(r30A7, r3164, 0x01));

                  body.emit(assign(r30A6, r3162, 0x01));

                  ir_variable *const r3167 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r3167, r30AC, 0x01));

                  ir_variable *const r3168 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r3168, r3164, 0x01));

                  ir_variable *const r3169 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r3169, r3163, 0x01));

                  ir_variable *const r316A = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r316A, r3162, 0x01));

                  ir_variable *const r316B = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r316B, body.constant(true), 0x01));

                  ir_variable *const r316C = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r316D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r316D);
                  ir_expression *const r316E = expr(ir_unop_u2i, r3162);
                  body.emit(assign(r316D, less(r316E, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3170 = lequal(body.constant(int(2045)), r30AC);
                  ir_if *f316F = new(mem_ctx) ir_if(operand(r3170).val);
                  exec_list *const f316F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f316F->then_instructions;

                     ir_variable *const r3171 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3173 = less(body.constant(int(2045)), r30AC);
                     ir_if *f3172 = new(mem_ctx) ir_if(operand(r3173).val);
                     exec_list *const f3172_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3172->then_instructions;

                        body.emit(assign(r3171, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3172->else_instructions;

                        ir_variable *const r3174 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3176 = equal(r30AC, body.constant(int(2045)));
                        ir_if *f3175 = new(mem_ctx) ir_if(operand(r3176).val);
                        exec_list *const f3175_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3175->then_instructions;

                           ir_expression *const r3177 = equal(body.constant(2097151u), r3164);
                           ir_expression *const r3178 = equal(body.constant(4294967295u), r3163);
                           body.emit(assign(r3174, logic_and(r3177, r3178), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3175->else_instructions;

                           body.emit(assign(r3174, body.constant(false), 0x01));


                        body.instructions = f3175_parent_instructions;
                        body.emit(f3175);

                        /* END IF */

                        body.emit(assign(r3171, logic_and(r3174, r316D), 0x01));


                     body.instructions = f3172_parent_instructions;
                     body.emit(f3172);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f3179 = new(mem_ctx) ir_if(operand(r3171).val);
                     exec_list *const f3179_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3179->then_instructions;

                        ir_variable *const r317A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r317A);
                        ir_expression *const r317B = lshift(r2C84, body.constant(int(31)));
                        body.emit(assign(r317A, add(r317B, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r317A, body.constant(0u), 0x01));

                        body.emit(assign(r316C, r317A, 0x03));

                        body.emit(assign(r316B, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3179->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r317D = less(r30AC, body.constant(int(0)));
                        ir_if *f317C = new(mem_ctx) ir_if(operand(r317D).val);
                        exec_list *const f317C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f317C->then_instructions;

                           ir_variable *const r317E = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r317E, r3162, 0x01));

                           ir_variable *const r317F = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r317F, neg(r30AC), 0x01));

                           ir_variable *const r3180 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3180);
                           ir_variable *const r3181 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3181);
                           ir_variable *const r3182 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3182);
                           ir_variable *const r3183 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r3184 = neg(r317F);
                           body.emit(assign(r3183, bit_and(r3184, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3186 = equal(r317F, body.constant(int(0)));
                           ir_if *f3185 = new(mem_ctx) ir_if(operand(r3186).val);
                           exec_list *const f3185_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3185->then_instructions;

                              body.emit(assign(r3180, r3162, 0x01));

                              body.emit(assign(r3181, r3163, 0x01));

                              body.emit(assign(r3182, r3164, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3185->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3188 = less(r317F, body.constant(int(32)));
                              ir_if *f3187 = new(mem_ctx) ir_if(operand(r3188).val);
                              exec_list *const f3187_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3187->then_instructions;

                                 body.emit(assign(r3180, lshift(r3163, r3183), 0x01));

                                 ir_expression *const r3189 = lshift(r3164, r3183);
                                 ir_expression *const r318A = rshift(r3163, r317F);
                                 body.emit(assign(r3181, bit_or(r3189, r318A), 0x01));

                                 body.emit(assign(r3182, rshift(r3164, r317F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3187->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r318C = equal(r317F, body.constant(int(32)));
                                 ir_if *f318B = new(mem_ctx) ir_if(operand(r318C).val);
                                 exec_list *const f318B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f318B->then_instructions;

                                    body.emit(assign(r3180, r3163, 0x01));

                                    body.emit(assign(r3181, r3164, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f318B->else_instructions;

                                    body.emit(assign(r317E, bit_or(r3162, r3163), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r318E = less(r317F, body.constant(int(64)));
                                    ir_if *f318D = new(mem_ctx) ir_if(operand(r318E).val);
                                    exec_list *const f318D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f318D->then_instructions;

                                       body.emit(assign(r3180, lshift(r3164, r3183), 0x01));

                                       ir_expression *const r318F = bit_and(r317F, body.constant(int(31)));
                                       body.emit(assign(r3181, rshift(r3164, r318F), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f318D->else_instructions;

                                       ir_variable *const r3190 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3192 = equal(r317F, body.constant(int(64)));
                                       ir_if *f3191 = new(mem_ctx) ir_if(operand(r3192).val);
                                       exec_list *const f3191_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3191->then_instructions;

                                          body.emit(assign(r3190, r3164, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3191->else_instructions;

                                          ir_expression *const r3193 = nequal(r3164, body.constant(0u));
                                          ir_expression *const r3194 = expr(ir_unop_b2i, r3193);
                                          body.emit(assign(r3190, expr(ir_unop_i2u, r3194), 0x01));


                                       body.instructions = f3191_parent_instructions;
                                       body.emit(f3191);

                                       /* END IF */

                                       body.emit(assign(r3180, r3190, 0x01));

                                       body.emit(assign(r3181, body.constant(0u), 0x01));


                                    body.instructions = f318D_parent_instructions;
                                    body.emit(f318D);

                                    /* END IF */


                                 body.instructions = f318B_parent_instructions;
                                 body.emit(f318B);

                                 /* END IF */

                                 body.emit(assign(r3182, body.constant(0u), 0x01));


                              body.instructions = f3187_parent_instructions;
                              body.emit(f3187);

                              /* END IF */

                              ir_expression *const r3195 = nequal(r317E, body.constant(0u));
                              ir_expression *const r3196 = expr(ir_unop_b2i, r3195);
                              ir_expression *const r3197 = expr(ir_unop_i2u, r3196);
                              body.emit(assign(r3180, bit_or(r3180, r3197), 0x01));


                           body.instructions = f3185_parent_instructions;
                           body.emit(f3185);

                           /* END IF */

                           body.emit(assign(r3168, r3182, 0x01));

                           body.emit(assign(r3169, r3181, 0x01));

                           body.emit(assign(r316A, r3180, 0x01));

                           body.emit(assign(r3167, body.constant(int(0)), 0x01));

                           body.emit(assign(r316D, less(r3180, body.constant(0u)), 0x01));


                        body.instructions = f317C_parent_instructions;
                        body.emit(f317C);

                        /* END IF */


                     body.instructions = f3179_parent_instructions;
                     body.emit(f3179);

                     /* END IF */


                  body.instructions = f316F_parent_instructions;
                  body.emit(f316F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3198 = new(mem_ctx) ir_if(operand(r316B).val);
                  exec_list *const f3198_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3198->then_instructions;

                     /* IF CONDITION */
                     ir_if *f3199 = new(mem_ctx) ir_if(operand(r316D).val);
                     exec_list *const f3199_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3199->then_instructions;

                        ir_variable *const r319A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r319A, add(r3169, body.constant(1u)), 0x01));

                        ir_expression *const r319B = less(r319A, r3169);
                        ir_expression *const r319C = expr(ir_unop_b2i, r319B);
                        ir_expression *const r319D = expr(ir_unop_i2u, r319C);
                        body.emit(assign(r3168, add(r3168, r319D), 0x01));

                        ir_expression *const r319E = equal(r316A, body.constant(0u));
                        ir_expression *const r319F = expr(ir_unop_b2i, r319E);
                        ir_expression *const r31A0 = expr(ir_unop_i2u, r319F);
                        ir_expression *const r31A1 = add(r316A, r31A0);
                        ir_expression *const r31A2 = bit_and(r31A1, body.constant(1u));
                        ir_expression *const r31A3 = expr(ir_unop_bit_not, r31A2);
                        body.emit(assign(r3169, bit_and(r319A, r31A3), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3199->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r31A5 = bit_or(r3168, r3169);
                        ir_expression *const r31A6 = equal(r31A5, body.constant(0u));
                        ir_if *f31A4 = new(mem_ctx) ir_if(operand(r31A6).val);
                        exec_list *const f31A4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f31A4->then_instructions;

                           body.emit(assign(r3167, body.constant(int(0)), 0x01));


                        body.instructions = f31A4_parent_instructions;
                        body.emit(f31A4);

                        /* END IF */


                     body.instructions = f3199_parent_instructions;
                     body.emit(f3199);

                     /* END IF */

                     ir_variable *const r31A7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r31A7);
                     ir_expression *const r31A8 = lshift(r2C84, body.constant(int(31)));
                     ir_expression *const r31A9 = expr(ir_unop_i2u, r3167);
                     ir_expression *const r31AA = lshift(r31A9, body.constant(int(20)));
                     ir_expression *const r31AB = add(r31A8, r31AA);
                     body.emit(assign(r31A7, add(r31AB, r3168), 0x02));

                     body.emit(assign(r31A7, r3169, 0x01));

                     body.emit(assign(r316C, r31A7, 0x03));

                     body.emit(assign(r316B, body.constant(false), 0x01));


                  body.instructions = f3198_parent_instructions;
                  body.emit(f3198);

                  /* END IF */

                  body.emit(assign(r309F, r316C, 0x03));

                  body.emit(assign(r309E, body.constant(false), 0x01));


               body.instructions = f315E_parent_instructions;
               body.emit(f315E);

               /* END IF */


            body.instructions = f3134_parent_instructions;
            body.emit(f3134);

            /* END IF */


         body.instructions = f30F2_parent_instructions;
         body.emit(f30F2);

         /* END IF */


      body.instructions = f30B3_parent_instructions;
      body.emit(f30B3);

      /* END IF */

      /* IF CONDITION */
      ir_if *f31AC = new(mem_ctx) ir_if(operand(r309E).val);
      exec_list *const f31AC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f31AC->then_instructions;

         body.emit(assign(r30A3, bit_or(r30A3, body.constant(1048576u)), 0x01));

         ir_variable *const r31AD = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r31AE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r31AE, add(r30A4, r30A2), 0x01));

         ir_expression *const r31AF = add(r30A3, r30A1);
         ir_expression *const r31B0 = less(r31AE, r30A4);
         ir_expression *const r31B1 = expr(ir_unop_b2i, r31B0);
         ir_expression *const r31B2 = expr(ir_unop_i2u, r31B1);
         body.emit(assign(r31AD, add(r31AF, r31B2), 0x01));

         body.emit(assign(r30A7, r31AD, 0x01));

         body.emit(assign(r30A5, add(r30A5, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r31B4 = less(r31AD, body.constant(2097152u));
         ir_if *f31B3 = new(mem_ctx) ir_if(operand(r31B4).val);
         exec_list *const f31B3_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f31B3->then_instructions;

            ir_variable *const r31B5 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r31B5, r30A5, 0x01));

            ir_variable *const r31B6 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r31B6, r31AD, 0x01));

            ir_variable *const r31B7 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r31B7, r31AE, 0x01));

            ir_variable *const r31B8 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r31B8, r30A6, 0x01));

            ir_variable *const r31B9 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r31B9, body.constant(true), 0x01));

            ir_variable *const r31BA = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r31BB = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r31BB);
            ir_expression *const r31BC = expr(ir_unop_u2i, r30A6);
            body.emit(assign(r31BB, less(r31BC, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r31BE = lequal(body.constant(int(2045)), r30A5);
            ir_if *f31BD = new(mem_ctx) ir_if(operand(r31BE).val);
            exec_list *const f31BD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f31BD->then_instructions;

               ir_variable *const r31BF = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r31C1 = less(body.constant(int(2045)), r30A5);
               ir_if *f31C0 = new(mem_ctx) ir_if(operand(r31C1).val);
               exec_list *const f31C0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f31C0->then_instructions;

                  body.emit(assign(r31BF, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f31C0->else_instructions;

                  ir_variable *const r31C2 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r31C4 = equal(r30A5, body.constant(int(2045)));
                  ir_if *f31C3 = new(mem_ctx) ir_if(operand(r31C4).val);
                  exec_list *const f31C3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f31C3->then_instructions;

                     ir_expression *const r31C5 = equal(body.constant(2097151u), r31AD);
                     ir_expression *const r31C6 = equal(body.constant(4294967295u), r31AE);
                     body.emit(assign(r31C2, logic_and(r31C5, r31C6), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f31C3->else_instructions;

                     body.emit(assign(r31C2, body.constant(false), 0x01));


                  body.instructions = f31C3_parent_instructions;
                  body.emit(f31C3);

                  /* END IF */

                  body.emit(assign(r31BF, logic_and(r31C2, r31BB), 0x01));


               body.instructions = f31C0_parent_instructions;
               body.emit(f31C0);

               /* END IF */

               /* IF CONDITION */
               ir_if *f31C7 = new(mem_ctx) ir_if(operand(r31BF).val);
               exec_list *const f31C7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f31C7->then_instructions;

                  ir_variable *const r31C8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r31C8);
                  ir_expression *const r31C9 = lshift(r2C84, body.constant(int(31)));
                  body.emit(assign(r31C8, add(r31C9, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r31C8, body.constant(0u), 0x01));

                  body.emit(assign(r31BA, r31C8, 0x03));

                  body.emit(assign(r31B9, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f31C7->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r31CB = less(r30A5, body.constant(int(0)));
                  ir_if *f31CA = new(mem_ctx) ir_if(operand(r31CB).val);
                  exec_list *const f31CA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f31CA->then_instructions;

                     ir_variable *const r31CC = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r31CC, r30A6, 0x01));

                     ir_variable *const r31CD = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r31CD, neg(r30A5), 0x01));

                     ir_variable *const r31CE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r31CE);
                     ir_variable *const r31CF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r31CF);
                     ir_variable *const r31D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r31D0);
                     ir_variable *const r31D1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r31D2 = neg(r31CD);
                     body.emit(assign(r31D1, bit_and(r31D2, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r31D4 = equal(r31CD, body.constant(int(0)));
                     ir_if *f31D3 = new(mem_ctx) ir_if(operand(r31D4).val);
                     exec_list *const f31D3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f31D3->then_instructions;

                        body.emit(assign(r31CE, r30A6, 0x01));

                        body.emit(assign(r31CF, r31AE, 0x01));

                        body.emit(assign(r31D0, r31AD, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f31D3->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r31D6 = less(r31CD, body.constant(int(32)));
                        ir_if *f31D5 = new(mem_ctx) ir_if(operand(r31D6).val);
                        exec_list *const f31D5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f31D5->then_instructions;

                           body.emit(assign(r31CE, lshift(r31AE, r31D1), 0x01));

                           ir_expression *const r31D7 = lshift(r31AD, r31D1);
                           ir_expression *const r31D8 = rshift(r31AE, r31CD);
                           body.emit(assign(r31CF, bit_or(r31D7, r31D8), 0x01));

                           body.emit(assign(r31D0, rshift(r31AD, r31CD), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f31D5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r31DA = equal(r31CD, body.constant(int(32)));
                           ir_if *f31D9 = new(mem_ctx) ir_if(operand(r31DA).val);
                           exec_list *const f31D9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f31D9->then_instructions;

                              body.emit(assign(r31CE, r31AE, 0x01));

                              body.emit(assign(r31CF, r31AD, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f31D9->else_instructions;

                              body.emit(assign(r31CC, bit_or(r30A6, r31AE), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r31DC = less(r31CD, body.constant(int(64)));
                              ir_if *f31DB = new(mem_ctx) ir_if(operand(r31DC).val);
                              exec_list *const f31DB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31DB->then_instructions;

                                 body.emit(assign(r31CE, lshift(r31AD, r31D1), 0x01));

                                 ir_expression *const r31DD = bit_and(r31CD, body.constant(int(31)));
                                 body.emit(assign(r31CF, rshift(r31AD, r31DD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f31DB->else_instructions;

                                 ir_variable *const r31DE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r31E0 = equal(r31CD, body.constant(int(64)));
                                 ir_if *f31DF = new(mem_ctx) ir_if(operand(r31E0).val);
                                 exec_list *const f31DF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f31DF->then_instructions;

                                    body.emit(assign(r31DE, r31AD, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f31DF->else_instructions;

                                    ir_expression *const r31E1 = nequal(r31AD, body.constant(0u));
                                    ir_expression *const r31E2 = expr(ir_unop_b2i, r31E1);
                                    body.emit(assign(r31DE, expr(ir_unop_i2u, r31E2), 0x01));


                                 body.instructions = f31DF_parent_instructions;
                                 body.emit(f31DF);

                                 /* END IF */

                                 body.emit(assign(r31CE, r31DE, 0x01));

                                 body.emit(assign(r31CF, body.constant(0u), 0x01));


                              body.instructions = f31DB_parent_instructions;
                              body.emit(f31DB);

                              /* END IF */


                           body.instructions = f31D9_parent_instructions;
                           body.emit(f31D9);

                           /* END IF */

                           body.emit(assign(r31D0, body.constant(0u), 0x01));


                        body.instructions = f31D5_parent_instructions;
                        body.emit(f31D5);

                        /* END IF */

                        ir_expression *const r31E3 = nequal(r31CC, body.constant(0u));
                        ir_expression *const r31E4 = expr(ir_unop_b2i, r31E3);
                        ir_expression *const r31E5 = expr(ir_unop_i2u, r31E4);
                        body.emit(assign(r31CE, bit_or(r31CE, r31E5), 0x01));


                     body.instructions = f31D3_parent_instructions;
                     body.emit(f31D3);

                     /* END IF */

                     body.emit(assign(r31B6, r31D0, 0x01));

                     body.emit(assign(r31B7, r31CF, 0x01));

                     body.emit(assign(r31B8, r31CE, 0x01));

                     body.emit(assign(r31B5, body.constant(int(0)), 0x01));

                     body.emit(assign(r31BB, less(r31CE, body.constant(0u)), 0x01));


                  body.instructions = f31CA_parent_instructions;
                  body.emit(f31CA);

                  /* END IF */


               body.instructions = f31C7_parent_instructions;
               body.emit(f31C7);

               /* END IF */


            body.instructions = f31BD_parent_instructions;
            body.emit(f31BD);

            /* END IF */

            /* IF CONDITION */
            ir_if *f31E6 = new(mem_ctx) ir_if(operand(r31B9).val);
            exec_list *const f31E6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f31E6->then_instructions;

               /* IF CONDITION */
               ir_if *f31E7 = new(mem_ctx) ir_if(operand(r31BB).val);
               exec_list *const f31E7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f31E7->then_instructions;

                  ir_variable *const r31E8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r31E8, add(r31B7, body.constant(1u)), 0x01));

                  ir_expression *const r31E9 = less(r31E8, r31B7);
                  ir_expression *const r31EA = expr(ir_unop_b2i, r31E9);
                  ir_expression *const r31EB = expr(ir_unop_i2u, r31EA);
                  body.emit(assign(r31B6, add(r31B6, r31EB), 0x01));

                  ir_expression *const r31EC = equal(r31B8, body.constant(0u));
                  ir_expression *const r31ED = expr(ir_unop_b2i, r31EC);
                  ir_expression *const r31EE = expr(ir_unop_i2u, r31ED);
                  ir_expression *const r31EF = add(r31B8, r31EE);
                  ir_expression *const r31F0 = bit_and(r31EF, body.constant(1u));
                  ir_expression *const r31F1 = expr(ir_unop_bit_not, r31F0);
                  body.emit(assign(r31B7, bit_and(r31E8, r31F1), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f31E7->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r31F3 = bit_or(r31B6, r31B7);
                  ir_expression *const r31F4 = equal(r31F3, body.constant(0u));
                  ir_if *f31F2 = new(mem_ctx) ir_if(operand(r31F4).val);
                  exec_list *const f31F2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f31F2->then_instructions;

                     body.emit(assign(r31B5, body.constant(int(0)), 0x01));


                  body.instructions = f31F2_parent_instructions;
                  body.emit(f31F2);

                  /* END IF */


               body.instructions = f31E7_parent_instructions;
               body.emit(f31E7);

               /* END IF */

               ir_variable *const r31F5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r31F5);
               ir_expression *const r31F6 = lshift(r2C84, body.constant(int(31)));
               ir_expression *const r31F7 = expr(ir_unop_i2u, r31B5);
               ir_expression *const r31F8 = lshift(r31F7, body.constant(int(20)));
               ir_expression *const r31F9 = add(r31F6, r31F8);
               body.emit(assign(r31F5, add(r31F9, r31B6), 0x02));

               body.emit(assign(r31F5, r31B7, 0x01));

               body.emit(assign(r31BA, r31F5, 0x03));

               body.emit(assign(r31B9, body.constant(false), 0x01));


            body.instructions = f31E6_parent_instructions;
            body.emit(f31E6);

            /* END IF */

            body.emit(assign(r309F, r31BA, 0x03));

            body.emit(assign(r309E, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f31B3->else_instructions;

            body.emit(assign(r30A5, add(r30A5, body.constant(int(1))), 0x01));

            ir_variable *const r31FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r31FA);
            ir_variable *const r31FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r31FB);
            ir_variable *const r31FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r31FC);
            body.emit(assign(r31FA, lshift(r31AE, body.constant(int(31))), 0x01));

            ir_expression *const r31FD = lshift(r31AD, body.constant(int(31)));
            ir_expression *const r31FE = rshift(r31AE, body.constant(int(1)));
            body.emit(assign(r31FB, bit_or(r31FD, r31FE), 0x01));

            body.emit(assign(r31FC, rshift(r31AD, body.constant(int(1))), 0x01));

            ir_expression *const r31FF = nequal(r30A6, body.constant(0u));
            ir_expression *const r3200 = expr(ir_unop_b2i, r31FF);
            ir_expression *const r3201 = expr(ir_unop_i2u, r3200);
            body.emit(assign(r31FA, bit_or(r31FA, r3201), 0x01));

            body.emit(assign(r30A7, r31FC, 0x01));

            body.emit(assign(r30A6, r31FA, 0x01));

            ir_variable *const r3202 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r3202, r30A5, 0x01));

            ir_variable *const r3203 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r3203, r31FC, 0x01));

            ir_variable *const r3204 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r3204, r31FB, 0x01));

            ir_variable *const r3205 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r3205, r31FA, 0x01));

            ir_variable *const r3206 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r3206, body.constant(true), 0x01));

            ir_variable *const r3207 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r3208 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r3208);
            ir_expression *const r3209 = expr(ir_unop_u2i, r31FA);
            body.emit(assign(r3208, less(r3209, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r320B = lequal(body.constant(int(2045)), r30A5);
            ir_if *f320A = new(mem_ctx) ir_if(operand(r320B).val);
            exec_list *const f320A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f320A->then_instructions;

               ir_variable *const r320C = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r320E = less(body.constant(int(2045)), r30A5);
               ir_if *f320D = new(mem_ctx) ir_if(operand(r320E).val);
               exec_list *const f320D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f320D->then_instructions;

                  body.emit(assign(r320C, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f320D->else_instructions;

                  ir_variable *const r320F = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3211 = equal(r30A5, body.constant(int(2045)));
                  ir_if *f3210 = new(mem_ctx) ir_if(operand(r3211).val);
                  exec_list *const f3210_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3210->then_instructions;

                     ir_expression *const r3212 = equal(body.constant(2097151u), r31FC);
                     ir_expression *const r3213 = equal(body.constant(4294967295u), r31FB);
                     body.emit(assign(r320F, logic_and(r3212, r3213), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3210->else_instructions;

                     body.emit(assign(r320F, body.constant(false), 0x01));


                  body.instructions = f3210_parent_instructions;
                  body.emit(f3210);

                  /* END IF */

                  body.emit(assign(r320C, logic_and(r320F, r3208), 0x01));


               body.instructions = f320D_parent_instructions;
               body.emit(f320D);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3214 = new(mem_ctx) ir_if(operand(r320C).val);
               exec_list *const f3214_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3214->then_instructions;

                  ir_variable *const r3215 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3215);
                  ir_expression *const r3216 = lshift(r2C84, body.constant(int(31)));
                  body.emit(assign(r3215, add(r3216, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r3215, body.constant(0u), 0x01));

                  body.emit(assign(r3207, r3215, 0x03));

                  body.emit(assign(r3206, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3214->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3218 = less(r30A5, body.constant(int(0)));
                  ir_if *f3217 = new(mem_ctx) ir_if(operand(r3218).val);
                  exec_list *const f3217_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3217->then_instructions;

                     ir_variable *const r3219 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r3219, r31FA, 0x01));

                     ir_variable *const r321A = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r321A, neg(r30A5), 0x01));

                     ir_variable *const r321B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r321B);
                     ir_variable *const r321C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r321C);
                     ir_variable *const r321D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r321D);
                     ir_variable *const r321E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r321F = neg(r321A);
                     body.emit(assign(r321E, bit_and(r321F, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3221 = equal(r321A, body.constant(int(0)));
                     ir_if *f3220 = new(mem_ctx) ir_if(operand(r3221).val);
                     exec_list *const f3220_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3220->then_instructions;

                        body.emit(assign(r321B, r31FA, 0x01));

                        body.emit(assign(r321C, r31FB, 0x01));

                        body.emit(assign(r321D, r31FC, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3220->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3223 = less(r321A, body.constant(int(32)));
                        ir_if *f3222 = new(mem_ctx) ir_if(operand(r3223).val);
                        exec_list *const f3222_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3222->then_instructions;

                           body.emit(assign(r321B, lshift(r31FB, r321E), 0x01));

                           ir_expression *const r3224 = lshift(r31FC, r321E);
                           ir_expression *const r3225 = rshift(r31FB, r321A);
                           body.emit(assign(r321C, bit_or(r3224, r3225), 0x01));

                           body.emit(assign(r321D, rshift(r31FC, r321A), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3222->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3227 = equal(r321A, body.constant(int(32)));
                           ir_if *f3226 = new(mem_ctx) ir_if(operand(r3227).val);
                           exec_list *const f3226_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3226->then_instructions;

                              body.emit(assign(r321B, r31FB, 0x01));

                              body.emit(assign(r321C, r31FC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3226->else_instructions;

                              body.emit(assign(r3219, bit_or(r31FA, r31FB), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3229 = less(r321A, body.constant(int(64)));
                              ir_if *f3228 = new(mem_ctx) ir_if(operand(r3229).val);
                              exec_list *const f3228_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3228->then_instructions;

                                 body.emit(assign(r321B, lshift(r31FC, r321E), 0x01));

                                 ir_expression *const r322A = bit_and(r321A, body.constant(int(31)));
                                 body.emit(assign(r321C, rshift(r31FC, r322A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3228->else_instructions;

                                 ir_variable *const r322B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r322D = equal(r321A, body.constant(int(64)));
                                 ir_if *f322C = new(mem_ctx) ir_if(operand(r322D).val);
                                 exec_list *const f322C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f322C->then_instructions;

                                    body.emit(assign(r322B, r31FC, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f322C->else_instructions;

                                    ir_expression *const r322E = nequal(r31FC, body.constant(0u));
                                    ir_expression *const r322F = expr(ir_unop_b2i, r322E);
                                    body.emit(assign(r322B, expr(ir_unop_i2u, r322F), 0x01));


                                 body.instructions = f322C_parent_instructions;
                                 body.emit(f322C);

                                 /* END IF */

                                 body.emit(assign(r321B, r322B, 0x01));

                                 body.emit(assign(r321C, body.constant(0u), 0x01));


                              body.instructions = f3228_parent_instructions;
                              body.emit(f3228);

                              /* END IF */


                           body.instructions = f3226_parent_instructions;
                           body.emit(f3226);

                           /* END IF */

                           body.emit(assign(r321D, body.constant(0u), 0x01));


                        body.instructions = f3222_parent_instructions;
                        body.emit(f3222);

                        /* END IF */

                        ir_expression *const r3230 = nequal(r3219, body.constant(0u));
                        ir_expression *const r3231 = expr(ir_unop_b2i, r3230);
                        ir_expression *const r3232 = expr(ir_unop_i2u, r3231);
                        body.emit(assign(r321B, bit_or(r321B, r3232), 0x01));


                     body.instructions = f3220_parent_instructions;
                     body.emit(f3220);

                     /* END IF */

                     body.emit(assign(r3203, r321D, 0x01));

                     body.emit(assign(r3204, r321C, 0x01));

                     body.emit(assign(r3205, r321B, 0x01));

                     body.emit(assign(r3202, body.constant(int(0)), 0x01));

                     body.emit(assign(r3208, less(r321B, body.constant(0u)), 0x01));


                  body.instructions = f3217_parent_instructions;
                  body.emit(f3217);

                  /* END IF */


               body.instructions = f3214_parent_instructions;
               body.emit(f3214);

               /* END IF */


            body.instructions = f320A_parent_instructions;
            body.emit(f320A);

            /* END IF */

            /* IF CONDITION */
            ir_if *f3233 = new(mem_ctx) ir_if(operand(r3206).val);
            exec_list *const f3233_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3233->then_instructions;

               /* IF CONDITION */
               ir_if *f3234 = new(mem_ctx) ir_if(operand(r3208).val);
               exec_list *const f3234_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3234->then_instructions;

                  ir_variable *const r3235 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3235, add(r3204, body.constant(1u)), 0x01));

                  ir_expression *const r3236 = less(r3235, r3204);
                  ir_expression *const r3237 = expr(ir_unop_b2i, r3236);
                  ir_expression *const r3238 = expr(ir_unop_i2u, r3237);
                  body.emit(assign(r3203, add(r3203, r3238), 0x01));

                  ir_expression *const r3239 = equal(r3205, body.constant(0u));
                  ir_expression *const r323A = expr(ir_unop_b2i, r3239);
                  ir_expression *const r323B = expr(ir_unop_i2u, r323A);
                  ir_expression *const r323C = add(r3205, r323B);
                  ir_expression *const r323D = bit_and(r323C, body.constant(1u));
                  ir_expression *const r323E = expr(ir_unop_bit_not, r323D);
                  body.emit(assign(r3204, bit_and(r3235, r323E), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3234->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3240 = bit_or(r3203, r3204);
                  ir_expression *const r3241 = equal(r3240, body.constant(0u));
                  ir_if *f323F = new(mem_ctx) ir_if(operand(r3241).val);
                  exec_list *const f323F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f323F->then_instructions;

                     body.emit(assign(r3202, body.constant(int(0)), 0x01));


                  body.instructions = f323F_parent_instructions;
                  body.emit(f323F);

                  /* END IF */


               body.instructions = f3234_parent_instructions;
               body.emit(f3234);

               /* END IF */

               ir_variable *const r3242 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r3242);
               ir_expression *const r3243 = lshift(r2C84, body.constant(int(31)));
               ir_expression *const r3244 = expr(ir_unop_i2u, r3202);
               ir_expression *const r3245 = lshift(r3244, body.constant(int(20)));
               ir_expression *const r3246 = add(r3243, r3245);
               body.emit(assign(r3242, add(r3246, r3203), 0x02));

               body.emit(assign(r3242, r3204, 0x01));

               body.emit(assign(r3207, r3242, 0x03));

               body.emit(assign(r3206, body.constant(false), 0x01));


            body.instructions = f3233_parent_instructions;
            body.emit(f3233);

            /* END IF */

            body.emit(assign(r309F, r3207, 0x03));

            body.emit(assign(r309E, body.constant(false), 0x01));


         body.instructions = f31B3_parent_instructions;
         body.emit(f31B3);

         /* END IF */


      body.instructions = f31AC_parent_instructions;
      body.emit(f31AC);

      /* END IF */

      body.emit(assign(r2C83, r309F, 0x03));


   body.instructions = f2C86_parent_instructions;
   body.emit(f2C86);

   /* END IF */

   body.emit(ret(r2C83));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fmod64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r3247 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "x", ir_var_function_in);
   sig_parameters.push_tail(r3247);
   ir_variable *const r3248 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "y", ir_var_function_in);
   sig_parameters.push_tail(r3248);
   ir_variable *const r3249 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r3249, body.constant(true), 0x01));

   ir_variable *const r324A = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r324B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r324B);
   ir_variable *const r324C = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r324C);
   ir_variable *const r324D = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r324D);
   ir_variable *const r324E = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r324E);
   ir_variable *const r324F = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r324F);
   ir_variable *const r3250 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r3250);
   ir_variable *const r3251 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r3251);
   ir_variable *const r3252 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem3", ir_var_auto);
   body.emit(r3252);
   ir_variable *const r3253 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem2", ir_var_auto);
   body.emit(r3253);
   ir_variable *const r3254 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r3254);
   ir_variable *const r3255 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r3255);
   ir_variable *const r3256 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r3256);
   ir_variable *const r3257 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r3257);
   ir_variable *const r3258 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r3258);
   body.emit(assign(r3257, body.constant(0u), 0x01));

   body.emit(assign(r3256, body.constant(0u), 0x01));

   body.emit(assign(r3255, body.constant(0u), 0x01));

   body.emit(assign(r3254, body.constant(0u), 0x01));

   body.emit(assign(r3253, body.constant(0u), 0x01));

   body.emit(assign(r3252, body.constant(0u), 0x01));

   ir_variable *const r3259 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r3259, swizzle_x(r3247), 0x01));

   body.emit(assign(r3251, r3259, 0x01));

   ir_variable *const r325A = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r325A, bit_and(swizzle_y(r3247), body.constant(1048575u)), 0x01));

   body.emit(assign(r3250, r325A, 0x01));

   ir_variable *const r325B = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r325B, swizzle_x(r3248), 0x01));

   body.emit(assign(r324F, r325B, 0x01));

   ir_variable *const r325C = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r325C, bit_and(swizzle_y(r3248), body.constant(1048575u)), 0x01));

   body.emit(assign(r324E, r325C, 0x01));

   ir_variable *const r325D = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r325E = rshift(swizzle_y(r3247), body.constant(int(20)));
   ir_expression *const r325F = bit_and(r325E, body.constant(2047u));
   body.emit(assign(r325D, expr(ir_unop_u2i, r325F), 0x01));

   body.emit(assign(r324D, r325D, 0x01));

   ir_variable *const r3260 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r3261 = rshift(swizzle_y(r3248), body.constant(int(20)));
   ir_expression *const r3262 = bit_and(r3261, body.constant(2047u));
   body.emit(assign(r3260, expr(ir_unop_u2i, r3262), 0x01));

   body.emit(assign(r324C, r3260, 0x01));

   ir_expression *const r3263 = rshift(swizzle_y(r3247), body.constant(int(31)));
   ir_expression *const r3264 = rshift(swizzle_y(r3248), body.constant(int(31)));
   body.emit(assign(r324B, bit_xor(r3263, r3264), 0x01));

   /* IF CONDITION */
   ir_expression *const r3266 = equal(r325D, body.constant(int(2047)));
   ir_if *f3265 = new(mem_ctx) ir_if(operand(r3266).val);
   exec_list *const f3265_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f3265->then_instructions;

      /* IF CONDITION */
      ir_expression *const r3268 = bit_or(r325A, swizzle_x(r3247));
      ir_expression *const r3269 = nequal(r3268, body.constant(0u));
      ir_if *f3267 = new(mem_ctx) ir_if(operand(r3269).val);
      exec_list *const f3267_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3267->then_instructions;

         ir_variable *const r326A = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r326A, swizzle_x(r3247), 0x01));

         ir_variable *const r326B = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r326B, swizzle_x(r3248), 0x01));

         ir_variable *const r326C = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r326D = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r326E = rshift(swizzle_y(r3247), body.constant(int(19)));
         ir_expression *const r326F = bit_and(r326E, body.constant(4095u));
         ir_expression *const r3270 = equal(r326F, body.constant(4094u));
         ir_expression *const r3271 = nequal(swizzle_x(r3247), body.constant(0u));
         ir_expression *const r3272 = bit_and(swizzle_y(r3247), body.constant(524287u));
         ir_expression *const r3273 = nequal(r3272, body.constant(0u));
         ir_expression *const r3274 = logic_or(r3271, r3273);
         body.emit(assign(r326D, logic_and(r3270, r3274), 0x01));

         ir_variable *const r3275 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r3276 = lshift(swizzle_y(r3248), body.constant(int(1)));
         ir_expression *const r3277 = lequal(body.constant(4292870144u), r3276);
         ir_expression *const r3278 = nequal(swizzle_x(r3248), body.constant(0u));
         ir_expression *const r3279 = bit_and(swizzle_y(r3248), body.constant(1048575u));
         ir_expression *const r327A = nequal(r3279, body.constant(0u));
         ir_expression *const r327B = logic_or(r3278, r327A);
         body.emit(assign(r3275, logic_and(r3277, r327B), 0x01));

         body.emit(assign(r326A, bit_or(swizzle_y(r3247), body.constant(524288u)), 0x02));

         body.emit(assign(r326B, bit_or(swizzle_y(r3248), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r327D = lshift(swizzle_y(r3247), body.constant(int(1)));
         ir_expression *const r327E = lequal(body.constant(4292870144u), r327D);
         ir_expression *const r327F = nequal(swizzle_x(r3247), body.constant(0u));
         ir_expression *const r3280 = bit_and(swizzle_y(r3247), body.constant(1048575u));
         ir_expression *const r3281 = nequal(r3280, body.constant(0u));
         ir_expression *const r3282 = logic_or(r327F, r3281);
         ir_expression *const r3283 = logic_and(r327E, r3282);
         ir_if *f327C = new(mem_ctx) ir_if(operand(r3283).val);
         exec_list *const f327C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f327C->then_instructions;

            ir_variable *const r3284 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r3286 = logic_and(r326D, r3275);
            ir_if *f3285 = new(mem_ctx) ir_if(operand(r3286).val);
            exec_list *const f3285_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3285->then_instructions;

               body.emit(assign(r3284, r326B, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3285->else_instructions;

               body.emit(assign(r3284, r326A, 0x03));


            body.instructions = f3285_parent_instructions;
            body.emit(f3285);

            /* END IF */

            body.emit(assign(r326C, r3284, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f327C->else_instructions;

            body.emit(assign(r326C, r326B, 0x03));


         body.instructions = f327C_parent_instructions;
         body.emit(f327C);

         /* END IF */

         body.emit(assign(r324A, r326C, 0x03));

         body.emit(assign(r3249, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3267->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3288 = equal(r3260, body.constant(int(2047)));
         ir_if *f3287 = new(mem_ctx) ir_if(operand(r3288).val);
         exec_list *const f3287_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3287->then_instructions;

            /* IF CONDITION */
            ir_expression *const r328A = bit_or(r325C, swizzle_x(r3248));
            ir_expression *const r328B = nequal(r328A, body.constant(0u));
            ir_if *f3289 = new(mem_ctx) ir_if(operand(r328B).val);
            exec_list *const f3289_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3289->then_instructions;

               ir_variable *const r328C = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r328C, swizzle_x(r3247), 0x01));

               ir_variable *const r328D = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r328D, swizzle_x(r3248), 0x01));

               ir_variable *const r328E = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r328F = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r3290 = rshift(swizzle_y(r3247), body.constant(int(19)));
               ir_expression *const r3291 = bit_and(r3290, body.constant(4095u));
               ir_expression *const r3292 = equal(r3291, body.constant(4094u));
               ir_expression *const r3293 = nequal(swizzle_x(r3247), body.constant(0u));
               ir_expression *const r3294 = bit_and(swizzle_y(r3247), body.constant(524287u));
               ir_expression *const r3295 = nequal(r3294, body.constant(0u));
               ir_expression *const r3296 = logic_or(r3293, r3295);
               body.emit(assign(r328F, logic_and(r3292, r3296), 0x01));

               ir_variable *const r3297 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r3298 = lshift(swizzle_y(r3248), body.constant(int(1)));
               ir_expression *const r3299 = lequal(body.constant(4292870144u), r3298);
               ir_expression *const r329A = nequal(swizzle_x(r3248), body.constant(0u));
               ir_expression *const r329B = bit_and(swizzle_y(r3248), body.constant(1048575u));
               ir_expression *const r329C = nequal(r329B, body.constant(0u));
               ir_expression *const r329D = logic_or(r329A, r329C);
               body.emit(assign(r3297, logic_and(r3299, r329D), 0x01));

               body.emit(assign(r328C, bit_or(swizzle_y(r3247), body.constant(524288u)), 0x02));

               body.emit(assign(r328D, bit_or(swizzle_y(r3248), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r329F = lshift(swizzle_y(r3247), body.constant(int(1)));
               ir_expression *const r32A0 = lequal(body.constant(4292870144u), r329F);
               ir_expression *const r32A1 = nequal(swizzle_x(r3247), body.constant(0u));
               ir_expression *const r32A2 = bit_and(swizzle_y(r3247), body.constant(1048575u));
               ir_expression *const r32A3 = nequal(r32A2, body.constant(0u));
               ir_expression *const r32A4 = logic_or(r32A1, r32A3);
               ir_expression *const r32A5 = logic_and(r32A0, r32A4);
               ir_if *f329E = new(mem_ctx) ir_if(operand(r32A5).val);
               exec_list *const f329E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f329E->then_instructions;

                  ir_variable *const r32A6 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r32A8 = logic_and(r328F, r3297);
                  ir_if *f32A7 = new(mem_ctx) ir_if(operand(r32A8).val);
                  exec_list *const f32A7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32A7->then_instructions;

                     body.emit(assign(r32A6, r328D, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32A7->else_instructions;

                     body.emit(assign(r32A6, r328C, 0x03));


                  body.instructions = f32A7_parent_instructions;
                  body.emit(f32A7);

                  /* END IF */

                  body.emit(assign(r328E, r32A6, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f329E->else_instructions;

                  body.emit(assign(r328E, r328D, 0x03));


               body.instructions = f329E_parent_instructions;
               body.emit(f329E);

               /* END IF */

               body.emit(assign(r324A, r328E, 0x03));

               body.emit(assign(r3249, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3289->else_instructions;

               ir_constant_data r32A9_data;
               memset(&r32A9_data, 0, sizeof(ir_constant_data));
               r32A9_data.u[0] = 4294967295;
               r32A9_data.u[1] = 4294967295;
               ir_constant *const r32A9 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r32A9_data);
               body.emit(assign(r324A, r32A9, 0x03));

               body.emit(assign(r3249, body.constant(false), 0x01));


            body.instructions = f3289_parent_instructions;
            body.emit(f3289);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3287->else_instructions;

            ir_variable *const r32AA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r32AA);
            ir_expression *const r32AB = lshift(r324B, body.constant(int(31)));
            body.emit(assign(r32AA, add(r32AB, body.constant(2146435072u)), 0x02));

            body.emit(assign(r32AA, body.constant(0u), 0x01));

            body.emit(assign(r324A, r32AA, 0x03));

            body.emit(assign(r3249, body.constant(false), 0x01));


         body.instructions = f3287_parent_instructions;
         body.emit(f3287);

         /* END IF */


      body.instructions = f3267_parent_instructions;
      body.emit(f3267);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f3265->else_instructions;

      /* IF CONDITION */
      ir_expression *const r32AD = equal(r3260, body.constant(int(2047)));
      ir_if *f32AC = new(mem_ctx) ir_if(operand(r32AD).val);
      exec_list *const f32AC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f32AC->then_instructions;

         /* IF CONDITION */
         ir_expression *const r32AF = bit_or(r325C, swizzle_x(r3248));
         ir_expression *const r32B0 = nequal(r32AF, body.constant(0u));
         ir_if *f32AE = new(mem_ctx) ir_if(operand(r32B0).val);
         exec_list *const f32AE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f32AE->then_instructions;

            ir_variable *const r32B1 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r32B1, swizzle_x(r3247), 0x01));

            ir_variable *const r32B2 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r32B2, swizzle_x(r3248), 0x01));

            ir_variable *const r32B3 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r32B4 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r32B5 = rshift(swizzle_y(r3247), body.constant(int(19)));
            ir_expression *const r32B6 = bit_and(r32B5, body.constant(4095u));
            ir_expression *const r32B7 = equal(r32B6, body.constant(4094u));
            ir_expression *const r32B8 = nequal(swizzle_x(r3247), body.constant(0u));
            ir_expression *const r32B9 = bit_and(swizzle_y(r3247), body.constant(524287u));
            ir_expression *const r32BA = nequal(r32B9, body.constant(0u));
            ir_expression *const r32BB = logic_or(r32B8, r32BA);
            body.emit(assign(r32B4, logic_and(r32B7, r32BB), 0x01));

            ir_variable *const r32BC = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r32BD = lshift(swizzle_y(r3248), body.constant(int(1)));
            ir_expression *const r32BE = lequal(body.constant(4292870144u), r32BD);
            ir_expression *const r32BF = nequal(swizzle_x(r3248), body.constant(0u));
            ir_expression *const r32C0 = bit_and(swizzle_y(r3248), body.constant(1048575u));
            ir_expression *const r32C1 = nequal(r32C0, body.constant(0u));
            ir_expression *const r32C2 = logic_or(r32BF, r32C1);
            body.emit(assign(r32BC, logic_and(r32BE, r32C2), 0x01));

            body.emit(assign(r32B1, bit_or(swizzle_y(r3247), body.constant(524288u)), 0x02));

            body.emit(assign(r32B2, bit_or(swizzle_y(r3248), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r32C4 = lshift(swizzle_y(r3247), body.constant(int(1)));
            ir_expression *const r32C5 = lequal(body.constant(4292870144u), r32C4);
            ir_expression *const r32C6 = nequal(swizzle_x(r3247), body.constant(0u));
            ir_expression *const r32C7 = bit_and(swizzle_y(r3247), body.constant(1048575u));
            ir_expression *const r32C8 = nequal(r32C7, body.constant(0u));
            ir_expression *const r32C9 = logic_or(r32C6, r32C8);
            ir_expression *const r32CA = logic_and(r32C5, r32C9);
            ir_if *f32C3 = new(mem_ctx) ir_if(operand(r32CA).val);
            exec_list *const f32C3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f32C3->then_instructions;

               ir_variable *const r32CB = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r32CD = logic_and(r32B4, r32BC);
               ir_if *f32CC = new(mem_ctx) ir_if(operand(r32CD).val);
               exec_list *const f32CC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32CC->then_instructions;

                  body.emit(assign(r32CB, r32B2, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32CC->else_instructions;

                  body.emit(assign(r32CB, r32B1, 0x03));


               body.instructions = f32CC_parent_instructions;
               body.emit(f32CC);

               /* END IF */

               body.emit(assign(r32B3, r32CB, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f32C3->else_instructions;

               body.emit(assign(r32B3, r32B2, 0x03));


            body.instructions = f32C3_parent_instructions;
            body.emit(f32C3);

            /* END IF */

            body.emit(assign(r324A, r32B3, 0x03));

            body.emit(assign(r3249, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f32AE->else_instructions;

            ir_variable *const r32CE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r32CE);
            body.emit(assign(r32CE, lshift(r324B, body.constant(int(31))), 0x02));

            body.emit(assign(r32CE, body.constant(0u), 0x01));

            body.emit(assign(r324A, r32CE, 0x03));

            body.emit(assign(r3249, body.constant(false), 0x01));


         body.instructions = f32AE_parent_instructions;
         body.emit(f32AE);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f32AC->else_instructions;

         /* IF CONDITION */
         ir_expression *const r32D0 = equal(r3260, body.constant(int(0)));
         ir_if *f32CF = new(mem_ctx) ir_if(operand(r32D0).val);
         exec_list *const f32CF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f32CF->then_instructions;

            /* IF CONDITION */
            ir_expression *const r32D2 = bit_or(r325C, swizzle_x(r3248));
            ir_expression *const r32D3 = equal(r32D2, body.constant(0u));
            ir_if *f32D1 = new(mem_ctx) ir_if(operand(r32D3).val);
            exec_list *const f32D1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f32D1->then_instructions;

               /* IF CONDITION */
               ir_expression *const r32D5 = expr(ir_unop_i2u, r325D);
               ir_expression *const r32D6 = bit_or(r32D5, r325A);
               ir_expression *const r32D7 = bit_or(r32D6, swizzle_x(r3247));
               ir_expression *const r32D8 = equal(r32D7, body.constant(0u));
               ir_if *f32D4 = new(mem_ctx) ir_if(operand(r32D8).val);
               exec_list *const f32D4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32D4->then_instructions;

                  ir_constant_data r32D9_data;
                  memset(&r32D9_data, 0, sizeof(ir_constant_data));
                  r32D9_data.u[0] = 4294967295;
                  r32D9_data.u[1] = 4294967295;
                  ir_constant *const r32D9 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r32D9_data);
                  body.emit(assign(r324A, r32D9, 0x03));

                  body.emit(assign(r3249, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32D4->else_instructions;

                  ir_variable *const r32DA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r32DA);
                  ir_expression *const r32DB = lshift(r324B, body.constant(int(31)));
                  body.emit(assign(r32DA, add(r32DB, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r32DA, body.constant(0u), 0x01));

                  body.emit(assign(r324A, r32DA, 0x03));

                  body.emit(assign(r3249, body.constant(false), 0x01));


               body.instructions = f32D4_parent_instructions;
               body.emit(f32D4);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f32D1->else_instructions;

               ir_variable *const r32DC = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r32DC, r3260, 0x01));

               ir_variable *const r32DD = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r32DD, r325C, 0x01));

               ir_variable *const r32DE = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r32DE, r325B, 0x01));

               ir_variable *const r32DF = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r32DF);
               /* IF CONDITION */
               ir_expression *const r32E1 = equal(r325C, body.constant(0u));
               ir_if *f32E0 = new(mem_ctx) ir_if(operand(r32E1).val);
               exec_list *const f32E0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32E0->then_instructions;

                  ir_variable *const r32E2 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r32E2, r325B, 0x01));

                  ir_variable *const r32E3 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r32E4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r32E4);
                  /* IF CONDITION */
                  ir_expression *const r32E6 = equal(swizzle_x(r3248), body.constant(0u));
                  ir_if *f32E5 = new(mem_ctx) ir_if(operand(r32E6).val);
                  exec_list *const f32E5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32E5->then_instructions;

                     body.emit(assign(r32E3, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32E5->else_instructions;

                     body.emit(assign(r32E4, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r32E8 = bit_and(swizzle_x(r3248), body.constant(4294901760u));
                     ir_expression *const r32E9 = equal(r32E8, body.constant(0u));
                     ir_if *f32E7 = new(mem_ctx) ir_if(operand(r32E9).val);
                     exec_list *const f32E7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32E7->then_instructions;

                        body.emit(assign(r32E4, body.constant(int(16)), 0x01));

                        body.emit(assign(r32E2, lshift(swizzle_x(r3248), body.constant(int(16))), 0x01));


                     body.instructions = f32E7_parent_instructions;
                     body.emit(f32E7);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32EB = bit_and(r32E2, body.constant(4278190080u));
                     ir_expression *const r32EC = equal(r32EB, body.constant(0u));
                     ir_if *f32EA = new(mem_ctx) ir_if(operand(r32EC).val);
                     exec_list *const f32EA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32EA->then_instructions;

                        body.emit(assign(r32E4, add(r32E4, body.constant(int(8))), 0x01));

                        body.emit(assign(r32E2, lshift(r32E2, body.constant(int(8))), 0x01));


                     body.instructions = f32EA_parent_instructions;
                     body.emit(f32EA);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32EE = bit_and(r32E2, body.constant(4026531840u));
                     ir_expression *const r32EF = equal(r32EE, body.constant(0u));
                     ir_if *f32ED = new(mem_ctx) ir_if(operand(r32EF).val);
                     exec_list *const f32ED_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32ED->then_instructions;

                        body.emit(assign(r32E4, add(r32E4, body.constant(int(4))), 0x01));

                        body.emit(assign(r32E2, lshift(r32E2, body.constant(int(4))), 0x01));


                     body.instructions = f32ED_parent_instructions;
                     body.emit(f32ED);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32F1 = bit_and(r32E2, body.constant(3221225472u));
                     ir_expression *const r32F2 = equal(r32F1, body.constant(0u));
                     ir_if *f32F0 = new(mem_ctx) ir_if(operand(r32F2).val);
                     exec_list *const f32F0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32F0->then_instructions;

                        body.emit(assign(r32E4, add(r32E4, body.constant(int(2))), 0x01));

                        body.emit(assign(r32E2, lshift(r32E2, body.constant(int(2))), 0x01));


                     body.instructions = f32F0_parent_instructions;
                     body.emit(f32F0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32F4 = bit_and(r32E2, body.constant(2147483648u));
                     ir_expression *const r32F5 = equal(r32F4, body.constant(0u));
                     ir_if *f32F3 = new(mem_ctx) ir_if(operand(r32F5).val);
                     exec_list *const f32F3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32F3->then_instructions;

                        body.emit(assign(r32E4, add(r32E4, body.constant(int(1))), 0x01));


                     body.instructions = f32F3_parent_instructions;
                     body.emit(f32F3);

                     /* END IF */

                     body.emit(assign(r32E3, r32E4, 0x01));


                  body.instructions = f32E5_parent_instructions;
                  body.emit(f32E5);

                  /* END IF */

                  body.emit(assign(r32DF, add(r32E3, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r32F7 = less(r32DF, body.constant(int(0)));
                  ir_if *f32F6 = new(mem_ctx) ir_if(operand(r32F7).val);
                  exec_list *const f32F6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32F6->then_instructions;

                     ir_expression *const r32F8 = neg(r32DF);
                     body.emit(assign(r32DD, rshift(swizzle_x(r3248), r32F8), 0x01));

                     ir_expression *const r32F9 = bit_and(r32DF, body.constant(int(31)));
                     body.emit(assign(r32DE, lshift(swizzle_x(r3248), r32F9), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32F6->else_instructions;

                     body.emit(assign(r32DD, lshift(swizzle_x(r3248), r32DF), 0x01));

                     body.emit(assign(r32DE, body.constant(0u), 0x01));


                  body.instructions = f32F6_parent_instructions;
                  body.emit(f32F6);

                  /* END IF */

                  body.emit(assign(r32DC, sub(body.constant(int(-31)), r32DF), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32E0->else_instructions;

                  ir_variable *const r32FA = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r32FA, r325C, 0x01));

                  ir_variable *const r32FB = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r32FC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r32FC);
                  /* IF CONDITION */
                  ir_expression *const r32FE = equal(r325C, body.constant(0u));
                  ir_if *f32FD = new(mem_ctx) ir_if(operand(r32FE).val);
                  exec_list *const f32FD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32FD->then_instructions;

                     body.emit(assign(r32FB, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32FD->else_instructions;

                     body.emit(assign(r32FC, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3300 = bit_and(r325C, body.constant(4294901760u));
                     ir_expression *const r3301 = equal(r3300, body.constant(0u));
                     ir_if *f32FF = new(mem_ctx) ir_if(operand(r3301).val);
                     exec_list *const f32FF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32FF->then_instructions;

                        body.emit(assign(r32FC, body.constant(int(16)), 0x01));

                        body.emit(assign(r32FA, lshift(r325C, body.constant(int(16))), 0x01));


                     body.instructions = f32FF_parent_instructions;
                     body.emit(f32FF);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3303 = bit_and(r32FA, body.constant(4278190080u));
                     ir_expression *const r3304 = equal(r3303, body.constant(0u));
                     ir_if *f3302 = new(mem_ctx) ir_if(operand(r3304).val);
                     exec_list *const f3302_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3302->then_instructions;

                        body.emit(assign(r32FC, add(r32FC, body.constant(int(8))), 0x01));

                        body.emit(assign(r32FA, lshift(r32FA, body.constant(int(8))), 0x01));


                     body.instructions = f3302_parent_instructions;
                     body.emit(f3302);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3306 = bit_and(r32FA, body.constant(4026531840u));
                     ir_expression *const r3307 = equal(r3306, body.constant(0u));
                     ir_if *f3305 = new(mem_ctx) ir_if(operand(r3307).val);
                     exec_list *const f3305_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3305->then_instructions;

                        body.emit(assign(r32FC, add(r32FC, body.constant(int(4))), 0x01));

                        body.emit(assign(r32FA, lshift(r32FA, body.constant(int(4))), 0x01));


                     body.instructions = f3305_parent_instructions;
                     body.emit(f3305);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3309 = bit_and(r32FA, body.constant(3221225472u));
                     ir_expression *const r330A = equal(r3309, body.constant(0u));
                     ir_if *f3308 = new(mem_ctx) ir_if(operand(r330A).val);
                     exec_list *const f3308_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3308->then_instructions;

                        body.emit(assign(r32FC, add(r32FC, body.constant(int(2))), 0x01));

                        body.emit(assign(r32FA, lshift(r32FA, body.constant(int(2))), 0x01));


                     body.instructions = f3308_parent_instructions;
                     body.emit(f3308);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r330C = bit_and(r32FA, body.constant(2147483648u));
                     ir_expression *const r330D = equal(r330C, body.constant(0u));
                     ir_if *f330B = new(mem_ctx) ir_if(operand(r330D).val);
                     exec_list *const f330B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f330B->then_instructions;

                        body.emit(assign(r32FC, add(r32FC, body.constant(int(1))), 0x01));


                     body.instructions = f330B_parent_instructions;
                     body.emit(f330B);

                     /* END IF */

                     body.emit(assign(r32FB, r32FC, 0x01));


                  body.instructions = f32FD_parent_instructions;
                  body.emit(f32FD);

                  /* END IF */

                  body.emit(assign(r32DF, add(r32FB, body.constant(int(-11))), 0x01));

                  ir_variable *const r330E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r330E, lshift(swizzle_x(r3248), r32DF), 0x01));

                  ir_variable *const r330F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3311 = equal(r32DF, body.constant(int(0)));
                  ir_if *f3310 = new(mem_ctx) ir_if(operand(r3311).val);
                  exec_list *const f3310_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3310->then_instructions;

                     body.emit(assign(r330F, r325C, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3310->else_instructions;

                     ir_expression *const r3312 = lshift(r325C, r32DF);
                     ir_expression *const r3313 = neg(r32DF);
                     ir_expression *const r3314 = bit_and(r3313, body.constant(int(31)));
                     ir_expression *const r3315 = rshift(swizzle_x(r3248), r3314);
                     body.emit(assign(r330F, bit_or(r3312, r3315), 0x01));


                  body.instructions = f3310_parent_instructions;
                  body.emit(f3310);

                  /* END IF */

                  body.emit(assign(r32DD, r330F, 0x01));

                  body.emit(assign(r32DE, r330E, 0x01));

                  body.emit(assign(r32DC, sub(body.constant(int(1)), r32DF), 0x01));


               body.instructions = f32E0_parent_instructions;
               body.emit(f32E0);

               /* END IF */

               body.emit(assign(r324C, r32DC, 0x01));

               body.emit(assign(r324E, r32DD, 0x01));

               body.emit(assign(r324F, r32DE, 0x01));


            body.instructions = f32D1_parent_instructions;
            body.emit(f32D1);

            /* END IF */


         body.instructions = f32CF_parent_instructions;
         body.emit(f32CF);

         /* END IF */

         /* IF CONDITION */
         ir_if *f3316 = new(mem_ctx) ir_if(operand(r3249).val);
         exec_list *const f3316_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3316->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3318 = equal(r325D, body.constant(int(0)));
            ir_if *f3317 = new(mem_ctx) ir_if(operand(r3318).val);
            exec_list *const f3317_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3317->then_instructions;

               /* IF CONDITION */
               ir_expression *const r331A = bit_or(r325A, swizzle_x(r3247));
               ir_expression *const r331B = equal(r331A, body.constant(0u));
               ir_if *f3319 = new(mem_ctx) ir_if(operand(r331B).val);
               exec_list *const f3319_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3319->then_instructions;

                  ir_variable *const r331C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r331C);
                  body.emit(assign(r331C, lshift(r324B, body.constant(int(31))), 0x02));

                  body.emit(assign(r331C, body.constant(0u), 0x01));

                  body.emit(assign(r324A, r331C, 0x03));

                  body.emit(assign(r3249, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3319->else_instructions;

                  ir_variable *const r331D = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r331D, r325D, 0x01));

                  ir_variable *const r331E = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r331E, r325A, 0x01));

                  ir_variable *const r331F = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r331F, r3259, 0x01));

                  ir_variable *const r3320 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3320);
                  /* IF CONDITION */
                  ir_expression *const r3322 = equal(r325A, body.constant(0u));
                  ir_if *f3321 = new(mem_ctx) ir_if(operand(r3322).val);
                  exec_list *const f3321_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3321->then_instructions;

                     ir_variable *const r3323 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3323, r3259, 0x01));

                     ir_variable *const r3324 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3325 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3325);
                     /* IF CONDITION */
                     ir_expression *const r3327 = equal(swizzle_x(r3247), body.constant(0u));
                     ir_if *f3326 = new(mem_ctx) ir_if(operand(r3327).val);
                     exec_list *const f3326_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3326->then_instructions;

                        body.emit(assign(r3324, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3326->else_instructions;

                        body.emit(assign(r3325, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3329 = bit_and(swizzle_x(r3247), body.constant(4294901760u));
                        ir_expression *const r332A = equal(r3329, body.constant(0u));
                        ir_if *f3328 = new(mem_ctx) ir_if(operand(r332A).val);
                        exec_list *const f3328_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3328->then_instructions;

                           body.emit(assign(r3325, body.constant(int(16)), 0x01));

                           body.emit(assign(r3323, lshift(swizzle_x(r3247), body.constant(int(16))), 0x01));


                        body.instructions = f3328_parent_instructions;
                        body.emit(f3328);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r332C = bit_and(r3323, body.constant(4278190080u));
                        ir_expression *const r332D = equal(r332C, body.constant(0u));
                        ir_if *f332B = new(mem_ctx) ir_if(operand(r332D).val);
                        exec_list *const f332B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f332B->then_instructions;

                           body.emit(assign(r3325, add(r3325, body.constant(int(8))), 0x01));

                           body.emit(assign(r3323, lshift(r3323, body.constant(int(8))), 0x01));


                        body.instructions = f332B_parent_instructions;
                        body.emit(f332B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r332F = bit_and(r3323, body.constant(4026531840u));
                        ir_expression *const r3330 = equal(r332F, body.constant(0u));
                        ir_if *f332E = new(mem_ctx) ir_if(operand(r3330).val);
                        exec_list *const f332E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f332E->then_instructions;

                           body.emit(assign(r3325, add(r3325, body.constant(int(4))), 0x01));

                           body.emit(assign(r3323, lshift(r3323, body.constant(int(4))), 0x01));


                        body.instructions = f332E_parent_instructions;
                        body.emit(f332E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3332 = bit_and(r3323, body.constant(3221225472u));
                        ir_expression *const r3333 = equal(r3332, body.constant(0u));
                        ir_if *f3331 = new(mem_ctx) ir_if(operand(r3333).val);
                        exec_list *const f3331_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3331->then_instructions;

                           body.emit(assign(r3325, add(r3325, body.constant(int(2))), 0x01));

                           body.emit(assign(r3323, lshift(r3323, body.constant(int(2))), 0x01));


                        body.instructions = f3331_parent_instructions;
                        body.emit(f3331);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3335 = bit_and(r3323, body.constant(2147483648u));
                        ir_expression *const r3336 = equal(r3335, body.constant(0u));
                        ir_if *f3334 = new(mem_ctx) ir_if(operand(r3336).val);
                        exec_list *const f3334_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3334->then_instructions;

                           body.emit(assign(r3325, add(r3325, body.constant(int(1))), 0x01));


                        body.instructions = f3334_parent_instructions;
                        body.emit(f3334);

                        /* END IF */

                        body.emit(assign(r3324, r3325, 0x01));


                     body.instructions = f3326_parent_instructions;
                     body.emit(f3326);

                     /* END IF */

                     body.emit(assign(r3320, add(r3324, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3338 = less(r3320, body.constant(int(0)));
                     ir_if *f3337 = new(mem_ctx) ir_if(operand(r3338).val);
                     exec_list *const f3337_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3337->then_instructions;

                        ir_expression *const r3339 = neg(r3320);
                        body.emit(assign(r331E, rshift(swizzle_x(r3247), r3339), 0x01));

                        ir_expression *const r333A = bit_and(r3320, body.constant(int(31)));
                        body.emit(assign(r331F, lshift(swizzle_x(r3247), r333A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3337->else_instructions;

                        body.emit(assign(r331E, lshift(swizzle_x(r3247), r3320), 0x01));

                        body.emit(assign(r331F, body.constant(0u), 0x01));


                     body.instructions = f3337_parent_instructions;
                     body.emit(f3337);

                     /* END IF */

                     body.emit(assign(r331D, sub(body.constant(int(-31)), r3320), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3321->else_instructions;

                     ir_variable *const r333B = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r333B, r325A, 0x01));

                     ir_variable *const r333C = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r333D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r333D);
                     /* IF CONDITION */
                     ir_expression *const r333F = equal(r325A, body.constant(0u));
                     ir_if *f333E = new(mem_ctx) ir_if(operand(r333F).val);
                     exec_list *const f333E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f333E->then_instructions;

                        body.emit(assign(r333C, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f333E->else_instructions;

                        body.emit(assign(r333D, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3341 = bit_and(r325A, body.constant(4294901760u));
                        ir_expression *const r3342 = equal(r3341, body.constant(0u));
                        ir_if *f3340 = new(mem_ctx) ir_if(operand(r3342).val);
                        exec_list *const f3340_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3340->then_instructions;

                           body.emit(assign(r333D, body.constant(int(16)), 0x01));

                           body.emit(assign(r333B, lshift(r325A, body.constant(int(16))), 0x01));


                        body.instructions = f3340_parent_instructions;
                        body.emit(f3340);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3344 = bit_and(r333B, body.constant(4278190080u));
                        ir_expression *const r3345 = equal(r3344, body.constant(0u));
                        ir_if *f3343 = new(mem_ctx) ir_if(operand(r3345).val);
                        exec_list *const f3343_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3343->then_instructions;

                           body.emit(assign(r333D, add(r333D, body.constant(int(8))), 0x01));

                           body.emit(assign(r333B, lshift(r333B, body.constant(int(8))), 0x01));


                        body.instructions = f3343_parent_instructions;
                        body.emit(f3343);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3347 = bit_and(r333B, body.constant(4026531840u));
                        ir_expression *const r3348 = equal(r3347, body.constant(0u));
                        ir_if *f3346 = new(mem_ctx) ir_if(operand(r3348).val);
                        exec_list *const f3346_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3346->then_instructions;

                           body.emit(assign(r333D, add(r333D, body.constant(int(4))), 0x01));

                           body.emit(assign(r333B, lshift(r333B, body.constant(int(4))), 0x01));


                        body.instructions = f3346_parent_instructions;
                        body.emit(f3346);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r334A = bit_and(r333B, body.constant(3221225472u));
                        ir_expression *const r334B = equal(r334A, body.constant(0u));
                        ir_if *f3349 = new(mem_ctx) ir_if(operand(r334B).val);
                        exec_list *const f3349_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3349->then_instructions;

                           body.emit(assign(r333D, add(r333D, body.constant(int(2))), 0x01));

                           body.emit(assign(r333B, lshift(r333B, body.constant(int(2))), 0x01));


                        body.instructions = f3349_parent_instructions;
                        body.emit(f3349);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r334D = bit_and(r333B, body.constant(2147483648u));
                        ir_expression *const r334E = equal(r334D, body.constant(0u));
                        ir_if *f334C = new(mem_ctx) ir_if(operand(r334E).val);
                        exec_list *const f334C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f334C->then_instructions;

                           body.emit(assign(r333D, add(r333D, body.constant(int(1))), 0x01));


                        body.instructions = f334C_parent_instructions;
                        body.emit(f334C);

                        /* END IF */

                        body.emit(assign(r333C, r333D, 0x01));


                     body.instructions = f333E_parent_instructions;
                     body.emit(f333E);

                     /* END IF */

                     body.emit(assign(r3320, add(r333C, body.constant(int(-11))), 0x01));

                     ir_variable *const r334F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r334F, lshift(swizzle_x(r3247), r3320), 0x01));

                     ir_variable *const r3350 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3352 = equal(r3320, body.constant(int(0)));
                     ir_if *f3351 = new(mem_ctx) ir_if(operand(r3352).val);
                     exec_list *const f3351_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3351->then_instructions;

                        body.emit(assign(r3350, r325A, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3351->else_instructions;

                        ir_expression *const r3353 = lshift(r325A, r3320);
                        ir_expression *const r3354 = neg(r3320);
                        ir_expression *const r3355 = bit_and(r3354, body.constant(int(31)));
                        ir_expression *const r3356 = rshift(swizzle_x(r3247), r3355);
                        body.emit(assign(r3350, bit_or(r3353, r3356), 0x01));


                     body.instructions = f3351_parent_instructions;
                     body.emit(f3351);

                     /* END IF */

                     body.emit(assign(r331E, r3350, 0x01));

                     body.emit(assign(r331F, r334F, 0x01));

                     body.emit(assign(r331D, sub(body.constant(int(1)), r3320), 0x01));


                  body.instructions = f3321_parent_instructions;
                  body.emit(f3321);

                  /* END IF */

                  body.emit(assign(r324D, r331D, 0x01));

                  body.emit(assign(r3250, r331E, 0x01));

                  body.emit(assign(r3251, r331F, 0x01));


               body.instructions = f3319_parent_instructions;
               body.emit(f3319);

               /* END IF */


            body.instructions = f3317_parent_instructions;
            body.emit(f3317);

            /* END IF */

            /* IF CONDITION */
            ir_if *f3357 = new(mem_ctx) ir_if(operand(r3249).val);
            exec_list *const f3357_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3357->then_instructions;

               ir_expression *const r3358 = sub(r324D, r324C);
               body.emit(assign(r3258, add(r3358, body.constant(int(1021))), 0x01));

               ir_variable *const r3359 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3359, lshift(r3251, body.constant(int(11))), 0x01));

               ir_variable *const r335A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r335B = bit_or(r3250, body.constant(1048576u));
               ir_expression *const r335C = lshift(r335B, body.constant(int(11)));
               ir_expression *const r335D = rshift(r3251, body.constant(int(21)));
               body.emit(assign(r335A, bit_or(r335C, r335D), 0x01));

               body.emit(assign(r3250, r335A, 0x01));

               body.emit(assign(r3251, r3359, 0x01));

               ir_variable *const r335E = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r335E, lshift(r324F, body.constant(int(11))), 0x01));

               ir_variable *const r335F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r3360 = bit_or(r324E, body.constant(1048576u));
               ir_expression *const r3361 = lshift(r3360, body.constant(int(11)));
               ir_expression *const r3362 = rshift(r324F, body.constant(int(21)));
               body.emit(assign(r335F, bit_or(r3361, r3362), 0x01));

               body.emit(assign(r324E, r335F, 0x01));

               body.emit(assign(r324F, r335E, 0x01));

               /* IF CONDITION */
               ir_expression *const r3364 = less(r335F, r335A);
               ir_expression *const r3365 = equal(r335F, r335A);
               ir_expression *const r3366 = lequal(r335E, r3359);
               ir_expression *const r3367 = logic_and(r3365, r3366);
               ir_expression *const r3368 = logic_or(r3364, r3367);
               ir_if *f3363 = new(mem_ctx) ir_if(operand(r3368).val);
               exec_list *const f3363_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3363->then_instructions;

                  body.emit(assign(r3250, rshift(r335A, body.constant(int(1))), 0x01));

                  ir_expression *const r3369 = lshift(r335A, body.constant(int(31)));
                  ir_expression *const r336A = rshift(r3359, body.constant(int(1)));
                  body.emit(assign(r3251, bit_or(r3369, r336A), 0x01));

                  body.emit(assign(r3258, add(r3258, body.constant(int(1))), 0x01));


               body.instructions = f3363_parent_instructions;
               body.emit(f3363);

               /* END IF */

               ir_variable *const r336B = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r336C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r336C);
               ir_variable *const r336D = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r336D);
               ir_variable *const r336E = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r336E);
               ir_variable *const r336F = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r336F);
               body.emit(assign(r336E, body.constant(0u), 0x01));

               body.emit(assign(r336D, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r3371 = lequal(r335F, r3250);
               ir_if *f3370 = new(mem_ctx) ir_if(operand(r3371).val);
               exec_list *const f3370_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3370->then_instructions;

                  body.emit(assign(r336B, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3370->else_instructions;

                  body.emit(assign(r336F, rshift(r335F, body.constant(int(16))), 0x01));

                  ir_variable *const r3372 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3374 = lshift(r336F, body.constant(int(16)));
                  ir_expression *const r3375 = lequal(r3374, r3250);
                  ir_if *f3373 = new(mem_ctx) ir_if(operand(r3375).val);
                  exec_list *const f3373_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3373->then_instructions;

                     body.emit(assign(r3372, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3373->else_instructions;

                     ir_expression *const r3376 = expr(ir_binop_div, r3250, r336F);
                     body.emit(assign(r3372, lshift(r3376, body.constant(int(16))), 0x01));


                  body.instructions = f3373_parent_instructions;
                  body.emit(f3373);

                  /* END IF */

                  body.emit(assign(r336C, r3372, 0x01));

                  ir_variable *const r3377 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r3377);
                  ir_variable *const r3378 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r3378);
                  ir_variable *const r3379 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3379);
                  ir_variable *const r337A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r337A, bit_and(r335F, body.constant(65535u)), 0x01));

                  ir_variable *const r337B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r337B, rshift(r335F, body.constant(int(16))), 0x01));

                  ir_variable *const r337C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r337C, bit_and(r3372, body.constant(65535u)), 0x01));

                  ir_variable *const r337D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r337D, rshift(r3372, body.constant(int(16))), 0x01));

                  ir_variable *const r337E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r337E, mul(r337B, r337C), 0x01));

                  ir_expression *const r337F = mul(r337A, r337D);
                  body.emit(assign(r3378, add(r337F, r337E), 0x01));

                  ir_expression *const r3380 = mul(r337B, r337D);
                  ir_expression *const r3381 = less(r3378, r337E);
                  ir_expression *const r3382 = expr(ir_unop_b2i, r3381);
                  ir_expression *const r3383 = expr(ir_unop_i2u, r3382);
                  ir_expression *const r3384 = lshift(r3383, body.constant(int(16)));
                  ir_expression *const r3385 = rshift(r3378, body.constant(int(16)));
                  ir_expression *const r3386 = add(r3384, r3385);
                  body.emit(assign(r3377, add(r3380, r3386), 0x01));

                  body.emit(assign(r3378, lshift(r3378, body.constant(int(16))), 0x01));

                  ir_expression *const r3387 = mul(r337A, r337C);
                  body.emit(assign(r3379, add(r3387, r3378), 0x01));

                  ir_expression *const r3388 = less(r3379, r3378);
                  ir_expression *const r3389 = expr(ir_unop_b2i, r3388);
                  ir_expression *const r338A = expr(ir_unop_i2u, r3389);
                  body.emit(assign(r3377, add(r3377, r338A), 0x01));

                  ir_expression *const r338B = sub(r3250, r3377);
                  ir_expression *const r338C = less(r3251, r3379);
                  ir_expression *const r338D = expr(ir_unop_b2i, r338C);
                  ir_expression *const r338E = expr(ir_unop_i2u, r338D);
                  body.emit(assign(r336E, sub(r338B, r338E), 0x01));

                  body.emit(assign(r336D, sub(r3251, r3379), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f338F = new(mem_ctx) ir_loop();
                  exec_list *const f338F_parent_instructions = body.instructions;

                     body.instructions = &f338F->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3391 = expr(ir_unop_u2i, r336E);
                     ir_expression *const r3392 = gequal(r3391, body.constant(int(0)));
                     ir_if *f3390 = new(mem_ctx) ir_if(operand(r3392).val);
                     exec_list *const f3390_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3390->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f3390_parent_instructions;
                     body.emit(f3390);

                     /* END IF */

                     body.emit(assign(r336C, add(r336C, body.constant(4294901760u)), 0x01));

                     ir_variable *const r3393 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r3394 = lshift(r335F, body.constant(int(16)));
                     body.emit(assign(r3393, add(r336D, r3394), 0x01));

                     ir_expression *const r3395 = add(r336E, r336F);
                     ir_expression *const r3396 = less(r3393, r336D);
                     ir_expression *const r3397 = expr(ir_unop_b2i, r3396);
                     ir_expression *const r3398 = expr(ir_unop_i2u, r3397);
                     body.emit(assign(r336E, add(r3395, r3398), 0x01));

                     body.emit(assign(r336D, r3393, 0x01));

                  /* LOOP END */

                  body.instructions = f338F_parent_instructions;
                  body.emit(f338F);

                  ir_expression *const r3399 = lshift(r336E, body.constant(int(16)));
                  ir_expression *const r339A = rshift(r336D, body.constant(int(16)));
                  body.emit(assign(r336E, bit_or(r3399, r339A), 0x01));

                  ir_variable *const r339B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r339D = lshift(r336F, body.constant(int(16)));
                  ir_expression *const r339E = lequal(r339D, r336E);
                  ir_if *f339C = new(mem_ctx) ir_if(operand(r339E).val);
                  exec_list *const f339C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f339C->then_instructions;

                     body.emit(assign(r339B, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f339C->else_instructions;

                     body.emit(assign(r339B, expr(ir_binop_div, r336E, r336F), 0x01));


                  body.instructions = f339C_parent_instructions;
                  body.emit(f339C);

                  /* END IF */

                  body.emit(assign(r336C, bit_or(r336C, r339B), 0x01));

                  body.emit(assign(r336B, r336C, 0x01));


               body.instructions = f3370_parent_instructions;
               body.emit(f3370);

               /* END IF */

               body.emit(assign(r3257, r336B, 0x01));

               ir_variable *const r339F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r339F);
               ir_variable *const r33A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r33A0);
               ir_variable *const r33A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r33A1);
               ir_variable *const r33A2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r33A2, bit_and(r335E, body.constant(65535u)), 0x01));

               ir_variable *const r33A3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r33A3, rshift(r335E, body.constant(int(16))), 0x01));

               ir_variable *const r33A4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r33A4, bit_and(r336B, body.constant(65535u)), 0x01));

               ir_variable *const r33A5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r33A5, rshift(r336B, body.constant(int(16))), 0x01));

               ir_variable *const r33A6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r33A6, mul(r33A3, r33A4), 0x01));

               ir_expression *const r33A7 = mul(r33A2, r33A5);
               body.emit(assign(r33A0, add(r33A7, r33A6), 0x01));

               ir_expression *const r33A8 = mul(r33A3, r33A5);
               ir_expression *const r33A9 = less(r33A0, r33A6);
               ir_expression *const r33AA = expr(ir_unop_b2i, r33A9);
               ir_expression *const r33AB = expr(ir_unop_i2u, r33AA);
               ir_expression *const r33AC = lshift(r33AB, body.constant(int(16)));
               ir_expression *const r33AD = rshift(r33A0, body.constant(int(16)));
               ir_expression *const r33AE = add(r33AC, r33AD);
               body.emit(assign(r339F, add(r33A8, r33AE), 0x01));

               body.emit(assign(r33A0, lshift(r33A0, body.constant(int(16))), 0x01));

               ir_expression *const r33AF = mul(r33A2, r33A4);
               body.emit(assign(r33A1, add(r33AF, r33A0), 0x01));

               ir_expression *const r33B0 = less(r33A1, r33A0);
               ir_expression *const r33B1 = expr(ir_unop_b2i, r33B0);
               ir_expression *const r33B2 = expr(ir_unop_i2u, r33B1);
               body.emit(assign(r339F, add(r339F, r33B2), 0x01));

               ir_variable *const r33B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r33B3);
               ir_variable *const r33B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r33B4);
               ir_variable *const r33B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r33B5);
               ir_variable *const r33B6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r33B6, bit_and(r335F, body.constant(65535u)), 0x01));

               ir_variable *const r33B7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r33B7, rshift(r335F, body.constant(int(16))), 0x01));

               ir_variable *const r33B8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r33B8, bit_and(r336B, body.constant(65535u)), 0x01));

               ir_variable *const r33B9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r33B9, rshift(r336B, body.constant(int(16))), 0x01));

               ir_variable *const r33BA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r33BA, mul(r33B7, r33B8), 0x01));

               ir_expression *const r33BB = mul(r33B6, r33B9);
               body.emit(assign(r33B4, add(r33BB, r33BA), 0x01));

               ir_expression *const r33BC = mul(r33B7, r33B9);
               ir_expression *const r33BD = less(r33B4, r33BA);
               ir_expression *const r33BE = expr(ir_unop_b2i, r33BD);
               ir_expression *const r33BF = expr(ir_unop_i2u, r33BE);
               ir_expression *const r33C0 = lshift(r33BF, body.constant(int(16)));
               ir_expression *const r33C1 = rshift(r33B4, body.constant(int(16)));
               ir_expression *const r33C2 = add(r33C0, r33C1);
               body.emit(assign(r33B3, add(r33BC, r33C2), 0x01));

               body.emit(assign(r33B4, lshift(r33B4, body.constant(int(16))), 0x01));

               ir_expression *const r33C3 = mul(r33B6, r33B8);
               body.emit(assign(r33B5, add(r33C3, r33B4), 0x01));

               ir_expression *const r33C4 = less(r33B5, r33B4);
               ir_expression *const r33C5 = expr(ir_unop_b2i, r33C4);
               ir_expression *const r33C6 = expr(ir_unop_i2u, r33C5);
               body.emit(assign(r33B3, add(r33B3, r33C6), 0x01));

               ir_variable *const r33C7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r33C7, add(r33B5, r339F), 0x01));

               ir_variable *const r33C8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r33C8);
               ir_variable *const r33C9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r33CA = less(body.constant(0u), r33A1);
               ir_expression *const r33CB = expr(ir_unop_b2i, r33CA);
               body.emit(assign(r33C9, expr(ir_unop_i2u, r33CB), 0x01));

               ir_variable *const r33CC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r33CC, sub(r3251, r33C7), 0x01));

               ir_expression *const r33CD = less(r33C7, r33B5);
               ir_expression *const r33CE = expr(ir_unop_b2i, r33CD);
               ir_expression *const r33CF = expr(ir_unop_i2u, r33CE);
               ir_expression *const r33D0 = add(r33B3, r33CF);
               ir_expression *const r33D1 = sub(r3250, r33D0);
               ir_expression *const r33D2 = less(r33CC, r33C9);
               ir_expression *const r33D3 = expr(ir_unop_b2i, r33D2);
               ir_expression *const r33D4 = expr(ir_unop_i2u, r33D3);
               body.emit(assign(r33C8, sub(r33D1, r33D4), 0x01));

               ir_expression *const r33D5 = less(r3251, r33C7);
               ir_expression *const r33D6 = expr(ir_unop_b2i, r33D5);
               ir_expression *const r33D7 = expr(ir_unop_i2u, r33D6);
               body.emit(assign(r33C8, sub(r33C8, r33D7), 0x01));

               body.emit(assign(r3255, r33C8, 0x01));

               body.emit(assign(r3254, sub(r33CC, r33C9), 0x01));

               body.emit(assign(r3253, neg(r33A1), 0x01));

               /* LOOP BEGIN */
               ir_loop *f33D8 = new(mem_ctx) ir_loop();
               exec_list *const f33D8_parent_instructions = body.instructions;

                  body.instructions = &f33D8->body_instructions;

                  /* IF CONDITION */
                  ir_expression *const r33DA = expr(ir_unop_u2i, r3255);
                  ir_expression *const r33DB = gequal(r33DA, body.constant(int(0)));
                  ir_if *f33D9 = new(mem_ctx) ir_if(operand(r33DB).val);
                  exec_list *const f33D9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f33D9->then_instructions;

                     body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                  body.instructions = f33D9_parent_instructions;
                  body.emit(f33D9);

                  /* END IF */

                  body.emit(assign(r3257, add(r3257, body.constant(4294967295u)), 0x01));

                  ir_variable *const r33DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r33DC);
                  ir_variable *const r33DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r33DD);
                  ir_variable *const r33DE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33DE, add(r3253, r335E), 0x01));

                  ir_variable *const r33DF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r33E0 = less(r33DE, r3253);
                  ir_expression *const r33E1 = expr(ir_unop_b2i, r33E0);
                  body.emit(assign(r33DF, expr(ir_unop_i2u, r33E1), 0x01));

                  ir_variable *const r33E2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33E2, add(r3254, r335F), 0x01));

                  body.emit(assign(r33DD, add(r33E2, r33DF), 0x01));

                  ir_expression *const r33E3 = less(r33DD, r33DF);
                  ir_expression *const r33E4 = expr(ir_unop_b2i, r33E3);
                  ir_expression *const r33E5 = expr(ir_unop_i2u, r33E4);
                  body.emit(assign(r33DC, add(r3255, r33E5), 0x01));

                  ir_expression *const r33E6 = less(r33E2, r3254);
                  ir_expression *const r33E7 = expr(ir_unop_b2i, r33E6);
                  ir_expression *const r33E8 = expr(ir_unop_i2u, r33E7);
                  body.emit(assign(r33DC, add(r33DC, r33E8), 0x01));

                  body.emit(assign(r3255, r33DC, 0x01));

                  body.emit(assign(r3254, r33DD, 0x01));

                  body.emit(assign(r3253, r33DE, 0x01));

               /* LOOP END */

               body.instructions = f33D8_parent_instructions;
               body.emit(f33D8);

               ir_variable *const r33E9 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r33EA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r33EA);
               ir_variable *const r33EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r33EB);
               ir_variable *const r33EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r33EC);
               ir_variable *const r33ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r33ED);
               body.emit(assign(r33EC, body.constant(0u), 0x01));

               body.emit(assign(r33EB, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r33EF = lequal(r335F, r3254);
               ir_if *f33EE = new(mem_ctx) ir_if(operand(r33EF).val);
               exec_list *const f33EE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f33EE->then_instructions;

                  body.emit(assign(r33E9, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f33EE->else_instructions;

                  body.emit(assign(r33ED, rshift(r335F, body.constant(int(16))), 0x01));

                  ir_variable *const r33F0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r33F2 = lshift(r33ED, body.constant(int(16)));
                  ir_expression *const r33F3 = lequal(r33F2, r3254);
                  ir_if *f33F1 = new(mem_ctx) ir_if(operand(r33F3).val);
                  exec_list *const f33F1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f33F1->then_instructions;

                     body.emit(assign(r33F0, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f33F1->else_instructions;

                     ir_expression *const r33F4 = expr(ir_binop_div, r3254, r33ED);
                     body.emit(assign(r33F0, lshift(r33F4, body.constant(int(16))), 0x01));


                  body.instructions = f33F1_parent_instructions;
                  body.emit(f33F1);

                  /* END IF */

                  body.emit(assign(r33EA, r33F0, 0x01));

                  ir_variable *const r33F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r33F5);
                  ir_variable *const r33F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r33F6);
                  ir_variable *const r33F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r33F7);
                  ir_variable *const r33F8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33F8, bit_and(r335F, body.constant(65535u)), 0x01));

                  ir_variable *const r33F9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33F9, rshift(r335F, body.constant(int(16))), 0x01));

                  ir_variable *const r33FA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33FA, bit_and(r33F0, body.constant(65535u)), 0x01));

                  ir_variable *const r33FB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33FB, rshift(r33F0, body.constant(int(16))), 0x01));

                  ir_variable *const r33FC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33FC, mul(r33F9, r33FA), 0x01));

                  ir_expression *const r33FD = mul(r33F8, r33FB);
                  body.emit(assign(r33F6, add(r33FD, r33FC), 0x01));

                  ir_expression *const r33FE = mul(r33F9, r33FB);
                  ir_expression *const r33FF = less(r33F6, r33FC);
                  ir_expression *const r3400 = expr(ir_unop_b2i, r33FF);
                  ir_expression *const r3401 = expr(ir_unop_i2u, r3400);
                  ir_expression *const r3402 = lshift(r3401, body.constant(int(16)));
                  ir_expression *const r3403 = rshift(r33F6, body.constant(int(16)));
                  ir_expression *const r3404 = add(r3402, r3403);
                  body.emit(assign(r33F5, add(r33FE, r3404), 0x01));

                  body.emit(assign(r33F6, lshift(r33F6, body.constant(int(16))), 0x01));

                  ir_expression *const r3405 = mul(r33F8, r33FA);
                  body.emit(assign(r33F7, add(r3405, r33F6), 0x01));

                  ir_expression *const r3406 = less(r33F7, r33F6);
                  ir_expression *const r3407 = expr(ir_unop_b2i, r3406);
                  ir_expression *const r3408 = expr(ir_unop_i2u, r3407);
                  body.emit(assign(r33F5, add(r33F5, r3408), 0x01));

                  ir_expression *const r3409 = sub(r3254, r33F5);
                  ir_expression *const r340A = less(r3253, r33F7);
                  ir_expression *const r340B = expr(ir_unop_b2i, r340A);
                  ir_expression *const r340C = expr(ir_unop_i2u, r340B);
                  body.emit(assign(r33EC, sub(r3409, r340C), 0x01));

                  body.emit(assign(r33EB, sub(r3253, r33F7), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f340D = new(mem_ctx) ir_loop();
                  exec_list *const f340D_parent_instructions = body.instructions;

                     body.instructions = &f340D->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r340F = expr(ir_unop_u2i, r33EC);
                     ir_expression *const r3410 = gequal(r340F, body.constant(int(0)));
                     ir_if *f340E = new(mem_ctx) ir_if(operand(r3410).val);
                     exec_list *const f340E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f340E->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f340E_parent_instructions;
                     body.emit(f340E);

                     /* END IF */

                     body.emit(assign(r33EA, add(r33EA, body.constant(4294901760u)), 0x01));

                     ir_variable *const r3411 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r3412 = lshift(r335F, body.constant(int(16)));
                     body.emit(assign(r3411, add(r33EB, r3412), 0x01));

                     ir_expression *const r3413 = add(r33EC, r33ED);
                     ir_expression *const r3414 = less(r3411, r33EB);
                     ir_expression *const r3415 = expr(ir_unop_b2i, r3414);
                     ir_expression *const r3416 = expr(ir_unop_i2u, r3415);
                     body.emit(assign(r33EC, add(r3413, r3416), 0x01));

                     body.emit(assign(r33EB, r3411, 0x01));

                  /* LOOP END */

                  body.instructions = f340D_parent_instructions;
                  body.emit(f340D);

                  ir_expression *const r3417 = lshift(r33EC, body.constant(int(16)));
                  ir_expression *const r3418 = rshift(r33EB, body.constant(int(16)));
                  body.emit(assign(r33EC, bit_or(r3417, r3418), 0x01));

                  ir_variable *const r3419 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r341B = lshift(r33ED, body.constant(int(16)));
                  ir_expression *const r341C = lequal(r341B, r33EC);
                  ir_if *f341A = new(mem_ctx) ir_if(operand(r341C).val);
                  exec_list *const f341A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f341A->then_instructions;

                     body.emit(assign(r3419, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f341A->else_instructions;

                     body.emit(assign(r3419, expr(ir_binop_div, r33EC, r33ED), 0x01));


                  body.instructions = f341A_parent_instructions;
                  body.emit(f341A);

                  /* END IF */

                  body.emit(assign(r33EA, bit_or(r33EA, r3419), 0x01));

                  body.emit(assign(r33E9, r33EA, 0x01));


               body.instructions = f33EE_parent_instructions;
               body.emit(f33EE);

               /* END IF */

               body.emit(assign(r3256, r33E9, 0x01));

               /* IF CONDITION */
               ir_expression *const r341E = bit_and(r33E9, body.constant(1023u));
               ir_expression *const r341F = lequal(r341E, body.constant(4u));
               ir_if *f341D = new(mem_ctx) ir_if(operand(r341F).val);
               exec_list *const f341D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f341D->then_instructions;

                  ir_variable *const r3420 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r3420);
                  ir_variable *const r3421 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r3421);
                  ir_variable *const r3422 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3422);
                  ir_variable *const r3423 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3423, bit_and(r335E, body.constant(65535u)), 0x01));

                  ir_variable *const r3424 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3424, rshift(r335E, body.constant(int(16))), 0x01));

                  ir_variable *const r3425 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3425, bit_and(r33E9, body.constant(65535u)), 0x01));

                  ir_variable *const r3426 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3426, rshift(r33E9, body.constant(int(16))), 0x01));

                  ir_variable *const r3427 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3427, mul(r3424, r3425), 0x01));

                  ir_expression *const r3428 = mul(r3423, r3426);
                  body.emit(assign(r3421, add(r3428, r3427), 0x01));

                  ir_expression *const r3429 = mul(r3424, r3426);
                  ir_expression *const r342A = less(r3421, r3427);
                  ir_expression *const r342B = expr(ir_unop_b2i, r342A);
                  ir_expression *const r342C = expr(ir_unop_i2u, r342B);
                  ir_expression *const r342D = lshift(r342C, body.constant(int(16)));
                  ir_expression *const r342E = rshift(r3421, body.constant(int(16)));
                  ir_expression *const r342F = add(r342D, r342E);
                  body.emit(assign(r3420, add(r3429, r342F), 0x01));

                  body.emit(assign(r3421, lshift(r3421, body.constant(int(16))), 0x01));

                  ir_expression *const r3430 = mul(r3423, r3425);
                  body.emit(assign(r3422, add(r3430, r3421), 0x01));

                  ir_expression *const r3431 = less(r3422, r3421);
                  ir_expression *const r3432 = expr(ir_unop_b2i, r3431);
                  ir_expression *const r3433 = expr(ir_unop_i2u, r3432);
                  body.emit(assign(r3420, add(r3420, r3433), 0x01));

                  ir_variable *const r3434 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r3434);
                  ir_variable *const r3435 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r3435);
                  ir_variable *const r3436 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3436);
                  ir_variable *const r3437 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3437, bit_and(r335F, body.constant(65535u)), 0x01));

                  ir_variable *const r3438 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3438, rshift(r335F, body.constant(int(16))), 0x01));

                  ir_variable *const r3439 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3439, bit_and(r33E9, body.constant(65535u)), 0x01));

                  ir_variable *const r343A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r343A, rshift(r33E9, body.constant(int(16))), 0x01));

                  ir_variable *const r343B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r343B, mul(r3438, r3439), 0x01));

                  ir_expression *const r343C = mul(r3437, r343A);
                  body.emit(assign(r3435, add(r343C, r343B), 0x01));

                  ir_expression *const r343D = mul(r3438, r343A);
                  ir_expression *const r343E = less(r3435, r343B);
                  ir_expression *const r343F = expr(ir_unop_b2i, r343E);
                  ir_expression *const r3440 = expr(ir_unop_i2u, r343F);
                  ir_expression *const r3441 = lshift(r3440, body.constant(int(16)));
                  ir_expression *const r3442 = rshift(r3435, body.constant(int(16)));
                  ir_expression *const r3443 = add(r3441, r3442);
                  body.emit(assign(r3434, add(r343D, r3443), 0x01));

                  body.emit(assign(r3435, lshift(r3435, body.constant(int(16))), 0x01));

                  ir_expression *const r3444 = mul(r3437, r3439);
                  body.emit(assign(r3436, add(r3444, r3435), 0x01));

                  ir_expression *const r3445 = less(r3436, r3435);
                  ir_expression *const r3446 = expr(ir_unop_b2i, r3445);
                  ir_expression *const r3447 = expr(ir_unop_i2u, r3446);
                  body.emit(assign(r3434, add(r3434, r3447), 0x01));

                  ir_variable *const r3448 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3448, add(r3436, r3420), 0x01));

                  ir_variable *const r3449 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r3449);
                  ir_variable *const r344A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r344B = less(body.constant(0u), r3422);
                  ir_expression *const r344C = expr(ir_unop_b2i, r344B);
                  body.emit(assign(r344A, expr(ir_unop_i2u, r344C), 0x01));

                  ir_variable *const r344D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r344D, sub(r3253, r3448), 0x01));

                  ir_expression *const r344E = less(r3448, r3436);
                  ir_expression *const r344F = expr(ir_unop_b2i, r344E);
                  ir_expression *const r3450 = expr(ir_unop_i2u, r344F);
                  ir_expression *const r3451 = add(r3434, r3450);
                  ir_expression *const r3452 = sub(r3254, r3451);
                  ir_expression *const r3453 = less(r344D, r344A);
                  ir_expression *const r3454 = expr(ir_unop_b2i, r3453);
                  ir_expression *const r3455 = expr(ir_unop_i2u, r3454);
                  body.emit(assign(r3449, sub(r3452, r3455), 0x01));

                  ir_expression *const r3456 = less(r3253, r3448);
                  ir_expression *const r3457 = expr(ir_unop_b2i, r3456);
                  ir_expression *const r3458 = expr(ir_unop_i2u, r3457);
                  body.emit(assign(r3449, sub(r3449, r3458), 0x01));

                  body.emit(assign(r3254, r3449, 0x01));

                  body.emit(assign(r3253, sub(r344D, r344A), 0x01));

                  body.emit(assign(r3252, neg(r3422), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f3459 = new(mem_ctx) ir_loop();
                  exec_list *const f3459_parent_instructions = body.instructions;

                     body.instructions = &f3459->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r345B = expr(ir_unop_u2i, r3254);
                     ir_expression *const r345C = gequal(r345B, body.constant(int(0)));
                     ir_if *f345A = new(mem_ctx) ir_if(operand(r345C).val);
                     exec_list *const f345A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f345A->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f345A_parent_instructions;
                     body.emit(f345A);

                     /* END IF */

                     body.emit(assign(r3256, add(r3256, body.constant(4294967295u)), 0x01));

                     ir_variable *const r345D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r345D);
                     ir_variable *const r345E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r345E);
                     ir_variable *const r345F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r345F, add(r3252, r335E), 0x01));

                     ir_variable *const r3460 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r3461 = less(r345F, r3252);
                     ir_expression *const r3462 = expr(ir_unop_b2i, r3461);
                     body.emit(assign(r3460, expr(ir_unop_i2u, r3462), 0x01));

                     ir_variable *const r3463 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3463, add(r3253, r335F), 0x01));

                     body.emit(assign(r345E, add(r3463, r3460), 0x01));

                     ir_expression *const r3464 = less(r345E, r3460);
                     ir_expression *const r3465 = expr(ir_unop_b2i, r3464);
                     ir_expression *const r3466 = expr(ir_unop_i2u, r3465);
                     body.emit(assign(r345D, add(r3254, r3466), 0x01));

                     ir_expression *const r3467 = less(r3463, r3253);
                     ir_expression *const r3468 = expr(ir_unop_b2i, r3467);
                     ir_expression *const r3469 = expr(ir_unop_i2u, r3468);
                     body.emit(assign(r345D, add(r345D, r3469), 0x01));

                     body.emit(assign(r3254, r345D, 0x01));

                     body.emit(assign(r3253, r345E, 0x01));

                     body.emit(assign(r3252, r345F, 0x01));

                  /* LOOP END */

                  body.instructions = f3459_parent_instructions;
                  body.emit(f3459);

                  ir_expression *const r346A = bit_or(r3254, r3253);
                  ir_expression *const r346B = bit_or(r346A, r3252);
                  ir_expression *const r346C = nequal(r346B, body.constant(0u));
                  ir_expression *const r346D = expr(ir_unop_b2i, r346C);
                  ir_expression *const r346E = expr(ir_unop_i2u, r346D);
                  body.emit(assign(r3256, bit_or(r3256, r346E), 0x01));


               body.instructions = f341D_parent_instructions;
               body.emit(f341D);

               /* END IF */

               ir_variable *const r346F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r346F);
               ir_variable *const r3470 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3470);
               ir_variable *const r3471 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3471);
               body.emit(assign(r346F, lshift(r3256, body.constant(int(21))), 0x01));

               ir_expression *const r3472 = lshift(r3257, body.constant(int(21)));
               ir_expression *const r3473 = rshift(r3256, body.constant(int(11)));
               body.emit(assign(r3470, bit_or(r3472, r3473), 0x01));

               body.emit(assign(r3471, rshift(r3257, body.constant(int(11))), 0x01));

               body.emit(assign(r346F, bit_or(r346F, body.constant(0u)), 0x01));

               body.emit(assign(r3257, r3471, 0x01));

               body.emit(assign(r3256, r3470, 0x01));

               ir_variable *const r3474 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3474, r3258, 0x01));

               ir_variable *const r3475 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3475, r3471, 0x01));

               ir_variable *const r3476 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3476, r3470, 0x01));

               ir_variable *const r3477 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3477, r346F, 0x01));

               ir_variable *const r3478 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r3478, body.constant(true), 0x01));

               ir_variable *const r3479 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r347A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r347A);
               ir_expression *const r347B = expr(ir_unop_u2i, r346F);
               body.emit(assign(r347A, less(r347B, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r347D = lequal(body.constant(int(2045)), r3258);
               ir_if *f347C = new(mem_ctx) ir_if(operand(r347D).val);
               exec_list *const f347C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f347C->then_instructions;

                  ir_variable *const r347E = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3480 = less(body.constant(int(2045)), r3258);
                  ir_if *f347F = new(mem_ctx) ir_if(operand(r3480).val);
                  exec_list *const f347F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f347F->then_instructions;

                     body.emit(assign(r347E, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f347F->else_instructions;

                     ir_variable *const r3481 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3483 = equal(r3258, body.constant(int(2045)));
                     ir_if *f3482 = new(mem_ctx) ir_if(operand(r3483).val);
                     exec_list *const f3482_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3482->then_instructions;

                        ir_expression *const r3484 = equal(body.constant(2097151u), r3471);
                        ir_expression *const r3485 = equal(body.constant(4294967295u), r3470);
                        body.emit(assign(r3481, logic_and(r3484, r3485), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3482->else_instructions;

                        body.emit(assign(r3481, body.constant(false), 0x01));


                     body.instructions = f3482_parent_instructions;
                     body.emit(f3482);

                     /* END IF */

                     body.emit(assign(r347E, logic_and(r3481, r347A), 0x01));


                  body.instructions = f347F_parent_instructions;
                  body.emit(f347F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3486 = new(mem_ctx) ir_if(operand(r347E).val);
                  exec_list *const f3486_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3486->then_instructions;

                     ir_variable *const r3487 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3487);
                     ir_expression *const r3488 = lshift(r324B, body.constant(int(31)));
                     body.emit(assign(r3487, add(r3488, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3487, body.constant(0u), 0x01));

                     body.emit(assign(r3479, r3487, 0x03));

                     body.emit(assign(r3478, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3486->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r348A = less(r3258, body.constant(int(0)));
                     ir_if *f3489 = new(mem_ctx) ir_if(operand(r348A).val);
                     exec_list *const f3489_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3489->then_instructions;

                        ir_variable *const r348B = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r348B, r346F, 0x01));

                        ir_variable *const r348C = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r348C, neg(r3258), 0x01));

                        ir_variable *const r348D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r348D);
                        ir_variable *const r348E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r348E);
                        ir_variable *const r348F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r348F);
                        ir_variable *const r3490 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3491 = neg(r348C);
                        body.emit(assign(r3490, bit_and(r3491, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3493 = equal(r348C, body.constant(int(0)));
                        ir_if *f3492 = new(mem_ctx) ir_if(operand(r3493).val);
                        exec_list *const f3492_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3492->then_instructions;

                           body.emit(assign(r348D, r346F, 0x01));

                           body.emit(assign(r348E, r3470, 0x01));

                           body.emit(assign(r348F, r3471, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3492->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3495 = less(r348C, body.constant(int(32)));
                           ir_if *f3494 = new(mem_ctx) ir_if(operand(r3495).val);
                           exec_list *const f3494_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3494->then_instructions;

                              body.emit(assign(r348D, lshift(r3470, r3490), 0x01));

                              ir_expression *const r3496 = lshift(r3471, r3490);
                              ir_expression *const r3497 = rshift(r3470, r348C);
                              body.emit(assign(r348E, bit_or(r3496, r3497), 0x01));

                              body.emit(assign(r348F, rshift(r3471, r348C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3494->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3499 = equal(r348C, body.constant(int(32)));
                              ir_if *f3498 = new(mem_ctx) ir_if(operand(r3499).val);
                              exec_list *const f3498_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3498->then_instructions;

                                 body.emit(assign(r348D, r3470, 0x01));

                                 body.emit(assign(r348E, r3471, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3498->else_instructions;

                                 body.emit(assign(r348B, bit_or(r346F, r3470), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r349B = less(r348C, body.constant(int(64)));
                                 ir_if *f349A = new(mem_ctx) ir_if(operand(r349B).val);
                                 exec_list *const f349A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f349A->then_instructions;

                                    body.emit(assign(r348D, lshift(r3471, r3490), 0x01));

                                    ir_expression *const r349C = bit_and(r348C, body.constant(int(31)));
                                    body.emit(assign(r348E, rshift(r3471, r349C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f349A->else_instructions;

                                    ir_variable *const r349D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r349F = equal(r348C, body.constant(int(64)));
                                    ir_if *f349E = new(mem_ctx) ir_if(operand(r349F).val);
                                    exec_list *const f349E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f349E->then_instructions;

                                       body.emit(assign(r349D, r3471, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f349E->else_instructions;

                                       ir_expression *const r34A0 = nequal(r3471, body.constant(0u));
                                       ir_expression *const r34A1 = expr(ir_unop_b2i, r34A0);
                                       body.emit(assign(r349D, expr(ir_unop_i2u, r34A1), 0x01));


                                    body.instructions = f349E_parent_instructions;
                                    body.emit(f349E);

                                    /* END IF */

                                    body.emit(assign(r348D, r349D, 0x01));

                                    body.emit(assign(r348E, body.constant(0u), 0x01));


                                 body.instructions = f349A_parent_instructions;
                                 body.emit(f349A);

                                 /* END IF */


                              body.instructions = f3498_parent_instructions;
                              body.emit(f3498);

                              /* END IF */

                              body.emit(assign(r348F, body.constant(0u), 0x01));


                           body.instructions = f3494_parent_instructions;
                           body.emit(f3494);

                           /* END IF */

                           ir_expression *const r34A2 = nequal(r348B, body.constant(0u));
                           ir_expression *const r34A3 = expr(ir_unop_b2i, r34A2);
                           ir_expression *const r34A4 = expr(ir_unop_i2u, r34A3);
                           body.emit(assign(r348D, bit_or(r348D, r34A4), 0x01));


                        body.instructions = f3492_parent_instructions;
                        body.emit(f3492);

                        /* END IF */

                        body.emit(assign(r3475, r348F, 0x01));

                        body.emit(assign(r3476, r348E, 0x01));

                        body.emit(assign(r3477, r348D, 0x01));

                        body.emit(assign(r3474, body.constant(int(0)), 0x01));

                        body.emit(assign(r347A, less(r348D, body.constant(0u)), 0x01));


                     body.instructions = f3489_parent_instructions;
                     body.emit(f3489);

                     /* END IF */


                  body.instructions = f3486_parent_instructions;
                  body.emit(f3486);

                  /* END IF */


               body.instructions = f347C_parent_instructions;
               body.emit(f347C);

               /* END IF */

               /* IF CONDITION */
               ir_if *f34A5 = new(mem_ctx) ir_if(operand(r3478).val);
               exec_list *const f34A5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f34A5->then_instructions;

                  /* IF CONDITION */
                  ir_if *f34A6 = new(mem_ctx) ir_if(operand(r347A).val);
                  exec_list *const f34A6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f34A6->then_instructions;

                     ir_variable *const r34A7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r34A7, add(r3476, body.constant(1u)), 0x01));

                     ir_expression *const r34A8 = less(r34A7, r3476);
                     ir_expression *const r34A9 = expr(ir_unop_b2i, r34A8);
                     ir_expression *const r34AA = expr(ir_unop_i2u, r34A9);
                     body.emit(assign(r3475, add(r3475, r34AA), 0x01));

                     ir_expression *const r34AB = equal(r3477, body.constant(0u));
                     ir_expression *const r34AC = expr(ir_unop_b2i, r34AB);
                     ir_expression *const r34AD = expr(ir_unop_i2u, r34AC);
                     ir_expression *const r34AE = add(r3477, r34AD);
                     ir_expression *const r34AF = bit_and(r34AE, body.constant(1u));
                     ir_expression *const r34B0 = expr(ir_unop_bit_not, r34AF);
                     body.emit(assign(r3476, bit_and(r34A7, r34B0), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f34A6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r34B2 = bit_or(r3475, r3476);
                     ir_expression *const r34B3 = equal(r34B2, body.constant(0u));
                     ir_if *f34B1 = new(mem_ctx) ir_if(operand(r34B3).val);
                     exec_list *const f34B1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f34B1->then_instructions;

                        body.emit(assign(r3474, body.constant(int(0)), 0x01));


                     body.instructions = f34B1_parent_instructions;
                     body.emit(f34B1);

                     /* END IF */


                  body.instructions = f34A6_parent_instructions;
                  body.emit(f34A6);

                  /* END IF */

                  ir_variable *const r34B4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r34B4);
                  ir_expression *const r34B5 = lshift(r324B, body.constant(int(31)));
                  ir_expression *const r34B6 = expr(ir_unop_i2u, r3474);
                  ir_expression *const r34B7 = lshift(r34B6, body.constant(int(20)));
                  ir_expression *const r34B8 = add(r34B5, r34B7);
                  body.emit(assign(r34B4, add(r34B8, r3475), 0x02));

                  body.emit(assign(r34B4, r3476, 0x01));

                  body.emit(assign(r3479, r34B4, 0x03));

                  body.emit(assign(r3478, body.constant(false), 0x01));


               body.instructions = f34A5_parent_instructions;
               body.emit(f34A5);

               /* END IF */

               body.emit(assign(r324A, r3479, 0x03));

               body.emit(assign(r3249, body.constant(false), 0x01));


            body.instructions = f3357_parent_instructions;
            body.emit(f3357);

            /* END IF */


         body.instructions = f3316_parent_instructions;
         body.emit(f3316);

         /* END IF */


      body.instructions = f32AC_parent_instructions;
      body.emit(f32AC);

      /* END IF */


   body.instructions = f3265_parent_instructions;
   body.emit(f3265);

   /* END IF */

   ir_variable *const r34B9 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r34BA = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r34BB = rshift(swizzle_y(r324A), body.constant(int(20)));
   ir_expression *const r34BC = bit_and(r34BB, body.constant(2047u));
   ir_expression *const r34BD = expr(ir_unop_u2i, r34BC);
   body.emit(assign(r34BA, add(r34BD, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r34BF = less(r34BA, body.constant(int(0)));
   ir_if *f34BE = new(mem_ctx) ir_if(operand(r34BF).val);
   exec_list *const f34BE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f34BE->then_instructions;

      body.emit(assign(r34B9, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f34BE->else_instructions;

      /* IF CONDITION */
      ir_expression *const r34C1 = greater(r34BA, body.constant(int(52)));
      ir_if *f34C0 = new(mem_ctx) ir_if(operand(r34C1).val);
      exec_list *const f34C0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f34C0->then_instructions;

         body.emit(assign(r34B9, r324A, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f34C0->else_instructions;

         ir_variable *const r34C2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r34C2, sub(body.constant(int(52)), r34BA), 0x01));

         ir_variable *const r34C3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r34C5 = gequal(r34C2, body.constant(int(32)));
         ir_if *f34C4 = new(mem_ctx) ir_if(operand(r34C5).val);
         exec_list *const f34C4_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f34C4->then_instructions;

            body.emit(assign(r34C3, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f34C4->else_instructions;

            body.emit(assign(r34C3, lshift(body.constant(4294967295u), r34C2), 0x01));


         body.instructions = f34C4_parent_instructions;
         body.emit(f34C4);

         /* END IF */

         ir_variable *const r34C6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r34C8 = less(r34C2, body.constant(int(33)));
         ir_if *f34C7 = new(mem_ctx) ir_if(operand(r34C8).val);
         exec_list *const f34C7_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f34C7->then_instructions;

            body.emit(assign(r34C6, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f34C7->else_instructions;

            ir_expression *const r34C9 = add(r34C2, body.constant(int(-32)));
            body.emit(assign(r34C6, lshift(body.constant(4294967295u), r34C9), 0x01));


         body.instructions = f34C7_parent_instructions;
         body.emit(f34C7);

         /* END IF */

         ir_variable *const r34CA = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r34CA, bit_and(r34C3, swizzle_x(r324A)), 0x01));

         body.emit(assign(r34CA, bit_and(r34C6, swizzle_y(r324A)), 0x02));

         body.emit(assign(r34B9, r34CA, 0x03));


      body.instructions = f34C0_parent_instructions;
      body.emit(f34C0);

      /* END IF */


   body.instructions = f34BE_parent_instructions;
   body.emit(f34BE);

   /* END IF */

   ir_variable *const r34CB = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r34CC = rshift(swizzle_y(r324A), body.constant(int(31)));
   ir_expression *const r34CD = expr(ir_unop_u2i, r34CC);
   body.emit(assign(r34CB, expr(ir_unop_i2b, r34CD), 0x01));

   ir_variable *const r34CE = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r34D0 = expr(ir_unop_logic_not, r34CB);
   ir_if *f34CF = new(mem_ctx) ir_if(operand(r34D0).val);
   exec_list *const f34CF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f34CF->then_instructions;

      body.emit(assign(r34CE, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f34CF->else_instructions;

      ir_variable *const r34D1 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r34D2 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r34D2);
      ir_variable *const r34D3 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r34D3);
      ir_expression *const r34D4 = rshift(swizzle_y(r324A), body.constant(int(20)));
      ir_expression *const r34D5 = bit_and(r34D4, body.constant(2047u));
      ir_expression *const r34D6 = expr(ir_unop_u2i, r34D5);
      ir_expression *const r34D7 = equal(r34D6, body.constant(int(2047)));
      ir_expression *const r34D8 = bit_and(swizzle_y(r324A), body.constant(1048575u));
      ir_expression *const r34D9 = bit_or(r34D8, swizzle_x(r324A));
      ir_expression *const r34DA = nequal(r34D9, body.constant(0u));
      body.emit(assign(r34D3, logic_and(r34D7, r34DA), 0x01));

      ir_expression *const r34DB = rshift(swizzle_y(r34B9), body.constant(int(20)));
      ir_expression *const r34DC = bit_and(r34DB, body.constant(2047u));
      ir_expression *const r34DD = expr(ir_unop_u2i, r34DC);
      ir_expression *const r34DE = equal(r34DD, body.constant(int(2047)));
      ir_expression *const r34DF = bit_and(swizzle_y(r34B9), body.constant(1048575u));
      ir_expression *const r34E0 = bit_or(r34DF, swizzle_x(r34B9));
      ir_expression *const r34E1 = nequal(r34E0, body.constant(0u));
      body.emit(assign(r34D2, logic_and(r34DE, r34E1), 0x01));

      /* IF CONDITION */
      ir_expression *const r34E3 = logic_or(r34D3, r34D2);
      ir_if *f34E2 = new(mem_ctx) ir_if(operand(r34E3).val);
      exec_list *const f34E2_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f34E2->then_instructions;

         body.emit(assign(r34D1, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f34E2->else_instructions;

         ir_expression *const r34E4 = equal(swizzle_x(r324A), swizzle_x(r34B9));
         ir_expression *const r34E5 = equal(swizzle_y(r324A), swizzle_y(r34B9));
         ir_expression *const r34E6 = equal(swizzle_x(r324A), body.constant(0u));
         ir_expression *const r34E7 = bit_or(swizzle_y(r324A), swizzle_y(r34B9));
         ir_expression *const r34E8 = lshift(r34E7, body.constant(int(1)));
         ir_expression *const r34E9 = equal(r34E8, body.constant(0u));
         ir_expression *const r34EA = logic_and(r34E6, r34E9);
         ir_expression *const r34EB = logic_or(r34E5, r34EA);
         body.emit(assign(r34D1, logic_and(r34E4, r34EB), 0x01));


      body.instructions = f34E2_parent_instructions;
      body.emit(f34E2);

      /* END IF */

      body.emit(assign(r34CE, r34D1, 0x01));


   body.instructions = f34CF_parent_instructions;
   body.emit(f34CF);

   /* END IF */

   ir_variable *const r34EC = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f34ED = new(mem_ctx) ir_if(operand(r34CE).val);
   exec_list *const f34ED_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f34ED->then_instructions;

      body.emit(assign(r34EC, r34B9, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f34ED->else_instructions;

      ir_variable *const r34EE = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r34EF = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r34EF, rshift(swizzle_y(r34B9), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r34F1 = equal(r34EF, body.constant(0u));
      ir_if *f34F0 = new(mem_ctx) ir_if(operand(r34F1).val);
      exec_list *const f34F0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f34F0->then_instructions;

         ir_variable *const r34F2 = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r34F2, r34EF, 0x01));

         ir_variable *const r34F3 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r34F4 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r34F4);
         ir_variable *const r34F5 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r34F5);
         ir_variable *const r34F6 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r34F6);
         ir_variable *const r34F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r34F7);
         ir_variable *const r34F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r34F8);
         ir_variable *const r34F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r34F9);
         ir_variable *const r34FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r34FA);
         ir_variable *const r34FB = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r34FB);
         ir_variable *const r34FC = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r34FC, body.constant(0u), 0x01));

         ir_variable *const r34FD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r34FE = rshift(swizzle_y(r34B9), body.constant(int(20)));
         ir_expression *const r34FF = bit_and(r34FE, body.constant(2047u));
         body.emit(assign(r34FD, expr(ir_unop_u2i, r34FF), 0x01));

         body.emit(assign(r34F6, r34FD, 0x01));

         body.emit(assign(r34F5, body.constant(int(1023)), 0x01));

         body.emit(assign(r34F4, add(r34FD, body.constant(int(-1023))), 0x01));

         ir_variable *const r3500 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r3500, lshift(swizzle_x(r34B9), body.constant(int(10))), 0x01));

         ir_variable *const r3501 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r3502 = bit_and(swizzle_y(r34B9), body.constant(1048575u));
         ir_expression *const r3503 = lshift(r3502, body.constant(int(10)));
         ir_expression *const r3504 = rshift(swizzle_x(r34B9), body.constant(int(22)));
         body.emit(assign(r3501, bit_or(r3503, r3504), 0x01));

         body.emit(assign(r34F9, r3501, 0x01));

         body.emit(assign(r34FA, r3500, 0x01));

         ir_variable *const r3505 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r3505, body.constant(0u), 0x01));

         ir_variable *const r3506 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r3506, body.constant(0u), 0x01));

         body.emit(assign(r34F7, r3506, 0x01));

         body.emit(assign(r34F8, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r3508 = less(body.constant(int(0)), r34F4);
         ir_if *f3507 = new(mem_ctx) ir_if(operand(r3508).val);
         exec_list *const f3507_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3507->then_instructions;

            /* IF CONDITION */
            ir_expression *const r350A = equal(r34FD, body.constant(int(2047)));
            ir_if *f3509 = new(mem_ctx) ir_if(operand(r350A).val);
            exec_list *const f3509_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3509->then_instructions;

               /* IF CONDITION */
               ir_expression *const r350C = bit_or(r3501, r3500);
               ir_expression *const r350D = nequal(r350C, body.constant(0u));
               ir_if *f350B = new(mem_ctx) ir_if(operand(r350D).val);
               exec_list *const f350B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f350B->then_instructions;

                  ir_variable *const r350E = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r350E, swizzle_x(r34B9), 0x01));

                  ir_variable *const r350F = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r350F, body.constant(0u), 0x01));

                  ir_variable *const r3510 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r350E, bit_or(swizzle_y(r34B9), body.constant(524288u)), 0x02));

                  body.emit(assign(r350F, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r3512 = lshift(swizzle_y(r34B9), body.constant(int(1)));
                  ir_expression *const r3513 = lequal(body.constant(4292870144u), r3512);
                  ir_expression *const r3514 = nequal(swizzle_x(r34B9), body.constant(0u));
                  ir_expression *const r3515 = bit_and(swizzle_y(r34B9), body.constant(1048575u));
                  ir_expression *const r3516 = nequal(r3515, body.constant(0u));
                  ir_expression *const r3517 = logic_or(r3514, r3516);
                  ir_expression *const r3518 = logic_and(r3513, r3517);
                  ir_if *f3511 = new(mem_ctx) ir_if(operand(r3518).val);
                  exec_list *const f3511_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3511->then_instructions;

                     body.emit(assign(r3510, r350E, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3511->else_instructions;

                     body.emit(assign(r3510, r350F, 0x03));


                  body.instructions = f3511_parent_instructions;
                  body.emit(f3511);

                  /* END IF */

                  body.emit(assign(r34F3, r3510, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f350B->else_instructions;

                  body.emit(assign(r34F3, r34B9, 0x03));


               body.instructions = f350B_parent_instructions;
               body.emit(f350B);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3509->else_instructions;

               body.emit(assign(r34F7, body.constant(1073741824u), 0x01));

               ir_variable *const r3519 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3519);
               ir_variable *const r351A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r351A);
               ir_variable *const r351B = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r351C = neg(r34F4);
               body.emit(assign(r351B, bit_and(r351C, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r351E = equal(r34F4, body.constant(int(0)));
               ir_if *f351D = new(mem_ctx) ir_if(operand(r351E).val);
               exec_list *const f351D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f351D->then_instructions;

                  body.emit(assign(r3519, body.constant(0u), 0x01));

                  body.emit(assign(r351A, r34F7, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f351D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3520 = less(r34F4, body.constant(int(32)));
                  ir_if *f351F = new(mem_ctx) ir_if(operand(r3520).val);
                  exec_list *const f351F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f351F->then_instructions;

                     ir_expression *const r3521 = lshift(body.constant(1073741824u), r351B);
                     ir_expression *const r3522 = bit_or(r3521, body.constant(0u));
                     body.emit(assign(r3519, bit_or(r3522, body.constant(0u)), 0x01));

                     body.emit(assign(r351A, rshift(body.constant(1073741824u), r34F4), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f351F->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3524 = equal(r34F4, body.constant(int(32)));
                     ir_if *f3523 = new(mem_ctx) ir_if(operand(r3524).val);
                     exec_list *const f3523_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3523->then_instructions;

                        body.emit(assign(r3519, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3523->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3526 = less(r34F4, body.constant(int(64)));
                        ir_if *f3525 = new(mem_ctx) ir_if(operand(r3526).val);
                        exec_list *const f3525_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3525->then_instructions;

                           ir_expression *const r3527 = bit_and(r34F4, body.constant(int(31)));
                           ir_expression *const r3528 = rshift(body.constant(1073741824u), r3527);
                           ir_expression *const r3529 = lshift(body.constant(1073741824u), r351B);
                           ir_expression *const r352A = bit_or(r3529, body.constant(0u));
                           ir_expression *const r352B = nequal(r352A, body.constant(0u));
                           ir_expression *const r352C = expr(ir_unop_b2i, r352B);
                           ir_expression *const r352D = expr(ir_unop_i2u, r352C);
                           body.emit(assign(r3519, bit_or(r3528, r352D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3525->else_instructions;

                           body.emit(assign(r3519, body.constant(1u), 0x01));


                        body.instructions = f3525_parent_instructions;
                        body.emit(f3525);

                        /* END IF */


                     body.instructions = f3523_parent_instructions;
                     body.emit(f3523);

                     /* END IF */

                     body.emit(assign(r351A, body.constant(0u), 0x01));


                  body.instructions = f351F_parent_instructions;
                  body.emit(f351F);

                  /* END IF */


               body.instructions = f351D_parent_instructions;
               body.emit(f351D);

               /* END IF */

               body.emit(assign(r34F7, r351A, 0x01));

               body.emit(assign(r34F8, r3519, 0x01));

               body.emit(assign(r34F9, bit_or(r3501, body.constant(1073741824u)), 0x01));

               ir_variable *const r352E = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r352F = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r352F, sub(r3500, r3519), 0x01));

               ir_expression *const r3530 = sub(r34F9, r351A);
               ir_expression *const r3531 = less(r3500, r3519);
               ir_expression *const r3532 = expr(ir_unop_b2i, r3531);
               ir_expression *const r3533 = expr(ir_unop_i2u, r3532);
               body.emit(assign(r352E, sub(r3530, r3533), 0x01));

               body.emit(assign(r34FB, add(r34FD, body.constant(int(-1))), 0x01));

               ir_variable *const r3534 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3534, add(r34FB, body.constant(int(-10))), 0x01));

               ir_variable *const r3535 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3535, r352E, 0x01));

               ir_variable *const r3536 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3536, r352F, 0x01));

               ir_variable *const r3537 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r3537);
               ir_variable *const r3538 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3538);
               /* IF CONDITION */
               ir_expression *const r353A = equal(r352E, body.constant(0u));
               ir_if *f3539 = new(mem_ctx) ir_if(operand(r353A).val);
               exec_list *const f3539_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3539->then_instructions;

                  body.emit(assign(r3535, r352F, 0x01));

                  body.emit(assign(r3536, body.constant(0u), 0x01));

                  body.emit(assign(r3534, add(r3534, body.constant(int(-32))), 0x01));


               body.instructions = f3539_parent_instructions;
               body.emit(f3539);

               /* END IF */

               ir_variable *const r353B = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r353B, r3535, 0x01));

               ir_variable *const r353C = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r353D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r353D);
               /* IF CONDITION */
               ir_expression *const r353F = equal(r3535, body.constant(0u));
               ir_if *f353E = new(mem_ctx) ir_if(operand(r353F).val);
               exec_list *const f353E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f353E->then_instructions;

                  body.emit(assign(r353C, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f353E->else_instructions;

                  body.emit(assign(r353D, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3541 = bit_and(r3535, body.constant(4294901760u));
                  ir_expression *const r3542 = equal(r3541, body.constant(0u));
                  ir_if *f3540 = new(mem_ctx) ir_if(operand(r3542).val);
                  exec_list *const f3540_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3540->then_instructions;

                     body.emit(assign(r353D, body.constant(int(16)), 0x01));

                     body.emit(assign(r353B, lshift(r3535, body.constant(int(16))), 0x01));


                  body.instructions = f3540_parent_instructions;
                  body.emit(f3540);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3544 = bit_and(r353B, body.constant(4278190080u));
                  ir_expression *const r3545 = equal(r3544, body.constant(0u));
                  ir_if *f3543 = new(mem_ctx) ir_if(operand(r3545).val);
                  exec_list *const f3543_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3543->then_instructions;

                     body.emit(assign(r353D, add(r353D, body.constant(int(8))), 0x01));

                     body.emit(assign(r353B, lshift(r353B, body.constant(int(8))), 0x01));


                  body.instructions = f3543_parent_instructions;
                  body.emit(f3543);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3547 = bit_and(r353B, body.constant(4026531840u));
                  ir_expression *const r3548 = equal(r3547, body.constant(0u));
                  ir_if *f3546 = new(mem_ctx) ir_if(operand(r3548).val);
                  exec_list *const f3546_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3546->then_instructions;

                     body.emit(assign(r353D, add(r353D, body.constant(int(4))), 0x01));

                     body.emit(assign(r353B, lshift(r353B, body.constant(int(4))), 0x01));


                  body.instructions = f3546_parent_instructions;
                  body.emit(f3546);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r354A = bit_and(r353B, body.constant(3221225472u));
                  ir_expression *const r354B = equal(r354A, body.constant(0u));
                  ir_if *f3549 = new(mem_ctx) ir_if(operand(r354B).val);
                  exec_list *const f3549_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3549->then_instructions;

                     body.emit(assign(r353D, add(r353D, body.constant(int(2))), 0x01));

                     body.emit(assign(r353B, lshift(r353B, body.constant(int(2))), 0x01));


                  body.instructions = f3549_parent_instructions;
                  body.emit(f3549);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r354D = bit_and(r353B, body.constant(2147483648u));
                  ir_expression *const r354E = equal(r354D, body.constant(0u));
                  ir_if *f354C = new(mem_ctx) ir_if(operand(r354E).val);
                  exec_list *const f354C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f354C->then_instructions;

                     body.emit(assign(r353D, add(r353D, body.constant(int(1))), 0x01));


                  body.instructions = f354C_parent_instructions;
                  body.emit(f354C);

                  /* END IF */

                  body.emit(assign(r353C, r353D, 0x01));


               body.instructions = f353E_parent_instructions;
               body.emit(f353E);

               /* END IF */

               body.emit(assign(r3538, add(r353C, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3550 = lequal(body.constant(int(0)), r3538);
               ir_if *f354F = new(mem_ctx) ir_if(operand(r3550).val);
               exec_list *const f354F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f354F->then_instructions;

                  body.emit(assign(r3537, body.constant(0u), 0x01));

                  ir_variable *const r3551 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3551, lshift(r3536, r3538), 0x01));

                  ir_variable *const r3552 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3554 = equal(r3538, body.constant(int(0)));
                  ir_if *f3553 = new(mem_ctx) ir_if(operand(r3554).val);
                  exec_list *const f3553_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3553->then_instructions;

                     body.emit(assign(r3552, r3535, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3553->else_instructions;

                     ir_expression *const r3555 = lshift(r3535, r3538);
                     ir_expression *const r3556 = neg(r3538);
                     ir_expression *const r3557 = bit_and(r3556, body.constant(int(31)));
                     ir_expression *const r3558 = rshift(r3536, r3557);
                     body.emit(assign(r3552, bit_or(r3555, r3558), 0x01));


                  body.instructions = f3553_parent_instructions;
                  body.emit(f3553);

                  /* END IF */

                  body.emit(assign(r3535, r3552, 0x01));

                  body.emit(assign(r3536, r3551, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f354F->else_instructions;

                  ir_variable *const r3559 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r3559, body.constant(0u), 0x01));

                  ir_variable *const r355A = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r355A, neg(r3538), 0x01));

                  ir_variable *const r355B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r355B);
                  ir_variable *const r355C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r355C);
                  ir_variable *const r355D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r355D);
                  ir_variable *const r355E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r355F = neg(r355A);
                  body.emit(assign(r355E, bit_and(r355F, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3561 = equal(r355A, body.constant(int(0)));
                  ir_if *f3560 = new(mem_ctx) ir_if(operand(r3561).val);
                  exec_list *const f3560_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3560->then_instructions;

                     body.emit(assign(r355B, r3559, 0x01));

                     body.emit(assign(r355C, r3536, 0x01));

                     body.emit(assign(r355D, r3535, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3560->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3563 = less(r355A, body.constant(int(32)));
                     ir_if *f3562 = new(mem_ctx) ir_if(operand(r3563).val);
                     exec_list *const f3562_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3562->then_instructions;

                        body.emit(assign(r355B, lshift(r3536, r355E), 0x01));

                        ir_expression *const r3564 = lshift(r3535, r355E);
                        ir_expression *const r3565 = rshift(r3536, r355A);
                        body.emit(assign(r355C, bit_or(r3564, r3565), 0x01));

                        body.emit(assign(r355D, rshift(r3535, r355A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3562->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3567 = equal(r355A, body.constant(int(32)));
                        ir_if *f3566 = new(mem_ctx) ir_if(operand(r3567).val);
                        exec_list *const f3566_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3566->then_instructions;

                           body.emit(assign(r355B, r3536, 0x01));

                           body.emit(assign(r355C, r3535, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3566->else_instructions;

                           body.emit(assign(r3559, bit_or(body.constant(0u), r3536), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3569 = less(r355A, body.constant(int(64)));
                           ir_if *f3568 = new(mem_ctx) ir_if(operand(r3569).val);
                           exec_list *const f3568_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3568->then_instructions;

                              body.emit(assign(r355B, lshift(r3535, r355E), 0x01));

                              ir_expression *const r356A = bit_and(r355A, body.constant(int(31)));
                              body.emit(assign(r355C, rshift(r3535, r356A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3568->else_instructions;

                              ir_variable *const r356B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r356D = equal(r355A, body.constant(int(64)));
                              ir_if *f356C = new(mem_ctx) ir_if(operand(r356D).val);
                              exec_list *const f356C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f356C->then_instructions;

                                 body.emit(assign(r356B, r3535, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f356C->else_instructions;

                                 ir_expression *const r356E = nequal(r3535, body.constant(0u));
                                 ir_expression *const r356F = expr(ir_unop_b2i, r356E);
                                 body.emit(assign(r356B, expr(ir_unop_i2u, r356F), 0x01));


                              body.instructions = f356C_parent_instructions;
                              body.emit(f356C);

                              /* END IF */

                              body.emit(assign(r355B, r356B, 0x01));

                              body.emit(assign(r355C, body.constant(0u), 0x01));


                           body.instructions = f3568_parent_instructions;
                           body.emit(f3568);

                           /* END IF */


                        body.instructions = f3566_parent_instructions;
                        body.emit(f3566);

                        /* END IF */

                        body.emit(assign(r355D, body.constant(0u), 0x01));


                     body.instructions = f3562_parent_instructions;
                     body.emit(f3562);

                     /* END IF */

                     ir_expression *const r3570 = nequal(r3559, body.constant(0u));
                     ir_expression *const r3571 = expr(ir_unop_b2i, r3570);
                     ir_expression *const r3572 = expr(ir_unop_i2u, r3571);
                     body.emit(assign(r355B, bit_or(r355B, r3572), 0x01));


                  body.instructions = f3560_parent_instructions;
                  body.emit(f3560);

                  /* END IF */

                  body.emit(assign(r3535, r355D, 0x01));

                  body.emit(assign(r3536, r355C, 0x01));

                  body.emit(assign(r3537, r355B, 0x01));


               body.instructions = f354F_parent_instructions;
               body.emit(f354F);

               /* END IF */

               body.emit(assign(r3534, sub(r3534, r3538), 0x01));

               ir_variable *const r3573 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3573, r3534, 0x01));

               ir_variable *const r3574 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3574, r3535, 0x01));

               ir_variable *const r3575 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3575, r3536, 0x01));

               ir_variable *const r3576 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3576, r3537, 0x01));

               ir_variable *const r3577 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r3577, body.constant(true), 0x01));

               ir_variable *const r3578 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3579 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3579);
               ir_expression *const r357A = expr(ir_unop_u2i, r3537);
               body.emit(assign(r3579, less(r357A, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r357C = lequal(body.constant(int(2045)), r3534);
               ir_if *f357B = new(mem_ctx) ir_if(operand(r357C).val);
               exec_list *const f357B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f357B->then_instructions;

                  ir_variable *const r357D = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r357F = less(body.constant(int(2045)), r3534);
                  ir_if *f357E = new(mem_ctx) ir_if(operand(r357F).val);
                  exec_list *const f357E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f357E->then_instructions;

                     body.emit(assign(r357D, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f357E->else_instructions;

                     ir_variable *const r3580 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3582 = equal(r3534, body.constant(int(2045)));
                     ir_if *f3581 = new(mem_ctx) ir_if(operand(r3582).val);
                     exec_list *const f3581_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3581->then_instructions;

                        ir_expression *const r3583 = equal(body.constant(2097151u), r3535);
                        ir_expression *const r3584 = equal(body.constant(4294967295u), r3536);
                        body.emit(assign(r3580, logic_and(r3583, r3584), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3581->else_instructions;

                        body.emit(assign(r3580, body.constant(false), 0x01));


                     body.instructions = f3581_parent_instructions;
                     body.emit(f3581);

                     /* END IF */

                     body.emit(assign(r357D, logic_and(r3580, r3579), 0x01));


                  body.instructions = f357E_parent_instructions;
                  body.emit(f357E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3585 = new(mem_ctx) ir_if(operand(r357D).val);
                  exec_list *const f3585_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3585->then_instructions;

                     ir_variable *const r3586 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3586);
                     ir_expression *const r3587 = lshift(r34EF, body.constant(int(31)));
                     body.emit(assign(r3586, add(r3587, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3586, body.constant(0u), 0x01));

                     body.emit(assign(r3578, r3586, 0x03));

                     body.emit(assign(r3577, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3585->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3589 = less(r3534, body.constant(int(0)));
                     ir_if *f3588 = new(mem_ctx) ir_if(operand(r3589).val);
                     exec_list *const f3588_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3588->then_instructions;

                        ir_variable *const r358A = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r358A, r3537, 0x01));

                        ir_variable *const r358B = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r358B, neg(r3534), 0x01));

                        ir_variable *const r358C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r358C);
                        ir_variable *const r358D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r358D);
                        ir_variable *const r358E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r358E);
                        ir_variable *const r358F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3590 = neg(r358B);
                        body.emit(assign(r358F, bit_and(r3590, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3592 = equal(r358B, body.constant(int(0)));
                        ir_if *f3591 = new(mem_ctx) ir_if(operand(r3592).val);
                        exec_list *const f3591_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3591->then_instructions;

                           body.emit(assign(r358C, r3537, 0x01));

                           body.emit(assign(r358D, r3536, 0x01));

                           body.emit(assign(r358E, r3535, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3591->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3594 = less(r358B, body.constant(int(32)));
                           ir_if *f3593 = new(mem_ctx) ir_if(operand(r3594).val);
                           exec_list *const f3593_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3593->then_instructions;

                              body.emit(assign(r358C, lshift(r3536, r358F), 0x01));

                              ir_expression *const r3595 = lshift(r3535, r358F);
                              ir_expression *const r3596 = rshift(r3536, r358B);
                              body.emit(assign(r358D, bit_or(r3595, r3596), 0x01));

                              body.emit(assign(r358E, rshift(r3535, r358B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3593->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3598 = equal(r358B, body.constant(int(32)));
                              ir_if *f3597 = new(mem_ctx) ir_if(operand(r3598).val);
                              exec_list *const f3597_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3597->then_instructions;

                                 body.emit(assign(r358C, r3536, 0x01));

                                 body.emit(assign(r358D, r3535, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3597->else_instructions;

                                 body.emit(assign(r358A, bit_or(r3537, r3536), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r359A = less(r358B, body.constant(int(64)));
                                 ir_if *f3599 = new(mem_ctx) ir_if(operand(r359A).val);
                                 exec_list *const f3599_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3599->then_instructions;

                                    body.emit(assign(r358C, lshift(r3535, r358F), 0x01));

                                    ir_expression *const r359B = bit_and(r358B, body.constant(int(31)));
                                    body.emit(assign(r358D, rshift(r3535, r359B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3599->else_instructions;

                                    ir_variable *const r359C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r359E = equal(r358B, body.constant(int(64)));
                                    ir_if *f359D = new(mem_ctx) ir_if(operand(r359E).val);
                                    exec_list *const f359D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f359D->then_instructions;

                                       body.emit(assign(r359C, r3535, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f359D->else_instructions;

                                       ir_expression *const r359F = nequal(r3535, body.constant(0u));
                                       ir_expression *const r35A0 = expr(ir_unop_b2i, r359F);
                                       body.emit(assign(r359C, expr(ir_unop_i2u, r35A0), 0x01));


                                    body.instructions = f359D_parent_instructions;
                                    body.emit(f359D);

                                    /* END IF */

                                    body.emit(assign(r358C, r359C, 0x01));

                                    body.emit(assign(r358D, body.constant(0u), 0x01));


                                 body.instructions = f3599_parent_instructions;
                                 body.emit(f3599);

                                 /* END IF */


                              body.instructions = f3597_parent_instructions;
                              body.emit(f3597);

                              /* END IF */

                              body.emit(assign(r358E, body.constant(0u), 0x01));


                           body.instructions = f3593_parent_instructions;
                           body.emit(f3593);

                           /* END IF */

                           ir_expression *const r35A1 = nequal(r358A, body.constant(0u));
                           ir_expression *const r35A2 = expr(ir_unop_b2i, r35A1);
                           ir_expression *const r35A3 = expr(ir_unop_i2u, r35A2);
                           body.emit(assign(r358C, bit_or(r358C, r35A3), 0x01));


                        body.instructions = f3591_parent_instructions;
                        body.emit(f3591);

                        /* END IF */

                        body.emit(assign(r3574, r358E, 0x01));

                        body.emit(assign(r3575, r358D, 0x01));

                        body.emit(assign(r3576, r358C, 0x01));

                        body.emit(assign(r3573, body.constant(int(0)), 0x01));

                        body.emit(assign(r3579, less(r358C, body.constant(0u)), 0x01));


                     body.instructions = f3588_parent_instructions;
                     body.emit(f3588);

                     /* END IF */


                  body.instructions = f3585_parent_instructions;
                  body.emit(f3585);

                  /* END IF */


               body.instructions = f357B_parent_instructions;
               body.emit(f357B);

               /* END IF */

               /* IF CONDITION */
               ir_if *f35A4 = new(mem_ctx) ir_if(operand(r3577).val);
               exec_list *const f35A4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f35A4->then_instructions;

                  /* IF CONDITION */
                  ir_if *f35A5 = new(mem_ctx) ir_if(operand(r3579).val);
                  exec_list *const f35A5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35A5->then_instructions;

                     ir_variable *const r35A6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r35A6, add(r3575, body.constant(1u)), 0x01));

                     ir_expression *const r35A7 = less(r35A6, r3575);
                     ir_expression *const r35A8 = expr(ir_unop_b2i, r35A7);
                     ir_expression *const r35A9 = expr(ir_unop_i2u, r35A8);
                     body.emit(assign(r3574, add(r3574, r35A9), 0x01));

                     ir_expression *const r35AA = equal(r3576, body.constant(0u));
                     ir_expression *const r35AB = expr(ir_unop_b2i, r35AA);
                     ir_expression *const r35AC = expr(ir_unop_i2u, r35AB);
                     ir_expression *const r35AD = add(r3576, r35AC);
                     ir_expression *const r35AE = bit_and(r35AD, body.constant(1u));
                     ir_expression *const r35AF = expr(ir_unop_bit_not, r35AE);
                     body.emit(assign(r3575, bit_and(r35A6, r35AF), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f35A5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r35B1 = bit_or(r3574, r3575);
                     ir_expression *const r35B2 = equal(r35B1, body.constant(0u));
                     ir_if *f35B0 = new(mem_ctx) ir_if(operand(r35B2).val);
                     exec_list *const f35B0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f35B0->then_instructions;

                        body.emit(assign(r3573, body.constant(int(0)), 0x01));


                     body.instructions = f35B0_parent_instructions;
                     body.emit(f35B0);

                     /* END IF */


                  body.instructions = f35A5_parent_instructions;
                  body.emit(f35A5);

                  /* END IF */

                  ir_variable *const r35B3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r35B3);
                  ir_expression *const r35B4 = lshift(r34EF, body.constant(int(31)));
                  ir_expression *const r35B5 = expr(ir_unop_i2u, r3573);
                  ir_expression *const r35B6 = lshift(r35B5, body.constant(int(20)));
                  ir_expression *const r35B7 = add(r35B4, r35B6);
                  body.emit(assign(r35B3, add(r35B7, r3574), 0x02));

                  body.emit(assign(r35B3, r3575, 0x01));

                  body.emit(assign(r3578, r35B3, 0x03));

                  body.emit(assign(r3577, body.constant(false), 0x01));


               body.instructions = f35A4_parent_instructions;
               body.emit(f35A4);

               /* END IF */

               body.emit(assign(r34F3, r3578, 0x03));


            body.instructions = f3509_parent_instructions;
            body.emit(f3509);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3507->else_instructions;

            /* IF CONDITION */
            ir_expression *const r35B9 = less(r34F4, body.constant(int(0)));
            ir_if *f35B8 = new(mem_ctx) ir_if(operand(r35B9).val);
            exec_list *const f35B8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f35B8->then_instructions;

               /* IF CONDITION */
               ir_expression *const r35BB = equal(r34FD, body.constant(int(0)));
               ir_if *f35BA = new(mem_ctx) ir_if(operand(r35BB).val);
               exec_list *const f35BA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f35BA->then_instructions;

                  body.emit(assign(r34F4, add(r34F4, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f35BA->else_instructions;

                  body.emit(assign(r34F9, bit_or(r34F9, body.constant(1073741824u)), 0x01));


               body.instructions = f35BA_parent_instructions;
               body.emit(f35BA);

               /* END IF */

               ir_variable *const r35BC = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r35BC, neg(r34F4), 0x01));

               ir_variable *const r35BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r35BD);
               ir_variable *const r35BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r35BE);
               ir_variable *const r35BF = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r35C0 = neg(r35BC);
               body.emit(assign(r35BF, bit_and(r35C0, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r35C2 = equal(r35BC, body.constant(int(0)));
               ir_if *f35C1 = new(mem_ctx) ir_if(operand(r35C2).val);
               exec_list *const f35C1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f35C1->then_instructions;

                  body.emit(assign(r35BD, r3500, 0x01));

                  body.emit(assign(r35BE, r34F9, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f35C1->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r35C4 = less(r35BC, body.constant(int(32)));
                  ir_if *f35C3 = new(mem_ctx) ir_if(operand(r35C4).val);
                  exec_list *const f35C3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35C3->then_instructions;

                     ir_expression *const r35C5 = lshift(r34F9, r35BF);
                     ir_expression *const r35C6 = rshift(r3500, r35BC);
                     ir_expression *const r35C7 = bit_or(r35C5, r35C6);
                     ir_expression *const r35C8 = lshift(r3500, r35BF);
                     ir_expression *const r35C9 = nequal(r35C8, body.constant(0u));
                     ir_expression *const r35CA = expr(ir_unop_b2i, r35C9);
                     ir_expression *const r35CB = expr(ir_unop_i2u, r35CA);
                     body.emit(assign(r35BD, bit_or(r35C7, r35CB), 0x01));

                     body.emit(assign(r35BE, rshift(r34F9, r35BC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f35C3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r35CD = equal(r35BC, body.constant(int(32)));
                     ir_if *f35CC = new(mem_ctx) ir_if(operand(r35CD).val);
                     exec_list *const f35CC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f35CC->then_instructions;

                        ir_expression *const r35CE = nequal(r3500, body.constant(0u));
                        ir_expression *const r35CF = expr(ir_unop_b2i, r35CE);
                        ir_expression *const r35D0 = expr(ir_unop_i2u, r35CF);
                        body.emit(assign(r35BD, bit_or(r34F9, r35D0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f35CC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r35D2 = less(r35BC, body.constant(int(64)));
                        ir_if *f35D1 = new(mem_ctx) ir_if(operand(r35D2).val);
                        exec_list *const f35D1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f35D1->then_instructions;

                           ir_expression *const r35D3 = bit_and(r35BC, body.constant(int(31)));
                           ir_expression *const r35D4 = rshift(r34F9, r35D3);
                           ir_expression *const r35D5 = lshift(r34F9, r35BF);
                           ir_expression *const r35D6 = bit_or(r35D5, r3500);
                           ir_expression *const r35D7 = nequal(r35D6, body.constant(0u));
                           ir_expression *const r35D8 = expr(ir_unop_b2i, r35D7);
                           ir_expression *const r35D9 = expr(ir_unop_i2u, r35D8);
                           body.emit(assign(r35BD, bit_or(r35D4, r35D9), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f35D1->else_instructions;

                           ir_expression *const r35DA = bit_or(r34F9, r3500);
                           ir_expression *const r35DB = nequal(r35DA, body.constant(0u));
                           ir_expression *const r35DC = expr(ir_unop_b2i, r35DB);
                           body.emit(assign(r35BD, expr(ir_unop_i2u, r35DC), 0x01));


                        body.instructions = f35D1_parent_instructions;
                        body.emit(f35D1);

                        /* END IF */


                     body.instructions = f35CC_parent_instructions;
                     body.emit(f35CC);

                     /* END IF */

                     body.emit(assign(r35BE, body.constant(0u), 0x01));


                  body.instructions = f35C3_parent_instructions;
                  body.emit(f35C3);

                  /* END IF */


               body.instructions = f35C1_parent_instructions;
               body.emit(f35C1);

               /* END IF */

               body.emit(assign(r34F9, r35BE, 0x01));

               body.emit(assign(r34FA, r35BD, 0x01));

               body.emit(assign(r34F7, bit_or(r34F7, body.constant(1073741824u)), 0x01));

               ir_variable *const r35DD = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r35DE = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r35DE, sub(r34F8, r35BD), 0x01));

               ir_expression *const r35DF = sub(r34F7, r35BE);
               ir_expression *const r35E0 = less(r34F8, r35BD);
               ir_expression *const r35E1 = expr(ir_unop_b2i, r35E0);
               ir_expression *const r35E2 = expr(ir_unop_i2u, r35E1);
               body.emit(assign(r35DD, sub(r35DF, r35E2), 0x01));

               body.emit(assign(r34F2, bit_xor(r34EF, body.constant(1u)), 0x01));

               body.emit(assign(r34FB, body.constant(int(1022)), 0x01));

               ir_variable *const r35E3 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r35E3, body.constant(int(1012)), 0x01));

               ir_variable *const r35E4 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r35E4, r35DD, 0x01));

               ir_variable *const r35E5 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r35E5, r35DE, 0x01));

               ir_variable *const r35E6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r35E6);
               ir_variable *const r35E7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r35E7);
               /* IF CONDITION */
               ir_expression *const r35E9 = equal(r35DD, body.constant(0u));
               ir_if *f35E8 = new(mem_ctx) ir_if(operand(r35E9).val);
               exec_list *const f35E8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f35E8->then_instructions;

                  body.emit(assign(r35E4, r35DE, 0x01));

                  body.emit(assign(r35E5, body.constant(0u), 0x01));

                  body.emit(assign(r35E3, body.constant(int(980)), 0x01));


               body.instructions = f35E8_parent_instructions;
               body.emit(f35E8);

               /* END IF */

               ir_variable *const r35EA = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r35EA, r35E4, 0x01));

               ir_variable *const r35EB = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r35EC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r35EC);
               /* IF CONDITION */
               ir_expression *const r35EE = equal(r35E4, body.constant(0u));
               ir_if *f35ED = new(mem_ctx) ir_if(operand(r35EE).val);
               exec_list *const f35ED_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f35ED->then_instructions;

                  body.emit(assign(r35EB, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f35ED->else_instructions;

                  body.emit(assign(r35EC, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r35F0 = bit_and(r35E4, body.constant(4294901760u));
                  ir_expression *const r35F1 = equal(r35F0, body.constant(0u));
                  ir_if *f35EF = new(mem_ctx) ir_if(operand(r35F1).val);
                  exec_list *const f35EF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35EF->then_instructions;

                     body.emit(assign(r35EC, body.constant(int(16)), 0x01));

                     body.emit(assign(r35EA, lshift(r35E4, body.constant(int(16))), 0x01));


                  body.instructions = f35EF_parent_instructions;
                  body.emit(f35EF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r35F3 = bit_and(r35EA, body.constant(4278190080u));
                  ir_expression *const r35F4 = equal(r35F3, body.constant(0u));
                  ir_if *f35F2 = new(mem_ctx) ir_if(operand(r35F4).val);
                  exec_list *const f35F2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35F2->then_instructions;

                     body.emit(assign(r35EC, add(r35EC, body.constant(int(8))), 0x01));

                     body.emit(assign(r35EA, lshift(r35EA, body.constant(int(8))), 0x01));


                  body.instructions = f35F2_parent_instructions;
                  body.emit(f35F2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r35F6 = bit_and(r35EA, body.constant(4026531840u));
                  ir_expression *const r35F7 = equal(r35F6, body.constant(0u));
                  ir_if *f35F5 = new(mem_ctx) ir_if(operand(r35F7).val);
                  exec_list *const f35F5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35F5->then_instructions;

                     body.emit(assign(r35EC, add(r35EC, body.constant(int(4))), 0x01));

                     body.emit(assign(r35EA, lshift(r35EA, body.constant(int(4))), 0x01));


                  body.instructions = f35F5_parent_instructions;
                  body.emit(f35F5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r35F9 = bit_and(r35EA, body.constant(3221225472u));
                  ir_expression *const r35FA = equal(r35F9, body.constant(0u));
                  ir_if *f35F8 = new(mem_ctx) ir_if(operand(r35FA).val);
                  exec_list *const f35F8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35F8->then_instructions;

                     body.emit(assign(r35EC, add(r35EC, body.constant(int(2))), 0x01));

                     body.emit(assign(r35EA, lshift(r35EA, body.constant(int(2))), 0x01));


                  body.instructions = f35F8_parent_instructions;
                  body.emit(f35F8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r35FC = bit_and(r35EA, body.constant(2147483648u));
                  ir_expression *const r35FD = equal(r35FC, body.constant(0u));
                  ir_if *f35FB = new(mem_ctx) ir_if(operand(r35FD).val);
                  exec_list *const f35FB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35FB->then_instructions;

                     body.emit(assign(r35EC, add(r35EC, body.constant(int(1))), 0x01));


                  body.instructions = f35FB_parent_instructions;
                  body.emit(f35FB);

                  /* END IF */

                  body.emit(assign(r35EB, r35EC, 0x01));


               body.instructions = f35ED_parent_instructions;
               body.emit(f35ED);

               /* END IF */

               body.emit(assign(r35E7, add(r35EB, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r35FF = lequal(body.constant(int(0)), r35E7);
               ir_if *f35FE = new(mem_ctx) ir_if(operand(r35FF).val);
               exec_list *const f35FE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f35FE->then_instructions;

                  body.emit(assign(r35E6, body.constant(0u), 0x01));

                  ir_variable *const r3600 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3600, lshift(r35E5, r35E7), 0x01));

                  ir_variable *const r3601 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3603 = equal(r35E7, body.constant(int(0)));
                  ir_if *f3602 = new(mem_ctx) ir_if(operand(r3603).val);
                  exec_list *const f3602_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3602->then_instructions;

                     body.emit(assign(r3601, r35E4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3602->else_instructions;

                     ir_expression *const r3604 = lshift(r35E4, r35E7);
                     ir_expression *const r3605 = neg(r35E7);
                     ir_expression *const r3606 = bit_and(r3605, body.constant(int(31)));
                     ir_expression *const r3607 = rshift(r35E5, r3606);
                     body.emit(assign(r3601, bit_or(r3604, r3607), 0x01));


                  body.instructions = f3602_parent_instructions;
                  body.emit(f3602);

                  /* END IF */

                  body.emit(assign(r35E4, r3601, 0x01));

                  body.emit(assign(r35E5, r3600, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f35FE->else_instructions;

                  ir_variable *const r3608 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r3608, body.constant(0u), 0x01));

                  ir_variable *const r3609 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r3609, neg(r35E7), 0x01));

                  ir_variable *const r360A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r360A);
                  ir_variable *const r360B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r360B);
                  ir_variable *const r360C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r360C);
                  ir_variable *const r360D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r360E = neg(r3609);
                  body.emit(assign(r360D, bit_and(r360E, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3610 = equal(r3609, body.constant(int(0)));
                  ir_if *f360F = new(mem_ctx) ir_if(operand(r3610).val);
                  exec_list *const f360F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f360F->then_instructions;

                     body.emit(assign(r360A, r3608, 0x01));

                     body.emit(assign(r360B, r35E5, 0x01));

                     body.emit(assign(r360C, r35E4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f360F->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3612 = less(r3609, body.constant(int(32)));
                     ir_if *f3611 = new(mem_ctx) ir_if(operand(r3612).val);
                     exec_list *const f3611_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3611->then_instructions;

                        body.emit(assign(r360A, lshift(r35E5, r360D), 0x01));

                        ir_expression *const r3613 = lshift(r35E4, r360D);
                        ir_expression *const r3614 = rshift(r35E5, r3609);
                        body.emit(assign(r360B, bit_or(r3613, r3614), 0x01));

                        body.emit(assign(r360C, rshift(r35E4, r3609), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3611->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3616 = equal(r3609, body.constant(int(32)));
                        ir_if *f3615 = new(mem_ctx) ir_if(operand(r3616).val);
                        exec_list *const f3615_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3615->then_instructions;

                           body.emit(assign(r360A, r35E5, 0x01));

                           body.emit(assign(r360B, r35E4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3615->else_instructions;

                           body.emit(assign(r3608, bit_or(body.constant(0u), r35E5), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3618 = less(r3609, body.constant(int(64)));
                           ir_if *f3617 = new(mem_ctx) ir_if(operand(r3618).val);
                           exec_list *const f3617_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3617->then_instructions;

                              body.emit(assign(r360A, lshift(r35E4, r360D), 0x01));

                              ir_expression *const r3619 = bit_and(r3609, body.constant(int(31)));
                              body.emit(assign(r360B, rshift(r35E4, r3619), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3617->else_instructions;

                              ir_variable *const r361A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r361C = equal(r3609, body.constant(int(64)));
                              ir_if *f361B = new(mem_ctx) ir_if(operand(r361C).val);
                              exec_list *const f361B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f361B->then_instructions;

                                 body.emit(assign(r361A, r35E4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f361B->else_instructions;

                                 ir_expression *const r361D = nequal(r35E4, body.constant(0u));
                                 ir_expression *const r361E = expr(ir_unop_b2i, r361D);
                                 body.emit(assign(r361A, expr(ir_unop_i2u, r361E), 0x01));


                              body.instructions = f361B_parent_instructions;
                              body.emit(f361B);

                              /* END IF */

                              body.emit(assign(r360A, r361A, 0x01));

                              body.emit(assign(r360B, body.constant(0u), 0x01));


                           body.instructions = f3617_parent_instructions;
                           body.emit(f3617);

                           /* END IF */


                        body.instructions = f3615_parent_instructions;
                        body.emit(f3615);

                        /* END IF */

                        body.emit(assign(r360C, body.constant(0u), 0x01));


                     body.instructions = f3611_parent_instructions;
                     body.emit(f3611);

                     /* END IF */

                     ir_expression *const r361F = nequal(r3608, body.constant(0u));
                     ir_expression *const r3620 = expr(ir_unop_b2i, r361F);
                     ir_expression *const r3621 = expr(ir_unop_i2u, r3620);
                     body.emit(assign(r360A, bit_or(r360A, r3621), 0x01));


                  body.instructions = f360F_parent_instructions;
                  body.emit(f360F);

                  /* END IF */

                  body.emit(assign(r35E4, r360C, 0x01));

                  body.emit(assign(r35E5, r360B, 0x01));

                  body.emit(assign(r35E6, r360A, 0x01));


               body.instructions = f35FE_parent_instructions;
               body.emit(f35FE);

               /* END IF */

               body.emit(assign(r35E3, sub(r35E3, r35E7), 0x01));

               ir_variable *const r3622 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3622, r35E3, 0x01));

               ir_variable *const r3623 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3623, r35E4, 0x01));

               ir_variable *const r3624 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3624, r35E5, 0x01));

               ir_variable *const r3625 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3625, r35E6, 0x01));

               ir_variable *const r3626 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r3626, body.constant(true), 0x01));

               ir_variable *const r3627 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3628 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3628);
               ir_expression *const r3629 = expr(ir_unop_u2i, r35E6);
               body.emit(assign(r3628, less(r3629, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r362B = lequal(body.constant(int(2045)), r35E3);
               ir_if *f362A = new(mem_ctx) ir_if(operand(r362B).val);
               exec_list *const f362A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f362A->then_instructions;

                  ir_variable *const r362C = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r362E = less(body.constant(int(2045)), r35E3);
                  ir_if *f362D = new(mem_ctx) ir_if(operand(r362E).val);
                  exec_list *const f362D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f362D->then_instructions;

                     body.emit(assign(r362C, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f362D->else_instructions;

                     ir_variable *const r362F = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3631 = equal(r35E3, body.constant(int(2045)));
                     ir_if *f3630 = new(mem_ctx) ir_if(operand(r3631).val);
                     exec_list *const f3630_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3630->then_instructions;

                        ir_expression *const r3632 = equal(body.constant(2097151u), r35E4);
                        ir_expression *const r3633 = equal(body.constant(4294967295u), r35E5);
                        body.emit(assign(r362F, logic_and(r3632, r3633), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3630->else_instructions;

                        body.emit(assign(r362F, body.constant(false), 0x01));


                     body.instructions = f3630_parent_instructions;
                     body.emit(f3630);

                     /* END IF */

                     body.emit(assign(r362C, logic_and(r362F, r3628), 0x01));


                  body.instructions = f362D_parent_instructions;
                  body.emit(f362D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3634 = new(mem_ctx) ir_if(operand(r362C).val);
                  exec_list *const f3634_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3634->then_instructions;

                     ir_variable *const r3635 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3635);
                     ir_expression *const r3636 = lshift(r34F2, body.constant(int(31)));
                     body.emit(assign(r3635, add(r3636, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3635, body.constant(0u), 0x01));

                     body.emit(assign(r3627, r3635, 0x03));

                     body.emit(assign(r3626, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3634->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3638 = less(r35E3, body.constant(int(0)));
                     ir_if *f3637 = new(mem_ctx) ir_if(operand(r3638).val);
                     exec_list *const f3637_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3637->then_instructions;

                        ir_variable *const r3639 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3639, r35E6, 0x01));

                        ir_variable *const r363A = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r363A, neg(r35E3), 0x01));

                        ir_variable *const r363B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r363B);
                        ir_variable *const r363C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r363C);
                        ir_variable *const r363D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r363D);
                        ir_variable *const r363E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r363F = neg(r363A);
                        body.emit(assign(r363E, bit_and(r363F, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3641 = equal(r363A, body.constant(int(0)));
                        ir_if *f3640 = new(mem_ctx) ir_if(operand(r3641).val);
                        exec_list *const f3640_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3640->then_instructions;

                           body.emit(assign(r363B, r35E6, 0x01));

                           body.emit(assign(r363C, r35E5, 0x01));

                           body.emit(assign(r363D, r35E4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3640->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3643 = less(r363A, body.constant(int(32)));
                           ir_if *f3642 = new(mem_ctx) ir_if(operand(r3643).val);
                           exec_list *const f3642_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3642->then_instructions;

                              body.emit(assign(r363B, lshift(r35E5, r363E), 0x01));

                              ir_expression *const r3644 = lshift(r35E4, r363E);
                              ir_expression *const r3645 = rshift(r35E5, r363A);
                              body.emit(assign(r363C, bit_or(r3644, r3645), 0x01));

                              body.emit(assign(r363D, rshift(r35E4, r363A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3642->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3647 = equal(r363A, body.constant(int(32)));
                              ir_if *f3646 = new(mem_ctx) ir_if(operand(r3647).val);
                              exec_list *const f3646_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3646->then_instructions;

                                 body.emit(assign(r363B, r35E5, 0x01));

                                 body.emit(assign(r363C, r35E4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3646->else_instructions;

                                 body.emit(assign(r3639, bit_or(r35E6, r35E5), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3649 = less(r363A, body.constant(int(64)));
                                 ir_if *f3648 = new(mem_ctx) ir_if(operand(r3649).val);
                                 exec_list *const f3648_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3648->then_instructions;

                                    body.emit(assign(r363B, lshift(r35E4, r363E), 0x01));

                                    ir_expression *const r364A = bit_and(r363A, body.constant(int(31)));
                                    body.emit(assign(r363C, rshift(r35E4, r364A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3648->else_instructions;

                                    ir_variable *const r364B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r364D = equal(r363A, body.constant(int(64)));
                                    ir_if *f364C = new(mem_ctx) ir_if(operand(r364D).val);
                                    exec_list *const f364C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f364C->then_instructions;

                                       body.emit(assign(r364B, r35E4, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f364C->else_instructions;

                                       ir_expression *const r364E = nequal(r35E4, body.constant(0u));
                                       ir_expression *const r364F = expr(ir_unop_b2i, r364E);
                                       body.emit(assign(r364B, expr(ir_unop_i2u, r364F), 0x01));


                                    body.instructions = f364C_parent_instructions;
                                    body.emit(f364C);

                                    /* END IF */

                                    body.emit(assign(r363B, r364B, 0x01));

                                    body.emit(assign(r363C, body.constant(0u), 0x01));


                                 body.instructions = f3648_parent_instructions;
                                 body.emit(f3648);

                                 /* END IF */


                              body.instructions = f3646_parent_instructions;
                              body.emit(f3646);

                              /* END IF */

                              body.emit(assign(r363D, body.constant(0u), 0x01));


                           body.instructions = f3642_parent_instructions;
                           body.emit(f3642);

                           /* END IF */

                           ir_expression *const r3650 = nequal(r3639, body.constant(0u));
                           ir_expression *const r3651 = expr(ir_unop_b2i, r3650);
                           ir_expression *const r3652 = expr(ir_unop_i2u, r3651);
                           body.emit(assign(r363B, bit_or(r363B, r3652), 0x01));


                        body.instructions = f3640_parent_instructions;
                        body.emit(f3640);

                        /* END IF */

                        body.emit(assign(r3623, r363D, 0x01));

                        body.emit(assign(r3624, r363C, 0x01));

                        body.emit(assign(r3625, r363B, 0x01));

                        body.emit(assign(r3622, body.constant(int(0)), 0x01));

                        body.emit(assign(r3628, less(r363B, body.constant(0u)), 0x01));


                     body.instructions = f3637_parent_instructions;
                     body.emit(f3637);

                     /* END IF */


                  body.instructions = f3634_parent_instructions;
                  body.emit(f3634);

                  /* END IF */


               body.instructions = f362A_parent_instructions;
               body.emit(f362A);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3653 = new(mem_ctx) ir_if(operand(r3626).val);
               exec_list *const f3653_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3653->then_instructions;

                  /* IF CONDITION */
                  ir_if *f3654 = new(mem_ctx) ir_if(operand(r3628).val);
                  exec_list *const f3654_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3654->then_instructions;

                     ir_variable *const r3655 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3655, add(r3624, body.constant(1u)), 0x01));

                     ir_expression *const r3656 = less(r3655, r3624);
                     ir_expression *const r3657 = expr(ir_unop_b2i, r3656);
                     ir_expression *const r3658 = expr(ir_unop_i2u, r3657);
                     body.emit(assign(r3623, add(r3623, r3658), 0x01));

                     ir_expression *const r3659 = equal(r3625, body.constant(0u));
                     ir_expression *const r365A = expr(ir_unop_b2i, r3659);
                     ir_expression *const r365B = expr(ir_unop_i2u, r365A);
                     ir_expression *const r365C = add(r3625, r365B);
                     ir_expression *const r365D = bit_and(r365C, body.constant(1u));
                     ir_expression *const r365E = expr(ir_unop_bit_not, r365D);
                     body.emit(assign(r3624, bit_and(r3655, r365E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3654->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3660 = bit_or(r3623, r3624);
                     ir_expression *const r3661 = equal(r3660, body.constant(0u));
                     ir_if *f365F = new(mem_ctx) ir_if(operand(r3661).val);
                     exec_list *const f365F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f365F->then_instructions;

                        body.emit(assign(r3622, body.constant(int(0)), 0x01));


                     body.instructions = f365F_parent_instructions;
                     body.emit(f365F);

                     /* END IF */


                  body.instructions = f3654_parent_instructions;
                  body.emit(f3654);

                  /* END IF */

                  ir_variable *const r3662 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3662);
                  ir_expression *const r3663 = lshift(r34F2, body.constant(int(31)));
                  ir_expression *const r3664 = expr(ir_unop_i2u, r3622);
                  ir_expression *const r3665 = lshift(r3664, body.constant(int(20)));
                  ir_expression *const r3666 = add(r3663, r3665);
                  body.emit(assign(r3662, add(r3666, r3623), 0x02));

                  body.emit(assign(r3662, r3624, 0x01));

                  body.emit(assign(r3627, r3662, 0x03));

                  body.emit(assign(r3626, body.constant(false), 0x01));


               body.instructions = f3653_parent_instructions;
               body.emit(f3653);

               /* END IF */

               body.emit(assign(r34F3, r3627, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f35B8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3668 = equal(r34FD, body.constant(int(2047)));
               ir_if *f3667 = new(mem_ctx) ir_if(operand(r3668).val);
               exec_list *const f3667_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3667->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r366A = bit_or(r34F9, r34FA);
                  ir_expression *const r366B = bit_or(r34F7, r34F8);
                  ir_expression *const r366C = bit_or(r366A, r366B);
                  ir_expression *const r366D = nequal(r366C, body.constant(0u));
                  ir_if *f3669 = new(mem_ctx) ir_if(operand(r366D).val);
                  exec_list *const f3669_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3669->then_instructions;

                     ir_variable *const r366E = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r366E, swizzle_x(r34B9), 0x01));

                     ir_variable *const r366F = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r366F, body.constant(0u), 0x01));

                     ir_variable *const r3670 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r366E, bit_or(swizzle_y(r34B9), body.constant(524288u)), 0x02));

                     body.emit(assign(r366F, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r3672 = lshift(swizzle_y(r34B9), body.constant(int(1)));
                     ir_expression *const r3673 = lequal(body.constant(4292870144u), r3672);
                     ir_expression *const r3674 = nequal(swizzle_x(r34B9), body.constant(0u));
                     ir_expression *const r3675 = bit_and(swizzle_y(r34B9), body.constant(1048575u));
                     ir_expression *const r3676 = nequal(r3675, body.constant(0u));
                     ir_expression *const r3677 = logic_or(r3674, r3676);
                     ir_expression *const r3678 = logic_and(r3673, r3677);
                     ir_if *f3671 = new(mem_ctx) ir_if(operand(r3678).val);
                     exec_list *const f3671_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3671->then_instructions;

                        body.emit(assign(r3670, r366E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3671->else_instructions;

                        body.emit(assign(r3670, r366F, 0x03));


                     body.instructions = f3671_parent_instructions;
                     body.emit(f3671);

                     /* END IF */

                     body.emit(assign(r34F3, r3670, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3669->else_instructions;

                     ir_constant_data r3679_data;
                     memset(&r3679_data, 0, sizeof(ir_constant_data));
                     r3679_data.u[0] = 4294967295;
                     r3679_data.u[1] = 4294967295;
                     ir_constant *const r3679 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3679_data);
                     body.emit(assign(r34F3, r3679, 0x03));


                  body.instructions = f3669_parent_instructions;
                  body.emit(f3669);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3667->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r367B = equal(r34FD, body.constant(int(0)));
                  ir_if *f367A = new(mem_ctx) ir_if(operand(r367B).val);
                  exec_list *const f367A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f367A->then_instructions;

                     body.emit(assign(r34F6, body.constant(int(1)), 0x01));

                     body.emit(assign(r34F5, body.constant(int(1)), 0x01));


                  body.instructions = f367A_parent_instructions;
                  body.emit(f367A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r367D = less(r34F7, r34F9);
                  ir_if *f367C = new(mem_ctx) ir_if(operand(r367D).val);
                  exec_list *const f367C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f367C->then_instructions;

                     ir_variable *const r367E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r367F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r367F, sub(r34FA, r34F8), 0x01));

                     ir_expression *const r3680 = sub(r34F9, r34F7);
                     ir_expression *const r3681 = less(r34FA, r34F8);
                     ir_expression *const r3682 = expr(ir_unop_b2i, r3681);
                     ir_expression *const r3683 = expr(ir_unop_i2u, r3682);
                     body.emit(assign(r367E, sub(r3680, r3683), 0x01));

                     body.emit(assign(r34FB, add(r34F6, body.constant(int(-1))), 0x01));

                     ir_variable *const r3684 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r3684, add(r34FB, body.constant(int(-10))), 0x01));

                     ir_variable *const r3685 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r3685, r367E, 0x01));

                     ir_variable *const r3686 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r3686, r367F, 0x01));

                     ir_variable *const r3687 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r3687);
                     ir_variable *const r3688 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3688);
                     /* IF CONDITION */
                     ir_expression *const r368A = equal(r367E, body.constant(0u));
                     ir_if *f3689 = new(mem_ctx) ir_if(operand(r368A).val);
                     exec_list *const f3689_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3689->then_instructions;

                        body.emit(assign(r3685, r367F, 0x01));

                        body.emit(assign(r3686, body.constant(0u), 0x01));

                        body.emit(assign(r3684, add(r3684, body.constant(int(-32))), 0x01));


                     body.instructions = f3689_parent_instructions;
                     body.emit(f3689);

                     /* END IF */

                     ir_variable *const r368B = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r368B, r3685, 0x01));

                     ir_variable *const r368C = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r368D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r368D);
                     /* IF CONDITION */
                     ir_expression *const r368F = equal(r3685, body.constant(0u));
                     ir_if *f368E = new(mem_ctx) ir_if(operand(r368F).val);
                     exec_list *const f368E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f368E->then_instructions;

                        body.emit(assign(r368C, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f368E->else_instructions;

                        body.emit(assign(r368D, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3691 = bit_and(r3685, body.constant(4294901760u));
                        ir_expression *const r3692 = equal(r3691, body.constant(0u));
                        ir_if *f3690 = new(mem_ctx) ir_if(operand(r3692).val);
                        exec_list *const f3690_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3690->then_instructions;

                           body.emit(assign(r368D, body.constant(int(16)), 0x01));

                           body.emit(assign(r368B, lshift(r3685, body.constant(int(16))), 0x01));


                        body.instructions = f3690_parent_instructions;
                        body.emit(f3690);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3694 = bit_and(r368B, body.constant(4278190080u));
                        ir_expression *const r3695 = equal(r3694, body.constant(0u));
                        ir_if *f3693 = new(mem_ctx) ir_if(operand(r3695).val);
                        exec_list *const f3693_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3693->then_instructions;

                           body.emit(assign(r368D, add(r368D, body.constant(int(8))), 0x01));

                           body.emit(assign(r368B, lshift(r368B, body.constant(int(8))), 0x01));


                        body.instructions = f3693_parent_instructions;
                        body.emit(f3693);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3697 = bit_and(r368B, body.constant(4026531840u));
                        ir_expression *const r3698 = equal(r3697, body.constant(0u));
                        ir_if *f3696 = new(mem_ctx) ir_if(operand(r3698).val);
                        exec_list *const f3696_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3696->then_instructions;

                           body.emit(assign(r368D, add(r368D, body.constant(int(4))), 0x01));

                           body.emit(assign(r368B, lshift(r368B, body.constant(int(4))), 0x01));


                        body.instructions = f3696_parent_instructions;
                        body.emit(f3696);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r369A = bit_and(r368B, body.constant(3221225472u));
                        ir_expression *const r369B = equal(r369A, body.constant(0u));
                        ir_if *f3699 = new(mem_ctx) ir_if(operand(r369B).val);
                        exec_list *const f3699_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3699->then_instructions;

                           body.emit(assign(r368D, add(r368D, body.constant(int(2))), 0x01));

                           body.emit(assign(r368B, lshift(r368B, body.constant(int(2))), 0x01));


                        body.instructions = f3699_parent_instructions;
                        body.emit(f3699);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r369D = bit_and(r368B, body.constant(2147483648u));
                        ir_expression *const r369E = equal(r369D, body.constant(0u));
                        ir_if *f369C = new(mem_ctx) ir_if(operand(r369E).val);
                        exec_list *const f369C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f369C->then_instructions;

                           body.emit(assign(r368D, add(r368D, body.constant(int(1))), 0x01));


                        body.instructions = f369C_parent_instructions;
                        body.emit(f369C);

                        /* END IF */

                        body.emit(assign(r368C, r368D, 0x01));


                     body.instructions = f368E_parent_instructions;
                     body.emit(f368E);

                     /* END IF */

                     body.emit(assign(r3688, add(r368C, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r36A0 = lequal(body.constant(int(0)), r3688);
                     ir_if *f369F = new(mem_ctx) ir_if(operand(r36A0).val);
                     exec_list *const f369F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f369F->then_instructions;

                        body.emit(assign(r3687, body.constant(0u), 0x01));

                        ir_variable *const r36A1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r36A1, lshift(r3686, r3688), 0x01));

                        ir_variable *const r36A2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r36A4 = equal(r3688, body.constant(int(0)));
                        ir_if *f36A3 = new(mem_ctx) ir_if(operand(r36A4).val);
                        exec_list *const f36A3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f36A3->then_instructions;

                           body.emit(assign(r36A2, r3685, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f36A3->else_instructions;

                           ir_expression *const r36A5 = lshift(r3685, r3688);
                           ir_expression *const r36A6 = neg(r3688);
                           ir_expression *const r36A7 = bit_and(r36A6, body.constant(int(31)));
                           ir_expression *const r36A8 = rshift(r3686, r36A7);
                           body.emit(assign(r36A2, bit_or(r36A5, r36A8), 0x01));


                        body.instructions = f36A3_parent_instructions;
                        body.emit(f36A3);

                        /* END IF */

                        body.emit(assign(r3685, r36A2, 0x01));

                        body.emit(assign(r3686, r36A1, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f369F->else_instructions;

                        ir_variable *const r36A9 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r36A9, body.constant(0u), 0x01));

                        ir_variable *const r36AA = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r36AA, neg(r3688), 0x01));

                        ir_variable *const r36AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r36AB);
                        ir_variable *const r36AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r36AC);
                        ir_variable *const r36AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r36AD);
                        ir_variable *const r36AE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r36AF = neg(r36AA);
                        body.emit(assign(r36AE, bit_and(r36AF, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r36B1 = equal(r36AA, body.constant(int(0)));
                        ir_if *f36B0 = new(mem_ctx) ir_if(operand(r36B1).val);
                        exec_list *const f36B0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f36B0->then_instructions;

                           body.emit(assign(r36AB, r36A9, 0x01));

                           body.emit(assign(r36AC, r3686, 0x01));

                           body.emit(assign(r36AD, r3685, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f36B0->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r36B3 = less(r36AA, body.constant(int(32)));
                           ir_if *f36B2 = new(mem_ctx) ir_if(operand(r36B3).val);
                           exec_list *const f36B2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36B2->then_instructions;

                              body.emit(assign(r36AB, lshift(r3686, r36AE), 0x01));

                              ir_expression *const r36B4 = lshift(r3685, r36AE);
                              ir_expression *const r36B5 = rshift(r3686, r36AA);
                              body.emit(assign(r36AC, bit_or(r36B4, r36B5), 0x01));

                              body.emit(assign(r36AD, rshift(r3685, r36AA), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f36B2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r36B7 = equal(r36AA, body.constant(int(32)));
                              ir_if *f36B6 = new(mem_ctx) ir_if(operand(r36B7).val);
                              exec_list *const f36B6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f36B6->then_instructions;

                                 body.emit(assign(r36AB, r3686, 0x01));

                                 body.emit(assign(r36AC, r3685, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f36B6->else_instructions;

                                 body.emit(assign(r36A9, bit_or(body.constant(0u), r3686), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r36B9 = less(r36AA, body.constant(int(64)));
                                 ir_if *f36B8 = new(mem_ctx) ir_if(operand(r36B9).val);
                                 exec_list *const f36B8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f36B8->then_instructions;

                                    body.emit(assign(r36AB, lshift(r3685, r36AE), 0x01));

                                    ir_expression *const r36BA = bit_and(r36AA, body.constant(int(31)));
                                    body.emit(assign(r36AC, rshift(r3685, r36BA), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f36B8->else_instructions;

                                    ir_variable *const r36BB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r36BD = equal(r36AA, body.constant(int(64)));
                                    ir_if *f36BC = new(mem_ctx) ir_if(operand(r36BD).val);
                                    exec_list *const f36BC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f36BC->then_instructions;

                                       body.emit(assign(r36BB, r3685, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f36BC->else_instructions;

                                       ir_expression *const r36BE = nequal(r3685, body.constant(0u));
                                       ir_expression *const r36BF = expr(ir_unop_b2i, r36BE);
                                       body.emit(assign(r36BB, expr(ir_unop_i2u, r36BF), 0x01));


                                    body.instructions = f36BC_parent_instructions;
                                    body.emit(f36BC);

                                    /* END IF */

                                    body.emit(assign(r36AB, r36BB, 0x01));

                                    body.emit(assign(r36AC, body.constant(0u), 0x01));


                                 body.instructions = f36B8_parent_instructions;
                                 body.emit(f36B8);

                                 /* END IF */


                              body.instructions = f36B6_parent_instructions;
                              body.emit(f36B6);

                              /* END IF */

                              body.emit(assign(r36AD, body.constant(0u), 0x01));


                           body.instructions = f36B2_parent_instructions;
                           body.emit(f36B2);

                           /* END IF */

                           ir_expression *const r36C0 = nequal(r36A9, body.constant(0u));
                           ir_expression *const r36C1 = expr(ir_unop_b2i, r36C0);
                           ir_expression *const r36C2 = expr(ir_unop_i2u, r36C1);
                           body.emit(assign(r36AB, bit_or(r36AB, r36C2), 0x01));


                        body.instructions = f36B0_parent_instructions;
                        body.emit(f36B0);

                        /* END IF */

                        body.emit(assign(r3685, r36AD, 0x01));

                        body.emit(assign(r3686, r36AC, 0x01));

                        body.emit(assign(r3687, r36AB, 0x01));


                     body.instructions = f369F_parent_instructions;
                     body.emit(f369F);

                     /* END IF */

                     body.emit(assign(r3684, sub(r3684, r3688), 0x01));

                     ir_variable *const r36C3 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r36C3, r3684, 0x01));

                     ir_variable *const r36C4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r36C4, r3685, 0x01));

                     ir_variable *const r36C5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r36C5, r3686, 0x01));

                     ir_variable *const r36C6 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r36C6, r3687, 0x01));

                     ir_variable *const r36C7 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r36C7, body.constant(true), 0x01));

                     ir_variable *const r36C8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r36C9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r36C9);
                     ir_expression *const r36CA = expr(ir_unop_u2i, r3687);
                     body.emit(assign(r36C9, less(r36CA, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r36CC = lequal(body.constant(int(2045)), r3684);
                     ir_if *f36CB = new(mem_ctx) ir_if(operand(r36CC).val);
                     exec_list *const f36CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f36CB->then_instructions;

                        ir_variable *const r36CD = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r36CF = less(body.constant(int(2045)), r3684);
                        ir_if *f36CE = new(mem_ctx) ir_if(operand(r36CF).val);
                        exec_list *const f36CE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f36CE->then_instructions;

                           body.emit(assign(r36CD, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f36CE->else_instructions;

                           ir_variable *const r36D0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r36D2 = equal(r3684, body.constant(int(2045)));
                           ir_if *f36D1 = new(mem_ctx) ir_if(operand(r36D2).val);
                           exec_list *const f36D1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36D1->then_instructions;

                              ir_expression *const r36D3 = equal(body.constant(2097151u), r3685);
                              ir_expression *const r36D4 = equal(body.constant(4294967295u), r3686);
                              body.emit(assign(r36D0, logic_and(r36D3, r36D4), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f36D1->else_instructions;

                              body.emit(assign(r36D0, body.constant(false), 0x01));


                           body.instructions = f36D1_parent_instructions;
                           body.emit(f36D1);

                           /* END IF */

                           body.emit(assign(r36CD, logic_and(r36D0, r36C9), 0x01));


                        body.instructions = f36CE_parent_instructions;
                        body.emit(f36CE);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f36D5 = new(mem_ctx) ir_if(operand(r36CD).val);
                        exec_list *const f36D5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f36D5->then_instructions;

                           ir_variable *const r36D6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r36D6);
                           ir_expression *const r36D7 = lshift(r34F2, body.constant(int(31)));
                           body.emit(assign(r36D6, add(r36D7, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r36D6, body.constant(0u), 0x01));

                           body.emit(assign(r36C8, r36D6, 0x03));

                           body.emit(assign(r36C7, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f36D5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r36D9 = less(r3684, body.constant(int(0)));
                           ir_if *f36D8 = new(mem_ctx) ir_if(operand(r36D9).val);
                           exec_list *const f36D8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36D8->then_instructions;

                              ir_variable *const r36DA = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r36DA, r3687, 0x01));

                              ir_variable *const r36DB = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r36DB, neg(r3684), 0x01));

                              ir_variable *const r36DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r36DC);
                              ir_variable *const r36DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r36DD);
                              ir_variable *const r36DE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r36DE);
                              ir_variable *const r36DF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r36E0 = neg(r36DB);
                              body.emit(assign(r36DF, bit_and(r36E0, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r36E2 = equal(r36DB, body.constant(int(0)));
                              ir_if *f36E1 = new(mem_ctx) ir_if(operand(r36E2).val);
                              exec_list *const f36E1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f36E1->then_instructions;

                                 body.emit(assign(r36DC, r3687, 0x01));

                                 body.emit(assign(r36DD, r3686, 0x01));

                                 body.emit(assign(r36DE, r3685, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f36E1->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r36E4 = less(r36DB, body.constant(int(32)));
                                 ir_if *f36E3 = new(mem_ctx) ir_if(operand(r36E4).val);
                                 exec_list *const f36E3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f36E3->then_instructions;

                                    body.emit(assign(r36DC, lshift(r3686, r36DF), 0x01));

                                    ir_expression *const r36E5 = lshift(r3685, r36DF);
                                    ir_expression *const r36E6 = rshift(r3686, r36DB);
                                    body.emit(assign(r36DD, bit_or(r36E5, r36E6), 0x01));

                                    body.emit(assign(r36DE, rshift(r3685, r36DB), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f36E3->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r36E8 = equal(r36DB, body.constant(int(32)));
                                    ir_if *f36E7 = new(mem_ctx) ir_if(operand(r36E8).val);
                                    exec_list *const f36E7_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f36E7->then_instructions;

                                       body.emit(assign(r36DC, r3686, 0x01));

                                       body.emit(assign(r36DD, r3685, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f36E7->else_instructions;

                                       body.emit(assign(r36DA, bit_or(r3687, r3686), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r36EA = less(r36DB, body.constant(int(64)));
                                       ir_if *f36E9 = new(mem_ctx) ir_if(operand(r36EA).val);
                                       exec_list *const f36E9_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f36E9->then_instructions;

                                          body.emit(assign(r36DC, lshift(r3685, r36DF), 0x01));

                                          ir_expression *const r36EB = bit_and(r36DB, body.constant(int(31)));
                                          body.emit(assign(r36DD, rshift(r3685, r36EB), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f36E9->else_instructions;

                                          ir_variable *const r36EC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r36EE = equal(r36DB, body.constant(int(64)));
                                          ir_if *f36ED = new(mem_ctx) ir_if(operand(r36EE).val);
                                          exec_list *const f36ED_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f36ED->then_instructions;

                                             body.emit(assign(r36EC, r3685, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f36ED->else_instructions;

                                             ir_expression *const r36EF = nequal(r3685, body.constant(0u));
                                             ir_expression *const r36F0 = expr(ir_unop_b2i, r36EF);
                                             body.emit(assign(r36EC, expr(ir_unop_i2u, r36F0), 0x01));


                                          body.instructions = f36ED_parent_instructions;
                                          body.emit(f36ED);

                                          /* END IF */

                                          body.emit(assign(r36DC, r36EC, 0x01));

                                          body.emit(assign(r36DD, body.constant(0u), 0x01));


                                       body.instructions = f36E9_parent_instructions;
                                       body.emit(f36E9);

                                       /* END IF */


                                    body.instructions = f36E7_parent_instructions;
                                    body.emit(f36E7);

                                    /* END IF */

                                    body.emit(assign(r36DE, body.constant(0u), 0x01));


                                 body.instructions = f36E3_parent_instructions;
                                 body.emit(f36E3);

                                 /* END IF */

                                 ir_expression *const r36F1 = nequal(r36DA, body.constant(0u));
                                 ir_expression *const r36F2 = expr(ir_unop_b2i, r36F1);
                                 ir_expression *const r36F3 = expr(ir_unop_i2u, r36F2);
                                 body.emit(assign(r36DC, bit_or(r36DC, r36F3), 0x01));


                              body.instructions = f36E1_parent_instructions;
                              body.emit(f36E1);

                              /* END IF */

                              body.emit(assign(r36C4, r36DE, 0x01));

                              body.emit(assign(r36C5, r36DD, 0x01));

                              body.emit(assign(r36C6, r36DC, 0x01));

                              body.emit(assign(r36C3, body.constant(int(0)), 0x01));

                              body.emit(assign(r36C9, less(r36DC, body.constant(0u)), 0x01));


                           body.instructions = f36D8_parent_instructions;
                           body.emit(f36D8);

                           /* END IF */


                        body.instructions = f36D5_parent_instructions;
                        body.emit(f36D5);

                        /* END IF */


                     body.instructions = f36CB_parent_instructions;
                     body.emit(f36CB);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f36F4 = new(mem_ctx) ir_if(operand(r36C7).val);
                     exec_list *const f36F4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f36F4->then_instructions;

                        /* IF CONDITION */
                        ir_if *f36F5 = new(mem_ctx) ir_if(operand(r36C9).val);
                        exec_list *const f36F5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f36F5->then_instructions;

                           ir_variable *const r36F6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r36F6, add(r36C5, body.constant(1u)), 0x01));

                           ir_expression *const r36F7 = less(r36F6, r36C5);
                           ir_expression *const r36F8 = expr(ir_unop_b2i, r36F7);
                           ir_expression *const r36F9 = expr(ir_unop_i2u, r36F8);
                           body.emit(assign(r36C4, add(r36C4, r36F9), 0x01));

                           ir_expression *const r36FA = equal(r36C6, body.constant(0u));
                           ir_expression *const r36FB = expr(ir_unop_b2i, r36FA);
                           ir_expression *const r36FC = expr(ir_unop_i2u, r36FB);
                           ir_expression *const r36FD = add(r36C6, r36FC);
                           ir_expression *const r36FE = bit_and(r36FD, body.constant(1u));
                           ir_expression *const r36FF = expr(ir_unop_bit_not, r36FE);
                           body.emit(assign(r36C5, bit_and(r36F6, r36FF), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f36F5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3701 = bit_or(r36C4, r36C5);
                           ir_expression *const r3702 = equal(r3701, body.constant(0u));
                           ir_if *f3700 = new(mem_ctx) ir_if(operand(r3702).val);
                           exec_list *const f3700_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3700->then_instructions;

                              body.emit(assign(r36C3, body.constant(int(0)), 0x01));


                           body.instructions = f3700_parent_instructions;
                           body.emit(f3700);

                           /* END IF */


                        body.instructions = f36F5_parent_instructions;
                        body.emit(f36F5);

                        /* END IF */

                        ir_variable *const r3703 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3703);
                        ir_expression *const r3704 = lshift(r34F2, body.constant(int(31)));
                        ir_expression *const r3705 = expr(ir_unop_i2u, r36C3);
                        ir_expression *const r3706 = lshift(r3705, body.constant(int(20)));
                        ir_expression *const r3707 = add(r3704, r3706);
                        body.emit(assign(r3703, add(r3707, r36C4), 0x02));

                        body.emit(assign(r3703, r36C5, 0x01));

                        body.emit(assign(r36C8, r3703, 0x03));

                        body.emit(assign(r36C7, body.constant(false), 0x01));


                     body.instructions = f36F4_parent_instructions;
                     body.emit(f36F4);

                     /* END IF */

                     body.emit(assign(r34F3, r36C8, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f367C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3709 = less(r34F9, r34F7);
                     ir_if *f3708 = new(mem_ctx) ir_if(operand(r3709).val);
                     exec_list *const f3708_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3708->then_instructions;

                        ir_variable *const r370A = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r370B = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r370B, sub(r34F8, r34FA), 0x01));

                        ir_expression *const r370C = sub(r34F7, r34F9);
                        ir_expression *const r370D = less(r34F8, r34FA);
                        ir_expression *const r370E = expr(ir_unop_b2i, r370D);
                        ir_expression *const r370F = expr(ir_unop_i2u, r370E);
                        body.emit(assign(r370A, sub(r370C, r370F), 0x01));

                        body.emit(assign(r34F2, bit_xor(r34F2, body.constant(1u)), 0x01));

                        body.emit(assign(r34FB, add(r34F5, body.constant(int(-1))), 0x01));

                        ir_variable *const r3710 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r3710, add(r34FB, body.constant(int(-10))), 0x01));

                        ir_variable *const r3711 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r3711, r370A, 0x01));

                        ir_variable *const r3712 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r3712, r370B, 0x01));

                        ir_variable *const r3713 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r3713);
                        ir_variable *const r3714 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r3714);
                        /* IF CONDITION */
                        ir_expression *const r3716 = equal(r370A, body.constant(0u));
                        ir_if *f3715 = new(mem_ctx) ir_if(operand(r3716).val);
                        exec_list *const f3715_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3715->then_instructions;

                           body.emit(assign(r3711, r370B, 0x01));

                           body.emit(assign(r3712, body.constant(0u), 0x01));

                           body.emit(assign(r3710, add(r3710, body.constant(int(-32))), 0x01));


                        body.instructions = f3715_parent_instructions;
                        body.emit(f3715);

                        /* END IF */

                        ir_variable *const r3717 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r3717, r3711, 0x01));

                        ir_variable *const r3718 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r3719 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r3719);
                        /* IF CONDITION */
                        ir_expression *const r371B = equal(r3711, body.constant(0u));
                        ir_if *f371A = new(mem_ctx) ir_if(operand(r371B).val);
                        exec_list *const f371A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f371A->then_instructions;

                           body.emit(assign(r3718, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f371A->else_instructions;

                           body.emit(assign(r3719, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r371D = bit_and(r3711, body.constant(4294901760u));
                           ir_expression *const r371E = equal(r371D, body.constant(0u));
                           ir_if *f371C = new(mem_ctx) ir_if(operand(r371E).val);
                           exec_list *const f371C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f371C->then_instructions;

                              body.emit(assign(r3719, body.constant(int(16)), 0x01));

                              body.emit(assign(r3717, lshift(r3711, body.constant(int(16))), 0x01));


                           body.instructions = f371C_parent_instructions;
                           body.emit(f371C);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3720 = bit_and(r3717, body.constant(4278190080u));
                           ir_expression *const r3721 = equal(r3720, body.constant(0u));
                           ir_if *f371F = new(mem_ctx) ir_if(operand(r3721).val);
                           exec_list *const f371F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f371F->then_instructions;

                              body.emit(assign(r3719, add(r3719, body.constant(int(8))), 0x01));

                              body.emit(assign(r3717, lshift(r3717, body.constant(int(8))), 0x01));


                           body.instructions = f371F_parent_instructions;
                           body.emit(f371F);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3723 = bit_and(r3717, body.constant(4026531840u));
                           ir_expression *const r3724 = equal(r3723, body.constant(0u));
                           ir_if *f3722 = new(mem_ctx) ir_if(operand(r3724).val);
                           exec_list *const f3722_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3722->then_instructions;

                              body.emit(assign(r3719, add(r3719, body.constant(int(4))), 0x01));

                              body.emit(assign(r3717, lshift(r3717, body.constant(int(4))), 0x01));


                           body.instructions = f3722_parent_instructions;
                           body.emit(f3722);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3726 = bit_and(r3717, body.constant(3221225472u));
                           ir_expression *const r3727 = equal(r3726, body.constant(0u));
                           ir_if *f3725 = new(mem_ctx) ir_if(operand(r3727).val);
                           exec_list *const f3725_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3725->then_instructions;

                              body.emit(assign(r3719, add(r3719, body.constant(int(2))), 0x01));

                              body.emit(assign(r3717, lshift(r3717, body.constant(int(2))), 0x01));


                           body.instructions = f3725_parent_instructions;
                           body.emit(f3725);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3729 = bit_and(r3717, body.constant(2147483648u));
                           ir_expression *const r372A = equal(r3729, body.constant(0u));
                           ir_if *f3728 = new(mem_ctx) ir_if(operand(r372A).val);
                           exec_list *const f3728_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3728->then_instructions;

                              body.emit(assign(r3719, add(r3719, body.constant(int(1))), 0x01));


                           body.instructions = f3728_parent_instructions;
                           body.emit(f3728);

                           /* END IF */

                           body.emit(assign(r3718, r3719, 0x01));


                        body.instructions = f371A_parent_instructions;
                        body.emit(f371A);

                        /* END IF */

                        body.emit(assign(r3714, add(r3718, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r372C = lequal(body.constant(int(0)), r3714);
                        ir_if *f372B = new(mem_ctx) ir_if(operand(r372C).val);
                        exec_list *const f372B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f372B->then_instructions;

                           body.emit(assign(r3713, body.constant(0u), 0x01));

                           ir_variable *const r372D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r372D, lshift(r3712, r3714), 0x01));

                           ir_variable *const r372E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3730 = equal(r3714, body.constant(int(0)));
                           ir_if *f372F = new(mem_ctx) ir_if(operand(r3730).val);
                           exec_list *const f372F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f372F->then_instructions;

                              body.emit(assign(r372E, r3711, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f372F->else_instructions;

                              ir_expression *const r3731 = lshift(r3711, r3714);
                              ir_expression *const r3732 = neg(r3714);
                              ir_expression *const r3733 = bit_and(r3732, body.constant(int(31)));
                              ir_expression *const r3734 = rshift(r3712, r3733);
                              body.emit(assign(r372E, bit_or(r3731, r3734), 0x01));


                           body.instructions = f372F_parent_instructions;
                           body.emit(f372F);

                           /* END IF */

                           body.emit(assign(r3711, r372E, 0x01));

                           body.emit(assign(r3712, r372D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f372B->else_instructions;

                           ir_variable *const r3735 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3735, body.constant(0u), 0x01));

                           ir_variable *const r3736 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3736, neg(r3714), 0x01));

                           ir_variable *const r3737 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3737);
                           ir_variable *const r3738 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3738);
                           ir_variable *const r3739 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3739);
                           ir_variable *const r373A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r373B = neg(r3736);
                           body.emit(assign(r373A, bit_and(r373B, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r373D = equal(r3736, body.constant(int(0)));
                           ir_if *f373C = new(mem_ctx) ir_if(operand(r373D).val);
                           exec_list *const f373C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f373C->then_instructions;

                              body.emit(assign(r3737, r3735, 0x01));

                              body.emit(assign(r3738, r3712, 0x01));

                              body.emit(assign(r3739, r3711, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f373C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r373F = less(r3736, body.constant(int(32)));
                              ir_if *f373E = new(mem_ctx) ir_if(operand(r373F).val);
                              exec_list *const f373E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f373E->then_instructions;

                                 body.emit(assign(r3737, lshift(r3712, r373A), 0x01));

                                 ir_expression *const r3740 = lshift(r3711, r373A);
                                 ir_expression *const r3741 = rshift(r3712, r3736);
                                 body.emit(assign(r3738, bit_or(r3740, r3741), 0x01));

                                 body.emit(assign(r3739, rshift(r3711, r3736), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f373E->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3743 = equal(r3736, body.constant(int(32)));
                                 ir_if *f3742 = new(mem_ctx) ir_if(operand(r3743).val);
                                 exec_list *const f3742_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3742->then_instructions;

                                    body.emit(assign(r3737, r3712, 0x01));

                                    body.emit(assign(r3738, r3711, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3742->else_instructions;

                                    body.emit(assign(r3735, bit_or(body.constant(0u), r3712), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3745 = less(r3736, body.constant(int(64)));
                                    ir_if *f3744 = new(mem_ctx) ir_if(operand(r3745).val);
                                    exec_list *const f3744_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3744->then_instructions;

                                       body.emit(assign(r3737, lshift(r3711, r373A), 0x01));

                                       ir_expression *const r3746 = bit_and(r3736, body.constant(int(31)));
                                       body.emit(assign(r3738, rshift(r3711, r3746), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3744->else_instructions;

                                       ir_variable *const r3747 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3749 = equal(r3736, body.constant(int(64)));
                                       ir_if *f3748 = new(mem_ctx) ir_if(operand(r3749).val);
                                       exec_list *const f3748_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3748->then_instructions;

                                          body.emit(assign(r3747, r3711, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3748->else_instructions;

                                          ir_expression *const r374A = nequal(r3711, body.constant(0u));
                                          ir_expression *const r374B = expr(ir_unop_b2i, r374A);
                                          body.emit(assign(r3747, expr(ir_unop_i2u, r374B), 0x01));


                                       body.instructions = f3748_parent_instructions;
                                       body.emit(f3748);

                                       /* END IF */

                                       body.emit(assign(r3737, r3747, 0x01));

                                       body.emit(assign(r3738, body.constant(0u), 0x01));


                                    body.instructions = f3744_parent_instructions;
                                    body.emit(f3744);

                                    /* END IF */


                                 body.instructions = f3742_parent_instructions;
                                 body.emit(f3742);

                                 /* END IF */

                                 body.emit(assign(r3739, body.constant(0u), 0x01));


                              body.instructions = f373E_parent_instructions;
                              body.emit(f373E);

                              /* END IF */

                              ir_expression *const r374C = nequal(r3735, body.constant(0u));
                              ir_expression *const r374D = expr(ir_unop_b2i, r374C);
                              ir_expression *const r374E = expr(ir_unop_i2u, r374D);
                              body.emit(assign(r3737, bit_or(r3737, r374E), 0x01));


                           body.instructions = f373C_parent_instructions;
                           body.emit(f373C);

                           /* END IF */

                           body.emit(assign(r3711, r3739, 0x01));

                           body.emit(assign(r3712, r3738, 0x01));

                           body.emit(assign(r3713, r3737, 0x01));


                        body.instructions = f372B_parent_instructions;
                        body.emit(f372B);

                        /* END IF */

                        body.emit(assign(r3710, sub(r3710, r3714), 0x01));

                        ir_variable *const r374F = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r374F, r3710, 0x01));

                        ir_variable *const r3750 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r3750, r3711, 0x01));

                        ir_variable *const r3751 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r3751, r3712, 0x01));

                        ir_variable *const r3752 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r3752, r3713, 0x01));

                        ir_variable *const r3753 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r3753, body.constant(true), 0x01));

                        ir_variable *const r3754 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r3755 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r3755);
                        ir_expression *const r3756 = expr(ir_unop_u2i, r3713);
                        body.emit(assign(r3755, less(r3756, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3758 = lequal(body.constant(int(2045)), r3710);
                        ir_if *f3757 = new(mem_ctx) ir_if(operand(r3758).val);
                        exec_list *const f3757_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3757->then_instructions;

                           ir_variable *const r3759 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r375B = less(body.constant(int(2045)), r3710);
                           ir_if *f375A = new(mem_ctx) ir_if(operand(r375B).val);
                           exec_list *const f375A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f375A->then_instructions;

                              body.emit(assign(r3759, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f375A->else_instructions;

                              ir_variable *const r375C = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r375E = equal(r3710, body.constant(int(2045)));
                              ir_if *f375D = new(mem_ctx) ir_if(operand(r375E).val);
                              exec_list *const f375D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f375D->then_instructions;

                                 ir_expression *const r375F = equal(body.constant(2097151u), r3711);
                                 ir_expression *const r3760 = equal(body.constant(4294967295u), r3712);
                                 body.emit(assign(r375C, logic_and(r375F, r3760), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f375D->else_instructions;

                                 body.emit(assign(r375C, body.constant(false), 0x01));


                              body.instructions = f375D_parent_instructions;
                              body.emit(f375D);

                              /* END IF */

                              body.emit(assign(r3759, logic_and(r375C, r3755), 0x01));


                           body.instructions = f375A_parent_instructions;
                           body.emit(f375A);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f3761 = new(mem_ctx) ir_if(operand(r3759).val);
                           exec_list *const f3761_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3761->then_instructions;

                              ir_variable *const r3762 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3762);
                              ir_expression *const r3763 = lshift(r34F2, body.constant(int(31)));
                              body.emit(assign(r3762, add(r3763, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r3762, body.constant(0u), 0x01));

                              body.emit(assign(r3754, r3762, 0x03));

                              body.emit(assign(r3753, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3761->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3765 = less(r3710, body.constant(int(0)));
                              ir_if *f3764 = new(mem_ctx) ir_if(operand(r3765).val);
                              exec_list *const f3764_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3764->then_instructions;

                                 ir_variable *const r3766 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r3766, r3713, 0x01));

                                 ir_variable *const r3767 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r3767, neg(r3710), 0x01));

                                 ir_variable *const r3768 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r3768);
                                 ir_variable *const r3769 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r3769);
                                 ir_variable *const r376A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r376A);
                                 ir_variable *const r376B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r376C = neg(r3767);
                                 body.emit(assign(r376B, bit_and(r376C, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r376E = equal(r3767, body.constant(int(0)));
                                 ir_if *f376D = new(mem_ctx) ir_if(operand(r376E).val);
                                 exec_list *const f376D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f376D->then_instructions;

                                    body.emit(assign(r3768, r3713, 0x01));

                                    body.emit(assign(r3769, r3712, 0x01));

                                    body.emit(assign(r376A, r3711, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f376D->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3770 = less(r3767, body.constant(int(32)));
                                    ir_if *f376F = new(mem_ctx) ir_if(operand(r3770).val);
                                    exec_list *const f376F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f376F->then_instructions;

                                       body.emit(assign(r3768, lshift(r3712, r376B), 0x01));

                                       ir_expression *const r3771 = lshift(r3711, r376B);
                                       ir_expression *const r3772 = rshift(r3712, r3767);
                                       body.emit(assign(r3769, bit_or(r3771, r3772), 0x01));

                                       body.emit(assign(r376A, rshift(r3711, r3767), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f376F->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r3774 = equal(r3767, body.constant(int(32)));
                                       ir_if *f3773 = new(mem_ctx) ir_if(operand(r3774).val);
                                       exec_list *const f3773_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3773->then_instructions;

                                          body.emit(assign(r3768, r3712, 0x01));

                                          body.emit(assign(r3769, r3711, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3773->else_instructions;

                                          body.emit(assign(r3766, bit_or(r3713, r3712), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r3776 = less(r3767, body.constant(int(64)));
                                          ir_if *f3775 = new(mem_ctx) ir_if(operand(r3776).val);
                                          exec_list *const f3775_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3775->then_instructions;

                                             body.emit(assign(r3768, lshift(r3711, r376B), 0x01));

                                             ir_expression *const r3777 = bit_and(r3767, body.constant(int(31)));
                                             body.emit(assign(r3769, rshift(r3711, r3777), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3775->else_instructions;

                                             ir_variable *const r3778 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r377A = equal(r3767, body.constant(int(64)));
                                             ir_if *f3779 = new(mem_ctx) ir_if(operand(r377A).val);
                                             exec_list *const f3779_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3779->then_instructions;

                                                body.emit(assign(r3778, r3711, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3779->else_instructions;

                                                ir_expression *const r377B = nequal(r3711, body.constant(0u));
                                                ir_expression *const r377C = expr(ir_unop_b2i, r377B);
                                                body.emit(assign(r3778, expr(ir_unop_i2u, r377C), 0x01));


                                             body.instructions = f3779_parent_instructions;
                                             body.emit(f3779);

                                             /* END IF */

                                             body.emit(assign(r3768, r3778, 0x01));

                                             body.emit(assign(r3769, body.constant(0u), 0x01));


                                          body.instructions = f3775_parent_instructions;
                                          body.emit(f3775);

                                          /* END IF */


                                       body.instructions = f3773_parent_instructions;
                                       body.emit(f3773);

                                       /* END IF */

                                       body.emit(assign(r376A, body.constant(0u), 0x01));


                                    body.instructions = f376F_parent_instructions;
                                    body.emit(f376F);

                                    /* END IF */

                                    ir_expression *const r377D = nequal(r3766, body.constant(0u));
                                    ir_expression *const r377E = expr(ir_unop_b2i, r377D);
                                    ir_expression *const r377F = expr(ir_unop_i2u, r377E);
                                    body.emit(assign(r3768, bit_or(r3768, r377F), 0x01));


                                 body.instructions = f376D_parent_instructions;
                                 body.emit(f376D);

                                 /* END IF */

                                 body.emit(assign(r3750, r376A, 0x01));

                                 body.emit(assign(r3751, r3769, 0x01));

                                 body.emit(assign(r3752, r3768, 0x01));

                                 body.emit(assign(r374F, body.constant(int(0)), 0x01));

                                 body.emit(assign(r3755, less(r3768, body.constant(0u)), 0x01));


                              body.instructions = f3764_parent_instructions;
                              body.emit(f3764);

                              /* END IF */


                           body.instructions = f3761_parent_instructions;
                           body.emit(f3761);

                           /* END IF */


                        body.instructions = f3757_parent_instructions;
                        body.emit(f3757);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f3780 = new(mem_ctx) ir_if(operand(r3753).val);
                        exec_list *const f3780_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3780->then_instructions;

                           /* IF CONDITION */
                           ir_if *f3781 = new(mem_ctx) ir_if(operand(r3755).val);
                           exec_list *const f3781_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3781->then_instructions;

                              ir_variable *const r3782 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r3782, add(r3751, body.constant(1u)), 0x01));

                              ir_expression *const r3783 = less(r3782, r3751);
                              ir_expression *const r3784 = expr(ir_unop_b2i, r3783);
                              ir_expression *const r3785 = expr(ir_unop_i2u, r3784);
                              body.emit(assign(r3750, add(r3750, r3785), 0x01));

                              ir_expression *const r3786 = equal(r3752, body.constant(0u));
                              ir_expression *const r3787 = expr(ir_unop_b2i, r3786);
                              ir_expression *const r3788 = expr(ir_unop_i2u, r3787);
                              ir_expression *const r3789 = add(r3752, r3788);
                              ir_expression *const r378A = bit_and(r3789, body.constant(1u));
                              ir_expression *const r378B = expr(ir_unop_bit_not, r378A);
                              body.emit(assign(r3751, bit_and(r3782, r378B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3781->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r378D = bit_or(r3750, r3751);
                              ir_expression *const r378E = equal(r378D, body.constant(0u));
                              ir_if *f378C = new(mem_ctx) ir_if(operand(r378E).val);
                              exec_list *const f378C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f378C->then_instructions;

                                 body.emit(assign(r374F, body.constant(int(0)), 0x01));


                              body.instructions = f378C_parent_instructions;
                              body.emit(f378C);

                              /* END IF */


                           body.instructions = f3781_parent_instructions;
                           body.emit(f3781);

                           /* END IF */

                           ir_variable *const r378F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r378F);
                           ir_expression *const r3790 = lshift(r34F2, body.constant(int(31)));
                           ir_expression *const r3791 = expr(ir_unop_i2u, r374F);
                           ir_expression *const r3792 = lshift(r3791, body.constant(int(20)));
                           ir_expression *const r3793 = add(r3790, r3792);
                           body.emit(assign(r378F, add(r3793, r3750), 0x02));

                           body.emit(assign(r378F, r3751, 0x01));

                           body.emit(assign(r3754, r378F, 0x03));

                           body.emit(assign(r3753, body.constant(false), 0x01));


                        body.instructions = f3780_parent_instructions;
                        body.emit(f3780);

                        /* END IF */

                        body.emit(assign(r34F3, r3754, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3708->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3795 = less(r34F8, r34FA);
                        ir_if *f3794 = new(mem_ctx) ir_if(operand(r3795).val);
                        exec_list *const f3794_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3794->then_instructions;

                           ir_variable *const r3796 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r3797 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r3797, sub(r34FA, r34F8), 0x01));

                           ir_expression *const r3798 = sub(r34F9, r34F7);
                           ir_expression *const r3799 = less(r34FA, r34F8);
                           ir_expression *const r379A = expr(ir_unop_b2i, r3799);
                           ir_expression *const r379B = expr(ir_unop_i2u, r379A);
                           body.emit(assign(r3796, sub(r3798, r379B), 0x01));

                           body.emit(assign(r34FB, add(r34F6, body.constant(int(-1))), 0x01));

                           ir_variable *const r379C = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r379C, add(r34FB, body.constant(int(-10))), 0x01));

                           ir_variable *const r379D = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r379D, r3796, 0x01));

                           ir_variable *const r379E = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r379E, r3797, 0x01));

                           ir_variable *const r379F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r379F);
                           ir_variable *const r37A0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r37A0);
                           /* IF CONDITION */
                           ir_expression *const r37A2 = equal(r3796, body.constant(0u));
                           ir_if *f37A1 = new(mem_ctx) ir_if(operand(r37A2).val);
                           exec_list *const f37A1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f37A1->then_instructions;

                              body.emit(assign(r379D, r3797, 0x01));

                              body.emit(assign(r379E, body.constant(0u), 0x01));

                              body.emit(assign(r379C, add(r379C, body.constant(int(-32))), 0x01));


                           body.instructions = f37A1_parent_instructions;
                           body.emit(f37A1);

                           /* END IF */

                           ir_variable *const r37A3 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r37A3, r379D, 0x01));

                           ir_variable *const r37A4 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r37A5 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r37A5);
                           /* IF CONDITION */
                           ir_expression *const r37A7 = equal(r379D, body.constant(0u));
                           ir_if *f37A6 = new(mem_ctx) ir_if(operand(r37A7).val);
                           exec_list *const f37A6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f37A6->then_instructions;

                              body.emit(assign(r37A4, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f37A6->else_instructions;

                              body.emit(assign(r37A5, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r37A9 = bit_and(r379D, body.constant(4294901760u));
                              ir_expression *const r37AA = equal(r37A9, body.constant(0u));
                              ir_if *f37A8 = new(mem_ctx) ir_if(operand(r37AA).val);
                              exec_list *const f37A8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f37A8->then_instructions;

                                 body.emit(assign(r37A5, body.constant(int(16)), 0x01));

                                 body.emit(assign(r37A3, lshift(r379D, body.constant(int(16))), 0x01));


                              body.instructions = f37A8_parent_instructions;
                              body.emit(f37A8);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r37AC = bit_and(r37A3, body.constant(4278190080u));
                              ir_expression *const r37AD = equal(r37AC, body.constant(0u));
                              ir_if *f37AB = new(mem_ctx) ir_if(operand(r37AD).val);
                              exec_list *const f37AB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f37AB->then_instructions;

                                 body.emit(assign(r37A5, add(r37A5, body.constant(int(8))), 0x01));

                                 body.emit(assign(r37A3, lshift(r37A3, body.constant(int(8))), 0x01));


                              body.instructions = f37AB_parent_instructions;
                              body.emit(f37AB);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r37AF = bit_and(r37A3, body.constant(4026531840u));
                              ir_expression *const r37B0 = equal(r37AF, body.constant(0u));
                              ir_if *f37AE = new(mem_ctx) ir_if(operand(r37B0).val);
                              exec_list *const f37AE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f37AE->then_instructions;

                                 body.emit(assign(r37A5, add(r37A5, body.constant(int(4))), 0x01));

                                 body.emit(assign(r37A3, lshift(r37A3, body.constant(int(4))), 0x01));


                              body.instructions = f37AE_parent_instructions;
                              body.emit(f37AE);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r37B2 = bit_and(r37A3, body.constant(3221225472u));
                              ir_expression *const r37B3 = equal(r37B2, body.constant(0u));
                              ir_if *f37B1 = new(mem_ctx) ir_if(operand(r37B3).val);
                              exec_list *const f37B1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f37B1->then_instructions;

                                 body.emit(assign(r37A5, add(r37A5, body.constant(int(2))), 0x01));

                                 body.emit(assign(r37A3, lshift(r37A3, body.constant(int(2))), 0x01));


                              body.instructions = f37B1_parent_instructions;
                              body.emit(f37B1);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r37B5 = bit_and(r37A3, body.constant(2147483648u));
                              ir_expression *const r37B6 = equal(r37B5, body.constant(0u));
                              ir_if *f37B4 = new(mem_ctx) ir_if(operand(r37B6).val);
                              exec_list *const f37B4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f37B4->then_instructions;

                                 body.emit(assign(r37A5, add(r37A5, body.constant(int(1))), 0x01));


                              body.instructions = f37B4_parent_instructions;
                              body.emit(f37B4);

                              /* END IF */

                              body.emit(assign(r37A4, r37A5, 0x01));


                           body.instructions = f37A6_parent_instructions;
                           body.emit(f37A6);

                           /* END IF */

                           body.emit(assign(r37A0, add(r37A4, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r37B8 = lequal(body.constant(int(0)), r37A0);
                           ir_if *f37B7 = new(mem_ctx) ir_if(operand(r37B8).val);
                           exec_list *const f37B7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f37B7->then_instructions;

                              body.emit(assign(r379F, body.constant(0u), 0x01));

                              ir_variable *const r37B9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r37B9, lshift(r379E, r37A0), 0x01));

                              ir_variable *const r37BA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r37BC = equal(r37A0, body.constant(int(0)));
                              ir_if *f37BB = new(mem_ctx) ir_if(operand(r37BC).val);
                              exec_list *const f37BB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f37BB->then_instructions;

                                 body.emit(assign(r37BA, r379D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f37BB->else_instructions;

                                 ir_expression *const r37BD = lshift(r379D, r37A0);
                                 ir_expression *const r37BE = neg(r37A0);
                                 ir_expression *const r37BF = bit_and(r37BE, body.constant(int(31)));
                                 ir_expression *const r37C0 = rshift(r379E, r37BF);
                                 body.emit(assign(r37BA, bit_or(r37BD, r37C0), 0x01));


                              body.instructions = f37BB_parent_instructions;
                              body.emit(f37BB);

                              /* END IF */

                              body.emit(assign(r379D, r37BA, 0x01));

                              body.emit(assign(r379E, r37B9, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f37B7->else_instructions;

                              ir_variable *const r37C1 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r37C1, body.constant(0u), 0x01));

                              ir_variable *const r37C2 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r37C2, neg(r37A0), 0x01));

                              ir_variable *const r37C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r37C3);
                              ir_variable *const r37C4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r37C4);
                              ir_variable *const r37C5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r37C5);
                              ir_variable *const r37C6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r37C7 = neg(r37C2);
                              body.emit(assign(r37C6, bit_and(r37C7, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r37C9 = equal(r37C2, body.constant(int(0)));
                              ir_if *f37C8 = new(mem_ctx) ir_if(operand(r37C9).val);
                              exec_list *const f37C8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f37C8->then_instructions;

                                 body.emit(assign(r37C3, r37C1, 0x01));

                                 body.emit(assign(r37C4, r379E, 0x01));

                                 body.emit(assign(r37C5, r379D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f37C8->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r37CB = less(r37C2, body.constant(int(32)));
                                 ir_if *f37CA = new(mem_ctx) ir_if(operand(r37CB).val);
                                 exec_list *const f37CA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f37CA->then_instructions;

                                    body.emit(assign(r37C3, lshift(r379E, r37C6), 0x01));

                                    ir_expression *const r37CC = lshift(r379D, r37C6);
                                    ir_expression *const r37CD = rshift(r379E, r37C2);
                                    body.emit(assign(r37C4, bit_or(r37CC, r37CD), 0x01));

                                    body.emit(assign(r37C5, rshift(r379D, r37C2), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f37CA->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r37CF = equal(r37C2, body.constant(int(32)));
                                    ir_if *f37CE = new(mem_ctx) ir_if(operand(r37CF).val);
                                    exec_list *const f37CE_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f37CE->then_instructions;

                                       body.emit(assign(r37C3, r379E, 0x01));

                                       body.emit(assign(r37C4, r379D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f37CE->else_instructions;

                                       body.emit(assign(r37C1, bit_or(body.constant(0u), r379E), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r37D1 = less(r37C2, body.constant(int(64)));
                                       ir_if *f37D0 = new(mem_ctx) ir_if(operand(r37D1).val);
                                       exec_list *const f37D0_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f37D0->then_instructions;

                                          body.emit(assign(r37C3, lshift(r379D, r37C6), 0x01));

                                          ir_expression *const r37D2 = bit_and(r37C2, body.constant(int(31)));
                                          body.emit(assign(r37C4, rshift(r379D, r37D2), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f37D0->else_instructions;

                                          ir_variable *const r37D3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r37D5 = equal(r37C2, body.constant(int(64)));
                                          ir_if *f37D4 = new(mem_ctx) ir_if(operand(r37D5).val);
                                          exec_list *const f37D4_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f37D4->then_instructions;

                                             body.emit(assign(r37D3, r379D, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f37D4->else_instructions;

                                             ir_expression *const r37D6 = nequal(r379D, body.constant(0u));
                                             ir_expression *const r37D7 = expr(ir_unop_b2i, r37D6);
                                             body.emit(assign(r37D3, expr(ir_unop_i2u, r37D7), 0x01));


                                          body.instructions = f37D4_parent_instructions;
                                          body.emit(f37D4);

                                          /* END IF */

                                          body.emit(assign(r37C3, r37D3, 0x01));

                                          body.emit(assign(r37C4, body.constant(0u), 0x01));


                                       body.instructions = f37D0_parent_instructions;
                                       body.emit(f37D0);

                                       /* END IF */


                                    body.instructions = f37CE_parent_instructions;
                                    body.emit(f37CE);

                                    /* END IF */

                                    body.emit(assign(r37C5, body.constant(0u), 0x01));


                                 body.instructions = f37CA_parent_instructions;
                                 body.emit(f37CA);

                                 /* END IF */

                                 ir_expression *const r37D8 = nequal(r37C1, body.constant(0u));
                                 ir_expression *const r37D9 = expr(ir_unop_b2i, r37D8);
                                 ir_expression *const r37DA = expr(ir_unop_i2u, r37D9);
                                 body.emit(assign(r37C3, bit_or(r37C3, r37DA), 0x01));


                              body.instructions = f37C8_parent_instructions;
                              body.emit(f37C8);

                              /* END IF */

                              body.emit(assign(r379D, r37C5, 0x01));

                              body.emit(assign(r379E, r37C4, 0x01));

                              body.emit(assign(r379F, r37C3, 0x01));


                           body.instructions = f37B7_parent_instructions;
                           body.emit(f37B7);

                           /* END IF */

                           body.emit(assign(r379C, sub(r379C, r37A0), 0x01));

                           ir_variable *const r37DB = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r37DB, r379C, 0x01));

                           ir_variable *const r37DC = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r37DC, r379D, 0x01));

                           ir_variable *const r37DD = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r37DD, r379E, 0x01));

                           ir_variable *const r37DE = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r37DE, r379F, 0x01));

                           ir_variable *const r37DF = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r37DF, body.constant(true), 0x01));

                           ir_variable *const r37E0 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r37E1 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r37E1);
                           ir_expression *const r37E2 = expr(ir_unop_u2i, r379F);
                           body.emit(assign(r37E1, less(r37E2, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r37E4 = lequal(body.constant(int(2045)), r379C);
                           ir_if *f37E3 = new(mem_ctx) ir_if(operand(r37E4).val);
                           exec_list *const f37E3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f37E3->then_instructions;

                              ir_variable *const r37E5 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r37E7 = less(body.constant(int(2045)), r379C);
                              ir_if *f37E6 = new(mem_ctx) ir_if(operand(r37E7).val);
                              exec_list *const f37E6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f37E6->then_instructions;

                                 body.emit(assign(r37E5, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f37E6->else_instructions;

                                 ir_variable *const r37E8 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r37EA = equal(r379C, body.constant(int(2045)));
                                 ir_if *f37E9 = new(mem_ctx) ir_if(operand(r37EA).val);
                                 exec_list *const f37E9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f37E9->then_instructions;

                                    ir_expression *const r37EB = equal(body.constant(2097151u), r379D);
                                    ir_expression *const r37EC = equal(body.constant(4294967295u), r379E);
                                    body.emit(assign(r37E8, logic_and(r37EB, r37EC), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f37E9->else_instructions;

                                    body.emit(assign(r37E8, body.constant(false), 0x01));


                                 body.instructions = f37E9_parent_instructions;
                                 body.emit(f37E9);

                                 /* END IF */

                                 body.emit(assign(r37E5, logic_and(r37E8, r37E1), 0x01));


                              body.instructions = f37E6_parent_instructions;
                              body.emit(f37E6);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f37ED = new(mem_ctx) ir_if(operand(r37E5).val);
                              exec_list *const f37ED_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f37ED->then_instructions;

                                 ir_variable *const r37EE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r37EE);
                                 ir_expression *const r37EF = lshift(r34F2, body.constant(int(31)));
                                 body.emit(assign(r37EE, add(r37EF, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r37EE, body.constant(0u), 0x01));

                                 body.emit(assign(r37E0, r37EE, 0x03));

                                 body.emit(assign(r37DF, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f37ED->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r37F1 = less(r379C, body.constant(int(0)));
                                 ir_if *f37F0 = new(mem_ctx) ir_if(operand(r37F1).val);
                                 exec_list *const f37F0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f37F0->then_instructions;

                                    ir_variable *const r37F2 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r37F2, r379F, 0x01));

                                    ir_variable *const r37F3 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r37F3, neg(r379C), 0x01));

                                    ir_variable *const r37F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r37F4);
                                    ir_variable *const r37F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r37F5);
                                    ir_variable *const r37F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r37F6);
                                    ir_variable *const r37F7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r37F8 = neg(r37F3);
                                    body.emit(assign(r37F7, bit_and(r37F8, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r37FA = equal(r37F3, body.constant(int(0)));
                                    ir_if *f37F9 = new(mem_ctx) ir_if(operand(r37FA).val);
                                    exec_list *const f37F9_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f37F9->then_instructions;

                                       body.emit(assign(r37F4, r379F, 0x01));

                                       body.emit(assign(r37F5, r379E, 0x01));

                                       body.emit(assign(r37F6, r379D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f37F9->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r37FC = less(r37F3, body.constant(int(32)));
                                       ir_if *f37FB = new(mem_ctx) ir_if(operand(r37FC).val);
                                       exec_list *const f37FB_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f37FB->then_instructions;

                                          body.emit(assign(r37F4, lshift(r379E, r37F7), 0x01));

                                          ir_expression *const r37FD = lshift(r379D, r37F7);
                                          ir_expression *const r37FE = rshift(r379E, r37F3);
                                          body.emit(assign(r37F5, bit_or(r37FD, r37FE), 0x01));

                                          body.emit(assign(r37F6, rshift(r379D, r37F3), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f37FB->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r3800 = equal(r37F3, body.constant(int(32)));
                                          ir_if *f37FF = new(mem_ctx) ir_if(operand(r3800).val);
                                          exec_list *const f37FF_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f37FF->then_instructions;

                                             body.emit(assign(r37F4, r379E, 0x01));

                                             body.emit(assign(r37F5, r379D, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f37FF->else_instructions;

                                             body.emit(assign(r37F2, bit_or(r379F, r379E), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r3802 = less(r37F3, body.constant(int(64)));
                                             ir_if *f3801 = new(mem_ctx) ir_if(operand(r3802).val);
                                             exec_list *const f3801_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3801->then_instructions;

                                                body.emit(assign(r37F4, lshift(r379D, r37F7), 0x01));

                                                ir_expression *const r3803 = bit_and(r37F3, body.constant(int(31)));
                                                body.emit(assign(r37F5, rshift(r379D, r3803), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3801->else_instructions;

                                                ir_variable *const r3804 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r3806 = equal(r37F3, body.constant(int(64)));
                                                ir_if *f3805 = new(mem_ctx) ir_if(operand(r3806).val);
                                                exec_list *const f3805_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f3805->then_instructions;

                                                   body.emit(assign(r3804, r379D, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f3805->else_instructions;

                                                   ir_expression *const r3807 = nequal(r379D, body.constant(0u));
                                                   ir_expression *const r3808 = expr(ir_unop_b2i, r3807);
                                                   body.emit(assign(r3804, expr(ir_unop_i2u, r3808), 0x01));


                                                body.instructions = f3805_parent_instructions;
                                                body.emit(f3805);

                                                /* END IF */

                                                body.emit(assign(r37F4, r3804, 0x01));

                                                body.emit(assign(r37F5, body.constant(0u), 0x01));


                                             body.instructions = f3801_parent_instructions;
                                             body.emit(f3801);

                                             /* END IF */


                                          body.instructions = f37FF_parent_instructions;
                                          body.emit(f37FF);

                                          /* END IF */

                                          body.emit(assign(r37F6, body.constant(0u), 0x01));


                                       body.instructions = f37FB_parent_instructions;
                                       body.emit(f37FB);

                                       /* END IF */

                                       ir_expression *const r3809 = nequal(r37F2, body.constant(0u));
                                       ir_expression *const r380A = expr(ir_unop_b2i, r3809);
                                       ir_expression *const r380B = expr(ir_unop_i2u, r380A);
                                       body.emit(assign(r37F4, bit_or(r37F4, r380B), 0x01));


                                    body.instructions = f37F9_parent_instructions;
                                    body.emit(f37F9);

                                    /* END IF */

                                    body.emit(assign(r37DC, r37F6, 0x01));

                                    body.emit(assign(r37DD, r37F5, 0x01));

                                    body.emit(assign(r37DE, r37F4, 0x01));

                                    body.emit(assign(r37DB, body.constant(int(0)), 0x01));

                                    body.emit(assign(r37E1, less(r37F4, body.constant(0u)), 0x01));


                                 body.instructions = f37F0_parent_instructions;
                                 body.emit(f37F0);

                                 /* END IF */


                              body.instructions = f37ED_parent_instructions;
                              body.emit(f37ED);

                              /* END IF */


                           body.instructions = f37E3_parent_instructions;
                           body.emit(f37E3);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f380C = new(mem_ctx) ir_if(operand(r37DF).val);
                           exec_list *const f380C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f380C->then_instructions;

                              /* IF CONDITION */
                              ir_if *f380D = new(mem_ctx) ir_if(operand(r37E1).val);
                              exec_list *const f380D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f380D->then_instructions;

                                 ir_variable *const r380E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r380E, add(r37DD, body.constant(1u)), 0x01));

                                 ir_expression *const r380F = less(r380E, r37DD);
                                 ir_expression *const r3810 = expr(ir_unop_b2i, r380F);
                                 ir_expression *const r3811 = expr(ir_unop_i2u, r3810);
                                 body.emit(assign(r37DC, add(r37DC, r3811), 0x01));

                                 ir_expression *const r3812 = equal(r37DE, body.constant(0u));
                                 ir_expression *const r3813 = expr(ir_unop_b2i, r3812);
                                 ir_expression *const r3814 = expr(ir_unop_i2u, r3813);
                                 ir_expression *const r3815 = add(r37DE, r3814);
                                 ir_expression *const r3816 = bit_and(r3815, body.constant(1u));
                                 ir_expression *const r3817 = expr(ir_unop_bit_not, r3816);
                                 body.emit(assign(r37DD, bit_and(r380E, r3817), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f380D->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3819 = bit_or(r37DC, r37DD);
                                 ir_expression *const r381A = equal(r3819, body.constant(0u));
                                 ir_if *f3818 = new(mem_ctx) ir_if(operand(r381A).val);
                                 exec_list *const f3818_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3818->then_instructions;

                                    body.emit(assign(r37DB, body.constant(int(0)), 0x01));


                                 body.instructions = f3818_parent_instructions;
                                 body.emit(f3818);

                                 /* END IF */


                              body.instructions = f380D_parent_instructions;
                              body.emit(f380D);

                              /* END IF */

                              ir_variable *const r381B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r381B);
                              ir_expression *const r381C = lshift(r34F2, body.constant(int(31)));
                              ir_expression *const r381D = expr(ir_unop_i2u, r37DB);
                              ir_expression *const r381E = lshift(r381D, body.constant(int(20)));
                              ir_expression *const r381F = add(r381C, r381E);
                              body.emit(assign(r381B, add(r381F, r37DC), 0x02));

                              body.emit(assign(r381B, r37DD, 0x01));

                              body.emit(assign(r37E0, r381B, 0x03));

                              body.emit(assign(r37DF, body.constant(false), 0x01));


                           body.instructions = f380C_parent_instructions;
                           body.emit(f380C);

                           /* END IF */

                           body.emit(assign(r34F3, r37E0, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3794->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3821 = less(r34FA, r34F8);
                           ir_if *f3820 = new(mem_ctx) ir_if(operand(r3821).val);
                           exec_list *const f3820_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3820->then_instructions;

                              ir_variable *const r3822 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r3823 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r3823, sub(r34F8, r34FA), 0x01));

                              ir_expression *const r3824 = sub(r34F7, r34F9);
                              ir_expression *const r3825 = less(r34F8, r34FA);
                              ir_expression *const r3826 = expr(ir_unop_b2i, r3825);
                              ir_expression *const r3827 = expr(ir_unop_i2u, r3826);
                              body.emit(assign(r3822, sub(r3824, r3827), 0x01));

                              body.emit(assign(r34F2, bit_xor(r34F2, body.constant(1u)), 0x01));

                              body.emit(assign(r34FB, add(r34F5, body.constant(int(-1))), 0x01));

                              ir_variable *const r3828 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r3828, add(r34FB, body.constant(int(-10))), 0x01));

                              ir_variable *const r3829 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r3829, r3822, 0x01));

                              ir_variable *const r382A = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r382A, r3823, 0x01));

                              ir_variable *const r382B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r382B);
                              ir_variable *const r382C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r382C);
                              /* IF CONDITION */
                              ir_expression *const r382E = equal(r3822, body.constant(0u));
                              ir_if *f382D = new(mem_ctx) ir_if(operand(r382E).val);
                              exec_list *const f382D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f382D->then_instructions;

                                 body.emit(assign(r3829, r3823, 0x01));

                                 body.emit(assign(r382A, body.constant(0u), 0x01));

                                 body.emit(assign(r3828, add(r3828, body.constant(int(-32))), 0x01));


                              body.instructions = f382D_parent_instructions;
                              body.emit(f382D);

                              /* END IF */

                              ir_variable *const r382F = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r382F, r3829, 0x01));

                              ir_variable *const r3830 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r3831 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r3831);
                              /* IF CONDITION */
                              ir_expression *const r3833 = equal(r3829, body.constant(0u));
                              ir_if *f3832 = new(mem_ctx) ir_if(operand(r3833).val);
                              exec_list *const f3832_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3832->then_instructions;

                                 body.emit(assign(r3830, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3832->else_instructions;

                                 body.emit(assign(r3831, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3835 = bit_and(r3829, body.constant(4294901760u));
                                 ir_expression *const r3836 = equal(r3835, body.constant(0u));
                                 ir_if *f3834 = new(mem_ctx) ir_if(operand(r3836).val);
                                 exec_list *const f3834_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3834->then_instructions;

                                    body.emit(assign(r3831, body.constant(int(16)), 0x01));

                                    body.emit(assign(r382F, lshift(r3829, body.constant(int(16))), 0x01));


                                 body.instructions = f3834_parent_instructions;
                                 body.emit(f3834);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r3838 = bit_and(r382F, body.constant(4278190080u));
                                 ir_expression *const r3839 = equal(r3838, body.constant(0u));
                                 ir_if *f3837 = new(mem_ctx) ir_if(operand(r3839).val);
                                 exec_list *const f3837_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3837->then_instructions;

                                    body.emit(assign(r3831, add(r3831, body.constant(int(8))), 0x01));

                                    body.emit(assign(r382F, lshift(r382F, body.constant(int(8))), 0x01));


                                 body.instructions = f3837_parent_instructions;
                                 body.emit(f3837);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r383B = bit_and(r382F, body.constant(4026531840u));
                                 ir_expression *const r383C = equal(r383B, body.constant(0u));
                                 ir_if *f383A = new(mem_ctx) ir_if(operand(r383C).val);
                                 exec_list *const f383A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f383A->then_instructions;

                                    body.emit(assign(r3831, add(r3831, body.constant(int(4))), 0x01));

                                    body.emit(assign(r382F, lshift(r382F, body.constant(int(4))), 0x01));


                                 body.instructions = f383A_parent_instructions;
                                 body.emit(f383A);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r383E = bit_and(r382F, body.constant(3221225472u));
                                 ir_expression *const r383F = equal(r383E, body.constant(0u));
                                 ir_if *f383D = new(mem_ctx) ir_if(operand(r383F).val);
                                 exec_list *const f383D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f383D->then_instructions;

                                    body.emit(assign(r3831, add(r3831, body.constant(int(2))), 0x01));

                                    body.emit(assign(r382F, lshift(r382F, body.constant(int(2))), 0x01));


                                 body.instructions = f383D_parent_instructions;
                                 body.emit(f383D);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r3841 = bit_and(r382F, body.constant(2147483648u));
                                 ir_expression *const r3842 = equal(r3841, body.constant(0u));
                                 ir_if *f3840 = new(mem_ctx) ir_if(operand(r3842).val);
                                 exec_list *const f3840_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3840->then_instructions;

                                    body.emit(assign(r3831, add(r3831, body.constant(int(1))), 0x01));


                                 body.instructions = f3840_parent_instructions;
                                 body.emit(f3840);

                                 /* END IF */

                                 body.emit(assign(r3830, r3831, 0x01));


                              body.instructions = f3832_parent_instructions;
                              body.emit(f3832);

                              /* END IF */

                              body.emit(assign(r382C, add(r3830, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3844 = lequal(body.constant(int(0)), r382C);
                              ir_if *f3843 = new(mem_ctx) ir_if(operand(r3844).val);
                              exec_list *const f3843_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3843->then_instructions;

                                 body.emit(assign(r382B, body.constant(0u), 0x01));

                                 ir_variable *const r3845 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r3845, lshift(r382A, r382C), 0x01));

                                 ir_variable *const r3846 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3848 = equal(r382C, body.constant(int(0)));
                                 ir_if *f3847 = new(mem_ctx) ir_if(operand(r3848).val);
                                 exec_list *const f3847_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3847->then_instructions;

                                    body.emit(assign(r3846, r3829, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3847->else_instructions;

                                    ir_expression *const r3849 = lshift(r3829, r382C);
                                    ir_expression *const r384A = neg(r382C);
                                    ir_expression *const r384B = bit_and(r384A, body.constant(int(31)));
                                    ir_expression *const r384C = rshift(r382A, r384B);
                                    body.emit(assign(r3846, bit_or(r3849, r384C), 0x01));


                                 body.instructions = f3847_parent_instructions;
                                 body.emit(f3847);

                                 /* END IF */

                                 body.emit(assign(r3829, r3846, 0x01));

                                 body.emit(assign(r382A, r3845, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3843->else_instructions;

                                 ir_variable *const r384D = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r384D, body.constant(0u), 0x01));

                                 ir_variable *const r384E = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r384E, neg(r382C), 0x01));

                                 ir_variable *const r384F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r384F);
                                 ir_variable *const r3850 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r3850);
                                 ir_variable *const r3851 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r3851);
                                 ir_variable *const r3852 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r3853 = neg(r384E);
                                 body.emit(assign(r3852, bit_and(r3853, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3855 = equal(r384E, body.constant(int(0)));
                                 ir_if *f3854 = new(mem_ctx) ir_if(operand(r3855).val);
                                 exec_list *const f3854_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3854->then_instructions;

                                    body.emit(assign(r384F, r384D, 0x01));

                                    body.emit(assign(r3850, r382A, 0x01));

                                    body.emit(assign(r3851, r3829, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3854->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3857 = less(r384E, body.constant(int(32)));
                                    ir_if *f3856 = new(mem_ctx) ir_if(operand(r3857).val);
                                    exec_list *const f3856_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3856->then_instructions;

                                       body.emit(assign(r384F, lshift(r382A, r3852), 0x01));

                                       ir_expression *const r3858 = lshift(r3829, r3852);
                                       ir_expression *const r3859 = rshift(r382A, r384E);
                                       body.emit(assign(r3850, bit_or(r3858, r3859), 0x01));

                                       body.emit(assign(r3851, rshift(r3829, r384E), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3856->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r385B = equal(r384E, body.constant(int(32)));
                                       ir_if *f385A = new(mem_ctx) ir_if(operand(r385B).val);
                                       exec_list *const f385A_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f385A->then_instructions;

                                          body.emit(assign(r384F, r382A, 0x01));

                                          body.emit(assign(r3850, r3829, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f385A->else_instructions;

                                          body.emit(assign(r384D, bit_or(body.constant(0u), r382A), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r385D = less(r384E, body.constant(int(64)));
                                          ir_if *f385C = new(mem_ctx) ir_if(operand(r385D).val);
                                          exec_list *const f385C_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f385C->then_instructions;

                                             body.emit(assign(r384F, lshift(r3829, r3852), 0x01));

                                             ir_expression *const r385E = bit_and(r384E, body.constant(int(31)));
                                             body.emit(assign(r3850, rshift(r3829, r385E), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f385C->else_instructions;

                                             ir_variable *const r385F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r3861 = equal(r384E, body.constant(int(64)));
                                             ir_if *f3860 = new(mem_ctx) ir_if(operand(r3861).val);
                                             exec_list *const f3860_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3860->then_instructions;

                                                body.emit(assign(r385F, r3829, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3860->else_instructions;

                                                ir_expression *const r3862 = nequal(r3829, body.constant(0u));
                                                ir_expression *const r3863 = expr(ir_unop_b2i, r3862);
                                                body.emit(assign(r385F, expr(ir_unop_i2u, r3863), 0x01));


                                             body.instructions = f3860_parent_instructions;
                                             body.emit(f3860);

                                             /* END IF */

                                             body.emit(assign(r384F, r385F, 0x01));

                                             body.emit(assign(r3850, body.constant(0u), 0x01));


                                          body.instructions = f385C_parent_instructions;
                                          body.emit(f385C);

                                          /* END IF */


                                       body.instructions = f385A_parent_instructions;
                                       body.emit(f385A);

                                       /* END IF */

                                       body.emit(assign(r3851, body.constant(0u), 0x01));


                                    body.instructions = f3856_parent_instructions;
                                    body.emit(f3856);

                                    /* END IF */

                                    ir_expression *const r3864 = nequal(r384D, body.constant(0u));
                                    ir_expression *const r3865 = expr(ir_unop_b2i, r3864);
                                    ir_expression *const r3866 = expr(ir_unop_i2u, r3865);
                                    body.emit(assign(r384F, bit_or(r384F, r3866), 0x01));


                                 body.instructions = f3854_parent_instructions;
                                 body.emit(f3854);

                                 /* END IF */

                                 body.emit(assign(r3829, r3851, 0x01));

                                 body.emit(assign(r382A, r3850, 0x01));

                                 body.emit(assign(r382B, r384F, 0x01));


                              body.instructions = f3843_parent_instructions;
                              body.emit(f3843);

                              /* END IF */

                              body.emit(assign(r3828, sub(r3828, r382C), 0x01));

                              ir_variable *const r3867 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r3867, r3828, 0x01));

                              ir_variable *const r3868 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r3868, r3829, 0x01));

                              ir_variable *const r3869 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r3869, r382A, 0x01));

                              ir_variable *const r386A = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r386A, r382B, 0x01));

                              ir_variable *const r386B = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r386B, body.constant(true), 0x01));

                              ir_variable *const r386C = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r386D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r386D);
                              ir_expression *const r386E = expr(ir_unop_u2i, r382B);
                              body.emit(assign(r386D, less(r386E, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3870 = lequal(body.constant(int(2045)), r3828);
                              ir_if *f386F = new(mem_ctx) ir_if(operand(r3870).val);
                              exec_list *const f386F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f386F->then_instructions;

                                 ir_variable *const r3871 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3873 = less(body.constant(int(2045)), r3828);
                                 ir_if *f3872 = new(mem_ctx) ir_if(operand(r3873).val);
                                 exec_list *const f3872_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3872->then_instructions;

                                    body.emit(assign(r3871, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3872->else_instructions;

                                    ir_variable *const r3874 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3876 = equal(r3828, body.constant(int(2045)));
                                    ir_if *f3875 = new(mem_ctx) ir_if(operand(r3876).val);
                                    exec_list *const f3875_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3875->then_instructions;

                                       ir_expression *const r3877 = equal(body.constant(2097151u), r3829);
                                       ir_expression *const r3878 = equal(body.constant(4294967295u), r382A);
                                       body.emit(assign(r3874, logic_and(r3877, r3878), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3875->else_instructions;

                                       body.emit(assign(r3874, body.constant(false), 0x01));


                                    body.instructions = f3875_parent_instructions;
                                    body.emit(f3875);

                                    /* END IF */

                                    body.emit(assign(r3871, logic_and(r3874, r386D), 0x01));


                                 body.instructions = f3872_parent_instructions;
                                 body.emit(f3872);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f3879 = new(mem_ctx) ir_if(operand(r3871).val);
                                 exec_list *const f3879_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3879->then_instructions;

                                    ir_variable *const r387A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r387A);
                                    ir_expression *const r387B = lshift(r34F2, body.constant(int(31)));
                                    body.emit(assign(r387A, add(r387B, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r387A, body.constant(0u), 0x01));

                                    body.emit(assign(r386C, r387A, 0x03));

                                    body.emit(assign(r386B, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3879->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r387D = less(r3828, body.constant(int(0)));
                                    ir_if *f387C = new(mem_ctx) ir_if(operand(r387D).val);
                                    exec_list *const f387C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f387C->then_instructions;

                                       ir_variable *const r387E = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r387E, r382B, 0x01));

                                       ir_variable *const r387F = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r387F, neg(r3828), 0x01));

                                       ir_variable *const r3880 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r3880);
                                       ir_variable *const r3881 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r3881);
                                       ir_variable *const r3882 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r3882);
                                       ir_variable *const r3883 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r3884 = neg(r387F);
                                       body.emit(assign(r3883, bit_and(r3884, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r3886 = equal(r387F, body.constant(int(0)));
                                       ir_if *f3885 = new(mem_ctx) ir_if(operand(r3886).val);
                                       exec_list *const f3885_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3885->then_instructions;

                                          body.emit(assign(r3880, r382B, 0x01));

                                          body.emit(assign(r3881, r382A, 0x01));

                                          body.emit(assign(r3882, r3829, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3885->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r3888 = less(r387F, body.constant(int(32)));
                                          ir_if *f3887 = new(mem_ctx) ir_if(operand(r3888).val);
                                          exec_list *const f3887_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3887->then_instructions;

                                             body.emit(assign(r3880, lshift(r382A, r3883), 0x01));

                                             ir_expression *const r3889 = lshift(r3829, r3883);
                                             ir_expression *const r388A = rshift(r382A, r387F);
                                             body.emit(assign(r3881, bit_or(r3889, r388A), 0x01));

                                             body.emit(assign(r3882, rshift(r3829, r387F), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3887->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r388C = equal(r387F, body.constant(int(32)));
                                             ir_if *f388B = new(mem_ctx) ir_if(operand(r388C).val);
                                             exec_list *const f388B_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f388B->then_instructions;

                                                body.emit(assign(r3880, r382A, 0x01));

                                                body.emit(assign(r3881, r3829, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f388B->else_instructions;

                                                body.emit(assign(r387E, bit_or(r382B, r382A), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r388E = less(r387F, body.constant(int(64)));
                                                ir_if *f388D = new(mem_ctx) ir_if(operand(r388E).val);
                                                exec_list *const f388D_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f388D->then_instructions;

                                                   body.emit(assign(r3880, lshift(r3829, r3883), 0x01));

                                                   ir_expression *const r388F = bit_and(r387F, body.constant(int(31)));
                                                   body.emit(assign(r3881, rshift(r3829, r388F), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f388D->else_instructions;

                                                   ir_variable *const r3890 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r3892 = equal(r387F, body.constant(int(64)));
                                                   ir_if *f3891 = new(mem_ctx) ir_if(operand(r3892).val);
                                                   exec_list *const f3891_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f3891->then_instructions;

                                                      body.emit(assign(r3890, r3829, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f3891->else_instructions;

                                                      ir_expression *const r3893 = nequal(r3829, body.constant(0u));
                                                      ir_expression *const r3894 = expr(ir_unop_b2i, r3893);
                                                      body.emit(assign(r3890, expr(ir_unop_i2u, r3894), 0x01));


                                                   body.instructions = f3891_parent_instructions;
                                                   body.emit(f3891);

                                                   /* END IF */

                                                   body.emit(assign(r3880, r3890, 0x01));

                                                   body.emit(assign(r3881, body.constant(0u), 0x01));


                                                body.instructions = f388D_parent_instructions;
                                                body.emit(f388D);

                                                /* END IF */


                                             body.instructions = f388B_parent_instructions;
                                             body.emit(f388B);

                                             /* END IF */

                                             body.emit(assign(r3882, body.constant(0u), 0x01));


                                          body.instructions = f3887_parent_instructions;
                                          body.emit(f3887);

                                          /* END IF */

                                          ir_expression *const r3895 = nequal(r387E, body.constant(0u));
                                          ir_expression *const r3896 = expr(ir_unop_b2i, r3895);
                                          ir_expression *const r3897 = expr(ir_unop_i2u, r3896);
                                          body.emit(assign(r3880, bit_or(r3880, r3897), 0x01));


                                       body.instructions = f3885_parent_instructions;
                                       body.emit(f3885);

                                       /* END IF */

                                       body.emit(assign(r3868, r3882, 0x01));

                                       body.emit(assign(r3869, r3881, 0x01));

                                       body.emit(assign(r386A, r3880, 0x01));

                                       body.emit(assign(r3867, body.constant(int(0)), 0x01));

                                       body.emit(assign(r386D, less(r3880, body.constant(0u)), 0x01));


                                    body.instructions = f387C_parent_instructions;
                                    body.emit(f387C);

                                    /* END IF */


                                 body.instructions = f3879_parent_instructions;
                                 body.emit(f3879);

                                 /* END IF */


                              body.instructions = f386F_parent_instructions;
                              body.emit(f386F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f3898 = new(mem_ctx) ir_if(operand(r386B).val);
                              exec_list *const f3898_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3898->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f3899 = new(mem_ctx) ir_if(operand(r386D).val);
                                 exec_list *const f3899_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3899->then_instructions;

                                    ir_variable *const r389A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r389A, add(r3869, body.constant(1u)), 0x01));

                                    ir_expression *const r389B = less(r389A, r3869);
                                    ir_expression *const r389C = expr(ir_unop_b2i, r389B);
                                    ir_expression *const r389D = expr(ir_unop_i2u, r389C);
                                    body.emit(assign(r3868, add(r3868, r389D), 0x01));

                                    ir_expression *const r389E = equal(r386A, body.constant(0u));
                                    ir_expression *const r389F = expr(ir_unop_b2i, r389E);
                                    ir_expression *const r38A0 = expr(ir_unop_i2u, r389F);
                                    ir_expression *const r38A1 = add(r386A, r38A0);
                                    ir_expression *const r38A2 = bit_and(r38A1, body.constant(1u));
                                    ir_expression *const r38A3 = expr(ir_unop_bit_not, r38A2);
                                    body.emit(assign(r3869, bit_and(r389A, r38A3), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3899->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r38A5 = bit_or(r3868, r3869);
                                    ir_expression *const r38A6 = equal(r38A5, body.constant(0u));
                                    ir_if *f38A4 = new(mem_ctx) ir_if(operand(r38A6).val);
                                    exec_list *const f38A4_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f38A4->then_instructions;

                                       body.emit(assign(r3867, body.constant(int(0)), 0x01));


                                    body.instructions = f38A4_parent_instructions;
                                    body.emit(f38A4);

                                    /* END IF */


                                 body.instructions = f3899_parent_instructions;
                                 body.emit(f3899);

                                 /* END IF */

                                 ir_variable *const r38A7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r38A7);
                                 ir_expression *const r38A8 = lshift(r34F2, body.constant(int(31)));
                                 ir_expression *const r38A9 = expr(ir_unop_i2u, r3867);
                                 ir_expression *const r38AA = lshift(r38A9, body.constant(int(20)));
                                 ir_expression *const r38AB = add(r38A8, r38AA);
                                 body.emit(assign(r38A7, add(r38AB, r3868), 0x02));

                                 body.emit(assign(r38A7, r3869, 0x01));

                                 body.emit(assign(r386C, r38A7, 0x03));

                                 body.emit(assign(r386B, body.constant(false), 0x01));


                              body.instructions = f3898_parent_instructions;
                              body.emit(f3898);

                              /* END IF */

                              body.emit(assign(r34F3, r386C, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3820->else_instructions;

                              ir_variable *const r38AC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r38AC);
                              body.emit(assign(r38AC, body.constant(0u), 0x02));

                              body.emit(assign(r38AC, body.constant(0u), 0x01));

                              body.emit(assign(r34F3, r38AC, 0x03));


                           body.instructions = f3820_parent_instructions;
                           body.emit(f3820);

                           /* END IF */


                        body.instructions = f3794_parent_instructions;
                        body.emit(f3794);

                        /* END IF */


                     body.instructions = f3708_parent_instructions;
                     body.emit(f3708);

                     /* END IF */


                  body.instructions = f367C_parent_instructions;
                  body.emit(f367C);

                  /* END IF */


               body.instructions = f3667_parent_instructions;
               body.emit(f3667);

               /* END IF */


            body.instructions = f35B8_parent_instructions;
            body.emit(f35B8);

            /* END IF */


         body.instructions = f3507_parent_instructions;
         body.emit(f3507);

         /* END IF */

         body.emit(assign(r34EE, r34F3, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f34F0->else_instructions;

         ir_variable *const r38AD = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r38AD, body.constant(true), 0x01));

         ir_variable *const r38AE = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r38AF = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r38AF);
         ir_variable *const r38B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r38B0);
         ir_variable *const r38B1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r38B1);
         ir_variable *const r38B2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r38B2);
         ir_variable *const r38B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r38B3);
         ir_variable *const r38B4 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r38B4);
         ir_variable *const r38B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r38B5);
         ir_variable *const r38B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r38B6);
         body.emit(assign(r38B6, body.constant(0u), 0x01));

         body.emit(assign(r38B5, body.constant(0u), 0x01));

         ir_variable *const r38B7 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r38B7, swizzle_x(r34B9), 0x01));

         body.emit(assign(r38B3, r38B7, 0x01));

         ir_variable *const r38B8 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r38B8, bit_and(swizzle_y(r34B9), body.constant(1048575u)), 0x01));

         body.emit(assign(r38B2, r38B8, 0x01));

         ir_variable *const r38B9 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r38B9, body.constant(0u), 0x01));

         body.emit(assign(r38B1, body.constant(0u), 0x01));

         body.emit(assign(r38B0, body.constant(0u), 0x01));

         ir_variable *const r38BA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r38BB = rshift(swizzle_y(r34B9), body.constant(int(20)));
         ir_expression *const r38BC = bit_and(r38BB, body.constant(2047u));
         body.emit(assign(r38BA, expr(ir_unop_u2i, r38BC), 0x01));

         ir_variable *const r38BD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r38BD, body.constant(int(1023)), 0x01));

         ir_variable *const r38BE = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r38BE, add(r38BA, body.constant(int(-1023))), 0x01));

         body.emit(assign(r38AF, r38BE, 0x01));

         /* IF CONDITION */
         ir_expression *const r38C0 = less(body.constant(int(0)), r38BE);
         ir_if *f38BF = new(mem_ctx) ir_if(operand(r38C0).val);
         exec_list *const f38BF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f38BF->then_instructions;

            /* IF CONDITION */
            ir_expression *const r38C2 = equal(r38BA, body.constant(int(2047)));
            ir_if *f38C1 = new(mem_ctx) ir_if(operand(r38C2).val);
            exec_list *const f38C1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f38C1->then_instructions;

               /* IF CONDITION */
               ir_expression *const r38C4 = bit_or(r38B8, swizzle_x(r34B9));
               ir_expression *const r38C5 = nequal(r38C4, body.constant(0u));
               ir_if *f38C3 = new(mem_ctx) ir_if(operand(r38C5).val);
               exec_list *const f38C3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f38C3->then_instructions;

                  ir_variable *const r38C6 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r38C6, swizzle_x(r34B9), 0x01));

                  ir_variable *const r38C7 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r38C7, body.constant(0u), 0x01));

                  ir_variable *const r38C8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r38C6, bit_or(swizzle_y(r34B9), body.constant(524288u)), 0x02));

                  body.emit(assign(r38C7, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r38CA = lshift(swizzle_y(r34B9), body.constant(int(1)));
                  ir_expression *const r38CB = lequal(body.constant(4292870144u), r38CA);
                  ir_expression *const r38CC = nequal(swizzle_x(r34B9), body.constant(0u));
                  ir_expression *const r38CD = bit_and(swizzle_y(r34B9), body.constant(1048575u));
                  ir_expression *const r38CE = nequal(r38CD, body.constant(0u));
                  ir_expression *const r38CF = logic_or(r38CC, r38CE);
                  ir_expression *const r38D0 = logic_and(r38CB, r38CF);
                  ir_if *f38C9 = new(mem_ctx) ir_if(operand(r38D0).val);
                  exec_list *const f38C9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f38C9->then_instructions;

                     body.emit(assign(r38C8, r38C6, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f38C9->else_instructions;

                     body.emit(assign(r38C8, r38C7, 0x03));


                  body.instructions = f38C9_parent_instructions;
                  body.emit(f38C9);

                  /* END IF */

                  body.emit(assign(r38AE, r38C8, 0x03));

                  body.emit(assign(r38AD, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f38C3->else_instructions;

                  body.emit(assign(r38AE, r34B9, 0x03));

                  body.emit(assign(r38AD, body.constant(false), 0x01));


               body.instructions = f38C3_parent_instructions;
               body.emit(f38C3);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f38C1->else_instructions;

               body.emit(assign(r38B0, body.constant(1048576u), 0x01));

               ir_variable *const r38D1 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r38D1, body.constant(0u), 0x01));

               ir_variable *const r38D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r38D2);
               ir_variable *const r38D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r38D3);
               ir_variable *const r38D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r38D4);
               ir_variable *const r38D5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r38D6 = neg(r38BE);
               body.emit(assign(r38D5, bit_and(r38D6, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r38D8 = equal(r38BE, body.constant(int(0)));
               ir_if *f38D7 = new(mem_ctx) ir_if(operand(r38D8).val);
               exec_list *const f38D7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f38D7->then_instructions;

                  body.emit(assign(r38D2, r38D1, 0x01));

                  body.emit(assign(r38D3, body.constant(0u), 0x01));

                  body.emit(assign(r38D4, r38B0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f38D7->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r38DA = less(r38BE, body.constant(int(32)));
                  ir_if *f38D9 = new(mem_ctx) ir_if(operand(r38DA).val);
                  exec_list *const f38D9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f38D9->then_instructions;

                     body.emit(assign(r38D2, body.constant(0u), 0x01));

                     ir_expression *const r38DB = lshift(body.constant(1048576u), r38D5);
                     body.emit(assign(r38D3, bit_or(r38DB, body.constant(0u)), 0x01));

                     body.emit(assign(r38D4, rshift(body.constant(1048576u), r38BE), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f38D9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r38DD = equal(r38BE, body.constant(int(32)));
                     ir_if *f38DC = new(mem_ctx) ir_if(operand(r38DD).val);
                     exec_list *const f38DC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f38DC->then_instructions;

                        body.emit(assign(r38D2, body.constant(0u), 0x01));

                        body.emit(assign(r38D3, r38B0, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f38DC->else_instructions;

                        body.emit(assign(r38D1, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r38DF = less(r38BE, body.constant(int(64)));
                        ir_if *f38DE = new(mem_ctx) ir_if(operand(r38DF).val);
                        exec_list *const f38DE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f38DE->then_instructions;

                           body.emit(assign(r38D2, lshift(body.constant(1048576u), r38D5), 0x01));

                           ir_expression *const r38E0 = bit_and(r38BE, body.constant(int(31)));
                           body.emit(assign(r38D3, rshift(body.constant(1048576u), r38E0), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f38DE->else_instructions;

                           ir_variable *const r38E1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r38E3 = equal(r38BE, body.constant(int(64)));
                           ir_if *f38E2 = new(mem_ctx) ir_if(operand(r38E3).val);
                           exec_list *const f38E2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f38E2->then_instructions;

                              body.emit(assign(r38E1, r38B0, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f38E2->else_instructions;

                              body.emit(assign(r38E1, body.constant(1u), 0x01));


                           body.instructions = f38E2_parent_instructions;
                           body.emit(f38E2);

                           /* END IF */

                           body.emit(assign(r38D2, r38E1, 0x01));

                           body.emit(assign(r38D3, body.constant(0u), 0x01));


                        body.instructions = f38DE_parent_instructions;
                        body.emit(f38DE);

                        /* END IF */


                     body.instructions = f38DC_parent_instructions;
                     body.emit(f38DC);

                     /* END IF */

                     body.emit(assign(r38D4, body.constant(0u), 0x01));


                  body.instructions = f38D9_parent_instructions;
                  body.emit(f38D9);

                  /* END IF */

                  ir_expression *const r38E4 = nequal(r38D1, body.constant(0u));
                  ir_expression *const r38E5 = expr(ir_unop_b2i, r38E4);
                  ir_expression *const r38E6 = expr(ir_unop_i2u, r38E5);
                  body.emit(assign(r38D2, bit_or(r38D2, r38E6), 0x01));


               body.instructions = f38D7_parent_instructions;
               body.emit(f38D7);

               /* END IF */

               body.emit(assign(r38B0, r38D4, 0x01));

               body.emit(assign(r38B1, r38D3, 0x01));

               body.emit(assign(r38B5, r38D2, 0x01));

               body.emit(assign(r38B4, r38BA, 0x01));


            body.instructions = f38C1_parent_instructions;
            body.emit(f38C1);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f38BF->else_instructions;

            /* IF CONDITION */
            ir_expression *const r38E8 = less(r38BE, body.constant(int(0)));
            ir_if *f38E7 = new(mem_ctx) ir_if(operand(r38E8).val);
            exec_list *const f38E7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f38E7->then_instructions;

               /* IF CONDITION */
               ir_expression *const r38EA = equal(r38BA, body.constant(int(0)));
               ir_if *f38E9 = new(mem_ctx) ir_if(operand(r38EA).val);
               exec_list *const f38E9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f38E9->then_instructions;

                  body.emit(assign(r38AF, add(r38BE, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f38E9->else_instructions;

                  body.emit(assign(r38B2, bit_or(r38B8, body.constant(1048576u)), 0x01));


               body.instructions = f38E9_parent_instructions;
               body.emit(f38E9);

               /* END IF */

               ir_variable *const r38EB = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r38EB, body.constant(0u), 0x01));

               ir_variable *const r38EC = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r38EC, neg(r38AF), 0x01));

               ir_variable *const r38ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r38ED);
               ir_variable *const r38EE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r38EE);
               ir_variable *const r38EF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r38EF);
               ir_variable *const r38F0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r38F1 = neg(r38EC);
               body.emit(assign(r38F0, bit_and(r38F1, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r38F3 = equal(r38EC, body.constant(int(0)));
               ir_if *f38F2 = new(mem_ctx) ir_if(operand(r38F3).val);
               exec_list *const f38F2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f38F2->then_instructions;

                  body.emit(assign(r38ED, r38EB, 0x01));

                  body.emit(assign(r38EE, r38B7, 0x01));

                  body.emit(assign(r38EF, r38B2, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f38F2->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r38F5 = less(r38EC, body.constant(int(32)));
                  ir_if *f38F4 = new(mem_ctx) ir_if(operand(r38F5).val);
                  exec_list *const f38F4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f38F4->then_instructions;

                     body.emit(assign(r38ED, lshift(swizzle_x(r34B9), r38F0), 0x01));

                     ir_expression *const r38F6 = lshift(r38B2, r38F0);
                     ir_expression *const r38F7 = rshift(swizzle_x(r34B9), r38EC);
                     body.emit(assign(r38EE, bit_or(r38F6, r38F7), 0x01));

                     body.emit(assign(r38EF, rshift(r38B2, r38EC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f38F4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r38F9 = equal(r38EC, body.constant(int(32)));
                     ir_if *f38F8 = new(mem_ctx) ir_if(operand(r38F9).val);
                     exec_list *const f38F8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f38F8->then_instructions;

                        body.emit(assign(r38ED, r38B7, 0x01));

                        body.emit(assign(r38EE, r38B2, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f38F8->else_instructions;

                        body.emit(assign(r38EB, bit_or(body.constant(0u), swizzle_x(r34B9)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r38FB = less(r38EC, body.constant(int(64)));
                        ir_if *f38FA = new(mem_ctx) ir_if(operand(r38FB).val);
                        exec_list *const f38FA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f38FA->then_instructions;

                           body.emit(assign(r38ED, lshift(r38B2, r38F0), 0x01));

                           ir_expression *const r38FC = bit_and(r38EC, body.constant(int(31)));
                           body.emit(assign(r38EE, rshift(r38B2, r38FC), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f38FA->else_instructions;

                           ir_variable *const r38FD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r38FF = equal(r38EC, body.constant(int(64)));
                           ir_if *f38FE = new(mem_ctx) ir_if(operand(r38FF).val);
                           exec_list *const f38FE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f38FE->then_instructions;

                              body.emit(assign(r38FD, r38B2, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f38FE->else_instructions;

                              ir_expression *const r3900 = nequal(r38B2, body.constant(0u));
                              ir_expression *const r3901 = expr(ir_unop_b2i, r3900);
                              body.emit(assign(r38FD, expr(ir_unop_i2u, r3901), 0x01));


                           body.instructions = f38FE_parent_instructions;
                           body.emit(f38FE);

                           /* END IF */

                           body.emit(assign(r38ED, r38FD, 0x01));

                           body.emit(assign(r38EE, body.constant(0u), 0x01));


                        body.instructions = f38FA_parent_instructions;
                        body.emit(f38FA);

                        /* END IF */


                     body.instructions = f38F8_parent_instructions;
                     body.emit(f38F8);

                     /* END IF */

                     body.emit(assign(r38EF, body.constant(0u), 0x01));


                  body.instructions = f38F4_parent_instructions;
                  body.emit(f38F4);

                  /* END IF */

                  ir_expression *const r3902 = nequal(r38EB, body.constant(0u));
                  ir_expression *const r3903 = expr(ir_unop_b2i, r3902);
                  ir_expression *const r3904 = expr(ir_unop_i2u, r3903);
                  body.emit(assign(r38ED, bit_or(r38ED, r3904), 0x01));


               body.instructions = f38F2_parent_instructions;
               body.emit(f38F2);

               /* END IF */

               body.emit(assign(r38B2, r38EF, 0x01));

               body.emit(assign(r38B3, r38EE, 0x01));

               body.emit(assign(r38B5, r38ED, 0x01));

               body.emit(assign(r38B4, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f38E7->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3906 = equal(r38BA, body.constant(int(2047)));
               ir_if *f3905 = new(mem_ctx) ir_if(operand(r3906).val);
               exec_list *const f3905_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3905->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3908 = bit_or(r38B2, r38B3);
                  ir_expression *const r3909 = bit_or(r38B0, r38B1);
                  ir_expression *const r390A = bit_or(r3908, r3909);
                  ir_expression *const r390B = nequal(r390A, body.constant(0u));
                  ir_if *f3907 = new(mem_ctx) ir_if(operand(r390B).val);
                  exec_list *const f3907_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3907->then_instructions;

                     ir_variable *const r390C = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r390C, swizzle_x(r34B9), 0x01));

                     ir_variable *const r390D = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r390D, body.constant(0u), 0x01));

                     ir_variable *const r390E = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r390C, bit_or(swizzle_y(r34B9), body.constant(524288u)), 0x02));

                     body.emit(assign(r390D, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r3910 = lshift(swizzle_y(r34B9), body.constant(int(1)));
                     ir_expression *const r3911 = lequal(body.constant(4292870144u), r3910);
                     ir_expression *const r3912 = nequal(swizzle_x(r34B9), body.constant(0u));
                     ir_expression *const r3913 = bit_and(swizzle_y(r34B9), body.constant(1048575u));
                     ir_expression *const r3914 = nequal(r3913, body.constant(0u));
                     ir_expression *const r3915 = logic_or(r3912, r3914);
                     ir_expression *const r3916 = logic_and(r3911, r3915);
                     ir_if *f390F = new(mem_ctx) ir_if(operand(r3916).val);
                     exec_list *const f390F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f390F->then_instructions;

                        body.emit(assign(r390E, r390C, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f390F->else_instructions;

                        body.emit(assign(r390E, r390D, 0x03));


                     body.instructions = f390F_parent_instructions;
                     body.emit(f390F);

                     /* END IF */

                     body.emit(assign(r38AE, r390E, 0x03));

                     body.emit(assign(r38AD, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3907->else_instructions;

                     body.emit(assign(r38AE, r34B9, 0x03));

                     body.emit(assign(r38AD, body.constant(false), 0x01));


                  body.instructions = f3907_parent_instructions;
                  body.emit(f3907);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3905->else_instructions;

                  ir_variable *const r3917 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r3918 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3918, add(r38B3, r38B1), 0x01));

                  ir_expression *const r3919 = add(r38B2, r38B0);
                  ir_expression *const r391A = less(r3918, r38B3);
                  ir_expression *const r391B = expr(ir_unop_b2i, r391A);
                  ir_expression *const r391C = expr(ir_unop_i2u, r391B);
                  body.emit(assign(r3917, add(r3919, r391C), 0x01));

                  body.emit(assign(r38B6, r3917, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r391E = equal(r38BA, body.constant(int(0)));
                  ir_if *f391D = new(mem_ctx) ir_if(operand(r391E).val);
                  exec_list *const f391D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f391D->then_instructions;

                     ir_variable *const r391F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r391F);
                     ir_expression *const r3920 = lshift(r34EF, body.constant(int(31)));
                     body.emit(assign(r391F, add(r3920, r3917), 0x02));

                     body.emit(assign(r391F, r3918, 0x01));

                     body.emit(assign(r38AE, r391F, 0x03));

                     body.emit(assign(r38AD, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f391D->else_instructions;

                     body.emit(assign(r38B6, bit_or(r3917, body.constant(2097152u)), 0x01));

                     body.emit(assign(r38B4, r38BA, 0x01));

                     ir_variable *const r3921 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r3921);
                     ir_variable *const r3922 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3922);
                     ir_variable *const r3923 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3923);
                     body.emit(assign(r3921, lshift(r3918, body.constant(int(31))), 0x01));

                     ir_expression *const r3924 = lshift(r38B6, body.constant(int(31)));
                     ir_expression *const r3925 = rshift(r3918, body.constant(int(1)));
                     body.emit(assign(r3922, bit_or(r3924, r3925), 0x01));

                     body.emit(assign(r3923, rshift(r38B6, body.constant(int(1))), 0x01));

                     body.emit(assign(r3921, bit_or(r3921, body.constant(0u)), 0x01));

                     body.emit(assign(r38B6, r3923, 0x01));

                     body.emit(assign(r38B5, r3921, 0x01));

                     ir_variable *const r3926 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r3926, r38BA, 0x01));

                     ir_variable *const r3927 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r3927, r3923, 0x01));

                     ir_variable *const r3928 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r3928, r3922, 0x01));

                     ir_variable *const r3929 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r3929, r3921, 0x01));

                     ir_variable *const r392A = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r392A, body.constant(true), 0x01));

                     ir_variable *const r392B = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r392C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r392C);
                     ir_expression *const r392D = expr(ir_unop_u2i, r3921);
                     body.emit(assign(r392C, less(r392D, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r392F = lequal(body.constant(int(2045)), r38BA);
                     ir_if *f392E = new(mem_ctx) ir_if(operand(r392F).val);
                     exec_list *const f392E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f392E->then_instructions;

                        ir_variable *const r3930 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3932 = less(body.constant(int(2045)), r38BA);
                        ir_if *f3931 = new(mem_ctx) ir_if(operand(r3932).val);
                        exec_list *const f3931_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3931->then_instructions;

                           body.emit(assign(r3930, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3931->else_instructions;

                           ir_variable *const r3933 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3935 = equal(r38BA, body.constant(int(2045)));
                           ir_if *f3934 = new(mem_ctx) ir_if(operand(r3935).val);
                           exec_list *const f3934_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3934->then_instructions;

                              ir_expression *const r3936 = equal(body.constant(2097151u), r3923);
                              ir_expression *const r3937 = equal(body.constant(4294967295u), r3922);
                              body.emit(assign(r3933, logic_and(r3936, r3937), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3934->else_instructions;

                              body.emit(assign(r3933, body.constant(false), 0x01));


                           body.instructions = f3934_parent_instructions;
                           body.emit(f3934);

                           /* END IF */

                           body.emit(assign(r3930, logic_and(r3933, r392C), 0x01));


                        body.instructions = f3931_parent_instructions;
                        body.emit(f3931);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f3938 = new(mem_ctx) ir_if(operand(r3930).val);
                        exec_list *const f3938_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3938->then_instructions;

                           ir_variable *const r3939 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3939);
                           ir_expression *const r393A = lshift(r34EF, body.constant(int(31)));
                           body.emit(assign(r3939, add(r393A, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r3939, body.constant(0u), 0x01));

                           body.emit(assign(r392B, r3939, 0x03));

                           body.emit(assign(r392A, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3938->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r393C = less(r38BA, body.constant(int(0)));
                           ir_if *f393B = new(mem_ctx) ir_if(operand(r393C).val);
                           exec_list *const f393B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f393B->then_instructions;

                              ir_variable *const r393D = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r393D, r3921, 0x01));

                              ir_variable *const r393E = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r393E, neg(r38BA), 0x01));

                              ir_variable *const r393F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r393F);
                              ir_variable *const r3940 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r3940);
                              ir_variable *const r3941 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r3941);
                              ir_variable *const r3942 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r3943 = neg(r393E);
                              body.emit(assign(r3942, bit_and(r3943, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3945 = equal(r393E, body.constant(int(0)));
                              ir_if *f3944 = new(mem_ctx) ir_if(operand(r3945).val);
                              exec_list *const f3944_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3944->then_instructions;

                                 body.emit(assign(r393F, r3921, 0x01));

                                 body.emit(assign(r3940, r3922, 0x01));

                                 body.emit(assign(r3941, r3923, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3944->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3947 = less(r393E, body.constant(int(32)));
                                 ir_if *f3946 = new(mem_ctx) ir_if(operand(r3947).val);
                                 exec_list *const f3946_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3946->then_instructions;

                                    body.emit(assign(r393F, lshift(r3922, r3942), 0x01));

                                    ir_expression *const r3948 = lshift(r3923, r3942);
                                    ir_expression *const r3949 = rshift(r3922, r393E);
                                    body.emit(assign(r3940, bit_or(r3948, r3949), 0x01));

                                    body.emit(assign(r3941, rshift(r3923, r393E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3946->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r394B = equal(r393E, body.constant(int(32)));
                                    ir_if *f394A = new(mem_ctx) ir_if(operand(r394B).val);
                                    exec_list *const f394A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f394A->then_instructions;

                                       body.emit(assign(r393F, r3922, 0x01));

                                       body.emit(assign(r3940, r3923, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f394A->else_instructions;

                                       body.emit(assign(r393D, bit_or(r3921, r3922), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r394D = less(r393E, body.constant(int(64)));
                                       ir_if *f394C = new(mem_ctx) ir_if(operand(r394D).val);
                                       exec_list *const f394C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f394C->then_instructions;

                                          body.emit(assign(r393F, lshift(r3923, r3942), 0x01));

                                          ir_expression *const r394E = bit_and(r393E, body.constant(int(31)));
                                          body.emit(assign(r3940, rshift(r3923, r394E), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f394C->else_instructions;

                                          ir_variable *const r394F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3951 = equal(r393E, body.constant(int(64)));
                                          ir_if *f3950 = new(mem_ctx) ir_if(operand(r3951).val);
                                          exec_list *const f3950_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3950->then_instructions;

                                             body.emit(assign(r394F, r3923, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3950->else_instructions;

                                             ir_expression *const r3952 = nequal(r3923, body.constant(0u));
                                             ir_expression *const r3953 = expr(ir_unop_b2i, r3952);
                                             body.emit(assign(r394F, expr(ir_unop_i2u, r3953), 0x01));


                                          body.instructions = f3950_parent_instructions;
                                          body.emit(f3950);

                                          /* END IF */

                                          body.emit(assign(r393F, r394F, 0x01));

                                          body.emit(assign(r3940, body.constant(0u), 0x01));


                                       body.instructions = f394C_parent_instructions;
                                       body.emit(f394C);

                                       /* END IF */


                                    body.instructions = f394A_parent_instructions;
                                    body.emit(f394A);

                                    /* END IF */

                                    body.emit(assign(r3941, body.constant(0u), 0x01));


                                 body.instructions = f3946_parent_instructions;
                                 body.emit(f3946);

                                 /* END IF */

                                 ir_expression *const r3954 = nequal(r393D, body.constant(0u));
                                 ir_expression *const r3955 = expr(ir_unop_b2i, r3954);
                                 ir_expression *const r3956 = expr(ir_unop_i2u, r3955);
                                 body.emit(assign(r393F, bit_or(r393F, r3956), 0x01));


                              body.instructions = f3944_parent_instructions;
                              body.emit(f3944);

                              /* END IF */

                              body.emit(assign(r3927, r3941, 0x01));

                              body.emit(assign(r3928, r3940, 0x01));

                              body.emit(assign(r3929, r393F, 0x01));

                              body.emit(assign(r3926, body.constant(int(0)), 0x01));

                              body.emit(assign(r392C, less(r393F, body.constant(0u)), 0x01));


                           body.instructions = f393B_parent_instructions;
                           body.emit(f393B);

                           /* END IF */


                        body.instructions = f3938_parent_instructions;
                        body.emit(f3938);

                        /* END IF */


                     body.instructions = f392E_parent_instructions;
                     body.emit(f392E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f3957 = new(mem_ctx) ir_if(operand(r392A).val);
                     exec_list *const f3957_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3957->then_instructions;

                        /* IF CONDITION */
                        ir_if *f3958 = new(mem_ctx) ir_if(operand(r392C).val);
                        exec_list *const f3958_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3958->then_instructions;

                           ir_variable *const r3959 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r3959, add(r3928, body.constant(1u)), 0x01));

                           ir_expression *const r395A = less(r3959, r3928);
                           ir_expression *const r395B = expr(ir_unop_b2i, r395A);
                           ir_expression *const r395C = expr(ir_unop_i2u, r395B);
                           body.emit(assign(r3927, add(r3927, r395C), 0x01));

                           ir_expression *const r395D = equal(r3929, body.constant(0u));
                           ir_expression *const r395E = expr(ir_unop_b2i, r395D);
                           ir_expression *const r395F = expr(ir_unop_i2u, r395E);
                           ir_expression *const r3960 = add(r3929, r395F);
                           ir_expression *const r3961 = bit_and(r3960, body.constant(1u));
                           ir_expression *const r3962 = expr(ir_unop_bit_not, r3961);
                           body.emit(assign(r3928, bit_and(r3959, r3962), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3958->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3964 = bit_or(r3927, r3928);
                           ir_expression *const r3965 = equal(r3964, body.constant(0u));
                           ir_if *f3963 = new(mem_ctx) ir_if(operand(r3965).val);
                           exec_list *const f3963_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3963->then_instructions;

                              body.emit(assign(r3926, body.constant(int(0)), 0x01));


                           body.instructions = f3963_parent_instructions;
                           body.emit(f3963);

                           /* END IF */


                        body.instructions = f3958_parent_instructions;
                        body.emit(f3958);

                        /* END IF */

                        ir_variable *const r3966 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3966);
                        ir_expression *const r3967 = lshift(r34EF, body.constant(int(31)));
                        ir_expression *const r3968 = expr(ir_unop_i2u, r3926);
                        ir_expression *const r3969 = lshift(r3968, body.constant(int(20)));
                        ir_expression *const r396A = add(r3967, r3969);
                        body.emit(assign(r3966, add(r396A, r3927), 0x02));

                        body.emit(assign(r3966, r3928, 0x01));

                        body.emit(assign(r392B, r3966, 0x03));

                        body.emit(assign(r392A, body.constant(false), 0x01));


                     body.instructions = f3957_parent_instructions;
                     body.emit(f3957);

                     /* END IF */

                     body.emit(assign(r38AE, r392B, 0x03));

                     body.emit(assign(r38AD, body.constant(false), 0x01));


                  body.instructions = f391D_parent_instructions;
                  body.emit(f391D);

                  /* END IF */


               body.instructions = f3905_parent_instructions;
               body.emit(f3905);

               /* END IF */


            body.instructions = f38E7_parent_instructions;
            body.emit(f38E7);

            /* END IF */


         body.instructions = f38BF_parent_instructions;
         body.emit(f38BF);

         /* END IF */

         /* IF CONDITION */
         ir_if *f396B = new(mem_ctx) ir_if(operand(r38AD).val);
         exec_list *const f396B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f396B->then_instructions;

            body.emit(assign(r38B2, bit_or(r38B2, body.constant(1048576u)), 0x01));

            ir_variable *const r396C = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r396D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r396D, add(r38B3, r38B1), 0x01));

            ir_expression *const r396E = add(r38B2, r38B0);
            ir_expression *const r396F = less(r396D, r38B3);
            ir_expression *const r3970 = expr(ir_unop_b2i, r396F);
            ir_expression *const r3971 = expr(ir_unop_i2u, r3970);
            body.emit(assign(r396C, add(r396E, r3971), 0x01));

            body.emit(assign(r38B6, r396C, 0x01));

            body.emit(assign(r38B4, add(r38B4, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3973 = less(r396C, body.constant(2097152u));
            ir_if *f3972 = new(mem_ctx) ir_if(operand(r3973).val);
            exec_list *const f3972_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3972->then_instructions;

               ir_variable *const r3974 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3974, r38B4, 0x01));

               ir_variable *const r3975 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3975, r396C, 0x01));

               ir_variable *const r3976 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3976, r396D, 0x01));

               ir_variable *const r3977 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3977, r38B5, 0x01));

               ir_variable *const r3978 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r3978, body.constant(true), 0x01));

               ir_variable *const r3979 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r397A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r397A);
               ir_expression *const r397B = expr(ir_unop_u2i, r38B5);
               body.emit(assign(r397A, less(r397B, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r397D = lequal(body.constant(int(2045)), r38B4);
               ir_if *f397C = new(mem_ctx) ir_if(operand(r397D).val);
               exec_list *const f397C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f397C->then_instructions;

                  ir_variable *const r397E = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3980 = less(body.constant(int(2045)), r38B4);
                  ir_if *f397F = new(mem_ctx) ir_if(operand(r3980).val);
                  exec_list *const f397F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f397F->then_instructions;

                     body.emit(assign(r397E, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f397F->else_instructions;

                     ir_variable *const r3981 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3983 = equal(r38B4, body.constant(int(2045)));
                     ir_if *f3982 = new(mem_ctx) ir_if(operand(r3983).val);
                     exec_list *const f3982_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3982->then_instructions;

                        ir_expression *const r3984 = equal(body.constant(2097151u), r396C);
                        ir_expression *const r3985 = equal(body.constant(4294967295u), r396D);
                        body.emit(assign(r3981, logic_and(r3984, r3985), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3982->else_instructions;

                        body.emit(assign(r3981, body.constant(false), 0x01));


                     body.instructions = f3982_parent_instructions;
                     body.emit(f3982);

                     /* END IF */

                     body.emit(assign(r397E, logic_and(r3981, r397A), 0x01));


                  body.instructions = f397F_parent_instructions;
                  body.emit(f397F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3986 = new(mem_ctx) ir_if(operand(r397E).val);
                  exec_list *const f3986_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3986->then_instructions;

                     ir_variable *const r3987 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3987);
                     ir_expression *const r3988 = lshift(r34EF, body.constant(int(31)));
                     body.emit(assign(r3987, add(r3988, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3987, body.constant(0u), 0x01));

                     body.emit(assign(r3979, r3987, 0x03));

                     body.emit(assign(r3978, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3986->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r398A = less(r38B4, body.constant(int(0)));
                     ir_if *f3989 = new(mem_ctx) ir_if(operand(r398A).val);
                     exec_list *const f3989_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3989->then_instructions;

                        ir_variable *const r398B = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r398B, r38B5, 0x01));

                        ir_variable *const r398C = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r398C, neg(r38B4), 0x01));

                        ir_variable *const r398D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r398D);
                        ir_variable *const r398E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r398E);
                        ir_variable *const r398F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r398F);
                        ir_variable *const r3990 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3991 = neg(r398C);
                        body.emit(assign(r3990, bit_and(r3991, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3993 = equal(r398C, body.constant(int(0)));
                        ir_if *f3992 = new(mem_ctx) ir_if(operand(r3993).val);
                        exec_list *const f3992_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3992->then_instructions;

                           body.emit(assign(r398D, r38B5, 0x01));

                           body.emit(assign(r398E, r396D, 0x01));

                           body.emit(assign(r398F, r396C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3992->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3995 = less(r398C, body.constant(int(32)));
                           ir_if *f3994 = new(mem_ctx) ir_if(operand(r3995).val);
                           exec_list *const f3994_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3994->then_instructions;

                              body.emit(assign(r398D, lshift(r396D, r3990), 0x01));

                              ir_expression *const r3996 = lshift(r396C, r3990);
                              ir_expression *const r3997 = rshift(r396D, r398C);
                              body.emit(assign(r398E, bit_or(r3996, r3997), 0x01));

                              body.emit(assign(r398F, rshift(r396C, r398C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3994->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3999 = equal(r398C, body.constant(int(32)));
                              ir_if *f3998 = new(mem_ctx) ir_if(operand(r3999).val);
                              exec_list *const f3998_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3998->then_instructions;

                                 body.emit(assign(r398D, r396D, 0x01));

                                 body.emit(assign(r398E, r396C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3998->else_instructions;

                                 body.emit(assign(r398B, bit_or(r38B5, r396D), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r399B = less(r398C, body.constant(int(64)));
                                 ir_if *f399A = new(mem_ctx) ir_if(operand(r399B).val);
                                 exec_list *const f399A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f399A->then_instructions;

                                    body.emit(assign(r398D, lshift(r396C, r3990), 0x01));

                                    ir_expression *const r399C = bit_and(r398C, body.constant(int(31)));
                                    body.emit(assign(r398E, rshift(r396C, r399C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f399A->else_instructions;

                                    ir_variable *const r399D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r399F = equal(r398C, body.constant(int(64)));
                                    ir_if *f399E = new(mem_ctx) ir_if(operand(r399F).val);
                                    exec_list *const f399E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f399E->then_instructions;

                                       body.emit(assign(r399D, r396C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f399E->else_instructions;

                                       ir_expression *const r39A0 = nequal(r396C, body.constant(0u));
                                       ir_expression *const r39A1 = expr(ir_unop_b2i, r39A0);
                                       body.emit(assign(r399D, expr(ir_unop_i2u, r39A1), 0x01));


                                    body.instructions = f399E_parent_instructions;
                                    body.emit(f399E);

                                    /* END IF */

                                    body.emit(assign(r398D, r399D, 0x01));

                                    body.emit(assign(r398E, body.constant(0u), 0x01));


                                 body.instructions = f399A_parent_instructions;
                                 body.emit(f399A);

                                 /* END IF */


                              body.instructions = f3998_parent_instructions;
                              body.emit(f3998);

                              /* END IF */

                              body.emit(assign(r398F, body.constant(0u), 0x01));


                           body.instructions = f3994_parent_instructions;
                           body.emit(f3994);

                           /* END IF */

                           ir_expression *const r39A2 = nequal(r398B, body.constant(0u));
                           ir_expression *const r39A3 = expr(ir_unop_b2i, r39A2);
                           ir_expression *const r39A4 = expr(ir_unop_i2u, r39A3);
                           body.emit(assign(r398D, bit_or(r398D, r39A4), 0x01));


                        body.instructions = f3992_parent_instructions;
                        body.emit(f3992);

                        /* END IF */

                        body.emit(assign(r3975, r398F, 0x01));

                        body.emit(assign(r3976, r398E, 0x01));

                        body.emit(assign(r3977, r398D, 0x01));

                        body.emit(assign(r3974, body.constant(int(0)), 0x01));

                        body.emit(assign(r397A, less(r398D, body.constant(0u)), 0x01));


                     body.instructions = f3989_parent_instructions;
                     body.emit(f3989);

                     /* END IF */


                  body.instructions = f3986_parent_instructions;
                  body.emit(f3986);

                  /* END IF */


               body.instructions = f397C_parent_instructions;
               body.emit(f397C);

               /* END IF */

               /* IF CONDITION */
               ir_if *f39A5 = new(mem_ctx) ir_if(operand(r3978).val);
               exec_list *const f39A5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f39A5->then_instructions;

                  /* IF CONDITION */
                  ir_if *f39A6 = new(mem_ctx) ir_if(operand(r397A).val);
                  exec_list *const f39A6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f39A6->then_instructions;

                     ir_variable *const r39A7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r39A7, add(r3976, body.constant(1u)), 0x01));

                     ir_expression *const r39A8 = less(r39A7, r3976);
                     ir_expression *const r39A9 = expr(ir_unop_b2i, r39A8);
                     ir_expression *const r39AA = expr(ir_unop_i2u, r39A9);
                     body.emit(assign(r3975, add(r3975, r39AA), 0x01));

                     ir_expression *const r39AB = equal(r3977, body.constant(0u));
                     ir_expression *const r39AC = expr(ir_unop_b2i, r39AB);
                     ir_expression *const r39AD = expr(ir_unop_i2u, r39AC);
                     ir_expression *const r39AE = add(r3977, r39AD);
                     ir_expression *const r39AF = bit_and(r39AE, body.constant(1u));
                     ir_expression *const r39B0 = expr(ir_unop_bit_not, r39AF);
                     body.emit(assign(r3976, bit_and(r39A7, r39B0), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f39A6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r39B2 = bit_or(r3975, r3976);
                     ir_expression *const r39B3 = equal(r39B2, body.constant(0u));
                     ir_if *f39B1 = new(mem_ctx) ir_if(operand(r39B3).val);
                     exec_list *const f39B1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f39B1->then_instructions;

                        body.emit(assign(r3974, body.constant(int(0)), 0x01));


                     body.instructions = f39B1_parent_instructions;
                     body.emit(f39B1);

                     /* END IF */


                  body.instructions = f39A6_parent_instructions;
                  body.emit(f39A6);

                  /* END IF */

                  ir_variable *const r39B4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r39B4);
                  ir_expression *const r39B5 = lshift(r34EF, body.constant(int(31)));
                  ir_expression *const r39B6 = expr(ir_unop_i2u, r3974);
                  ir_expression *const r39B7 = lshift(r39B6, body.constant(int(20)));
                  ir_expression *const r39B8 = add(r39B5, r39B7);
                  body.emit(assign(r39B4, add(r39B8, r3975), 0x02));

                  body.emit(assign(r39B4, r3976, 0x01));

                  body.emit(assign(r3979, r39B4, 0x03));

                  body.emit(assign(r3978, body.constant(false), 0x01));


               body.instructions = f39A5_parent_instructions;
               body.emit(f39A5);

               /* END IF */

               body.emit(assign(r38AE, r3979, 0x03));

               body.emit(assign(r38AD, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3972->else_instructions;

               body.emit(assign(r38B4, add(r38B4, body.constant(int(1))), 0x01));

               ir_variable *const r39B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r39B9);
               ir_variable *const r39BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r39BA);
               ir_variable *const r39BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r39BB);
               body.emit(assign(r39B9, lshift(r396D, body.constant(int(31))), 0x01));

               ir_expression *const r39BC = lshift(r396C, body.constant(int(31)));
               ir_expression *const r39BD = rshift(r396D, body.constant(int(1)));
               body.emit(assign(r39BA, bit_or(r39BC, r39BD), 0x01));

               body.emit(assign(r39BB, rshift(r396C, body.constant(int(1))), 0x01));

               ir_expression *const r39BE = nequal(r38B5, body.constant(0u));
               ir_expression *const r39BF = expr(ir_unop_b2i, r39BE);
               ir_expression *const r39C0 = expr(ir_unop_i2u, r39BF);
               body.emit(assign(r39B9, bit_or(r39B9, r39C0), 0x01));

               body.emit(assign(r38B6, r39BB, 0x01));

               body.emit(assign(r38B5, r39B9, 0x01));

               ir_variable *const r39C1 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r39C1, r38B4, 0x01));

               ir_variable *const r39C2 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r39C2, r39BB, 0x01));

               ir_variable *const r39C3 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r39C3, r39BA, 0x01));

               ir_variable *const r39C4 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r39C4, r39B9, 0x01));

               ir_variable *const r39C5 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r39C5, body.constant(true), 0x01));

               ir_variable *const r39C6 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r39C7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r39C7);
               ir_expression *const r39C8 = expr(ir_unop_u2i, r39B9);
               body.emit(assign(r39C7, less(r39C8, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r39CA = lequal(body.constant(int(2045)), r38B4);
               ir_if *f39C9 = new(mem_ctx) ir_if(operand(r39CA).val);
               exec_list *const f39C9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f39C9->then_instructions;

                  ir_variable *const r39CB = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r39CD = less(body.constant(int(2045)), r38B4);
                  ir_if *f39CC = new(mem_ctx) ir_if(operand(r39CD).val);
                  exec_list *const f39CC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f39CC->then_instructions;

                     body.emit(assign(r39CB, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f39CC->else_instructions;

                     ir_variable *const r39CE = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r39D0 = equal(r38B4, body.constant(int(2045)));
                     ir_if *f39CF = new(mem_ctx) ir_if(operand(r39D0).val);
                     exec_list *const f39CF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f39CF->then_instructions;

                        ir_expression *const r39D1 = equal(body.constant(2097151u), r39BB);
                        ir_expression *const r39D2 = equal(body.constant(4294967295u), r39BA);
                        body.emit(assign(r39CE, logic_and(r39D1, r39D2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f39CF->else_instructions;

                        body.emit(assign(r39CE, body.constant(false), 0x01));


                     body.instructions = f39CF_parent_instructions;
                     body.emit(f39CF);

                     /* END IF */

                     body.emit(assign(r39CB, logic_and(r39CE, r39C7), 0x01));


                  body.instructions = f39CC_parent_instructions;
                  body.emit(f39CC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f39D3 = new(mem_ctx) ir_if(operand(r39CB).val);
                  exec_list *const f39D3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f39D3->then_instructions;

                     ir_variable *const r39D4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r39D4);
                     ir_expression *const r39D5 = lshift(r34EF, body.constant(int(31)));
                     body.emit(assign(r39D4, add(r39D5, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r39D4, body.constant(0u), 0x01));

                     body.emit(assign(r39C6, r39D4, 0x03));

                     body.emit(assign(r39C5, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f39D3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r39D7 = less(r38B4, body.constant(int(0)));
                     ir_if *f39D6 = new(mem_ctx) ir_if(operand(r39D7).val);
                     exec_list *const f39D6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f39D6->then_instructions;

                        ir_variable *const r39D8 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r39D8, r39B9, 0x01));

                        ir_variable *const r39D9 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r39D9, neg(r38B4), 0x01));

                        ir_variable *const r39DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r39DA);
                        ir_variable *const r39DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r39DB);
                        ir_variable *const r39DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r39DC);
                        ir_variable *const r39DD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r39DE = neg(r39D9);
                        body.emit(assign(r39DD, bit_and(r39DE, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r39E0 = equal(r39D9, body.constant(int(0)));
                        ir_if *f39DF = new(mem_ctx) ir_if(operand(r39E0).val);
                        exec_list *const f39DF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f39DF->then_instructions;

                           body.emit(assign(r39DA, r39B9, 0x01));

                           body.emit(assign(r39DB, r39BA, 0x01));

                           body.emit(assign(r39DC, r39BB, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f39DF->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r39E2 = less(r39D9, body.constant(int(32)));
                           ir_if *f39E1 = new(mem_ctx) ir_if(operand(r39E2).val);
                           exec_list *const f39E1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f39E1->then_instructions;

                              body.emit(assign(r39DA, lshift(r39BA, r39DD), 0x01));

                              ir_expression *const r39E3 = lshift(r39BB, r39DD);
                              ir_expression *const r39E4 = rshift(r39BA, r39D9);
                              body.emit(assign(r39DB, bit_or(r39E3, r39E4), 0x01));

                              body.emit(assign(r39DC, rshift(r39BB, r39D9), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f39E1->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r39E6 = equal(r39D9, body.constant(int(32)));
                              ir_if *f39E5 = new(mem_ctx) ir_if(operand(r39E6).val);
                              exec_list *const f39E5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f39E5->then_instructions;

                                 body.emit(assign(r39DA, r39BA, 0x01));

                                 body.emit(assign(r39DB, r39BB, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f39E5->else_instructions;

                                 body.emit(assign(r39D8, bit_or(r39B9, r39BA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r39E8 = less(r39D9, body.constant(int(64)));
                                 ir_if *f39E7 = new(mem_ctx) ir_if(operand(r39E8).val);
                                 exec_list *const f39E7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f39E7->then_instructions;

                                    body.emit(assign(r39DA, lshift(r39BB, r39DD), 0x01));

                                    ir_expression *const r39E9 = bit_and(r39D9, body.constant(int(31)));
                                    body.emit(assign(r39DB, rshift(r39BB, r39E9), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f39E7->else_instructions;

                                    ir_variable *const r39EA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r39EC = equal(r39D9, body.constant(int(64)));
                                    ir_if *f39EB = new(mem_ctx) ir_if(operand(r39EC).val);
                                    exec_list *const f39EB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f39EB->then_instructions;

                                       body.emit(assign(r39EA, r39BB, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f39EB->else_instructions;

                                       ir_expression *const r39ED = nequal(r39BB, body.constant(0u));
                                       ir_expression *const r39EE = expr(ir_unop_b2i, r39ED);
                                       body.emit(assign(r39EA, expr(ir_unop_i2u, r39EE), 0x01));


                                    body.instructions = f39EB_parent_instructions;
                                    body.emit(f39EB);

                                    /* END IF */

                                    body.emit(assign(r39DA, r39EA, 0x01));

                                    body.emit(assign(r39DB, body.constant(0u), 0x01));


                                 body.instructions = f39E7_parent_instructions;
                                 body.emit(f39E7);

                                 /* END IF */


                              body.instructions = f39E5_parent_instructions;
                              body.emit(f39E5);

                              /* END IF */

                              body.emit(assign(r39DC, body.constant(0u), 0x01));


                           body.instructions = f39E1_parent_instructions;
                           body.emit(f39E1);

                           /* END IF */

                           ir_expression *const r39EF = nequal(r39D8, body.constant(0u));
                           ir_expression *const r39F0 = expr(ir_unop_b2i, r39EF);
                           ir_expression *const r39F1 = expr(ir_unop_i2u, r39F0);
                           body.emit(assign(r39DA, bit_or(r39DA, r39F1), 0x01));


                        body.instructions = f39DF_parent_instructions;
                        body.emit(f39DF);

                        /* END IF */

                        body.emit(assign(r39C2, r39DC, 0x01));

                        body.emit(assign(r39C3, r39DB, 0x01));

                        body.emit(assign(r39C4, r39DA, 0x01));

                        body.emit(assign(r39C1, body.constant(int(0)), 0x01));

                        body.emit(assign(r39C7, less(r39DA, body.constant(0u)), 0x01));


                     body.instructions = f39D6_parent_instructions;
                     body.emit(f39D6);

                     /* END IF */


                  body.instructions = f39D3_parent_instructions;
                  body.emit(f39D3);

                  /* END IF */


               body.instructions = f39C9_parent_instructions;
               body.emit(f39C9);

               /* END IF */

               /* IF CONDITION */
               ir_if *f39F2 = new(mem_ctx) ir_if(operand(r39C5).val);
               exec_list *const f39F2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f39F2->then_instructions;

                  /* IF CONDITION */
                  ir_if *f39F3 = new(mem_ctx) ir_if(operand(r39C7).val);
                  exec_list *const f39F3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f39F3->then_instructions;

                     ir_variable *const r39F4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r39F4, add(r39C3, body.constant(1u)), 0x01));

                     ir_expression *const r39F5 = less(r39F4, r39C3);
                     ir_expression *const r39F6 = expr(ir_unop_b2i, r39F5);
                     ir_expression *const r39F7 = expr(ir_unop_i2u, r39F6);
                     body.emit(assign(r39C2, add(r39C2, r39F7), 0x01));

                     ir_expression *const r39F8 = equal(r39C4, body.constant(0u));
                     ir_expression *const r39F9 = expr(ir_unop_b2i, r39F8);
                     ir_expression *const r39FA = expr(ir_unop_i2u, r39F9);
                     ir_expression *const r39FB = add(r39C4, r39FA);
                     ir_expression *const r39FC = bit_and(r39FB, body.constant(1u));
                     ir_expression *const r39FD = expr(ir_unop_bit_not, r39FC);
                     body.emit(assign(r39C3, bit_and(r39F4, r39FD), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f39F3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r39FF = bit_or(r39C2, r39C3);
                     ir_expression *const r3A00 = equal(r39FF, body.constant(0u));
                     ir_if *f39FE = new(mem_ctx) ir_if(operand(r3A00).val);
                     exec_list *const f39FE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f39FE->then_instructions;

                        body.emit(assign(r39C1, body.constant(int(0)), 0x01));


                     body.instructions = f39FE_parent_instructions;
                     body.emit(f39FE);

                     /* END IF */


                  body.instructions = f39F3_parent_instructions;
                  body.emit(f39F3);

                  /* END IF */

                  ir_variable *const r3A01 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3A01);
                  ir_expression *const r3A02 = lshift(r34EF, body.constant(int(31)));
                  ir_expression *const r3A03 = expr(ir_unop_i2u, r39C1);
                  ir_expression *const r3A04 = lshift(r3A03, body.constant(int(20)));
                  ir_expression *const r3A05 = add(r3A02, r3A04);
                  body.emit(assign(r3A01, add(r3A05, r39C2), 0x02));

                  body.emit(assign(r3A01, r39C3, 0x01));

                  body.emit(assign(r39C6, r3A01, 0x03));

                  body.emit(assign(r39C5, body.constant(false), 0x01));


               body.instructions = f39F2_parent_instructions;
               body.emit(f39F2);

               /* END IF */

               body.emit(assign(r38AE, r39C6, 0x03));

               body.emit(assign(r38AD, body.constant(false), 0x01));


            body.instructions = f3972_parent_instructions;
            body.emit(f3972);

            /* END IF */


         body.instructions = f396B_parent_instructions;
         body.emit(f396B);

         /* END IF */

         body.emit(assign(r34EE, r38AE, 0x03));


      body.instructions = f34F0_parent_instructions;
      body.emit(f34F0);

      /* END IF */

      body.emit(assign(r34EC, r34EE, 0x03));


   body.instructions = f34ED_parent_instructions;
   body.emit(f34ED);

   /* END IF */

   ir_variable *const r3A06 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r3A06, body.constant(true), 0x01));

   ir_variable *const r3A07 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r3A08 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r3A08);
   ir_variable *const r3A09 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r3A09);
   ir_variable *const r3A0A = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r3A0A);
   ir_variable *const r3A0B = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r3A0B);
   ir_variable *const r3A0C = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r3A0C);
   ir_variable *const r3A0D = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r3A0D);
   ir_variable *const r3A0E = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r3A0E);
   ir_variable *const r3A0F = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r3A0F);
   ir_variable *const r3A10 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r3A10);
   ir_variable *const r3A11 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r3A11);
   ir_variable *const r3A12 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r3A12);
   body.emit(assign(r3A12, body.constant(0u), 0x01));

   body.emit(assign(r3A11, body.constant(0u), 0x01));

   body.emit(assign(r3A10, body.constant(0u), 0x01));

   ir_variable *const r3A13 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r3A13, swizzle_x(r3248), 0x01));

   body.emit(assign(r3A0E, r3A13, 0x01));

   ir_variable *const r3A14 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r3A14, bit_and(swizzle_y(r3248), body.constant(1048575u)), 0x01));

   body.emit(assign(r3A0D, r3A14, 0x01));

   ir_variable *const r3A15 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r3A15, swizzle_x(r34EC), 0x01));

   body.emit(assign(r3A0C, r3A15, 0x01));

   ir_variable *const r3A16 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r3A16, bit_and(swizzle_y(r34EC), body.constant(1048575u)), 0x01));

   body.emit(assign(r3A0B, r3A16, 0x01));

   ir_variable *const r3A17 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r3A18 = rshift(swizzle_y(r3248), body.constant(int(20)));
   ir_expression *const r3A19 = bit_and(r3A18, body.constant(2047u));
   body.emit(assign(r3A17, expr(ir_unop_u2i, r3A19), 0x01));

   body.emit(assign(r3A0A, r3A17, 0x01));

   ir_variable *const r3A1A = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r3A1B = rshift(swizzle_y(r34EC), body.constant(int(20)));
   ir_expression *const r3A1C = bit_and(r3A1B, body.constant(2047u));
   body.emit(assign(r3A1A, expr(ir_unop_u2i, r3A1C), 0x01));

   body.emit(assign(r3A09, r3A1A, 0x01));

   ir_expression *const r3A1D = rshift(swizzle_y(r3248), body.constant(int(31)));
   ir_expression *const r3A1E = rshift(swizzle_y(r34EC), body.constant(int(31)));
   body.emit(assign(r3A08, bit_xor(r3A1D, r3A1E), 0x01));

   /* IF CONDITION */
   ir_expression *const r3A20 = equal(r3A17, body.constant(int(2047)));
   ir_if *f3A1F = new(mem_ctx) ir_if(operand(r3A20).val);
   exec_list *const f3A1F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f3A1F->then_instructions;

      /* IF CONDITION */
      ir_expression *const r3A22 = bit_or(r3A14, swizzle_x(r3248));
      ir_expression *const r3A23 = nequal(r3A22, body.constant(0u));
      ir_expression *const r3A24 = equal(r3A1A, body.constant(int(2047)));
      ir_expression *const r3A25 = bit_or(r3A16, swizzle_x(r34EC));
      ir_expression *const r3A26 = nequal(r3A25, body.constant(0u));
      ir_expression *const r3A27 = logic_and(r3A24, r3A26);
      ir_expression *const r3A28 = logic_or(r3A23, r3A27);
      ir_if *f3A21 = new(mem_ctx) ir_if(operand(r3A28).val);
      exec_list *const f3A21_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3A21->then_instructions;

         ir_variable *const r3A29 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r3A29, swizzle_x(r3248), 0x01));

         ir_variable *const r3A2A = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r3A2A, swizzle_x(r34EC), 0x01));

         ir_variable *const r3A2B = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r3A2C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r3A2D = rshift(swizzle_y(r3248), body.constant(int(19)));
         ir_expression *const r3A2E = bit_and(r3A2D, body.constant(4095u));
         ir_expression *const r3A2F = equal(r3A2E, body.constant(4094u));
         ir_expression *const r3A30 = nequal(swizzle_x(r3248), body.constant(0u));
         ir_expression *const r3A31 = bit_and(swizzle_y(r3248), body.constant(524287u));
         ir_expression *const r3A32 = nequal(r3A31, body.constant(0u));
         ir_expression *const r3A33 = logic_or(r3A30, r3A32);
         body.emit(assign(r3A2C, logic_and(r3A2F, r3A33), 0x01));

         ir_variable *const r3A34 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r3A35 = lshift(swizzle_y(r34EC), body.constant(int(1)));
         ir_expression *const r3A36 = lequal(body.constant(4292870144u), r3A35);
         ir_expression *const r3A37 = nequal(swizzle_x(r34EC), body.constant(0u));
         ir_expression *const r3A38 = bit_and(swizzle_y(r34EC), body.constant(1048575u));
         ir_expression *const r3A39 = nequal(r3A38, body.constant(0u));
         ir_expression *const r3A3A = logic_or(r3A37, r3A39);
         body.emit(assign(r3A34, logic_and(r3A36, r3A3A), 0x01));

         body.emit(assign(r3A29, bit_or(swizzle_y(r3248), body.constant(524288u)), 0x02));

         body.emit(assign(r3A2A, bit_or(swizzle_y(r34EC), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r3A3C = lshift(swizzle_y(r3248), body.constant(int(1)));
         ir_expression *const r3A3D = lequal(body.constant(4292870144u), r3A3C);
         ir_expression *const r3A3E = nequal(swizzle_x(r3248), body.constant(0u));
         ir_expression *const r3A3F = bit_and(swizzle_y(r3248), body.constant(1048575u));
         ir_expression *const r3A40 = nequal(r3A3F, body.constant(0u));
         ir_expression *const r3A41 = logic_or(r3A3E, r3A40);
         ir_expression *const r3A42 = logic_and(r3A3D, r3A41);
         ir_if *f3A3B = new(mem_ctx) ir_if(operand(r3A42).val);
         exec_list *const f3A3B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3A3B->then_instructions;

            ir_variable *const r3A43 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r3A45 = logic_and(r3A2C, r3A34);
            ir_if *f3A44 = new(mem_ctx) ir_if(operand(r3A45).val);
            exec_list *const f3A44_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3A44->then_instructions;

               body.emit(assign(r3A43, r3A2A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3A44->else_instructions;

               body.emit(assign(r3A43, r3A29, 0x03));


            body.instructions = f3A44_parent_instructions;
            body.emit(f3A44);

            /* END IF */

            body.emit(assign(r3A2B, r3A43, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3A3B->else_instructions;

            body.emit(assign(r3A2B, r3A2A, 0x03));


         body.instructions = f3A3B_parent_instructions;
         body.emit(f3A3B);

         /* END IF */

         body.emit(assign(r3A07, r3A2B, 0x03));

         body.emit(assign(r3A06, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3A21->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3A47 = expr(ir_unop_i2u, r3A1A);
         ir_expression *const r3A48 = bit_or(r3A47, r3A16);
         ir_expression *const r3A49 = bit_or(r3A48, swizzle_x(r34EC));
         ir_expression *const r3A4A = equal(r3A49, body.constant(0u));
         ir_if *f3A46 = new(mem_ctx) ir_if(operand(r3A4A).val);
         exec_list *const f3A46_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3A46->then_instructions;

            ir_constant_data r3A4B_data;
            memset(&r3A4B_data, 0, sizeof(ir_constant_data));
            r3A4B_data.u[0] = 4294967295;
            r3A4B_data.u[1] = 4294967295;
            ir_constant *const r3A4B = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3A4B_data);
            body.emit(assign(r3A07, r3A4B, 0x03));

            body.emit(assign(r3A06, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3A46->else_instructions;

            ir_variable *const r3A4C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r3A4C);
            ir_expression *const r3A4D = lshift(r3A08, body.constant(int(31)));
            body.emit(assign(r3A4C, add(r3A4D, body.constant(2146435072u)), 0x02));

            body.emit(assign(r3A4C, body.constant(0u), 0x01));

            body.emit(assign(r3A07, r3A4C, 0x03));

            body.emit(assign(r3A06, body.constant(false), 0x01));


         body.instructions = f3A46_parent_instructions;
         body.emit(f3A46);

         /* END IF */


      body.instructions = f3A21_parent_instructions;
      body.emit(f3A21);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f3A1F->else_instructions;

      /* IF CONDITION */
      ir_expression *const r3A4F = equal(r3A1A, body.constant(int(2047)));
      ir_if *f3A4E = new(mem_ctx) ir_if(operand(r3A4F).val);
      exec_list *const f3A4E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3A4E->then_instructions;

         /* IF CONDITION */
         ir_expression *const r3A51 = bit_or(r3A16, swizzle_x(r34EC));
         ir_expression *const r3A52 = nequal(r3A51, body.constant(0u));
         ir_if *f3A50 = new(mem_ctx) ir_if(operand(r3A52).val);
         exec_list *const f3A50_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3A50->then_instructions;

            ir_variable *const r3A53 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r3A53, swizzle_x(r3248), 0x01));

            ir_variable *const r3A54 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r3A54, swizzle_x(r34EC), 0x01));

            ir_variable *const r3A55 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r3A56 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r3A57 = rshift(swizzle_y(r3248), body.constant(int(19)));
            ir_expression *const r3A58 = bit_and(r3A57, body.constant(4095u));
            ir_expression *const r3A59 = equal(r3A58, body.constant(4094u));
            ir_expression *const r3A5A = nequal(swizzle_x(r3248), body.constant(0u));
            ir_expression *const r3A5B = bit_and(swizzle_y(r3248), body.constant(524287u));
            ir_expression *const r3A5C = nequal(r3A5B, body.constant(0u));
            ir_expression *const r3A5D = logic_or(r3A5A, r3A5C);
            body.emit(assign(r3A56, logic_and(r3A59, r3A5D), 0x01));

            ir_variable *const r3A5E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r3A5F = lshift(swizzle_y(r34EC), body.constant(int(1)));
            ir_expression *const r3A60 = lequal(body.constant(4292870144u), r3A5F);
            ir_expression *const r3A61 = nequal(swizzle_x(r34EC), body.constant(0u));
            ir_expression *const r3A62 = bit_and(swizzle_y(r34EC), body.constant(1048575u));
            ir_expression *const r3A63 = nequal(r3A62, body.constant(0u));
            ir_expression *const r3A64 = logic_or(r3A61, r3A63);
            body.emit(assign(r3A5E, logic_and(r3A60, r3A64), 0x01));

            body.emit(assign(r3A53, bit_or(swizzle_y(r3248), body.constant(524288u)), 0x02));

            body.emit(assign(r3A54, bit_or(swizzle_y(r34EC), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r3A66 = lshift(swizzle_y(r3248), body.constant(int(1)));
            ir_expression *const r3A67 = lequal(body.constant(4292870144u), r3A66);
            ir_expression *const r3A68 = nequal(swizzle_x(r3248), body.constant(0u));
            ir_expression *const r3A69 = bit_and(swizzle_y(r3248), body.constant(1048575u));
            ir_expression *const r3A6A = nequal(r3A69, body.constant(0u));
            ir_expression *const r3A6B = logic_or(r3A68, r3A6A);
            ir_expression *const r3A6C = logic_and(r3A67, r3A6B);
            ir_if *f3A65 = new(mem_ctx) ir_if(operand(r3A6C).val);
            exec_list *const f3A65_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3A65->then_instructions;

               ir_variable *const r3A6D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r3A6F = logic_and(r3A56, r3A5E);
               ir_if *f3A6E = new(mem_ctx) ir_if(operand(r3A6F).val);
               exec_list *const f3A6E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A6E->then_instructions;

                  body.emit(assign(r3A6D, r3A54, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3A6E->else_instructions;

                  body.emit(assign(r3A6D, r3A53, 0x03));


               body.instructions = f3A6E_parent_instructions;
               body.emit(f3A6E);

               /* END IF */

               body.emit(assign(r3A55, r3A6D, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3A65->else_instructions;

               body.emit(assign(r3A55, r3A54, 0x03));


            body.instructions = f3A65_parent_instructions;
            body.emit(f3A65);

            /* END IF */

            body.emit(assign(r3A07, r3A55, 0x03));

            body.emit(assign(r3A06, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3A50->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3A71 = expr(ir_unop_i2u, r3A17);
            ir_expression *const r3A72 = bit_or(r3A71, r3A14);
            ir_expression *const r3A73 = bit_or(r3A72, swizzle_x(r3248));
            ir_expression *const r3A74 = equal(r3A73, body.constant(0u));
            ir_if *f3A70 = new(mem_ctx) ir_if(operand(r3A74).val);
            exec_list *const f3A70_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3A70->then_instructions;

               ir_constant_data r3A75_data;
               memset(&r3A75_data, 0, sizeof(ir_constant_data));
               r3A75_data.u[0] = 4294967295;
               r3A75_data.u[1] = 4294967295;
               ir_constant *const r3A75 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3A75_data);
               body.emit(assign(r3A07, r3A75, 0x03));

               body.emit(assign(r3A06, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3A70->else_instructions;

               ir_variable *const r3A76 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r3A76);
               ir_expression *const r3A77 = lshift(r3A08, body.constant(int(31)));
               body.emit(assign(r3A76, add(r3A77, body.constant(2146435072u)), 0x02));

               body.emit(assign(r3A76, body.constant(0u), 0x01));

               body.emit(assign(r3A07, r3A76, 0x03));

               body.emit(assign(r3A06, body.constant(false), 0x01));


            body.instructions = f3A70_parent_instructions;
            body.emit(f3A70);

            /* END IF */


         body.instructions = f3A50_parent_instructions;
         body.emit(f3A50);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3A4E->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3A79 = equal(r3A17, body.constant(int(0)));
         ir_if *f3A78 = new(mem_ctx) ir_if(operand(r3A79).val);
         exec_list *const f3A78_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3A78->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3A7B = bit_or(r3A14, swizzle_x(r3248));
            ir_expression *const r3A7C = equal(r3A7B, body.constant(0u));
            ir_if *f3A7A = new(mem_ctx) ir_if(operand(r3A7C).val);
            exec_list *const f3A7A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3A7A->then_instructions;

               ir_variable *const r3A7D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r3A7D);
               body.emit(assign(r3A7D, lshift(r3A08, body.constant(int(31))), 0x02));

               body.emit(assign(r3A7D, body.constant(0u), 0x01));

               body.emit(assign(r3A07, r3A7D, 0x03));

               body.emit(assign(r3A06, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3A7A->else_instructions;

               ir_variable *const r3A7E = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r3A7E, r3A17, 0x01));

               ir_variable *const r3A7F = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r3A7F, r3A14, 0x01));

               ir_variable *const r3A80 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r3A80, r3A13, 0x01));

               ir_variable *const r3A81 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3A81);
               /* IF CONDITION */
               ir_expression *const r3A83 = equal(r3A14, body.constant(0u));
               ir_if *f3A82 = new(mem_ctx) ir_if(operand(r3A83).val);
               exec_list *const f3A82_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A82->then_instructions;

                  ir_variable *const r3A84 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r3A84, r3A13, 0x01));

                  ir_variable *const r3A85 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3A86 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3A86);
                  /* IF CONDITION */
                  ir_expression *const r3A88 = equal(swizzle_x(r3248), body.constant(0u));
                  ir_if *f3A87 = new(mem_ctx) ir_if(operand(r3A88).val);
                  exec_list *const f3A87_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A87->then_instructions;

                     body.emit(assign(r3A85, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A87->else_instructions;

                     body.emit(assign(r3A86, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3A8A = bit_and(swizzle_x(r3248), body.constant(4294901760u));
                     ir_expression *const r3A8B = equal(r3A8A, body.constant(0u));
                     ir_if *f3A89 = new(mem_ctx) ir_if(operand(r3A8B).val);
                     exec_list *const f3A89_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A89->then_instructions;

                        body.emit(assign(r3A86, body.constant(int(16)), 0x01));

                        body.emit(assign(r3A84, lshift(swizzle_x(r3248), body.constant(int(16))), 0x01));


                     body.instructions = f3A89_parent_instructions;
                     body.emit(f3A89);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A8D = bit_and(r3A84, body.constant(4278190080u));
                     ir_expression *const r3A8E = equal(r3A8D, body.constant(0u));
                     ir_if *f3A8C = new(mem_ctx) ir_if(operand(r3A8E).val);
                     exec_list *const f3A8C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A8C->then_instructions;

                        body.emit(assign(r3A86, add(r3A86, body.constant(int(8))), 0x01));

                        body.emit(assign(r3A84, lshift(r3A84, body.constant(int(8))), 0x01));


                     body.instructions = f3A8C_parent_instructions;
                     body.emit(f3A8C);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A90 = bit_and(r3A84, body.constant(4026531840u));
                     ir_expression *const r3A91 = equal(r3A90, body.constant(0u));
                     ir_if *f3A8F = new(mem_ctx) ir_if(operand(r3A91).val);
                     exec_list *const f3A8F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A8F->then_instructions;

                        body.emit(assign(r3A86, add(r3A86, body.constant(int(4))), 0x01));

                        body.emit(assign(r3A84, lshift(r3A84, body.constant(int(4))), 0x01));


                     body.instructions = f3A8F_parent_instructions;
                     body.emit(f3A8F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A93 = bit_and(r3A84, body.constant(3221225472u));
                     ir_expression *const r3A94 = equal(r3A93, body.constant(0u));
                     ir_if *f3A92 = new(mem_ctx) ir_if(operand(r3A94).val);
                     exec_list *const f3A92_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A92->then_instructions;

                        body.emit(assign(r3A86, add(r3A86, body.constant(int(2))), 0x01));

                        body.emit(assign(r3A84, lshift(r3A84, body.constant(int(2))), 0x01));


                     body.instructions = f3A92_parent_instructions;
                     body.emit(f3A92);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A96 = bit_and(r3A84, body.constant(2147483648u));
                     ir_expression *const r3A97 = equal(r3A96, body.constant(0u));
                     ir_if *f3A95 = new(mem_ctx) ir_if(operand(r3A97).val);
                     exec_list *const f3A95_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A95->then_instructions;

                        body.emit(assign(r3A86, add(r3A86, body.constant(int(1))), 0x01));


                     body.instructions = f3A95_parent_instructions;
                     body.emit(f3A95);

                     /* END IF */

                     body.emit(assign(r3A85, r3A86, 0x01));


                  body.instructions = f3A87_parent_instructions;
                  body.emit(f3A87);

                  /* END IF */

                  body.emit(assign(r3A81, add(r3A85, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3A99 = less(r3A81, body.constant(int(0)));
                  ir_if *f3A98 = new(mem_ctx) ir_if(operand(r3A99).val);
                  exec_list *const f3A98_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A98->then_instructions;

                     ir_expression *const r3A9A = neg(r3A81);
                     body.emit(assign(r3A7F, rshift(swizzle_x(r3248), r3A9A), 0x01));

                     ir_expression *const r3A9B = bit_and(r3A81, body.constant(int(31)));
                     body.emit(assign(r3A80, lshift(swizzle_x(r3248), r3A9B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A98->else_instructions;

                     body.emit(assign(r3A7F, lshift(swizzle_x(r3248), r3A81), 0x01));

                     body.emit(assign(r3A80, body.constant(0u), 0x01));


                  body.instructions = f3A98_parent_instructions;
                  body.emit(f3A98);

                  /* END IF */

                  body.emit(assign(r3A7E, sub(body.constant(int(-31)), r3A81), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3A82->else_instructions;

                  ir_variable *const r3A9C = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r3A9C, r3A14, 0x01));

                  ir_variable *const r3A9D = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3A9E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3A9E);
                  /* IF CONDITION */
                  ir_expression *const r3AA0 = equal(r3A14, body.constant(0u));
                  ir_if *f3A9F = new(mem_ctx) ir_if(operand(r3AA0).val);
                  exec_list *const f3A9F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A9F->then_instructions;

                     body.emit(assign(r3A9D, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A9F->else_instructions;

                     body.emit(assign(r3A9E, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3AA2 = bit_and(r3A14, body.constant(4294901760u));
                     ir_expression *const r3AA3 = equal(r3AA2, body.constant(0u));
                     ir_if *f3AA1 = new(mem_ctx) ir_if(operand(r3AA3).val);
                     exec_list *const f3AA1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AA1->then_instructions;

                        body.emit(assign(r3A9E, body.constant(int(16)), 0x01));

                        body.emit(assign(r3A9C, lshift(r3A14, body.constant(int(16))), 0x01));


                     body.instructions = f3AA1_parent_instructions;
                     body.emit(f3AA1);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3AA5 = bit_and(r3A9C, body.constant(4278190080u));
                     ir_expression *const r3AA6 = equal(r3AA5, body.constant(0u));
                     ir_if *f3AA4 = new(mem_ctx) ir_if(operand(r3AA6).val);
                     exec_list *const f3AA4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AA4->then_instructions;

                        body.emit(assign(r3A9E, add(r3A9E, body.constant(int(8))), 0x01));

                        body.emit(assign(r3A9C, lshift(r3A9C, body.constant(int(8))), 0x01));


                     body.instructions = f3AA4_parent_instructions;
                     body.emit(f3AA4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3AA8 = bit_and(r3A9C, body.constant(4026531840u));
                     ir_expression *const r3AA9 = equal(r3AA8, body.constant(0u));
                     ir_if *f3AA7 = new(mem_ctx) ir_if(operand(r3AA9).val);
                     exec_list *const f3AA7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AA7->then_instructions;

                        body.emit(assign(r3A9E, add(r3A9E, body.constant(int(4))), 0x01));

                        body.emit(assign(r3A9C, lshift(r3A9C, body.constant(int(4))), 0x01));


                     body.instructions = f3AA7_parent_instructions;
                     body.emit(f3AA7);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3AAB = bit_and(r3A9C, body.constant(3221225472u));
                     ir_expression *const r3AAC = equal(r3AAB, body.constant(0u));
                     ir_if *f3AAA = new(mem_ctx) ir_if(operand(r3AAC).val);
                     exec_list *const f3AAA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AAA->then_instructions;

                        body.emit(assign(r3A9E, add(r3A9E, body.constant(int(2))), 0x01));

                        body.emit(assign(r3A9C, lshift(r3A9C, body.constant(int(2))), 0x01));


                     body.instructions = f3AAA_parent_instructions;
                     body.emit(f3AAA);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3AAE = bit_and(r3A9C, body.constant(2147483648u));
                     ir_expression *const r3AAF = equal(r3AAE, body.constant(0u));
                     ir_if *f3AAD = new(mem_ctx) ir_if(operand(r3AAF).val);
                     exec_list *const f3AAD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AAD->then_instructions;

                        body.emit(assign(r3A9E, add(r3A9E, body.constant(int(1))), 0x01));


                     body.instructions = f3AAD_parent_instructions;
                     body.emit(f3AAD);

                     /* END IF */

                     body.emit(assign(r3A9D, r3A9E, 0x01));


                  body.instructions = f3A9F_parent_instructions;
                  body.emit(f3A9F);

                  /* END IF */

                  body.emit(assign(r3A81, add(r3A9D, body.constant(int(-11))), 0x01));

                  ir_variable *const r3AB0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3AB0, lshift(swizzle_x(r3248), r3A81), 0x01));

                  ir_variable *const r3AB1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3AB3 = equal(r3A81, body.constant(int(0)));
                  ir_if *f3AB2 = new(mem_ctx) ir_if(operand(r3AB3).val);
                  exec_list *const f3AB2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3AB2->then_instructions;

                     body.emit(assign(r3AB1, r3A14, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3AB2->else_instructions;

                     ir_expression *const r3AB4 = lshift(r3A14, r3A81);
                     ir_expression *const r3AB5 = neg(r3A81);
                     ir_expression *const r3AB6 = bit_and(r3AB5, body.constant(int(31)));
                     ir_expression *const r3AB7 = rshift(swizzle_x(r3248), r3AB6);
                     body.emit(assign(r3AB1, bit_or(r3AB4, r3AB7), 0x01));


                  body.instructions = f3AB2_parent_instructions;
                  body.emit(f3AB2);

                  /* END IF */

                  body.emit(assign(r3A7F, r3AB1, 0x01));

                  body.emit(assign(r3A80, r3AB0, 0x01));

                  body.emit(assign(r3A7E, sub(body.constant(int(1)), r3A81), 0x01));


               body.instructions = f3A82_parent_instructions;
               body.emit(f3A82);

               /* END IF */

               body.emit(assign(r3A0A, r3A7E, 0x01));

               body.emit(assign(r3A0D, r3A7F, 0x01));

               body.emit(assign(r3A0E, r3A80, 0x01));


            body.instructions = f3A7A_parent_instructions;
            body.emit(f3A7A);

            /* END IF */


         body.instructions = f3A78_parent_instructions;
         body.emit(f3A78);

         /* END IF */

         /* IF CONDITION */
         ir_if *f3AB8 = new(mem_ctx) ir_if(operand(r3A06).val);
         exec_list *const f3AB8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3AB8->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3ABA = equal(r3A1A, body.constant(int(0)));
            ir_if *f3AB9 = new(mem_ctx) ir_if(operand(r3ABA).val);
            exec_list *const f3AB9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3AB9->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3ABC = bit_or(r3A16, swizzle_x(r34EC));
               ir_expression *const r3ABD = equal(r3ABC, body.constant(0u));
               ir_if *f3ABB = new(mem_ctx) ir_if(operand(r3ABD).val);
               exec_list *const f3ABB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3ABB->then_instructions;

                  ir_variable *const r3ABE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3ABE);
                  body.emit(assign(r3ABE, lshift(r3A08, body.constant(int(31))), 0x02));

                  body.emit(assign(r3ABE, body.constant(0u), 0x01));

                  body.emit(assign(r3A07, r3ABE, 0x03));

                  body.emit(assign(r3A06, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3ABB->else_instructions;

                  ir_variable *const r3ABF = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r3ABF, r3A1A, 0x01));

                  ir_variable *const r3AC0 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r3AC0, r3A16, 0x01));

                  ir_variable *const r3AC1 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r3AC1, r3A15, 0x01));

                  ir_variable *const r3AC2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3AC2);
                  /* IF CONDITION */
                  ir_expression *const r3AC4 = equal(r3A16, body.constant(0u));
                  ir_if *f3AC3 = new(mem_ctx) ir_if(operand(r3AC4).val);
                  exec_list *const f3AC3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3AC3->then_instructions;

                     ir_variable *const r3AC5 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3AC5, r3A15, 0x01));

                     ir_variable *const r3AC6 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3AC7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3AC7);
                     /* IF CONDITION */
                     ir_expression *const r3AC9 = equal(swizzle_x(r34EC), body.constant(0u));
                     ir_if *f3AC8 = new(mem_ctx) ir_if(operand(r3AC9).val);
                     exec_list *const f3AC8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AC8->then_instructions;

                        body.emit(assign(r3AC6, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3AC8->else_instructions;

                        body.emit(assign(r3AC7, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3ACB = bit_and(swizzle_x(r34EC), body.constant(4294901760u));
                        ir_expression *const r3ACC = equal(r3ACB, body.constant(0u));
                        ir_if *f3ACA = new(mem_ctx) ir_if(operand(r3ACC).val);
                        exec_list *const f3ACA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3ACA->then_instructions;

                           body.emit(assign(r3AC7, body.constant(int(16)), 0x01));

                           body.emit(assign(r3AC5, lshift(swizzle_x(r34EC), body.constant(int(16))), 0x01));


                        body.instructions = f3ACA_parent_instructions;
                        body.emit(f3ACA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3ACE = bit_and(r3AC5, body.constant(4278190080u));
                        ir_expression *const r3ACF = equal(r3ACE, body.constant(0u));
                        ir_if *f3ACD = new(mem_ctx) ir_if(operand(r3ACF).val);
                        exec_list *const f3ACD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3ACD->then_instructions;

                           body.emit(assign(r3AC7, add(r3AC7, body.constant(int(8))), 0x01));

                           body.emit(assign(r3AC5, lshift(r3AC5, body.constant(int(8))), 0x01));


                        body.instructions = f3ACD_parent_instructions;
                        body.emit(f3ACD);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AD1 = bit_and(r3AC5, body.constant(4026531840u));
                        ir_expression *const r3AD2 = equal(r3AD1, body.constant(0u));
                        ir_if *f3AD0 = new(mem_ctx) ir_if(operand(r3AD2).val);
                        exec_list *const f3AD0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AD0->then_instructions;

                           body.emit(assign(r3AC7, add(r3AC7, body.constant(int(4))), 0x01));

                           body.emit(assign(r3AC5, lshift(r3AC5, body.constant(int(4))), 0x01));


                        body.instructions = f3AD0_parent_instructions;
                        body.emit(f3AD0);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AD4 = bit_and(r3AC5, body.constant(3221225472u));
                        ir_expression *const r3AD5 = equal(r3AD4, body.constant(0u));
                        ir_if *f3AD3 = new(mem_ctx) ir_if(operand(r3AD5).val);
                        exec_list *const f3AD3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AD3->then_instructions;

                           body.emit(assign(r3AC7, add(r3AC7, body.constant(int(2))), 0x01));

                           body.emit(assign(r3AC5, lshift(r3AC5, body.constant(int(2))), 0x01));


                        body.instructions = f3AD3_parent_instructions;
                        body.emit(f3AD3);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AD7 = bit_and(r3AC5, body.constant(2147483648u));
                        ir_expression *const r3AD8 = equal(r3AD7, body.constant(0u));
                        ir_if *f3AD6 = new(mem_ctx) ir_if(operand(r3AD8).val);
                        exec_list *const f3AD6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AD6->then_instructions;

                           body.emit(assign(r3AC7, add(r3AC7, body.constant(int(1))), 0x01));


                        body.instructions = f3AD6_parent_instructions;
                        body.emit(f3AD6);

                        /* END IF */

                        body.emit(assign(r3AC6, r3AC7, 0x01));


                     body.instructions = f3AC8_parent_instructions;
                     body.emit(f3AC8);

                     /* END IF */

                     body.emit(assign(r3AC2, add(r3AC6, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3ADA = less(r3AC2, body.constant(int(0)));
                     ir_if *f3AD9 = new(mem_ctx) ir_if(operand(r3ADA).val);
                     exec_list *const f3AD9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AD9->then_instructions;

                        ir_expression *const r3ADB = neg(r3AC2);
                        body.emit(assign(r3AC0, rshift(swizzle_x(r34EC), r3ADB), 0x01));

                        ir_expression *const r3ADC = bit_and(r3AC2, body.constant(int(31)));
                        body.emit(assign(r3AC1, lshift(swizzle_x(r34EC), r3ADC), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3AD9->else_instructions;

                        body.emit(assign(r3AC0, lshift(swizzle_x(r34EC), r3AC2), 0x01));

                        body.emit(assign(r3AC1, body.constant(0u), 0x01));


                     body.instructions = f3AD9_parent_instructions;
                     body.emit(f3AD9);

                     /* END IF */

                     body.emit(assign(r3ABF, sub(body.constant(int(-31)), r3AC2), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3AC3->else_instructions;

                     ir_variable *const r3ADD = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3ADD, r3A16, 0x01));

                     ir_variable *const r3ADE = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3ADF = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3ADF);
                     /* IF CONDITION */
                     ir_expression *const r3AE1 = equal(r3A16, body.constant(0u));
                     ir_if *f3AE0 = new(mem_ctx) ir_if(operand(r3AE1).val);
                     exec_list *const f3AE0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AE0->then_instructions;

                        body.emit(assign(r3ADE, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3AE0->else_instructions;

                        body.emit(assign(r3ADF, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3AE3 = bit_and(r3A16, body.constant(4294901760u));
                        ir_expression *const r3AE4 = equal(r3AE3, body.constant(0u));
                        ir_if *f3AE2 = new(mem_ctx) ir_if(operand(r3AE4).val);
                        exec_list *const f3AE2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AE2->then_instructions;

                           body.emit(assign(r3ADF, body.constant(int(16)), 0x01));

                           body.emit(assign(r3ADD, lshift(r3A16, body.constant(int(16))), 0x01));


                        body.instructions = f3AE2_parent_instructions;
                        body.emit(f3AE2);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AE6 = bit_and(r3ADD, body.constant(4278190080u));
                        ir_expression *const r3AE7 = equal(r3AE6, body.constant(0u));
                        ir_if *f3AE5 = new(mem_ctx) ir_if(operand(r3AE7).val);
                        exec_list *const f3AE5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AE5->then_instructions;

                           body.emit(assign(r3ADF, add(r3ADF, body.constant(int(8))), 0x01));

                           body.emit(assign(r3ADD, lshift(r3ADD, body.constant(int(8))), 0x01));


                        body.instructions = f3AE5_parent_instructions;
                        body.emit(f3AE5);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AE9 = bit_and(r3ADD, body.constant(4026531840u));
                        ir_expression *const r3AEA = equal(r3AE9, body.constant(0u));
                        ir_if *f3AE8 = new(mem_ctx) ir_if(operand(r3AEA).val);
                        exec_list *const f3AE8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AE8->then_instructions;

                           body.emit(assign(r3ADF, add(r3ADF, body.constant(int(4))), 0x01));

                           body.emit(assign(r3ADD, lshift(r3ADD, body.constant(int(4))), 0x01));


                        body.instructions = f3AE8_parent_instructions;
                        body.emit(f3AE8);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AEC = bit_and(r3ADD, body.constant(3221225472u));
                        ir_expression *const r3AED = equal(r3AEC, body.constant(0u));
                        ir_if *f3AEB = new(mem_ctx) ir_if(operand(r3AED).val);
                        exec_list *const f3AEB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AEB->then_instructions;

                           body.emit(assign(r3ADF, add(r3ADF, body.constant(int(2))), 0x01));

                           body.emit(assign(r3ADD, lshift(r3ADD, body.constant(int(2))), 0x01));


                        body.instructions = f3AEB_parent_instructions;
                        body.emit(f3AEB);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AEF = bit_and(r3ADD, body.constant(2147483648u));
                        ir_expression *const r3AF0 = equal(r3AEF, body.constant(0u));
                        ir_if *f3AEE = new(mem_ctx) ir_if(operand(r3AF0).val);
                        exec_list *const f3AEE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AEE->then_instructions;

                           body.emit(assign(r3ADF, add(r3ADF, body.constant(int(1))), 0x01));


                        body.instructions = f3AEE_parent_instructions;
                        body.emit(f3AEE);

                        /* END IF */

                        body.emit(assign(r3ADE, r3ADF, 0x01));


                     body.instructions = f3AE0_parent_instructions;
                     body.emit(f3AE0);

                     /* END IF */

                     body.emit(assign(r3AC2, add(r3ADE, body.constant(int(-11))), 0x01));

                     ir_variable *const r3AF1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3AF1, lshift(swizzle_x(r34EC), r3AC2), 0x01));

                     ir_variable *const r3AF2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3AF4 = equal(r3AC2, body.constant(int(0)));
                     ir_if *f3AF3 = new(mem_ctx) ir_if(operand(r3AF4).val);
                     exec_list *const f3AF3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AF3->then_instructions;

                        body.emit(assign(r3AF2, r3A16, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3AF3->else_instructions;

                        ir_expression *const r3AF5 = lshift(r3A16, r3AC2);
                        ir_expression *const r3AF6 = neg(r3AC2);
                        ir_expression *const r3AF7 = bit_and(r3AF6, body.constant(int(31)));
                        ir_expression *const r3AF8 = rshift(swizzle_x(r34EC), r3AF7);
                        body.emit(assign(r3AF2, bit_or(r3AF5, r3AF8), 0x01));


                     body.instructions = f3AF3_parent_instructions;
                     body.emit(f3AF3);

                     /* END IF */

                     body.emit(assign(r3AC0, r3AF2, 0x01));

                     body.emit(assign(r3AC1, r3AF1, 0x01));

                     body.emit(assign(r3ABF, sub(body.constant(int(1)), r3AC2), 0x01));


                  body.instructions = f3AC3_parent_instructions;
                  body.emit(f3AC3);

                  /* END IF */

                  body.emit(assign(r3A09, r3ABF, 0x01));

                  body.emit(assign(r3A0B, r3AC0, 0x01));

                  body.emit(assign(r3A0C, r3AC1, 0x01));


               body.instructions = f3ABB_parent_instructions;
               body.emit(f3ABB);

               /* END IF */


            body.instructions = f3AB9_parent_instructions;
            body.emit(f3AB9);

            /* END IF */

            /* IF CONDITION */
            ir_if *f3AF9 = new(mem_ctx) ir_if(operand(r3A06).val);
            exec_list *const f3AF9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3AF9->then_instructions;

               ir_expression *const r3AFA = add(r3A0A, r3A09);
               body.emit(assign(r3A0F, add(r3AFA, body.constant(int(-1024))), 0x01));

               body.emit(assign(r3A0D, bit_or(r3A0D, body.constant(1048576u)), 0x01));

               ir_variable *const r3AFB = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3AFB, lshift(r3A0C, body.constant(int(12))), 0x01));

               ir_variable *const r3AFC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r3AFD = lshift(r3A0B, body.constant(int(12)));
               ir_expression *const r3AFE = rshift(r3A0C, body.constant(int(20)));
               body.emit(assign(r3AFC, bit_or(r3AFD, r3AFE), 0x01));

               body.emit(assign(r3A0B, r3AFC, 0x01));

               body.emit(assign(r3A0C, r3AFB, 0x01));

               ir_variable *const r3AFF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3AFF);
               ir_variable *const r3B00 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3B00);
               ir_variable *const r3B01 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3B01);
               ir_variable *const r3B02 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B02, bit_and(r3A0E, body.constant(65535u)), 0x01));

               ir_variable *const r3B03 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B03, rshift(r3A0E, body.constant(int(16))), 0x01));

               ir_variable *const r3B04 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B04, bit_and(r3AFB, body.constant(65535u)), 0x01));

               ir_variable *const r3B05 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B05, rshift(r3AFB, body.constant(int(16))), 0x01));

               ir_variable *const r3B06 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B06, mul(r3B03, r3B04), 0x01));

               ir_expression *const r3B07 = mul(r3B02, r3B05);
               body.emit(assign(r3B00, add(r3B07, r3B06), 0x01));

               ir_expression *const r3B08 = mul(r3B03, r3B05);
               ir_expression *const r3B09 = less(r3B00, r3B06);
               ir_expression *const r3B0A = expr(ir_unop_b2i, r3B09);
               ir_expression *const r3B0B = expr(ir_unop_i2u, r3B0A);
               ir_expression *const r3B0C = lshift(r3B0B, body.constant(int(16)));
               ir_expression *const r3B0D = rshift(r3B00, body.constant(int(16)));
               ir_expression *const r3B0E = add(r3B0C, r3B0D);
               body.emit(assign(r3AFF, add(r3B08, r3B0E), 0x01));

               body.emit(assign(r3B00, lshift(r3B00, body.constant(int(16))), 0x01));

               ir_expression *const r3B0F = mul(r3B02, r3B04);
               body.emit(assign(r3B01, add(r3B0F, r3B00), 0x01));

               ir_expression *const r3B10 = less(r3B01, r3B00);
               ir_expression *const r3B11 = expr(ir_unop_b2i, r3B10);
               ir_expression *const r3B12 = expr(ir_unop_i2u, r3B11);
               body.emit(assign(r3AFF, add(r3AFF, r3B12), 0x01));

               ir_variable *const r3B13 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3B13);
               ir_variable *const r3B14 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3B14);
               ir_variable *const r3B15 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3B15);
               ir_variable *const r3B16 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B16, bit_and(r3A0E, body.constant(65535u)), 0x01));

               ir_variable *const r3B17 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B17, rshift(r3A0E, body.constant(int(16))), 0x01));

               ir_variable *const r3B18 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B18, bit_and(r3AFC, body.constant(65535u)), 0x01));

               ir_variable *const r3B19 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B19, rshift(r3AFC, body.constant(int(16))), 0x01));

               ir_variable *const r3B1A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B1A, mul(r3B17, r3B18), 0x01));

               ir_expression *const r3B1B = mul(r3B16, r3B19);
               body.emit(assign(r3B14, add(r3B1B, r3B1A), 0x01));

               ir_expression *const r3B1C = mul(r3B17, r3B19);
               ir_expression *const r3B1D = less(r3B14, r3B1A);
               ir_expression *const r3B1E = expr(ir_unop_b2i, r3B1D);
               ir_expression *const r3B1F = expr(ir_unop_i2u, r3B1E);
               ir_expression *const r3B20 = lshift(r3B1F, body.constant(int(16)));
               ir_expression *const r3B21 = rshift(r3B14, body.constant(int(16)));
               ir_expression *const r3B22 = add(r3B20, r3B21);
               body.emit(assign(r3B13, add(r3B1C, r3B22), 0x01));

               body.emit(assign(r3B14, lshift(r3B14, body.constant(int(16))), 0x01));

               ir_expression *const r3B23 = mul(r3B16, r3B18);
               body.emit(assign(r3B15, add(r3B23, r3B14), 0x01));

               ir_expression *const r3B24 = less(r3B15, r3B14);
               ir_expression *const r3B25 = expr(ir_unop_b2i, r3B24);
               ir_expression *const r3B26 = expr(ir_unop_i2u, r3B25);
               body.emit(assign(r3B13, add(r3B13, r3B26), 0x01));

               ir_variable *const r3B27 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B27, add(r3B15, r3AFF), 0x01));

               ir_variable *const r3B28 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3B28);
               ir_variable *const r3B29 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3B29);
               ir_variable *const r3B2A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3B2A);
               ir_variable *const r3B2B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B2B, bit_and(r3A0D, body.constant(65535u)), 0x01));

               ir_variable *const r3B2C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B2C, rshift(r3A0D, body.constant(int(16))), 0x01));

               ir_variable *const r3B2D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B2D, bit_and(r3AFC, body.constant(65535u)), 0x01));

               ir_variable *const r3B2E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B2E, rshift(r3AFC, body.constant(int(16))), 0x01));

               ir_variable *const r3B2F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B2F, mul(r3B2C, r3B2D), 0x01));

               ir_expression *const r3B30 = mul(r3B2B, r3B2E);
               body.emit(assign(r3B29, add(r3B30, r3B2F), 0x01));

               ir_expression *const r3B31 = mul(r3B2C, r3B2E);
               ir_expression *const r3B32 = less(r3B29, r3B2F);
               ir_expression *const r3B33 = expr(ir_unop_b2i, r3B32);
               ir_expression *const r3B34 = expr(ir_unop_i2u, r3B33);
               ir_expression *const r3B35 = lshift(r3B34, body.constant(int(16)));
               ir_expression *const r3B36 = rshift(r3B29, body.constant(int(16)));
               ir_expression *const r3B37 = add(r3B35, r3B36);
               body.emit(assign(r3B28, add(r3B31, r3B37), 0x01));

               body.emit(assign(r3B29, lshift(r3B29, body.constant(int(16))), 0x01));

               ir_expression *const r3B38 = mul(r3B2B, r3B2D);
               body.emit(assign(r3B2A, add(r3B38, r3B29), 0x01));

               ir_expression *const r3B39 = less(r3B2A, r3B29);
               ir_expression *const r3B3A = expr(ir_unop_b2i, r3B39);
               ir_expression *const r3B3B = expr(ir_unop_i2u, r3B3A);
               body.emit(assign(r3B28, add(r3B28, r3B3B), 0x01));

               ir_variable *const r3B3C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r3B3D = less(r3B27, r3B15);
               ir_expression *const r3B3E = expr(ir_unop_b2i, r3B3D);
               ir_expression *const r3B3F = expr(ir_unop_i2u, r3B3E);
               ir_expression *const r3B40 = add(r3B13, r3B3F);
               body.emit(assign(r3B3C, add(r3B2A, r3B40), 0x01));

               ir_variable *const r3B41 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3B41);
               ir_variable *const r3B42 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3B42);
               ir_variable *const r3B43 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3B43);
               ir_variable *const r3B44 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B44, bit_and(r3A0D, body.constant(65535u)), 0x01));

               ir_variable *const r3B45 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B45, rshift(r3A0D, body.constant(int(16))), 0x01));

               ir_variable *const r3B46 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B46, bit_and(r3AFB, body.constant(65535u)), 0x01));

               ir_variable *const r3B47 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B47, rshift(r3AFB, body.constant(int(16))), 0x01));

               ir_variable *const r3B48 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B48, mul(r3B45, r3B46), 0x01));

               ir_expression *const r3B49 = mul(r3B44, r3B47);
               body.emit(assign(r3B42, add(r3B49, r3B48), 0x01));

               ir_expression *const r3B4A = mul(r3B45, r3B47);
               ir_expression *const r3B4B = less(r3B42, r3B48);
               ir_expression *const r3B4C = expr(ir_unop_b2i, r3B4B);
               ir_expression *const r3B4D = expr(ir_unop_i2u, r3B4C);
               ir_expression *const r3B4E = lshift(r3B4D, body.constant(int(16)));
               ir_expression *const r3B4F = rshift(r3B42, body.constant(int(16)));
               ir_expression *const r3B50 = add(r3B4E, r3B4F);
               body.emit(assign(r3B41, add(r3B4A, r3B50), 0x01));

               body.emit(assign(r3B42, lshift(r3B42, body.constant(int(16))), 0x01));

               ir_expression *const r3B51 = mul(r3B44, r3B46);
               body.emit(assign(r3B43, add(r3B51, r3B42), 0x01));

               ir_expression *const r3B52 = less(r3B43, r3B42);
               ir_expression *const r3B53 = expr(ir_unop_b2i, r3B52);
               ir_expression *const r3B54 = expr(ir_unop_i2u, r3B53);
               body.emit(assign(r3B41, add(r3B41, r3B54), 0x01));

               ir_variable *const r3B55 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B55, add(r3B43, r3B27), 0x01));

               ir_variable *const r3B56 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r3B57 = less(r3B55, r3B43);
               ir_expression *const r3B58 = expr(ir_unop_b2i, r3B57);
               ir_expression *const r3B59 = expr(ir_unop_i2u, r3B58);
               ir_expression *const r3B5A = add(r3B41, r3B59);
               body.emit(assign(r3B56, add(r3B3C, r3B5A), 0x01));

               ir_variable *const r3B5B = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r3B5C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B5C, add(r3B56, r3A0E), 0x01));

               ir_expression *const r3B5D = less(r3B3C, r3B2A);
               ir_expression *const r3B5E = expr(ir_unop_b2i, r3B5D);
               ir_expression *const r3B5F = expr(ir_unop_i2u, r3B5E);
               ir_expression *const r3B60 = add(r3B28, r3B5F);
               ir_expression *const r3B61 = less(r3B56, r3B3C);
               ir_expression *const r3B62 = expr(ir_unop_b2i, r3B61);
               ir_expression *const r3B63 = expr(ir_unop_i2u, r3B62);
               ir_expression *const r3B64 = add(r3B60, r3B63);
               ir_expression *const r3B65 = add(r3B64, r3A0D);
               ir_expression *const r3B66 = less(r3B5C, r3B56);
               ir_expression *const r3B67 = expr(ir_unop_b2i, r3B66);
               ir_expression *const r3B68 = expr(ir_unop_i2u, r3B67);
               body.emit(assign(r3B5B, add(r3B65, r3B68), 0x01));

               body.emit(assign(r3A12, r3B5B, 0x01));

               body.emit(assign(r3A11, r3B5C, 0x01));

               ir_expression *const r3B69 = nequal(r3B01, body.constant(0u));
               ir_expression *const r3B6A = expr(ir_unop_b2i, r3B69);
               ir_expression *const r3B6B = expr(ir_unop_i2u, r3B6A);
               body.emit(assign(r3A10, bit_or(r3B55, r3B6B), 0x01));

               /* IF CONDITION */
               ir_expression *const r3B6D = lequal(body.constant(2097152u), r3B5B);
               ir_if *f3B6C = new(mem_ctx) ir_if(operand(r3B6D).val);
               exec_list *const f3B6C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3B6C->then_instructions;

                  ir_variable *const r3B6E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r3B6E);
                  body.emit(assign(r3B6E, lshift(r3B5C, body.constant(int(31))), 0x01));

                  ir_expression *const r3B6F = nequal(r3A10, body.constant(0u));
                  ir_expression *const r3B70 = expr(ir_unop_b2i, r3B6F);
                  ir_expression *const r3B71 = expr(ir_unop_i2u, r3B70);
                  body.emit(assign(r3B6E, bit_or(r3B6E, r3B71), 0x01));

                  body.emit(assign(r3A12, rshift(r3B5B, body.constant(int(1))), 0x01));

                  ir_expression *const r3B72 = lshift(r3B5B, body.constant(int(31)));
                  ir_expression *const r3B73 = rshift(r3B5C, body.constant(int(1)));
                  body.emit(assign(r3A11, bit_or(r3B72, r3B73), 0x01));

                  body.emit(assign(r3A10, r3B6E, 0x01));

                  body.emit(assign(r3A0F, add(r3A0F, body.constant(int(1))), 0x01));


               body.instructions = f3B6C_parent_instructions;
               body.emit(f3B6C);

               /* END IF */

               ir_variable *const r3B74 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3B74, r3A0F, 0x01));

               ir_variable *const r3B75 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3B75, r3A12, 0x01));

               ir_variable *const r3B76 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3B76, r3A11, 0x01));

               ir_variable *const r3B77 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3B77, r3A10, 0x01));

               ir_variable *const r3B78 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r3B78, body.constant(true), 0x01));

               ir_variable *const r3B79 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3B7A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3B7A);
               ir_expression *const r3B7B = expr(ir_unop_u2i, r3A10);
               body.emit(assign(r3B7A, less(r3B7B, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3B7D = lequal(body.constant(int(2045)), r3A0F);
               ir_if *f3B7C = new(mem_ctx) ir_if(operand(r3B7D).val);
               exec_list *const f3B7C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3B7C->then_instructions;

                  ir_variable *const r3B7E = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3B80 = less(body.constant(int(2045)), r3A0F);
                  ir_if *f3B7F = new(mem_ctx) ir_if(operand(r3B80).val);
                  exec_list *const f3B7F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B7F->then_instructions;

                     body.emit(assign(r3B7E, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3B7F->else_instructions;

                     ir_variable *const r3B81 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3B83 = equal(r3A0F, body.constant(int(2045)));
                     ir_if *f3B82 = new(mem_ctx) ir_if(operand(r3B83).val);
                     exec_list *const f3B82_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B82->then_instructions;

                        ir_expression *const r3B84 = equal(body.constant(2097151u), r3A12);
                        ir_expression *const r3B85 = equal(body.constant(4294967295u), r3A11);
                        body.emit(assign(r3B81, logic_and(r3B84, r3B85), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3B82->else_instructions;

                        body.emit(assign(r3B81, body.constant(false), 0x01));


                     body.instructions = f3B82_parent_instructions;
                     body.emit(f3B82);

                     /* END IF */

                     body.emit(assign(r3B7E, logic_and(r3B81, r3B7A), 0x01));


                  body.instructions = f3B7F_parent_instructions;
                  body.emit(f3B7F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3B86 = new(mem_ctx) ir_if(operand(r3B7E).val);
                  exec_list *const f3B86_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B86->then_instructions;

                     ir_variable *const r3B87 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3B87);
                     ir_expression *const r3B88 = lshift(r3A08, body.constant(int(31)));
                     body.emit(assign(r3B87, add(r3B88, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3B87, body.constant(0u), 0x01));

                     body.emit(assign(r3B79, r3B87, 0x03));

                     body.emit(assign(r3B78, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3B86->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3B8A = less(r3A0F, body.constant(int(0)));
                     ir_if *f3B89 = new(mem_ctx) ir_if(operand(r3B8A).val);
                     exec_list *const f3B89_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B89->then_instructions;

                        ir_variable *const r3B8B = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3B8B, r3A10, 0x01));

                        ir_variable *const r3B8C = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3B8C, neg(r3A0F), 0x01));

                        ir_variable *const r3B8D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3B8D);
                        ir_variable *const r3B8E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3B8E);
                        ir_variable *const r3B8F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3B8F);
                        ir_variable *const r3B90 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3B91 = neg(r3B8C);
                        body.emit(assign(r3B90, bit_and(r3B91, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3B93 = equal(r3B8C, body.constant(int(0)));
                        ir_if *f3B92 = new(mem_ctx) ir_if(operand(r3B93).val);
                        exec_list *const f3B92_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3B92->then_instructions;

                           body.emit(assign(r3B8D, r3A10, 0x01));

                           body.emit(assign(r3B8E, r3A11, 0x01));

                           body.emit(assign(r3B8F, r3A12, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3B92->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3B95 = less(r3B8C, body.constant(int(32)));
                           ir_if *f3B94 = new(mem_ctx) ir_if(operand(r3B95).val);
                           exec_list *const f3B94_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3B94->then_instructions;

                              body.emit(assign(r3B8D, lshift(r3A11, r3B90), 0x01));

                              ir_expression *const r3B96 = lshift(r3A12, r3B90);
                              ir_expression *const r3B97 = rshift(r3A11, r3B8C);
                              body.emit(assign(r3B8E, bit_or(r3B96, r3B97), 0x01));

                              body.emit(assign(r3B8F, rshift(r3A12, r3B8C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3B94->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3B99 = equal(r3B8C, body.constant(int(32)));
                              ir_if *f3B98 = new(mem_ctx) ir_if(operand(r3B99).val);
                              exec_list *const f3B98_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3B98->then_instructions;

                                 body.emit(assign(r3B8D, r3A11, 0x01));

                                 body.emit(assign(r3B8E, r3A12, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3B98->else_instructions;

                                 body.emit(assign(r3B8B, bit_or(r3A10, r3A11), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3B9B = less(r3B8C, body.constant(int(64)));
                                 ir_if *f3B9A = new(mem_ctx) ir_if(operand(r3B9B).val);
                                 exec_list *const f3B9A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3B9A->then_instructions;

                                    body.emit(assign(r3B8D, lshift(r3A12, r3B90), 0x01));

                                    ir_expression *const r3B9C = bit_and(r3B8C, body.constant(int(31)));
                                    body.emit(assign(r3B8E, rshift(r3A12, r3B9C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3B9A->else_instructions;

                                    ir_variable *const r3B9D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3B9F = equal(r3B8C, body.constant(int(64)));
                                    ir_if *f3B9E = new(mem_ctx) ir_if(operand(r3B9F).val);
                                    exec_list *const f3B9E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3B9E->then_instructions;

                                       body.emit(assign(r3B9D, r3A12, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3B9E->else_instructions;

                                       ir_expression *const r3BA0 = nequal(r3A12, body.constant(0u));
                                       ir_expression *const r3BA1 = expr(ir_unop_b2i, r3BA0);
                                       body.emit(assign(r3B9D, expr(ir_unop_i2u, r3BA1), 0x01));


                                    body.instructions = f3B9E_parent_instructions;
                                    body.emit(f3B9E);

                                    /* END IF */

                                    body.emit(assign(r3B8D, r3B9D, 0x01));

                                    body.emit(assign(r3B8E, body.constant(0u), 0x01));


                                 body.instructions = f3B9A_parent_instructions;
                                 body.emit(f3B9A);

                                 /* END IF */


                              body.instructions = f3B98_parent_instructions;
                              body.emit(f3B98);

                              /* END IF */

                              body.emit(assign(r3B8F, body.constant(0u), 0x01));


                           body.instructions = f3B94_parent_instructions;
                           body.emit(f3B94);

                           /* END IF */

                           ir_expression *const r3BA2 = nequal(r3B8B, body.constant(0u));
                           ir_expression *const r3BA3 = expr(ir_unop_b2i, r3BA2);
                           ir_expression *const r3BA4 = expr(ir_unop_i2u, r3BA3);
                           body.emit(assign(r3B8D, bit_or(r3B8D, r3BA4), 0x01));


                        body.instructions = f3B92_parent_instructions;
                        body.emit(f3B92);

                        /* END IF */

                        body.emit(assign(r3B75, r3B8F, 0x01));

                        body.emit(assign(r3B76, r3B8E, 0x01));

                        body.emit(assign(r3B77, r3B8D, 0x01));

                        body.emit(assign(r3B74, body.constant(int(0)), 0x01));

                        body.emit(assign(r3B7A, less(r3B8D, body.constant(0u)), 0x01));


                     body.instructions = f3B89_parent_instructions;
                     body.emit(f3B89);

                     /* END IF */


                  body.instructions = f3B86_parent_instructions;
                  body.emit(f3B86);

                  /* END IF */


               body.instructions = f3B7C_parent_instructions;
               body.emit(f3B7C);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3BA5 = new(mem_ctx) ir_if(operand(r3B78).val);
               exec_list *const f3BA5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3BA5->then_instructions;

                  /* IF CONDITION */
                  ir_if *f3BA6 = new(mem_ctx) ir_if(operand(r3B7A).val);
                  exec_list *const f3BA6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3BA6->then_instructions;

                     ir_variable *const r3BA7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3BA7, add(r3B76, body.constant(1u)), 0x01));

                     ir_expression *const r3BA8 = less(r3BA7, r3B76);
                     ir_expression *const r3BA9 = expr(ir_unop_b2i, r3BA8);
                     ir_expression *const r3BAA = expr(ir_unop_i2u, r3BA9);
                     body.emit(assign(r3B75, add(r3B75, r3BAA), 0x01));

                     ir_expression *const r3BAB = equal(r3B77, body.constant(0u));
                     ir_expression *const r3BAC = expr(ir_unop_b2i, r3BAB);
                     ir_expression *const r3BAD = expr(ir_unop_i2u, r3BAC);
                     ir_expression *const r3BAE = add(r3B77, r3BAD);
                     ir_expression *const r3BAF = bit_and(r3BAE, body.constant(1u));
                     ir_expression *const r3BB0 = expr(ir_unop_bit_not, r3BAF);
                     body.emit(assign(r3B76, bit_and(r3BA7, r3BB0), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3BA6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3BB2 = bit_or(r3B75, r3B76);
                     ir_expression *const r3BB3 = equal(r3BB2, body.constant(0u));
                     ir_if *f3BB1 = new(mem_ctx) ir_if(operand(r3BB3).val);
                     exec_list *const f3BB1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3BB1->then_instructions;

                        body.emit(assign(r3B74, body.constant(int(0)), 0x01));


                     body.instructions = f3BB1_parent_instructions;
                     body.emit(f3BB1);

                     /* END IF */


                  body.instructions = f3BA6_parent_instructions;
                  body.emit(f3BA6);

                  /* END IF */

                  ir_variable *const r3BB4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3BB4);
                  ir_expression *const r3BB5 = lshift(r3A08, body.constant(int(31)));
                  ir_expression *const r3BB6 = expr(ir_unop_i2u, r3B74);
                  ir_expression *const r3BB7 = lshift(r3BB6, body.constant(int(20)));
                  ir_expression *const r3BB8 = add(r3BB5, r3BB7);
                  body.emit(assign(r3BB4, add(r3BB8, r3B75), 0x02));

                  body.emit(assign(r3BB4, r3B76, 0x01));

                  body.emit(assign(r3B79, r3BB4, 0x03));

                  body.emit(assign(r3B78, body.constant(false), 0x01));


               body.instructions = f3BA5_parent_instructions;
               body.emit(f3BA5);

               /* END IF */

               body.emit(assign(r3A07, r3B79, 0x03));

               body.emit(assign(r3A06, body.constant(false), 0x01));


            body.instructions = f3AF9_parent_instructions;
            body.emit(f3AF9);

            /* END IF */


         body.instructions = f3AB8_parent_instructions;
         body.emit(f3AB8);

         /* END IF */


      body.instructions = f3A4E_parent_instructions;
      body.emit(f3A4E);

      /* END IF */


   body.instructions = f3A1F_parent_instructions;
   body.emit(f3A1F);

   /* END IF */

   ir_variable *const r3BB9 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r3BBA = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r3BBA, rshift(swizzle_y(r3247), body.constant(int(31))), 0x01));

   ir_variable *const r3BBB = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r3BBB, rshift(swizzle_y(r3A07), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r3BBD = equal(r3BBA, r3BBB);
   ir_if *f3BBC = new(mem_ctx) ir_if(operand(r3BBD).val);
   exec_list *const f3BBC_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f3BBC->then_instructions;

      ir_variable *const r3BBE = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r3BBE, r3BBA, 0x01));

      ir_variable *const r3BBF = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r3BC0 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r3BC0);
      ir_variable *const r3BC1 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r3BC1);
      ir_variable *const r3BC2 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r3BC2);
      ir_variable *const r3BC3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r3BC3);
      ir_variable *const r3BC4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r3BC4);
      ir_variable *const r3BC5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r3BC5);
      ir_variable *const r3BC6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r3BC6);
      ir_variable *const r3BC7 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r3BC7);
      ir_variable *const r3BC8 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3BC9 = rshift(swizzle_y(r3247), body.constant(int(20)));
      ir_expression *const r3BCA = bit_and(r3BC9, body.constant(2047u));
      body.emit(assign(r3BC8, expr(ir_unop_u2i, r3BCA), 0x01));

      body.emit(assign(r3BC2, r3BC8, 0x01));

      ir_variable *const r3BCB = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3BCC = rshift(swizzle_y(r3A07), body.constant(int(20)));
      ir_expression *const r3BCD = bit_and(r3BCC, body.constant(2047u));
      body.emit(assign(r3BCB, expr(ir_unop_u2i, r3BCD), 0x01));

      body.emit(assign(r3BC1, r3BCB, 0x01));

      body.emit(assign(r3BC0, sub(r3BC8, r3BCB), 0x01));

      ir_variable *const r3BCE = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r3BCE, lshift(swizzle_x(r3247), body.constant(int(10))), 0x01));

      ir_variable *const r3BCF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r3BD0 = bit_and(swizzle_y(r3247), body.constant(1048575u));
      ir_expression *const r3BD1 = lshift(r3BD0, body.constant(int(10)));
      ir_expression *const r3BD2 = rshift(swizzle_x(r3247), body.constant(int(22)));
      body.emit(assign(r3BCF, bit_or(r3BD1, r3BD2), 0x01));

      body.emit(assign(r3BC5, r3BCF, 0x01));

      body.emit(assign(r3BC6, r3BCE, 0x01));

      ir_variable *const r3BD3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r3BD3, lshift(swizzle_x(r3A07), body.constant(int(10))), 0x01));

      ir_variable *const r3BD4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r3BD5 = bit_and(swizzle_y(r3A07), body.constant(1048575u));
      ir_expression *const r3BD6 = lshift(r3BD5, body.constant(int(10)));
      ir_expression *const r3BD7 = rshift(swizzle_x(r3A07), body.constant(int(22)));
      body.emit(assign(r3BD4, bit_or(r3BD6, r3BD7), 0x01));

      body.emit(assign(r3BC3, r3BD4, 0x01));

      body.emit(assign(r3BC4, r3BD3, 0x01));

      /* IF CONDITION */
      ir_expression *const r3BD9 = less(body.constant(int(0)), r3BC0);
      ir_if *f3BD8 = new(mem_ctx) ir_if(operand(r3BD9).val);
      exec_list *const f3BD8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3BD8->then_instructions;

         /* IF CONDITION */
         ir_expression *const r3BDB = equal(r3BC8, body.constant(int(2047)));
         ir_if *f3BDA = new(mem_ctx) ir_if(operand(r3BDB).val);
         exec_list *const f3BDA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3BDA->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3BDD = bit_or(r3BCF, r3BCE);
            ir_expression *const r3BDE = nequal(r3BDD, body.constant(0u));
            ir_if *f3BDC = new(mem_ctx) ir_if(operand(r3BDE).val);
            exec_list *const f3BDC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3BDC->then_instructions;

               ir_variable *const r3BDF = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r3BDF, swizzle_x(r3247), 0x01));

               ir_variable *const r3BE0 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r3BE0, swizzle_x(r3A07), 0x01));

               ir_variable *const r3BE1 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3BE2 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r3BE3 = rshift(swizzle_y(r3247), body.constant(int(19)));
               ir_expression *const r3BE4 = bit_and(r3BE3, body.constant(4095u));
               ir_expression *const r3BE5 = equal(r3BE4, body.constant(4094u));
               ir_expression *const r3BE6 = nequal(swizzle_x(r3247), body.constant(0u));
               ir_expression *const r3BE7 = bit_and(swizzle_y(r3247), body.constant(524287u));
               ir_expression *const r3BE8 = nequal(r3BE7, body.constant(0u));
               ir_expression *const r3BE9 = logic_or(r3BE6, r3BE8);
               body.emit(assign(r3BE2, logic_and(r3BE5, r3BE9), 0x01));

               ir_variable *const r3BEA = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r3BEB = lshift(swizzle_y(r3A07), body.constant(int(1)));
               ir_expression *const r3BEC = lequal(body.constant(4292870144u), r3BEB);
               ir_expression *const r3BED = nequal(swizzle_x(r3A07), body.constant(0u));
               ir_expression *const r3BEE = bit_and(swizzle_y(r3A07), body.constant(1048575u));
               ir_expression *const r3BEF = nequal(r3BEE, body.constant(0u));
               ir_expression *const r3BF0 = logic_or(r3BED, r3BEF);
               body.emit(assign(r3BEA, logic_and(r3BEC, r3BF0), 0x01));

               body.emit(assign(r3BDF, bit_or(swizzle_y(r3247), body.constant(524288u)), 0x02));

               body.emit(assign(r3BE0, bit_or(swizzle_y(r3A07), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r3BF2 = lshift(swizzle_y(r3247), body.constant(int(1)));
               ir_expression *const r3BF3 = lequal(body.constant(4292870144u), r3BF2);
               ir_expression *const r3BF4 = nequal(swizzle_x(r3247), body.constant(0u));
               ir_expression *const r3BF5 = bit_and(swizzle_y(r3247), body.constant(1048575u));
               ir_expression *const r3BF6 = nequal(r3BF5, body.constant(0u));
               ir_expression *const r3BF7 = logic_or(r3BF4, r3BF6);
               ir_expression *const r3BF8 = logic_and(r3BF3, r3BF7);
               ir_if *f3BF1 = new(mem_ctx) ir_if(operand(r3BF8).val);
               exec_list *const f3BF1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3BF1->then_instructions;

                  ir_variable *const r3BF9 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3BFB = logic_and(r3BE2, r3BEA);
                  ir_if *f3BFA = new(mem_ctx) ir_if(operand(r3BFB).val);
                  exec_list *const f3BFA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3BFA->then_instructions;

                     body.emit(assign(r3BF9, r3BE0, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3BFA->else_instructions;

                     body.emit(assign(r3BF9, r3BDF, 0x03));


                  body.instructions = f3BFA_parent_instructions;
                  body.emit(f3BFA);

                  /* END IF */

                  body.emit(assign(r3BE1, r3BF9, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3BF1->else_instructions;

                  body.emit(assign(r3BE1, r3BE0, 0x03));


               body.instructions = f3BF1_parent_instructions;
               body.emit(f3BF1);

               /* END IF */

               body.emit(assign(r3BBF, r3BE1, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3BDC->else_instructions;

               body.emit(assign(r3BBF, r3247, 0x03));


            body.instructions = f3BDC_parent_instructions;
            body.emit(f3BDC);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3BDA->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3BFD = equal(r3BCB, body.constant(int(0)));
            ir_if *f3BFC = new(mem_ctx) ir_if(operand(r3BFD).val);
            exec_list *const f3BFC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3BFC->then_instructions;

               body.emit(assign(r3BC0, add(r3BC0, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3BFC->else_instructions;

               body.emit(assign(r3BC3, bit_or(r3BD4, body.constant(1073741824u)), 0x01));


            body.instructions = f3BFC_parent_instructions;
            body.emit(f3BFC);

            /* END IF */

            ir_variable *const r3BFE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r3BFE);
            ir_variable *const r3BFF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r3BFF);
            ir_variable *const r3C00 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r3C01 = neg(r3BC0);
            body.emit(assign(r3C00, bit_and(r3C01, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3C03 = equal(r3BC0, body.constant(int(0)));
            ir_if *f3C02 = new(mem_ctx) ir_if(operand(r3C03).val);
            exec_list *const f3C02_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C02->then_instructions;

               body.emit(assign(r3BFE, r3BD3, 0x01));

               body.emit(assign(r3BFF, r3BC3, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3C02->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3C05 = less(r3BC0, body.constant(int(32)));
               ir_if *f3C04 = new(mem_ctx) ir_if(operand(r3C05).val);
               exec_list *const f3C04_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C04->then_instructions;

                  ir_expression *const r3C06 = lshift(r3BC3, r3C00);
                  ir_expression *const r3C07 = rshift(r3BD3, r3BC0);
                  ir_expression *const r3C08 = bit_or(r3C06, r3C07);
                  ir_expression *const r3C09 = lshift(r3BD3, r3C00);
                  ir_expression *const r3C0A = nequal(r3C09, body.constant(0u));
                  ir_expression *const r3C0B = expr(ir_unop_b2i, r3C0A);
                  ir_expression *const r3C0C = expr(ir_unop_i2u, r3C0B);
                  body.emit(assign(r3BFE, bit_or(r3C08, r3C0C), 0x01));

                  body.emit(assign(r3BFF, rshift(r3BC3, r3BC0), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C04->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3C0E = equal(r3BC0, body.constant(int(32)));
                  ir_if *f3C0D = new(mem_ctx) ir_if(operand(r3C0E).val);
                  exec_list *const f3C0D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C0D->then_instructions;

                     ir_expression *const r3C0F = nequal(r3BD3, body.constant(0u));
                     ir_expression *const r3C10 = expr(ir_unop_b2i, r3C0F);
                     ir_expression *const r3C11 = expr(ir_unop_i2u, r3C10);
                     body.emit(assign(r3BFE, bit_or(r3BC3, r3C11), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3C0D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3C13 = less(r3BC0, body.constant(int(64)));
                     ir_if *f3C12 = new(mem_ctx) ir_if(operand(r3C13).val);
                     exec_list *const f3C12_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C12->then_instructions;

                        ir_expression *const r3C14 = bit_and(r3BC0, body.constant(int(31)));
                        ir_expression *const r3C15 = rshift(r3BC3, r3C14);
                        ir_expression *const r3C16 = lshift(r3BC3, r3C00);
                        ir_expression *const r3C17 = bit_or(r3C16, r3BD3);
                        ir_expression *const r3C18 = nequal(r3C17, body.constant(0u));
                        ir_expression *const r3C19 = expr(ir_unop_b2i, r3C18);
                        ir_expression *const r3C1A = expr(ir_unop_i2u, r3C19);
                        body.emit(assign(r3BFE, bit_or(r3C15, r3C1A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3C12->else_instructions;

                        ir_expression *const r3C1B = bit_or(r3BC3, r3BD3);
                        ir_expression *const r3C1C = nequal(r3C1B, body.constant(0u));
                        ir_expression *const r3C1D = expr(ir_unop_b2i, r3C1C);
                        body.emit(assign(r3BFE, expr(ir_unop_i2u, r3C1D), 0x01));


                     body.instructions = f3C12_parent_instructions;
                     body.emit(f3C12);

                     /* END IF */


                  body.instructions = f3C0D_parent_instructions;
                  body.emit(f3C0D);

                  /* END IF */

                  body.emit(assign(r3BFF, body.constant(0u), 0x01));


               body.instructions = f3C04_parent_instructions;
               body.emit(f3C04);

               /* END IF */


            body.instructions = f3C02_parent_instructions;
            body.emit(f3C02);

            /* END IF */

            body.emit(assign(r3BC3, r3BFF, 0x01));

            body.emit(assign(r3BC4, r3BFE, 0x01));

            body.emit(assign(r3BC5, bit_or(r3BCF, body.constant(1073741824u)), 0x01));

            ir_variable *const r3C1E = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r3C1F = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r3C1F, sub(r3BCE, r3BFE), 0x01));

            ir_expression *const r3C20 = sub(r3BC5, r3BFF);
            ir_expression *const r3C21 = less(r3BCE, r3BFE);
            ir_expression *const r3C22 = expr(ir_unop_b2i, r3C21);
            ir_expression *const r3C23 = expr(ir_unop_i2u, r3C22);
            body.emit(assign(r3C1E, sub(r3C20, r3C23), 0x01));

            body.emit(assign(r3BC7, add(r3BC8, body.constant(int(-1))), 0x01));

            ir_variable *const r3C24 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r3C24, add(r3BC7, body.constant(int(-10))), 0x01));

            ir_variable *const r3C25 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r3C25, r3C1E, 0x01));

            ir_variable *const r3C26 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r3C26, r3C1F, 0x01));

            ir_variable *const r3C27 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r3C27);
            ir_variable *const r3C28 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r3C28);
            /* IF CONDITION */
            ir_expression *const r3C2A = equal(r3C1E, body.constant(0u));
            ir_if *f3C29 = new(mem_ctx) ir_if(operand(r3C2A).val);
            exec_list *const f3C29_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C29->then_instructions;

               body.emit(assign(r3C25, r3C1F, 0x01));

               body.emit(assign(r3C26, body.constant(0u), 0x01));

               body.emit(assign(r3C24, add(r3C24, body.constant(int(-32))), 0x01));


            body.instructions = f3C29_parent_instructions;
            body.emit(f3C29);

            /* END IF */

            ir_variable *const r3C2B = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r3C2B, r3C25, 0x01));

            ir_variable *const r3C2C = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r3C2D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r3C2D);
            /* IF CONDITION */
            ir_expression *const r3C2F = equal(r3C25, body.constant(0u));
            ir_if *f3C2E = new(mem_ctx) ir_if(operand(r3C2F).val);
            exec_list *const f3C2E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C2E->then_instructions;

               body.emit(assign(r3C2C, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3C2E->else_instructions;

               body.emit(assign(r3C2D, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r3C31 = bit_and(r3C25, body.constant(4294901760u));
               ir_expression *const r3C32 = equal(r3C31, body.constant(0u));
               ir_if *f3C30 = new(mem_ctx) ir_if(operand(r3C32).val);
               exec_list *const f3C30_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C30->then_instructions;

                  body.emit(assign(r3C2D, body.constant(int(16)), 0x01));

                  body.emit(assign(r3C2B, lshift(r3C25, body.constant(int(16))), 0x01));


               body.instructions = f3C30_parent_instructions;
               body.emit(f3C30);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3C34 = bit_and(r3C2B, body.constant(4278190080u));
               ir_expression *const r3C35 = equal(r3C34, body.constant(0u));
               ir_if *f3C33 = new(mem_ctx) ir_if(operand(r3C35).val);
               exec_list *const f3C33_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C33->then_instructions;

                  body.emit(assign(r3C2D, add(r3C2D, body.constant(int(8))), 0x01));

                  body.emit(assign(r3C2B, lshift(r3C2B, body.constant(int(8))), 0x01));


               body.instructions = f3C33_parent_instructions;
               body.emit(f3C33);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3C37 = bit_and(r3C2B, body.constant(4026531840u));
               ir_expression *const r3C38 = equal(r3C37, body.constant(0u));
               ir_if *f3C36 = new(mem_ctx) ir_if(operand(r3C38).val);
               exec_list *const f3C36_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C36->then_instructions;

                  body.emit(assign(r3C2D, add(r3C2D, body.constant(int(4))), 0x01));

                  body.emit(assign(r3C2B, lshift(r3C2B, body.constant(int(4))), 0x01));


               body.instructions = f3C36_parent_instructions;
               body.emit(f3C36);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3C3A = bit_and(r3C2B, body.constant(3221225472u));
               ir_expression *const r3C3B = equal(r3C3A, body.constant(0u));
               ir_if *f3C39 = new(mem_ctx) ir_if(operand(r3C3B).val);
               exec_list *const f3C39_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C39->then_instructions;

                  body.emit(assign(r3C2D, add(r3C2D, body.constant(int(2))), 0x01));

                  body.emit(assign(r3C2B, lshift(r3C2B, body.constant(int(2))), 0x01));


               body.instructions = f3C39_parent_instructions;
               body.emit(f3C39);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3C3D = bit_and(r3C2B, body.constant(2147483648u));
               ir_expression *const r3C3E = equal(r3C3D, body.constant(0u));
               ir_if *f3C3C = new(mem_ctx) ir_if(operand(r3C3E).val);
               exec_list *const f3C3C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C3C->then_instructions;

                  body.emit(assign(r3C2D, add(r3C2D, body.constant(int(1))), 0x01));


               body.instructions = f3C3C_parent_instructions;
               body.emit(f3C3C);

               /* END IF */

               body.emit(assign(r3C2C, r3C2D, 0x01));


            body.instructions = f3C2E_parent_instructions;
            body.emit(f3C2E);

            /* END IF */

            body.emit(assign(r3C28, add(r3C2C, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3C40 = lequal(body.constant(int(0)), r3C28);
            ir_if *f3C3F = new(mem_ctx) ir_if(operand(r3C40).val);
            exec_list *const f3C3F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C3F->then_instructions;

               body.emit(assign(r3C27, body.constant(0u), 0x01));

               ir_variable *const r3C41 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3C41, lshift(r3C26, r3C28), 0x01));

               ir_variable *const r3C42 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r3C44 = equal(r3C28, body.constant(int(0)));
               ir_if *f3C43 = new(mem_ctx) ir_if(operand(r3C44).val);
               exec_list *const f3C43_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C43->then_instructions;

                  body.emit(assign(r3C42, r3C25, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C43->else_instructions;

                  ir_expression *const r3C45 = lshift(r3C25, r3C28);
                  ir_expression *const r3C46 = neg(r3C28);
                  ir_expression *const r3C47 = bit_and(r3C46, body.constant(int(31)));
                  ir_expression *const r3C48 = rshift(r3C26, r3C47);
                  body.emit(assign(r3C42, bit_or(r3C45, r3C48), 0x01));


               body.instructions = f3C43_parent_instructions;
               body.emit(f3C43);

               /* END IF */

               body.emit(assign(r3C25, r3C42, 0x01));

               body.emit(assign(r3C26, r3C41, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3C3F->else_instructions;

               ir_variable *const r3C49 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r3C49, body.constant(0u), 0x01));

               ir_variable *const r3C4A = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r3C4A, neg(r3C28), 0x01));

               ir_variable *const r3C4B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r3C4B);
               ir_variable *const r3C4C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3C4C);
               ir_variable *const r3C4D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3C4D);
               ir_variable *const r3C4E = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r3C4F = neg(r3C4A);
               body.emit(assign(r3C4E, bit_and(r3C4F, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3C51 = equal(r3C4A, body.constant(int(0)));
               ir_if *f3C50 = new(mem_ctx) ir_if(operand(r3C51).val);
               exec_list *const f3C50_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C50->then_instructions;

                  body.emit(assign(r3C4B, r3C49, 0x01));

                  body.emit(assign(r3C4C, r3C26, 0x01));

                  body.emit(assign(r3C4D, r3C25, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C50->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3C53 = less(r3C4A, body.constant(int(32)));
                  ir_if *f3C52 = new(mem_ctx) ir_if(operand(r3C53).val);
                  exec_list *const f3C52_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C52->then_instructions;

                     body.emit(assign(r3C4B, lshift(r3C26, r3C4E), 0x01));

                     ir_expression *const r3C54 = lshift(r3C25, r3C4E);
                     ir_expression *const r3C55 = rshift(r3C26, r3C4A);
                     body.emit(assign(r3C4C, bit_or(r3C54, r3C55), 0x01));

                     body.emit(assign(r3C4D, rshift(r3C25, r3C4A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3C52->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3C57 = equal(r3C4A, body.constant(int(32)));
                     ir_if *f3C56 = new(mem_ctx) ir_if(operand(r3C57).val);
                     exec_list *const f3C56_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C56->then_instructions;

                        body.emit(assign(r3C4B, r3C26, 0x01));

                        body.emit(assign(r3C4C, r3C25, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3C56->else_instructions;

                        body.emit(assign(r3C49, bit_or(body.constant(0u), r3C26), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3C59 = less(r3C4A, body.constant(int(64)));
                        ir_if *f3C58 = new(mem_ctx) ir_if(operand(r3C59).val);
                        exec_list *const f3C58_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C58->then_instructions;

                           body.emit(assign(r3C4B, lshift(r3C25, r3C4E), 0x01));

                           ir_expression *const r3C5A = bit_and(r3C4A, body.constant(int(31)));
                           body.emit(assign(r3C4C, rshift(r3C25, r3C5A), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3C58->else_instructions;

                           ir_variable *const r3C5B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3C5D = equal(r3C4A, body.constant(int(64)));
                           ir_if *f3C5C = new(mem_ctx) ir_if(operand(r3C5D).val);
                           exec_list *const f3C5C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C5C->then_instructions;

                              body.emit(assign(r3C5B, r3C25, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3C5C->else_instructions;

                              ir_expression *const r3C5E = nequal(r3C25, body.constant(0u));
                              ir_expression *const r3C5F = expr(ir_unop_b2i, r3C5E);
                              body.emit(assign(r3C5B, expr(ir_unop_i2u, r3C5F), 0x01));


                           body.instructions = f3C5C_parent_instructions;
                           body.emit(f3C5C);

                           /* END IF */

                           body.emit(assign(r3C4B, r3C5B, 0x01));

                           body.emit(assign(r3C4C, body.constant(0u), 0x01));


                        body.instructions = f3C58_parent_instructions;
                        body.emit(f3C58);

                        /* END IF */


                     body.instructions = f3C56_parent_instructions;
                     body.emit(f3C56);

                     /* END IF */

                     body.emit(assign(r3C4D, body.constant(0u), 0x01));


                  body.instructions = f3C52_parent_instructions;
                  body.emit(f3C52);

                  /* END IF */

                  ir_expression *const r3C60 = nequal(r3C49, body.constant(0u));
                  ir_expression *const r3C61 = expr(ir_unop_b2i, r3C60);
                  ir_expression *const r3C62 = expr(ir_unop_i2u, r3C61);
                  body.emit(assign(r3C4B, bit_or(r3C4B, r3C62), 0x01));


               body.instructions = f3C50_parent_instructions;
               body.emit(f3C50);

               /* END IF */

               body.emit(assign(r3C25, r3C4D, 0x01));

               body.emit(assign(r3C26, r3C4C, 0x01));

               body.emit(assign(r3C27, r3C4B, 0x01));


            body.instructions = f3C3F_parent_instructions;
            body.emit(f3C3F);

            /* END IF */

            body.emit(assign(r3C24, sub(r3C24, r3C28), 0x01));

            ir_variable *const r3C63 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r3C63, r3C24, 0x01));

            ir_variable *const r3C64 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r3C64, r3C25, 0x01));

            ir_variable *const r3C65 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r3C65, r3C26, 0x01));

            ir_variable *const r3C66 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r3C66, r3C27, 0x01));

            ir_variable *const r3C67 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r3C67, body.constant(true), 0x01));

            ir_variable *const r3C68 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r3C69 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r3C69);
            ir_expression *const r3C6A = expr(ir_unop_u2i, r3C27);
            body.emit(assign(r3C69, less(r3C6A, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3C6C = lequal(body.constant(int(2045)), r3C24);
            ir_if *f3C6B = new(mem_ctx) ir_if(operand(r3C6C).val);
            exec_list *const f3C6B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C6B->then_instructions;

               ir_variable *const r3C6D = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r3C6F = less(body.constant(int(2045)), r3C24);
               ir_if *f3C6E = new(mem_ctx) ir_if(operand(r3C6F).val);
               exec_list *const f3C6E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C6E->then_instructions;

                  body.emit(assign(r3C6D, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C6E->else_instructions;

                  ir_variable *const r3C70 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3C72 = equal(r3C24, body.constant(int(2045)));
                  ir_if *f3C71 = new(mem_ctx) ir_if(operand(r3C72).val);
                  exec_list *const f3C71_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C71->then_instructions;

                     ir_expression *const r3C73 = equal(body.constant(2097151u), r3C25);
                     ir_expression *const r3C74 = equal(body.constant(4294967295u), r3C26);
                     body.emit(assign(r3C70, logic_and(r3C73, r3C74), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3C71->else_instructions;

                     body.emit(assign(r3C70, body.constant(false), 0x01));


                  body.instructions = f3C71_parent_instructions;
                  body.emit(f3C71);

                  /* END IF */

                  body.emit(assign(r3C6D, logic_and(r3C70, r3C69), 0x01));


               body.instructions = f3C6E_parent_instructions;
               body.emit(f3C6E);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3C75 = new(mem_ctx) ir_if(operand(r3C6D).val);
               exec_list *const f3C75_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C75->then_instructions;

                  ir_variable *const r3C76 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3C76);
                  ir_expression *const r3C77 = lshift(r3BBA, body.constant(int(31)));
                  body.emit(assign(r3C76, add(r3C77, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r3C76, body.constant(0u), 0x01));

                  body.emit(assign(r3C68, r3C76, 0x03));

                  body.emit(assign(r3C67, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C75->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3C79 = less(r3C24, body.constant(int(0)));
                  ir_if *f3C78 = new(mem_ctx) ir_if(operand(r3C79).val);
                  exec_list *const f3C78_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C78->then_instructions;

                     ir_variable *const r3C7A = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r3C7A, r3C27, 0x01));

                     ir_variable *const r3C7B = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r3C7B, neg(r3C24), 0x01));

                     ir_variable *const r3C7C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r3C7C);
                     ir_variable *const r3C7D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3C7D);
                     ir_variable *const r3C7E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3C7E);
                     ir_variable *const r3C7F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r3C80 = neg(r3C7B);
                     body.emit(assign(r3C7F, bit_and(r3C80, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3C82 = equal(r3C7B, body.constant(int(0)));
                     ir_if *f3C81 = new(mem_ctx) ir_if(operand(r3C82).val);
                     exec_list *const f3C81_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C81->then_instructions;

                        body.emit(assign(r3C7C, r3C27, 0x01));

                        body.emit(assign(r3C7D, r3C26, 0x01));

                        body.emit(assign(r3C7E, r3C25, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3C81->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3C84 = less(r3C7B, body.constant(int(32)));
                        ir_if *f3C83 = new(mem_ctx) ir_if(operand(r3C84).val);
                        exec_list *const f3C83_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C83->then_instructions;

                           body.emit(assign(r3C7C, lshift(r3C26, r3C7F), 0x01));

                           ir_expression *const r3C85 = lshift(r3C25, r3C7F);
                           ir_expression *const r3C86 = rshift(r3C26, r3C7B);
                           body.emit(assign(r3C7D, bit_or(r3C85, r3C86), 0x01));

                           body.emit(assign(r3C7E, rshift(r3C25, r3C7B), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3C83->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3C88 = equal(r3C7B, body.constant(int(32)));
                           ir_if *f3C87 = new(mem_ctx) ir_if(operand(r3C88).val);
                           exec_list *const f3C87_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C87->then_instructions;

                              body.emit(assign(r3C7C, r3C26, 0x01));

                              body.emit(assign(r3C7D, r3C25, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3C87->else_instructions;

                              body.emit(assign(r3C7A, bit_or(r3C27, r3C26), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3C8A = less(r3C7B, body.constant(int(64)));
                              ir_if *f3C89 = new(mem_ctx) ir_if(operand(r3C8A).val);
                              exec_list *const f3C89_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3C89->then_instructions;

                                 body.emit(assign(r3C7C, lshift(r3C25, r3C7F), 0x01));

                                 ir_expression *const r3C8B = bit_and(r3C7B, body.constant(int(31)));
                                 body.emit(assign(r3C7D, rshift(r3C25, r3C8B), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3C89->else_instructions;

                                 ir_variable *const r3C8C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3C8E = equal(r3C7B, body.constant(int(64)));
                                 ir_if *f3C8D = new(mem_ctx) ir_if(operand(r3C8E).val);
                                 exec_list *const f3C8D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3C8D->then_instructions;

                                    body.emit(assign(r3C8C, r3C25, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3C8D->else_instructions;

                                    ir_expression *const r3C8F = nequal(r3C25, body.constant(0u));
                                    ir_expression *const r3C90 = expr(ir_unop_b2i, r3C8F);
                                    body.emit(assign(r3C8C, expr(ir_unop_i2u, r3C90), 0x01));


                                 body.instructions = f3C8D_parent_instructions;
                                 body.emit(f3C8D);

                                 /* END IF */

                                 body.emit(assign(r3C7C, r3C8C, 0x01));

                                 body.emit(assign(r3C7D, body.constant(0u), 0x01));


                              body.instructions = f3C89_parent_instructions;
                              body.emit(f3C89);

                              /* END IF */


                           body.instructions = f3C87_parent_instructions;
                           body.emit(f3C87);

                           /* END IF */

                           body.emit(assign(r3C7E, body.constant(0u), 0x01));


                        body.instructions = f3C83_parent_instructions;
                        body.emit(f3C83);

                        /* END IF */

                        ir_expression *const r3C91 = nequal(r3C7A, body.constant(0u));
                        ir_expression *const r3C92 = expr(ir_unop_b2i, r3C91);
                        ir_expression *const r3C93 = expr(ir_unop_i2u, r3C92);
                        body.emit(assign(r3C7C, bit_or(r3C7C, r3C93), 0x01));


                     body.instructions = f3C81_parent_instructions;
                     body.emit(f3C81);

                     /* END IF */

                     body.emit(assign(r3C64, r3C7E, 0x01));

                     body.emit(assign(r3C65, r3C7D, 0x01));

                     body.emit(assign(r3C66, r3C7C, 0x01));

                     body.emit(assign(r3C63, body.constant(int(0)), 0x01));

                     body.emit(assign(r3C69, less(r3C7C, body.constant(0u)), 0x01));


                  body.instructions = f3C78_parent_instructions;
                  body.emit(f3C78);

                  /* END IF */


               body.instructions = f3C75_parent_instructions;
               body.emit(f3C75);

               /* END IF */


            body.instructions = f3C6B_parent_instructions;
            body.emit(f3C6B);

            /* END IF */

            /* IF CONDITION */
            ir_if *f3C94 = new(mem_ctx) ir_if(operand(r3C67).val);
            exec_list *const f3C94_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C94->then_instructions;

               /* IF CONDITION */
               ir_if *f3C95 = new(mem_ctx) ir_if(operand(r3C69).val);
               exec_list *const f3C95_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C95->then_instructions;

                  ir_variable *const r3C96 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3C96, add(r3C65, body.constant(1u)), 0x01));

                  ir_expression *const r3C97 = less(r3C96, r3C65);
                  ir_expression *const r3C98 = expr(ir_unop_b2i, r3C97);
                  ir_expression *const r3C99 = expr(ir_unop_i2u, r3C98);
                  body.emit(assign(r3C64, add(r3C64, r3C99), 0x01));

                  ir_expression *const r3C9A = equal(r3C66, body.constant(0u));
                  ir_expression *const r3C9B = expr(ir_unop_b2i, r3C9A);
                  ir_expression *const r3C9C = expr(ir_unop_i2u, r3C9B);
                  ir_expression *const r3C9D = add(r3C66, r3C9C);
                  ir_expression *const r3C9E = bit_and(r3C9D, body.constant(1u));
                  ir_expression *const r3C9F = expr(ir_unop_bit_not, r3C9E);
                  body.emit(assign(r3C65, bit_and(r3C96, r3C9F), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C95->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3CA1 = bit_or(r3C64, r3C65);
                  ir_expression *const r3CA2 = equal(r3CA1, body.constant(0u));
                  ir_if *f3CA0 = new(mem_ctx) ir_if(operand(r3CA2).val);
                  exec_list *const f3CA0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CA0->then_instructions;

                     body.emit(assign(r3C63, body.constant(int(0)), 0x01));


                  body.instructions = f3CA0_parent_instructions;
                  body.emit(f3CA0);

                  /* END IF */


               body.instructions = f3C95_parent_instructions;
               body.emit(f3C95);

               /* END IF */

               ir_variable *const r3CA3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r3CA3);
               ir_expression *const r3CA4 = lshift(r3BBA, body.constant(int(31)));
               ir_expression *const r3CA5 = expr(ir_unop_i2u, r3C63);
               ir_expression *const r3CA6 = lshift(r3CA5, body.constant(int(20)));
               ir_expression *const r3CA7 = add(r3CA4, r3CA6);
               body.emit(assign(r3CA3, add(r3CA7, r3C64), 0x02));

               body.emit(assign(r3CA3, r3C65, 0x01));

               body.emit(assign(r3C68, r3CA3, 0x03));

               body.emit(assign(r3C67, body.constant(false), 0x01));


            body.instructions = f3C94_parent_instructions;
            body.emit(f3C94);

            /* END IF */

            body.emit(assign(r3BBF, r3C68, 0x03));


         body.instructions = f3BDA_parent_instructions;
         body.emit(f3BDA);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3BD8->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3CA9 = less(r3BC0, body.constant(int(0)));
         ir_if *f3CA8 = new(mem_ctx) ir_if(operand(r3CA9).val);
         exec_list *const f3CA8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3CA8->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3CAB = equal(r3BCB, body.constant(int(2047)));
            ir_if *f3CAA = new(mem_ctx) ir_if(operand(r3CAB).val);
            exec_list *const f3CAA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3CAA->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3CAD = bit_or(r3BC3, r3BC4);
               ir_expression *const r3CAE = nequal(r3CAD, body.constant(0u));
               ir_if *f3CAC = new(mem_ctx) ir_if(operand(r3CAE).val);
               exec_list *const f3CAC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3CAC->then_instructions;

                  ir_variable *const r3CAF = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r3CAF, swizzle_x(r3247), 0x01));

                  ir_variable *const r3CB0 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r3CB0, swizzle_x(r3A07), 0x01));

                  ir_variable *const r3CB1 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3CB2 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r3CB3 = rshift(swizzle_y(r3247), body.constant(int(19)));
                  ir_expression *const r3CB4 = bit_and(r3CB3, body.constant(4095u));
                  ir_expression *const r3CB5 = equal(r3CB4, body.constant(4094u));
                  ir_expression *const r3CB6 = nequal(swizzle_x(r3247), body.constant(0u));
                  ir_expression *const r3CB7 = bit_and(swizzle_y(r3247), body.constant(524287u));
                  ir_expression *const r3CB8 = nequal(r3CB7, body.constant(0u));
                  ir_expression *const r3CB9 = logic_or(r3CB6, r3CB8);
                  body.emit(assign(r3CB2, logic_and(r3CB5, r3CB9), 0x01));

                  ir_variable *const r3CBA = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r3CBB = lshift(swizzle_y(r3A07), body.constant(int(1)));
                  ir_expression *const r3CBC = lequal(body.constant(4292870144u), r3CBB);
                  ir_expression *const r3CBD = nequal(swizzle_x(r3A07), body.constant(0u));
                  ir_expression *const r3CBE = bit_and(swizzle_y(r3A07), body.constant(1048575u));
                  ir_expression *const r3CBF = nequal(r3CBE, body.constant(0u));
                  ir_expression *const r3CC0 = logic_or(r3CBD, r3CBF);
                  body.emit(assign(r3CBA, logic_and(r3CBC, r3CC0), 0x01));

                  body.emit(assign(r3CAF, bit_or(swizzle_y(r3247), body.constant(524288u)), 0x02));

                  body.emit(assign(r3CB0, bit_or(swizzle_y(r3A07), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r3CC2 = lshift(swizzle_y(r3247), body.constant(int(1)));
                  ir_expression *const r3CC3 = lequal(body.constant(4292870144u), r3CC2);
                  ir_expression *const r3CC4 = nequal(swizzle_x(r3247), body.constant(0u));
                  ir_expression *const r3CC5 = bit_and(swizzle_y(r3247), body.constant(1048575u));
                  ir_expression *const r3CC6 = nequal(r3CC5, body.constant(0u));
                  ir_expression *const r3CC7 = logic_or(r3CC4, r3CC6);
                  ir_expression *const r3CC8 = logic_and(r3CC3, r3CC7);
                  ir_if *f3CC1 = new(mem_ctx) ir_if(operand(r3CC8).val);
                  exec_list *const f3CC1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CC1->then_instructions;

                     ir_variable *const r3CC9 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3CCB = logic_and(r3CB2, r3CBA);
                     ir_if *f3CCA = new(mem_ctx) ir_if(operand(r3CCB).val);
                     exec_list *const f3CCA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3CCA->then_instructions;

                        body.emit(assign(r3CC9, r3CB0, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3CCA->else_instructions;

                        body.emit(assign(r3CC9, r3CAF, 0x03));


                     body.instructions = f3CCA_parent_instructions;
                     body.emit(f3CCA);

                     /* END IF */

                     body.emit(assign(r3CB1, r3CC9, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3CC1->else_instructions;

                     body.emit(assign(r3CB1, r3CB0, 0x03));


                  body.instructions = f3CC1_parent_instructions;
                  body.emit(f3CC1);

                  /* END IF */

                  body.emit(assign(r3BBF, r3CB1, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3CAC->else_instructions;

                  ir_variable *const r3CCC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3CCC);
                  ir_expression *const r3CCD = bit_xor(r3BBA, body.constant(1u));
                  ir_expression *const r3CCE = lshift(r3CCD, body.constant(int(31)));
                  body.emit(assign(r3CCC, add(r3CCE, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r3CCC, body.constant(0u), 0x01));

                  body.emit(assign(r3BBF, r3CCC, 0x03));


               body.instructions = f3CAC_parent_instructions;
               body.emit(f3CAC);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3CAA->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3CD0 = equal(r3BC8, body.constant(int(0)));
               ir_if *f3CCF = new(mem_ctx) ir_if(operand(r3CD0).val);
               exec_list *const f3CCF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3CCF->then_instructions;

                  body.emit(assign(r3BC0, add(r3BC0, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3CCF->else_instructions;

                  body.emit(assign(r3BC5, bit_or(r3BC5, body.constant(1073741824u)), 0x01));


               body.instructions = f3CCF_parent_instructions;
               body.emit(f3CCF);

               /* END IF */

               ir_variable *const r3CD1 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r3CD1, neg(r3BC0), 0x01));

               ir_variable *const r3CD2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3CD2);
               ir_variable *const r3CD3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3CD3);
               ir_variable *const r3CD4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r3CD5 = neg(r3CD1);
               body.emit(assign(r3CD4, bit_and(r3CD5, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3CD7 = equal(r3CD1, body.constant(int(0)));
               ir_if *f3CD6 = new(mem_ctx) ir_if(operand(r3CD7).val);
               exec_list *const f3CD6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3CD6->then_instructions;

                  body.emit(assign(r3CD2, r3BCE, 0x01));

                  body.emit(assign(r3CD3, r3BC5, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3CD6->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3CD9 = less(r3CD1, body.constant(int(32)));
                  ir_if *f3CD8 = new(mem_ctx) ir_if(operand(r3CD9).val);
                  exec_list *const f3CD8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CD8->then_instructions;

                     ir_expression *const r3CDA = lshift(r3BC5, r3CD4);
                     ir_expression *const r3CDB = rshift(r3BCE, r3CD1);
                     ir_expression *const r3CDC = bit_or(r3CDA, r3CDB);
                     ir_expression *const r3CDD = lshift(r3BCE, r3CD4);
                     ir_expression *const r3CDE = nequal(r3CDD, body.constant(0u));
                     ir_expression *const r3CDF = expr(ir_unop_b2i, r3CDE);
                     ir_expression *const r3CE0 = expr(ir_unop_i2u, r3CDF);
                     body.emit(assign(r3CD2, bit_or(r3CDC, r3CE0), 0x01));

                     body.emit(assign(r3CD3, rshift(r3BC5, r3CD1), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3CD8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3CE2 = equal(r3CD1, body.constant(int(32)));
                     ir_if *f3CE1 = new(mem_ctx) ir_if(operand(r3CE2).val);
                     exec_list *const f3CE1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3CE1->then_instructions;

                        ir_expression *const r3CE3 = nequal(r3BCE, body.constant(0u));
                        ir_expression *const r3CE4 = expr(ir_unop_b2i, r3CE3);
                        ir_expression *const r3CE5 = expr(ir_unop_i2u, r3CE4);
                        body.emit(assign(r3CD2, bit_or(r3BC5, r3CE5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3CE1->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3CE7 = less(r3CD1, body.constant(int(64)));
                        ir_if *f3CE6 = new(mem_ctx) ir_if(operand(r3CE7).val);
                        exec_list *const f3CE6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3CE6->then_instructions;

                           ir_expression *const r3CE8 = bit_and(r3CD1, body.constant(int(31)));
                           ir_expression *const r3CE9 = rshift(r3BC5, r3CE8);
                           ir_expression *const r3CEA = lshift(r3BC5, r3CD4);
                           ir_expression *const r3CEB = bit_or(r3CEA, r3BCE);
                           ir_expression *const r3CEC = nequal(r3CEB, body.constant(0u));
                           ir_expression *const r3CED = expr(ir_unop_b2i, r3CEC);
                           ir_expression *const r3CEE = expr(ir_unop_i2u, r3CED);
                           body.emit(assign(r3CD2, bit_or(r3CE9, r3CEE), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3CE6->else_instructions;

                           ir_expression *const r3CEF = bit_or(r3BC5, r3BCE);
                           ir_expression *const r3CF0 = nequal(r3CEF, body.constant(0u));
                           ir_expression *const r3CF1 = expr(ir_unop_b2i, r3CF0);
                           body.emit(assign(r3CD2, expr(ir_unop_i2u, r3CF1), 0x01));


                        body.instructions = f3CE6_parent_instructions;
                        body.emit(f3CE6);

                        /* END IF */


                     body.instructions = f3CE1_parent_instructions;
                     body.emit(f3CE1);

                     /* END IF */

                     body.emit(assign(r3CD3, body.constant(0u), 0x01));


                  body.instructions = f3CD8_parent_instructions;
                  body.emit(f3CD8);

                  /* END IF */


               body.instructions = f3CD6_parent_instructions;
               body.emit(f3CD6);

               /* END IF */

               body.emit(assign(r3BC5, r3CD3, 0x01));

               body.emit(assign(r3BC6, r3CD2, 0x01));

               body.emit(assign(r3BC3, bit_or(r3BC3, body.constant(1073741824u)), 0x01));

               ir_variable *const r3CF2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r3CF3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3CF3, sub(r3BC4, r3CD2), 0x01));

               ir_expression *const r3CF4 = sub(r3BC3, r3CD3);
               ir_expression *const r3CF5 = less(r3BC4, r3CD2);
               ir_expression *const r3CF6 = expr(ir_unop_b2i, r3CF5);
               ir_expression *const r3CF7 = expr(ir_unop_i2u, r3CF6);
               body.emit(assign(r3CF2, sub(r3CF4, r3CF7), 0x01));

               body.emit(assign(r3BBE, bit_xor(r3BBA, body.constant(1u)), 0x01));

               body.emit(assign(r3BC7, add(r3BCB, body.constant(int(-1))), 0x01));

               ir_variable *const r3CF8 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3CF8, add(r3BC7, body.constant(int(-10))), 0x01));

               ir_variable *const r3CF9 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3CF9, r3CF2, 0x01));

               ir_variable *const r3CFA = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3CFA, r3CF3, 0x01));

               ir_variable *const r3CFB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r3CFB);
               ir_variable *const r3CFC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3CFC);
               /* IF CONDITION */
               ir_expression *const r3CFE = equal(r3CF2, body.constant(0u));
               ir_if *f3CFD = new(mem_ctx) ir_if(operand(r3CFE).val);
               exec_list *const f3CFD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3CFD->then_instructions;

                  body.emit(assign(r3CF9, r3CF3, 0x01));

                  body.emit(assign(r3CFA, body.constant(0u), 0x01));

                  body.emit(assign(r3CF8, add(r3CF8, body.constant(int(-32))), 0x01));


               body.instructions = f3CFD_parent_instructions;
               body.emit(f3CFD);

               /* END IF */

               ir_variable *const r3CFF = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r3CFF, r3CF9, 0x01));

               ir_variable *const r3D00 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r3D01 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3D01);
               /* IF CONDITION */
               ir_expression *const r3D03 = equal(r3CF9, body.constant(0u));
               ir_if *f3D02 = new(mem_ctx) ir_if(operand(r3D03).val);
               exec_list *const f3D02_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D02->then_instructions;

                  body.emit(assign(r3D00, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3D02->else_instructions;

                  body.emit(assign(r3D01, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3D05 = bit_and(r3CF9, body.constant(4294901760u));
                  ir_expression *const r3D06 = equal(r3D05, body.constant(0u));
                  ir_if *f3D04 = new(mem_ctx) ir_if(operand(r3D06).val);
                  exec_list *const f3D04_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D04->then_instructions;

                     body.emit(assign(r3D01, body.constant(int(16)), 0x01));

                     body.emit(assign(r3CFF, lshift(r3CF9, body.constant(int(16))), 0x01));


                  body.instructions = f3D04_parent_instructions;
                  body.emit(f3D04);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3D08 = bit_and(r3CFF, body.constant(4278190080u));
                  ir_expression *const r3D09 = equal(r3D08, body.constant(0u));
                  ir_if *f3D07 = new(mem_ctx) ir_if(operand(r3D09).val);
                  exec_list *const f3D07_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D07->then_instructions;

                     body.emit(assign(r3D01, add(r3D01, body.constant(int(8))), 0x01));

                     body.emit(assign(r3CFF, lshift(r3CFF, body.constant(int(8))), 0x01));


                  body.instructions = f3D07_parent_instructions;
                  body.emit(f3D07);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3D0B = bit_and(r3CFF, body.constant(4026531840u));
                  ir_expression *const r3D0C = equal(r3D0B, body.constant(0u));
                  ir_if *f3D0A = new(mem_ctx) ir_if(operand(r3D0C).val);
                  exec_list *const f3D0A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D0A->then_instructions;

                     body.emit(assign(r3D01, add(r3D01, body.constant(int(4))), 0x01));

                     body.emit(assign(r3CFF, lshift(r3CFF, body.constant(int(4))), 0x01));


                  body.instructions = f3D0A_parent_instructions;
                  body.emit(f3D0A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3D0E = bit_and(r3CFF, body.constant(3221225472u));
                  ir_expression *const r3D0F = equal(r3D0E, body.constant(0u));
                  ir_if *f3D0D = new(mem_ctx) ir_if(operand(r3D0F).val);
                  exec_list *const f3D0D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D0D->then_instructions;

                     body.emit(assign(r3D01, add(r3D01, body.constant(int(2))), 0x01));

                     body.emit(assign(r3CFF, lshift(r3CFF, body.constant(int(2))), 0x01));


                  body.instructions = f3D0D_parent_instructions;
                  body.emit(f3D0D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3D11 = bit_and(r3CFF, body.constant(2147483648u));
                  ir_expression *const r3D12 = equal(r3D11, body.constant(0u));
                  ir_if *f3D10 = new(mem_ctx) ir_if(operand(r3D12).val);
                  exec_list *const f3D10_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D10->then_instructions;

                     body.emit(assign(r3D01, add(r3D01, body.constant(int(1))), 0x01));


                  body.instructions = f3D10_parent_instructions;
                  body.emit(f3D10);

                  /* END IF */

                  body.emit(assign(r3D00, r3D01, 0x01));


               body.instructions = f3D02_parent_instructions;
               body.emit(f3D02);

               /* END IF */

               body.emit(assign(r3CFC, add(r3D00, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3D14 = lequal(body.constant(int(0)), r3CFC);
               ir_if *f3D13 = new(mem_ctx) ir_if(operand(r3D14).val);
               exec_list *const f3D13_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D13->then_instructions;

                  body.emit(assign(r3CFB, body.constant(0u), 0x01));

                  ir_variable *const r3D15 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3D15, lshift(r3CFA, r3CFC), 0x01));

                  ir_variable *const r3D16 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3D18 = equal(r3CFC, body.constant(int(0)));
                  ir_if *f3D17 = new(mem_ctx) ir_if(operand(r3D18).val);
                  exec_list *const f3D17_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D17->then_instructions;

                     body.emit(assign(r3D16, r3CF9, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D17->else_instructions;

                     ir_expression *const r3D19 = lshift(r3CF9, r3CFC);
                     ir_expression *const r3D1A = neg(r3CFC);
                     ir_expression *const r3D1B = bit_and(r3D1A, body.constant(int(31)));
                     ir_expression *const r3D1C = rshift(r3CFA, r3D1B);
                     body.emit(assign(r3D16, bit_or(r3D19, r3D1C), 0x01));


                  body.instructions = f3D17_parent_instructions;
                  body.emit(f3D17);

                  /* END IF */

                  body.emit(assign(r3CF9, r3D16, 0x01));

                  body.emit(assign(r3CFA, r3D15, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3D13->else_instructions;

                  ir_variable *const r3D1D = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r3D1D, body.constant(0u), 0x01));

                  ir_variable *const r3D1E = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r3D1E, neg(r3CFC), 0x01));

                  ir_variable *const r3D1F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r3D1F);
                  ir_variable *const r3D20 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3D20);
                  ir_variable *const r3D21 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r3D21);
                  ir_variable *const r3D22 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r3D23 = neg(r3D1E);
                  body.emit(assign(r3D22, bit_and(r3D23, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3D25 = equal(r3D1E, body.constant(int(0)));
                  ir_if *f3D24 = new(mem_ctx) ir_if(operand(r3D25).val);
                  exec_list *const f3D24_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D24->then_instructions;

                     body.emit(assign(r3D1F, r3D1D, 0x01));

                     body.emit(assign(r3D20, r3CFA, 0x01));

                     body.emit(assign(r3D21, r3CF9, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D24->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3D27 = less(r3D1E, body.constant(int(32)));
                     ir_if *f3D26 = new(mem_ctx) ir_if(operand(r3D27).val);
                     exec_list *const f3D26_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D26->then_instructions;

                        body.emit(assign(r3D1F, lshift(r3CFA, r3D22), 0x01));

                        ir_expression *const r3D28 = lshift(r3CF9, r3D22);
                        ir_expression *const r3D29 = rshift(r3CFA, r3D1E);
                        body.emit(assign(r3D20, bit_or(r3D28, r3D29), 0x01));

                        body.emit(assign(r3D21, rshift(r3CF9, r3D1E), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3D26->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3D2B = equal(r3D1E, body.constant(int(32)));
                        ir_if *f3D2A = new(mem_ctx) ir_if(operand(r3D2B).val);
                        exec_list *const f3D2A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3D2A->then_instructions;

                           body.emit(assign(r3D1F, r3CFA, 0x01));

                           body.emit(assign(r3D20, r3CF9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3D2A->else_instructions;

                           body.emit(assign(r3D1D, bit_or(body.constant(0u), r3CFA), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3D2D = less(r3D1E, body.constant(int(64)));
                           ir_if *f3D2C = new(mem_ctx) ir_if(operand(r3D2D).val);
                           exec_list *const f3D2C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3D2C->then_instructions;

                              body.emit(assign(r3D1F, lshift(r3CF9, r3D22), 0x01));

                              ir_expression *const r3D2E = bit_and(r3D1E, body.constant(int(31)));
                              body.emit(assign(r3D20, rshift(r3CF9, r3D2E), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3D2C->else_instructions;

                              ir_variable *const r3D2F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3D31 = equal(r3D1E, body.constant(int(64)));
                              ir_if *f3D30 = new(mem_ctx) ir_if(operand(r3D31).val);
                              exec_list *const f3D30_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3D30->then_instructions;

                                 body.emit(assign(r3D2F, r3CF9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3D30->else_instructions;

                                 ir_expression *const r3D32 = nequal(r3CF9, body.constant(0u));
                                 ir_expression *const r3D33 = expr(ir_unop_b2i, r3D32);
                                 body.emit(assign(r3D2F, expr(ir_unop_i2u, r3D33), 0x01));


                              body.instructions = f3D30_parent_instructions;
                              body.emit(f3D30);

                              /* END IF */

                              body.emit(assign(r3D1F, r3D2F, 0x01));

                              body.emit(assign(r3D20, body.constant(0u), 0x01));


                           body.instructions = f3D2C_parent_instructions;
                           body.emit(f3D2C);

                           /* END IF */


                        body.instructions = f3D2A_parent_instructions;
                        body.emit(f3D2A);

                        /* END IF */

                        body.emit(assign(r3D21, body.constant(0u), 0x01));


                     body.instructions = f3D26_parent_instructions;
                     body.emit(f3D26);

                     /* END IF */

                     ir_expression *const r3D34 = nequal(r3D1D, body.constant(0u));
                     ir_expression *const r3D35 = expr(ir_unop_b2i, r3D34);
                     ir_expression *const r3D36 = expr(ir_unop_i2u, r3D35);
                     body.emit(assign(r3D1F, bit_or(r3D1F, r3D36), 0x01));


                  body.instructions = f3D24_parent_instructions;
                  body.emit(f3D24);

                  /* END IF */

                  body.emit(assign(r3CF9, r3D21, 0x01));

                  body.emit(assign(r3CFA, r3D20, 0x01));

                  body.emit(assign(r3CFB, r3D1F, 0x01));


               body.instructions = f3D13_parent_instructions;
               body.emit(f3D13);

               /* END IF */

               body.emit(assign(r3CF8, sub(r3CF8, r3CFC), 0x01));

               ir_variable *const r3D37 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3D37, r3CF8, 0x01));

               ir_variable *const r3D38 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3D38, r3CF9, 0x01));

               ir_variable *const r3D39 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3D39, r3CFA, 0x01));

               ir_variable *const r3D3A = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3D3A, r3CFB, 0x01));

               ir_variable *const r3D3B = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r3D3B, body.constant(true), 0x01));

               ir_variable *const r3D3C = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3D3D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3D3D);
               ir_expression *const r3D3E = expr(ir_unop_u2i, r3CFB);
               body.emit(assign(r3D3D, less(r3D3E, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3D40 = lequal(body.constant(int(2045)), r3CF8);
               ir_if *f3D3F = new(mem_ctx) ir_if(operand(r3D40).val);
               exec_list *const f3D3F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D3F->then_instructions;

                  ir_variable *const r3D41 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3D43 = less(body.constant(int(2045)), r3CF8);
                  ir_if *f3D42 = new(mem_ctx) ir_if(operand(r3D43).val);
                  exec_list *const f3D42_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D42->then_instructions;

                     body.emit(assign(r3D41, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D42->else_instructions;

                     ir_variable *const r3D44 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3D46 = equal(r3CF8, body.constant(int(2045)));
                     ir_if *f3D45 = new(mem_ctx) ir_if(operand(r3D46).val);
                     exec_list *const f3D45_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D45->then_instructions;

                        ir_expression *const r3D47 = equal(body.constant(2097151u), r3CF9);
                        ir_expression *const r3D48 = equal(body.constant(4294967295u), r3CFA);
                        body.emit(assign(r3D44, logic_and(r3D47, r3D48), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3D45->else_instructions;

                        body.emit(assign(r3D44, body.constant(false), 0x01));


                     body.instructions = f3D45_parent_instructions;
                     body.emit(f3D45);

                     /* END IF */

                     body.emit(assign(r3D41, logic_and(r3D44, r3D3D), 0x01));


                  body.instructions = f3D42_parent_instructions;
                  body.emit(f3D42);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3D49 = new(mem_ctx) ir_if(operand(r3D41).val);
                  exec_list *const f3D49_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D49->then_instructions;

                     ir_variable *const r3D4A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3D4A);
                     ir_expression *const r3D4B = lshift(r3BBE, body.constant(int(31)));
                     body.emit(assign(r3D4A, add(r3D4B, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3D4A, body.constant(0u), 0x01));

                     body.emit(assign(r3D3C, r3D4A, 0x03));

                     body.emit(assign(r3D3B, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D49->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3D4D = less(r3CF8, body.constant(int(0)));
                     ir_if *f3D4C = new(mem_ctx) ir_if(operand(r3D4D).val);
                     exec_list *const f3D4C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D4C->then_instructions;

                        ir_variable *const r3D4E = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3D4E, r3CFB, 0x01));

                        ir_variable *const r3D4F = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3D4F, neg(r3CF8), 0x01));

                        ir_variable *const r3D50 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3D50);
                        ir_variable *const r3D51 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3D51);
                        ir_variable *const r3D52 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3D52);
                        ir_variable *const r3D53 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3D54 = neg(r3D4F);
                        body.emit(assign(r3D53, bit_and(r3D54, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3D56 = equal(r3D4F, body.constant(int(0)));
                        ir_if *f3D55 = new(mem_ctx) ir_if(operand(r3D56).val);
                        exec_list *const f3D55_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3D55->then_instructions;

                           body.emit(assign(r3D50, r3CFB, 0x01));

                           body.emit(assign(r3D51, r3CFA, 0x01));

                           body.emit(assign(r3D52, r3CF9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3D55->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3D58 = less(r3D4F, body.constant(int(32)));
                           ir_if *f3D57 = new(mem_ctx) ir_if(operand(r3D58).val);
                           exec_list *const f3D57_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3D57->then_instructions;

                              body.emit(assign(r3D50, lshift(r3CFA, r3D53), 0x01));

                              ir_expression *const r3D59 = lshift(r3CF9, r3D53);
                              ir_expression *const r3D5A = rshift(r3CFA, r3D4F);
                              body.emit(assign(r3D51, bit_or(r3D59, r3D5A), 0x01));

                              body.emit(assign(r3D52, rshift(r3CF9, r3D4F), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3D57->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3D5C = equal(r3D4F, body.constant(int(32)));
                              ir_if *f3D5B = new(mem_ctx) ir_if(operand(r3D5C).val);
                              exec_list *const f3D5B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3D5B->then_instructions;

                                 body.emit(assign(r3D50, r3CFA, 0x01));

                                 body.emit(assign(r3D51, r3CF9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3D5B->else_instructions;

                                 body.emit(assign(r3D4E, bit_or(r3CFB, r3CFA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3D5E = less(r3D4F, body.constant(int(64)));
                                 ir_if *f3D5D = new(mem_ctx) ir_if(operand(r3D5E).val);
                                 exec_list *const f3D5D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3D5D->then_instructions;

                                    body.emit(assign(r3D50, lshift(r3CF9, r3D53), 0x01));

                                    ir_expression *const r3D5F = bit_and(r3D4F, body.constant(int(31)));
                                    body.emit(assign(r3D51, rshift(r3CF9, r3D5F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3D5D->else_instructions;

                                    ir_variable *const r3D60 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3D62 = equal(r3D4F, body.constant(int(64)));
                                    ir_if *f3D61 = new(mem_ctx) ir_if(operand(r3D62).val);
                                    exec_list *const f3D61_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3D61->then_instructions;

                                       body.emit(assign(r3D60, r3CF9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3D61->else_instructions;

                                       ir_expression *const r3D63 = nequal(r3CF9, body.constant(0u));
                                       ir_expression *const r3D64 = expr(ir_unop_b2i, r3D63);
                                       body.emit(assign(r3D60, expr(ir_unop_i2u, r3D64), 0x01));


                                    body.instructions = f3D61_parent_instructions;
                                    body.emit(f3D61);

                                    /* END IF */

                                    body.emit(assign(r3D50, r3D60, 0x01));

                                    body.emit(assign(r3D51, body.constant(0u), 0x01));


                                 body.instructions = f3D5D_parent_instructions;
                                 body.emit(f3D5D);

                                 /* END IF */


                              body.instructions = f3D5B_parent_instructions;
                              body.emit(f3D5B);

                              /* END IF */

                              body.emit(assign(r3D52, body.constant(0u), 0x01));


                           body.instructions = f3D57_parent_instructions;
                           body.emit(f3D57);

                           /* END IF */

                           ir_expression *const r3D65 = nequal(r3D4E, body.constant(0u));
                           ir_expression *const r3D66 = expr(ir_unop_b2i, r3D65);
                           ir_expression *const r3D67 = expr(ir_unop_i2u, r3D66);
                           body.emit(assign(r3D50, bit_or(r3D50, r3D67), 0x01));


                        body.instructions = f3D55_parent_instructions;
                        body.emit(f3D55);

                        /* END IF */

                        body.emit(assign(r3D38, r3D52, 0x01));

                        body.emit(assign(r3D39, r3D51, 0x01));

                        body.emit(assign(r3D3A, r3D50, 0x01));

                        body.emit(assign(r3D37, body.constant(int(0)), 0x01));

                        body.emit(assign(r3D3D, less(r3D50, body.constant(0u)), 0x01));


                     body.instructions = f3D4C_parent_instructions;
                     body.emit(f3D4C);

                     /* END IF */


                  body.instructions = f3D49_parent_instructions;
                  body.emit(f3D49);

                  /* END IF */


               body.instructions = f3D3F_parent_instructions;
               body.emit(f3D3F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3D68 = new(mem_ctx) ir_if(operand(r3D3B).val);
               exec_list *const f3D68_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D68->then_instructions;

                  /* IF CONDITION */
                  ir_if *f3D69 = new(mem_ctx) ir_if(operand(r3D3D).val);
                  exec_list *const f3D69_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D69->then_instructions;

                     ir_variable *const r3D6A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3D6A, add(r3D39, body.constant(1u)), 0x01));

                     ir_expression *const r3D6B = less(r3D6A, r3D39);
                     ir_expression *const r3D6C = expr(ir_unop_b2i, r3D6B);
                     ir_expression *const r3D6D = expr(ir_unop_i2u, r3D6C);
                     body.emit(assign(r3D38, add(r3D38, r3D6D), 0x01));

                     ir_expression *const r3D6E = equal(r3D3A, body.constant(0u));
                     ir_expression *const r3D6F = expr(ir_unop_b2i, r3D6E);
                     ir_expression *const r3D70 = expr(ir_unop_i2u, r3D6F);
                     ir_expression *const r3D71 = add(r3D3A, r3D70);
                     ir_expression *const r3D72 = bit_and(r3D71, body.constant(1u));
                     ir_expression *const r3D73 = expr(ir_unop_bit_not, r3D72);
                     body.emit(assign(r3D39, bit_and(r3D6A, r3D73), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D69->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3D75 = bit_or(r3D38, r3D39);
                     ir_expression *const r3D76 = equal(r3D75, body.constant(0u));
                     ir_if *f3D74 = new(mem_ctx) ir_if(operand(r3D76).val);
                     exec_list *const f3D74_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D74->then_instructions;

                        body.emit(assign(r3D37, body.constant(int(0)), 0x01));


                     body.instructions = f3D74_parent_instructions;
                     body.emit(f3D74);

                     /* END IF */


                  body.instructions = f3D69_parent_instructions;
                  body.emit(f3D69);

                  /* END IF */

                  ir_variable *const r3D77 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3D77);
                  ir_expression *const r3D78 = lshift(r3BBE, body.constant(int(31)));
                  ir_expression *const r3D79 = expr(ir_unop_i2u, r3D37);
                  ir_expression *const r3D7A = lshift(r3D79, body.constant(int(20)));
                  ir_expression *const r3D7B = add(r3D78, r3D7A);
                  body.emit(assign(r3D77, add(r3D7B, r3D38), 0x02));

                  body.emit(assign(r3D77, r3D39, 0x01));

                  body.emit(assign(r3D3C, r3D77, 0x03));

                  body.emit(assign(r3D3B, body.constant(false), 0x01));


               body.instructions = f3D68_parent_instructions;
               body.emit(f3D68);

               /* END IF */

               body.emit(assign(r3BBF, r3D3C, 0x03));


            body.instructions = f3CAA_parent_instructions;
            body.emit(f3CAA);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3CA8->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3D7D = equal(r3BC8, body.constant(int(2047)));
            ir_if *f3D7C = new(mem_ctx) ir_if(operand(r3D7D).val);
            exec_list *const f3D7C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3D7C->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3D7F = bit_or(r3BC5, r3BC6);
               ir_expression *const r3D80 = bit_or(r3BC3, r3BC4);
               ir_expression *const r3D81 = bit_or(r3D7F, r3D80);
               ir_expression *const r3D82 = nequal(r3D81, body.constant(0u));
               ir_if *f3D7E = new(mem_ctx) ir_if(operand(r3D82).val);
               exec_list *const f3D7E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D7E->then_instructions;

                  ir_variable *const r3D83 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r3D83, swizzle_x(r3247), 0x01));

                  ir_variable *const r3D84 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r3D84, swizzle_x(r3A07), 0x01));

                  ir_variable *const r3D85 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3D86 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r3D87 = rshift(swizzle_y(r3247), body.constant(int(19)));
                  ir_expression *const r3D88 = bit_and(r3D87, body.constant(4095u));
                  ir_expression *const r3D89 = equal(r3D88, body.constant(4094u));
                  ir_expression *const r3D8A = nequal(swizzle_x(r3247), body.constant(0u));
                  ir_expression *const r3D8B = bit_and(swizzle_y(r3247), body.constant(524287u));
                  ir_expression *const r3D8C = nequal(r3D8B, body.constant(0u));
                  ir_expression *const r3D8D = logic_or(r3D8A, r3D8C);
                  body.emit(assign(r3D86, logic_and(r3D89, r3D8D), 0x01));

                  ir_variable *const r3D8E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r3D8F = lshift(swizzle_y(r3A07), body.constant(int(1)));
                  ir_expression *const r3D90 = lequal(body.constant(4292870144u), r3D8F);
                  ir_expression *const r3D91 = nequal(swizzle_x(r3A07), body.constant(0u));
                  ir_expression *const r3D92 = bit_and(swizzle_y(r3A07), body.constant(1048575u));
                  ir_expression *const r3D93 = nequal(r3D92, body.constant(0u));
                  ir_expression *const r3D94 = logic_or(r3D91, r3D93);
                  body.emit(assign(r3D8E, logic_and(r3D90, r3D94), 0x01));

                  body.emit(assign(r3D83, bit_or(swizzle_y(r3247), body.constant(524288u)), 0x02));

                  body.emit(assign(r3D84, bit_or(swizzle_y(r3A07), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r3D96 = lshift(swizzle_y(r3247), body.constant(int(1)));
                  ir_expression *const r3D97 = lequal(body.constant(4292870144u), r3D96);
                  ir_expression *const r3D98 = nequal(swizzle_x(r3247), body.constant(0u));
                  ir_expression *const r3D99 = bit_and(swizzle_y(r3247), body.constant(1048575u));
                  ir_expression *const r3D9A = nequal(r3D99, body.constant(0u));
                  ir_expression *const r3D9B = logic_or(r3D98, r3D9A);
                  ir_expression *const r3D9C = logic_and(r3D97, r3D9B);
                  ir_if *f3D95 = new(mem_ctx) ir_if(operand(r3D9C).val);
                  exec_list *const f3D95_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D95->then_instructions;

                     ir_variable *const r3D9D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3D9F = logic_and(r3D86, r3D8E);
                     ir_if *f3D9E = new(mem_ctx) ir_if(operand(r3D9F).val);
                     exec_list *const f3D9E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D9E->then_instructions;

                        body.emit(assign(r3D9D, r3D84, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3D9E->else_instructions;

                        body.emit(assign(r3D9D, r3D83, 0x03));


                     body.instructions = f3D9E_parent_instructions;
                     body.emit(f3D9E);

                     /* END IF */

                     body.emit(assign(r3D85, r3D9D, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D95->else_instructions;

                     body.emit(assign(r3D85, r3D84, 0x03));


                  body.instructions = f3D95_parent_instructions;
                  body.emit(f3D95);

                  /* END IF */

                  body.emit(assign(r3BBF, r3D85, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3D7E->else_instructions;

                  ir_constant_data r3DA0_data;
                  memset(&r3DA0_data, 0, sizeof(ir_constant_data));
                  r3DA0_data.u[0] = 4294967295;
                  r3DA0_data.u[1] = 4294967295;
                  ir_constant *const r3DA0 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3DA0_data);
                  body.emit(assign(r3BBF, r3DA0, 0x03));


               body.instructions = f3D7E_parent_instructions;
               body.emit(f3D7E);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3D7C->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3DA2 = equal(r3BC8, body.constant(int(0)));
               ir_if *f3DA1 = new(mem_ctx) ir_if(operand(r3DA2).val);
               exec_list *const f3DA1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3DA1->then_instructions;

                  body.emit(assign(r3BC2, body.constant(int(1)), 0x01));

                  body.emit(assign(r3BC1, body.constant(int(1)), 0x01));


               body.instructions = f3DA1_parent_instructions;
               body.emit(f3DA1);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3DA4 = less(r3BC3, r3BC5);
               ir_if *f3DA3 = new(mem_ctx) ir_if(operand(r3DA4).val);
               exec_list *const f3DA3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3DA3->then_instructions;

                  ir_variable *const r3DA5 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r3DA6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3DA6, sub(r3BC6, r3BC4), 0x01));

                  ir_expression *const r3DA7 = sub(r3BC5, r3BC3);
                  ir_expression *const r3DA8 = less(r3BC6, r3BC4);
                  ir_expression *const r3DA9 = expr(ir_unop_b2i, r3DA8);
                  ir_expression *const r3DAA = expr(ir_unop_i2u, r3DA9);
                  body.emit(assign(r3DA5, sub(r3DA7, r3DAA), 0x01));

                  body.emit(assign(r3BC7, add(r3BC2, body.constant(int(-1))), 0x01));

                  ir_variable *const r3DAB = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r3DAB, add(r3BC7, body.constant(int(-10))), 0x01));

                  ir_variable *const r3DAC = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r3DAC, r3DA5, 0x01));

                  ir_variable *const r3DAD = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r3DAD, r3DA6, 0x01));

                  ir_variable *const r3DAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r3DAE);
                  ir_variable *const r3DAF = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3DAF);
                  /* IF CONDITION */
                  ir_expression *const r3DB1 = equal(r3DA5, body.constant(0u));
                  ir_if *f3DB0 = new(mem_ctx) ir_if(operand(r3DB1).val);
                  exec_list *const f3DB0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3DB0->then_instructions;

                     body.emit(assign(r3DAC, r3DA6, 0x01));

                     body.emit(assign(r3DAD, body.constant(0u), 0x01));

                     body.emit(assign(r3DAB, add(r3DAB, body.constant(int(-32))), 0x01));


                  body.instructions = f3DB0_parent_instructions;
                  body.emit(f3DB0);

                  /* END IF */

                  ir_variable *const r3DB2 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r3DB2, r3DAC, 0x01));

                  ir_variable *const r3DB3 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3DB4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3DB4);
                  /* IF CONDITION */
                  ir_expression *const r3DB6 = equal(r3DAC, body.constant(0u));
                  ir_if *f3DB5 = new(mem_ctx) ir_if(operand(r3DB6).val);
                  exec_list *const f3DB5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3DB5->then_instructions;

                     body.emit(assign(r3DB3, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3DB5->else_instructions;

                     body.emit(assign(r3DB4, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3DB8 = bit_and(r3DAC, body.constant(4294901760u));
                     ir_expression *const r3DB9 = equal(r3DB8, body.constant(0u));
                     ir_if *f3DB7 = new(mem_ctx) ir_if(operand(r3DB9).val);
                     exec_list *const f3DB7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DB7->then_instructions;

                        body.emit(assign(r3DB4, body.constant(int(16)), 0x01));

                        body.emit(assign(r3DB2, lshift(r3DAC, body.constant(int(16))), 0x01));


                     body.instructions = f3DB7_parent_instructions;
                     body.emit(f3DB7);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3DBB = bit_and(r3DB2, body.constant(4278190080u));
                     ir_expression *const r3DBC = equal(r3DBB, body.constant(0u));
                     ir_if *f3DBA = new(mem_ctx) ir_if(operand(r3DBC).val);
                     exec_list *const f3DBA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DBA->then_instructions;

                        body.emit(assign(r3DB4, add(r3DB4, body.constant(int(8))), 0x01));

                        body.emit(assign(r3DB2, lshift(r3DB2, body.constant(int(8))), 0x01));


                     body.instructions = f3DBA_parent_instructions;
                     body.emit(f3DBA);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3DBE = bit_and(r3DB2, body.constant(4026531840u));
                     ir_expression *const r3DBF = equal(r3DBE, body.constant(0u));
                     ir_if *f3DBD = new(mem_ctx) ir_if(operand(r3DBF).val);
                     exec_list *const f3DBD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DBD->then_instructions;

                        body.emit(assign(r3DB4, add(r3DB4, body.constant(int(4))), 0x01));

                        body.emit(assign(r3DB2, lshift(r3DB2, body.constant(int(4))), 0x01));


                     body.instructions = f3DBD_parent_instructions;
                     body.emit(f3DBD);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3DC1 = bit_and(r3DB2, body.constant(3221225472u));
                     ir_expression *const r3DC2 = equal(r3DC1, body.constant(0u));
                     ir_if *f3DC0 = new(mem_ctx) ir_if(operand(r3DC2).val);
                     exec_list *const f3DC0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DC0->then_instructions;

                        body.emit(assign(r3DB4, add(r3DB4, body.constant(int(2))), 0x01));

                        body.emit(assign(r3DB2, lshift(r3DB2, body.constant(int(2))), 0x01));


                     body.instructions = f3DC0_parent_instructions;
                     body.emit(f3DC0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3DC4 = bit_and(r3DB2, body.constant(2147483648u));
                     ir_expression *const r3DC5 = equal(r3DC4, body.constant(0u));
                     ir_if *f3DC3 = new(mem_ctx) ir_if(operand(r3DC5).val);
                     exec_list *const f3DC3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DC3->then_instructions;

                        body.emit(assign(r3DB4, add(r3DB4, body.constant(int(1))), 0x01));


                     body.instructions = f3DC3_parent_instructions;
                     body.emit(f3DC3);

                     /* END IF */

                     body.emit(assign(r3DB3, r3DB4, 0x01));


                  body.instructions = f3DB5_parent_instructions;
                  body.emit(f3DB5);

                  /* END IF */

                  body.emit(assign(r3DAF, add(r3DB3, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3DC7 = lequal(body.constant(int(0)), r3DAF);
                  ir_if *f3DC6 = new(mem_ctx) ir_if(operand(r3DC7).val);
                  exec_list *const f3DC6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3DC6->then_instructions;

                     body.emit(assign(r3DAE, body.constant(0u), 0x01));

                     ir_variable *const r3DC8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3DC8, lshift(r3DAD, r3DAF), 0x01));

                     ir_variable *const r3DC9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3DCB = equal(r3DAF, body.constant(int(0)));
                     ir_if *f3DCA = new(mem_ctx) ir_if(operand(r3DCB).val);
                     exec_list *const f3DCA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DCA->then_instructions;

                        body.emit(assign(r3DC9, r3DAC, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3DCA->else_instructions;

                        ir_expression *const r3DCC = lshift(r3DAC, r3DAF);
                        ir_expression *const r3DCD = neg(r3DAF);
                        ir_expression *const r3DCE = bit_and(r3DCD, body.constant(int(31)));
                        ir_expression *const r3DCF = rshift(r3DAD, r3DCE);
                        body.emit(assign(r3DC9, bit_or(r3DCC, r3DCF), 0x01));


                     body.instructions = f3DCA_parent_instructions;
                     body.emit(f3DCA);

                     /* END IF */

                     body.emit(assign(r3DAC, r3DC9, 0x01));

                     body.emit(assign(r3DAD, r3DC8, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3DC6->else_instructions;

                     ir_variable *const r3DD0 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r3DD0, body.constant(0u), 0x01));

                     ir_variable *const r3DD1 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r3DD1, neg(r3DAF), 0x01));

                     ir_variable *const r3DD2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r3DD2);
                     ir_variable *const r3DD3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3DD3);
                     ir_variable *const r3DD4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3DD4);
                     ir_variable *const r3DD5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r3DD6 = neg(r3DD1);
                     body.emit(assign(r3DD5, bit_and(r3DD6, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3DD8 = equal(r3DD1, body.constant(int(0)));
                     ir_if *f3DD7 = new(mem_ctx) ir_if(operand(r3DD8).val);
                     exec_list *const f3DD7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DD7->then_instructions;

                        body.emit(assign(r3DD2, r3DD0, 0x01));

                        body.emit(assign(r3DD3, r3DAD, 0x01));

                        body.emit(assign(r3DD4, r3DAC, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3DD7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3DDA = less(r3DD1, body.constant(int(32)));
                        ir_if *f3DD9 = new(mem_ctx) ir_if(operand(r3DDA).val);
                        exec_list *const f3DD9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3DD9->then_instructions;

                           body.emit(assign(r3DD2, lshift(r3DAD, r3DD5), 0x01));

                           ir_expression *const r3DDB = lshift(r3DAC, r3DD5);
                           ir_expression *const r3DDC = rshift(r3DAD, r3DD1);
                           body.emit(assign(r3DD3, bit_or(r3DDB, r3DDC), 0x01));

                           body.emit(assign(r3DD4, rshift(r3DAC, r3DD1), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3DD9->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3DDE = equal(r3DD1, body.constant(int(32)));
                           ir_if *f3DDD = new(mem_ctx) ir_if(operand(r3DDE).val);
                           exec_list *const f3DDD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3DDD->then_instructions;

                              body.emit(assign(r3DD2, r3DAD, 0x01));

                              body.emit(assign(r3DD3, r3DAC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3DDD->else_instructions;

                              body.emit(assign(r3DD0, bit_or(body.constant(0u), r3DAD), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3DE0 = less(r3DD1, body.constant(int(64)));
                              ir_if *f3DDF = new(mem_ctx) ir_if(operand(r3DE0).val);
                              exec_list *const f3DDF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3DDF->then_instructions;

                                 body.emit(assign(r3DD2, lshift(r3DAC, r3DD5), 0x01));

                                 ir_expression *const r3DE1 = bit_and(r3DD1, body.constant(int(31)));
                                 body.emit(assign(r3DD3, rshift(r3DAC, r3DE1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3DDF->else_instructions;

                                 ir_variable *const r3DE2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3DE4 = equal(r3DD1, body.constant(int(64)));
                                 ir_if *f3DE3 = new(mem_ctx) ir_if(operand(r3DE4).val);
                                 exec_list *const f3DE3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3DE3->then_instructions;

                                    body.emit(assign(r3DE2, r3DAC, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3DE3->else_instructions;

                                    ir_expression *const r3DE5 = nequal(r3DAC, body.constant(0u));
                                    ir_expression *const r3DE6 = expr(ir_unop_b2i, r3DE5);
                                    body.emit(assign(r3DE2, expr(ir_unop_i2u, r3DE6), 0x01));


                                 body.instructions = f3DE3_parent_instructions;
                                 body.emit(f3DE3);

                                 /* END IF */

                                 body.emit(assign(r3DD2, r3DE2, 0x01));

                                 body.emit(assign(r3DD3, body.constant(0u), 0x01));


                              body.instructions = f3DDF_parent_instructions;
                              body.emit(f3DDF);

                              /* END IF */


                           body.instructions = f3DDD_parent_instructions;
                           body.emit(f3DDD);

                           /* END IF */

                           body.emit(assign(r3DD4, body.constant(0u), 0x01));


                        body.instructions = f3DD9_parent_instructions;
                        body.emit(f3DD9);

                        /* END IF */

                        ir_expression *const r3DE7 = nequal(r3DD0, body.constant(0u));
                        ir_expression *const r3DE8 = expr(ir_unop_b2i, r3DE7);
                        ir_expression *const r3DE9 = expr(ir_unop_i2u, r3DE8);
                        body.emit(assign(r3DD2, bit_or(r3DD2, r3DE9), 0x01));


                     body.instructions = f3DD7_parent_instructions;
                     body.emit(f3DD7);

                     /* END IF */

                     body.emit(assign(r3DAC, r3DD4, 0x01));

                     body.emit(assign(r3DAD, r3DD3, 0x01));

                     body.emit(assign(r3DAE, r3DD2, 0x01));


                  body.instructions = f3DC6_parent_instructions;
                  body.emit(f3DC6);

                  /* END IF */

                  body.emit(assign(r3DAB, sub(r3DAB, r3DAF), 0x01));

                  ir_variable *const r3DEA = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r3DEA, r3DAB, 0x01));

                  ir_variable *const r3DEB = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r3DEB, r3DAC, 0x01));

                  ir_variable *const r3DEC = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r3DEC, r3DAD, 0x01));

                  ir_variable *const r3DED = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r3DED, r3DAE, 0x01));

                  ir_variable *const r3DEE = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r3DEE, body.constant(true), 0x01));

                  ir_variable *const r3DEF = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3DF0 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r3DF0);
                  ir_expression *const r3DF1 = expr(ir_unop_u2i, r3DAE);
                  body.emit(assign(r3DF0, less(r3DF1, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3DF3 = lequal(body.constant(int(2045)), r3DAB);
                  ir_if *f3DF2 = new(mem_ctx) ir_if(operand(r3DF3).val);
                  exec_list *const f3DF2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3DF2->then_instructions;

                     ir_variable *const r3DF4 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3DF6 = less(body.constant(int(2045)), r3DAB);
                     ir_if *f3DF5 = new(mem_ctx) ir_if(operand(r3DF6).val);
                     exec_list *const f3DF5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DF5->then_instructions;

                        body.emit(assign(r3DF4, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3DF5->else_instructions;

                        ir_variable *const r3DF7 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3DF9 = equal(r3DAB, body.constant(int(2045)));
                        ir_if *f3DF8 = new(mem_ctx) ir_if(operand(r3DF9).val);
                        exec_list *const f3DF8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3DF8->then_instructions;

                           ir_expression *const r3DFA = equal(body.constant(2097151u), r3DAC);
                           ir_expression *const r3DFB = equal(body.constant(4294967295u), r3DAD);
                           body.emit(assign(r3DF7, logic_and(r3DFA, r3DFB), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3DF8->else_instructions;

                           body.emit(assign(r3DF7, body.constant(false), 0x01));


                        body.instructions = f3DF8_parent_instructions;
                        body.emit(f3DF8);

                        /* END IF */

                        body.emit(assign(r3DF4, logic_and(r3DF7, r3DF0), 0x01));


                     body.instructions = f3DF5_parent_instructions;
                     body.emit(f3DF5);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f3DFC = new(mem_ctx) ir_if(operand(r3DF4).val);
                     exec_list *const f3DFC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DFC->then_instructions;

                        ir_variable *const r3DFD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3DFD);
                        ir_expression *const r3DFE = lshift(r3BBE, body.constant(int(31)));
                        body.emit(assign(r3DFD, add(r3DFE, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r3DFD, body.constant(0u), 0x01));

                        body.emit(assign(r3DEF, r3DFD, 0x03));

                        body.emit(assign(r3DEE, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3DFC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3E00 = less(r3DAB, body.constant(int(0)));
                        ir_if *f3DFF = new(mem_ctx) ir_if(operand(r3E00).val);
                        exec_list *const f3DFF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3DFF->then_instructions;

                           ir_variable *const r3E01 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3E01, r3DAE, 0x01));

                           ir_variable *const r3E02 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3E02, neg(r3DAB), 0x01));

                           ir_variable *const r3E03 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3E03);
                           ir_variable *const r3E04 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3E04);
                           ir_variable *const r3E05 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3E05);
                           ir_variable *const r3E06 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r3E07 = neg(r3E02);
                           body.emit(assign(r3E06, bit_and(r3E07, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3E09 = equal(r3E02, body.constant(int(0)));
                           ir_if *f3E08 = new(mem_ctx) ir_if(operand(r3E09).val);
                           exec_list *const f3E08_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3E08->then_instructions;

                              body.emit(assign(r3E03, r3DAE, 0x01));

                              body.emit(assign(r3E04, r3DAD, 0x01));

                              body.emit(assign(r3E05, r3DAC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3E08->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3E0B = less(r3E02, body.constant(int(32)));
                              ir_if *f3E0A = new(mem_ctx) ir_if(operand(r3E0B).val);
                              exec_list *const f3E0A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3E0A->then_instructions;

                                 body.emit(assign(r3E03, lshift(r3DAD, r3E06), 0x01));

                                 ir_expression *const r3E0C = lshift(r3DAC, r3E06);
                                 ir_expression *const r3E0D = rshift(r3DAD, r3E02);
                                 body.emit(assign(r3E04, bit_or(r3E0C, r3E0D), 0x01));

                                 body.emit(assign(r3E05, rshift(r3DAC, r3E02), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3E0A->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3E0F = equal(r3E02, body.constant(int(32)));
                                 ir_if *f3E0E = new(mem_ctx) ir_if(operand(r3E0F).val);
                                 exec_list *const f3E0E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3E0E->then_instructions;

                                    body.emit(assign(r3E03, r3DAD, 0x01));

                                    body.emit(assign(r3E04, r3DAC, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3E0E->else_instructions;

                                    body.emit(assign(r3E01, bit_or(r3DAE, r3DAD), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3E11 = less(r3E02, body.constant(int(64)));
                                    ir_if *f3E10 = new(mem_ctx) ir_if(operand(r3E11).val);
                                    exec_list *const f3E10_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3E10->then_instructions;

                                       body.emit(assign(r3E03, lshift(r3DAC, r3E06), 0x01));

                                       ir_expression *const r3E12 = bit_and(r3E02, body.constant(int(31)));
                                       body.emit(assign(r3E04, rshift(r3DAC, r3E12), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3E10->else_instructions;

                                       ir_variable *const r3E13 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3E15 = equal(r3E02, body.constant(int(64)));
                                       ir_if *f3E14 = new(mem_ctx) ir_if(operand(r3E15).val);
                                       exec_list *const f3E14_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3E14->then_instructions;

                                          body.emit(assign(r3E13, r3DAC, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3E14->else_instructions;

                                          ir_expression *const r3E16 = nequal(r3DAC, body.constant(0u));
                                          ir_expression *const r3E17 = expr(ir_unop_b2i, r3E16);
                                          body.emit(assign(r3E13, expr(ir_unop_i2u, r3E17), 0x01));


                                       body.instructions = f3E14_parent_instructions;
                                       body.emit(f3E14);

                                       /* END IF */

                                       body.emit(assign(r3E03, r3E13, 0x01));

                                       body.emit(assign(r3E04, body.constant(0u), 0x01));


                                    body.instructions = f3E10_parent_instructions;
                                    body.emit(f3E10);

                                    /* END IF */


                                 body.instructions = f3E0E_parent_instructions;
                                 body.emit(f3E0E);

                                 /* END IF */

                                 body.emit(assign(r3E05, body.constant(0u), 0x01));


                              body.instructions = f3E0A_parent_instructions;
                              body.emit(f3E0A);

                              /* END IF */

                              ir_expression *const r3E18 = nequal(r3E01, body.constant(0u));
                              ir_expression *const r3E19 = expr(ir_unop_b2i, r3E18);
                              ir_expression *const r3E1A = expr(ir_unop_i2u, r3E19);
                              body.emit(assign(r3E03, bit_or(r3E03, r3E1A), 0x01));


                           body.instructions = f3E08_parent_instructions;
                           body.emit(f3E08);

                           /* END IF */

                           body.emit(assign(r3DEB, r3E05, 0x01));

                           body.emit(assign(r3DEC, r3E04, 0x01));

                           body.emit(assign(r3DED, r3E03, 0x01));

                           body.emit(assign(r3DEA, body.constant(int(0)), 0x01));

                           body.emit(assign(r3DF0, less(r3E03, body.constant(0u)), 0x01));


                        body.instructions = f3DFF_parent_instructions;
                        body.emit(f3DFF);

                        /* END IF */


                     body.instructions = f3DFC_parent_instructions;
                     body.emit(f3DFC);

                     /* END IF */


                  body.instructions = f3DF2_parent_instructions;
                  body.emit(f3DF2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3E1B = new(mem_ctx) ir_if(operand(r3DEE).val);
                  exec_list *const f3E1B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3E1B->then_instructions;

                     /* IF CONDITION */
                     ir_if *f3E1C = new(mem_ctx) ir_if(operand(r3DF0).val);
                     exec_list *const f3E1C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E1C->then_instructions;

                        ir_variable *const r3E1D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r3E1D, add(r3DEC, body.constant(1u)), 0x01));

                        ir_expression *const r3E1E = less(r3E1D, r3DEC);
                        ir_expression *const r3E1F = expr(ir_unop_b2i, r3E1E);
                        ir_expression *const r3E20 = expr(ir_unop_i2u, r3E1F);
                        body.emit(assign(r3DEB, add(r3DEB, r3E20), 0x01));

                        ir_expression *const r3E21 = equal(r3DED, body.constant(0u));
                        ir_expression *const r3E22 = expr(ir_unop_b2i, r3E21);
                        ir_expression *const r3E23 = expr(ir_unop_i2u, r3E22);
                        ir_expression *const r3E24 = add(r3DED, r3E23);
                        ir_expression *const r3E25 = bit_and(r3E24, body.constant(1u));
                        ir_expression *const r3E26 = expr(ir_unop_bit_not, r3E25);
                        body.emit(assign(r3DEC, bit_and(r3E1D, r3E26), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3E1C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3E28 = bit_or(r3DEB, r3DEC);
                        ir_expression *const r3E29 = equal(r3E28, body.constant(0u));
                        ir_if *f3E27 = new(mem_ctx) ir_if(operand(r3E29).val);
                        exec_list *const f3E27_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E27->then_instructions;

                           body.emit(assign(r3DEA, body.constant(int(0)), 0x01));


                        body.instructions = f3E27_parent_instructions;
                        body.emit(f3E27);

                        /* END IF */


                     body.instructions = f3E1C_parent_instructions;
                     body.emit(f3E1C);

                     /* END IF */

                     ir_variable *const r3E2A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3E2A);
                     ir_expression *const r3E2B = lshift(r3BBE, body.constant(int(31)));
                     ir_expression *const r3E2C = expr(ir_unop_i2u, r3DEA);
                     ir_expression *const r3E2D = lshift(r3E2C, body.constant(int(20)));
                     ir_expression *const r3E2E = add(r3E2B, r3E2D);
                     body.emit(assign(r3E2A, add(r3E2E, r3DEB), 0x02));

                     body.emit(assign(r3E2A, r3DEC, 0x01));

                     body.emit(assign(r3DEF, r3E2A, 0x03));

                     body.emit(assign(r3DEE, body.constant(false), 0x01));


                  body.instructions = f3E1B_parent_instructions;
                  body.emit(f3E1B);

                  /* END IF */

                  body.emit(assign(r3BBF, r3DEF, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3DA3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3E30 = less(r3BC5, r3BC3);
                  ir_if *f3E2F = new(mem_ctx) ir_if(operand(r3E30).val);
                  exec_list *const f3E2F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3E2F->then_instructions;

                     ir_variable *const r3E31 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r3E32 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3E32, sub(r3BC4, r3BC6), 0x01));

                     ir_expression *const r3E33 = sub(r3BC3, r3BC5);
                     ir_expression *const r3E34 = less(r3BC4, r3BC6);
                     ir_expression *const r3E35 = expr(ir_unop_b2i, r3E34);
                     ir_expression *const r3E36 = expr(ir_unop_i2u, r3E35);
                     body.emit(assign(r3E31, sub(r3E33, r3E36), 0x01));

                     body.emit(assign(r3BBE, bit_xor(r3BBE, body.constant(1u)), 0x01));

                     body.emit(assign(r3BC7, add(r3BC1, body.constant(int(-1))), 0x01));

                     ir_variable *const r3E37 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r3E37, add(r3BC7, body.constant(int(-10))), 0x01));

                     ir_variable *const r3E38 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r3E38, r3E31, 0x01));

                     ir_variable *const r3E39 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r3E39, r3E32, 0x01));

                     ir_variable *const r3E3A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r3E3A);
                     ir_variable *const r3E3B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3E3B);
                     /* IF CONDITION */
                     ir_expression *const r3E3D = equal(r3E31, body.constant(0u));
                     ir_if *f3E3C = new(mem_ctx) ir_if(operand(r3E3D).val);
                     exec_list *const f3E3C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E3C->then_instructions;

                        body.emit(assign(r3E38, r3E32, 0x01));

                        body.emit(assign(r3E39, body.constant(0u), 0x01));

                        body.emit(assign(r3E37, add(r3E37, body.constant(int(-32))), 0x01));


                     body.instructions = f3E3C_parent_instructions;
                     body.emit(f3E3C);

                     /* END IF */

                     ir_variable *const r3E3E = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3E3E, r3E38, 0x01));

                     ir_variable *const r3E3F = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3E40 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3E40);
                     /* IF CONDITION */
                     ir_expression *const r3E42 = equal(r3E38, body.constant(0u));
                     ir_if *f3E41 = new(mem_ctx) ir_if(operand(r3E42).val);
                     exec_list *const f3E41_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E41->then_instructions;

                        body.emit(assign(r3E3F, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3E41->else_instructions;

                        body.emit(assign(r3E40, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3E44 = bit_and(r3E38, body.constant(4294901760u));
                        ir_expression *const r3E45 = equal(r3E44, body.constant(0u));
                        ir_if *f3E43 = new(mem_ctx) ir_if(operand(r3E45).val);
                        exec_list *const f3E43_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E43->then_instructions;

                           body.emit(assign(r3E40, body.constant(int(16)), 0x01));

                           body.emit(assign(r3E3E, lshift(r3E38, body.constant(int(16))), 0x01));


                        body.instructions = f3E43_parent_instructions;
                        body.emit(f3E43);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3E47 = bit_and(r3E3E, body.constant(4278190080u));
                        ir_expression *const r3E48 = equal(r3E47, body.constant(0u));
                        ir_if *f3E46 = new(mem_ctx) ir_if(operand(r3E48).val);
                        exec_list *const f3E46_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E46->then_instructions;

                           body.emit(assign(r3E40, add(r3E40, body.constant(int(8))), 0x01));

                           body.emit(assign(r3E3E, lshift(r3E3E, body.constant(int(8))), 0x01));


                        body.instructions = f3E46_parent_instructions;
                        body.emit(f3E46);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3E4A = bit_and(r3E3E, body.constant(4026531840u));
                        ir_expression *const r3E4B = equal(r3E4A, body.constant(0u));
                        ir_if *f3E49 = new(mem_ctx) ir_if(operand(r3E4B).val);
                        exec_list *const f3E49_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E49->then_instructions;

                           body.emit(assign(r3E40, add(r3E40, body.constant(int(4))), 0x01));

                           body.emit(assign(r3E3E, lshift(r3E3E, body.constant(int(4))), 0x01));


                        body.instructions = f3E49_parent_instructions;
                        body.emit(f3E49);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3E4D = bit_and(r3E3E, body.constant(3221225472u));
                        ir_expression *const r3E4E = equal(r3E4D, body.constant(0u));
                        ir_if *f3E4C = new(mem_ctx) ir_if(operand(r3E4E).val);
                        exec_list *const f3E4C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E4C->then_instructions;

                           body.emit(assign(r3E40, add(r3E40, body.constant(int(2))), 0x01));

                           body.emit(assign(r3E3E, lshift(r3E3E, body.constant(int(2))), 0x01));


                        body.instructions = f3E4C_parent_instructions;
                        body.emit(f3E4C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3E50 = bit_and(r3E3E, body.constant(2147483648u));
                        ir_expression *const r3E51 = equal(r3E50, body.constant(0u));
                        ir_if *f3E4F = new(mem_ctx) ir_if(operand(r3E51).val);
                        exec_list *const f3E4F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E4F->then_instructions;

                           body.emit(assign(r3E40, add(r3E40, body.constant(int(1))), 0x01));


                        body.instructions = f3E4F_parent_instructions;
                        body.emit(f3E4F);

                        /* END IF */

                        body.emit(assign(r3E3F, r3E40, 0x01));


                     body.instructions = f3E41_parent_instructions;
                     body.emit(f3E41);

                     /* END IF */

                     body.emit(assign(r3E3B, add(r3E3F, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3E53 = lequal(body.constant(int(0)), r3E3B);
                     ir_if *f3E52 = new(mem_ctx) ir_if(operand(r3E53).val);
                     exec_list *const f3E52_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E52->then_instructions;

                        body.emit(assign(r3E3A, body.constant(0u), 0x01));

                        ir_variable *const r3E54 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r3E54, lshift(r3E39, r3E3B), 0x01));

                        ir_variable *const r3E55 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3E57 = equal(r3E3B, body.constant(int(0)));
                        ir_if *f3E56 = new(mem_ctx) ir_if(operand(r3E57).val);
                        exec_list *const f3E56_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E56->then_instructions;

                           body.emit(assign(r3E55, r3E38, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3E56->else_instructions;

                           ir_expression *const r3E58 = lshift(r3E38, r3E3B);
                           ir_expression *const r3E59 = neg(r3E3B);
                           ir_expression *const r3E5A = bit_and(r3E59, body.constant(int(31)));
                           ir_expression *const r3E5B = rshift(r3E39, r3E5A);
                           body.emit(assign(r3E55, bit_or(r3E58, r3E5B), 0x01));


                        body.instructions = f3E56_parent_instructions;
                        body.emit(f3E56);

                        /* END IF */

                        body.emit(assign(r3E38, r3E55, 0x01));

                        body.emit(assign(r3E39, r3E54, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3E52->else_instructions;

                        ir_variable *const r3E5C = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3E5C, body.constant(0u), 0x01));

                        ir_variable *const r3E5D = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3E5D, neg(r3E3B), 0x01));

                        ir_variable *const r3E5E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3E5E);
                        ir_variable *const r3E5F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3E5F);
                        ir_variable *const r3E60 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3E60);
                        ir_variable *const r3E61 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3E62 = neg(r3E5D);
                        body.emit(assign(r3E61, bit_and(r3E62, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3E64 = equal(r3E5D, body.constant(int(0)));
                        ir_if *f3E63 = new(mem_ctx) ir_if(operand(r3E64).val);
                        exec_list *const f3E63_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E63->then_instructions;

                           body.emit(assign(r3E5E, r3E5C, 0x01));

                           body.emit(assign(r3E5F, r3E39, 0x01));

                           body.emit(assign(r3E60, r3E38, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3E63->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3E66 = less(r3E5D, body.constant(int(32)));
                           ir_if *f3E65 = new(mem_ctx) ir_if(operand(r3E66).val);
                           exec_list *const f3E65_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3E65->then_instructions;

                              body.emit(assign(r3E5E, lshift(r3E39, r3E61), 0x01));

                              ir_expression *const r3E67 = lshift(r3E38, r3E61);
                              ir_expression *const r3E68 = rshift(r3E39, r3E5D);
                              body.emit(assign(r3E5F, bit_or(r3E67, r3E68), 0x01));

                              body.emit(assign(r3E60, rshift(r3E38, r3E5D), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3E65->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3E6A = equal(r3E5D, body.constant(int(32)));
                              ir_if *f3E69 = new(mem_ctx) ir_if(operand(r3E6A).val);
                              exec_list *const f3E69_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3E69->then_instructions;

                                 body.emit(assign(r3E5E, r3E39, 0x01));

                                 body.emit(assign(r3E5F, r3E38, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3E69->else_instructions;

                                 body.emit(assign(r3E5C, bit_or(body.constant(0u), r3E39), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3E6C = less(r3E5D, body.constant(int(64)));
                                 ir_if *f3E6B = new(mem_ctx) ir_if(operand(r3E6C).val);
                                 exec_list *const f3E6B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3E6B->then_instructions;

                                    body.emit(assign(r3E5E, lshift(r3E38, r3E61), 0x01));

                                    ir_expression *const r3E6D = bit_and(r3E5D, body.constant(int(31)));
                                    body.emit(assign(r3E5F, rshift(r3E38, r3E6D), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3E6B->else_instructions;

                                    ir_variable *const r3E6E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3E70 = equal(r3E5D, body.constant(int(64)));
                                    ir_if *f3E6F = new(mem_ctx) ir_if(operand(r3E70).val);
                                    exec_list *const f3E6F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3E6F->then_instructions;

                                       body.emit(assign(r3E6E, r3E38, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3E6F->else_instructions;

                                       ir_expression *const r3E71 = nequal(r3E38, body.constant(0u));
                                       ir_expression *const r3E72 = expr(ir_unop_b2i, r3E71);
                                       body.emit(assign(r3E6E, expr(ir_unop_i2u, r3E72), 0x01));


                                    body.instructions = f3E6F_parent_instructions;
                                    body.emit(f3E6F);

                                    /* END IF */

                                    body.emit(assign(r3E5E, r3E6E, 0x01));

                                    body.emit(assign(r3E5F, body.constant(0u), 0x01));


                                 body.instructions = f3E6B_parent_instructions;
                                 body.emit(f3E6B);

                                 /* END IF */


                              body.instructions = f3E69_parent_instructions;
                              body.emit(f3E69);

                              /* END IF */

                              body.emit(assign(r3E60, body.constant(0u), 0x01));


                           body.instructions = f3E65_parent_instructions;
                           body.emit(f3E65);

                           /* END IF */

                           ir_expression *const r3E73 = nequal(r3E5C, body.constant(0u));
                           ir_expression *const r3E74 = expr(ir_unop_b2i, r3E73);
                           ir_expression *const r3E75 = expr(ir_unop_i2u, r3E74);
                           body.emit(assign(r3E5E, bit_or(r3E5E, r3E75), 0x01));


                        body.instructions = f3E63_parent_instructions;
                        body.emit(f3E63);

                        /* END IF */

                        body.emit(assign(r3E38, r3E60, 0x01));

                        body.emit(assign(r3E39, r3E5F, 0x01));

                        body.emit(assign(r3E3A, r3E5E, 0x01));


                     body.instructions = f3E52_parent_instructions;
                     body.emit(f3E52);

                     /* END IF */

                     body.emit(assign(r3E37, sub(r3E37, r3E3B), 0x01));

                     ir_variable *const r3E76 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r3E76, r3E37, 0x01));

                     ir_variable *const r3E77 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r3E77, r3E38, 0x01));

                     ir_variable *const r3E78 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r3E78, r3E39, 0x01));

                     ir_variable *const r3E79 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r3E79, r3E3A, 0x01));

                     ir_variable *const r3E7A = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r3E7A, body.constant(true), 0x01));

                     ir_variable *const r3E7B = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r3E7C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r3E7C);
                     ir_expression *const r3E7D = expr(ir_unop_u2i, r3E3A);
                     body.emit(assign(r3E7C, less(r3E7D, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3E7F = lequal(body.constant(int(2045)), r3E37);
                     ir_if *f3E7E = new(mem_ctx) ir_if(operand(r3E7F).val);
                     exec_list *const f3E7E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E7E->then_instructions;

                        ir_variable *const r3E80 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3E82 = less(body.constant(int(2045)), r3E37);
                        ir_if *f3E81 = new(mem_ctx) ir_if(operand(r3E82).val);
                        exec_list *const f3E81_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E81->then_instructions;

                           body.emit(assign(r3E80, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3E81->else_instructions;

                           ir_variable *const r3E83 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3E85 = equal(r3E37, body.constant(int(2045)));
                           ir_if *f3E84 = new(mem_ctx) ir_if(operand(r3E85).val);
                           exec_list *const f3E84_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3E84->then_instructions;

                              ir_expression *const r3E86 = equal(body.constant(2097151u), r3E38);
                              ir_expression *const r3E87 = equal(body.constant(4294967295u), r3E39);
                              body.emit(assign(r3E83, logic_and(r3E86, r3E87), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3E84->else_instructions;

                              body.emit(assign(r3E83, body.constant(false), 0x01));


                           body.instructions = f3E84_parent_instructions;
                           body.emit(f3E84);

                           /* END IF */

                           body.emit(assign(r3E80, logic_and(r3E83, r3E7C), 0x01));


                        body.instructions = f3E81_parent_instructions;
                        body.emit(f3E81);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f3E88 = new(mem_ctx) ir_if(operand(r3E80).val);
                        exec_list *const f3E88_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E88->then_instructions;

                           ir_variable *const r3E89 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3E89);
                           ir_expression *const r3E8A = lshift(r3BBE, body.constant(int(31)));
                           body.emit(assign(r3E89, add(r3E8A, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r3E89, body.constant(0u), 0x01));

                           body.emit(assign(r3E7B, r3E89, 0x03));

                           body.emit(assign(r3E7A, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3E88->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3E8C = less(r3E37, body.constant(int(0)));
                           ir_if *f3E8B = new(mem_ctx) ir_if(operand(r3E8C).val);
                           exec_list *const f3E8B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3E8B->then_instructions;

                              ir_variable *const r3E8D = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r3E8D, r3E3A, 0x01));

                              ir_variable *const r3E8E = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r3E8E, neg(r3E37), 0x01));

                              ir_variable *const r3E8F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r3E8F);
                              ir_variable *const r3E90 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r3E90);
                              ir_variable *const r3E91 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r3E91);
                              ir_variable *const r3E92 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r3E93 = neg(r3E8E);
                              body.emit(assign(r3E92, bit_and(r3E93, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3E95 = equal(r3E8E, body.constant(int(0)));
                              ir_if *f3E94 = new(mem_ctx) ir_if(operand(r3E95).val);
                              exec_list *const f3E94_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3E94->then_instructions;

                                 body.emit(assign(r3E8F, r3E3A, 0x01));

                                 body.emit(assign(r3E90, r3E39, 0x01));

                                 body.emit(assign(r3E91, r3E38, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3E94->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3E97 = less(r3E8E, body.constant(int(32)));
                                 ir_if *f3E96 = new(mem_ctx) ir_if(operand(r3E97).val);
                                 exec_list *const f3E96_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3E96->then_instructions;

                                    body.emit(assign(r3E8F, lshift(r3E39, r3E92), 0x01));

                                    ir_expression *const r3E98 = lshift(r3E38, r3E92);
                                    ir_expression *const r3E99 = rshift(r3E39, r3E8E);
                                    body.emit(assign(r3E90, bit_or(r3E98, r3E99), 0x01));

                                    body.emit(assign(r3E91, rshift(r3E38, r3E8E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3E96->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3E9B = equal(r3E8E, body.constant(int(32)));
                                    ir_if *f3E9A = new(mem_ctx) ir_if(operand(r3E9B).val);
                                    exec_list *const f3E9A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3E9A->then_instructions;

                                       body.emit(assign(r3E8F, r3E39, 0x01));

                                       body.emit(assign(r3E90, r3E38, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3E9A->else_instructions;

                                       body.emit(assign(r3E8D, bit_or(r3E3A, r3E39), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r3E9D = less(r3E8E, body.constant(int(64)));
                                       ir_if *f3E9C = new(mem_ctx) ir_if(operand(r3E9D).val);
                                       exec_list *const f3E9C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3E9C->then_instructions;

                                          body.emit(assign(r3E8F, lshift(r3E38, r3E92), 0x01));

                                          ir_expression *const r3E9E = bit_and(r3E8E, body.constant(int(31)));
                                          body.emit(assign(r3E90, rshift(r3E38, r3E9E), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3E9C->else_instructions;

                                          ir_variable *const r3E9F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3EA1 = equal(r3E8E, body.constant(int(64)));
                                          ir_if *f3EA0 = new(mem_ctx) ir_if(operand(r3EA1).val);
                                          exec_list *const f3EA0_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3EA0->then_instructions;

                                             body.emit(assign(r3E9F, r3E38, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3EA0->else_instructions;

                                             ir_expression *const r3EA2 = nequal(r3E38, body.constant(0u));
                                             ir_expression *const r3EA3 = expr(ir_unop_b2i, r3EA2);
                                             body.emit(assign(r3E9F, expr(ir_unop_i2u, r3EA3), 0x01));


                                          body.instructions = f3EA0_parent_instructions;
                                          body.emit(f3EA0);

                                          /* END IF */

                                          body.emit(assign(r3E8F, r3E9F, 0x01));

                                          body.emit(assign(r3E90, body.constant(0u), 0x01));


                                       body.instructions = f3E9C_parent_instructions;
                                       body.emit(f3E9C);

                                       /* END IF */


                                    body.instructions = f3E9A_parent_instructions;
                                    body.emit(f3E9A);

                                    /* END IF */

                                    body.emit(assign(r3E91, body.constant(0u), 0x01));


                                 body.instructions = f3E96_parent_instructions;
                                 body.emit(f3E96);

                                 /* END IF */

                                 ir_expression *const r3EA4 = nequal(r3E8D, body.constant(0u));
                                 ir_expression *const r3EA5 = expr(ir_unop_b2i, r3EA4);
                                 ir_expression *const r3EA6 = expr(ir_unop_i2u, r3EA5);
                                 body.emit(assign(r3E8F, bit_or(r3E8F, r3EA6), 0x01));


                              body.instructions = f3E94_parent_instructions;
                              body.emit(f3E94);

                              /* END IF */

                              body.emit(assign(r3E77, r3E91, 0x01));

                              body.emit(assign(r3E78, r3E90, 0x01));

                              body.emit(assign(r3E79, r3E8F, 0x01));

                              body.emit(assign(r3E76, body.constant(int(0)), 0x01));

                              body.emit(assign(r3E7C, less(r3E8F, body.constant(0u)), 0x01));


                           body.instructions = f3E8B_parent_instructions;
                           body.emit(f3E8B);

                           /* END IF */


                        body.instructions = f3E88_parent_instructions;
                        body.emit(f3E88);

                        /* END IF */


                     body.instructions = f3E7E_parent_instructions;
                     body.emit(f3E7E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f3EA7 = new(mem_ctx) ir_if(operand(r3E7A).val);
                     exec_list *const f3EA7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3EA7->then_instructions;

                        /* IF CONDITION */
                        ir_if *f3EA8 = new(mem_ctx) ir_if(operand(r3E7C).val);
                        exec_list *const f3EA8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3EA8->then_instructions;

                           ir_variable *const r3EA9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r3EA9, add(r3E78, body.constant(1u)), 0x01));

                           ir_expression *const r3EAA = less(r3EA9, r3E78);
                           ir_expression *const r3EAB = expr(ir_unop_b2i, r3EAA);
                           ir_expression *const r3EAC = expr(ir_unop_i2u, r3EAB);
                           body.emit(assign(r3E77, add(r3E77, r3EAC), 0x01));

                           ir_expression *const r3EAD = equal(r3E79, body.constant(0u));
                           ir_expression *const r3EAE = expr(ir_unop_b2i, r3EAD);
                           ir_expression *const r3EAF = expr(ir_unop_i2u, r3EAE);
                           ir_expression *const r3EB0 = add(r3E79, r3EAF);
                           ir_expression *const r3EB1 = bit_and(r3EB0, body.constant(1u));
                           ir_expression *const r3EB2 = expr(ir_unop_bit_not, r3EB1);
                           body.emit(assign(r3E78, bit_and(r3EA9, r3EB2), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3EA8->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3EB4 = bit_or(r3E77, r3E78);
                           ir_expression *const r3EB5 = equal(r3EB4, body.constant(0u));
                           ir_if *f3EB3 = new(mem_ctx) ir_if(operand(r3EB5).val);
                           exec_list *const f3EB3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EB3->then_instructions;

                              body.emit(assign(r3E76, body.constant(int(0)), 0x01));


                           body.instructions = f3EB3_parent_instructions;
                           body.emit(f3EB3);

                           /* END IF */


                        body.instructions = f3EA8_parent_instructions;
                        body.emit(f3EA8);

                        /* END IF */

                        ir_variable *const r3EB6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3EB6);
                        ir_expression *const r3EB7 = lshift(r3BBE, body.constant(int(31)));
                        ir_expression *const r3EB8 = expr(ir_unop_i2u, r3E76);
                        ir_expression *const r3EB9 = lshift(r3EB8, body.constant(int(20)));
                        ir_expression *const r3EBA = add(r3EB7, r3EB9);
                        body.emit(assign(r3EB6, add(r3EBA, r3E77), 0x02));

                        body.emit(assign(r3EB6, r3E78, 0x01));

                        body.emit(assign(r3E7B, r3EB6, 0x03));

                        body.emit(assign(r3E7A, body.constant(false), 0x01));


                     body.instructions = f3EA7_parent_instructions;
                     body.emit(f3EA7);

                     /* END IF */

                     body.emit(assign(r3BBF, r3E7B, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3E2F->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3EBC = less(r3BC4, r3BC6);
                     ir_if *f3EBB = new(mem_ctx) ir_if(operand(r3EBC).val);
                     exec_list *const f3EBB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3EBB->then_instructions;

                        ir_variable *const r3EBD = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r3EBE = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r3EBE, sub(r3BC6, r3BC4), 0x01));

                        ir_expression *const r3EBF = sub(r3BC5, r3BC3);
                        ir_expression *const r3EC0 = less(r3BC6, r3BC4);
                        ir_expression *const r3EC1 = expr(ir_unop_b2i, r3EC0);
                        ir_expression *const r3EC2 = expr(ir_unop_i2u, r3EC1);
                        body.emit(assign(r3EBD, sub(r3EBF, r3EC2), 0x01));

                        body.emit(assign(r3BC7, add(r3BC2, body.constant(int(-1))), 0x01));

                        ir_variable *const r3EC3 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r3EC3, add(r3BC7, body.constant(int(-10))), 0x01));

                        ir_variable *const r3EC4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r3EC4, r3EBD, 0x01));

                        ir_variable *const r3EC5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r3EC5, r3EBE, 0x01));

                        ir_variable *const r3EC6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r3EC6);
                        ir_variable *const r3EC7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r3EC7);
                        /* IF CONDITION */
                        ir_expression *const r3EC9 = equal(r3EBD, body.constant(0u));
                        ir_if *f3EC8 = new(mem_ctx) ir_if(operand(r3EC9).val);
                        exec_list *const f3EC8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3EC8->then_instructions;

                           body.emit(assign(r3EC4, r3EBE, 0x01));

                           body.emit(assign(r3EC5, body.constant(0u), 0x01));

                           body.emit(assign(r3EC3, add(r3EC3, body.constant(int(-32))), 0x01));


                        body.instructions = f3EC8_parent_instructions;
                        body.emit(f3EC8);

                        /* END IF */

                        ir_variable *const r3ECA = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r3ECA, r3EC4, 0x01));

                        ir_variable *const r3ECB = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r3ECC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r3ECC);
                        /* IF CONDITION */
                        ir_expression *const r3ECE = equal(r3EC4, body.constant(0u));
                        ir_if *f3ECD = new(mem_ctx) ir_if(operand(r3ECE).val);
                        exec_list *const f3ECD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3ECD->then_instructions;

                           body.emit(assign(r3ECB, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3ECD->else_instructions;

                           body.emit(assign(r3ECC, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3ED0 = bit_and(r3EC4, body.constant(4294901760u));
                           ir_expression *const r3ED1 = equal(r3ED0, body.constant(0u));
                           ir_if *f3ECF = new(mem_ctx) ir_if(operand(r3ED1).val);
                           exec_list *const f3ECF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3ECF->then_instructions;

                              body.emit(assign(r3ECC, body.constant(int(16)), 0x01));

                              body.emit(assign(r3ECA, lshift(r3EC4, body.constant(int(16))), 0x01));


                           body.instructions = f3ECF_parent_instructions;
                           body.emit(f3ECF);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3ED3 = bit_and(r3ECA, body.constant(4278190080u));
                           ir_expression *const r3ED4 = equal(r3ED3, body.constant(0u));
                           ir_if *f3ED2 = new(mem_ctx) ir_if(operand(r3ED4).val);
                           exec_list *const f3ED2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3ED2->then_instructions;

                              body.emit(assign(r3ECC, add(r3ECC, body.constant(int(8))), 0x01));

                              body.emit(assign(r3ECA, lshift(r3ECA, body.constant(int(8))), 0x01));


                           body.instructions = f3ED2_parent_instructions;
                           body.emit(f3ED2);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3ED6 = bit_and(r3ECA, body.constant(4026531840u));
                           ir_expression *const r3ED7 = equal(r3ED6, body.constant(0u));
                           ir_if *f3ED5 = new(mem_ctx) ir_if(operand(r3ED7).val);
                           exec_list *const f3ED5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3ED5->then_instructions;

                              body.emit(assign(r3ECC, add(r3ECC, body.constant(int(4))), 0x01));

                              body.emit(assign(r3ECA, lshift(r3ECA, body.constant(int(4))), 0x01));


                           body.instructions = f3ED5_parent_instructions;
                           body.emit(f3ED5);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3ED9 = bit_and(r3ECA, body.constant(3221225472u));
                           ir_expression *const r3EDA = equal(r3ED9, body.constant(0u));
                           ir_if *f3ED8 = new(mem_ctx) ir_if(operand(r3EDA).val);
                           exec_list *const f3ED8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3ED8->then_instructions;

                              body.emit(assign(r3ECC, add(r3ECC, body.constant(int(2))), 0x01));

                              body.emit(assign(r3ECA, lshift(r3ECA, body.constant(int(2))), 0x01));


                           body.instructions = f3ED8_parent_instructions;
                           body.emit(f3ED8);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3EDC = bit_and(r3ECA, body.constant(2147483648u));
                           ir_expression *const r3EDD = equal(r3EDC, body.constant(0u));
                           ir_if *f3EDB = new(mem_ctx) ir_if(operand(r3EDD).val);
                           exec_list *const f3EDB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EDB->then_instructions;

                              body.emit(assign(r3ECC, add(r3ECC, body.constant(int(1))), 0x01));


                           body.instructions = f3EDB_parent_instructions;
                           body.emit(f3EDB);

                           /* END IF */

                           body.emit(assign(r3ECB, r3ECC, 0x01));


                        body.instructions = f3ECD_parent_instructions;
                        body.emit(f3ECD);

                        /* END IF */

                        body.emit(assign(r3EC7, add(r3ECB, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3EDF = lequal(body.constant(int(0)), r3EC7);
                        ir_if *f3EDE = new(mem_ctx) ir_if(operand(r3EDF).val);
                        exec_list *const f3EDE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3EDE->then_instructions;

                           body.emit(assign(r3EC6, body.constant(0u), 0x01));

                           ir_variable *const r3EE0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r3EE0, lshift(r3EC5, r3EC7), 0x01));

                           ir_variable *const r3EE1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3EE3 = equal(r3EC7, body.constant(int(0)));
                           ir_if *f3EE2 = new(mem_ctx) ir_if(operand(r3EE3).val);
                           exec_list *const f3EE2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EE2->then_instructions;

                              body.emit(assign(r3EE1, r3EC4, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3EE2->else_instructions;

                              ir_expression *const r3EE4 = lshift(r3EC4, r3EC7);
                              ir_expression *const r3EE5 = neg(r3EC7);
                              ir_expression *const r3EE6 = bit_and(r3EE5, body.constant(int(31)));
                              ir_expression *const r3EE7 = rshift(r3EC5, r3EE6);
                              body.emit(assign(r3EE1, bit_or(r3EE4, r3EE7), 0x01));


                           body.instructions = f3EE2_parent_instructions;
                           body.emit(f3EE2);

                           /* END IF */

                           body.emit(assign(r3EC4, r3EE1, 0x01));

                           body.emit(assign(r3EC5, r3EE0, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3EDE->else_instructions;

                           ir_variable *const r3EE8 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3EE8, body.constant(0u), 0x01));

                           ir_variable *const r3EE9 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3EE9, neg(r3EC7), 0x01));

                           ir_variable *const r3EEA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3EEA);
                           ir_variable *const r3EEB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3EEB);
                           ir_variable *const r3EEC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3EEC);
                           ir_variable *const r3EED = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r3EEE = neg(r3EE9);
                           body.emit(assign(r3EED, bit_and(r3EEE, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3EF0 = equal(r3EE9, body.constant(int(0)));
                           ir_if *f3EEF = new(mem_ctx) ir_if(operand(r3EF0).val);
                           exec_list *const f3EEF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EEF->then_instructions;

                              body.emit(assign(r3EEA, r3EE8, 0x01));

                              body.emit(assign(r3EEB, r3EC5, 0x01));

                              body.emit(assign(r3EEC, r3EC4, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3EEF->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3EF2 = less(r3EE9, body.constant(int(32)));
                              ir_if *f3EF1 = new(mem_ctx) ir_if(operand(r3EF2).val);
                              exec_list *const f3EF1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3EF1->then_instructions;

                                 body.emit(assign(r3EEA, lshift(r3EC5, r3EED), 0x01));

                                 ir_expression *const r3EF3 = lshift(r3EC4, r3EED);
                                 ir_expression *const r3EF4 = rshift(r3EC5, r3EE9);
                                 body.emit(assign(r3EEB, bit_or(r3EF3, r3EF4), 0x01));

                                 body.emit(assign(r3EEC, rshift(r3EC4, r3EE9), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3EF1->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3EF6 = equal(r3EE9, body.constant(int(32)));
                                 ir_if *f3EF5 = new(mem_ctx) ir_if(operand(r3EF6).val);
                                 exec_list *const f3EF5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3EF5->then_instructions;

                                    body.emit(assign(r3EEA, r3EC5, 0x01));

                                    body.emit(assign(r3EEB, r3EC4, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3EF5->else_instructions;

                                    body.emit(assign(r3EE8, bit_or(body.constant(0u), r3EC5), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3EF8 = less(r3EE9, body.constant(int(64)));
                                    ir_if *f3EF7 = new(mem_ctx) ir_if(operand(r3EF8).val);
                                    exec_list *const f3EF7_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3EF7->then_instructions;

                                       body.emit(assign(r3EEA, lshift(r3EC4, r3EED), 0x01));

                                       ir_expression *const r3EF9 = bit_and(r3EE9, body.constant(int(31)));
                                       body.emit(assign(r3EEB, rshift(r3EC4, r3EF9), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3EF7->else_instructions;

                                       ir_variable *const r3EFA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3EFC = equal(r3EE9, body.constant(int(64)));
                                       ir_if *f3EFB = new(mem_ctx) ir_if(operand(r3EFC).val);
                                       exec_list *const f3EFB_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3EFB->then_instructions;

                                          body.emit(assign(r3EFA, r3EC4, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3EFB->else_instructions;

                                          ir_expression *const r3EFD = nequal(r3EC4, body.constant(0u));
                                          ir_expression *const r3EFE = expr(ir_unop_b2i, r3EFD);
                                          body.emit(assign(r3EFA, expr(ir_unop_i2u, r3EFE), 0x01));


                                       body.instructions = f3EFB_parent_instructions;
                                       body.emit(f3EFB);

                                       /* END IF */

                                       body.emit(assign(r3EEA, r3EFA, 0x01));

                                       body.emit(assign(r3EEB, body.constant(0u), 0x01));


                                    body.instructions = f3EF7_parent_instructions;
                                    body.emit(f3EF7);

                                    /* END IF */


                                 body.instructions = f3EF5_parent_instructions;
                                 body.emit(f3EF5);

                                 /* END IF */

                                 body.emit(assign(r3EEC, body.constant(0u), 0x01));


                              body.instructions = f3EF1_parent_instructions;
                              body.emit(f3EF1);

                              /* END IF */

                              ir_expression *const r3EFF = nequal(r3EE8, body.constant(0u));
                              ir_expression *const r3F00 = expr(ir_unop_b2i, r3EFF);
                              ir_expression *const r3F01 = expr(ir_unop_i2u, r3F00);
                              body.emit(assign(r3EEA, bit_or(r3EEA, r3F01), 0x01));


                           body.instructions = f3EEF_parent_instructions;
                           body.emit(f3EEF);

                           /* END IF */

                           body.emit(assign(r3EC4, r3EEC, 0x01));

                           body.emit(assign(r3EC5, r3EEB, 0x01));

                           body.emit(assign(r3EC6, r3EEA, 0x01));


                        body.instructions = f3EDE_parent_instructions;
                        body.emit(f3EDE);

                        /* END IF */

                        body.emit(assign(r3EC3, sub(r3EC3, r3EC7), 0x01));

                        ir_variable *const r3F02 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r3F02, r3EC3, 0x01));

                        ir_variable *const r3F03 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r3F03, r3EC4, 0x01));

                        ir_variable *const r3F04 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r3F04, r3EC5, 0x01));

                        ir_variable *const r3F05 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r3F05, r3EC6, 0x01));

                        ir_variable *const r3F06 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r3F06, body.constant(true), 0x01));

                        ir_variable *const r3F07 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r3F08 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r3F08);
                        ir_expression *const r3F09 = expr(ir_unop_u2i, r3EC6);
                        body.emit(assign(r3F08, less(r3F09, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3F0B = lequal(body.constant(int(2045)), r3EC3);
                        ir_if *f3F0A = new(mem_ctx) ir_if(operand(r3F0B).val);
                        exec_list *const f3F0A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3F0A->then_instructions;

                           ir_variable *const r3F0C = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3F0E = less(body.constant(int(2045)), r3EC3);
                           ir_if *f3F0D = new(mem_ctx) ir_if(operand(r3F0E).val);
                           exec_list *const f3F0D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F0D->then_instructions;

                              body.emit(assign(r3F0C, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3F0D->else_instructions;

                              ir_variable *const r3F0F = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3F11 = equal(r3EC3, body.constant(int(2045)));
                              ir_if *f3F10 = new(mem_ctx) ir_if(operand(r3F11).val);
                              exec_list *const f3F10_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F10->then_instructions;

                                 ir_expression *const r3F12 = equal(body.constant(2097151u), r3EC4);
                                 ir_expression *const r3F13 = equal(body.constant(4294967295u), r3EC5);
                                 body.emit(assign(r3F0F, logic_and(r3F12, r3F13), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3F10->else_instructions;

                                 body.emit(assign(r3F0F, body.constant(false), 0x01));


                              body.instructions = f3F10_parent_instructions;
                              body.emit(f3F10);

                              /* END IF */

                              body.emit(assign(r3F0C, logic_and(r3F0F, r3F08), 0x01));


                           body.instructions = f3F0D_parent_instructions;
                           body.emit(f3F0D);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f3F14 = new(mem_ctx) ir_if(operand(r3F0C).val);
                           exec_list *const f3F14_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F14->then_instructions;

                              ir_variable *const r3F15 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3F15);
                              ir_expression *const r3F16 = lshift(r3BBE, body.constant(int(31)));
                              body.emit(assign(r3F15, add(r3F16, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r3F15, body.constant(0u), 0x01));

                              body.emit(assign(r3F07, r3F15, 0x03));

                              body.emit(assign(r3F06, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3F14->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3F18 = less(r3EC3, body.constant(int(0)));
                              ir_if *f3F17 = new(mem_ctx) ir_if(operand(r3F18).val);
                              exec_list *const f3F17_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F17->then_instructions;

                                 ir_variable *const r3F19 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r3F19, r3EC6, 0x01));

                                 ir_variable *const r3F1A = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r3F1A, neg(r3EC3), 0x01));

                                 ir_variable *const r3F1B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r3F1B);
                                 ir_variable *const r3F1C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r3F1C);
                                 ir_variable *const r3F1D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r3F1D);
                                 ir_variable *const r3F1E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r3F1F = neg(r3F1A);
                                 body.emit(assign(r3F1E, bit_and(r3F1F, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3F21 = equal(r3F1A, body.constant(int(0)));
                                 ir_if *f3F20 = new(mem_ctx) ir_if(operand(r3F21).val);
                                 exec_list *const f3F20_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3F20->then_instructions;

                                    body.emit(assign(r3F1B, r3EC6, 0x01));

                                    body.emit(assign(r3F1C, r3EC5, 0x01));

                                    body.emit(assign(r3F1D, r3EC4, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3F20->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3F23 = less(r3F1A, body.constant(int(32)));
                                    ir_if *f3F22 = new(mem_ctx) ir_if(operand(r3F23).val);
                                    exec_list *const f3F22_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3F22->then_instructions;

                                       body.emit(assign(r3F1B, lshift(r3EC5, r3F1E), 0x01));

                                       ir_expression *const r3F24 = lshift(r3EC4, r3F1E);
                                       ir_expression *const r3F25 = rshift(r3EC5, r3F1A);
                                       body.emit(assign(r3F1C, bit_or(r3F24, r3F25), 0x01));

                                       body.emit(assign(r3F1D, rshift(r3EC4, r3F1A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3F22->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r3F27 = equal(r3F1A, body.constant(int(32)));
                                       ir_if *f3F26 = new(mem_ctx) ir_if(operand(r3F27).val);
                                       exec_list *const f3F26_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3F26->then_instructions;

                                          body.emit(assign(r3F1B, r3EC5, 0x01));

                                          body.emit(assign(r3F1C, r3EC4, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3F26->else_instructions;

                                          body.emit(assign(r3F19, bit_or(r3EC6, r3EC5), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r3F29 = less(r3F1A, body.constant(int(64)));
                                          ir_if *f3F28 = new(mem_ctx) ir_if(operand(r3F29).val);
                                          exec_list *const f3F28_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3F28->then_instructions;

                                             body.emit(assign(r3F1B, lshift(r3EC4, r3F1E), 0x01));

                                             ir_expression *const r3F2A = bit_and(r3F1A, body.constant(int(31)));
                                             body.emit(assign(r3F1C, rshift(r3EC4, r3F2A), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3F28->else_instructions;

                                             ir_variable *const r3F2B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r3F2D = equal(r3F1A, body.constant(int(64)));
                                             ir_if *f3F2C = new(mem_ctx) ir_if(operand(r3F2D).val);
                                             exec_list *const f3F2C_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3F2C->then_instructions;

                                                body.emit(assign(r3F2B, r3EC4, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3F2C->else_instructions;

                                                ir_expression *const r3F2E = nequal(r3EC4, body.constant(0u));
                                                ir_expression *const r3F2F = expr(ir_unop_b2i, r3F2E);
                                                body.emit(assign(r3F2B, expr(ir_unop_i2u, r3F2F), 0x01));


                                             body.instructions = f3F2C_parent_instructions;
                                             body.emit(f3F2C);

                                             /* END IF */

                                             body.emit(assign(r3F1B, r3F2B, 0x01));

                                             body.emit(assign(r3F1C, body.constant(0u), 0x01));


                                          body.instructions = f3F28_parent_instructions;
                                          body.emit(f3F28);

                                          /* END IF */


                                       body.instructions = f3F26_parent_instructions;
                                       body.emit(f3F26);

                                       /* END IF */

                                       body.emit(assign(r3F1D, body.constant(0u), 0x01));


                                    body.instructions = f3F22_parent_instructions;
                                    body.emit(f3F22);

                                    /* END IF */

                                    ir_expression *const r3F30 = nequal(r3F19, body.constant(0u));
                                    ir_expression *const r3F31 = expr(ir_unop_b2i, r3F30);
                                    ir_expression *const r3F32 = expr(ir_unop_i2u, r3F31);
                                    body.emit(assign(r3F1B, bit_or(r3F1B, r3F32), 0x01));


                                 body.instructions = f3F20_parent_instructions;
                                 body.emit(f3F20);

                                 /* END IF */

                                 body.emit(assign(r3F03, r3F1D, 0x01));

                                 body.emit(assign(r3F04, r3F1C, 0x01));

                                 body.emit(assign(r3F05, r3F1B, 0x01));

                                 body.emit(assign(r3F02, body.constant(int(0)), 0x01));

                                 body.emit(assign(r3F08, less(r3F1B, body.constant(0u)), 0x01));


                              body.instructions = f3F17_parent_instructions;
                              body.emit(f3F17);

                              /* END IF */


                           body.instructions = f3F14_parent_instructions;
                           body.emit(f3F14);

                           /* END IF */


                        body.instructions = f3F0A_parent_instructions;
                        body.emit(f3F0A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f3F33 = new(mem_ctx) ir_if(operand(r3F06).val);
                        exec_list *const f3F33_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3F33->then_instructions;

                           /* IF CONDITION */
                           ir_if *f3F34 = new(mem_ctx) ir_if(operand(r3F08).val);
                           exec_list *const f3F34_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F34->then_instructions;

                              ir_variable *const r3F35 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r3F35, add(r3F04, body.constant(1u)), 0x01));

                              ir_expression *const r3F36 = less(r3F35, r3F04);
                              ir_expression *const r3F37 = expr(ir_unop_b2i, r3F36);
                              ir_expression *const r3F38 = expr(ir_unop_i2u, r3F37);
                              body.emit(assign(r3F03, add(r3F03, r3F38), 0x01));

                              ir_expression *const r3F39 = equal(r3F05, body.constant(0u));
                              ir_expression *const r3F3A = expr(ir_unop_b2i, r3F39);
                              ir_expression *const r3F3B = expr(ir_unop_i2u, r3F3A);
                              ir_expression *const r3F3C = add(r3F05, r3F3B);
                              ir_expression *const r3F3D = bit_and(r3F3C, body.constant(1u));
                              ir_expression *const r3F3E = expr(ir_unop_bit_not, r3F3D);
                              body.emit(assign(r3F04, bit_and(r3F35, r3F3E), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3F34->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3F40 = bit_or(r3F03, r3F04);
                              ir_expression *const r3F41 = equal(r3F40, body.constant(0u));
                              ir_if *f3F3F = new(mem_ctx) ir_if(operand(r3F41).val);
                              exec_list *const f3F3F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F3F->then_instructions;

                                 body.emit(assign(r3F02, body.constant(int(0)), 0x01));


                              body.instructions = f3F3F_parent_instructions;
                              body.emit(f3F3F);

                              /* END IF */


                           body.instructions = f3F34_parent_instructions;
                           body.emit(f3F34);

                           /* END IF */

                           ir_variable *const r3F42 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3F42);
                           ir_expression *const r3F43 = lshift(r3BBE, body.constant(int(31)));
                           ir_expression *const r3F44 = expr(ir_unop_i2u, r3F02);
                           ir_expression *const r3F45 = lshift(r3F44, body.constant(int(20)));
                           ir_expression *const r3F46 = add(r3F43, r3F45);
                           body.emit(assign(r3F42, add(r3F46, r3F03), 0x02));

                           body.emit(assign(r3F42, r3F04, 0x01));

                           body.emit(assign(r3F07, r3F42, 0x03));

                           body.emit(assign(r3F06, body.constant(false), 0x01));


                        body.instructions = f3F33_parent_instructions;
                        body.emit(f3F33);

                        /* END IF */

                        body.emit(assign(r3BBF, r3F07, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3EBB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3F48 = less(r3BC6, r3BC4);
                        ir_if *f3F47 = new(mem_ctx) ir_if(operand(r3F48).val);
                        exec_list *const f3F47_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3F47->then_instructions;

                           ir_variable *const r3F49 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r3F4A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r3F4A, sub(r3BC4, r3BC6), 0x01));

                           ir_expression *const r3F4B = sub(r3BC3, r3BC5);
                           ir_expression *const r3F4C = less(r3BC4, r3BC6);
                           ir_expression *const r3F4D = expr(ir_unop_b2i, r3F4C);
                           ir_expression *const r3F4E = expr(ir_unop_i2u, r3F4D);
                           body.emit(assign(r3F49, sub(r3F4B, r3F4E), 0x01));

                           body.emit(assign(r3BBE, bit_xor(r3BBE, body.constant(1u)), 0x01));

                           body.emit(assign(r3BC7, add(r3BC1, body.constant(int(-1))), 0x01));

                           ir_variable *const r3F4F = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r3F4F, add(r3BC7, body.constant(int(-10))), 0x01));

                           ir_variable *const r3F50 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r3F50, r3F49, 0x01));

                           ir_variable *const r3F51 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r3F51, r3F4A, 0x01));

                           ir_variable *const r3F52 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r3F52);
                           ir_variable *const r3F53 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r3F53);
                           /* IF CONDITION */
                           ir_expression *const r3F55 = equal(r3F49, body.constant(0u));
                           ir_if *f3F54 = new(mem_ctx) ir_if(operand(r3F55).val);
                           exec_list *const f3F54_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F54->then_instructions;

                              body.emit(assign(r3F50, r3F4A, 0x01));

                              body.emit(assign(r3F51, body.constant(0u), 0x01));

                              body.emit(assign(r3F4F, add(r3F4F, body.constant(int(-32))), 0x01));


                           body.instructions = f3F54_parent_instructions;
                           body.emit(f3F54);

                           /* END IF */

                           ir_variable *const r3F56 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r3F56, r3F50, 0x01));

                           ir_variable *const r3F57 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r3F58 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r3F58);
                           /* IF CONDITION */
                           ir_expression *const r3F5A = equal(r3F50, body.constant(0u));
                           ir_if *f3F59 = new(mem_ctx) ir_if(operand(r3F5A).val);
                           exec_list *const f3F59_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F59->then_instructions;

                              body.emit(assign(r3F57, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3F59->else_instructions;

                              body.emit(assign(r3F58, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3F5C = bit_and(r3F50, body.constant(4294901760u));
                              ir_expression *const r3F5D = equal(r3F5C, body.constant(0u));
                              ir_if *f3F5B = new(mem_ctx) ir_if(operand(r3F5D).val);
                              exec_list *const f3F5B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F5B->then_instructions;

                                 body.emit(assign(r3F58, body.constant(int(16)), 0x01));

                                 body.emit(assign(r3F56, lshift(r3F50, body.constant(int(16))), 0x01));


                              body.instructions = f3F5B_parent_instructions;
                              body.emit(f3F5B);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3F5F = bit_and(r3F56, body.constant(4278190080u));
                              ir_expression *const r3F60 = equal(r3F5F, body.constant(0u));
                              ir_if *f3F5E = new(mem_ctx) ir_if(operand(r3F60).val);
                              exec_list *const f3F5E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F5E->then_instructions;

                                 body.emit(assign(r3F58, add(r3F58, body.constant(int(8))), 0x01));

                                 body.emit(assign(r3F56, lshift(r3F56, body.constant(int(8))), 0x01));


                              body.instructions = f3F5E_parent_instructions;
                              body.emit(f3F5E);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3F62 = bit_and(r3F56, body.constant(4026531840u));
                              ir_expression *const r3F63 = equal(r3F62, body.constant(0u));
                              ir_if *f3F61 = new(mem_ctx) ir_if(operand(r3F63).val);
                              exec_list *const f3F61_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F61->then_instructions;

                                 body.emit(assign(r3F58, add(r3F58, body.constant(int(4))), 0x01));

                                 body.emit(assign(r3F56, lshift(r3F56, body.constant(int(4))), 0x01));


                              body.instructions = f3F61_parent_instructions;
                              body.emit(f3F61);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3F65 = bit_and(r3F56, body.constant(3221225472u));
                              ir_expression *const r3F66 = equal(r3F65, body.constant(0u));
                              ir_if *f3F64 = new(mem_ctx) ir_if(operand(r3F66).val);
                              exec_list *const f3F64_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F64->then_instructions;

                                 body.emit(assign(r3F58, add(r3F58, body.constant(int(2))), 0x01));

                                 body.emit(assign(r3F56, lshift(r3F56, body.constant(int(2))), 0x01));


                              body.instructions = f3F64_parent_instructions;
                              body.emit(f3F64);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3F68 = bit_and(r3F56, body.constant(2147483648u));
                              ir_expression *const r3F69 = equal(r3F68, body.constant(0u));
                              ir_if *f3F67 = new(mem_ctx) ir_if(operand(r3F69).val);
                              exec_list *const f3F67_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F67->then_instructions;

                                 body.emit(assign(r3F58, add(r3F58, body.constant(int(1))), 0x01));


                              body.instructions = f3F67_parent_instructions;
                              body.emit(f3F67);

                              /* END IF */

                              body.emit(assign(r3F57, r3F58, 0x01));


                           body.instructions = f3F59_parent_instructions;
                           body.emit(f3F59);

                           /* END IF */

                           body.emit(assign(r3F53, add(r3F57, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3F6B = lequal(body.constant(int(0)), r3F53);
                           ir_if *f3F6A = new(mem_ctx) ir_if(operand(r3F6B).val);
                           exec_list *const f3F6A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F6A->then_instructions;

                              body.emit(assign(r3F52, body.constant(0u), 0x01));

                              ir_variable *const r3F6C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r3F6C, lshift(r3F51, r3F53), 0x01));

                              ir_variable *const r3F6D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3F6F = equal(r3F53, body.constant(int(0)));
                              ir_if *f3F6E = new(mem_ctx) ir_if(operand(r3F6F).val);
                              exec_list *const f3F6E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F6E->then_instructions;

                                 body.emit(assign(r3F6D, r3F50, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3F6E->else_instructions;

                                 ir_expression *const r3F70 = lshift(r3F50, r3F53);
                                 ir_expression *const r3F71 = neg(r3F53);
                                 ir_expression *const r3F72 = bit_and(r3F71, body.constant(int(31)));
                                 ir_expression *const r3F73 = rshift(r3F51, r3F72);
                                 body.emit(assign(r3F6D, bit_or(r3F70, r3F73), 0x01));


                              body.instructions = f3F6E_parent_instructions;
                              body.emit(f3F6E);

                              /* END IF */

                              body.emit(assign(r3F50, r3F6D, 0x01));

                              body.emit(assign(r3F51, r3F6C, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3F6A->else_instructions;

                              ir_variable *const r3F74 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r3F74, body.constant(0u), 0x01));

                              ir_variable *const r3F75 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r3F75, neg(r3F53), 0x01));

                              ir_variable *const r3F76 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r3F76);
                              ir_variable *const r3F77 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r3F77);
                              ir_variable *const r3F78 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r3F78);
                              ir_variable *const r3F79 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r3F7A = neg(r3F75);
                              body.emit(assign(r3F79, bit_and(r3F7A, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3F7C = equal(r3F75, body.constant(int(0)));
                              ir_if *f3F7B = new(mem_ctx) ir_if(operand(r3F7C).val);
                              exec_list *const f3F7B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F7B->then_instructions;

                                 body.emit(assign(r3F76, r3F74, 0x01));

                                 body.emit(assign(r3F77, r3F51, 0x01));

                                 body.emit(assign(r3F78, r3F50, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3F7B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3F7E = less(r3F75, body.constant(int(32)));
                                 ir_if *f3F7D = new(mem_ctx) ir_if(operand(r3F7E).val);
                                 exec_list *const f3F7D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3F7D->then_instructions;

                                    body.emit(assign(r3F76, lshift(r3F51, r3F79), 0x01));

                                    ir_expression *const r3F7F = lshift(r3F50, r3F79);
                                    ir_expression *const r3F80 = rshift(r3F51, r3F75);
                                    body.emit(assign(r3F77, bit_or(r3F7F, r3F80), 0x01));

                                    body.emit(assign(r3F78, rshift(r3F50, r3F75), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3F7D->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3F82 = equal(r3F75, body.constant(int(32)));
                                    ir_if *f3F81 = new(mem_ctx) ir_if(operand(r3F82).val);
                                    exec_list *const f3F81_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3F81->then_instructions;

                                       body.emit(assign(r3F76, r3F51, 0x01));

                                       body.emit(assign(r3F77, r3F50, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3F81->else_instructions;

                                       body.emit(assign(r3F74, bit_or(body.constant(0u), r3F51), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r3F84 = less(r3F75, body.constant(int(64)));
                                       ir_if *f3F83 = new(mem_ctx) ir_if(operand(r3F84).val);
                                       exec_list *const f3F83_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3F83->then_instructions;

                                          body.emit(assign(r3F76, lshift(r3F50, r3F79), 0x01));

                                          ir_expression *const r3F85 = bit_and(r3F75, body.constant(int(31)));
                                          body.emit(assign(r3F77, rshift(r3F50, r3F85), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3F83->else_instructions;

                                          ir_variable *const r3F86 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3F88 = equal(r3F75, body.constant(int(64)));
                                          ir_if *f3F87 = new(mem_ctx) ir_if(operand(r3F88).val);
                                          exec_list *const f3F87_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3F87->then_instructions;

                                             body.emit(assign(r3F86, r3F50, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3F87->else_instructions;

                                             ir_expression *const r3F89 = nequal(r3F50, body.constant(0u));
                                             ir_expression *const r3F8A = expr(ir_unop_b2i, r3F89);
                                             body.emit(assign(r3F86, expr(ir_unop_i2u, r3F8A), 0x01));


                                          body.instructions = f3F87_parent_instructions;
                                          body.emit(f3F87);

                                          /* END IF */

                                          body.emit(assign(r3F76, r3F86, 0x01));

                                          body.emit(assign(r3F77, body.constant(0u), 0x01));


                                       body.instructions = f3F83_parent_instructions;
                                       body.emit(f3F83);

                                       /* END IF */


                                    body.instructions = f3F81_parent_instructions;
                                    body.emit(f3F81);

                                    /* END IF */

                                    body.emit(assign(r3F78, body.constant(0u), 0x01));


                                 body.instructions = f3F7D_parent_instructions;
                                 body.emit(f3F7D);

                                 /* END IF */

                                 ir_expression *const r3F8B = nequal(r3F74, body.constant(0u));
                                 ir_expression *const r3F8C = expr(ir_unop_b2i, r3F8B);
                                 ir_expression *const r3F8D = expr(ir_unop_i2u, r3F8C);
                                 body.emit(assign(r3F76, bit_or(r3F76, r3F8D), 0x01));


                              body.instructions = f3F7B_parent_instructions;
                              body.emit(f3F7B);

                              /* END IF */

                              body.emit(assign(r3F50, r3F78, 0x01));

                              body.emit(assign(r3F51, r3F77, 0x01));

                              body.emit(assign(r3F52, r3F76, 0x01));


                           body.instructions = f3F6A_parent_instructions;
                           body.emit(f3F6A);

                           /* END IF */

                           body.emit(assign(r3F4F, sub(r3F4F, r3F53), 0x01));

                           ir_variable *const r3F8E = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r3F8E, r3F4F, 0x01));

                           ir_variable *const r3F8F = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r3F8F, r3F50, 0x01));

                           ir_variable *const r3F90 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r3F90, r3F51, 0x01));

                           ir_variable *const r3F91 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r3F91, r3F52, 0x01));

                           ir_variable *const r3F92 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r3F92, body.constant(true), 0x01));

                           ir_variable *const r3F93 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r3F94 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r3F94);
                           ir_expression *const r3F95 = expr(ir_unop_u2i, r3F52);
                           body.emit(assign(r3F94, less(r3F95, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3F97 = lequal(body.constant(int(2045)), r3F4F);
                           ir_if *f3F96 = new(mem_ctx) ir_if(operand(r3F97).val);
                           exec_list *const f3F96_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F96->then_instructions;

                              ir_variable *const r3F98 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3F9A = less(body.constant(int(2045)), r3F4F);
                              ir_if *f3F99 = new(mem_ctx) ir_if(operand(r3F9A).val);
                              exec_list *const f3F99_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F99->then_instructions;

                                 body.emit(assign(r3F98, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3F99->else_instructions;

                                 ir_variable *const r3F9B = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3F9D = equal(r3F4F, body.constant(int(2045)));
                                 ir_if *f3F9C = new(mem_ctx) ir_if(operand(r3F9D).val);
                                 exec_list *const f3F9C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3F9C->then_instructions;

                                    ir_expression *const r3F9E = equal(body.constant(2097151u), r3F50);
                                    ir_expression *const r3F9F = equal(body.constant(4294967295u), r3F51);
                                    body.emit(assign(r3F9B, logic_and(r3F9E, r3F9F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3F9C->else_instructions;

                                    body.emit(assign(r3F9B, body.constant(false), 0x01));


                                 body.instructions = f3F9C_parent_instructions;
                                 body.emit(f3F9C);

                                 /* END IF */

                                 body.emit(assign(r3F98, logic_and(r3F9B, r3F94), 0x01));


                              body.instructions = f3F99_parent_instructions;
                              body.emit(f3F99);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f3FA0 = new(mem_ctx) ir_if(operand(r3F98).val);
                              exec_list *const f3FA0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3FA0->then_instructions;

                                 ir_variable *const r3FA1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r3FA1);
                                 ir_expression *const r3FA2 = lshift(r3BBE, body.constant(int(31)));
                                 body.emit(assign(r3FA1, add(r3FA2, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r3FA1, body.constant(0u), 0x01));

                                 body.emit(assign(r3F93, r3FA1, 0x03));

                                 body.emit(assign(r3F92, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3FA0->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3FA4 = less(r3F4F, body.constant(int(0)));
                                 ir_if *f3FA3 = new(mem_ctx) ir_if(operand(r3FA4).val);
                                 exec_list *const f3FA3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3FA3->then_instructions;

                                    ir_variable *const r3FA5 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r3FA5, r3F52, 0x01));

                                    ir_variable *const r3FA6 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r3FA6, neg(r3F4F), 0x01));

                                    ir_variable *const r3FA7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r3FA7);
                                    ir_variable *const r3FA8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r3FA8);
                                    ir_variable *const r3FA9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r3FA9);
                                    ir_variable *const r3FAA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r3FAB = neg(r3FA6);
                                    body.emit(assign(r3FAA, bit_and(r3FAB, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3FAD = equal(r3FA6, body.constant(int(0)));
                                    ir_if *f3FAC = new(mem_ctx) ir_if(operand(r3FAD).val);
                                    exec_list *const f3FAC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3FAC->then_instructions;

                                       body.emit(assign(r3FA7, r3F52, 0x01));

                                       body.emit(assign(r3FA8, r3F51, 0x01));

                                       body.emit(assign(r3FA9, r3F50, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3FAC->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r3FAF = less(r3FA6, body.constant(int(32)));
                                       ir_if *f3FAE = new(mem_ctx) ir_if(operand(r3FAF).val);
                                       exec_list *const f3FAE_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3FAE->then_instructions;

                                          body.emit(assign(r3FA7, lshift(r3F51, r3FAA), 0x01));

                                          ir_expression *const r3FB0 = lshift(r3F50, r3FAA);
                                          ir_expression *const r3FB1 = rshift(r3F51, r3FA6);
                                          body.emit(assign(r3FA8, bit_or(r3FB0, r3FB1), 0x01));

                                          body.emit(assign(r3FA9, rshift(r3F50, r3FA6), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3FAE->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r3FB3 = equal(r3FA6, body.constant(int(32)));
                                          ir_if *f3FB2 = new(mem_ctx) ir_if(operand(r3FB3).val);
                                          exec_list *const f3FB2_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3FB2->then_instructions;

                                             body.emit(assign(r3FA7, r3F51, 0x01));

                                             body.emit(assign(r3FA8, r3F50, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3FB2->else_instructions;

                                             body.emit(assign(r3FA5, bit_or(r3F52, r3F51), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r3FB5 = less(r3FA6, body.constant(int(64)));
                                             ir_if *f3FB4 = new(mem_ctx) ir_if(operand(r3FB5).val);
                                             exec_list *const f3FB4_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3FB4->then_instructions;

                                                body.emit(assign(r3FA7, lshift(r3F50, r3FAA), 0x01));

                                                ir_expression *const r3FB6 = bit_and(r3FA6, body.constant(int(31)));
                                                body.emit(assign(r3FA8, rshift(r3F50, r3FB6), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3FB4->else_instructions;

                                                ir_variable *const r3FB7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r3FB9 = equal(r3FA6, body.constant(int(64)));
                                                ir_if *f3FB8 = new(mem_ctx) ir_if(operand(r3FB9).val);
                                                exec_list *const f3FB8_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f3FB8->then_instructions;

                                                   body.emit(assign(r3FB7, r3F50, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f3FB8->else_instructions;

                                                   ir_expression *const r3FBA = nequal(r3F50, body.constant(0u));
                                                   ir_expression *const r3FBB = expr(ir_unop_b2i, r3FBA);
                                                   body.emit(assign(r3FB7, expr(ir_unop_i2u, r3FBB), 0x01));


                                                body.instructions = f3FB8_parent_instructions;
                                                body.emit(f3FB8);

                                                /* END IF */

                                                body.emit(assign(r3FA7, r3FB7, 0x01));

                                                body.emit(assign(r3FA8, body.constant(0u), 0x01));


                                             body.instructions = f3FB4_parent_instructions;
                                             body.emit(f3FB4);

                                             /* END IF */


                                          body.instructions = f3FB2_parent_instructions;
                                          body.emit(f3FB2);

                                          /* END IF */

                                          body.emit(assign(r3FA9, body.constant(0u), 0x01));


                                       body.instructions = f3FAE_parent_instructions;
                                       body.emit(f3FAE);

                                       /* END IF */

                                       ir_expression *const r3FBC = nequal(r3FA5, body.constant(0u));
                                       ir_expression *const r3FBD = expr(ir_unop_b2i, r3FBC);
                                       ir_expression *const r3FBE = expr(ir_unop_i2u, r3FBD);
                                       body.emit(assign(r3FA7, bit_or(r3FA7, r3FBE), 0x01));


                                    body.instructions = f3FAC_parent_instructions;
                                    body.emit(f3FAC);

                                    /* END IF */

                                    body.emit(assign(r3F8F, r3FA9, 0x01));

                                    body.emit(assign(r3F90, r3FA8, 0x01));

                                    body.emit(assign(r3F91, r3FA7, 0x01));

                                    body.emit(assign(r3F8E, body.constant(int(0)), 0x01));

                                    body.emit(assign(r3F94, less(r3FA7, body.constant(0u)), 0x01));


                                 body.instructions = f3FA3_parent_instructions;
                                 body.emit(f3FA3);

                                 /* END IF */


                              body.instructions = f3FA0_parent_instructions;
                              body.emit(f3FA0);

                              /* END IF */


                           body.instructions = f3F96_parent_instructions;
                           body.emit(f3F96);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f3FBF = new(mem_ctx) ir_if(operand(r3F92).val);
                           exec_list *const f3FBF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3FBF->then_instructions;

                              /* IF CONDITION */
                              ir_if *f3FC0 = new(mem_ctx) ir_if(operand(r3F94).val);
                              exec_list *const f3FC0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3FC0->then_instructions;

                                 ir_variable *const r3FC1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r3FC1, add(r3F90, body.constant(1u)), 0x01));

                                 ir_expression *const r3FC2 = less(r3FC1, r3F90);
                                 ir_expression *const r3FC3 = expr(ir_unop_b2i, r3FC2);
                                 ir_expression *const r3FC4 = expr(ir_unop_i2u, r3FC3);
                                 body.emit(assign(r3F8F, add(r3F8F, r3FC4), 0x01));

                                 ir_expression *const r3FC5 = equal(r3F91, body.constant(0u));
                                 ir_expression *const r3FC6 = expr(ir_unop_b2i, r3FC5);
                                 ir_expression *const r3FC7 = expr(ir_unop_i2u, r3FC6);
                                 ir_expression *const r3FC8 = add(r3F91, r3FC7);
                                 ir_expression *const r3FC9 = bit_and(r3FC8, body.constant(1u));
                                 ir_expression *const r3FCA = expr(ir_unop_bit_not, r3FC9);
                                 body.emit(assign(r3F90, bit_and(r3FC1, r3FCA), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3FC0->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3FCC = bit_or(r3F8F, r3F90);
                                 ir_expression *const r3FCD = equal(r3FCC, body.constant(0u));
                                 ir_if *f3FCB = new(mem_ctx) ir_if(operand(r3FCD).val);
                                 exec_list *const f3FCB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3FCB->then_instructions;

                                    body.emit(assign(r3F8E, body.constant(int(0)), 0x01));


                                 body.instructions = f3FCB_parent_instructions;
                                 body.emit(f3FCB);

                                 /* END IF */


                              body.instructions = f3FC0_parent_instructions;
                              body.emit(f3FC0);

                              /* END IF */

                              ir_variable *const r3FCE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3FCE);
                              ir_expression *const r3FCF = lshift(r3BBE, body.constant(int(31)));
                              ir_expression *const r3FD0 = expr(ir_unop_i2u, r3F8E);
                              ir_expression *const r3FD1 = lshift(r3FD0, body.constant(int(20)));
                              ir_expression *const r3FD2 = add(r3FCF, r3FD1);
                              body.emit(assign(r3FCE, add(r3FD2, r3F8F), 0x02));

                              body.emit(assign(r3FCE, r3F90, 0x01));

                              body.emit(assign(r3F93, r3FCE, 0x03));

                              body.emit(assign(r3F92, body.constant(false), 0x01));


                           body.instructions = f3FBF_parent_instructions;
                           body.emit(f3FBF);

                           /* END IF */

                           body.emit(assign(r3BBF, r3F93, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3F47->else_instructions;

                           ir_variable *const r3FD3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3FD3);
                           body.emit(assign(r3FD3, body.constant(0u), 0x02));

                           body.emit(assign(r3FD3, body.constant(0u), 0x01));

                           body.emit(assign(r3BBF, r3FD3, 0x03));


                        body.instructions = f3F47_parent_instructions;
                        body.emit(f3F47);

                        /* END IF */


                     body.instructions = f3EBB_parent_instructions;
                     body.emit(f3EBB);

                     /* END IF */


                  body.instructions = f3E2F_parent_instructions;
                  body.emit(f3E2F);

                  /* END IF */


               body.instructions = f3DA3_parent_instructions;
               body.emit(f3DA3);

               /* END IF */


            body.instructions = f3D7C_parent_instructions;
            body.emit(f3D7C);

            /* END IF */


         body.instructions = f3CA8_parent_instructions;
         body.emit(f3CA8);

         /* END IF */


      body.instructions = f3BD8_parent_instructions;
      body.emit(f3BD8);

      /* END IF */

      body.emit(assign(r3BB9, r3BBF, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f3BBC->else_instructions;

      ir_variable *const r3FD4 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r3FD4, body.constant(true), 0x01));

      ir_variable *const r3FD5 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r3FD6 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r3FD6);
      ir_variable *const r3FD7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r3FD7);
      ir_variable *const r3FD8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r3FD8);
      ir_variable *const r3FD9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r3FD9);
      ir_variable *const r3FDA = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r3FDA);
      ir_variable *const r3FDB = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r3FDB);
      ir_variable *const r3FDC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r3FDC);
      ir_variable *const r3FDD = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r3FDD);
      body.emit(assign(r3FDD, body.constant(0u), 0x01));

      body.emit(assign(r3FDC, body.constant(0u), 0x01));

      ir_variable *const r3FDE = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r3FDE, swizzle_x(r3247), 0x01));

      body.emit(assign(r3FDA, r3FDE, 0x01));

      ir_variable *const r3FDF = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r3FDF, bit_and(swizzle_y(r3247), body.constant(1048575u)), 0x01));

      body.emit(assign(r3FD9, r3FDF, 0x01));

      ir_variable *const r3FE0 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r3FE0, swizzle_x(r3A07), 0x01));

      body.emit(assign(r3FD8, r3FE0, 0x01));

      ir_variable *const r3FE1 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r3FE1, bit_and(swizzle_y(r3A07), body.constant(1048575u)), 0x01));

      body.emit(assign(r3FD7, r3FE1, 0x01));

      ir_variable *const r3FE2 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3FE3 = rshift(swizzle_y(r3247), body.constant(int(20)));
      ir_expression *const r3FE4 = bit_and(r3FE3, body.constant(2047u));
      body.emit(assign(r3FE2, expr(ir_unop_u2i, r3FE4), 0x01));

      ir_variable *const r3FE5 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3FE6 = rshift(swizzle_y(r3A07), body.constant(int(20)));
      ir_expression *const r3FE7 = bit_and(r3FE6, body.constant(2047u));
      body.emit(assign(r3FE5, expr(ir_unop_u2i, r3FE7), 0x01));

      ir_variable *const r3FE8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r3FE8, sub(r3FE2, r3FE5), 0x01));

      body.emit(assign(r3FD6, r3FE8, 0x01));

      /* IF CONDITION */
      ir_expression *const r3FEA = less(body.constant(int(0)), r3FE8);
      ir_if *f3FE9 = new(mem_ctx) ir_if(operand(r3FEA).val);
      exec_list *const f3FE9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3FE9->then_instructions;

         /* IF CONDITION */
         ir_expression *const r3FEC = equal(r3FE2, body.constant(int(2047)));
         ir_if *f3FEB = new(mem_ctx) ir_if(operand(r3FEC).val);
         exec_list *const f3FEB_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3FEB->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3FEE = bit_or(r3FDF, swizzle_x(r3247));
            ir_expression *const r3FEF = nequal(r3FEE, body.constant(0u));
            ir_if *f3FED = new(mem_ctx) ir_if(operand(r3FEF).val);
            exec_list *const f3FED_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3FED->then_instructions;

               ir_variable *const r3FF0 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r3FF0, swizzle_x(r3247), 0x01));

               ir_variable *const r3FF1 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r3FF1, swizzle_x(r3A07), 0x01));

               ir_variable *const r3FF2 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3FF3 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r3FF4 = rshift(swizzle_y(r3247), body.constant(int(19)));
               ir_expression *const r3FF5 = bit_and(r3FF4, body.constant(4095u));
               ir_expression *const r3FF6 = equal(r3FF5, body.constant(4094u));
               ir_expression *const r3FF7 = nequal(swizzle_x(r3247), body.constant(0u));
               ir_expression *const r3FF8 = bit_and(swizzle_y(r3247), body.constant(524287u));
               ir_expression *const r3FF9 = nequal(r3FF8, body.constant(0u));
               ir_expression *const r3FFA = logic_or(r3FF7, r3FF9);
               body.emit(assign(r3FF3, logic_and(r3FF6, r3FFA), 0x01));

               ir_variable *const r3FFB = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r3FFC = lshift(swizzle_y(r3A07), body.constant(int(1)));
               ir_expression *const r3FFD = lequal(body.constant(4292870144u), r3FFC);
               ir_expression *const r3FFE = nequal(swizzle_x(r3A07), body.constant(0u));
               ir_expression *const r3FFF = bit_and(swizzle_y(r3A07), body.constant(1048575u));
               ir_expression *const r4000 = nequal(r3FFF, body.constant(0u));
               ir_expression *const r4001 = logic_or(r3FFE, r4000);
               body.emit(assign(r3FFB, logic_and(r3FFD, r4001), 0x01));

               body.emit(assign(r3FF0, bit_or(swizzle_y(r3247), body.constant(524288u)), 0x02));

               body.emit(assign(r3FF1, bit_or(swizzle_y(r3A07), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r4003 = lshift(swizzle_y(r3247), body.constant(int(1)));
               ir_expression *const r4004 = lequal(body.constant(4292870144u), r4003);
               ir_expression *const r4005 = nequal(swizzle_x(r3247), body.constant(0u));
               ir_expression *const r4006 = bit_and(swizzle_y(r3247), body.constant(1048575u));
               ir_expression *const r4007 = nequal(r4006, body.constant(0u));
               ir_expression *const r4008 = logic_or(r4005, r4007);
               ir_expression *const r4009 = logic_and(r4004, r4008);
               ir_if *f4002 = new(mem_ctx) ir_if(operand(r4009).val);
               exec_list *const f4002_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4002->then_instructions;

                  ir_variable *const r400A = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r400C = logic_and(r3FF3, r3FFB);
                  ir_if *f400B = new(mem_ctx) ir_if(operand(r400C).val);
                  exec_list *const f400B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f400B->then_instructions;

                     body.emit(assign(r400A, r3FF1, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f400B->else_instructions;

                     body.emit(assign(r400A, r3FF0, 0x03));


                  body.instructions = f400B_parent_instructions;
                  body.emit(f400B);

                  /* END IF */

                  body.emit(assign(r3FF2, r400A, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4002->else_instructions;

                  body.emit(assign(r3FF2, r3FF1, 0x03));


               body.instructions = f4002_parent_instructions;
               body.emit(f4002);

               /* END IF */

               body.emit(assign(r3FD5, r3FF2, 0x03));

               body.emit(assign(r3FD4, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3FED->else_instructions;

               body.emit(assign(r3FD5, r3247, 0x03));

               body.emit(assign(r3FD4, body.constant(false), 0x01));


            body.instructions = f3FED_parent_instructions;
            body.emit(f3FED);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3FEB->else_instructions;

            /* IF CONDITION */
            ir_expression *const r400E = equal(r3FE5, body.constant(int(0)));
            ir_if *f400D = new(mem_ctx) ir_if(operand(r400E).val);
            exec_list *const f400D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f400D->then_instructions;

               body.emit(assign(r3FD6, add(r3FE8, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f400D->else_instructions;

               body.emit(assign(r3FD7, bit_or(r3FE1, body.constant(1048576u)), 0x01));


            body.instructions = f400D_parent_instructions;
            body.emit(f400D);

            /* END IF */

            ir_variable *const r400F = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r400F, body.constant(0u), 0x01));

            ir_variable *const r4010 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r4010);
            ir_variable *const r4011 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r4011);
            ir_variable *const r4012 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r4012);
            ir_variable *const r4013 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r4014 = neg(r3FD6);
            body.emit(assign(r4013, bit_and(r4014, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r4016 = equal(r3FD6, body.constant(int(0)));
            ir_if *f4015 = new(mem_ctx) ir_if(operand(r4016).val);
            exec_list *const f4015_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f4015->then_instructions;

               body.emit(assign(r4010, r400F, 0x01));

               body.emit(assign(r4011, r3FE0, 0x01));

               body.emit(assign(r4012, r3FD7, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f4015->else_instructions;

               /* IF CONDITION */
               ir_expression *const r4018 = less(r3FD6, body.constant(int(32)));
               ir_if *f4017 = new(mem_ctx) ir_if(operand(r4018).val);
               exec_list *const f4017_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4017->then_instructions;

                  body.emit(assign(r4010, lshift(swizzle_x(r3A07), r4013), 0x01));

                  ir_expression *const r4019 = lshift(r3FD7, r4013);
                  ir_expression *const r401A = rshift(swizzle_x(r3A07), r3FD6);
                  body.emit(assign(r4011, bit_or(r4019, r401A), 0x01));

                  body.emit(assign(r4012, rshift(r3FD7, r3FD6), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4017->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r401C = equal(r3FD6, body.constant(int(32)));
                  ir_if *f401B = new(mem_ctx) ir_if(operand(r401C).val);
                  exec_list *const f401B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f401B->then_instructions;

                     body.emit(assign(r4010, r3FE0, 0x01));

                     body.emit(assign(r4011, r3FD7, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f401B->else_instructions;

                     body.emit(assign(r400F, bit_or(body.constant(0u), swizzle_x(r3A07)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r401E = less(r3FD6, body.constant(int(64)));
                     ir_if *f401D = new(mem_ctx) ir_if(operand(r401E).val);
                     exec_list *const f401D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f401D->then_instructions;

                        body.emit(assign(r4010, lshift(r3FD7, r4013), 0x01));

                        ir_expression *const r401F = bit_and(r3FD6, body.constant(int(31)));
                        body.emit(assign(r4011, rshift(r3FD7, r401F), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f401D->else_instructions;

                        ir_variable *const r4020 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r4022 = equal(r3FD6, body.constant(int(64)));
                        ir_if *f4021 = new(mem_ctx) ir_if(operand(r4022).val);
                        exec_list *const f4021_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f4021->then_instructions;

                           body.emit(assign(r4020, r3FD7, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f4021->else_instructions;

                           ir_expression *const r4023 = nequal(r3FD7, body.constant(0u));
                           ir_expression *const r4024 = expr(ir_unop_b2i, r4023);
                           body.emit(assign(r4020, expr(ir_unop_i2u, r4024), 0x01));


                        body.instructions = f4021_parent_instructions;
                        body.emit(f4021);

                        /* END IF */

                        body.emit(assign(r4010, r4020, 0x01));

                        body.emit(assign(r4011, body.constant(0u), 0x01));


                     body.instructions = f401D_parent_instructions;
                     body.emit(f401D);

                     /* END IF */


                  body.instructions = f401B_parent_instructions;
                  body.emit(f401B);

                  /* END IF */

                  body.emit(assign(r4012, body.constant(0u), 0x01));


               body.instructions = f4017_parent_instructions;
               body.emit(f4017);

               /* END IF */

               ir_expression *const r4025 = nequal(r400F, body.constant(0u));
               ir_expression *const r4026 = expr(ir_unop_b2i, r4025);
               ir_expression *const r4027 = expr(ir_unop_i2u, r4026);
               body.emit(assign(r4010, bit_or(r4010, r4027), 0x01));


            body.instructions = f4015_parent_instructions;
            body.emit(f4015);

            /* END IF */

            body.emit(assign(r3FD7, r4012, 0x01));

            body.emit(assign(r3FD8, r4011, 0x01));

            body.emit(assign(r3FDC, r4010, 0x01));

            body.emit(assign(r3FDB, r3FE2, 0x01));


         body.instructions = f3FEB_parent_instructions;
         body.emit(f3FEB);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3FE9->else_instructions;

         /* IF CONDITION */
         ir_expression *const r4029 = less(r3FD6, body.constant(int(0)));
         ir_if *f4028 = new(mem_ctx) ir_if(operand(r4029).val);
         exec_list *const f4028_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f4028->then_instructions;

            /* IF CONDITION */
            ir_expression *const r402B = equal(r3FE5, body.constant(int(2047)));
            ir_if *f402A = new(mem_ctx) ir_if(operand(r402B).val);
            exec_list *const f402A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f402A->then_instructions;

               /* IF CONDITION */
               ir_expression *const r402D = bit_or(r3FD7, r3FD8);
               ir_expression *const r402E = nequal(r402D, body.constant(0u));
               ir_if *f402C = new(mem_ctx) ir_if(operand(r402E).val);
               exec_list *const f402C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f402C->then_instructions;

                  ir_variable *const r402F = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r402F, swizzle_x(r3247), 0x01));

                  ir_variable *const r4030 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r4030, swizzle_x(r3A07), 0x01));

                  ir_variable *const r4031 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r4032 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r4033 = rshift(swizzle_y(r3247), body.constant(int(19)));
                  ir_expression *const r4034 = bit_and(r4033, body.constant(4095u));
                  ir_expression *const r4035 = equal(r4034, body.constant(4094u));
                  ir_expression *const r4036 = nequal(swizzle_x(r3247), body.constant(0u));
                  ir_expression *const r4037 = bit_and(swizzle_y(r3247), body.constant(524287u));
                  ir_expression *const r4038 = nequal(r4037, body.constant(0u));
                  ir_expression *const r4039 = logic_or(r4036, r4038);
                  body.emit(assign(r4032, logic_and(r4035, r4039), 0x01));

                  ir_variable *const r403A = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r403B = lshift(swizzle_y(r3A07), body.constant(int(1)));
                  ir_expression *const r403C = lequal(body.constant(4292870144u), r403B);
                  ir_expression *const r403D = nequal(swizzle_x(r3A07), body.constant(0u));
                  ir_expression *const r403E = bit_and(swizzle_y(r3A07), body.constant(1048575u));
                  ir_expression *const r403F = nequal(r403E, body.constant(0u));
                  ir_expression *const r4040 = logic_or(r403D, r403F);
                  body.emit(assign(r403A, logic_and(r403C, r4040), 0x01));

                  body.emit(assign(r402F, bit_or(swizzle_y(r3247), body.constant(524288u)), 0x02));

                  body.emit(assign(r4030, bit_or(swizzle_y(r3A07), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r4042 = lshift(swizzle_y(r3247), body.constant(int(1)));
                  ir_expression *const r4043 = lequal(body.constant(4292870144u), r4042);
                  ir_expression *const r4044 = nequal(swizzle_x(r3247), body.constant(0u));
                  ir_expression *const r4045 = bit_and(swizzle_y(r3247), body.constant(1048575u));
                  ir_expression *const r4046 = nequal(r4045, body.constant(0u));
                  ir_expression *const r4047 = logic_or(r4044, r4046);
                  ir_expression *const r4048 = logic_and(r4043, r4047);
                  ir_if *f4041 = new(mem_ctx) ir_if(operand(r4048).val);
                  exec_list *const f4041_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f4041->then_instructions;

                     ir_variable *const r4049 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r404B = logic_and(r4032, r403A);
                     ir_if *f404A = new(mem_ctx) ir_if(operand(r404B).val);
                     exec_list *const f404A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f404A->then_instructions;

                        body.emit(assign(r4049, r4030, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f404A->else_instructions;

                        body.emit(assign(r4049, r402F, 0x03));


                     body.instructions = f404A_parent_instructions;
                     body.emit(f404A);

                     /* END IF */

                     body.emit(assign(r4031, r4049, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f4041->else_instructions;

                     body.emit(assign(r4031, r4030, 0x03));


                  body.instructions = f4041_parent_instructions;
                  body.emit(f4041);

                  /* END IF */

                  body.emit(assign(r3FD5, r4031, 0x03));

                  body.emit(assign(r3FD4, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f402C->else_instructions;

                  ir_variable *const r404C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r404C);
                  ir_expression *const r404D = lshift(r3BBA, body.constant(int(31)));
                  body.emit(assign(r404C, add(r404D, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r404C, body.constant(0u), 0x01));

                  body.emit(assign(r3FD5, r404C, 0x03));

                  body.emit(assign(r3FD4, body.constant(false), 0x01));


               body.instructions = f402C_parent_instructions;
               body.emit(f402C);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f402A->else_instructions;

               /* IF CONDITION */
               ir_expression *const r404F = equal(r3FE2, body.constant(int(0)));
               ir_if *f404E = new(mem_ctx) ir_if(operand(r404F).val);
               exec_list *const f404E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f404E->then_instructions;

                  body.emit(assign(r3FD6, add(r3FD6, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f404E->else_instructions;

                  body.emit(assign(r3FD9, bit_or(r3FDF, body.constant(1048576u)), 0x01));


               body.instructions = f404E_parent_instructions;
               body.emit(f404E);

               /* END IF */

               ir_variable *const r4050 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r4050, body.constant(0u), 0x01));

               ir_variable *const r4051 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r4051, neg(r3FD6), 0x01));

               ir_variable *const r4052 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r4052);
               ir_variable *const r4053 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r4053);
               ir_variable *const r4054 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r4054);
               ir_variable *const r4055 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r4056 = neg(r4051);
               body.emit(assign(r4055, bit_and(r4056, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r4058 = equal(r4051, body.constant(int(0)));
               ir_if *f4057 = new(mem_ctx) ir_if(operand(r4058).val);
               exec_list *const f4057_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4057->then_instructions;

                  body.emit(assign(r4052, r4050, 0x01));

                  body.emit(assign(r4053, r3FDE, 0x01));

                  body.emit(assign(r4054, r3FD9, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4057->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r405A = less(r4051, body.constant(int(32)));
                  ir_if *f4059 = new(mem_ctx) ir_if(operand(r405A).val);
                  exec_list *const f4059_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f4059->then_instructions;

                     body.emit(assign(r4052, lshift(swizzle_x(r3247), r4055), 0x01));

                     ir_expression *const r405B = lshift(r3FD9, r4055);
                     ir_expression *const r405C = rshift(swizzle_x(r3247), r4051);
                     body.emit(assign(r4053, bit_or(r405B, r405C), 0x01));

                     body.emit(assign(r4054, rshift(r3FD9, r4051), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f4059->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r405E = equal(r4051, body.constant(int(32)));
                     ir_if *f405D = new(mem_ctx) ir_if(operand(r405E).val);
                     exec_list *const f405D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f405D->then_instructions;

                        body.emit(assign(r4052, r3FDE, 0x01));

                        body.emit(assign(r4053, r3FD9, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f405D->else_instructions;

                        body.emit(assign(r4050, bit_or(body.constant(0u), swizzle_x(r3247)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r4060 = less(r4051, body.constant(int(64)));
                        ir_if *f405F = new(mem_ctx) ir_if(operand(r4060).val);
                        exec_list *const f405F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f405F->then_instructions;

                           body.emit(assign(r4052, lshift(r3FD9, r4055), 0x01));

                           ir_expression *const r4061 = bit_and(r4051, body.constant(int(31)));
                           body.emit(assign(r4053, rshift(r3FD9, r4061), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f405F->else_instructions;

                           ir_variable *const r4062 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r4064 = equal(r4051, body.constant(int(64)));
                           ir_if *f4063 = new(mem_ctx) ir_if(operand(r4064).val);
                           exec_list *const f4063_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f4063->then_instructions;

                              body.emit(assign(r4062, r3FD9, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f4063->else_instructions;

                              ir_expression *const r4065 = nequal(r3FD9, body.constant(0u));
                              ir_expression *const r4066 = expr(ir_unop_b2i, r4065);
                              body.emit(assign(r4062, expr(ir_unop_i2u, r4066), 0x01));


                           body.instructions = f4063_parent_instructions;
                           body.emit(f4063);

                           /* END IF */

                           body.emit(assign(r4052, r4062, 0x01));

                           body.emit(assign(r4053, body.constant(0u), 0x01));


                        body.instructions = f405F_parent_instructions;
                        body.emit(f405F);

                        /* END IF */


                     body.instructions = f405D_parent_instructions;
                     body.emit(f405D);

                     /* END IF */

                     body.emit(assign(r4054, body.constant(0u), 0x01));


                  body.instructions = f4059_parent_instructions;
                  body.emit(f4059);

                  /* END IF */

                  ir_expression *const r4067 = nequal(r4050, body.constant(0u));
                  ir_expression *const r4068 = expr(ir_unop_b2i, r4067);
                  ir_expression *const r4069 = expr(ir_unop_i2u, r4068);
                  body.emit(assign(r4052, bit_or(r4052, r4069), 0x01));


               body.instructions = f4057_parent_instructions;
               body.emit(f4057);

               /* END IF */

               body.emit(assign(r3FD9, r4054, 0x01));

               body.emit(assign(r3FDA, r4053, 0x01));

               body.emit(assign(r3FDC, r4052, 0x01));

               body.emit(assign(r3FDB, r3FE5, 0x01));


            body.instructions = f402A_parent_instructions;
            body.emit(f402A);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f4028->else_instructions;

            /* IF CONDITION */
            ir_expression *const r406B = equal(r3FE2, body.constant(int(2047)));
            ir_if *f406A = new(mem_ctx) ir_if(operand(r406B).val);
            exec_list *const f406A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f406A->then_instructions;

               /* IF CONDITION */
               ir_expression *const r406D = bit_or(r3FD9, r3FDA);
               ir_expression *const r406E = bit_or(r3FD7, r3FD8);
               ir_expression *const r406F = bit_or(r406D, r406E);
               ir_expression *const r4070 = nequal(r406F, body.constant(0u));
               ir_if *f406C = new(mem_ctx) ir_if(operand(r4070).val);
               exec_list *const f406C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f406C->then_instructions;

                  ir_variable *const r4071 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r4071, swizzle_x(r3247), 0x01));

                  ir_variable *const r4072 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r4072, swizzle_x(r3A07), 0x01));

                  ir_variable *const r4073 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r4074 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r4075 = rshift(swizzle_y(r3247), body.constant(int(19)));
                  ir_expression *const r4076 = bit_and(r4075, body.constant(4095u));
                  ir_expression *const r4077 = equal(r4076, body.constant(4094u));
                  ir_expression *const r4078 = nequal(swizzle_x(r3247), body.constant(0u));
                  ir_expression *const r4079 = bit_and(swizzle_y(r3247), body.constant(524287u));
                  ir_expression *const r407A = nequal(r4079, body.constant(0u));
                  ir_expression *const r407B = logic_or(r4078, r407A);
                  body.emit(assign(r4074, logic_and(r4077, r407B), 0x01));

                  ir_variable *const r407C = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r407D = lshift(swizzle_y(r3A07), body.constant(int(1)));
                  ir_expression *const r407E = lequal(body.constant(4292870144u), r407D);
                  ir_expression *const r407F = nequal(swizzle_x(r3A07), body.constant(0u));
                  ir_expression *const r4080 = bit_and(swizzle_y(r3A07), body.constant(1048575u));
                  ir_expression *const r4081 = nequal(r4080, body.constant(0u));
                  ir_expression *const r4082 = logic_or(r407F, r4081);
                  body.emit(assign(r407C, logic_and(r407E, r4082), 0x01));

                  body.emit(assign(r4071, bit_or(swizzle_y(r3247), body.constant(524288u)), 0x02));

                  body.emit(assign(r4072, bit_or(swizzle_y(r3A07), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r4084 = lshift(swizzle_y(r3247), body.constant(int(1)));
                  ir_expression *const r4085 = lequal(body.constant(4292870144u), r4084);
                  ir_expression *const r4086 = nequal(swizzle_x(r3247), body.constant(0u));
                  ir_expression *const r4087 = bit_and(swizzle_y(r3247), body.constant(1048575u));
                  ir_expression *const r4088 = nequal(r4087, body.constant(0u));
                  ir_expression *const r4089 = logic_or(r4086, r4088);
                  ir_expression *const r408A = logic_and(r4085, r4089);
                  ir_if *f4083 = new(mem_ctx) ir_if(operand(r408A).val);
                  exec_list *const f4083_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f4083->then_instructions;

                     ir_variable *const r408B = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r408D = logic_and(r4074, r407C);
                     ir_if *f408C = new(mem_ctx) ir_if(operand(r408D).val);
                     exec_list *const f408C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f408C->then_instructions;

                        body.emit(assign(r408B, r4072, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f408C->else_instructions;

                        body.emit(assign(r408B, r4071, 0x03));


                     body.instructions = f408C_parent_instructions;
                     body.emit(f408C);

                     /* END IF */

                     body.emit(assign(r4073, r408B, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f4083->else_instructions;

                     body.emit(assign(r4073, r4072, 0x03));


                  body.instructions = f4083_parent_instructions;
                  body.emit(f4083);

                  /* END IF */

                  body.emit(assign(r3FD5, r4073, 0x03));

                  body.emit(assign(r3FD4, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f406C->else_instructions;

                  body.emit(assign(r3FD5, r3247, 0x03));

                  body.emit(assign(r3FD4, body.constant(false), 0x01));


               body.instructions = f406C_parent_instructions;
               body.emit(f406C);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f406A->else_instructions;

               ir_variable *const r408E = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r408F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r408F, add(r3FDA, r3FD8), 0x01));

               ir_expression *const r4090 = add(r3FD9, r3FD7);
               ir_expression *const r4091 = less(r408F, r3FDA);
               ir_expression *const r4092 = expr(ir_unop_b2i, r4091);
               ir_expression *const r4093 = expr(ir_unop_i2u, r4092);
               body.emit(assign(r408E, add(r4090, r4093), 0x01));

               body.emit(assign(r3FDD, r408E, 0x01));

               /* IF CONDITION */
               ir_expression *const r4095 = equal(r3FE2, body.constant(int(0)));
               ir_if *f4094 = new(mem_ctx) ir_if(operand(r4095).val);
               exec_list *const f4094_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4094->then_instructions;

                  ir_variable *const r4096 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r4096);
                  ir_expression *const r4097 = lshift(r3BBA, body.constant(int(31)));
                  body.emit(assign(r4096, add(r4097, r408E), 0x02));

                  body.emit(assign(r4096, r408F, 0x01));

                  body.emit(assign(r3FD5, r4096, 0x03));

                  body.emit(assign(r3FD4, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4094->else_instructions;

                  body.emit(assign(r3FDD, bit_or(r408E, body.constant(2097152u)), 0x01));

                  body.emit(assign(r3FDB, r3FE2, 0x01));

                  ir_variable *const r4098 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r4098);
                  ir_variable *const r4099 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r4099);
                  ir_variable *const r409A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r409A);
                  body.emit(assign(r4098, lshift(r408F, body.constant(int(31))), 0x01));

                  ir_expression *const r409B = lshift(r3FDD, body.constant(int(31)));
                  ir_expression *const r409C = rshift(r408F, body.constant(int(1)));
                  body.emit(assign(r4099, bit_or(r409B, r409C), 0x01));

                  body.emit(assign(r409A, rshift(r3FDD, body.constant(int(1))), 0x01));

                  body.emit(assign(r4098, bit_or(r4098, body.constant(0u)), 0x01));

                  body.emit(assign(r3FDD, r409A, 0x01));

                  body.emit(assign(r3FDC, r4098, 0x01));

                  ir_variable *const r409D = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r409D, r3FE2, 0x01));

                  ir_variable *const r409E = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r409E, r409A, 0x01));

                  ir_variable *const r409F = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r409F, r4099, 0x01));

                  ir_variable *const r40A0 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r40A0, r4098, 0x01));

                  ir_variable *const r40A1 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r40A1, body.constant(true), 0x01));

                  ir_variable *const r40A2 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r40A3 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r40A3);
                  ir_expression *const r40A4 = expr(ir_unop_u2i, r4098);
                  body.emit(assign(r40A3, less(r40A4, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r40A6 = lequal(body.constant(int(2045)), r3FE2);
                  ir_if *f40A5 = new(mem_ctx) ir_if(operand(r40A6).val);
                  exec_list *const f40A5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f40A5->then_instructions;

                     ir_variable *const r40A7 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r40A9 = less(body.constant(int(2045)), r3FE2);
                     ir_if *f40A8 = new(mem_ctx) ir_if(operand(r40A9).val);
                     exec_list *const f40A8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f40A8->then_instructions;

                        body.emit(assign(r40A7, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f40A8->else_instructions;

                        ir_variable *const r40AA = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r40AC = equal(r3FE2, body.constant(int(2045)));
                        ir_if *f40AB = new(mem_ctx) ir_if(operand(r40AC).val);
                        exec_list *const f40AB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f40AB->then_instructions;

                           ir_expression *const r40AD = equal(body.constant(2097151u), r409A);
                           ir_expression *const r40AE = equal(body.constant(4294967295u), r4099);
                           body.emit(assign(r40AA, logic_and(r40AD, r40AE), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f40AB->else_instructions;

                           body.emit(assign(r40AA, body.constant(false), 0x01));


                        body.instructions = f40AB_parent_instructions;
                        body.emit(f40AB);

                        /* END IF */

                        body.emit(assign(r40A7, logic_and(r40AA, r40A3), 0x01));


                     body.instructions = f40A8_parent_instructions;
                     body.emit(f40A8);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f40AF = new(mem_ctx) ir_if(operand(r40A7).val);
                     exec_list *const f40AF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f40AF->then_instructions;

                        ir_variable *const r40B0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r40B0);
                        ir_expression *const r40B1 = lshift(r3BBA, body.constant(int(31)));
                        body.emit(assign(r40B0, add(r40B1, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r40B0, body.constant(0u), 0x01));

                        body.emit(assign(r40A2, r40B0, 0x03));

                        body.emit(assign(r40A1, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f40AF->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r40B3 = less(r3FE2, body.constant(int(0)));
                        ir_if *f40B2 = new(mem_ctx) ir_if(operand(r40B3).val);
                        exec_list *const f40B2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f40B2->then_instructions;

                           ir_variable *const r40B4 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r40B4, r4098, 0x01));

                           ir_variable *const r40B5 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r40B5, neg(r3FE2), 0x01));

                           ir_variable *const r40B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r40B6);
                           ir_variable *const r40B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r40B7);
                           ir_variable *const r40B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r40B8);
                           ir_variable *const r40B9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r40BA = neg(r40B5);
                           body.emit(assign(r40B9, bit_and(r40BA, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r40BC = equal(r40B5, body.constant(int(0)));
                           ir_if *f40BB = new(mem_ctx) ir_if(operand(r40BC).val);
                           exec_list *const f40BB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f40BB->then_instructions;

                              body.emit(assign(r40B6, r4098, 0x01));

                              body.emit(assign(r40B7, r4099, 0x01));

                              body.emit(assign(r40B8, r409A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f40BB->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r40BE = less(r40B5, body.constant(int(32)));
                              ir_if *f40BD = new(mem_ctx) ir_if(operand(r40BE).val);
                              exec_list *const f40BD_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f40BD->then_instructions;

                                 body.emit(assign(r40B6, lshift(r4099, r40B9), 0x01));

                                 ir_expression *const r40BF = lshift(r409A, r40B9);
                                 ir_expression *const r40C0 = rshift(r4099, r40B5);
                                 body.emit(assign(r40B7, bit_or(r40BF, r40C0), 0x01));

                                 body.emit(assign(r40B8, rshift(r409A, r40B5), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f40BD->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r40C2 = equal(r40B5, body.constant(int(32)));
                                 ir_if *f40C1 = new(mem_ctx) ir_if(operand(r40C2).val);
                                 exec_list *const f40C1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f40C1->then_instructions;

                                    body.emit(assign(r40B6, r4099, 0x01));

                                    body.emit(assign(r40B7, r409A, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f40C1->else_instructions;

                                    body.emit(assign(r40B4, bit_or(r4098, r4099), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r40C4 = less(r40B5, body.constant(int(64)));
                                    ir_if *f40C3 = new(mem_ctx) ir_if(operand(r40C4).val);
                                    exec_list *const f40C3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f40C3->then_instructions;

                                       body.emit(assign(r40B6, lshift(r409A, r40B9), 0x01));

                                       ir_expression *const r40C5 = bit_and(r40B5, body.constant(int(31)));
                                       body.emit(assign(r40B7, rshift(r409A, r40C5), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f40C3->else_instructions;

                                       ir_variable *const r40C6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r40C8 = equal(r40B5, body.constant(int(64)));
                                       ir_if *f40C7 = new(mem_ctx) ir_if(operand(r40C8).val);
                                       exec_list *const f40C7_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f40C7->then_instructions;

                                          body.emit(assign(r40C6, r409A, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f40C7->else_instructions;

                                          ir_expression *const r40C9 = nequal(r409A, body.constant(0u));
                                          ir_expression *const r40CA = expr(ir_unop_b2i, r40C9);
                                          body.emit(assign(r40C6, expr(ir_unop_i2u, r40CA), 0x01));


                                       body.instructions = f40C7_parent_instructions;
                                       body.emit(f40C7);

                                       /* END IF */

                                       body.emit(assign(r40B6, r40C6, 0x01));

                                       body.emit(assign(r40B7, body.constant(0u), 0x01));


                                    body.instructions = f40C3_parent_instructions;
                                    body.emit(f40C3);

                                    /* END IF */


                                 body.instructions = f40C1_parent_instructions;
                                 body.emit(f40C1);

                                 /* END IF */

                                 body.emit(assign(r40B8, body.constant(0u), 0x01));


                              body.instructions = f40BD_parent_instructions;
                              body.emit(f40BD);

                              /* END IF */

                              ir_expression *const r40CB = nequal(r40B4, body.constant(0u));
                              ir_expression *const r40CC = expr(ir_unop_b2i, r40CB);
                              ir_expression *const r40CD = expr(ir_unop_i2u, r40CC);
                              body.emit(assign(r40B6, bit_or(r40B6, r40CD), 0x01));


                           body.instructions = f40BB_parent_instructions;
                           body.emit(f40BB);

                           /* END IF */

                           body.emit(assign(r409E, r40B8, 0x01));

                           body.emit(assign(r409F, r40B7, 0x01));

                           body.emit(assign(r40A0, r40B6, 0x01));

                           body.emit(assign(r409D, body.constant(int(0)), 0x01));

                           body.emit(assign(r40A3, less(r40B6, body.constant(0u)), 0x01));


                        body.instructions = f40B2_parent_instructions;
                        body.emit(f40B2);

                        /* END IF */


                     body.instructions = f40AF_parent_instructions;
                     body.emit(f40AF);

                     /* END IF */


                  body.instructions = f40A5_parent_instructions;
                  body.emit(f40A5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f40CE = new(mem_ctx) ir_if(operand(r40A1).val);
                  exec_list *const f40CE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f40CE->then_instructions;

                     /* IF CONDITION */
                     ir_if *f40CF = new(mem_ctx) ir_if(operand(r40A3).val);
                     exec_list *const f40CF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f40CF->then_instructions;

                        ir_variable *const r40D0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r40D0, add(r409F, body.constant(1u)), 0x01));

                        ir_expression *const r40D1 = less(r40D0, r409F);
                        ir_expression *const r40D2 = expr(ir_unop_b2i, r40D1);
                        ir_expression *const r40D3 = expr(ir_unop_i2u, r40D2);
                        body.emit(assign(r409E, add(r409E, r40D3), 0x01));

                        ir_expression *const r40D4 = equal(r40A0, body.constant(0u));
                        ir_expression *const r40D5 = expr(ir_unop_b2i, r40D4);
                        ir_expression *const r40D6 = expr(ir_unop_i2u, r40D5);
                        ir_expression *const r40D7 = add(r40A0, r40D6);
                        ir_expression *const r40D8 = bit_and(r40D7, body.constant(1u));
                        ir_expression *const r40D9 = expr(ir_unop_bit_not, r40D8);
                        body.emit(assign(r409F, bit_and(r40D0, r40D9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f40CF->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r40DB = bit_or(r409E, r409F);
                        ir_expression *const r40DC = equal(r40DB, body.constant(0u));
                        ir_if *f40DA = new(mem_ctx) ir_if(operand(r40DC).val);
                        exec_list *const f40DA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f40DA->then_instructions;

                           body.emit(assign(r409D, body.constant(int(0)), 0x01));


                        body.instructions = f40DA_parent_instructions;
                        body.emit(f40DA);

                        /* END IF */


                     body.instructions = f40CF_parent_instructions;
                     body.emit(f40CF);

                     /* END IF */

                     ir_variable *const r40DD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r40DD);
                     ir_expression *const r40DE = lshift(r3BBA, body.constant(int(31)));
                     ir_expression *const r40DF = expr(ir_unop_i2u, r409D);
                     ir_expression *const r40E0 = lshift(r40DF, body.constant(int(20)));
                     ir_expression *const r40E1 = add(r40DE, r40E0);
                     body.emit(assign(r40DD, add(r40E1, r409E), 0x02));

                     body.emit(assign(r40DD, r409F, 0x01));

                     body.emit(assign(r40A2, r40DD, 0x03));

                     body.emit(assign(r40A1, body.constant(false), 0x01));


                  body.instructions = f40CE_parent_instructions;
                  body.emit(f40CE);

                  /* END IF */

                  body.emit(assign(r3FD5, r40A2, 0x03));

                  body.emit(assign(r3FD4, body.constant(false), 0x01));


               body.instructions = f4094_parent_instructions;
               body.emit(f4094);

               /* END IF */


            body.instructions = f406A_parent_instructions;
            body.emit(f406A);

            /* END IF */


         body.instructions = f4028_parent_instructions;
         body.emit(f4028);

         /* END IF */


      body.instructions = f3FE9_parent_instructions;
      body.emit(f3FE9);

      /* END IF */

      /* IF CONDITION */
      ir_if *f40E2 = new(mem_ctx) ir_if(operand(r3FD4).val);
      exec_list *const f40E2_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f40E2->then_instructions;

         body.emit(assign(r3FD9, bit_or(r3FD9, body.constant(1048576u)), 0x01));

         ir_variable *const r40E3 = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r40E4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r40E4, add(r3FDA, r3FD8), 0x01));

         ir_expression *const r40E5 = add(r3FD9, r3FD7);
         ir_expression *const r40E6 = less(r40E4, r3FDA);
         ir_expression *const r40E7 = expr(ir_unop_b2i, r40E6);
         ir_expression *const r40E8 = expr(ir_unop_i2u, r40E7);
         body.emit(assign(r40E3, add(r40E5, r40E8), 0x01));

         body.emit(assign(r3FDD, r40E3, 0x01));

         body.emit(assign(r3FDB, add(r3FDB, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r40EA = less(r40E3, body.constant(2097152u));
         ir_if *f40E9 = new(mem_ctx) ir_if(operand(r40EA).val);
         exec_list *const f40E9_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f40E9->then_instructions;

            ir_variable *const r40EB = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r40EB, r3FDB, 0x01));

            ir_variable *const r40EC = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r40EC, r40E3, 0x01));

            ir_variable *const r40ED = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r40ED, r40E4, 0x01));

            ir_variable *const r40EE = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r40EE, r3FDC, 0x01));

            ir_variable *const r40EF = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r40EF, body.constant(true), 0x01));

            ir_variable *const r40F0 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r40F1 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r40F1);
            ir_expression *const r40F2 = expr(ir_unop_u2i, r3FDC);
            body.emit(assign(r40F1, less(r40F2, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r40F4 = lequal(body.constant(int(2045)), r3FDB);
            ir_if *f40F3 = new(mem_ctx) ir_if(operand(r40F4).val);
            exec_list *const f40F3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f40F3->then_instructions;

               ir_variable *const r40F5 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r40F7 = less(body.constant(int(2045)), r3FDB);
               ir_if *f40F6 = new(mem_ctx) ir_if(operand(r40F7).val);
               exec_list *const f40F6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f40F6->then_instructions;

                  body.emit(assign(r40F5, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f40F6->else_instructions;

                  ir_variable *const r40F8 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r40FA = equal(r3FDB, body.constant(int(2045)));
                  ir_if *f40F9 = new(mem_ctx) ir_if(operand(r40FA).val);
                  exec_list *const f40F9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f40F9->then_instructions;

                     ir_expression *const r40FB = equal(body.constant(2097151u), r40E3);
                     ir_expression *const r40FC = equal(body.constant(4294967295u), r40E4);
                     body.emit(assign(r40F8, logic_and(r40FB, r40FC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f40F9->else_instructions;

                     body.emit(assign(r40F8, body.constant(false), 0x01));


                  body.instructions = f40F9_parent_instructions;
                  body.emit(f40F9);

                  /* END IF */

                  body.emit(assign(r40F5, logic_and(r40F8, r40F1), 0x01));


               body.instructions = f40F6_parent_instructions;
               body.emit(f40F6);

               /* END IF */

               /* IF CONDITION */
               ir_if *f40FD = new(mem_ctx) ir_if(operand(r40F5).val);
               exec_list *const f40FD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f40FD->then_instructions;

                  ir_variable *const r40FE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r40FE);
                  ir_expression *const r40FF = lshift(r3BBA, body.constant(int(31)));
                  body.emit(assign(r40FE, add(r40FF, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r40FE, body.constant(0u), 0x01));

                  body.emit(assign(r40F0, r40FE, 0x03));

                  body.emit(assign(r40EF, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f40FD->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r4101 = less(r3FDB, body.constant(int(0)));
                  ir_if *f4100 = new(mem_ctx) ir_if(operand(r4101).val);
                  exec_list *const f4100_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f4100->then_instructions;

                     ir_variable *const r4102 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r4102, r3FDC, 0x01));

                     ir_variable *const r4103 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r4103, neg(r3FDB), 0x01));

                     ir_variable *const r4104 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r4104);
                     ir_variable *const r4105 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r4105);
                     ir_variable *const r4106 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r4106);
                     ir_variable *const r4107 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r4108 = neg(r4103);
                     body.emit(assign(r4107, bit_and(r4108, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r410A = equal(r4103, body.constant(int(0)));
                     ir_if *f4109 = new(mem_ctx) ir_if(operand(r410A).val);
                     exec_list *const f4109_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f4109->then_instructions;

                        body.emit(assign(r4104, r3FDC, 0x01));

                        body.emit(assign(r4105, r40E4, 0x01));

                        body.emit(assign(r4106, r40E3, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f4109->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r410C = less(r4103, body.constant(int(32)));
                        ir_if *f410B = new(mem_ctx) ir_if(operand(r410C).val);
                        exec_list *const f410B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f410B->then_instructions;

                           body.emit(assign(r4104, lshift(r40E4, r4107), 0x01));

                           ir_expression *const r410D = lshift(r40E3, r4107);
                           ir_expression *const r410E = rshift(r40E4, r4103);
                           body.emit(assign(r4105, bit_or(r410D, r410E), 0x01));

                           body.emit(assign(r4106, rshift(r40E3, r4103), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f410B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r4110 = equal(r4103, body.constant(int(32)));
                           ir_if *f410F = new(mem_ctx) ir_if(operand(r4110).val);
                           exec_list *const f410F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f410F->then_instructions;

                              body.emit(assign(r4104, r40E4, 0x01));

                              body.emit(assign(r4105, r40E3, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f410F->else_instructions;

                              body.emit(assign(r4102, bit_or(r3FDC, r40E4), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r4112 = less(r4103, body.constant(int(64)));
                              ir_if *f4111 = new(mem_ctx) ir_if(operand(r4112).val);
                              exec_list *const f4111_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f4111->then_instructions;

                                 body.emit(assign(r4104, lshift(r40E3, r4107), 0x01));

                                 ir_expression *const r4113 = bit_and(r4103, body.constant(int(31)));
                                 body.emit(assign(r4105, rshift(r40E3, r4113), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f4111->else_instructions;

                                 ir_variable *const r4114 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r4116 = equal(r4103, body.constant(int(64)));
                                 ir_if *f4115 = new(mem_ctx) ir_if(operand(r4116).val);
                                 exec_list *const f4115_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f4115->then_instructions;

                                    body.emit(assign(r4114, r40E3, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f4115->else_instructions;

                                    ir_expression *const r4117 = nequal(r40E3, body.constant(0u));
                                    ir_expression *const r4118 = expr(ir_unop_b2i, r4117);
                                    body.emit(assign(r4114, expr(ir_unop_i2u, r4118), 0x01));


                                 body.instructions = f4115_parent_instructions;
                                 body.emit(f4115);

                                 /* END IF */

                                 body.emit(assign(r4104, r4114, 0x01));

                                 body.emit(assign(r4105, body.constant(0u), 0x01));


                              body.instructions = f4111_parent_instructions;
                              body.emit(f4111);

                              /* END IF */


                           body.instructions = f410F_parent_instructions;
                           body.emit(f410F);

                           /* END IF */

                           body.emit(assign(r4106, body.constant(0u), 0x01));


                        body.instructions = f410B_parent_instructions;
                        body.emit(f410B);

                        /* END IF */

                        ir_expression *const r4119 = nequal(r4102, body.constant(0u));
                        ir_expression *const r411A = expr(ir_unop_b2i, r4119);
                        ir_expression *const r411B = expr(ir_unop_i2u, r411A);
                        body.emit(assign(r4104, bit_or(r4104, r411B), 0x01));


                     body.instructions = f4109_parent_instructions;
                     body.emit(f4109);

                     /* END IF */

                     body.emit(assign(r40EC, r4106, 0x01));

                     body.emit(assign(r40ED, r4105, 0x01));

                     body.emit(assign(r40EE, r4104, 0x01));

                     body.emit(assign(r40EB, body.constant(int(0)), 0x01));

                     body.emit(assign(r40F1, less(r4104, body.constant(0u)), 0x01));


                  body.instructions = f4100_parent_instructions;
                  body.emit(f4100);

                  /* END IF */


               body.instructions = f40FD_parent_instructions;
               body.emit(f40FD);

               /* END IF */


            body.instructions = f40F3_parent_instructions;
            body.emit(f40F3);

            /* END IF */

            /* IF CONDITION */
            ir_if *f411C = new(mem_ctx) ir_if(operand(r40EF).val);
            exec_list *const f411C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f411C->then_instructions;

               /* IF CONDITION */
               ir_if *f411D = new(mem_ctx) ir_if(operand(r40F1).val);
               exec_list *const f411D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f411D->then_instructions;

                  ir_variable *const r411E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r411E, add(r40ED, body.constant(1u)), 0x01));

                  ir_expression *const r411F = less(r411E, r40ED);
                  ir_expression *const r4120 = expr(ir_unop_b2i, r411F);
                  ir_expression *const r4121 = expr(ir_unop_i2u, r4120);
                  body.emit(assign(r40EC, add(r40EC, r4121), 0x01));

                  ir_expression *const r4122 = equal(r40EE, body.constant(0u));
                  ir_expression *const r4123 = expr(ir_unop_b2i, r4122);
                  ir_expression *const r4124 = expr(ir_unop_i2u, r4123);
                  ir_expression *const r4125 = add(r40EE, r4124);
                  ir_expression *const r4126 = bit_and(r4125, body.constant(1u));
                  ir_expression *const r4127 = expr(ir_unop_bit_not, r4126);
                  body.emit(assign(r40ED, bit_and(r411E, r4127), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f411D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r4129 = bit_or(r40EC, r40ED);
                  ir_expression *const r412A = equal(r4129, body.constant(0u));
                  ir_if *f4128 = new(mem_ctx) ir_if(operand(r412A).val);
                  exec_list *const f4128_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f4128->then_instructions;

                     body.emit(assign(r40EB, body.constant(int(0)), 0x01));


                  body.instructions = f4128_parent_instructions;
                  body.emit(f4128);

                  /* END IF */


               body.instructions = f411D_parent_instructions;
               body.emit(f411D);

               /* END IF */

               ir_variable *const r412B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r412B);
               ir_expression *const r412C = lshift(r3BBA, body.constant(int(31)));
               ir_expression *const r412D = expr(ir_unop_i2u, r40EB);
               ir_expression *const r412E = lshift(r412D, body.constant(int(20)));
               ir_expression *const r412F = add(r412C, r412E);
               body.emit(assign(r412B, add(r412F, r40EC), 0x02));

               body.emit(assign(r412B, r40ED, 0x01));

               body.emit(assign(r40F0, r412B, 0x03));

               body.emit(assign(r40EF, body.constant(false), 0x01));


            body.instructions = f411C_parent_instructions;
            body.emit(f411C);

            /* END IF */

            body.emit(assign(r3FD5, r40F0, 0x03));

            body.emit(assign(r3FD4, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f40E9->else_instructions;

            body.emit(assign(r3FDB, add(r3FDB, body.constant(int(1))), 0x01));

            ir_variable *const r4130 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r4130);
            ir_variable *const r4131 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r4131);
            ir_variable *const r4132 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r4132);
            body.emit(assign(r4130, lshift(r40E4, body.constant(int(31))), 0x01));

            ir_expression *const r4133 = lshift(r40E3, body.constant(int(31)));
            ir_expression *const r4134 = rshift(r40E4, body.constant(int(1)));
            body.emit(assign(r4131, bit_or(r4133, r4134), 0x01));

            body.emit(assign(r4132, rshift(r40E3, body.constant(int(1))), 0x01));

            ir_expression *const r4135 = nequal(r3FDC, body.constant(0u));
            ir_expression *const r4136 = expr(ir_unop_b2i, r4135);
            ir_expression *const r4137 = expr(ir_unop_i2u, r4136);
            body.emit(assign(r4130, bit_or(r4130, r4137), 0x01));

            body.emit(assign(r3FDD, r4132, 0x01));

            body.emit(assign(r3FDC, r4130, 0x01));

            ir_variable *const r4138 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r4138, r3FDB, 0x01));

            ir_variable *const r4139 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r4139, r4132, 0x01));

            ir_variable *const r413A = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r413A, r4131, 0x01));

            ir_variable *const r413B = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r413B, r4130, 0x01));

            ir_variable *const r413C = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r413C, body.constant(true), 0x01));

            ir_variable *const r413D = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r413E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r413E);
            ir_expression *const r413F = expr(ir_unop_u2i, r4130);
            body.emit(assign(r413E, less(r413F, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r4141 = lequal(body.constant(int(2045)), r3FDB);
            ir_if *f4140 = new(mem_ctx) ir_if(operand(r4141).val);
            exec_list *const f4140_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f4140->then_instructions;

               ir_variable *const r4142 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r4144 = less(body.constant(int(2045)), r3FDB);
               ir_if *f4143 = new(mem_ctx) ir_if(operand(r4144).val);
               exec_list *const f4143_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4143->then_instructions;

                  body.emit(assign(r4142, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4143->else_instructions;

                  ir_variable *const r4145 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r4147 = equal(r3FDB, body.constant(int(2045)));
                  ir_if *f4146 = new(mem_ctx) ir_if(operand(r4147).val);
                  exec_list *const f4146_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f4146->then_instructions;

                     ir_expression *const r4148 = equal(body.constant(2097151u), r4132);
                     ir_expression *const r4149 = equal(body.constant(4294967295u), r4131);
                     body.emit(assign(r4145, logic_and(r4148, r4149), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f4146->else_instructions;

                     body.emit(assign(r4145, body.constant(false), 0x01));


                  body.instructions = f4146_parent_instructions;
                  body.emit(f4146);

                  /* END IF */

                  body.emit(assign(r4142, logic_and(r4145, r413E), 0x01));


               body.instructions = f4143_parent_instructions;
               body.emit(f4143);

               /* END IF */

               /* IF CONDITION */
               ir_if *f414A = new(mem_ctx) ir_if(operand(r4142).val);
               exec_list *const f414A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f414A->then_instructions;

                  ir_variable *const r414B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r414B);
                  ir_expression *const r414C = lshift(r3BBA, body.constant(int(31)));
                  body.emit(assign(r414B, add(r414C, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r414B, body.constant(0u), 0x01));

                  body.emit(assign(r413D, r414B, 0x03));

                  body.emit(assign(r413C, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f414A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r414E = less(r3FDB, body.constant(int(0)));
                  ir_if *f414D = new(mem_ctx) ir_if(operand(r414E).val);
                  exec_list *const f414D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f414D->then_instructions;

                     ir_variable *const r414F = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r414F, r4130, 0x01));

                     ir_variable *const r4150 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r4150, neg(r3FDB), 0x01));

                     ir_variable *const r4151 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r4151);
                     ir_variable *const r4152 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r4152);
                     ir_variable *const r4153 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r4153);
                     ir_variable *const r4154 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r4155 = neg(r4150);
                     body.emit(assign(r4154, bit_and(r4155, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r4157 = equal(r4150, body.constant(int(0)));
                     ir_if *f4156 = new(mem_ctx) ir_if(operand(r4157).val);
                     exec_list *const f4156_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f4156->then_instructions;

                        body.emit(assign(r4151, r4130, 0x01));

                        body.emit(assign(r4152, r4131, 0x01));

                        body.emit(assign(r4153, r4132, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f4156->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r4159 = less(r4150, body.constant(int(32)));
                        ir_if *f4158 = new(mem_ctx) ir_if(operand(r4159).val);
                        exec_list *const f4158_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f4158->then_instructions;

                           body.emit(assign(r4151, lshift(r4131, r4154), 0x01));

                           ir_expression *const r415A = lshift(r4132, r4154);
                           ir_expression *const r415B = rshift(r4131, r4150);
                           body.emit(assign(r4152, bit_or(r415A, r415B), 0x01));

                           body.emit(assign(r4153, rshift(r4132, r4150), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f4158->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r415D = equal(r4150, body.constant(int(32)));
                           ir_if *f415C = new(mem_ctx) ir_if(operand(r415D).val);
                           exec_list *const f415C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f415C->then_instructions;

                              body.emit(assign(r4151, r4131, 0x01));

                              body.emit(assign(r4152, r4132, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f415C->else_instructions;

                              body.emit(assign(r414F, bit_or(r4130, r4131), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r415F = less(r4150, body.constant(int(64)));
                              ir_if *f415E = new(mem_ctx) ir_if(operand(r415F).val);
                              exec_list *const f415E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f415E->then_instructions;

                                 body.emit(assign(r4151, lshift(r4132, r4154), 0x01));

                                 ir_expression *const r4160 = bit_and(r4150, body.constant(int(31)));
                                 body.emit(assign(r4152, rshift(r4132, r4160), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f415E->else_instructions;

                                 ir_variable *const r4161 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r4163 = equal(r4150, body.constant(int(64)));
                                 ir_if *f4162 = new(mem_ctx) ir_if(operand(r4163).val);
                                 exec_list *const f4162_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f4162->then_instructions;

                                    body.emit(assign(r4161, r4132, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f4162->else_instructions;

                                    ir_expression *const r4164 = nequal(r4132, body.constant(0u));
                                    ir_expression *const r4165 = expr(ir_unop_b2i, r4164);
                                    body.emit(assign(r4161, expr(ir_unop_i2u, r4165), 0x01));


                                 body.instructions = f4162_parent_instructions;
                                 body.emit(f4162);

                                 /* END IF */

                                 body.emit(assign(r4151, r4161, 0x01));

                                 body.emit(assign(r4152, body.constant(0u), 0x01));


                              body.instructions = f415E_parent_instructions;
                              body.emit(f415E);

                              /* END IF */


                           body.instructions = f415C_parent_instructions;
                           body.emit(f415C);

                           /* END IF */

                           body.emit(assign(r4153, body.constant(0u), 0x01));


                        body.instructions = f4158_parent_instructions;
                        body.emit(f4158);

                        /* END IF */

                        ir_expression *const r4166 = nequal(r414F, body.constant(0u));
                        ir_expression *const r4167 = expr(ir_unop_b2i, r4166);
                        ir_expression *const r4168 = expr(ir_unop_i2u, r4167);
                        body.emit(assign(r4151, bit_or(r4151, r4168), 0x01));


                     body.instructions = f4156_parent_instructions;
                     body.emit(f4156);

                     /* END IF */

                     body.emit(assign(r4139, r4153, 0x01));

                     body.emit(assign(r413A, r4152, 0x01));

                     body.emit(assign(r413B, r4151, 0x01));

                     body.emit(assign(r4138, body.constant(int(0)), 0x01));

                     body.emit(assign(r413E, less(r4151, body.constant(0u)), 0x01));


                  body.instructions = f414D_parent_instructions;
                  body.emit(f414D);

                  /* END IF */


               body.instructions = f414A_parent_instructions;
               body.emit(f414A);

               /* END IF */


            body.instructions = f4140_parent_instructions;
            body.emit(f4140);

            /* END IF */

            /* IF CONDITION */
            ir_if *f4169 = new(mem_ctx) ir_if(operand(r413C).val);
            exec_list *const f4169_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f4169->then_instructions;

               /* IF CONDITION */
               ir_if *f416A = new(mem_ctx) ir_if(operand(r413E).val);
               exec_list *const f416A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f416A->then_instructions;

                  ir_variable *const r416B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r416B, add(r413A, body.constant(1u)), 0x01));

                  ir_expression *const r416C = less(r416B, r413A);
                  ir_expression *const r416D = expr(ir_unop_b2i, r416C);
                  ir_expression *const r416E = expr(ir_unop_i2u, r416D);
                  body.emit(assign(r4139, add(r4139, r416E), 0x01));

                  ir_expression *const r416F = equal(r413B, body.constant(0u));
                  ir_expression *const r4170 = expr(ir_unop_b2i, r416F);
                  ir_expression *const r4171 = expr(ir_unop_i2u, r4170);
                  ir_expression *const r4172 = add(r413B, r4171);
                  ir_expression *const r4173 = bit_and(r4172, body.constant(1u));
                  ir_expression *const r4174 = expr(ir_unop_bit_not, r4173);
                  body.emit(assign(r413A, bit_and(r416B, r4174), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f416A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r4176 = bit_or(r4139, r413A);
                  ir_expression *const r4177 = equal(r4176, body.constant(0u));
                  ir_if *f4175 = new(mem_ctx) ir_if(operand(r4177).val);
                  exec_list *const f4175_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f4175->then_instructions;

                     body.emit(assign(r4138, body.constant(int(0)), 0x01));


                  body.instructions = f4175_parent_instructions;
                  body.emit(f4175);

                  /* END IF */


               body.instructions = f416A_parent_instructions;
               body.emit(f416A);

               /* END IF */

               ir_variable *const r4178 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r4178);
               ir_expression *const r4179 = lshift(r3BBA, body.constant(int(31)));
               ir_expression *const r417A = expr(ir_unop_i2u, r4138);
               ir_expression *const r417B = lshift(r417A, body.constant(int(20)));
               ir_expression *const r417C = add(r4179, r417B);
               body.emit(assign(r4178, add(r417C, r4139), 0x02));

               body.emit(assign(r4178, r413A, 0x01));

               body.emit(assign(r413D, r4178, 0x03));

               body.emit(assign(r413C, body.constant(false), 0x01));


            body.instructions = f4169_parent_instructions;
            body.emit(f4169);

            /* END IF */

            body.emit(assign(r3FD5, r413D, 0x03));

            body.emit(assign(r3FD4, body.constant(false), 0x01));


         body.instructions = f40E9_parent_instructions;
         body.emit(f40E9);

         /* END IF */


      body.instructions = f40E2_parent_instructions;
      body.emit(f40E2);

      /* END IF */

      body.emit(assign(r3BB9, r3FD5, 0x03));


   body.instructions = f3BBC_parent_instructions;
   body.emit(f3BBC);

   /* END IF */

   ir_variable *const r417D = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r417E = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r417E);
   ir_variable *const r417F = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r417F);
   ir_expression *const r4180 = rshift(swizzle_y(r3BB9), body.constant(int(20)));
   ir_expression *const r4181 = bit_and(r4180, body.constant(2047u));
   ir_expression *const r4182 = expr(ir_unop_u2i, r4181);
   ir_expression *const r4183 = equal(r4182, body.constant(int(2047)));
   ir_expression *const r4184 = bit_and(swizzle_y(r3BB9), body.constant(1048575u));
   ir_expression *const r4185 = bit_or(r4184, swizzle_x(r3BB9));
   ir_expression *const r4186 = nequal(r4185, body.constant(0u));
   body.emit(assign(r417F, logic_and(r4183, r4186), 0x01));

   ir_expression *const r4187 = rshift(swizzle_y(r3248), body.constant(int(20)));
   ir_expression *const r4188 = bit_and(r4187, body.constant(2047u));
   ir_expression *const r4189 = expr(ir_unop_u2i, r4188);
   ir_expression *const r418A = equal(r4189, body.constant(int(2047)));
   ir_expression *const r418B = bit_and(swizzle_y(r3248), body.constant(1048575u));
   ir_expression *const r418C = bit_or(r418B, swizzle_x(r3248));
   ir_expression *const r418D = nequal(r418C, body.constant(0u));
   body.emit(assign(r417E, logic_and(r418A, r418D), 0x01));

   /* IF CONDITION */
   ir_expression *const r418F = logic_or(r417F, r417E);
   ir_if *f418E = new(mem_ctx) ir_if(operand(r418F).val);
   exec_list *const f418E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f418E->then_instructions;

      body.emit(assign(r417D, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f418E->else_instructions;

      ir_expression *const r4190 = equal(swizzle_x(r3BB9), swizzle_x(r3248));
      ir_expression *const r4191 = equal(swizzle_y(r3BB9), swizzle_y(r3248));
      ir_expression *const r4192 = equal(swizzle_x(r3BB9), body.constant(0u));
      ir_expression *const r4193 = bit_or(swizzle_y(r3BB9), swizzle_y(r3248));
      ir_expression *const r4194 = lshift(r4193, body.constant(int(1)));
      ir_expression *const r4195 = equal(r4194, body.constant(0u));
      ir_expression *const r4196 = logic_and(r4192, r4195);
      ir_expression *const r4197 = logic_or(r4191, r4196);
      body.emit(assign(r417D, logic_and(r4190, r4197), 0x01));


   body.instructions = f418E_parent_instructions;
   body.emit(f418E);

   /* END IF */

   ir_variable *const r4198 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_expression *const r419A = expr(ir_unop_logic_not, r417D);
   ir_if *f4199 = new(mem_ctx) ir_if(operand(r419A).val);
   exec_list *const f4199_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f4199->then_instructions;

      body.emit(assign(r4198, r3BB9, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f4199->else_instructions;

      body.emit(assign(r4198, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


   body.instructions = f4199_parent_instructions;
   body.emit(f4199);

   /* END IF */

   body.emit(ret(r4198));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
